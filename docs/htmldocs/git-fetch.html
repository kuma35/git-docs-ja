<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>git-fetch(1)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
git-fetch(1) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>git-fetch -
   別のリポジトリからオブジェクトとrefsをダウンロードします
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fetch</em> [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;&#8230;]]
<em>git fetch</em> [&lt;options&gt;] &lt;group&gt;
<em>git fetch</em> --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)&#8230;]
<em>git fetch</em> --all [&lt;options&gt;]</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>履歴を完成させるために必要なオブジェクトとともに、1つ以上の他のリポジトリからブランチやタグ(総称して「refs」)を取得します。 リモート追跡ブランチが更新されます(この振る舞いを制御する方法については、以下の &lt;refspec&gt; の説明を参照してください)。</p></div>
<div class="paragraph"><p>デフォルトでは、フェッチされている履歴を指すタグもフェッチされます。 その効果は、関心のあるブランチを指すタグをフェッチすることです。 このデフォルトの振る舞いは、 <code>--tags</code> または <code>--no-tags</code> オプションを使用するか、 remote.&lt;name&gt;.tagOpt を構成することで変更できます。 あなたは、タグを明示的にフェッチするrefspecを使用することで、関心のあるブランチを指していないタグもフェッチできます。</p></div>
<div class="paragraph"><p><code>git fetch</code> は、単一の名前付きリポジトリまたはURLから、あるいは、 &lt;group&gt; が指定され、かつ、構成ファイルに remotes.&lt;group&gt; エントリがある場合は、一度に複数のリポジトリからフェッチできます。 (<a href="git-config.html">git-config(1)</a> 参照)。</p></div>
<div class="paragraph"><p>「リモート」が指定されていない場合、現在のブランチ用にアップストリームブランチが構成されていない限り、デフォルトで <code>origin</code> リモートが使用されます。</p></div>
<div class="paragraph"><p>フェッチされたrefの名前は、それらが指すオブジェクト名とともに、 <code>.git/FETCH_HEAD</code> に書き込まれます。 この情報は、スクリプトまたは <a href="git-pull.html">git-pull(1)</a> などの他のgitコマンドで使用される場合があります。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_options">OPTIONS</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--all</code>
</dt>
<dd>
<p>
        すべてのリモートをフェッチします。
</p>
</dd>
<dt class="hdlist1">
<code>-a</code>
</dt>
<dt class="hdlist1">
<code>--append</code>
</dt>
<dd>
<p>
        フェッチされた参照の参照名とオブジェクト名を <code>.git/FETCH_HEAD</code> の既存のコンテンツに追加します。 このオプションがないと、 <code>.git/FETCH_HEAD</code> の古いデータが上書きされます。
</p>
</dd>
<dt class="hdlist1">
<code>--atomic</code>
</dt>
<dd>
<p>
        アトミックトランザクションを使用して、ローカル参照を更新します。 すべての参照が更新されるか、あるいは、エラーが発生してすべての参照が新されないか、のいずれかです。
</p>
</dd>
<dt class="hdlist1">
<code>--depth=&lt;depth&gt;</code>
</dt>
<dd>
<p>
        各リモートブランチ履歴の先端からの指定されたコミット数にフェッチを制限します。 <code>--depth=&lt;depth&gt;</code> オプションを指定して <code>git clone</code> によって作成された浅いリポジトリ(shallow repository)からフェッチする場合(<a href="git-clone.html">git-clone(1)</a> 参照)、指定されたコミット数まで履歴を深くするか浅くするかします。
</p>
</dd>
<dt class="hdlist1">
<code>--deepen=&lt;depth&gt;</code>
</dt>
<dd>
<p>
        <code>--depth</code> に似ていますが、各リモートブランチ履歴の先端からではなく、現在の浅い境界(shallow boundary)からのコミット数を指定する点が異なります。
</p>
</dd>
<dt class="hdlist1">
<code>--shallow-since=&lt;date&gt;</code>
</dt>
<dd>
<p>
        浅い(shallow)リポジトリの履歴を深くしたり浅くしたりして、&lt;date&gt;以降の到達可能なすべてのコミットを含めます。
</p>
</dd>
<dt class="hdlist1">
<code>--shallow-exclude=&lt;revision&gt;</code>
</dt>
<dd>
<p>
        浅いリ(shallow)ポジトリの履歴を深くするか浅くするかして、指定されたリモートブランチまたはタグから到達可能なコミットを除外します。 このオプションは複数回指定できます。
</p>
</dd>
<dt class="hdlist1">
<code>--unshallow</code>
</dt>
<dd>
<p>
        ソースリポジトリが完全な場合は、浅いリ(shallow)ポジトリを完全なリポジトリに変換し、浅い(shallow)リポジトリによって課せられるすべての制限を取り除きます。
</p>
<div class="paragraph"><p>ソースリポジトリが浅い(shallow)場合は、現在のリポジトリがソースリポジトリと同じ履歴を持つように、可能な限りフェッチします。</p></div>
</dd>
<dt class="hdlist1">
<code>--update-shallow</code>
</dt>
<dd>
<p>
        デフォルトでは、浅い(shallow)リポジトリからフェッチする場合、 <code>git fetch</code> は <code>.git/shallow</code> の更新が必要なrefを拒否します。 このオプションは <code>.git/should</code> を更新し、そのようなrefを受け入れます。
</p>
</dd>
<dt class="hdlist1">
<code>--negotiation-tip=&lt;commit|glob&gt;</code>
</dt>
<dd>
<p>
        デフォルトでは、Gitは、受信するパックファイルのサイズを縮小するために、すべてのローカルrefから到達可能なコミットをサーバーに報告して、共通のコミットを見つけます。 指定した場合、Gitは指定された先端から到達可能なコミットのみを報告します。 これは、フェッチされるアップストリームrefと共通のコミットを持つ可能性のあるローカルrefがユーザーにわかっている場合に、フェッチを高速化するのに役立ちます。
</p>
<div class="paragraph"><p>このオプションは複数回指定できます。 その場合、Gitは指定されたコミットのいずれかから到達可能なコミットを報告します。</p></div>
<div class="paragraph"><p>このオプションの引数は、ref名またはrefまたはコミットの(おそらく省略された)SHA-1のグロブである可能性があります。グロブを指定することは、一致するref名ごとに1つずつ、このオプションを複数回指定することと同じです。</p></div>
<div class="paragraph"><p><a href="git-config.html">git-config(1)</a> に記載されている <code>fetch.negotiationAlgorithm</code> と <code>push.negotiate</code> 構成変数、および、以下の <code>--negotiate-only</code> オプションも参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--negotiate-only</code>
</dt>
<dd>
<p>
        サーバーから何もフェッチせず、代わりに、サーバーと共通している、提供された <code>--negotiation-tip=*</code> 引数の祖先を出力します。
</p>
<div class="paragraph"><p>これは <code>--recurse-submodules=[yes|on-demand]</code> と互換性がありません。 内部的には、これは <code>push.negotiate</code> オプションを実装するために使用されます。 <a href="git-config.html">git-config(1)</a> を参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--dry-run</code>
</dt>
<dd>
<p>
        変更を加えずに、何が行われるかを示します。
</p>
</dd>
<dt class="hdlist1">
<code>--porcelain</code>
</dt>
<dd>
<p>
        スクリプトがパースしやすい形式で標準出力に出力します。 詳細については、<a href="git-fetch.html">git-fetch(1)</a> のセクション OUTPUT を参照してください。
</p>
<div class="paragraph"><p>これは <code>--recurse-submodules=[yes|on-demand]</code> とは互換性がなく、 かつ、 <code>fetch.output</code> 設定オプションよりも優先されます。</p></div>
</dd>
<dt class="hdlist1">
<code>--[no-]write-fetch-head</code>
</dt>
<dd>
<p>
        <code>$GIT_DIR</code> のすぐ下の <code>FETCH_HEAD</code> ファイルにフェッチされたリモートrefのリストを書き込みます。 これがデフォルトです。 コマンドラインから <code>--no-write-fetch-head</code> を渡すと、Gitにファイルを書き込まないように指示します。 <code>--dry-run</code> オプションでは、ファイルが書き込まれることはありません。
</p>
</dd>
<dt class="hdlist1">
<code>-f</code>
</dt>
<dt class="hdlist1">
<code>--force</code>
</dt>
<dd>
<p>
        <code>git fetch</code> を <code>&lt;src&gt;:&lt;dst&gt;</code> refspecと一緒に使用すると、既に説明したようにローカルブランチの更新を拒否する場合があります
        以下の <code>&lt;refspec&gt;</code> の部分にあります。
        このオプションは、そのチェックをオーバーライドします。
</p>
</dd>
<dt class="hdlist1">
<code>-k</code>
</dt>
<dt class="hdlist1">
<code>--keep</code>
</dt>
<dd>
<p>
        ダウンロードしたパックを保持してください。
</p>
</dd>
<dt class="hdlist1">
<code>--multiple</code>
</dt>
<dd>
<p>
        複数の&lt;repository&gt;および&lt;group&gt;引数を指定できるようにします。 &lt;refspec&gt;を指定することはできません。
</p>
</dd>
<dt class="hdlist1">
<code>--[no-]auto-maintenance</code>
</dt>
<dt class="hdlist1">
<code>--[no-]auto-gc</code>
</dt>
<dd>
<p>
        最後に <code>git maintenance run --auto</code> を実行して、必要に応じて自動リポジトリメンテナンスを実行します。 (<code>--[no-]auto-gc</code> は同義語です。) これはデフォルトで有効になっています。
</p>
</dd>
<dt class="hdlist1">
<code>--[no-]write-commit-graph</code>
</dt>
<dd>
<p>
        フェッチ後にコミットグラフ(commit-graph)を記述します。 これは、構成設定 <code>fetch.writeCommitGraph</code> をオーバーライドします。
</p>
</dd>
<dt class="hdlist1">
<code>--prefetch</code>
</dt>
<dd>
<p>
        構成されたrefspecを変更して、すべてのrefを <code>refs/prefetch/</code> 名前空間に配置します。 <a href="git-maintenance.html">git-maintenance(1)</a>の <code>prefetch</code> タスクを参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>-p</code>
</dt>
<dt class="hdlist1">
<code>--prune</code>
</dt>
<dd>
<p>
        フェッチする前に、リモートに存在しなくなったリモート追跡参照を削除します。 タグは、デフォルトのタグの自動追跡または <code>--tags</code> オプションのためにのみフェッチされた場合(コマンドラインまたはリモート構成のいずれかで、たとえば、リモートが <code>--mirror</code> オプションでcloneされた場合)、刈り込み(pruning)の対象にはなりません。 ただし、明示的なrefspecが原因でタグがフェッチされた場合、それらも刈り込み(pruning)の対象になります。 <code>--prune-tags</code> を指定することは、タグrefspecを提供するための省略形です。
</p>
<div class="paragraph"><p>詳細については、下記の「PRUNING」セクションを参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-P</code>
</dt>
<dt class="hdlist1">
<code>--prune-tags</code>
</dt>
<dd>
<p>
        <code>--prune</code> が有効になっている場合は、フェッチする前に、リモートに存在しなくなったローカルタグをすべて削除します。 このオプションは、 <code>--prune</code> とは異なり、より慎重に使用する必要があります。作成されたローカル参照(ローカルタグ)はすべて削除されます。 このオプションは、明示的なタグrefspecを <code>--prune</code> とともに提供するための省略形です。これについては、そのドキュメントの説明を参照してください。
</p>
<div class="paragraph"><p>詳細については、下記の「PRUNING」セクションを参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-n</code>
</dt>
<dt class="hdlist1">
<code>--no-tags</code>
</dt>
<dd>
<p>
        デフォルトでは、リモートリポジトリからダウンロードされたオブジェクトを指すタグがフェッチされ、ローカルに保存されます。このオプションは、この自動タグ追跡を無効にします。 リモートのデフォルトの動作は、 <code>remote.&lt;name&gt;.tagOpt</code> 設定で指定できます。 <a href="git-config.html">git-config(1)</a> を参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--refetch</code>
</dt>
<dd>
<p>
        すでにローカルに存在するコミットとその関連オブジェクトの転送を避けるためにサーバーと交渉(negotiate)する代わりに、 このオプションは新しいクローン(fresh clone)のようにすべてのオブジェクトをフェッチします。 これを使用して、構成から部分(partial)クローン・フィルターを再適用するか、または、フィルター定義が変更されたときに <code>--filter=</code> を使用します。 フェッチ後の自動メンテナンスにより、オブジェクト・データベース・パックの統合が実行され、重複オブジェクトが削除されます。
</p>
</dd>
<dt class="hdlist1">
<code>--refmap=&lt;refspec&gt;</code>
</dt>
<dd>
<p>
        コマンドラインにリストされているrefをフェッチするときは、リモートリポジトリの <code>remote.*.fetch</code> 構成変数の値の代わりに、指定されたrefspec(複数回指定可能)を使用してrefをリモート追跡ブランチにマップします。 空の <code>&lt;refspec&gt;</code> を <code>--refmap</code> オプションに指定すると、Gitは構成されたrefspecsを無視し、コマンドライン引数として提供されたrefspecsに完全に依存します。 詳細については、「Configured Remote-tracking Branches」のセクションを参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>-t</code>
</dt>
<dt class="hdlist1">
<code>--tags</code>
</dt>
<dd>
<p>
        他の方法でフェッチされるものに加えて、リモートからすべてのタグをフェッチします(つまり、リモートタグ <code>refs/tags/*</code> を同じ名前のローカルタグにフェッチします)。 このオプションを単独で使用しても、 <code>--prune</code> が使用されている場合でも、タグは刈り込み(pruning)の対象にはなりません(ただし、タグが明示的なrefspecの宛先でもある場合は、タグは刈り込み(pruning)される可能性があります。 <code>--prune</code> を参照してください)。
</p>
</dd>
<dt class="hdlist1">
<code>--recurse-submodules[=yes|on-demand|no]</code>
</dt>
<dd>
<p>
        このオプションは、サブモジュールの新しいコミットも取得する必要があるかどうか、およびどのような条件で取得するかを制御します。 サブモジュールを再帰するとき、 <code>git fetch</code> は常に「変更された」サブモジュール、つまり、新しく取得(fetch)されたスーパープロジェクト・コミットによって参照されるが、ローカル・サブモジュール・クローンにないコミットを持つサブモジュールを取得(fetch)しようとします。 変更されたサブモジュールは、ローカル、たとえば <code>$GIT_DIR/modules/</code> 内に存在する限り取得(fetch)できます(<a href="gitsubmodules.html">gitsubmodules(7)</a> を参照)。 アップストリームが新しいサブモジュールを追加した場合、そのサブモジュールはクローン、たとえば <code>git submodule update</code> されるまで取得(fetch)できません。
</p>
<div class="paragraph"><p><code>on-demand</code> に設定すると、 変更されたサブモジュールのみがフェッチされます。 <code>yes</code> に設定すると、すべての入力済みサブモジュールと、未入力かつ変更されたサブモジュールが、フェッチされます。 <code>no</code> に設定すると、サブモジュールはフェッチされません。</p></div>
<div class="paragraph"><p>指定されていない場合、 <code>fetch.recurseSubmodules</code> が設定されている場合は <code>fetch.recurseSubmodules</code> の値が使用され(<a href="git-config.html">git-config(1)</a> 参照)、 <code>fetch.recurseSubmodules</code> も設定されていない場合はデフォルトで <code>on-demand</code> になります。 このオプションを値なしで使用すると、デフォルトで <code>yes</code> になります。</p></div>
</dd>
<dt class="hdlist1">
<code>-j</code>
</dt>
<dt class="hdlist1">
<code>--jobs=&lt;n&gt;</code>
</dt>
<dd>
<p>
        すべての形式のフェッチに使用されるparallel childrenの数。
</p>
<div class="paragraph"><p><code>--multiple</code> オプションが指定された場合、異なるリモートが並行してフェッチされます。 複数のサブモジュールがフェッチされる場合、それらは並行してフェッチされます。 それらを個別に制御するには、構成設定 <code>fetch.parallel</code> と <code>submodule.fetchJobs</code> を使用します(<a href="git-config.html">git-config(1)</a> 参照)。</p></div>
<div class="paragraph"><p>通常、並列再帰フェッチとマルチリモートフェッチの方が高速です。デフォルトでは、フェッチは並列ではなく順次実行されます。</p></div>
</dd>
<dt class="hdlist1">
<code>--no-recurse-submodules</code>
</dt>
<dd>
<p>
        サブモジュールの再帰的フェッチを無効にします(これは、 <code>--recurse-submodules=no</code> オプションを使用するのと同一の効果があります)。
</p>
</dd>
<dt class="hdlist1">
<code>--set-upstream</code>
</dt>
<dd>
<p>
        リモートが正常にフェッチされた場合は、引数のない <a href="git-pull.html">git-pull(1)</a> およびその他のコマンドで使用されるアップストリーム(追跡)参照を追加します。 詳細については、 <a href="git-config.html">git-config(1)</a> の <code>branch.&lt;name&gt;.merge</code> および <code>branch.&lt;name&gt;.remote</code> を参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--submodule-prefix=&lt;path&gt;</code>
</dt>
<dd>
<p>
        「Fetching submodule foo」などの情報メッセージに出力されるパスの前に&lt;path&gt;を付けます。このオプションは、サブモジュールを再帰的に実行するときに内部的に使用されます。
</p>
</dd>
<dt class="hdlist1">
<code>--recurse-submodules-default=[yes|on-demand]</code>
</dt>
<dd>
<p>
        このオプションは、 <code>--recurse-submodules</code> オプションに負でないデフォルト値を一時的に提供するために内部的に使用されます。 フェッチのサブモジュール再帰を構成する他のすべての方法(<a href="gitmodules.html">gitmodules(5)</a> や <a href="git-config.html">git-config(1)</a> の設定など) は、 <code>--[no-]recurse-submodules</code> を直接指定する場合と同様に、このオプションをオーバーライドします。
</p>
</dd>
<dt class="hdlist1">
<code>-u</code>
</dt>
<dt class="hdlist1">
<code>--update-head-ok</code>
</dt>
<dd>
<p>
        デフォルトでは、 <code>git fetch</code> は現在のブランチに対応するヘッドの更新を拒否します。 このフラグはそのチェックを無効にします。 これは純粋に <code>git pull</code> が <code>git fetch</code> と通信するための内部使用のためであり、あなたが独自の磁器コマンドを実装していない限り、あなたがそれを使用することは想定されていません。
</p>
</dd>
<dt class="hdlist1">
<code>--upload-pack &lt;upload-pack&gt;</code>
</dt>
<dd>
<p>
        指定され、フェッチ元のリポジトリが <code>git fetch-pack</code> によって処理されると、 <code>--exec=&lt;upload-pack&gt;</code> がコマンドに渡され、もう一方の端で実行されるコマンドのデフォルト以外のパスが指定されます。
</p>
</dd>
<dt class="hdlist1">
<code>-q</code>
</dt>
<dt class="hdlist1">
<code>--quiet</code>
</dt>
<dd>
<p>
        <code>--quiet</code> を <code>git-fetch-pack</code> に渡し、内部で使用される他のgitコマンドをすべて静粛にさせます。 進行状況は標準エラーストリームに報告されません。
</p>
</dd>
<dt class="hdlist1">
<code>-v</code>
</dt>
<dt class="hdlist1">
<code>--verbose</code>
</dt>
<dd>
<p>
        おしゃべりにします。
</p>
</dd>
<dt class="hdlist1">
<code>--progress</code>
</dt>
<dd>
<p>
        <code>-q</code> が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。
</p>
</dd>
<dt class="hdlist1">
<code>-o &lt;option&gt;</code>
</dt>
<dt class="hdlist1">
<code>--server-option=&lt;option&gt;</code>
</dt>
<dd>
<p>
        プロトコルバージョン2を使用して通信する場合は、指定された文字列をサーバーに送信します。 指定された文字列には、NUL文字またはLF文字を含めることはできません。 不明なオプションを含むサーバーオプションのサーバー処理は、サーバー固有です。 複数の <code>--server-option=&lt;option&gt;</code> が指定されている場合、それらはすべてコマンドラインにリストされている順序で相手側に送信されます。
</p>
</dd>
<dt class="hdlist1">
<code>--show-forced-updates</code>
</dt>
<dd>
<p>
        デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 これは <code>fetch.showForcedUpdates</code> を介して無効にすることができますが、 <code>--show-forced-updates</code> オプションはこのチェックが行われることを保証します。 <a href="git-config.html">git-config(1)</a> を参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--no-show-forced-updates</code>
</dt>
<dd>
<p>
        デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 <code>--no-show-forced-updates</code> を渡すか、 <code>fetch.showForcedUpdates</code> を <code>false</code> に設定して、パフォーマンス上の理由からこのチェックをスキップします。 <code>git-pull</code> 処理中に使用された場合、 <code>--ff-only</code> オプションは、早送り(fast-forward)更新を試行する前に、強制更新をチェックします。 <a href="git-config.html">git-config(1)</a> を参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>-4</code>
</dt>
<dt class="hdlist1">
<code>--ipv4</code>
</dt>
<dd>
<p>
        IPv6アドレスを無視して、IPv4アドレスのみを使用します。
</p>
</dd>
<dt class="hdlist1">
<code>-6</code>
</dt>
<dt class="hdlist1">
<code>--ipv6</code>
</dt>
<dd>
<p>
        IPv4アドレスを無視して、IPv6アドレスのみを使用します。
</p>
</dd>
<dt class="hdlist1">
&lt;repository&gt;
</dt>
<dd>
<p>
        フェッチまたはプル操作のソースである「リモート」リポジトリ。このパラメーターは、URL(以下の <a href="#URLS">GIT URLS</a> セクションを参照)またはリモートの名前(以下の <a href="#REMOTES">REMOTES</a> セクションを参照)のいずれかです。
</p>
</dd>
<dt class="hdlist1">
&lt;group&gt;
</dt>
<dd>
<p>
        構成ファイル内のリモート。 &lt;group&gt; の値としてリポジトリーのリストを参照する名前。(<a href="git-config.html">git-config(1)</a> を参照)。
</p>
</dd>
<dt class="hdlist1">
&lt;refspec&gt;
</dt>
<dd>
<p>
        フェッチするrefと更新するローカルrefを指定します。コマンドラインに &lt;refspec&gt; がない場合、フェッチするrefは代わりに <code>remote.&lt;repository&gt;.fetch</code> 変数から読み取られます。
        (下記 <a href="#CRTB">CONFIGURED REMOTE-TRACKING BRANCHES</a> 参照)
</p>
<div class="paragraph"><p>&lt;refspec&gt; パラメータの組織は、オプションのプラス <code>+</code> に続いて ソースの &lt;src&gt; 、コロン <code>:</code> 宛先refの &lt;dst&gt; の順です。 &lt;dst&gt; が空の場合、コロン(<code>:</code>)は省略できます。 &lt;src&gt; は通常、refですが、フルスペルの16進オブジェクト名にすることもできます。</p></div>
<div class="paragraph"><p>&lt;refspec&gt; の &lt;src&gt; には、単純なパターン一致を示すための <code>*</code> が含まれている場合があります。このようなrefspecは、同じプレフィックスを持つ任意のrefに一致するglobのように機能します。パターン&lt;refspec&gt;では、 &lt;src&gt; と &lt;dst&gt; の両方に <code>*</code> が含まれている必要があります。 <code>*</code> をソースから一致したコンテンツに置き換えることにより、refを宛先にマッピングします。</p></div>
<div class="paragraph"><p>refspecの前に <code>^</code> が付いている場合、それはネガティブのrefspecとして解釈されます。このようなrefspecは、フェッチするrefや更新するローカルrefを指定するのではなく、除外するrefを指定します。 refは、少なくとも1つのポジティブ(通常)のrefspecと一致し、ネガティブのrefspecと一致しない場合、一致すると見なされます。ネガティブのrefspecは、特定のrefが含まれないように、パターンrefspecのスコープを制限するのに役立ちます。ネガティブのrefspecは、それ自体がパターンrefspecである可能性があります。 ただし、 &lt;src&gt; のみを含めることができ、 &lt;dst&gt; を指定することはできません。 フルスペルの16進オブジェクト名もサポートされていません。</p></div>
<div class="paragraph"><p><code>tag &lt;tag&gt;</code> は、 <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code> と同じ意味です。指定されたタグまでのすべてをフェッチするように要求します。</p></div>
<div class="paragraph"><p>&lt;src&gt; に一致するリモートrefがフェッチされ、 &lt;dst&gt; が空の文字列でない場合は、それに一致するローカルrefを更新しようとします。</p></div>
<div class="paragraph"><p>その更新が <code>--force</code> なしで許可されるかどうかは、フェッチ先のref名前空間、フェッチされるオブジェクトのタイプ、および更新がfast-forwardであると見なされるかどうかによって異なります。一般に、プッシュする場合と同じルールがフェッチに適用されます。それらが何であるかについては、 <a href="git-push.html">git-push(1)</a>の <code>&lt;refspec&gt;...</code> セクションを参照してください。 <em>git fetch</em> に固有の例外ルールを以下に示します。</p></div>
<div class="paragraph"><p>Gitバージョン2.20までは、 <a href="git-push.html">git-push(1)</a> でプッシュする場合とは異なり、 <code>refs/tags/*</code> の更新は、 refspec に <code>+</code> がなくても(または <code>--force</code> 指定が無くても)受け入れられます。フェッチするとき、リモートからのすべてのタグ更新を強制フェッチとしていました。Gitバージョン2.20以降では、 <code>refs/tags/*</code> を更新するためのフェッチは、プッシュする場合と同じように機能します。 つまり refspecに <code>+</code> が無い場合(または <code>--force</code> が無い場合)、更新は拒否されます。</p></div>
<div class="paragraph"><p><a href="git-push.html">git-push(1)</a> でプッシュするときとは異なり、 <code>refs/{tags,heads}/*</code> 以外の更新は、 refspecに <code>+</code> がなくても(あるいは <code>--force</code> 指定が無くても)受け付けられます。例えば、ツリーオブジェクトとブロブを交換したり、あるコミットを、祖先を持たない別のコミットと交換したりできます。</p></div>
<div class="paragraph"><p><a href="git-push.html">git-push(1)</a> でプッシュする場合とは異なり、これらのルールを修正する構成はなく、 <code>pre-receive</code> フックに類似した <code>pre-fetch</code> フックのようなものはありません。</p></div>
<div class="paragraph"><p><a href="git-push.html">git-push(1)</a> を使用したプッシュと同様に、更新として許可されないものに関する上記のすべてのルールは、refspec先頭にオプションで <code>+</code> をに追加する(または <code>--force</code> コマンドラインオプションを使用する)ことでオーバーライドできます。これに対する唯一の例外は、 <code>refs/heads/*</code> 名前空間が非コミットオブジェクトを受け入れるように強制することはないということです。</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">フェッチするリモートブランチが定期的に巻き戻されてリベースされることがわかっている場合、その新しい先端は(最後にフェッチしたときにリモートトラッキングブランチに保存された)以前の先端の子孫ではないことが予想されます。あなたは <code>+</code> 記号を使用して、そのようなブランチにnon-fast-forwardの更新が必要であることを指示します。この操作でブランチがリポジトリで使用可能になることを決定または宣言する方法はありません。プルするユーザーは、これがブランチの予想される使用パターンであることを知っている必要があります。</td>
</tr></table>
</div>
</dd>
<dt class="hdlist1">
<code>--stdin</code>
</dt>
<dd>
<p>
        引数として提供されているものに加えて、標準入力からrefspecsを1行に1つずつ読み取ります。 「tag &lt;name&gt;」形式はサポートされていません。
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_git_urls_a_id_urls_a">GIT URLS<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph"><p>一般に、URLには、トランスポートプロトコル、リモートサーバーのアドレス、およびリポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、一部の情報が欠落している場合があります。</p></div>
<div class="paragraph"><p>Gitはsshとgitとhttpとhttpsプロトコルをサポートします(さらにftpとftpsをフェッチに使用できますが、これは非効率的で非推奨です。使用しないでください)。</p></div>
<div class="paragraph"><p>ネイティブトランスポート(つまり、 git:// URL)は認証を行わないため、セキュリティで保護されていないネットワークでは注意して使用する必要があります。</p></div>
<div class="paragraph"><p>以下の構文を使用できます:</p></div>
<div class="ulist"><ul>
<li>
<p>
ssh://&#91;user@&#93;host.xz&#91;:port&#93;/path/to/repo.git/
</p>
</li>
<li>
<p>
git://host.xz&#91;:port&#93;/path/to/repo.git/
</p>
</li>
<li>
<p>
http&#91;s&#93;://host.xz&#91;:port&#93;/path/to/repo.git/
</p>
</li>
<li>
<p>
ftp&#91;s&#93;://host.xz&#91;:port&#93;/path/to/repo.git/
</p>
</li>
</ul></div>
<div class="paragraph"><p>代替のscpのような構文をsshプロトコルで使用することもできます:</p></div>
<div class="ulist"><ul>
<li>
<p>
&#91;user@&#93;host.xz:path/to/repo.git/
</p>
</li>
</ul></div>
<div class="paragraph"><p>この構文は、最初のコロン(:)の前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス <code>foo:bar</code> を、絶対パスまたは <code>./foo:bar</code> として指定して、 ssh url として誤って解釈されないようにすることができます。</p></div>
<div class="paragraph"><p>sshおよびgitプロトコルは、さらに ~username 拡張をサポートします:</p></div>
<div class="ulist"><ul>
<li>
<p>
ssh://&#91;user@&#93;host.xz&#91;:port&#93;/~&#91;user&#93;/path/to/repo.git/
</p>
</li>
<li>
<p>
git://host.xz&#91;:port&#93;/~&#91;user&#93;/path/to/repo.git/
</p>
</li>
<li>
<p>
&#91;user@&#93;host.xz:/~&#91;user&#93;/path/to/repo.git/
</p>
</li>
</ul></div>
<div class="paragraph"><p>Gitでもネイティブにサポートされているローカルリポジトリの場合、以下の構文を使用できます:</p></div>
<div class="ulist"><ul>
<li>
<p>
/path/to/repo.git/
</p>
</li>
<li>
<p>
file:///path/to/repo.git/
</p>
</li>
</ul></div>
<div class="paragraph"><p>これらの2つの構文は、前者が <code>--local</code> オプションの機能を含むクローン作成の場合を除いて、ほとんど同等です。 詳細については、 <a href="git-clone.html">git-clone(1)</a> を参照してください。</p></div>
<div class="paragraph"><p>「git clone」と「git fetch」と「git pull」は、「git push」と違って適切なバンドルファイルを受け入れます。 <a href="git-bundle.html">git-bundle(1)</a> を参照してください。</p></div>
<div class="paragraph"><p>Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、Gitは <em>remote-&lt;transport&gt;</em> リモートヘルパー(存在する場合)を使用しようとします。リモートヘルパーを明示的に要求するには、以下の構文を使用できます:</p></div>
<div class="ulist"><ul>
<li>
<p>
&lt;transport&gt;::&lt;address&gt;
</p>
</li>
</ul></div>
<div class="paragraph"><p>ここで、 &lt;address&gt; は、パス、サーバーとパス、または呼び出されている特定のリモートヘルパーによって認識される任意のURLのような文字列です。詳細については、 <a href="gitremote-helpers.html">gitremote-helpers(7)</a> を参照してください。</p></div>
<div class="paragraph"><p>同じ名前のリモートリポジトリが多数あり、それらに異なる形式を使用する場合(あなたの使用するURLが機能するURLに書き換えられるように)、以下の形式の構成セクションを作成できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        [url "&lt;actual url base&gt;"]
                insteadOf = &lt;other url base&gt;</code></pre>
</div></div>
<div class="paragraph"><p>例えば、以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:</code></pre>
</div></div>
<div class="paragraph"><p>"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、任意のコンテキストで、"git://git.host.xz/repo.git" に書き換えられます。</p></div>
<div class="paragraph"><p>プッシュ専用のURLを書き換えたい場合は、以下の形式の構成セクションを作成できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        [url "&lt;actual url base&gt;"]
                pushInsteadOf = &lt;other url base&gt;</code></pre>
</div></div>
<div class="paragraph"><p>例えば、以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/</code></pre>
</div></div>
<div class="paragraph"><p>"git://example.org/path/to/repo.git" のようなURLは、プッシュの場合は "ssh://example.org/path/to/repo.git" に書き換えられますが、プルは引き続き元のURLのままです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_remotes_a_id_remotes_a">REMOTES<a id="REMOTES"></a></h2>
<div class="sectionbody">
<div class="paragraph"><p><code>&lt;repository&gt;</code> 引数として、URLの代わりに以下のいずれかの名前を使用できます:</p></div>
<div class="ulist"><ul>
<li>
<p>
Git構成ファイル(configuration file)内のリモート(remote)として、 <code>$GIT_DIR/config</code> または
</p>
</li>
<li>
<p>
<code>$GIT_DIR/remotes</code> ディレクトリ内のファイル または
</p>
</li>
<li>
<p>
<code>$GIT_DIR/branches</code> ディレクトリ内のファイル
</p>
</li>
</ul></div>
<div class="paragraph"><p>これらはすべて、gitがデフォルトで使用するrefspecをそれぞれ含んでいるため、コマンドラインからrefspecを省略できます。</p></div>
<div class="sect2">
<h3 id="_named_remote_in_configuration_file">Named remote in configuration file</h3>
<div class="paragraph"><p>あなたは、 <a href="git-remote.html">git-remote(1)</a> を使うか、または <a href="git-config.html">git-config(1)</a> を使うか、または <code>$GIT_DIR/config</code> ファイルを手動で編集して、これ以前に構成したリモートの名前から選択できます。このリモートのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このリモートのrefspecがデフォルトで使用されます。構成ファイルのエントリは以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        [remote "&lt;name&gt;"]
                url = &lt;URL&gt;
                pushurl = &lt;pushurl&gt;
                push = &lt;refspec&gt;
                fetch = &lt;refspec&gt;</code></pre>
</div></div>
<div class="paragraph"><p><code>&lt;pushurl&gt;</code> はプッシュでのみ使用されます。 これはオプションであり、 デフォルトは <code>&lt;URL&gt;</code> です。 リモートへのプッシュは、 定義されているすべての pushurl に影響します。 pushurl が定義されていない場合は、 すべての定義された url に影響します。 ただし、 複数の url が定義されている場合、 Fetch は最初に定義された url からのみ取得します。</p></div>
</div>
<div class="sect2">
<h3 id="_named_file_in_code_git_dir_remotes_code">Named file in <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph"><p>あなたは、 <code>$GIT_DIR/remotes</code> でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このファイルのrefspecがデフォルトとして使用されます。このファイルの形式は以下のとおりです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        URL: one of the above URL format
        Push: &lt;refspec&gt;
        Pull: &lt;refspec&gt;</code></pre>
</div></div>
<div class="paragraph"><p><code>Push:</code> 行は <code>git push</code> で使用され、 <code>Pull:</code> 行は <code>git pull</code> と <code>git fetch</code> で使用されます。追加のブランチマッピングのために、複数の <code>Push:</code> および <code>Pull:</code> 行を指定できます。</p></div>
</div>
<div class="sect2">
<h3 id="_named_file_in_code_git_dir_branches_code">Named file in <code>$GIT_DIR/branches</code></h3>
<div class="paragraph"><p><code>$GIT_DIR/branches</code> でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。 このファイルの形式は以下のとおりです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        &lt;URL&gt;#&lt;head&gt;</code></pre>
</div></div>
<div class="paragraph"><p><code>&lt;URL&gt;</code> は必須です。 <code>#&lt;head&gt;</code> はオプションです。</p></div>
<div class="paragraph"><p>コマンドラインで指定しない場合、操作に応じて、gitは以下のrefspecのいずれかを使用します。 <code>&lt;branch&gt;</code> は <code>$GIT_DIR/branchs</code> 内のこのファイルの名前であり、 <code>&lt;head&gt;`はデフォルトで `master</code> になります。</p></div>
<div class="paragraph"><p>git fetch は以下を使用します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</code></pre>
</div></div>
<div class="paragraph"><p>git push は以下を使用します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        HEAD:refs/heads/&lt;head&gt;</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configured_remote_tracking_branches_a_id_crtb_a">CONFIGURED REMOTE-TRACKING BRANCHES<a id="CRTB"></a></h2>
<div class="sectionbody">
<div class="paragraph"><p>あなたは、定期的かつ繰り返しフェッチすることで、同じリモートリポジトリとやり取りすることがよくあります。 このようなリモートリポジトリの進行状況を追跡するために、 <code>git fetch</code> では <code>remote.&lt;repository&gt;.fetch</code> 構成変数を構成できます。</p></div>
<div class="paragraph"><p>通常、このような変数は以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>[remote "origin"]
        fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>
</div></div>
<div class="paragraph"><p>この構成は、以下の2つの方法で使用されます:</p></div>
<div class="ulist"><ul>
<li>
<p>
コマンドラインで取得するブランチやタグを指定せずに <code>git fetch</code> を実行した場合、例えば <code>git fetch origin</code> や <code>git fetch</code> では <code>remote.&lt;repository&gt;.fetch</code> の値が refspecs として使用され、取得する ref と更新するローカル ref を指定します。 上記の例では、<code>origin</code> に存在するすべてのブランチ(つまり、値の左辺 <code>refs/heads/*</code> にマッチするすべての ref)を取得し、対応するリモート追跡ブランチを <code>refs/remotes/origin/*</code> 階層にあるものに更新します。
</p>
</li>
<li>
<p>
フェッチするブランチやタグをコマンドラインで明示的に指定して、 <code>git fetch</code> を実行した場合、 たとえば <code>git fetch origin master</code> すると、コマンドラインで指定された&lt;refspec&gt;が何をフェッチするかを決定し(たとえば、この例の <code>master`は、 `master:</code> の省略形で、 「 <code>master' ブランチを取得しますが、どのリモート追跡ブランチを更新するかはコマンドラインから明示的に指示しません」を意味します)、サンプルコマンドは「 'master' ブランチのみ」をフェッチします。 `remote.&lt;repository&gt;.fetch</code> 値は、更新されるリモート追跡ブランチがある場合はそれを決定します。 このような使い方をすると、 <code>remote.&lt;repository&gt;.fetch</code> 値は、「何をフェッチするか」を決定するのに効果がありません(つまり、コマンドラインにrefspecsがリストされている場合、 <code>remote.&lt;repository&gt;.fetch</code> 値はrefspecsとして使用されません)。 これらは、マッピングとして機能することにより、フェッチされたrefがどこに保存されるかを決定するためにのみ使用されます。
</p>
</li>
</ul></div>
<div class="paragraph"><p>後者の <code>remote.&lt;repository&gt;.fetch</code> 値の使用は、コマンドラインで <code>--refmap=&lt;refspec&gt;</code> パラメーターを指定することでオーバーライドできます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pruning">PRUNING</h2>
<div class="sectionbody">
<div class="paragraph"><p>Gitには、明示的に破棄されない限り、データを保持するというデフォルトの性質があります。 これは、ブランチを削除したリモートのブランチへのローカル参照を保持することにまで及びます。</p></div>
<div class="paragraph"><p>蓄積したままにしておくと、これらの古い参照は、ブランチの撹拌が多い大きく忙しいリポジトリでパフォーマンスを低下させる可能性があります。 <code>git branch -a --contains &lt;commit&gt;</code> のようなコマンドの出力を不必要に冗長にし、既知の参照の完全なセットで機能する他のすべてに影響を与えます。</p></div>
<div class="paragraph"><p>これらのリモート追跡参照は、1回限りの利用で、以下のいずれかを使用して削除できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># While fetching
$ git fetch --prune &lt;name&gt;

# Only prune, don't fetch
$ git remote prune &lt;name&gt;</code></pre>
</div></div>
<div class="paragraph"><p>あなたの通常の作業フローの一部として参照を刈り込むには、それを実行することを覚えておく必要はありません。設定で <code>fetch.prune</code> をグローバルに設定するか、 <code>remote.&lt;name&gt;.prune</code> をリモート毎に設定します。 <a href="git-config.html">git-config(1)</a> を参照してください。</p></div>
<div class="paragraph"><p>ここで、物事がトリッキーでより具体的になります。 刈り込み機能は実際にはブランチを気にせず、代わりにリモートのrefspecの関数として <code>local &lt;--&gt; remote-references</code> を刈り込みます( <code>&lt;refspec&gt;</code> および 上記 <a href="#CRTB">CONFIGURED REMOTE-TRACKING BRANCHES</a> 参照)。</p></div>
<div class="paragraph"><p>したがって、リモートの refspec に、 たとえば <code>refs/tags/*:refs/tags/*</code> が含まれていたり、 手動でたとえば <code>git fetch --prune &lt;name&gt; "refs/tags/*:refs/tags/*"</code> を実行したりすると、削除されるのは古いリモート追跡ブランチではなく、リモートには存在しないローカルタグが削除されます。</p></div>
<div class="paragraph"><p>これはあなたが期待したものではない可能性があります。つまり、リモート <code>&lt;name&gt;</code> を刈り込むだけでなく、そこからタグを明示的にフェッチするため、そこからフェッチするときに、すべてのローカルタグを削除します。 そのほとんどは、そもそも <code>&lt;name&gt;</code> リモートからのものではない可能性があります。</p></div>
<div class="paragraph"><p>したがって、これを <code>refs/tags/*:refs/tags/*</code> のようなrefspec、または複数のリモートからの参照を同じローカル名前空間にマップする可能性のある他のrefspecで使用する場合は注意してください。</p></div>
<div class="paragraph"><p>リモートのブランチとタグの両方を最新に保つことはよくあることなので、 <code>--prune</code> と一緒に <code>--prune-tags</code> オプションを指定することで、リモートに存在しないローカルタグを削除し、異なるタグを強制更新することができます。 タグの刈り込みは、設定ファイルの <code>fetch.pruneTags</code> や <code>remote.&lt;name&gt;.pruneTags</code> で有効にすることもできます。 <a href="git-config.html">git-config(1)</a> を参照してください。</p></div>
<div class="paragraph"><p><code>--prune-tags</code> オプションは、「リモート」のrefspecsで <code>refs/tags/*:refs/tags/*</code> を宣言するのと同じです。 これは、一見奇妙な相互作用につながる可能性があります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># These both fetch tags
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin</code></pre>
</div></div>
<div class="paragraph"><p><code>--prune</code> またはその構成変数版なしで提供されたときにエラーにならない理由は、構成変数版の柔軟性と、コマンドラインフラグの機能と構成変数版の機能の間の 一対一 のマッピングを維持するためです。</p></div>
<div class="paragraph"><p>たとえば、 <code>~/.gitconfig</code> で <code>fetch.pruneTags=true</code> を構成して、 <code>--prune</code> なしで <code>git fetch</code> を呼び出すたびにエラーが発生することなく、 <code>git fetch --prune</code> が実行されるたびにタグが刈り込まれるようにします。</p></div>
<div class="paragraph"><p><code>--prune-tags</code> によるタグの刈り込みは、名前付きリモートの代わりに URL を取得するときにも機能します。 これらはすべて、origin で見つからなかったタグを刈り込みます。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch &lt;url of origin&gt; --prune --prune-tags
$ git fetch &lt;url of origin&gt; --prune 'refs/tags/*:refs/tags/*'</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_output">OUTPUT</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>git fetch</code> の出力は、使用する転送方法によって異なります。 このセクションでは、Gitプロトコル(ローカルまたはssh経由)およびスマートHTTPプロトコルを介してフェッチする場合の出力について説明します。</p></div>
<div class="paragraph"><p>フェッチのステータスは表形式で出力され、各行は単一のrefのステータスを表します。 各行の形式は以下のとおりです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> &lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; [&lt;reason&gt;]</code></pre>
</div></div>
<div class="paragraph"><p><code>--porcelain</code> を使用する場合、 出力形式は機械でパース可能(machine-parseable)であることが意図されています。 したがって、 人間が判読できる出力形式とは対照的に、 標準エラーではなく標準出力に出力されます。 各行の形式は以下のとおりです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;flag&gt; &lt;old-object-id&gt; &lt;new-object-id&gt; &lt;local-reference&gt;</code></pre>
</div></div>
<div class="paragraph"><p>最新のrefのステータスは、 <code>--verbose</code> オプションが使用されている場合にのみ表示されます。</p></div>
<div class="paragraph"><p>構成変数fetch.outputで指定されたコンパクト出力モードでは、他の文字列に <code>&lt;from&gt;</code> または <code>&lt;to&gt;</code> 全体が見つかった場合、他の文字列内では <code>*</code> に置き換えられます。 たとえば、 <code>master -&gt; origin/master</code> は <code>master -&gt; origin/*</code> になります。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
flag
</dt>
<dd>
<p>
        refのステータスを示す1文字:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
(space)
</dt>
<dd>
<p>
フェッチされた早送りの成功
</p>
</dd>
<dt class="hdlist1">
<code>+</code>
</dt>
<dd>
<p>
強制更新の成功
</p>
</dd>
<dt class="hdlist1">
<code>-</code>
</dt>
<dd>
<p>
refの刈り込みの成功
</p>
</dd>
<dt class="hdlist1">
<code>t</code>
</dt>
<dd>
<p>
タグ更新の成功
</p>
</dd>
<dt class="hdlist1">
<code>*</code>
</dt>
<dd>
<p>
新しいrefのフェッチの成功
</p>
</dd>
<dt class="hdlist1">
<code>!</code>
</dt>
<dd>
<p>
拒否された、または更新に失敗したref
</p>
</dd>
<dt class="hdlist1">
<code>=</code>
</dt>
<dd>
<p>
最新であり、フェッチする必要がなかったref
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
summary
</dt>
<dd>
<p>
        成功裏にフェッチされたrefの場合、概要には、refの古い値と新しい値が <code>git log</code> の引数として使用するのに適した形式で表示されます(これはほとんどの場合 <code>&lt;old&gt;..&lt;new&gt;</code> であり、強制的な非早送り(non-fast-forward)更新の場合は <code>&lt;old&gt;...&lt;new&gt;</code> です)。
</p>
</dd>
<dt class="hdlist1">
from
</dt>
<dd>
<p>
        フェッチ元のリモートrefの名前から、その <code>refs/&lt;type&gt;/`プレフィックスを差し引いたもの。 削除の場合、リモートrefの名前は `(none)</code> です。
</p>
</dd>
<dt class="hdlist1">
to
</dt>
<dd>
<p>
        更新されるローカルrefの名前から、その <code>refs/&lt;type&gt;/</code> プレフィックスを差し引いたもの。
</p>
</dd>
<dt class="hdlist1">
reason
</dt>
<dd>
<p>
        人間が読める説明。 正常にフェッチされたrefの場合、説明は必要ありません。 失敗したrefについては、失敗の理由が説明されています。
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">EXAMPLES</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
リモートトラッキングブランチを更新します:
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git fetch origin</code></pre>
</div></div>
<div class="paragraph"><p>上記のコマンドは、 <code>branch.&lt;name&gt;.fetch</code> オプションを使用してデフォルト以外のrefspecを指定しない限り、 すべてのブランチをリモート <code>refs/heads/</code> 名前空間からコピーし、 ローカル <code>refs/remotes/origin/</code> 名前空間に格納します。</p></div>
</li>
<li>
<p>
refspecsの明示的な使用:
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git fetch origin +seen:seen maint:tmp</code></pre>
</div></div>
<div class="paragraph"><p>これにより、リモートリポジトリからブランチ <code>seen</code> と <code>maint</code> を(それぞれ)フェッチすることにより、ローカルリポジトリでブランチ <code>seen</code> と <code>tmp</code> が更新(または必要に応じて作成)されます。</p></div>
<div class="paragraph"><p><code>seen</code> ブランチは、接頭辞にプラス記号(<code>+</code>)が付いているため、早送りしなくても更新されます。 <code>tmp</code> はそうしません。</p></div>
</li>
<li>
<p>
あなたのローカルリポジトリで「リモート」を構成せずに、リモートのブランチをちらっと見ます(peek):
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD</code></pre>
</div></div>
<div class="paragraph"><p>最初のコマンドは <code>git://git.kernel.org/pub/scm/git/git.git</code> のリポジトリから <code>maint</code> ブランチをフェッチし、2番目のコマンドは <code>FETCH_HEAD</code> を使用して <a href="git-log.html">git-log(1)</a> でブランチを調べます。 フェッチされたオブジェクトは、最終的にgitの組み込みの家政婦(housekeeping)によって削除されます(<a href="git-gc.html">git-gc(1)</a> を参照)。</p></div>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_security">SECURITY</h2>
<div class="sectionbody">
<div class="paragraph"><p>フェッチおよびプッシュプロトコルは、共有することを意図していない一方の側が他方のリポジトリからデータを盗むのを防ぐようには設計されていません。悪意のある者から保護する必要のあるプライベートデータがある場合、最善のオプションはそれを別のリポジトリに保存することです。これは、クライアントとサーバーの両方に適用されます。特に、サーバー上の名前空間は、読み取りアクセス制御には効果的ではありません。リポジトリ全体への読み取りアクセスで信頼できるクライアントにのみ、名前空間への読み取りアクセスを許可する必要があります。</p></div>
<div class="paragraph"><p>既知の攻撃ベクトル(attack vectors)は以下のとおりです:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
被害者は、明示的に共有することを意図していないオブジェクトのIDをアドバタイズする "have" 行を送信しますが、他にもIDを持っている者が居る場合は、転送を最適化するために使用できます。攻撃者はオブジェクトID Xを選択して盗み、refをXに送信しますが、被害者はすでにXのコンテンツを持っているため、Xのコンテンツを送信する必要はありません。 これで、被害者は攻撃者がXを持っていると信じ、Xのコンテンツを後で攻撃者に送り返します。 (この攻撃は、クライアントがアクセスできる名前空間にXへのrefを作成してフェッチすることにより、クライアントがサーバー上で実行するのが最も簡単です。サーバーがクライアント上で実行する最も可能性の高い方法は、Xをパブリックブランチにマージし、ユーザーがこのブランチで追加の作業を行い、マージに気付かずにサーバーにプッシュバックすることを期待します。)
</p>
</li>
<li>
<p>
#1 と同様に、攻撃者は盗むオブジェクトID Xを選択します。被害者は、攻撃者がすでに持っているオブジェクトYを送信し、攻撃者はYではなくXを持っていると誤って主張するため、被害者はYをXに対するデルタとして送信します。デルタは、攻撃者にYに類似したXの領域を明らかにします。
</p>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration">CONFIGURATION</h2>
<div class="sectionbody">
<div class="paragraph"><p>このセクションの以下のすべては、 <a href="git-config.html">git-config(1)</a> ドキュメントの抜粋です。 内容は <a href="git-config.html">git-config(1)</a> ドキュメント にあるものと同一です:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
fetch.recurseSubmodules
</dt>
<dd>
<p>
        このオプションは、 <code>git fetch</code>(および <code>git pull</code> の基になるフェッチ)が入力されたサブモジュールに再帰的にフェッチするかどうかを制御します。 このオプションは、ブール値または <code>on-demand</code> のいずれかに設定できます。 ブール値に設定すると、フェッチとプルの動作が変更され、trueに設定されている場合は無条件にサブモジュールに再帰し、falseに設定されている場合はまったく再帰しません。 <code>on-demand</code> に設定すると、フェッチとプルは、スーパープロジェクトがサブモジュールの参照を更新するコミットを取得したときにのみ、入力されたサブモジュールに再帰します。 デフォルトは <code>on-demand</code> 、または <code>submodule.recurse</code> が設定されている場合はその値です。
</p>
</dd>
<dt class="hdlist1">
fetch.fsckObjects
</dt>
<dd>
<p>
        trueに設定されている場合、git-fetch-packはフェッチされたすべてのオブジェクトをチェックします。 チェックされる内容については、 <code>transfer.fsckObjects</code> を参照してください。 デフォルトはfalseです。 設定されていない場合は、代わりに <code>transfer.fsckObjects</code> の値が使用されます。
</p>
</dd>
<dt class="hdlist1">
fetch.fsck.&lt;msg-id&gt;
</dt>
<dd>
<p>
        <code>fsck.&lt;msg-id&gt;</code> のように機能しますが、 <a href="git-fsck.html">git-fsck(1)</a> の代わりに <a href="git-fetch-pack.html">git-fetch-pack(1)</a> によって使用されます。 詳細については、 <code>fsck.&lt;msg-id&gt;</code> のドキュメントを参照してください。
</p>
</dd>
<dt class="hdlist1">
fetch.fsck.skipList
</dt>
<dd>
<p>
        <code>fsck.skipList</code> のように機能しますが、 <a href="git-fsck.html">git-fsck(1)</a> の代わりに <a href="git-fetch-pack.html">git-fetch-pack(1)</a> によって使用されます。 詳細については、 <code>fsck.skipList</code> のドキュメントを参照してください。
</p>
</dd>
<dt class="hdlist1">
fetch.unpackLimit
</dt>
<dd>
<p>
        Gitネイティブ転送を介してフェッチされるオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、受信したオブジェクトの数がこの制限以上の場合、受信したパックは、欠落しているデルタベースを追加した後、パックとして保存されます。 プッシュからパックを保存すると、特に低速のファイルシステムで、プッシュ操作をより速く完了することができます。 これが設定されていない場合は、代わりに <code>transfer.unpackLimit</code> の値が使用されます。
</p>
</dd>
<dt class="hdlist1">
fetch.prune
</dt>
<dd>
<p>
        trueの場合、fetchはコマンドラインで <code>--prune</code> オプションが指定されたかのように自動的に動作します。 <code>remote.&lt;name&gt;.prune</code> および <a href="git-fetch.html">git-fetch(1)</a> の「PRUNING」セクションも参照してください。
</p>
</dd>
<dt class="hdlist1">
fetch.pruneTags
</dt>
<dd>
<p>
        trueの場合、フェッチは、まだ設定されていない場合、刈り込み(pruning)時に <code>refs/tags/*:refs/tags/*</code> refspecが提供されたかのように自動的に振る舞います。 これにより、このオプションと <code>fetch.prune</code> の両方を設定して、アップストリーム参照への 1=1 マッピングを維持できます。 <code>remote.&lt;name&gt;.pruneTags</code> および <a href="git-fetch.html">git-fetch(1)</a> の「PRUNING」セクションも参照してください。
</p>
</dd>
<dt class="hdlist1">
fetch.output
</dt>
<dd>
<p>
        ref updateステータスの出力方法を制御します。 有効な値は <code>full</code> と <code>compact</code> です。 デフォルト値は <code>full</code> です。 詳細については、 <a href="git-fetch.html">git-fetch(1)</a> の「OUTPUT」セクションを参照してください。
</p>
</dd>
<dt class="hdlist1">
fetch.negotiationAlgorithm
</dt>
<dd>
<p>
        サーバーによって送信されるパックファイルの内容をネゴシエートするときに、ローカルリポジトリ内のコミットに関する情報がどのように送信されるかを制御します。 <code>consecutive</code> に設定すると、連続したコミットをそれぞれチェックするアルゴリズムを使用します。 <code>skipping</code> に設定すると、収束を高速化するためにコミットをスキップするアルゴリズムが使用されますが、必要以上の大きさのパックファイルが生成される可能性があります。 または、 <code>noop</code> に設定して情報をまったく送信しないようにします。これにより、ほぼ確実に必要以上に大きなパックファイルが生成されますが、ネゴシエーション・ステップはスキップされます。 <code>default</code> に設定すると、それ以前に行われた設定をオーバーライドしてデフォルトの振る舞いをします。 デフォルトは通常 <code>consecutive</code> ですが、 <code>feature.experimental</code> が true の場合、デフォルトは <code>skipping</code> です。 値が不明な場合、 <code>git fetch</code> でエラーが発生します。
</p>
<div class="paragraph"><p><a href="git-fetch.html">git-fetch(1)</a> の <code>--negotiate-only</code> および <code>--negotiation-tip</code> オプションも参照してください。</p></div>
</dd>
<dt class="hdlist1">
fetch.showForcedUpdates
</dt>
<dd>
<p>
        falseに設定すると、 <a href="git-fetch.html">git-fetch(1)</a> および <a href="git-pull.html">git-pull(1)</a> コマンドで <code>--no-show-forced-updates</code> が有効になります。 デフォルトはtrueです。
</p>
</dd>
<dt class="hdlist1">
fetch.parallel
</dt>
<dd>
<p>
        一度に並行して実行されるフェッチ操作の最大数を指定します(サブモジュール、または、<a href="git-fetch.html">git-fetch(1)</a> の <code>--multiple</code> オプションが有効な場合はリモート)。
</p>
<div class="paragraph"><p>値0は、適切なデフォルトを提供します。 設定されていない場合、デフォルトで1になります。</p></div>
<div class="paragraph"><p>サブモジュールの場合、この設定は、 <code>submodule.fetchJobs</code> 構成設定を使用してオーバーライドできます。</p></div>
</dd>
<dt class="hdlist1">
fetch.writeCommitGraph
</dt>
<dd>
<p>
        リモートからパックファイルをダウンロードするすべての <code>git fetch</code> コマンドの後でcommit-graphを書き込むには、trueに設定します。 <code>--split</code> オプションを使用すると、ほとんどの実行で、既存のcommit-graphファイルの上に非常に小さなcommit-graphファイルが作成されます。 場合によっては、これらのファイルがマージされ、書き込みに時間がかかることがあります。 更新されたcommit-graphファイルがあると、 <code>git merge-base</code> や <code>git push -f</code> や <code>git log --graph</code> などの多くのGitコマンドのパフォーマンス改善に役立ちます。 デフォルトはfalseです。
</p>
</dd>
<dt class="hdlist1">
fetch.bundleURI
</dt>
<dd>
<p>
        この値には、 元の Git サーバーからの増分フェッチを実行する前に、 バンドル URI から Git オブジェクト・データをダウンロードするための URI が格納されます。これは、 <a href="git-clone.html">git-clone(1)</a> の <code>--bundle-uri</code> オプションの動作に似ています。 指定されたバンドル URI に増分フェッチ用に編成されたバンドル・リストが含まれている場合、<code>git clone --bundle-uri</code> では <code>fetch.bundleURI</code> 値を設定します。
</p>
<div class="paragraph"><p>あなたが、 この値を変更し、 かつ、 あなたのリポジトリに <code>fetch.bundleCreationToken</code> 値がある場合、 新しいバンドル URI からフェッチする前に、 <code>fetch.bundleCreationToken</code> 値を削除してください。</p></div>
</dd>
<dt class="hdlist1">
fetch.bundleCreationToken
</dt>
<dd>
<p>
        <code>fetch.bundleURI</code> を使用して「creationToken」ヒューリスティックを使用するバンドル・リストから増分フェッチする場合、 この設定値には、 ダウンロードされたバンドルの、 最大 <code>creationToken</code> 値が格納されます。 この値は、 通知された <code>creationToken</code> がこの値を超えない限り、 その後のバンドルがダウンロードされないようにするために使用されます。
</p>
<div class="paragraph"><p>作成トークン(creation token)の値は、 指定のバンドル URI を提供しているプロバイダーが使います。 <code>fetch.bundleURI</code> で URI を変更する場合は、 フェッチする前に必ず <code>fetch.bundleCreationToken</code> 値を削除してください。</p></div>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs">BUGS</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>--recurse-submodules</code> を使用すると、ローカルに存在するサブモジュール、たとえば <code>$GIT_DIR/modules/</code> 内の新しいコミットのみを取得(fetch)できます。 アップストリームが新しいサブモジュールを追加した場合、そのサブモジュールは、たとえば <code>git submodule update</code> によるクローンが作成されるまで取得(fetch)できません。 これは、将来の Git バージョンで修正される予定です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">SEE ALSO</h2>
<div class="sectionbody">
<div class="paragraph"><p><a href="git-pull.html">git-pull(1)</a></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-10-27 08:12:06 JST
</div>
</div>
</body>
</html>
