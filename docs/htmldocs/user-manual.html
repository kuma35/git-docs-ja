<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Git User Manual</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="id-1"></a>Git User Manual</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#_introduction">Introduction</a></span></dt><dt><span class="chapter"><a href="#repositories-and-branches">1. Repositories and Branches</a></span></dt><dd><dl><dt><span class="section"><a href="#how-to-get-a-git-repository">How to get a Git repository</a></span></dt><dt><span class="section"><a href="#how-to-check-out">プロジェクトの別のバージョンをチェックアウトする方法</a></span></dt><dt><span class="section"><a href="#understanding-commits">Understanding History: Commits</a></span></dt><dd><dl><dt><span class="section"><a href="#understanding-reachability">Understanding history: commits, parents, and reachability</a></span></dt><dt><span class="section"><a href="#history-diagrams">Understanding history: History diagrams</a></span></dt><dt><span class="section"><a href="#what-is-a-branch">Understanding history: What is a branch?</a></span></dt></dl></dd><dt><span class="section"><a href="#manipulating-branches">Manipulating branches</a></span></dt><dt><span class="section"><a href="#detached-head">新しいブランチを作成せずに古いバージョンを調べる</a></span></dt><dt><span class="section"><a href="#examining-remote-branches">Examining branches from a remote repository</a></span></dt><dt><span class="section"><a href="#how-git-stores-references">Naming branches, tags, and other references</a></span></dt><dt><span class="section"><a href="#Updating-a-repository-With-git-fetch">Updating a repository with git fetch</a></span></dt><dt><span class="section"><a href="#fetching-branches">Fetching branches from other repositories</a></span></dt></dl></dd><dt><span class="chapter"><a href="#exploring-git-history">2. Exploring Git history</a></span></dt><dd><dl><dt><span class="section"><a href="#using-bisect">How to use bisect to find a regression</a></span></dt><dt><span class="section"><a href="#naming-commits">Naming commits</a></span></dt><dt><span class="section"><a href="#creating-tags">Creating tags</a></span></dt><dt><span class="section"><a href="#browsing-revisions">Browsing revisions</a></span></dt><dt><span class="section"><a href="#generating-diffs">Generating diffs</a></span></dt><dt><span class="section"><a href="#viewing-old-file-versions">Viewing old file versions</a></span></dt><dt><span class="section"><a href="#history-examples">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#counting-commits-on-a-branch">Counting the number of commits on a branch</a></span></dt><dt><span class="section"><a href="#checking-for-equal-branches">2つのブランチが同じ履歴を指しているかどうかを確認します</a></span></dt><dt><span class="section"><a href="#finding-tagged-descendants">指定の修正を含む最初のタグ付きバージョンを検索する</a></span></dt><dt><span class="section"><a href="#showing-commits-unique-to-a-branch">指定のブランチに固有のコミットを表示する</a></span></dt><dt><span class="section"><a href="#making-a-release">Creating a changelog and tarball for a software release</a></span></dt><dt><span class="section"><a href="#Finding-commits-With-given-Content">指定の内容を含むファイルを参照するコミットを検索する</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Developing-With-git">3. Gitでの開発作業</a></span></dt><dd><dl><dt><span class="section"><a href="#telling-git-your-name">あなたの名前をGitに教える</a></span></dt><dt><span class="section"><a href="#creating-a-new-repository">Creating a new repository</a></span></dt><dt><span class="section"><a href="#how-to-make-a-commit">How to make a commit</a></span></dt><dt><span class="section"><a href="#creating-good-commit-messages">適切なコミットメッセージの作成</a></span></dt><dt><span class="section"><a href="#ignoring-files">Ignoring files</a></span></dt><dt><span class="section"><a href="#how-to-merge">How to merge</a></span></dt><dt><span class="section"><a href="#resolving-a-merge">Resolving a merge</a></span></dt><dd><dl><dt><span class="section"><a href="#conflict-resolution">マージ作業中に競合解決の助けを得る</a></span></dt></dl></dd><dt><span class="section"><a href="#undoing-a-merge">マージを元に戻す</a></span></dt><dt><span class="section"><a href="#fast-forwards">Fast-forward merges</a></span></dt><dt><span class="section"><a href="#fixing-mistakes">作業ミスを修正する</a></span></dt><dd><dl><dt><span class="section"><a href="#reverting-a-commit">新しいコミットによって作業ミスを修正する</a></span></dt><dt><span class="section"><a href="#fixing-a-mistake-by-rewriting-history">履歴を巻き戻す事によって作業ミスを修正する</a></span></dt><dt><span class="section"><a href="#checkout-of-path">Checking out an old version of a file</a></span></dt><dt><span class="section"><a href="#interrupted-work">作業中の作業を一時的に保存しておく</a></span></dt></dl></dd><dt><span class="section"><a href="#ensuring-good-performance">良好なパフォーマンスの確保</a></span></dt><dt><span class="section"><a href="#ensuring-reliability">信頼性の確保</a></span></dt><dd><dl><dt><span class="section"><a href="#checking-for-corruption">リポジトリの破損をチェックする</a></span></dt><dt><span class="section"><a href="#recovering-lost-changes">失われた変更の回復</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#sharing-development">4. Sharing development with others</a></span></dt><dd><dl><dt><span class="section"><a href="#getting-updates-With-git-pull">Getting updates with git pull</a></span></dt><dt><span class="section"><a href="#submitting-patches">Submitting patches to a project</a></span></dt><dt><span class="section"><a href="#importing-patches">Importing patches to a project</a></span></dt><dt><span class="section"><a href="#public-repositories">Public Git repositories</a></span></dt><dd><dl><dt><span class="section"><a href="#setting-up-a-public-repository">Setting up a public repository</a></span></dt><dt><span class="section"><a href="#exporting-via-git">Gitプロトコルを介したGitリポジトリのエクスポート</a></span></dt><dt><span class="section"><a href="#exporting-via-http">Exporting a git repository via HTTP</a></span></dt><dt><span class="section"><a href="#pushing-changes-to-a-public-repository">Pushing changes to a public repository</a></span></dt><dt><span class="section"><a href="#forcing-push">プッシュが失敗した場合の対処方法</a></span></dt><dt><span class="section"><a href="#setting-up-a-shared-repository">Setting up a shared repository</a></span></dt><dt><span class="section"><a href="#setting-up-gitweb">Allowing web browsing of a repository</a></span></dt></dl></dd><dt><span class="section"><a href="#how-to-get-a-git-repository-with-minimal-history">最小限の履歴でGitリポジトリを取得する方法</a></span></dt><dt><span class="section"><a href="#sharing-development-examples">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#maintaining-topic-branches">Maintaining topic branches for a Linux subsystem maintainer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#cleaning-up-history">5. Rewriting history and maintaining patch series</a></span></dt><dd><dl><dt><span class="section"><a href="#patch-series">Creating the perfect patch series</a></span></dt><dt><span class="section"><a href="#using-git-rebase">Keeping a patch series up to date using git rebase</a></span></dt><dt><span class="section"><a href="#rewriting-one-commit">Rewriting a single commit</a></span></dt><dt><span class="section"><a href="#reordering-patch-series">Reordering or selecting from a patch series</a></span></dt><dt><span class="section"><a href="#interactive-rebase">Using interactive rebases</a></span></dt><dt><span class="section"><a href="#patch-series-tools">Other tools</a></span></dt><dt><span class="section"><a href="#problems-With-rewriting-history">履歴の書き換えに関する問題</a></span></dt><dt><span class="section"><a href="#bisect-merges">なぜマージコミットをbisectすることが線形履歴をbisectするよりも難しい場合があるのか</a></span></dt></dl></dd><dt><span class="chapter"><a href="#advanced-branch-management">6. Advanced branch management</a></span></dt><dd><dl><dt><span class="section"><a href="#fetching-individual-branches">Fetching individual branches</a></span></dt><dt><span class="section"><a href="#fetch-fast-forwards">git fetch and fast-forwards</a></span></dt><dt><span class="section"><a href="#forcing-fetch">Forcing git fetch to do non-fast-forward updates</a></span></dt><dt><span class="section"><a href="#remote-branch-configuration">Configuring remote-tracking branches</a></span></dt></dl></dd><dt><span class="chapter"><a href="#git-concepts">7. Gitの概念</a></span></dt><dd><dl><dt><span class="section"><a href="#the-object-database">The Object Database</a></span></dt><dd><dl><dt><span class="section"><a href="#commit-object">Commit Object</a></span></dt><dt><span class="section"><a href="#tree-object">Tree Object</a></span></dt><dt><span class="section"><a href="#blob-object">Blob Object</a></span></dt><dt><span class="section"><a href="#trust">Trust(信頼性)</a></span></dt><dt><span class="section"><a href="#tag-object">Tag Object</a></span></dt><dt><span class="section"><a href="#pack-files">Gitがオブジェクトを効率的に保存する方法: pack files</a></span></dt><dt><span class="section"><a href="#dangling-objects">Dangling objects(宙ぶらりんオブジェクト)</a></span></dt><dt><span class="section"><a href="#recovering-from-repository-corruption">破損したリポジトリの回復</a></span></dt></dl></dd><dt><span class="section"><a href="#the-index">The index</a></span></dt></dl></dd><dt><span class="chapter"><a href="#submodules">8. Submodules</a></span></dt><dd><dl><dt><span class="section"><a href="#pitfalls-with-submodules">サブモジュールの落とし穴</a></span></dt></dl></dd><dt><span class="chapter"><a href="#low-level-operations">9. Low-level Git operations</a></span></dt><dd><dl><dt><span class="section"><a href="#object-manipulation">Object access and manipulation</a></span></dt><dt><span class="section"><a href="#the-workflow">The Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#working-directory-to-index">working directory → index</a></span></dt><dt><span class="section"><a href="#index-to-object-database">index → object database</a></span></dt><dt><span class="section"><a href="#object-database-to-index">object database → index</a></span></dt><dt><span class="section"><a href="#index-to-working-directory">index → working directory</a></span></dt><dt><span class="section"><a href="#tying-it-all-together">全てを結び付ける</a></span></dt></dl></dd><dt><span class="section"><a href="#examining-the-data">Examining the data</a></span></dt><dt><span class="section"><a href="#merging-multiple-trees">Merging multiple trees</a></span></dt><dt><span class="section"><a href="#merging-multiple-trees-2">Merging multiple trees, continued</a></span></dt></dl></dd><dt><span class="chapter"><a href="#hacking-git">10. Hacking Git</a></span></dt><dd><dl><dt><span class="section"><a href="#object-details">Object storage format</a></span></dt><dt><span class="section"><a href="#birdview-on-the-source-code">Gitのソースコードを俯瞰する</a></span></dt></dl></dd><dt><span class="chapter"><a href="#glossary">11. Git用語集</a></span></dt><dd><dl><dt><span class="section"><a href="#git-explained">Git解説</a></span></dt></dl></dd><dt><span class="appendix"><a href="#git-quick-start">A. Git Quick Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#quick-creating-a-new-repository">Creating a new repository</a></span></dt><dt><span class="section"><a href="#managing-branches">Managing branches</a></span></dt><dt><span class="section"><a href="#exploring-history">Exploring history</a></span></dt><dt><span class="section"><a href="#making-changes">Making changes</a></span></dt><dt><span class="section"><a href="#merging">Merging</a></span></dt><dt><span class="section"><a href="#sharing-your-changes">Sharing your changes</a></span></dt><dt><span class="section"><a href="#repository-maintenance">Repository maintenance</a></span></dt></dl></dd><dt><span class="appendix"><a href="#todo">B. Notes and todo list for this manual</a></span></dt><dd><dl><dt><span class="section"><a href="#todo-list">Todo list</a></span></dt></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="_introduction"></a>Introduction</h1></div></div></div><p>Gitは高速分散型リビジョン管理システムです。</p><p>この説明書は、基本的なUNIXコマンドラインスキルを持っているが、Gitの予備知識がない人でも読めるように設計されています。</p><p><a class="xref" href="#repositories-and-branches" title="Chapter 1. Repositories and Branches">Chapter 1, <i>Repositories and Branches</i></a> と <a class="xref" href="#exploring-git-history" title="Chapter 2. Exploring Git history">Chapter 2, <i>Exploring Git history</i></a>
は、gitを使用してプロジェクトをフェッチして調査する方法を説明しています。これらの章を読んで、ソフトウェアプロジェクトの特定のバージョンをビルド、テスト、デグレを探す方法を学んで下さい。</p><p>実際の開発を行う必要がある人は、 <a class="xref" href="#Developing-With-git" title="Chapter 3. Gitでの開発作業">Chapter 3, <i>Gitでの開発作業</i></a> と <a class="xref" href="#sharing-development" title="Chapter 4. Sharing development with others">Chapter 4, <i>Sharing development with others</i></a>
も読みたいと思うでしょう。</p><p>それ以降の章では、より専門的なトピックについて説明します。</p><p>包括的なリファレンスドキュメントは、マニュアルページまたは <a class="ulink" href="git-help.html" target="_top">git-help(1)</a> コマンドから入手できます。 たとえば、コマンド
<code class="literal">git clone &lt;repo&gt;</code> の場合、次のいずれかを使用できます:</p><pre class="screen">$ man git-clone</pre><p>または:</p><pre class="screen">$ git help clone</pre><p>後者では、選択したマニュアルビューアを使用できます。 詳細については <a class="ulink" href="git-help.html" target="_top">git-help(1)</a> を参照してください。</p><p>詳しい説明なしでのGitコマンドの概要については、 <a class="xref" href="#git-quick-start" title="Appendix A. Git Quick Reference">Appendix A, <i>Git Quick Reference</i></a> も参照してください。</p><p>最後に、このマニュアルをより完全にするためにあなたが貢献する方法については、 <a class="xref" href="#todo" title="Appendix B. Notes and todo list for this manual">Appendix B, <i>Notes and todo list for this manual</i></a> を参照してください。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="repositories-and-branches"></a>Chapter 1. Repositories and Branches</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#how-to-get-a-git-repository">How to get a Git repository</a></span></dt><dt><span class="section"><a href="#how-to-check-out">プロジェクトの別のバージョンをチェックアウトする方法</a></span></dt><dt><span class="section"><a href="#understanding-commits">Understanding History: Commits</a></span></dt><dd><dl><dt><span class="section"><a href="#understanding-reachability">Understanding history: commits, parents, and reachability</a></span></dt><dt><span class="section"><a href="#history-diagrams">Understanding history: History diagrams</a></span></dt><dt><span class="section"><a href="#what-is-a-branch">Understanding history: What is a branch?</a></span></dt></dl></dd><dt><span class="section"><a href="#manipulating-branches">Manipulating branches</a></span></dt><dt><span class="section"><a href="#detached-head">新しいブランチを作成せずに古いバージョンを調べる</a></span></dt><dt><span class="section"><a href="#examining-remote-branches">Examining branches from a remote repository</a></span></dt><dt><span class="section"><a href="#how-git-stores-references">Naming branches, tags, and other references</a></span></dt><dt><span class="section"><a href="#Updating-a-repository-With-git-fetch">Updating a repository with git fetch</a></span></dt><dt><span class="section"><a href="#fetching-branches">Fetching branches from other repositories</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-to-get-a-git-repository"></a>How to get a Git repository</h2></div></div></div><p>このマニュアルを読むときに、Gitリポジトリを試してみると便利です。</p><p>これを取得する最良の方法は、 <a class="ulink" href="git-clone.html" target="_top">git-clone(1)</a>
コマンドを使用して既存のリポジトリのコピーをダウンロードすることです。あなたがプロジェクトをまだ考えていない場合は、いくつかの興味深い例を以下に示します:</p><pre class="screen">        # Git itself (approx. 40MB download):
$ git clone git://git.kernel.org/pub/scm/git/git.git
        # the Linux kernel (approx. 640MB download):
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</pre><p>大規模なプロジェクトでは、最初のクローン作成に時間がかかる場合がありますが、クローン作成が必要になるのは1回だけです。</p><p>cloneコマンドは、プロジェクトにちなんで名付けられた新しいディレクトリを作成します(上記の例では <code class="literal">git</code> または
<code class="literal">linux</code>)。このディレクトリにcdすると、 <a class="link" href="#def_working_tree">working tree</a>
と呼ばれるプロジェクトファイルのコピーと、プロジェクトの歴史について全ての情報を含む <code class="literal">.git</code>
という名前の特別なトップレベルディレクトリが含まれていることがわかります。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-to-check-out"></a>プロジェクトの別のバージョンをチェックアウトする方法</h2></div></div></div><p>Gitは、ファイルのコレクションの履歴を保存するためのツールとして最もよく考えられています。プロジェクトのコンテンツの相互に関連するスナップショットの圧縮されたコレクションとして履歴を保存します。
Gitでは、このような各バージョンは <a class="link" href="#def_commit">commit</a> と呼ばれます。</p><p>これらのスナップショットは、必ずしもすべてが古いものから新しいものへと一列に配置されているわけではなく、作業は、
<a class="link" href="#def_branch">branches</a>
と呼ばれる並行する開発ラインに沿って同時に進行する場合があります。これは、マージおよび分岐する場合があります。</p><p>単一のGitリポジトリで、複数のブランチの開発を追跡できます。これは、各ブランチの最新のコミットを参照する <a class="link" href="#def_head">heads</a>
のリストを保持することによって行われます。 <a class="ulink" href="git-branch.html" target="_top">git-branch(1)</a> コマンドは、ブランチヘッド(branch
heads)を一覧表示します。</p><pre class="screen">$ git branch
* master</pre><p>新しくクローンされたリポジトリには、デフォルトで「master」という名前の単一のブランチヘッドが含まれ、作業ディレクトリはそのブランチヘッドによって参照されるプロジェクトの状態に初期化されます。</p><p>ほとんどのプロジェクトは <a class="link" href="#def_tag">tags</a> も使用します。タグはヘッドのようであり、プロジェクトの履歴への参照であり、
<a class="ulink" href="git-tag.html" target="_top">git-tag(1)</a> コマンドを使用して一覧表示できます。</p><pre class="screen">$ git tag -l
v2.6.11
v2.6.11-tree
v2.6.12
v2.6.12-rc2
v2.6.12-rc3
v2.6.12-rc4
v2.6.12-rc5
v2.6.12-rc6
v2.6.13
...</pre><p>タグは常にプロジェクトの同じバージョンを指すことが期待されますが、開発が進むにつれてヘッドは前進することが期待されます。</p><p>これらのバージョンのいずれかを指す新しいブランチヘッドを作成し、 <a class="ulink" href="git-switch.html" target="_top">git-switch(1)</a> を使用してチェックアウトします:</p><pre class="screen">$ git switch -c new v2.6.13</pre><p>作業ディレクトリは、v2.6.13 のタグが付けられたときにプロジェクトが持っていた内容を反映し、 <a class="ulink" href="git-branch.html" target="_top">git-branch(1)</a>
は2つのブランチを表示し、アスタリスクは現在チェックアウトされているブランチを示します。</p><pre class="screen">$ git branch
  master
* new</pre><p>あなたがバージョン 2.6.17 を使用することにした場合は、以下のようにして、代わりに v2.6.17 を指すように現在のブランチを変更できます。</p><pre class="screen">$ git reset --hard v2.6.17</pre><p>注意:
現在のブランチヘッドが履歴内の特定のポイントへの唯一の参照である場合、そのブランチをリセットすると、それが指していた履歴を見つける方法がなくなる可能性があることに注意してください。したがって、このコマンドは慎重に使用してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="understanding-commits"></a>Understanding History: Commits</h2></div></div></div><p>プロジェクトの履歴のすべての変更は、コミットによって表されます。 <a class="ulink" href="git-show.html" target="_top">git-show(1)</a>
コマンドは、現在のブランチでの最新のコミットを表示します:</p><pre class="screen">$ git show
commit 17cf781661e6d38f737f15f53ab552f1e95960d7
Author: Linus Torvalds &lt;torvalds@ppc970.osdl.org.(none)&gt;
Date:   Tue Apr 19 14:11:06 2005 -0700

    Remove duplicate getenv(DB_ENVIRONMENT) call

    Noted by Tony Luck.

diff --git a/init-db.c b/init-db.c
index 65898fa..b002dc6 100644
--- a/init-db.c
+++ b/init-db.c
@@ -7,7 +7,7 @@

 int main(int argc, char **argv)
 {
-       char *sha1_dir = getenv(DB_ENVIRONMENT), *path;
+       char *sha1_dir, *path;
        int len, i;

        if (mkdir(".git", 0755) &lt; 0) {</pre><p>ご覧のとおり、コミットは、誰が最新の変更を行ったか、何をしたか、そしてその理由を示しています。</p><p>すべてのコミットには16進40桁のIDがあります。それは「オブジェクト名」または「SHA-1 ID」と呼ばれることもあり、「git
show」出力の最初の行に表示されます。通常、タグやブランチ名などの短い名前でコミットを参照できますが、この長い名前も役立ちます。最も重要なことは、これはこのコミットにとってグローバルに一意の名前です。したがって、他の誰かにオブジェクト名を(たとえば電子メールで)伝えると、その名前が自分のリポジトリで行うのと同じコミットを参照することが保証されます(彼らのリポジトリにそのコミットがあると仮定します)。オブジェクト名はコミットの内容に対するハッシュとして計算されるため、名前が変更されてなければコミットも変更されてない事が保証されます。</p><p>実際、 <a class="xref" href="#git-concepts" title="Chapter 7. Gitの概念">Chapter 7, <i>Gitの概念</i></a>
では、ファイルデータやディレクトリの内容など、Gitの履歴に保存されているすべてのものが、その内容のハッシュである名前が付いたオブジェクトに保存されていることがわかります。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="understanding-reachability"></a>Understanding history: commits, parents, and reachability</h3></div></div></div><p>(プロジェクトの最初のコミットを除く)すべてのコミットには、このコミットの前に何が起こったかを示す親コミットもあります。親の連鎖をたどると、最終的にはプロジェクトの最初に戻ります。</p><p>ただし、コミットは単純なリストを形成しません。
Gitを使用すると、開発ラインが分岐してから再収束します。2つの開発ラインが再収束するポイントは「マージ」と呼ばれます。したがって、マージを表すコミットは1つ以上の親を持つことができ、各親はそれぞれがそのポイントにつながる開発ラインの1つで最も最近のコミットを表します。</p><p>これがどのように働くを確認する最良の方法は、 <a class="ulink" href="gitk.html" target="_top">gitk(1)</a>
コマンドを使用することです。現在Gitリポジトリでgitkを実行し、マージコミットを探すと、Gitが履歴を整理する方法を理解するのに役立ちます。</p><p>以下、コミットXがコミットYの祖先である場合、コミットXはコミットYから「到達可能」(reachable)であると言います。同様に、YはXの子孫である、コミットYからコミットXにつながる親のチェーンがあると言えます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="history-diagrams"></a>Understanding history: History diagrams</h3></div></div></div><p>以下のような図を使用して、Gitの履歴を表す場合があります。コミットは「o」として表示され、コミット間の繋がりは、 <code class="literal">-</code> および <code class="literal">/</code> および
<code class="literal">\</code> で描かれた線で示されます。時間は左から右に進みます:</p><pre class="literallayout">         o--o--o &lt;-- Branch A
        /
 o--o--o &lt;-- master
        \
         o--o--o &lt;-- Branch B</pre><p>特定のコミットについて話す必要がある場合は、文字「o」を別の文字または数字に置き換えることができます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="what-is-a-branch"></a>Understanding history: What is a branch?</h3></div></div></div><p>正確にする必要がある場合は、「ブランチ」という言葉を使用して開発ラインを意味し、「ブランチヘッド」(branch
head)(または単に「ヘッド」(head))という言葉を使用して、ブランチでの最新のコミットへの参照を意味します。上記の例では、「A」という名前のブランチヘッドは、1つの特定のコミットへのポインターですが、その時点までの3つのコミットの連なった線をすべて「ブランチA」の一部として参照します。</p><p>ただし、混乱が生じない場合は、ブランチとブランチヘッドの両方に「ブランチ」という用語を使用することがよくあります。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulating-branches"></a>Manipulating branches</h2></div></div></div><p>ブランチの作成、削除、および変更は、素早く・簡単です。コマンドの概要は以下のとおりです:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<code class="literal">git branch</code>
</span></dt><dd>
        全てのブランチを一覧表示します。
</dd><dt><span class="term">
<code class="literal">git branch &lt;branch&gt;</code>
</span></dt><dd>
        現在のブランチと同じ履歴ポイントを参照して、 <code class="literal">&lt;branch&gt;</code> という名前の新しいブランチを作成します。
</dd><dt><span class="term">
<code class="literal">git branch &lt;branch&gt; &lt;start-point&gt;</code>
</span></dt><dd>
        <code class="literal">&lt;start-point&gt;</code> を参照して、 <code class="literal">&lt;branch&gt;</code>
        という名前の新しいブランチを作成します。これは、ブランチ名やタグ名を使用するなど、任意の方法で指定できます。
</dd><dt><span class="term">
<code class="literal">git branch -d &lt;branch&gt;</code>
</span></dt><dd>
        ブランチ
        `&lt;branch&gt;`を削除します。ブランチがそのアップストリームブランチに完全にマージされていないか、現在のブランチに含まれていない場合、このコマンドは警告とともに失敗します。
</dd><dt><span class="term">
<code class="literal">git branch -D &lt;branch&gt;</code>
</span></dt><dd>
        マージされたステータスに関係なく、ブランチ <code class="literal">&lt;branch&gt;</code> を削除します。
</dd><dt><span class="term">
<code class="literal">git switch &lt;branch&gt;</code>
</span></dt><dd>
        現在のブランチを <code class="literal">&lt;branch&gt;</code> にし、 <code class="literal">&lt;branch&gt;</code> によって参照されるバージョンを反映するように作業ディレクトリを更新します。
</dd><dt><span class="term">
<code class="literal">git switch -c &lt;new&gt; &lt;start-point&gt;</code>
</span></dt><dd>
        <code class="literal">&lt;start-point&gt;</code> を参照する新しいブランチ <code class="literal">&lt;new&gt;</code> を作成し、それをチェックアウトします。
</dd></dl></div><p>特殊シンボル記号「HEAD」は、常に現在のブランチを参照するために使用できます。実際、Gitは <code class="literal">.git</code> ディレクトリにある <code class="literal">HEAD</code>
という名前のファイルを使用して、現在のブランチを記憶しています。</p><pre class="screen">$ cat .git/HEAD
ref: refs/heads/master</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="detached-head"></a>新しいブランチを作成せずに古いバージョンを調べる</h2></div></div></div><p><code class="literal">git switch</code> コマンドは通常、ブランチヘッドを想定していますが、 <code class="literal">--detach</code>
を伴って呼び出されると任意のコミットも受け入れます。たとえば、タグによって参照されるコミットをチェックアウトできます:</p><pre class="screen">$ git switch --detach v2.6.17
Note: checking out 'v2.6.17'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another switch.
(あなたは「切り離されたHEAD」状態にあります。あなたは周りを見回し、
実験的な変更を加えてコミットすることができます。また、別のswitchを実行することで、
他のブランチに影響を与えることなく、この状態で行ったコミットを破棄できます。)

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command again. Example:
(作成したコミットを保持するために新しいブランチを作成する場合は、
switchコマンドで `-c` を再度使用して、(現在または後で)作成できます。例:)

  git switch -c new_branch_name

HEAD is now at 427abfa Linux v2.6.17</pre><p>次に、HEADはブランチではなくコミットのSHA-1を参照し、 <code class="literal">git branch</code> は、あなたがもはやブランチ上にいないことを示します:</p><pre class="screen">$ cat .git/HEAD
427abfa28afedffadfca9dd8b067eb6d36bac53f
$ git branch
* (detached from v2.6.17)
  master</pre><p>この場合、HEADは「切り離されている」(detached)と言います。</p><p>これは、新しいブランチの名前を作成しなくても、
特定のバージョンをチェックアウトする簡単な方法です。
必要に応じて、後でこのバージョンの新しいブランチ(またはタグ)を作成することもできます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examining-remote-branches"></a>Examining branches from a remote repository</h2></div></div></div><p>クローン作成時に作成された「master」ブランチは、クローン作成元のリポジトリにあるHEADのコピーです。ただし、そのリポジトリには他のブランチも含まれている可能性があり、ローカルリポジトリには、リモート追跡ブランチ(remote-tracking
branch)と呼ばれる、これらのリモートブランチのそれぞれを追跡するブランチが保持されます。これは、 <a class="ulink" href="git-branch.html" target="_top">git-branch(1)</a> の
<code class="literal">-r</code> オプションを使用して表示できます:</p><pre class="screen">$ git branch -r
  origin/HEAD
  origin/html
  origin/maint
  origin/man
  origin/master
  origin/next
  origin/seen
  origin/todo</pre><p>この例では、「origin」はリモートリポジトリ、または略して「リモート」(remote)と呼ばれます。このリポジトリのブランチは、私たちの観点からは「リモートブランチ」と呼ばれます。上記のリモート追跡ブランチは、クローン時にリモートブランチに基づいて作成され、
<code class="literal">git fetch</code> (つまり <code class="literal">git pull</code> でも)と <code class="literal">git push</code> によって更新されます。 詳細については、
<a class="xref" href="#Updating-a-repository-With-git-fetch" title="Updating a repository with git fetch">the section called “Updating a repository with git fetch”</a> を参照してください。</p><p>タグの場合と同じように、これらのリモート追跡ブランチの1つをあなた独自のブランチに構築することをお勧めします:</p><pre class="screen">$ git switch -c my-todo-copy origin/todo</pre><p><code class="literal">origin/todo</code> を直接チェックアウトして調べたり、1回限りのパッチを作成したりすることもできます。
<a class="link" href="#detached-head" title="新しいブランチを作成せずに古いバージョンを調べる">detached head</a> を参照してください。</p><p>注意: 「origin」という名前は、clone元のリポジトリを参照するためにGitがデフォルトで使用する名前にすぎないことに注意してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-git-stores-references"></a>Naming branches, tags, and other references</h2></div></div></div><p>ブランチやリモート追跡ブランチやタグはすべてコミットへの参照です。すべての参照は、 <code class="literal">refs</code>
で始まるスラッシュ(<code class="literal">/</code>)で区切られたパス名で名前が付けられます。これまで使用してきた名前は、実際には省略形です:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
ブランチ <code class="literal">test</code> は <code class="literal">refs/heads/test</code> の略です。
</li><li class="listitem">
タグ <code class="literal">v2.6.18</code> は <code class="literal">refs/tags/v2.6.18</code> の略です。
</li><li class="listitem">
<code class="literal">origin/master</code> は <code class="literal">refs/remotes/origin/master</code> の略です。
</li></ul></div><p>フルネームでの指定は、たとえば、同じ名前のタグとブランチが存在する場合に役立つことがあります。</p><p>(新しく作成されたrefは、実際にはその名前で指定されたパスで <code class="literal">.git/refs</code>
ディレクトリに保存されます。ただし、効率上の理由から、単一のファイルにまとめてパックすることもできます。
<a class="ulink" href="git-pack-refs.html" target="_top">git-pack-refs(1)</a> を参照してください。)</p><p>もう1つの便利な短縮形として、リポジトリの「HEAD」は、そのリポジトリの名前を使用するだけで参照できます。したがって、たとえば、「origin」は通常、「リポジトリ
origin のHEADブランチ」の短縮形です。</p><p>Gitが参照を調べるするパスの完全なリスト、および同じ省略名を持つ複数の参照がある場合に選択するために使用する順序については、
<a class="ulink" href="gitrevisions.html" target="_top">gitrevisions(7)</a> の「SPECIFYING REVISIONS」セクションを参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Updating-a-repository-With-git-fetch"></a>Updating a repository with git fetch</h2></div></div></div><p>リポジトリのクローンを作成し、独自の変更をいくつかコミットした後、あなたは元のリポジトリで更新を確認することをお勧めします。</p><p>引数を指定しない <code class="literal">git-fetch</code>
コマンドは、あなたのリポジトリにある全てのリモート追跡ブランチを元のリポジトリにある最新バージョンに更新します。それはあなた自身のどのブランチにも影響しません。それはあなたクローンで作成した「master」ブランチでさえ影響しません。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fetching-branches"></a>Fetching branches from other repositories</h2></div></div></div><p>あなたは <a class="ulink" href="git-remote.html" target="_top">git-remote(1)</a> を使用して、クローン元以外のリポジトリからブランチを追跡することもできます。</p><pre class="screen">$ git remote add staging git://git.kernel.org/.../gregkh/staging.git
$ git fetch staging
...
From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
 * [new branch]      master     -&gt; staging/master
 * [new branch]      staging-linus -&gt; staging/staging-linus
 * [new branch]      staging-next -&gt; staging/staging-next</pre><p>新しいリモート追跡ブランチは、 <code class="literal">git remote add</code> にて、今回は <code class="literal">staging</code> と名付けた省略名で保存されます:</p><pre class="screen">$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/master
  staging/master
  staging/staging-linus
  staging/staging-next</pre><p>後で <code class="literal">git fetch &lt;remote&gt;</code> を実行すると、 <code class="literal">&lt;remote&gt;</code> という名前のリモート追跡ブランチが更新されます。</p><p>ファイル <code class="literal">.git/config</code> を調べると、Gitが新しい一節を追加したことがわかります:</p><pre class="screen">$ cat .git/config
...
[remote "staging"]
        url = git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git
        fetch = +refs/heads/*:refs/remotes/staging/*
...</pre><p>これが、Gitがリモートのブランチを追跡できる理由です。 テキストエディタで <code class="literal">.git/config</code>
を編集することにより、これらの設定オプションを変更または削除できます。 (詳細については、 <a class="ulink" href="git-config.html" target="_top">git-config(1)</a>
の「CONFIGURATION FILE」セクションを参照してください。)</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="exploring-git-history"></a>Chapter 2. Exploring Git history</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#using-bisect">How to use bisect to find a regression</a></span></dt><dt><span class="section"><a href="#naming-commits">Naming commits</a></span></dt><dt><span class="section"><a href="#creating-tags">Creating tags</a></span></dt><dt><span class="section"><a href="#browsing-revisions">Browsing revisions</a></span></dt><dt><span class="section"><a href="#generating-diffs">Generating diffs</a></span></dt><dt><span class="section"><a href="#viewing-old-file-versions">Viewing old file versions</a></span></dt><dt><span class="section"><a href="#history-examples">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#counting-commits-on-a-branch">Counting the number of commits on a branch</a></span></dt><dt><span class="section"><a href="#checking-for-equal-branches">2つのブランチが同じ履歴を指しているかどうかを確認します</a></span></dt><dt><span class="section"><a href="#finding-tagged-descendants">指定の修正を含む最初のタグ付きバージョンを検索する</a></span></dt><dt><span class="section"><a href="#showing-commits-unique-to-a-branch">指定のブランチに固有のコミットを表示する</a></span></dt><dt><span class="section"><a href="#making-a-release">Creating a changelog and tarball for a software release</a></span></dt><dt><span class="section"><a href="#Finding-commits-With-given-Content">指定の内容を含むファイルを参照するコミットを検索する</a></span></dt></dl></dd></dl></div><p>Gitは、ファイルのコレクションの履歴を保存するためのツールとして最もよく考えられています。これは、ファイル階層のコンテンツの圧縮されたスナップショットを、これらのスナップショット間の関係を示す「コミット」とともに保存することによって行われます。</p><p>Gitは、プロジェクトの履歴を探索するための非常に柔軟で高速なツールを提供します。</p><p>私達は、プロジェクトにバグを導入したコミットを見つけるのに役立つ、ある専用ツールから始めることにします。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-bisect"></a>How to use bisect to find a regression</h2></div></div></div><p>あなたのプロジェクトのバージョン2.6.18は機能していしたが、「master」のバージョンがクラッシュしたとします。このようなデグレの原因を見つける最良の方法は、プロジェクトの履歴を総当たりで検索して、問題の原因となった特定のコミットを見つけることです。
<a class="ulink" href="git-bisect.html" target="_top">git-bisect(1)</a> コマンドは、あなたがこれを行う助けとなります:</p><pre class="screen">$ git bisect start
$ git bisect good v2.6.18
$ git bisect bad master
Bisecting: 3537 revisions left to test after this
[65934a9a028b88e83e2b0f8b36618fe503349f8e] BLOCK: Make USB storage depend on SCSI rather than selecting it [try #6]</pre><p>この時点で <code class="literal">git branch</code> を実行すると、Gitが一時的に あなたを "(no branch)"
に移動させたことがわかります。HEADはブランチから切り離され、「master」からは到達可能であるが v2.6.18
からは到達できないコミット(コミットID
65934)を直接指します。コンパイルしてテストし、クラッシュするかどうかを確認します。クラッシュするとします。ならばあなたは以下のようにします:</p><pre class="screen">$ git bisect bad
Bisecting: 1769 revisions left to test after this
[7eff82c8b1511017ae605f0c99ac275a7e21b867] i2c-core: Drop useless bitmaskings</pre><p>より古いバージョンをチェックアウトします。このように作業を続けて、各ステップで提供されるバージョンが良いか悪いかをGitに伝え、テストするために残されたリビジョンの数が毎回約半分に削減されることに注目してください。</p><p>(今回は)約13回のテストの後、有罪コミット(guilty commit)のコミットIDが出力されました。あなたは、次に、
<a class="ulink" href="git-show.html" target="_top">git-show(1)</a>
を使用してコミットを調べ、誰がコミットを作成したかを調べ、コミットIDを使用してバグレポートをメールで送信できます。そして最後に、あなたは以下を実行します:</p><pre class="screen">$ git bisect reset</pre><p>そうすると、あなたが以前にいたブランチに戻ります。</p><p>注意: <code class="literal">git bisect</code>
が各時点でチェックアウトするバージョンは単なる提案であり、そっちの方が良い考えであると思った場合は、別のバージョンを自由に試すことができることに注意してください。
たとえば、関係のない何かを壊したコミットにたどり着くことがあったりします。このようにしたいときは、以下のようにします。</p><pre class="screen">$ git bisect visualize</pre><p>これはgitkを実行し、選択したコミットに「bisect」というマーカーでラベルを付けます。近くで安全に見えるコミットを選択し、そのコミットIDをメモして、以下のコマンドでチェックアウトします:</p><pre class="screen">$ git reset --hard fb47ddb2db</pre><p>そしてテストし、必要に応じて「bisect good」または「bisect bad」を実行して続行します。</p><p><code class="literal">git bisect visualize</code> と <code class="literal">git reset --hard fb47ddb2db</code>
を行う代わりに、現在のコミットをスキップすることをGitに伝えたい場合があります:</p><pre class="screen">$ git bisect skip</pre><p>ただし、この場合、Gitは、最初にスキップされたコミットとその後の不正なコミットの間で、最初の不正なコミットを最終的に判断できない可能性があります。</p><p>良いコミットと悪いコミットを区別できるテストスクリプトがある場合は、bisecするプロセスを自動化する方法もあります。この機能およびその他の <code class="literal">git
bisect</code> 機能の詳細については、 <a class="ulink" href="git-bisect.html" target="_top">git-bisect(1)</a> を参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="naming-commits"></a>Naming commits</h2></div></div></div><p>コミットに名前を付けるいくつかの方法をすでに見てきました:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
16進40桁のオブジェクト名
</li><li class="listitem">
ブランチ名: 指定のブランチの先頭のコミットを参照します
</li><li class="listitem">
タグ名: 指定のタグが指すコミットを参照します(ブランチとタグは <a class="link" href="#how-git-stores-references" title="Naming branches, tags, and other references">参照</a>
          の特殊なケースです)。
</li><li class="listitem">
HEAD: 現在のブランチのheadを参照します
</li></ul></div><p>その他いろいろ: リビジョンに名前を付ける方法の完全なリストについては、 <a class="ulink" href="gitrevisions.html" target="_top">gitrevisions(7)</a>
のマニュアルページの「SPECIFYING REVISIONS」セクションを参照してください。 例をいくつか:</p><pre class="screen">$ git show fb47ddb2 # オブジェクト名の最初の数文字は、
                    # 通常、一意に指定するのに十分です。
$ git show HEAD^    # HEADコミットの親
$ git show HEAD^^   # 祖父母(grandparent;親の親)
$ git show HEAD~4   # 曽祖父母(great-great-grandparent)</pre><p>マージコミットには複数の親が存在する可能性があることを思い出してください。 デフォルトでは、 <code class="literal">^</code> と <code class="literal">~</code>
はそのコミットにリストされている最初の親を辿りますが、以下のように選択することもできます:</p><pre class="screen">$ git show HEAD^1   # HEADの(複数ある)親のうち1番目の親
$ git show HEAD^2   # HEADの複数ある親のうち2番目の親</pre><p>HEADに加えて、コミットには他にもいくつかの特別な名前があります:</p><p>マージ(後で説明します)、および現在チェックアウトされているコミットを変更する <code class="literal">git reset</code> などの操作では、通常、 ORIG_HEAD
を、「現在の操作の前にHEADが持っていた値」に設定します。</p><p><code class="literal">git fetch</code> 操作は、常に、最後にフェッチされたブランチのヘッドをFETCH_HEADに格納します。
たとえば、以下のように、操作のターゲットとしてローカルブランチを指定せずに <code class="literal">git fetch</code> を実行した場合</p><pre class="screen">$ git fetch git://example.com/proj.git theirbranch</pre><p>フェッチされたコミットは、引き続きFETCH_HEADから利用できます。</p><p>マージについて説明すると、現在のブランチにマージしている他のブランチを指す特別な名前MERGE_HEADもあります。</p><p><a class="ulink" href="git-rev-parse.html" target="_top">git-rev-parse(1)</a>
コマンドは、コミットの名前をそのコミットのオブジェクト名に変換するのに役立つことがある低レベルのコマンドです。</p><pre class="screen">$ git rev-parse origin
e05db0fd4f31dde7005f075a84f96b360d05984b</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creating-tags"></a>Creating tags</h2></div></div></div><p>特定のコミットを参照するタグを作成することもできます。以下を実行すると</p><pre class="screen">$ git tag stable-1 1b2e1d63ff</pre><p>あなたは <code class="literal">stable-1</code> を使用して、コミット <code class="literal">1b2e1d63ff</code> を参照できます。</p><p>これにより、「軽量」タグ(lightweight
tag)が作成されます。タグにコメントを含め、場合によっては暗号で署名する場合は、代わりにタグオブジェクトを作成する必要があります。詳細については、
<a class="ulink" href="git-tag.html" target="_top">git-tag(1)</a> のマニュアルページを参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="browsing-revisions"></a>Browsing revisions</h2></div></div></div><p><a class="ulink" href="git-log.html" target="_top">git-log(1)</a>
コマンドは、コミットのリストを表示できます。それ自体で、親コミットから到達可能なすべてのコミットが表示されますが、より具体的なリクエストを行うこともできます。</p><pre class="screen">$ git log v2.5..        # commits since (not reachable from) v2.5
$ git log test..master  # commits reachable from master but not test
$ git log master..test  # ...reachable from test but not master
$ git log master...test # ...reachable from either test or master,
                        #    but not both
$ git log --since="2 weeks ago" # commits from the last 2 weeks
$ git log Makefile      # commits which modify Makefile
$ git log fs/           # ... which modify any file under fs/
$ git log -S'foo()'     # commits which add or remove any file data
                        # matching the string 'foo()'</pre><p>そしてもちろん、これらすべてを組み合わせることができます。 以下は、 <code class="literal">Makefile</code> または <code class="literal">fs</code>
ディレクトリより下の任意のファイル、を触った v2.5 以降のコミットを検索します:</p><pre class="screen">$ git log v2.5.. Makefile fs/</pre><p>パッチを表示するようにgit logに依頼することもできます:</p><pre class="screen">$ git log -p</pre><p>その他の表示オプションについては、 <a class="ulink" href="git-log.html" target="_top">git-log(1)</a> のマニュアルページの <code class="literal">--pretty</code> オプションを参照してください。</p><p>git log は最新のコミットから始まり、親を介して逆方向に機能することに注意してください。
ただし、Gitの履歴には複数の独立した開発ラインが含まれる可能性があるため、コミットがリストされる順序は多少前後する可能性があります。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generating-diffs"></a>Generating diffs</h2></div></div></div><p><a class="ulink" href="git-diff.html" target="_top">git-diff(1)</a> を使用して、任意の2つのバージョン間の差分(diff)を生成できます。</p><pre class="screen">$ git diff master..test</pre><p>これにより、2つのブランチの先端の間にdiffが生じます。共通の祖先からのdiffを見つけてテストしたい場合は、2つではなく3つのドットを使用できます:</p><pre class="screen">$ git diff master...test</pre><p>しばしば、あなたが必要なのは差分の代わりにパッチのセットである場合があります。これには、 <a class="ulink" href="git-format-patch.html" target="_top">git-format-patch(1)</a>
を使用できます。</p><pre class="screen">$ git format-patch master..test</pre><p>これは、masterからではなく、testから到達可能な各コミットのパッチを含むファイルを生成します。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="viewing-old-file-versions"></a>Viewing old file versions</h2></div></div></div><p>あなたは、最初に正しいリビジョンをチェックアウトするだけで、いつでも古いバージョンのファイルを表示できます。ただし、何もチェックアウトせずに古いバージョンの単一ファイルを表示できる方が便利な場合もあります。以下のコマンドはそれを行います:</p><pre class="screen">$ git show v2.5:fs/locks.c</pre><p>コロン(<code class="literal">:</code>)の前にはコミットを指定するものがあり、その後にはGitによって追跡されているファイルへのパスがあります。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="history-examples"></a>Examples</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="counting-commits-on-a-branch"></a>Counting the number of commits on a branch</h3></div></div></div><p>あなたが <code class="literal">origin</code> から分岐して以来、 <code class="literal">mybranch</code> に対して行ったコミットの数を知りたいとします:</p><pre class="screen">$ git log --pretty=oneline origin..mybranch | wc -l</pre><p>あるいは、この種のことは、指定されたすべてのコミットのSHA-1を一覧表示するだけの低レベルのコマンド <a class="ulink" href="git-rev-list.html" target="_top">git-rev-list(1)</a>
で行われることがよくあります:</p><pre class="screen">$ git rev-list origin..mybranch | wc -l</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="checking-for-equal-branches"></a>2つのブランチが同じ履歴を指しているかどうかを確認します</h3></div></div></div><p>あなたが、2つのブランチが履歴の同じポイントを指しているかどうかを確認したいとします。</p><pre class="screen">$ git diff origin..master</pre><p>プロジェクトの内容が2つのブランチで同じであるかどうかがわかります。ただし、理論的には、同じプロジェクトの内容が2つの異なる履歴ルートによって到達された可能性があります。あなたはオブジェクト名を比較できます:</p><pre class="screen">$ git rev-list origin
e05db0fd4f31dde7005f075a84f96b360d05984b
$ git rev-list master
e05db0fd4f31dde7005f075a84f96b360d05984b</pre><p>または、 <code class="literal">...</code>
演算子は、一方の参照または他方の参照から到達可能なすべてのコミットを選択しますが、両方は選択しないことを思い出してください。ということで以下を実行すると</p><pre class="screen">$ git log origin...master</pre><p>この2つのブランチが等しい場合、コミットは返されません。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="finding-tagged-descendants"></a>指定の修正を含む最初のタグ付きバージョンを検索する</h3></div></div></div><p>コミット e05db0fd が特定の問題を修正したことを知っているとします。その修正を含む最も古いタグ付きリリースを見つけたいと思います。</p><p>ええ、もちろん、複数の答えがあるかもしれません。コミット e05db0fd
の後に履歴が分岐した場合、複数の「最も早い」タグ付きリリースが存在する可能性があります。</p><p>あなたは e05db0fd 以降のコミットを視覚的に検査できます:</p><pre class="screen">$ gitk e05db0fd..</pre><p>または、あなたは <a class="ulink" href="git-name-rev.html" target="_top">git-name-rev(1)</a>
を使用できます。これにより、コミットの子孫の1つを指すタグが見つかった場合は、そのコミットに名前が与えられます(訳注:コミットの子孫の1つを指すタグが
tags/v1.5.0-rc1 であったのでそこから辿って e05db0fd は tags/v1.5.0-rc1^0~23 という「名前」になった):</p><pre class="screen">$ git name-rev --tags e05db0fd
e05db0fd tags/v1.5.0-rc1^0~23</pre><p><a class="ulink" href="git-describe.html" target="_top">git-describe(1)</a> コマンドは逆のことを行い、指定されたコミットの基になっているタグを使用してリビジョンに名前を付けます:</p><pre class="screen">$ git describe e05db0fd
v1.5.0-rc0-260-ge05db0f</pre><p>これは、特定のコミット後にどのタグが来るかを推測するのに役立つ場合があります。</p><p>あなたが特定のタグ付きバージョンに特定のコミットが含まれているかどうかを確認したいだけの場合は、 <a class="ulink" href="git-merge-base.html" target="_top">git-merge-base(1)</a>
を使用できます:</p><pre class="screen">$ git merge-base e05db0fd v1.5.0-rc1
e05db0fd4f31dde7005f075a84f96b360d05984b</pre><p>merge-baseコマンドは、指定されたコミットの共通の祖先を検索し、一方が他方の子孫である場合は常にどちらか一方を返します。したがって、上記の出力は、e05db0fdが実際にはv1.5.0-rc1の祖先であることを示しています。</p><p>あるいは、以下のように</p><pre class="screen">$ git log v1.5.0-rc1..e05db0fd</pre><p>とすると、v1.5.0-rc1にe05db0fdが含まれている場合のみ、空の出力が生成されます。これは、v1.5.0-rc1から到達できないコミットのみを出力するためです。</p><p>さらに別の方法として、 <a class="ulink" href="git-show-branch.html" target="_top">git-show-branch(1)</a>
コマンドは、指定の引数から到達可能なコミットを一覧表示し、その各行の左側にそのコミットが指定のどの引数から到達可能かを示す表示を行います。よって、あなたが以下のようなものを実行する場合</p><pre class="screen">$ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2
! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if
available
 ! [v1.5.0-rc0] GIT v1.5.0 preview
  ! [v1.5.0-rc1] GIT v1.5.0-rc1
   ! [v1.5.0-rc2] GIT v1.5.0-rc2
...</pre><p>そしてこれに続く行は以下のようになります</p><pre class="screen">+ ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if
available</pre><p>これは、e05db0fdが、v1.5.0-rc0からではなく、v1.5.0-rc1とv1.5.0-rc2から到達可能であることを示しています。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="showing-commits-unique-to-a-branch"></a>指定のブランチに固有のコミットを表示する</h3></div></div></div><p><code class="literal">master</code> という名前のブランチヘッドから到達可能なすべてのコミットを確認したいが、リポジトリ内の他のヘッドからは到達できないと仮定します。</p><p><a class="ulink" href="git-show-ref.html" target="_top">git-show-ref(1)</a> を使用して、このリポジトリ内のすべてのヘッドを一覧表示できます。</p><pre class="screen">$ git show-ref --heads
bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial
db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint
a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master
24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2
1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes</pre><p>標準のユーティリティcutとgrepを使用して、ブランチヘッド名だけを取得し、 <code class="literal">master</code> を削除できます:</p><pre class="screen">$ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master'
refs/heads/core-tutorial
refs/heads/maint
refs/heads/tutorial-2
refs/heads/tutorial-fixes</pre><p>そして、masterから到達可能だけども他のヘッドからは到達できない全てのコミットを確認するように依頼できます:</p><pre class="screen">$ gitk master --not $( git show-ref --heads | cut -d' ' -f2 |
                                grep -v '^refs/heads/master' )</pre><p>このようにすれば、明らかに、無限のバリエーションが可能です。
たとえば、リポジトリ内のタグからではなく、あるヘッドから到達可能なすべてのコミットを表示するには、以下のようにします:</p><pre class="screen">$ gitk $( git show-ref --heads ) --not  $( git show-ref --tags )</pre><p>( <code class="literal">--not</code> などのコミット選択構文の説明については、 <a class="ulink" href="gitrevisions.html" target="_top">gitrevisions(7)</a> を参照してください。)</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="making-a-release"></a>Creating a changelog and tarball for a software release</h3></div></div></div><p><a class="ulink" href="git-archive.html" target="_top">git-archive(1)</a> コマンドは、プロジェクトの任意のバージョンからtarまたはzipアーカイブを作成できます。例えば:</p><pre class="screen">$ git archive -o latest.tar.gz --prefix=project/ HEAD</pre><p>HEADを使用して、各ファイル名の前に <code class="literal">project/</code>
が付いたgzip圧縮されたtarアーカイブを作成します。出力ファイル形式は、可能であれば出力ファイル拡張子から推測されます。詳細については
<a class="ulink" href="git-archive.html" target="_top">git-archive(1)</a> を参照してください。</p><p>1.7.7より古いバージョンのGitは、 `tar.gz`形式を認識していません。明示的にgzipを使用する必要があります:</p><pre class="screen">$ git archive --format=tar --prefix=project/ HEAD | gzip &gt;latest.tar.gz</pre><p>ソフトウェアプロジェクトの新しいバージョンをリリースする場合は、リリースアナウンスに含める変更ログを同時に作成することをお勧めします。</p><p>Linus Torvaldsは、たとえば、タグを付けて実行することにより、新しいカーネルリリースを作成します:</p><pre class="screen">$ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7</pre><p>ここで、release-script は以下のようなシェルスクリプトです:</p><pre class="screen">#!/bin/sh
stable="$1"
last="$2"
new="$3"
echo "# git tag v$new"
echo "git archive --prefix=linux-$new/ v$new | gzip -9 &gt; ../linux-$new.tar.gz"
echo "git diff v$stable v$new | gzip -9 &gt; ../patch-$new.gz"
echo "git log --no-merges v$new ^v$last &gt; ../ChangeLog-$new"
echo "git shortlog --no-merges v$new ^v$last &gt; ../ShortLog"
echo "git diff --stat --summary -M v$last v$new &gt; ../diffstat-$new"</pre><p>そしてそれから、シェルスクリプトが出力したコマンドが正常に見えることを確認した後、出力されたコマンドをカットアンドペーストします。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="Finding-commits-With-given-Content"></a>指定の内容を含むファイルを参照するコミットを検索する</h3></div></div></div><p>誰かがあなたにファイルのコピーを渡し、与えられた内容を含むようにファイルを変更したコミットを、そのコミットの前と後のどちらで行ったかを尋ねます。
それを知るには、以下のようにします:</p><pre class="screen">$  git log --raw --abbrev=40 --pretty=oneline |
        grep -B 1 `git hash-object filename`</pre><p>なぜこれが機能するのかを理解することは、(上級)学生への演習として残されています。 <a class="ulink" href="git-log.html" target="_top">git-log(1)</a> や
<a class="ulink" href="git-diff-tree.html" target="_top">git-diff-tree(1)</a> や <a class="ulink" href="git-hash-object.html" target="_top">git-hash-object(1)</a> のマニュアルページが役に立つ事でしょう。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="Developing-With-git"></a>Chapter 3. Gitでの開発作業</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#telling-git-your-name">あなたの名前をGitに教える</a></span></dt><dt><span class="section"><a href="#creating-a-new-repository">Creating a new repository</a></span></dt><dt><span class="section"><a href="#how-to-make-a-commit">How to make a commit</a></span></dt><dt><span class="section"><a href="#creating-good-commit-messages">適切なコミットメッセージの作成</a></span></dt><dt><span class="section"><a href="#ignoring-files">Ignoring files</a></span></dt><dt><span class="section"><a href="#how-to-merge">How to merge</a></span></dt><dt><span class="section"><a href="#resolving-a-merge">Resolving a merge</a></span></dt><dd><dl><dt><span class="section"><a href="#conflict-resolution">マージ作業中に競合解決の助けを得る</a></span></dt></dl></dd><dt><span class="section"><a href="#undoing-a-merge">マージを元に戻す</a></span></dt><dt><span class="section"><a href="#fast-forwards">Fast-forward merges</a></span></dt><dt><span class="section"><a href="#fixing-mistakes">作業ミスを修正する</a></span></dt><dd><dl><dt><span class="section"><a href="#reverting-a-commit">新しいコミットによって作業ミスを修正する</a></span></dt><dt><span class="section"><a href="#fixing-a-mistake-by-rewriting-history">履歴を巻き戻す事によって作業ミスを修正する</a></span></dt><dt><span class="section"><a href="#checkout-of-path">Checking out an old version of a file</a></span></dt><dt><span class="section"><a href="#interrupted-work">作業中の作業を一時的に保存しておく</a></span></dt></dl></dd><dt><span class="section"><a href="#ensuring-good-performance">良好なパフォーマンスの確保</a></span></dt><dt><span class="section"><a href="#ensuring-reliability">信頼性の確保</a></span></dt><dd><dl><dt><span class="section"><a href="#checking-for-corruption">リポジトリの破損をチェックする</a></span></dt><dt><span class="section"><a href="#recovering-lost-changes">失われた変更の回復</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="telling-git-your-name"></a>あなたの名前をGitに教える</h2></div></div></div><p>コミットを作成する前に、あなた自身をGitに紹介すべきです。これを行う最も簡単な方法は、 <a class="ulink" href="git-config.html" target="_top">git-config(1)</a>
を使用することです:</p><pre class="screen">$ git config --global user.name 'Your Name Comes Here'
$ git config --global user.email 'you@yourdomain.example.com'</pre><p>これにより、あなたのホームディレクトリの <code class="literal">.gitconfig</code> という名前のファイルに以下のものが追加されます:</p><pre class="screen">[user]
        name = Your Name Comes Here
        email = you@yourdomain.example.com</pre><p>構成ファイルの詳細については、 <a class="ulink" href="git-config.html" target="_top">git-config(1)</a>の「CONFIGURATION
FILE」セクションを参照してください。ファイルはプレーンテキストなので、お気に入りのエディタで編集することもできます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creating-a-new-repository"></a>Creating a new repository</h2></div></div></div><p>新しいリポジトリをイチから作成するのは非常に簡単です:</p><pre class="screen">$ mkdir project
$ cd project
$ git init</pre><p>初期コンテンツ(たとえば tarball)がある場合:</p><pre class="screen">$ tar xzvf project.tar.gz
$ cd project
$ git init
$ git add . # include everything below ./ in the first commit:
$ git commit</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-to-make-a-commit"></a>How to make a commit</h2></div></div></div><p>新しいコミットの以下の3つのステップがあります:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
あなたのお気に入りのエディタを使用して、作業ディレクトリでいくつかの変更を加えます。
</li><li class="listitem">
あなたの変更をGitに知らせます。
</li><li class="listitem">
手順2でGitに知らせた内容でコミットを作成します。
</li></ol></div><p>実際には、あなたが望むかぎりステップ1と2を何度でも行き来したり繰り返したりすることができます。ステップ3でコミットしたい内容を追跡するために、Gitは「インデックス」(index)と呼ばれる特別なステージング領域にツリーのコンテンツのスナップショットを保持します。</p><p>最初は、インデックスの内容はHEADの内容と同じになります。したがって、HEADとインデックスの違いを示すコマンド <code class="literal">git diff
--cached</code> は、その時点では何も出力を生成しないはずです。</p><p>インデックスの変更は簡単です:</p><p>新規または変更されたファイルの内容でインデックスを更新するには、以下を使用します</p><pre class="screen">$ git add path/to/file</pre><p>インデックスと作業ツリーからファイルを削除するには、以下を使用します</p><pre class="screen">$ git rm path/to/file</pre><p>各ステップの後、あなたは以下のようにして確認できます</p><pre class="screen">$ git diff --cached</pre><p>常にHEADとインデックスファイルの違い示します(つまり、今、この時点でコミットを作成した場合、何がコミットされる事になるのかを知る事ができます)</p><pre class="screen">$ git diff</pre><p>これは、作業ツリーとインデックスファイルの違いを示しています。</p><p>注意: <code class="literal">git add</code> は常に、ファイルのその時点での内容をインデックスに追加するだけであることに注意してください。同じファイルに対して <code class="literal">git
add</code> を再度実行しない限り、そのファイルへのその後の編集変更は無視されます。</p><p>準備ができたら、あとは実行するだけです</p><pre class="screen">$ git commit</pre><p>Gitはコミットメッセージの入力を求め、新しいコミットを作成します。以下のようにして、それがあなたが期待したもののように見えることをチェックしてください</p><pre class="screen">$ git show</pre><p>特別な省略形として、以下があります</p><pre class="screen">$ git commit -a</pre><p>これは、変更または削除したファイルでインデックスを更新し、コミットを作成します。それらを1ステップで実行します。</p><p>あなたの行ったコミットを追跡するために、いくつかのコマンドが役立ちます</p><pre class="screen">$ git diff --cached # HEADとインデックス間の差異。
                    # 今、コミットを実行したら何がコミットされるかを知る。
$ git diff          # インデックスファイルと作業ディレクトリの違い。
                    # 今、コミットを実行したら、
                    # 何がそのコミットに「含まれない」かを知る。
$ git diff HEAD     # HEADと作業ツリーの違い。
                    # 今、 `commit -a` を実行したら何がコミットされるかを知る。
$ git status        # 上記のファイルごとの簡単な要約。</pre><p><a class="ulink" href="git-gui.html" target="_top">git-gui(1)</a>
を使用して、コミットを作成し、インデックスと作業ツリーファイルの変更を表示し、インデックスに含めるdiffハンクを個別に選択することもできます(diffハンクを右クリックして「Stage
Hunk For Commit」を選択します)。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creating-good-commit-messages"></a>適切なコミットメッセージの作成</h2></div></div></div><p>必須ではありませんが、変更を要約した1行の短い行(50文字未満)でコミットメッセージを開始し、その後に空行を続け、さらに詳細な説明を続けることをお勧めします。
コミットメッセージの最初の空行までのテキストはコミットタイトルとして扱われ、そのタイトルはGit全体で使用されます。たとえば、
<a class="ulink" href="git-format-patch.html" target="_top">git-format-patch(1)</a>
はコミットを電子メールに変換し、コミットタイトルを件名に使用し、コミットタイトル以降を本文として使用します。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ignoring-files"></a>Ignoring files</h2></div></div></div><p>プロジェクトは、Gitで追跡したくないファイルを生成することがよくあります。これには通常、ビルドプロセスによって生成されたファイル、またはエディターによって作成された一時バックアップファイルが含まれます。もちろん、Gitでファイルを追跡しないのは、ファイルに対して「git
add」を呼び出さないだけの問題です。しかし、これらの追跡されていないファイルがたくさん横たわっているのはすぐにうっとおしくなります。例えば それらは
<code class="literal">git add .</code> を実質的に役に立たなくし、 <code class="literal">git status</code> の出力に表示され続けます。</p><p>あなたは、作業ディレクトリの最上位に <code class="literal">.gitignore</code>
というファイルを作成し、以下のような内容で特定のファイルを無視するようにGitに指示できます:</p><pre class="screen"># '＃'で始まる行はコメントと見なされます。
# foo.txtという名前のファイルはすべて無視してください。
foo.txt
# (生成された) htmlファイルを無視します。
*.html
# 但し、手作業で管理されているfoo.htmlを除きます(無視しません)。
!foo.html
# オブジェクト(*.o)とアーカイブ(*.a)を無視します。
*.[oa]</pre><p>構文の詳細な説明については、 <a class="ulink" href="gitignore.html" target="_top">gitignore(5)</a> を参照してください。作業ツリーの他のディレクトリに .gitignore
ファイルを配置することもでき、それらはそれらのディレクトリとその下のサブディレクトリに適用されます。 <code class="literal">.gitignore</code>
ファイルは、他のファイルと同じようにリポジトリに追加できます
.(通常どおり <code class="literal">git add .gitignore</code> と <code class="literal">git commit</code> を実行するだけです)。
これは、除外パターン(ビルド出力ファイルに一致するパターンなど)の場合に便利です。リポジトリのクローンを作成する他のユーザーにとっても意味があります。&lt;</p><p>除外パターンが(特定のプロジェクトのすべてのリポジトリではなく、)特定のリポジトリにのみ影響するようにする場合は、代わりに、リポジトリ内の
<code class="literal">.git/info/exclude</code> という名前のファイル、または <code class="literal">core.excludesFile</code>
構成変数で指定されたファイルに除外パターンを配置できます。一部のGitコマンドは、コマンドラインで直接除外パターンを指定することもできます。詳細については、
<a class="ulink" href="gitignore.html" target="_top">gitignore(5)</a> を参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-to-merge"></a>How to merge</h2></div></div></div><p><a class="ulink" href="git-merge.html" target="_top">git-merge(1)</a>を使用して、2つに分岐したブランチを再結合できます:</p><pre class="screen">$ git merge branchname</pre><p>ブランチ <code class="literal">branchname</code> を現在のブランチにマージします。</p><p>マージは、 <code class="literal">branchname</code>
で行われた変更と、履歴が分岐してから現在のブランチで最新のコミットまでに行われた変更とを組み合わせることによって行われます。作業ツリーは、この結合がクリーンに実行された場合はマージの結果によって上書きされ、この結合が競合を引き起こした場合は半マージ(half-merged)された結果によって上書きされます。したがって、マージの影響を受けたファイルと同じファイルに変更を加えたコミットされていない変更がある場合、Gitは続行を拒否します。ほとんどの場合、マージする前に変更をコミットする必要があります。コミットしない場合は、
<a class="ulink" href="git-stash.html" target="_top">git-stash(1)</a> を使用すると、マージ中にこれらの変更を一旦取り除いて、後で再適用できます。</p><p>変更が十分に独立している場合、Gitは自動的にマージを完了し、結果をコミットします(または、<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>の場合は、既存のコミットを再利用します。これについては以下を参照してください)。
一方、競合がある場合—たとえば、リモートブランチとローカルブランチで同じファイルが異なる方法で変更された場合—は警告が表示されます。出力は以下のようになります:</p><pre class="screen">$ git merge next
 100% (4/4) done
Auto-merged file.txt
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.</pre><p>問題のあるファイルには競合マーカーが残ります(訳注:つまり そのファイルは git merge
が編集したものです)。あなたは競合を手動で解決した後(訳注:当該ファイルを手動で編集してセーブして)、新しいファイルを作成するときと同じように、インデックスを更新してGit
commitを実行できます。</p><p>あなたがgitkを使用して結果のコミットを調べると、2つの親があり、1つは現在のブランチの先頭を指し、もう1つはもう一方のブランチの先頭を指していることがわかるはずです。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resolving-a-merge"></a>Resolving a merge</h2></div></div></div><p>マージが自動的に解決されない場合、Gitはインデックスと作業ツリーを特別な状態のままにして、マージの解決に必要なすべての情報を提供します。</p><p>特に、競合のあるファイルはインデックスでマークされるため、問題を解決してインデックスを更新するまで、 <a class="ulink" href="git-commit.html" target="_top">git-commit(1)</a>
は失敗します:</p><pre class="screen">$ git commit
file.txt: needs merge</pre><p>また、 <a class="ulink" href="git-status.html" target="_top">git-status(1)</a> は、これらのファイルを "unmerged"
としてリストし、競合のあるファイルの内容には、以下のように競合マーカー(conflict
marker)が追加されます(訳注:ファイルの内容が以下のように変更されます):</p><pre class="screen">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:file.txt
Hello world
=======
Goodbye
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 77976da35a11db4580b80ae27e8d65caf5208086:file.txt</pre><p>あなたしなければならないことは、競合を解決するためにファイルを編集することです。そしてその後、以下のようにします。</p><pre class="screen">$ git add file.txt
$ git commit</pre><p>注意: コミットメッセージには、マージに関するいくつかの情報がすでに入力されていることに注意してください。
通常、このデフォルトのメッセージは変更せずに使用できますが、必要に応じて独自のコメントを追加することもできます。</p><p>単純なマージを解決するために知っておく必要があるのは、上記ですべてです。 ただし、Gitは、競合の解決に役立つ詳細情報も提供します:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="conflict-resolution"></a>マージ作業中に競合解決の助けを得る</h3></div></div></div><p>Gitが自動的にマージできたすべての変更は、すでにインデックスファイルに追加されているため、 <a class="ulink" href="git-diff.html" target="_top">git-diff(1)</a>
は競合のみを表示します。それは普通でない構文を使用します:</p><pre class="screen">$ git diff
diff --cc file.txt
index 802992c,2b60207..0000000
--- a/file.txt
+++ b/file.txt
@@@ -1,1 -1,1 +1,5 @@@
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:file.txt
 +Hello world
++=======
+ Goodbye
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; 77976da35a11db4580b80ae27e8d65caf5208086:file.txt</pre><p>この競合を解決した後にコミットされるコミットには、通常の親ではなく2つの親があることを思い出してください。1つの親は現在のブランチの先端であるHEADになります。もう一方は、MERGE_HEADに一時的に保存されるもう一方のブランチの先端になります。</p><p>マージ中、インデックスは各ファイルについて3つのバージョンを保持します。これらの3つの「ファイルステージ」(file
stages)はそれぞれ、ファイルの異なるバージョンを表します。</p><pre class="screen">$ git show :1:file.txt  # 両方のブランチの共通の祖先にあるファイル
$ git show :2:file.txt  # the version from HEAD.
$ git show :3:file.txt  # the version from MERGE_HEAD.</pre><p><a class="ulink" href="git-diff.html" target="_top">git-diff(1)</a>
に競合を表示するように要求すると、競合するマージ結果間で3方向のdiffが実行され、ステージ2と3の作業ツリーで、内容がステージ2と3の両方があるハンクのみが混合されて表示されます(つまり、ハンクのマージ結果がステージ2からのみ取得される場合、その部分は競合せず、表示されません。ステージ3についても同じで、ハンクのマージ結果がステージ3からのみ取得される場合、その部分は競合せず、表示されません)。</p><p>上記の差分は、file.txt
の作業ツリーバージョンと、ステージ2バージョンと、ステージ3バージョンとの間の違いを示しています。したがって、各行の前に単一の <code class="literal">+</code> または <code class="literal">-</code>
を付ける代わりに、2つの桁を使用するようになりました。最初の桁は最初の親と作業ディレクトリのコピーの違いに使用され、2番目の列は2番目の親と
作業ディレクトリのコピーの違いに使用されます。（形式の詳細については、 linkgit: git-diff-files[1] の「COMBINED
DIFF FORMAT」セクションを参照してください。)</p><p>あなたが編集するなどして、ちゃんと競合を解決した後(ただし、インデックスを更新する前)でdiffを実行してみると以下のようになります:</p><pre class="screen">$ git diff
diff --cc file.txt
index 802992c,2b60207..0000000
--- a/file.txt
+++ b/file.txt
@@@ -1,1 -1,1 +1,1 @@@
- Hello world
 -Goodbye
++Goodbye world</pre><p>これは、解決されたバージョンが最初の親から「Hello
world」を削除し、2番目の親から「Goodbye」を削除し、以前は両方に存在しなかった「Goodbye world」を追加したことを示しています。</p><p>いくつかの特別なdiffオプションを使用すると、これらのステージのいずれかに対して作業ディレクトリとdiffを取ることができます:</p><pre class="screen">$ git diff -1 file.txt          # diff against stage 1
$ git diff --base file.txt      # same as the above
$ git diff -2 file.txt          # diff against stage 2
$ git diff --ours file.txt      # same as the above
$ git diff -3 file.txt          # diff against stage 3
$ git diff --theirs file.txt    # same as the above.</pre><p><a class="ulink" href="git-log.html" target="_top">git-log(1)</a> や <a class="ulink" href="gitk.html" target="_top">gitk(1)</a> コマンドも、マージのためにに特別な援助を提供します:</p><pre class="screen">$ git log --merge
$ gitk --merge</pre><p>これらは、HEADまたはMERGE_HEADにのみ存在し、マージされていないファイルにアクセスするすべてのコミットを表示します。</p><p>あなたは <a class="ulink" href="git-mergetool.html" target="_top">git-mergetool(1)</a>
を使用することもできます。これにより、Emacsやkdiff3などの外部ツールを使用してマージされていないファイルをマージできます。</p><p>ファイル内の競合を解決するたびに、以下のようにしてインデックスを更新します:</p><pre class="screen">$ git add file.txt</pre><p>そうすると、そのファイルのさまざまなステージが「折りたたまれ」(collapsed)、その後、 <code class="literal">git diff</code>
は(デフォルトでは)そのファイルのdiffを表示しなくなります。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="undoing-a-merge"></a>マージを元に戻す</h2></div></div></div><p>行き詰まり、あきらめて、混乱全体を捨てることにした場合は、いつでもマージ前の状態に戻ることができます</p><pre class="screen">$ git merge --abort</pre><p>または、あなたが破棄したいマージをすでにコミットしちゃってる場合は以下です</p><pre class="screen">$ git reset --hard ORIG_HEAD</pre><p>ただし、この最後のコマンドは危険な場合があります。コミット自体が別のブランチにマージされている可能性がある場合は、既にコミット済のコミットを破棄しないでください。これを行うと、さらにマージが混乱する可能性があります。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fast-forwards"></a>Fast-forward merges</h2></div></div></div><p>上記に記載されていない特殊なケースが1つあり、それは異なる方法で処理されます。通常、マージは、マージされた2つの開発ラインのそれぞれを指す2つの親を持つマージコミットをもたらします。</p><p>けれども、現在のブランチが他のブランチの祖先である場合(したがって、現在のブランチに存在するすべてのコミットは、すでに他のブランチに含まれています)、Gitは「fast-forward」(早送り)を実行するだけです。現在のブランチのヘッドは、新しいコミットが作成されることなく、マージされたブランチのヘッドを指すように前方に移動されます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fixing-mistakes"></a>作業ミスを修正する</h2></div></div></div><p>作業ツリーを台無しにしたが、まだ間違いをコミットしていない場合は、作業ツリー全体を最後にコミットした状態に戻すことができます</p><pre class="screen">$ git restore --staged --worktree :/</pre><p>コミットしたのを後悔した時、問題を解決するためには、根本的に異なる2つの方法があります:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
あなたは、古いコミットによって行われたことをすべて元に戻す新しいコミットを作成できます。
        あなたの間違いがすでに公表されているなら、これは正しいことです。
</li><li class="listitem">
あなたは、履歴を遡って古いコミットを変更できます。
        すでに履歴を公開している場合は、これは絶対にやってはいけません。Gitは通常、プロジェクトの「履歴」が変更されることを期待しておらず、履歴が変更されたブランチから繰り返しマージを正しく実行することはできません。
</li></ol></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reverting-a-commit"></a>新しいコミットによって作業ミスを修正する</h3></div></div></div><p>以前の変更を元に戻す新しいコミットを作成するのは非常に簡単です。 <a class="ulink" href="git-revert.html" target="_top">git-revert(1)</a>
コマンドに不正なコミットへの参照を渡すだけです。たとえば、最新のコミットを元に戻すには、以下のようにします:</p><pre class="screen">$ git revert HEAD</pre><p>これにより、HEADの変更を元に戻す新しいコミットが作成されます。そしてあなたには新しいコミットのコミットメッセージを編集する機会が与えられます。</p><p>以前の変更を元に戻すこともできます。たとえば、最後から2番目を指定します:</p><pre class="screen">$ git revert HEAD^</pre><p>この場合、Gitは古い変更を元に戻そうとしますが、それ以降に行われた変更はそのまま残します。最近の変更が元に戻す変更と重複する場合は、<a class="link" href="#resolving-a-merge" title="Resolving a merge">resolving a merge</a>の場合と同様に、競合を手動で修正するように求められます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fixing-a-mistake-by-rewriting-history"></a>履歴を巻き戻す事によって作業ミスを修正する</h3></div></div></div><p>問題のあるコミットが最新のコミットであり、そのコミットをまだ公開していない場合は、<a class="link" href="#undoing-a-merge" title="マージを元に戻す"><code class="literal">git reset</code> を使用して破棄</a>することができます。</p><p>あるいは、<a class="link" href="#how-to-make-a-commit" title="How to make a commit">create a new commit</a>を実行する場合と同じように、作業ディレクトリを編集してインデックスを更新し、間違いを修正することもできます。</p><pre class="screen">$ git commit --amend</pre><p>これにより、古いコミットが変更を組み込んだ新しいコミットに置き換えられ、最初に古いコミットメッセージの方を編集する機会が与えられます。</p><p>繰り返しになりますが、すでに別のブランチにマージされている可能性のあるコミットに対してこれを実行しないでください。 その場合は、代わりに
<a class="ulink" href="git-revert.html" target="_top">git-revert(1)</a> を使用してください。</p><p>履歴のさらに古いコミットを置き換えることも可能ですが、これは<a class="link" href="#cleaning-up-history" title="Chapter 5. Rewriting history and maintaining patch series">別の章</a>で扱う高度なトピックです。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="checkout-of-path"></a>Checking out an old version of a file</h3></div></div></div><p>以前の悪い変更を元に戻すプロセスでは、 <a class="ulink" href="git-restore.html" target="_top">git-restore(1)</a>
を使用して特定のファイルの古いバージョンをチェックアウトすると便利な場合があります。</p><pre class="screen">$ git restore --source=HEAD^ path/to/file</pre><p>これは path/to/fileを、コミットHEAD^にある内容に置き換え、それに一致するようにインデックスを更新します。ブランチは変更されません。</p><p>作業ディレクトリを変更せずに古いバージョンのファイルを確認したい場合は、 <a class="ulink" href="git-show.html" target="_top">git-show(1)</a> を使用して確認できます:</p><pre class="screen">$ git show HEAD^:path/to/file</pre><p>これにより、指定のバージョンのファイルが表示されます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="interrupted-work"></a>作業中の作業を一時的に保存しておく</h3></div></div></div><p>何か複雑なことに取り組んでいる最中に、無関係であるが明白で些細なバグを見つけたとします。取り組みを続行する前にちょいと修正したいと思います。
<a class="ulink" href="git-stash.html" target="_top">git-stash(1)</a>
を使用して作業の現在の状態を保存(stash;隠す)し、バグを修正した後(または、オプションで別のブランチで修正してから戻ってきた後)、保存(stash)しておいた進行中の変更を取り戻し(unstash)ます。</p><pre class="screen">$ git stash push -m "work in progress for foo feature"</pre><p>このコマンドは、変更を <code class="literal">stash</code>
に保存し、現在のブランチの先端に一致するように作業ツリーとインデックスをリセットします。その後、通常どおりに(ちょいと)修正を行うことができます。</p><pre class="screen">... edit and test ...
$ git commit -a -m "blorpl: typofix"</pre><p>その後、 <code class="literal">git stash pop</code> で作業していたのに戻ることができます:</p><pre class="screen">$ git stash pop</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ensuring-good-performance"></a>良好なパフォーマンスの確保</h2></div></div></div><p>大規模なリポジトリでは、Gitは圧縮に頼って、履歴情報がディスクまたはメモリ内のスペースを占有しすぎないようにします。 一部のGitコマンドは
<a class="ulink" href="git-gc.html" target="_top">git-gc(1)</a> を自動的に実行する可能性があるため、手動で実行することを心配する必要はありません。
ただし、大規模なリポジトリの圧縮には時間がかかる場合があるため、都合の悪いときに自動圧縮が開始されないように、明示的に <code class="literal">gc</code>
を呼び出すことをお勧めします。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ensuring-reliability"></a>信頼性の確保</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="checking-for-corruption"></a>リポジトリの破損をチェックする</h3></div></div></div><p><a class="ulink" href="git-fsck.html" target="_top">git-fsck(1)</a>
コマンドは、リポジトリに対していくつかの自己整合性チェックを実行し、問題があれば報告します。これには時間がかかる場合があります。</p><pre class="screen">$ git fsck
dangling commit 7281251ddd2a61e38657c827739c57015671a6b3
dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63
dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5
dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb
dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f
dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e
dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085
dangling tree b24c2473f1fd3d91352a624795be026d64c8841f
...</pre><p>宙ぶらりんオブジェクト(dangling
objects)に関するinfoメッセージが表示されます。これらはリポジトリにまだ存在しているが、どのブランチからも参照されていないオブジェクトであり、しばらくすると
<code class="literal">gc</code> を使用して削除できます(削除される予定です)。 <code class="literal">git fsck --no-dangling</code>
を実行してこれらのinfoメッセージを抑制し、errorメッセージだけを表示することができます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="recovering-lost-changes"></a>失われた変更の回復</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reflogs"></a>Reflogs</h4></div></div></div><p><a class="link" href="#fixing-mistakes" title="作業ミスを修正する"><code class="literal">git reset
--hard</code></a>を使用してブランチを変更し、そのブランチが履歴内のその時点への唯一の参照であることに気付いたとします。</p><p>幸い、Gitには、各ブランチの以前の値のすべてを保持する「reflog」と呼ばれるログがあります。したがって、この場合でも、たとえば、以下を使用して古い履歴を見つけることができます。</p><pre class="screen">$ git log master@{1}</pre><p>これは、以前のバージョンの <code class="literal">master</code> ブランチヘッドから到達可能なコミットを一覧表示します。 この構文は、 <code class="literal">git log</code>
だけでなく、コミットを受け入れる任意のGitコマンドで使用できます。 他のいくつかの例:</p><pre class="screen">$ git show master@{2}           # See where the branch pointed 2,
$ git show master@{3}           # 3, ... changes ago.
$ gitk master@{yesterday}       # See where it pointed yesterday,
$ gitk master@{"1 week ago"}    # ... or last week
$ git log --walk-reflogs master # show reflog entries for master</pre><p>HEAD用には個別のreflogが保持されるため、以下のようにできます</p><pre class="screen">$ git show HEAD@{"1 week ago"}</pre><p>現在のブランチが1週間前に指し示したものではなく、HEADが1週間前に指し示したものを表示します。これにより、チェックアウトした内容の履歴を確認できます。</p><p>reflogはデフォルトで30日間保持され、その後、たぶん刈り取られます(prune)。この刈り取りを制御する方法については、
<a class="ulink" href="git-reflog.html" target="_top">git-reflog(1)</a> や linkgit:git-gc [1] を参照してください。詳細については、
<a class="ulink" href="gitrevisions.html" target="_top">gitrevisions(7)</a>の「SPECIFYING REVISIONS」セクションを参照してください。</p><p>注意:
reflogの履歴は、通常のGitの履歴とは大きく異なることに注意してください。通常の履歴は同じプロジェクトで動作するすべてのリポジトリで共有されますが、reflogの履歴は共有されません。reflogは、ローカルリポジトリのブランチが時間の経過とともにどのように変化したかについてのみ通知します。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dangling-object-recovery"></a>Examining dangling objects(宙ぶらりんオブジェクトを調べる)</h4></div></div></div><p>状況によっては、reflogで保存できない場合があります。たとえば、ブランチを削除して、そこに含まれる履歴が必要であることに気付いたとします。reflogも削除されます。ただし、リポジトリをまだ刈り取りしていない場合でも、
<code class="literal">git fsck</code> が報告する宙ぶらりんオブジェクトで失われたコミットを見つけることができる場合があります。 詳細については、
<a class="xref" href="#dangling-objects" title="Dangling objects(宙ぶらりんオブジェクト)">the section called “Dangling objects(宙ぶらりんオブジェクト)”</a>を参照してください。</p><pre class="screen">$ git fsck
dangling commit 7281251ddd2a61e38657c827739c57015671a6b3
dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63
dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5
...</pre><p>あなたは、たとえば、以下のようにして、これらの宙ぶらりんコミットの1つを調べることができます。</p><pre class="screen">$ gitk 7281251ddd --not --all</pre><p>これを言葉で説明すると、つまり、宙ぶらりんコミットによって記述されたコミット履歴を表示したいが、既存のすべてのブランチとタグによって記述された履歴は表示したくないということです。したがって、失われたコミットから到達可能な履歴を正確に取得できます。(そして、それが1つのコミットだけではない可能性があることに注意してください。これは「開発ラインの先端」(tip
of the line)が宙ぶらりんだと報告するだけです。がしかし、全体に渡る深く複雑なコミット履歴が削除された可能性があります。)</p><p>履歴を元に戻したい場合は、いつでもそれを指す新しい参照を作成できます。たとえば、新しいブランチを作成できます:</p><pre class="screen">$ git branch recovered-branch 7281251ddd</pre><p>他のタイプの宙ぶらりんオブジェクト(ブロブとツリー)でもこれは可能であり、宙ぶらりんオブジェクトは他の状況でも発生する可能性があります。</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sharing-development"></a>Chapter 4. Sharing development with others</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#getting-updates-With-git-pull">Getting updates with git pull</a></span></dt><dt><span class="section"><a href="#submitting-patches">Submitting patches to a project</a></span></dt><dt><span class="section"><a href="#importing-patches">Importing patches to a project</a></span></dt><dt><span class="section"><a href="#public-repositories">Public Git repositories</a></span></dt><dd><dl><dt><span class="section"><a href="#setting-up-a-public-repository">Setting up a public repository</a></span></dt><dt><span class="section"><a href="#exporting-via-git">Gitプロトコルを介したGitリポジトリのエクスポート</a></span></dt><dt><span class="section"><a href="#exporting-via-http">Exporting a git repository via HTTP</a></span></dt><dt><span class="section"><a href="#pushing-changes-to-a-public-repository">Pushing changes to a public repository</a></span></dt><dt><span class="section"><a href="#forcing-push">プッシュが失敗した場合の対処方法</a></span></dt><dt><span class="section"><a href="#setting-up-a-shared-repository">Setting up a shared repository</a></span></dt><dt><span class="section"><a href="#setting-up-gitweb">Allowing web browsing of a repository</a></span></dt></dl></dd><dt><span class="section"><a href="#how-to-get-a-git-repository-with-minimal-history">最小限の履歴でGitリポジトリを取得する方法</a></span></dt><dt><span class="section"><a href="#sharing-development-examples">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#maintaining-topic-branches">Maintaining topic branches for a Linux subsystem maintainer</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="getting-updates-With-git-pull"></a>Getting updates with git pull</h2></div></div></div><p>リポジトリのクローンを作成し、あなた独自の変更をいくつかコミットした後、元のリポジトリで更新を確認し、それらをあなた独自の作業にマージすることをお勧めします。</p><p><a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a>
を使用した<a class="link" href="#Updating-a-repository-With-git-fetch" title="Updating a repository with git fetch">リモート追跡ブランチを最新の状態に保つ方法</a>や、2つのブランチをマージする方法についてはすでに説明しました。したがって、元のリポジトリのmasterブランチからの変更を以下のようにマージできます:</p><pre class="screen">$ git fetch
$ git merge origin/master</pre><p>しかしながら、 <a class="ulink" href="git-pull.html" target="_top">git-pull(1)</a> コマンドは、これを1ステップで実行する方法を提供します:</p><pre class="screen">$ git pull origin master</pre><p>実際、 あなたが <code class="literal">master</code> をチェックアウトしている場合、このブランチは、元のリポジトリのHEADブランチから変更を取得するように <code class="literal">git
clone</code> 実行時に構成済です。多くの場合、以下のように単純なもので上記を達成できます</p><pre class="screen">$ git pull</pre><p>このコマンドは、リモートブランチからリモート追跡ブランチ <code class="literal">origin/*</code>
に変更をフェッチし、そのデフォルトブランチを現在のブランチにマージします。</p><p>より一般的には、リモート追跡ブランチから作成されたブランチは、デフォルトでそのリモート追跡ブランチからプルされます。これらのデフォルトを制御する方法を学ぶためには、
<a class="ulink" href="git-config.html" target="_top">git-config(1)</a> の <code class="literal">branch.&lt;name&gt;.remote</code> や <code class="literal">branch.&lt;name&gt;.merge</code>
オプションの説明と、 <a class="ulink" href="git-checkout.html" target="_top">git-checkout(1)</a> の <code class="literal">--track</code> オプションの説明を参照してください。</p><p><code class="literal">git pull</code>
はキーストロークを節約するだけでなく、プル元のブランチとリポジトリを文書化したデフォルトのコミットメッセージを生成するのにも役立ちます。</p><p>(注意:
ただし、<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>の場合、そのようなコミットは作成されないことに注意してください。代わりに、アップストリームブランチからの最新のコミットを指すようにブランチが更新されます。)</p><p><code class="literal">git pull</code> コマンドに「リモートリポジトリ」として <code class="literal">.</code>
を指定することもできます。この場合、現在のリポジトリからのブランチにマージされます。</p><pre class="screen">$ git pull . branch
$ git merge branch</pre><p>よってこれらは、ほぼ同等です。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="submitting-patches"></a>Submitting patches to a project</h2></div></div></div><p>変更がいくつかある場合、それらを送信する最も簡単な方法は、パッチとして電子メールで送信することです:</p><p>まずは <a class="ulink" href="git-format-patch.html" target="_top">git-format-patch(1)</a> の使用例です:</p><pre class="screen">$ git format-patch origin</pre><p>そうすると、現在のディレクトリに番号付きの一連のファイルを生成します。現在のブランチのパッチごとに1つですが、 <code class="literal">origin/HEAD</code>
についてのモノはありません。</p><p><code class="literal">git format-patch</code> は、最初に送付状(cover letter)を付けることができます。 <code class="literal">format-patch</code>
がコミットメッセージの後、パッチ自体の前に配置する3つの破線(<code class="literal">---</code>)の後に、個々のパッチに関するコメントを挿入できます。送付状の素材を追跡するために
<code class="literal">git notes</code> を使用する場合、<code class="literal">git format-patch --notes</code> は同様の方法でコミットのnoteを含みます。</p><p>次に、これらをメールクライアントにインポートして、手動で送信できます。 ただし、一度に送信するものが多い場合は、
<a class="ulink" href="git-send-email.html" target="_top">git-send-email(1)</a>
スクリプトを使用してプロセスを自動化することをお勧めします。まずはプロジェクトのメーリングリストを参照して、パッチを送信するための要件を決定してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="importing-patches"></a>Importing patches to a project</h2></div></div></div><p>Gitは、このような電子メールで送信された一連のパッチをインポートするための <a class="ulink" href="git-am.html" target="_top">git-am(1)</a> (amは「apply
mailbox」の略)と呼ばれるツールも提供します。パッチを含むすべてのメッセージを順番に1つのメールボックスファイル(<code class="literal">patches.mbox</code>
など)に保存してから、以下を実行します</p><pre class="screen">$ git am -3 patches.mbox</pre><p>Gitは各パッチを順番に適用します。競合が見つかった場合は停止し、<a class="link" href="#resolving-a-merge" title="Resolving a merge">Resolving a merge</a>の説明に従って競合を修正できます。( <code class="literal">-3</code>
オプションは、Gitにマージを実行するように指示します。ツリーとインデックスを中止してそのままにしておく場合は、そのオプションを省略できます。)</p><p>競合解決の結果でインデックスが更新されたら、新しいコミットを作成する代わりに、以下を実行するだけです。</p><pre class="screen">$ git am --continue</pre><p>こうすると、Gitはコミットを作成し、メールボックスから残りのパッチを適用し続けます。</p><p>最終的な結果は、元のメールボックスのパッチごとに1つずつ、一連のコミットになります。各パッチを含むメッセージから作者とコミットログメッセージが取得されます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="public-repositories"></a>Public Git repositories</h2></div></div></div><p>プロジェクトに変更を送信する別の方法は、 <a class="ulink" href="git-pull.html" target="_top">git-pull(1)</a>
を使用して、リポジトリから変更をプルするようにそのプロジェクトのメンテナに指示することです。
「<a class="link" href="#getting-updates-With-git-pull" title="Getting updates with git pull">Getting updates with <code class="literal">git
pull</code></a>」のセクションでは、これを「メイン」リポジトリから更新を取得する方法として説明しましたが、 他の向きでも同様に機能します。</p><p>あなたとメンテナの両方が同じマシン上にアカウントを持っている場合は、お互いのリポジトリから直接変更をプルすることができます。リポジトリURLを引数として受け入れるコマンドは、ローカルディレクトリ名も受け入れます:</p><pre class="screen">$ git clone /path/to/repository
$ git pull /path/to/other/repository</pre><p>または ssh URL を指定できます:</p><pre class="screen">$ git clone ssh://yourhost/~you/repository</pre><p>開発者が少ないプロジェクトの場合、または少数のプライベートリポジトリを同期する場合は、これで十分な場合があります。</p><p>けれども、これを行うためのより一般的な方法は、他のユーザーが変更をプルできるように、別のパブリックリポジトリ(通常は別のホスト上)を維持することです。これは通常、より便利であり、進行中の私的な作業を公に見える作業からきれいに分離することができます。</p><p>あなたは個人リポジトリで日常業務を継続しますが、定期的に個人リポジトリから公開リポジトリに変更を「プッシュ」して、他の開発者がそのリポジトリからプルできるようにします。したがって、パブリックリポジトリを持つ他の開発者が1人いる状況での変更のフローは、以下のようになります:</p><pre class="literallayout">                      you push
your personal repo ------------------&gt; your public repo
      ^                                     |
      |                                     |
      | you pull                            | they pull
      |                                     |
      |                                     |
      |               they push             V
their public repo &lt;------------------- their repo</pre><p>これを行う方法については、次のセクションで説明します。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="setting-up-a-public-repository"></a>Setting up a public repository</h3></div></div></div><p>あなたの個人リポジトリがディレクトリ <code class="literal">~/proj</code> にあると仮定します。
まず、リポジトリの新しいクローンを作成し、それがパブリックであることを意図していることを <code class="literal">git daemon</code> に伝えます:</p><pre class="screen">$ git clone --bare ~/proj proj.git
$ touch proj.git/git-daemon-export-ok</pre><p>結果のディレクトリ proj.git には、ベアgitリポジトリ(bare;生の、むき出しの)が含まれています。これは、 <code class="literal">.git</code>
ディレクトリの内容であり、周囲にファイルがチェックアウトされていません。</p><p>次に、パブリックリポジトリをホストする予定のサーバーに <code class="literal">proj.git</code> をコピーします。
scpやrsyncなど、あなたが最も便利と思うツールを使う事ができます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exporting-via-git"></a>Gitプロトコルを介したGitリポジトリのエクスポート</h3></div></div></div><p>これが推奨の方法です。</p><p>もし、他の誰かがサーバーを管理している場合は、リポジトリを配置するディレクトリと、リポジトリが表示される <code class="literal">git://</code>
URLを教えてもらってください。そして、以下の「<a class="link" href="#pushing-changes-to-a-public-repository" title="Pushing changes to a public repository">Pushing changes to a public repository</a>」のセクションまでスキップできます。</p><p>それ以外の場合は、あなたは <a class="ulink" href="git-daemon.html" target="_top">git-daemon(1)</a>を開始する必要があります。
ポート9418でリッスンします。デフォルトでは、Gitディレクトリのように見え、マジックファイルgit-daemon-export-okを含む任意のディレクトリへのアクセスが許可されます。一部のディレクトリパスを
<code class="literal">git daemon</code> の引数として渡すと、さらにそれらのパスへのエクスポートが制限されます。</p><p>`gitdaemon`をinetdサービスとして実行することもできます。 詳細については、 <a class="ulink" href="git-daemon.html" target="_top">git-daemon(1)</a>
のマニュアルページを参照してください。(特に「examples」セクションを参照してください。)</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exporting-via-http"></a>Exporting a git repository via HTTP</h3></div></div></div><p>Gitプロトコルを使用した方がパフォーマンスと信頼性が向上しますが、Webサーバーが設定済のホストでは、HTTPエクスポートの設定が簡単な場合があります。</p><p>あなたは、新しく作成したベアGitリポジトリをWebサーバーによってエクスポートされるディレクトリに配置し、Webクライアントに必要な追加情報を提供するためにいくつかの調整を行うだけです:</p><pre class="screen">$ mv proj.git /home/you/public_html/proj.git
$ cd proj.git
$ git --bare update-server-info
$ mv hooks/post-update.sample hooks/post-update</pre><p>(最後の2行の説明については、 <a class="ulink" href="git-update-server-info.html" target="_top">git-update-server-info(1)</a> と <a class="ulink" href="githooks.html" target="_top">githooks(5)</a>
を参照してください。)</p><p><code class="literal">proj.git</code> のURLを公表します。
そうすれば、他の誰もが、たとえば以下のようなコマンドラインを使用して、そのURLからクローンを作成したりプルしたりできるようになります:</p><pre class="screen">$ git clone http://yourserver.com/~you/proj.git</pre><p>(HTTPでプッシュすることもできるWebDAVを使用した少し洗練されたセットアップについては、
<a class="ulink" href="howto/setup-git-server-over-http.html" target="_top">setup-git-server-over-http</a>
も参照してください。)</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pushing-changes-to-a-public-repository"></a>Pushing changes to a public repository</h3></div></div></div><p>上記の2つの手法(<a class="link" href="#exporting-via-http" title="Exporting a git repository via HTTP">http</a>または<a class="link" href="#exporting-via-git" title="Gitプロトコルを介したGitリポジトリのエクスポート">git</a>を介したエクスポート)では、他のメンテナが最新の変更をフェッチできますが、書き込みアクセスは許可されないことに注意してください。これらはあなたのプライベートリポジトリで作成された最新の変更であなたがパブリックリポジトリを更新する必要があります。</p><p>これを行う最も簡単な方法は、 <a class="ulink" href="git-push.html" target="_top">git-push(1)</a> とsshを使用することです。 <code class="literal">master</code> という名前のリモートブランチを
<code class="literal">master</code> という名前のブランチの最新の状態で更新するには、以下のコマンドを実行します</p><pre class="screen">$ git push ssh://yourserver.com/~you/proj.git master:master</pre><p>または単に</p><pre class="screen">$ git push ssh://yourserver.com/~you/proj.git master</pre><p><code class="literal">git fetch</code> と同様に、これが<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>にならない場合、 <code class="literal">git push</code>
は文句を言います。 この場合の処理の詳細については、次のセクションを参照してください。</p><p>注意: <code class="literal">push</code>
のターゲットは通常、<a class="link" href="#def_bare_repository">ベア</a>リポジトリであることに注意してください。チェックアウトされた作業ツリーがあるリポジトリにプッシュすることもできますが、混乱を防ぐために、現在チェックアウトされているブランチを更新するためのプッシュはデフォルトで拒否されます。詳細については、
<a class="ulink" href="git-config.html" target="_top">git-config(1)</a>の receive.denyCurrentBranch オプションの説明を参照してください。</p><p><code class="literal">git fetch</code> と同様に、入力を節約するための構成オプションを設定することもできます。たとえば:</p><pre class="screen">$ git remote add public-repo ssh://yourserver.com/~you/proj.git</pre><p>とすると、 <code class="literal">.git/config</code> は以下のようになります:</p><pre class="screen">[remote "public-repo"]
        url = yourserver.com:proj.git
        fetch = +refs/heads/*:refs/remotes/example/*</pre><p>そうすると、以下のようにするだけで上記と同じプッシュをする事ができます</p><pre class="screen">$ git push public-repo master</pre><p>詳細については、 <a class="ulink" href="git-config.html" target="_top">git-config(1)</a>の <code class="literal">remote.&lt;name&gt;.url</code> や <code class="literal">branch.&lt;name&gt;.remote</code>
や <code class="literal">remote.&lt;name&gt;.push</code> オプションの説明を参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="forcing-push"></a>プッシュが失敗した場合の対処方法</h3></div></div></div><p>プッシュによってリモートブランチで<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>が発生しない場合は、以下のようなエラーで失敗します:</p><pre class="screen"> ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to '...'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</pre><p>これは、たとえば、以下の場合に発生する可能性があります:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">git reset --hard</code> を使用して、すでに公開されているコミットを削除しようとした
</li><li class="listitem">
<code class="literal">git commit --amend</code>
          を使用して、すでに公開されているコミットを置き換えようとした(<a class="xref" href="#fixing-a-mistake-by-rewriting-history" title="履歴を巻き戻す事によって作業ミスを修正する">the section called “履歴を巻き戻す事によって作業ミスを修正する”</a>のように)
</li><li class="listitem">
<code class="literal">git rebase</code> を使用して、すでに公開されているコミットをリベースしようとした(<a class="xref" href="#using-git-rebase" title="Keeping a patch series up to date using git rebase">the section called “Keeping a patch series up to date using git rebase”</a>のように)
</li></ul></div><p>あなたはブランチ名の前にプラス記号(<code class="literal">+</code>)を付けることで、 <code class="literal">git push</code> に強制的に更新を実行させることができます:</p><pre class="screen">$ git push ssh://yourserver.com/~you/proj.git +master</pre><p>注意: 上記では <code class="literal">+</code> 記号が追加されていることに注意してください。または、以下のように、 <code class="literal">-f</code>
フラグを使用してリモート更新を強制することもできます:</p><pre class="screen">$ git push -f ssh://yourserver.com/~you/proj.git master</pre><p>通常、パブリックリポジトリのブランチヘッドが変更されると、以前にポイントしたコミットの子孫を指すように変更されます。この状況でプッシュを強制することにより、あなたはその慣習を破ることになります。(<a class="xref" href="#problems-With-rewriting-history" title="履歴の書き換えに関する問題">the section called “履歴の書き換えに関する問題”</a>を参照してください。)</p><p>それでも、これは進行中のパッチシリーズを公開する簡単な方法を必要とする人々にとって一般的な方法であり、これがブランチの管理方法であることを他の開発者に警告する限り、許容できる妥協案です。</p><p>他の人が同じリポジトリにプッシュする権利を持っている場合、この方法でプッシュが失敗する可能性もあります。その場合、正しい解決策は、最初にプル、またはフェッチとそれに続くリベースのいずれかの作業を更新した後にプッシュを再試行することです。詳細については、<a class="link" href="#setting-up-a-shared-repository" title="Setting up a shared repository">次のセクション</a>
および <a class="ulink" href="gitcvs-migration.html" target="_top">gitcvs-migration(7)</a> を参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="setting-up-a-shared-repository"></a>Setting up a shared repository</h3></div></div></div><p>共同作業するもう1つの方法は、CVSで一般的に使用されているモデルと同様のモデルを使用することです。このモデルでは、特別な権限を持つ複数の開発者がすべて、単一の共有リポジトリにプッシュおよびプルします。これを設定する方法については、
<a class="ulink" href="gitcvs-migration.html" target="_top">gitcvs-migration(7)</a> を参照してください。</p><p>けれども、共有リポジトリに対するGitのサポートに問題はありませんが、Gitがサポートする、パッチをやり取りし公開リポジトリからプルすることによる共同作業モードは中央共有リポジトリに比べて非常に多くの利点があるため、この操作モードは通常は推奨されません:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
パッチをすばやくインポートしてマージするGitの機能により、1人のメンテナが非常に高いレートでも受信した変更を処理できます。
          そして、それが多すぎる場合、 <code class="literal">git pull</code>
          は、そのメンテナがこのジョブを他のメンテナに委任するための簡単な方法を提供しますが、それでも着信変更のオプションのレビューを許可します。
</li><li class="listitem">
すべての開発者のリポジトリにはプロジェクト履歴の同じ完全なコピーがあるため、特別なリポジトリはありません。また、相互の合意によって、またはメンテナが応答しなくなったり、作業が困難になったりしたために、別の開発者がプロジェクトのメンテナンスを引き継ぐのは簡単です。
</li><li class="listitem">
「コミッター」の中央グループがないということは、誰が「グループ内側」なのか、誰が「グループ外側」なのかについての正式な決定の必要性が少ないことを意味します。
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="setting-up-gitweb"></a>Allowing web browsing of a repository</h3></div></div></div><p>gitweb cgiスクリプトを使用すると、Gitをインストールしなくても、プロジェクトのリビジョン、ファイルの内容、ログを簡単に参照できます。
RSS/Atomフィードやblame/annotationの詳細などの機能をオプションで有効にすることができます。</p><p><a class="ulink" href="git-instaweb.html" target="_top">git-instaweb(1)</a> コマンドは、gitwebを使用してリポジトリの閲覧を開始する簡単な方法を提供します。
instawebを使用する場合のデフォルトのサーバーはlighttpdです。</p><p>CGIまたはPerl対応サーバーを使用した永続的なインストールのセットアップの詳細については、Gitソースツリーのファイル gitweb/INSTALL
および <a class="ulink" href="gitweb.html" target="_top">gitweb(1)</a> を参照してください。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="how-to-get-a-git-repository-with-minimal-history"></a>最小限の履歴でGitリポジトリを取得する方法</h2></div></div></div><p>履歴が切り捨てられた<a class="link" href="#def_shallow_clone">shallow clone</a>は、プロジェクトの最近の履歴のみに関心があり、アップストリームから完全な履歴を取得するのにコストがかかる場合に役立ちます。</p><p><a class="link" href="#def_shallow_clone">shallow clone</a>は、 <a class="ulink" href="git-clone.html" target="_top">git-clone(1)</a> に <code class="literal">--depth</code>
スイッチを指定することで作成されます。深さは後で <a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a> の <code class="literal">--depth</code>
スイッチで変更するか、または、完全な履歴を <code class="literal">--unshallow</code> で復元することができます。</p><p><a class="link" href="#def_shallow_clone">shallow clone</a>内でのマージは、マージベースが取得してきた最近の履歴にある限り機能します。そうでなければ、無関係な履歴をマージするようなものになり、大きな競合が発生する可能性があります。この制限により、このようなリポジトリはマージベースのワークフローでの使用に適さなくなる可能性があります。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sharing-development-examples"></a>Examples</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maintaining-topic-branches"></a>Maintaining topic branches for a Linux subsystem maintainer</h3></div></div></div><p>ここでは、Tony LuckがLinuxカーネルのIA64アーキテクチャーのメンテナーとしてGitをどのように使用しているかを説明します。</p><p>彼は2つのパブリックブランチを使用しています:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
他の進行中の開発と統合されたときにパッチがある程度の露出を得ることができるように、パッチが最初に配置される「test」ツリー。このツリーは、Andrewが必要なときにいつでも
   -mm にプルするために使用できます。
</li><li class="listitem">
テスト済のパッチが最終的な健全性チェックのために移動され、それらを上流のLinusに送信(彼に「プルしてください」というリクエストを送信)するための手段としての「release」ツリー
</li></ul></div><p>彼はまた、パッチの論理グループをそれぞれ含む一時的なブランチ(トピックブランチ)の組を使用します。</p><p>これを設定するには、最初にLinusのパブリックツリーのクローンを作成して作業ツリーを作成します。</p><pre class="screen">$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git work
$ cd work</pre><p>Linusのツリーは、 origin/master という名前のリモート追跡ブランチに保存され、 <a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a>
を使用して更新できます。 <a class="ulink" href="git-remote.html" target="_top">git-remote(1)</a> を使用して "remote" を設定し、 <a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a>
を使用して他のパブリックツリーを追跡し、それらを最新の状態に保つことができます。<a class="xref" href="#repositories-and-branches" title="Chapter 1. Repositories and Branches">Chapter 1, <i>Repositories and Branches</i></a>
を参照してください。</p><p>そして今、作業するブランチを作成します。 これらは現在の origin/master
ブランチの先端から始まり、デフォルトでLinusからの変更をマージするように設定する必要があります(<a class="ulink" href="git-branch.html" target="_top">git-branch(1)</a>の
<code class="literal">--track</code> オプションを使用)。</p><pre class="screen">$ git branch --track test origin/master
$ git branch --track release origin/master</pre><p>これらは、 <a class="ulink" href="git-pull.html" target="_top">git-pull(1)</a> を使用して簡単に最新の状態に保つことができます。</p><pre class="screen">$ git switch test &amp;&amp; git pull
$ git switch release &amp;&amp; git pull</pre><p>重要な注意点！
これらのブランチにローカルの変更がある場合、このマージは履歴にコミットオブジェクトを作成します(ローカルの変更なしで、Gitは単に「fast-forward」マージを実行します)。
多くの人がこれがLinuxの歴史に生み出す「ノイズ」を嫌います。つまり、Linusにリリースブランチからプルするように依頼すると、これらのノイズの多いコミットが永続的な履歴の一部になるため、
<code class="literal">release</code> ブランチでこれを気まぐれに行うことは避けてください。</p><p>いくつかの構成変数(<a class="ulink" href="git-config.html" target="_top">git-config(1)</a>
を参照)を使用すると、両方のブランチをパブリックツリーに簡単にプッシュできます。(<a class="xref" href="#setting-up-a-public-repository" title="Setting up a public repository">the section called “Setting up a public repository”</a>
を参照してください。)</p><pre class="screen">$ cat &gt;&gt; .git/config &lt;&lt;EOF
[remote "mytree"]
        url =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux.git
        push = release
        push = test
EOF</pre><p>次に、 <a class="ulink" href="git-push.html" target="_top">git-push(1)</a> を使用して、testツリーとreleaseツリーの両方をプッシュできます:</p><pre class="screen">$ git push mytree</pre><p>または、以下を使用してtestブランチとreleaseブランチの1つだけをプッシュします:</p><pre class="screen">$ git push mytree test</pre><p>または</p><pre class="screen">$ git push mytree release</pre><p>次に、コミュニティからいくつかのパッチを適用します。
このパッチ(または関連するパッチのグループ)を保持するブランチの短い名前を考えて、Linusのブランチの最近の安定したタグから新しいブランチを作成します。あなたのブランチの為に安定したベースを選択すると、以下のようになります:
1) 無関係でおそらく軽くテストされた変更を含めることを避けるのは、あなた自身への助けになります。
2) <code class="literal">git bisect</code> を使用して問題を見つける将来のバグハンターを支援する</p><pre class="screen">$ git switch -c speed-up-spinlocks v2.6.35</pre><p>次に、パッチを適用し、いくつかのテストを実行して、変更をコミットします。
パッチがマルチパートシリーズの場合は、それぞれを個別のコミットとしてこのブランチに適用する必要があります。</p><pre class="screen">$ ... patch ... test  ... commit [ ... patch ... test ... commit ]*</pre><p>この変更の状態に満足したら、公開する準備として「test」ブランチにマージできます:</p><pre class="screen">$ git switch test &amp;&amp; git merge speed-up-spinlocks</pre><p>ここで競合が発生する可能性はほとんどありません…ただし、この手順にしばらく時間を費やし、アップストリームから新しいバージョンをプルした場合は、競合が発生する可能性があります。</p><p>しばらくして、十分な時間が経過してテストが完了したら、同じブランチを「release」ツリーにプルして、アップストリームに進む準備をすることができます。ここで、各パッチ（またはパッチシリーズ）を独自のブランチに保持することの価値を確認できます。
これは、パッチを任意の順序で「release」ツリーに移動できることを意味します。</p><pre class="screen">$ git switch release &amp;&amp; git merge speed-up-spinlocks</pre><p>しばらくすると、いくつかのブランチが作成され、それぞれに適切に選択された名前があるにもかかわらず、ブランチの目的や状態を忘れてしまう可能性があります。特定のブランチにどのような変更があるか思い出すには以下を使用します:</p><pre class="screen">$ git log linux..branchname | git shortlog</pre><p>testブランチまたはreleaseブランチにすでにマージされているかどうかを確認するには、以下を使用します:</p><pre class="screen">$ git log test..branchname</pre><p>または</p><pre class="screen">$ git log release..branchname</pre><p>(このブランチがまだマージされていない場合は、いくつかのログエントリが表示されます。マージされている場合、出力はありません。)</p><p>パッチがその大きなサイクルを完了すると(testからreleaseに移動し、Linusによってプルされ、最後にローカルの <code class="literal">origin/master</code>
ブランチに戻るというサイクル)、この、変更のためのブランチは不要になります。あなたは以下の出力時にそれを悟ります:</p><pre class="screen">$ git log origin..branchname</pre><p>これの出力が空です。この時点で、このブランチを削除できます:</p><pre class="screen">$ git branch -d branchname</pre><p>一部の変更は非常に簡単なので、個別のブランチを作成してから、testブランチとreleaseブランチのそれぞれにマージする必要はありません。これらの変更については、
<code class="literal">release</code> ブランチに直接適用してから、それを <code class="literal">test</code> ブランチにマージしてください。</p><p>作業を <code class="literal">mytree</code> にプッシュした後、 <a class="ulink" href="git-request-pull.html" target="_top">git-request-pull(1)</a>
を使用して、Linusに送信するための、「please pull」リクエストメッセージを準備できます:</p><pre class="screen">$ git push mytree
$ git request-pull origin mytree release</pre><p>これをさらに単純化するスクリプトのいくつかを以下に示します。</p><pre class="screen">==== update script ====
#
Gitツリーのブランチを更新します。更新するブランチがoriginの場合は、kernel.orgからプルします。それ以外の場合は、origin/masterブランチを
test ブランチ または releaseブランチにマージします

case "$1" in
test|release)
        git checkout $1 &amp;&amp; git pull . origin
        ;;
origin)
        before=$(git rev-parse refs/remotes/origin/master)
        git fetch origin
        after=$(git rev-parse refs/remotes/origin/master)
        if [ $before != $after ]
        then
                git log $before..$after | git shortlog
        fi
        ;;
*)
        echo "usage: $0 origin|test|release" 1&gt;&amp;2
        exit 1
        ;;
esac</pre><pre class="screen">==== merge script ====
# ブランチをtestブランチまたはreleaseブランチにマージします

pname=$0

usage()
{
        echo "usage: $pname branch test|release" 1&gt;&amp;2
        exit 1
}

git show-ref -q --verify -- refs/heads/"$1" || {
        echo "Can't see branch &lt;$1&gt;" 1&gt;&amp;2
        usage
}

case "$2" in
test|release)
        if [ $(git log $2..$1 | wc -c) -eq 0 ]
        then
                echo $1 already merged into $2 1&gt;&amp;2
                exit 1
        fi
        git checkout $2 &amp;&amp; git pull . $1
        ;;
*)
        usage
        ;;
esac</pre><pre class="screen">==== status script ====
# report on status of my ia64 Git tree

gb=$(tput setab 2)  rb=$(tput setab 1)  restore=$(tput setab 9)

if [ `git rev-list test..release | wc -c` -gt 0 ]
then
        echo $rb Warning: commits in release that are not in test $restore
        git log test..release
fi

for branch in `git show-ref --heads | sed 's|^.*/||'`
do
        if [ $branch = test -o $branch = release ]
        then
                continue
        fi

        echo -n $gb ======= $branch ====== $restore " "
        status=
        for ref in test release origin/master
        do
                if [ `git rev-list $ref..$branch | wc -c` -gt 0 ]
                then
                        status=$status${ref:0:1}
                fi
        done
        case $status in
        trl)
                echo $rb Need to pull into test $restore
                ;;
        rl)
                echo "In test"
                ;;
        l)
                echo "Waiting for linus"
                ;;
        "")
                echo $rb All done $restore
                ;;
        *)
                echo $rb "&lt;$status&gt;" $restore
                ;;
        esac
        git log origin/master..$branch | git shortlog
done</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="cleaning-up-history"></a>Chapter 5. Rewriting history and maintaining patch series</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#patch-series">Creating the perfect patch series</a></span></dt><dt><span class="section"><a href="#using-git-rebase">Keeping a patch series up to date using git rebase</a></span></dt><dt><span class="section"><a href="#rewriting-one-commit">Rewriting a single commit</a></span></dt><dt><span class="section"><a href="#reordering-patch-series">Reordering or selecting from a patch series</a></span></dt><dt><span class="section"><a href="#interactive-rebase">Using interactive rebases</a></span></dt><dt><span class="section"><a href="#patch-series-tools">Other tools</a></span></dt><dt><span class="section"><a href="#problems-With-rewriting-history">履歴の書き換えに関する問題</a></span></dt><dt><span class="section"><a href="#bisect-merges">なぜマージコミットをbisectすることが線形履歴をbisectするよりも難しい場合があるのか</a></span></dt></dl></div><p>通常、コミットはプロジェクトにのみ追加され、削除または置換されることはありません。
Gitはこの仮定に基づいて設計されており、これに違反すると、(たとえば、)Gitのマージ機構が間違ったことを実行することになります。</p><p>しかしながら、この仮定に違反することが役立つ場合があります。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="patch-series"></a>Creating the perfect patch series</h2></div></div></div><p>例えば、あなたが大規模なプロジェクトの貢献者で、複雑な機能を追加したとき、他の開発者があなたの変更を読んでそれらが正しいかどうかを確認するために、あなたがそれぞれの変更を行った理由を理解しやすい方法で、提示したいとします。</p><p>すべての変更をそれぞれ単一のパッチ(またはコミット)として提示すると、一度にすべてを消化するには多すぎると思える事があります。</p><p>あなたの仕事の全履歴を提示し、その間違い・訂正・行き詰まりでいっぱいいっぱいにしたら、それを見る人達は閉口するかもしれません。</p><p>したがって、理想なのは、通常、以下のような一連のパッチを作成することです:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
各パッチは順番に適用できます。
</li><li class="listitem">
各パッチには、変更を説明するメッセージとともに、単一の論理的な変更が含まれています。
</li><li class="listitem">
デグレを引き起こすパッチはありません。シリーズの最初の部分を適用した後でも、結果のプロジェクトはコンパイルおよび動作し、以前にはなかったバグはありません。
</li><li class="listitem">
このシリーズ全体は、あなた自身の(これらのパッチシリーズよりおそらくもっともっと厄介であった)開発作業で行ったのと同じ最終結果を生み出します。
</li></ol></div><p>これを行うのに役立ついくつかのツールを紹介し、それらの使用方法を説明してから、履歴を書き換えているために発生する可能性のあるいくつかの問題について説明します。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-git-rebase"></a>Keeping a patch series up to date using git rebase</h2></div></div></div><p>リモート追跡ブランチ <code class="literal">origin</code> にブランチ <code class="literal">mywork</code> を作成し、その先頭にいくつかのコミットを作成するとします:</p><pre class="screen">$ git switch -c mywork origin
$ vi file.txt
$ git commit
$ vi otherfile.txt
$ git commit
...</pre><p>myworkへのマージは実行されていないため、 <code class="literal">origin</code> の先頭にあるパッチの単純な線形シーケンスです:</p><pre class="literallayout"> o--o--O &lt;-- origin
        \
         a--b--c &lt;-- mywork</pre><p>上流のプロジェクトでさらに興味深い作業が行われ、 <code class="literal">origin</code> が前進歩しました:</p><pre class="literallayout"> o--o--O--o--o--o &lt;-- origin
        \
         a--b--c &lt;-- mywork</pre><p>この時点で、 <code class="literal">pull</code> を使用してあなたの変更をマージして戻すことができます。 その結果、次のような新しいマージコミットが作成されます:</p><pre class="literallayout"> o--o--O--o--o--o &lt;-- origin
        \        \
         a--b--c--m &lt;-- mywork</pre><p>しかしながら、myworkの履歴をマージせずに単純な一連のコミットを保持したい場合は、代わりに <a class="ulink" href="git-rebase.html" target="_top">git-rebase(1)</a>
を使用することを選択できます:</p><pre class="screen">$ git switch mywork
$ git rebase origin</pre><p>これにより、各コミットがmyworkから削除され、一時的にパッチとして( <code class="literal">.git/rebase-apply</code>
という名前のディレクトリに)保存され、最新バージョンのoriginを指すようにmyworkが更新され、保存された各パッチが新しいmyworkに適用されます。結果は以下のようになります:</p><pre class="literallayout"> o--o--O--o--o--o &lt;-- origin
                 \
                  a'--b'--c' &lt;-- mywork</pre><p>その過程で、競合が見つかる可能性があります。その場合、rebaseは停止し、競合を修正できるようになります。
競合を修正した後は、それらのコンテンツに対して <code class="literal">git add</code> を使用してインデックスを更新します。そして ` git commit`
を実行する代わりに以下を実行します:</p><pre class="screen">$ git rebase --continue</pre><p>そうすると、Gitは残りのパッチを適用し続けます。</p><p>あなたは、いつでも <code class="literal">--abort</code> オプションを使用してこの作業を中止し、リベースを開始する前の状態にmyworkを戻すことができます:</p><pre class="screen">$ git rebase --abort</pre><p>ブランチ内の多数のコミットを並べ替えたり編集したりする必要がある場合は、 <code class="literal">git rebase -i</code>
を使用する方が簡単な場合があります。これにより、コミットを並べ替えたり押しつぶしたり(squash)、リベース中に個別に編集できるようにマークを付けたりできます。詳細については
<a class="xref" href="#interactive-rebase" title="Using interactive rebases">the section called “Using interactive rebases”</a> を、代替案については <a class="xref" href="#reordering-patch-series" title="Reordering or selecting from a patch series">the section called “Reordering or selecting from a patch series”</a> を参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rewriting-one-commit"></a>Rewriting a single commit</h2></div></div></div><p><a class="xref" href="#fixing-a-mistake-by-rewriting-history" title="履歴を巻き戻す事によって作業ミスを修正する">the section called “履歴を巻き戻す事によって作業ミスを修正する”</a>で、以下のようにして最新のコミットを置き換えることができることを確認しました</p><pre class="screen">$ git commit --amend</pre><p>これにより、古いコミットが変更を組み込んだ新しいコミットに置き換えられ、最初に古いコミットメッセージを編集する機会が与えられます。これは、最後のコミットでのタイプミスを修正したり、ステージングが不十分なコミットのパッチの内容を調整したりする場合に役立ちます。</p><p>履歴のより深いところのコミットを修正する必要がある場合は、<a class="link" href="#interactive-rebase" title="Using interactive rebases">対話的rebaseの「edit」命令</a>を使用できます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reordering-patch-series"></a>Reordering or selecting from a patch series</h2></div></div></div><p>時々、あなたはあなたの歴史のより深いところにコミットを編集したいです。 1つのアプローチとしては、 <code class="literal">git format-patch</code>
を使用して一連のパッチを作成し、パッチ適用前の状態にリセットすることです:</p><pre class="screen">$ git format-patch origin
$ git reset --hard origin</pre><p>そして <a class="ulink" href="git-am.html" target="_top">git-am(1)</a> を使用してパッチを再度適用する前に、必要に応じてパッチを変更、並べ替え、または削除します:</p><pre class="screen">$ git am *.patch</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="interactive-rebase"></a>Using interactive rebases</h2></div></div></div><p>対話的なリベースで一連のパッチを編集することもできます。 これは <a class="link" href="#reordering-patch-series" title="Reordering or selecting from a patch series"><code class="literal">format-patch</code> を使用してパッチシリーズを並べ替える</a>のと同じなので、あなたの最も好きなインターフェースを使用してください。</p><p>現在のHEADを、そのまま保持する最後のコミットに基づいてリベースします。たとえば、最後の5つのコミットを並べ替える場合は、以下を使用します:</p><pre class="screen">$ git rebase -i HEAD~5</pre><p>これにより、リベースを実行するために実行する手順のリストが表示されたエディタが開きます。</p><pre class="screen">pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...

# Rebase c0ffeee..deadbee onto c0ffeee
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</pre><p>コメントで説明されているように、リストを編集することで、コミットの並べ替え、まとめ、コミットメッセージの編集などを行うことができます。満足したら、リストを保存してエディタを閉じると、リベースが開始されます。</p><p>リベースは、 <code class="literal">pick</code> が <code class="literal">edit</code>
に置き換えられた場合、またはリスト内のステップが競合を機械的に解決できず、あなたの助けが必要な場合に停止します。競合の編集や解決が完了したら、 <code class="literal">git
rebase --continue</code> で続行できます。途中で物事があまりにもスパゲッティ(hairy)になっていると判断した場合は、いつでも <code class="literal">git
rebase --abort</code>
で救済することができます。リベースが完了した後でも、<a class="link" href="#reflogs" title="Reflogs">reflog</a>を使用して、元のブランチを回復できます。</p><p>手順と追加のヒントの詳細については、 <a class="ulink" href="git-rebase.html" target="_top">git-rebase(1)</a> の「INTERACTIVE MODE」セクションを参照してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="patch-series-tools"></a>Other tools</h2></div></div></div><p>パッチシリーズを維持する目的で存在するStGitなど、他のツールは多数ありますが、それらはこのマニュアルの範囲外です。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="problems-With-rewriting-history"></a>履歴の書き換えに関する問題</h2></div></div></div><p>ブランチの履歴を書き換える際の主な問題は、マージに関係しています。誰かがあなたのブランチをフェッチしてブランチにマージすると、以下のような結果になります:</p><pre class="literallayout"> o--o--O--o--o--o &lt;-- origin
        \        \
         t--t--t--m &lt;-- their branch:</pre><p>次に、あなたが最後の3つのコミットを変更するとします:</p><pre class="literallayout">         o--o--o &lt;-- new head of origin
        /
 o--o--O--o--o--o &lt;-- old head of origin</pre><p>このすべての履歴を1つのリポジトリにまとめて見ると、以下のようになります:</p><pre class="literallayout">         o--o--o &lt;-- new head of origin
        /
 o--o--O--o--o--o &lt;-- old head of origin
        \        \
         t--t--t--m &lt;-- their branch:</pre><p>Gitには、新しいヘッドが古いヘッドの更新バージョンであることを知る方法がありません。この状況は、2人の開発者が独立して新旧のヘッドで並行して作業を行った場合とまったく同じように扱われます。この時点で、誰かが新しいヘッドをブランチにマージしようとすると、Gitは古いものを新しいものに置き換えようとするのではなく、2つの(古いものと新しい)開発ラインをマージしようとします。結果は予想外の可能性があります。</p><p>あなたは、履歴が書き換えられたブランチを公開することを選択することもできます。他の人がそれらのブランチを調べたりテストしたりするためにそれらのブランチをフェッチできると便利な場合がありますが、そのようなブランチを自分の作業に引き込もうとしないでください。</p><p>適切なマージをサポートする、本当に分散開発を行っている場合、公開されたブランチを書き直してはいけません。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bisect-merges"></a>なぜマージコミットをbisectすることが線形履歴をbisectするよりも難しい場合があるのか</h2></div></div></div><p><a class="ulink" href="git-bisect.html" target="_top">git-bisect(1)</a>
コマンドは、マージコミットを含む履歴を正しく処理します。ただし、検出されたコミットがマージコミットである場合、ユーザーは、そのコミットが問題を引き起こした理由を理解するために、通常よりも慎重に作業する事を心がけて下さい。</p><p>以下の履歴があるとします:</p><pre class="literallayout">      ---Z---o---X---...---o---A---C---D
          \                       /
           o---o---Y---...---o---B</pre><p>開発の(図の)上側のラインで、コミットXでZに存在する関数の1つの意味が変更されたとします。AにつながるZからのコミットは、関数の実装とZに存在するすべての呼び出し側の両方を変更し、一貫性を保つために、追加するする新しい呼び出し側も同様にします。Aにはバグはありません。</p><p>その間に、開発の(図の)下側のラインで、誰かがコミットYでその関数の新しい呼び出し側を追加するとします。BにつながるZからのコミットはすべて、その関数の古いセマンティクスを想定しており、呼び出し元と呼び出し先は互いに一貫しています。Bにもバグはありません。</p><p>さらに、この上下2つの開発ラインがCできれいにマージされるため、競合の解決は必要ないとします。</p><p>それにもかかわらず、開発の下側のラインで追加された呼び出し側は、開発の上側ラインに導入された新しいセマンティクスに変換されていないため、Cのコードは壊れています。したがって、Dがbad、Zがgoodで、<a class="ulink" href="git-bisect.html" target="_top">git-bisect(1)</a>
がCを原因として特定していることだけを知っている場合、あなたは問題がこのセマンティクスの変更によるものであることをどのようにして解き明かしますか？</p><p><code class="literal">git bisect</code>
の結果が非マージコミットである場合、通常はそのコミットだけを調べることで問題を発見できるはずです。開発者は、変更を小さな自己完結型のコミットに分割することで、これを簡単に行うことができます。
ただし、上記の場合は、単一のコミットを調べても問題が明らかではないため、これは役に立ちません。代わりに、開発の全体的な俯瞰が必要です。さらに悪いことに、問題のある関数のセマンティクスの変更は、開発の上側ラインの変更のほんの一部にすぎない可能性があります。</p><p>一方、Cでマージする代わりに、Aの上にZからBまでの履歴をリベースした場合、以下の線形履歴が得られます:</p><pre class="literallayout">    ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D*</pre><p>ZとD*の間のbisectは、単一の犯人コミットY*にヒットし、Y*が壊れた理由を理解するのはおそらく簡単でしょう。</p><p>多くの経験豊富なGitユーザーが、他の方法でマージが多いプロジェクトで作業している場合でも、公開する前に最新のアップストリームバージョンにリベースすることで履歴を線形に保つのは、これが理由の一つです。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="advanced-branch-management"></a>Chapter 6. Advanced branch management</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#fetching-individual-branches">Fetching individual branches</a></span></dt><dt><span class="section"><a href="#fetch-fast-forwards">git fetch and fast-forwards</a></span></dt><dt><span class="section"><a href="#forcing-fetch">Forcing git fetch to do non-fast-forward updates</a></span></dt><dt><span class="section"><a href="#remote-branch-configuration">Configuring remote-tracking branches</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fetching-individual-branches"></a>Fetching individual branches</h2></div></div></div><p><a class="ulink" href="git-remote.html" target="_top">git-remote(1)</a> を使用する代わりに、一度に1つのブランチを更新し、それを任意の名前でローカルに保存することもできます:</p><pre class="screen">$ git fetch origin todo:my-todo-work</pre><p>最初の引数 <code class="literal">origin</code> は、最初にクローンを作成したリポジトリからフェッチするようにGitに指示するだけのものです。2番目の引数は、Gitに
<code class="literal">todo</code> という名前のブランチをリモートリポジトリからフェッチし、それを <code class="literal">refs/heads/my-todo-work</code>
という名前でローカルに保存するように指示します。</p><p>以下のように、他のリポジトリからブランチをフェッチすることもできます。</p><pre class="screen">$ git fetch git://example.com/proj.git master:example-master</pre><p>これは <code class="literal">example-master</code> という名前の新しいブランチを作成し、指定されたURLのリポジトリの <code class="literal">master</code>
という名前のブランチをその中に保存します。<code class="literal">example-master</code> という名前のブランチがすでにある場合は、 <code class="literal">example.com</code> の
masterブランチによって指定されたコミットに<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>しようとします。これについて詳細は次のセクションを参照下さい:</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fetch-fast-forwards"></a>git fetch and fast-forwards</h2></div></div></div><p>前の例では、既存のブランチを更新するときに、 <code class="literal">git fetch</code>
は、新しいコミットを指すようにブランチのコピーを更新する前に、リモートブランチの最新のコミットがブランチのコピーの最新のコミットの子孫であることを確認します。Gitはこのプロセスを<a class="link" href="#fast-forwards" title="Fast-forward merges">fast-forward</a>と呼んでいます。</p><p>fast-forwardになるのは以下のような感じの場合です:</p><pre class="literallayout"> o--o--o--o &lt;-- old head of the branch
           \
            o--o--o &lt;-- new head of the branch</pre><p>場合によっては、新しいヘッドが実際には古いヘッドの子孫ではない可能性があります。たとえば、開発者は重大なミスがあったことに気づき、バックトラックすることを決定した可能性があり、その結果、以下のような状況になります:</p><pre class="literallayout"> o--o--o--o--a--b &lt;-- old head of the branch
           \
            o--o--o &lt;-- new head of the branch</pre><p>この場合、 <code class="literal">git fetch</code> は失敗し、警告を出力します。</p><p>その場合でも、次のセクションで説明するように、Gitを強制的に新しいヘッドに更新することができます。
ただし、上記の状況では、それらを指す独自の参照をすでに作成している場合を除き、「a」や「b」というラベルの付いたコミットが失われる可能性があることに注意してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="forcing-fetch"></a>Forcing git fetch to do non-fast-forward updates</h2></div></div></div><p>ブランチの新しいヘッドが古いヘッドの子孫ではないためにgit fetchが失敗した場合は、以下のように更新を強制できます:</p><pre class="screen">$ git fetch git://example.com/proj.git +master:refs/remotes/example/master</pre><p>注意: <code class="literal">+</code> 記号が追加されていることに注意してください。または、以下のように、 <code class="literal">-f</code>
フラグを使用して、フェッチされたすべてのブランチを強制的に更新することもできます:</p><pre class="screen">$ git fetch -f origin</pre><p>これは、前のセクションで述べたとおり、ポイントされた古いバージョンのexample/masterが失われる可能性があることに注意してください。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remote-branch-configuration"></a>Configuring remote-tracking branches</h2></div></div></div><p>前述したように、 <code class="literal">origin</code>
は、最初にクローンを作成したリポジトリを参照するためのショートカットにすぎません。この情報はGit構成変数に保存され、
<a class="ulink" href="git-config.html" target="_top">git-config(1)</a> を使用して確認できます。</p><pre class="screen">$ git config -l
core.repositoryformatversion=0
core.filemode=true
core.logallrefupdates=true
remote.origin.url=git://git.kernel.org/pub/scm/git/git.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.master.remote=origin
branch.master.merge=refs/heads/master</pre><p>頻繁に使用する他のリポジトリがある場合、あなたは同様の構成オプションを作成して入力を省略できます。例えば、</p><pre class="screen">$ git remote add example git://example.com/proj.git</pre><p>とすると、 <code class="literal">.git/config</code> は以下のようになります:</p><pre class="screen">[remote "example"]
        url = git://example.com/proj.git
        fetch = +refs/heads/*:refs/remotes/example/*</pre><p>注意: 上記の設定は、 <a class="ulink" href="git-remote.html" target="_top">git-remote(1)</a> を使用する代わりに、ファイル <code class="literal">.git/config</code>
を直接編集することでも機能することに注意してください。</p><p>リモートを構成した後、以下の3つのコマンドは同じことを行います:</p><pre class="screen">$ git fetch git://example.com/proj.git +refs/heads/*:refs/remotes/example/*
$ git fetch example +refs/heads/*:refs/remotes/example/*
$ git fetch example</pre><p>上記の構成オプションの詳細については <a class="ulink" href="git-config.html" target="_top">git-config(1)</a> を、refspec構文の詳細については
<a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a> を参照してください。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="git-concepts"></a>Chapter 7. Gitの概念</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#the-object-database">The Object Database</a></span></dt><dd><dl><dt><span class="section"><a href="#commit-object">Commit Object</a></span></dt><dt><span class="section"><a href="#tree-object">Tree Object</a></span></dt><dt><span class="section"><a href="#blob-object">Blob Object</a></span></dt><dt><span class="section"><a href="#trust">Trust(信頼性)</a></span></dt><dt><span class="section"><a href="#tag-object">Tag Object</a></span></dt><dt><span class="section"><a href="#pack-files">Gitがオブジェクトを効率的に保存する方法: pack files</a></span></dt><dt><span class="section"><a href="#dangling-objects">Dangling objects(宙ぶらりんオブジェクト)</a></span></dt><dt><span class="section"><a href="#recovering-from-repository-corruption">破損したリポジトリの回復</a></span></dt></dl></dd><dt><span class="section"><a href="#the-index">The index</a></span></dt></dl></div><p>Gitは、少数のシンプルで強力なアイデアに基づいて構築されています。これらのアイデアを理解しなくても物事を成し遂げることは可能ですが、理解した上での方がGitをはるかに直感的に理解できるようになります。</p><p>私達は、最も重要な<a class="link" href="#def_object_database">オブジェクト データベース</a>と<a class="link" href="#def_index">インデックス</a>から始めることにします。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="the-object-database"></a>The Object Database</h2></div></div></div><p>私達はすでに<a class="xref" href="#understanding-commits" title="Understanding History: Commits">the section called “Understanding History: Commits”</a>で、すべてのコミットが40桁の「オブジェクト名」で保存されているのを見ました。実際、プロジェクトの履歴を表すために必要なすべての情報は、そのような名前のオブジェクトに格納されています。いずれの場合も、名前はオブジェクトのコンテンツのSHA-1ハッシュを使用して計算されます。SHA-1ハッシュは暗号化ハッシュ関数です。それが私たちにとって意味することは、同じ名前の2つの異なるオブジェクトを見つけることは不可能であるということです。これには多くの利点があります:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Gitは、名前を比較するだけで、2つのオブジェクトが同一であるかどうかをすばやく判断できます。
</li><li class="listitem">
オブジェクト名はすべてのリポジトリで同じ方法で計算されるため、2つのリポジトリに保存されている同じコンテンツ(same
  content)は常に同じ名前(same name)で保存されます。
</li><li class="listitem">
Gitは、オブジェクトの名前がまだその内容のSHA-1ハッシュであるかどうかを確認することによって、オブジェクトを読み取るときにエラーを検出できます。
</li></ul></div><p>(オブジェクトのフォーマットとSHA-1計算の詳細については、<a class="xref" href="#object-details" title="Object storage format">the section called “Object storage format”</a>を参照してください。)</p><p>オブジェクトには "blob"、"tree"、"commit"、"tag" の4種類があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="#def_blob_object">ブロブ オブジェクト("blob" object)</a>は、ファイルデータを格納するために使用されます。
</li><li class="listitem">
<a class="link" href="#def_tree_object">ツリーオブジェクト("tree"   object)</a>は、1つ以上のブロブオブジェクトをディレクトリ構造に結び付けます。さらに、ツリーオブジェクトは他のツリーオブジェクトを参照できるため、ディレクトリ階層が作成されます。
</li><li class="listitem">
<a class="link" href="#def_commit_object">コミットオブジェクト("commit"   object)</a>は、そのようなディレクトリ階層をリビジョンの<a class="link" href="#def_DAG">有向非巡回グラフ(directed acyclic   graph)</a>に結び付けます。各コミットには、その時点でディレクトリ階層を指定する正確に1つのツリーのオブジェクト名が含まれます。さらにコミットは、そのディレクトリ階層に到達した方法の履歴を説明する「親」コミットオブジェクトを参照します。
</li><li class="listitem">
<a class="link" href="#def_tag_object">タグオブジェクト("tag"   object)</a>はシンボリックに識別を行い、他のオブジェクトに署名するために使用できます。
  これには、オブジェクト名と別のオブジェクトのタイプ、（もちろん）シンボリック名、およびオプションで署名(signature)が含まれます。
</li></ul></div><p>オブジェクトタイプの詳細:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="commit-object"></a>Commit Object</h3></div></div></div><p>「commit」オブジェクトは、ツリーの物理的な状態を、そこに到達した方法とその理由の説明にリンクします。 <code class="literal">--pretty=raw</code>
オプションを伴った <a class="ulink" href="git-show.html" target="_top">git-show(1)</a> または <a class="ulink" href="git-log.html" target="_top">git-log(1)</a>
を使用し、あなたのお気に入りのコミットを調べてみます:</p><pre class="screen">$ git show -s --pretty=raw 2be7fcb476
commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4
tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf
parent 257a84d9d02e90447b149af58b271c19405edb6a
author Dave Watson &lt;dwatson@mimvista.com&gt; 1187576872 -0400
committer Junio C Hamano &lt;gitster@pobox.com&gt; 1187591163 -0700

    Fix misspelling of 'suppress' in docs

    Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;</pre><p>コミットは以下のように定義されています:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
ツリー(a tree): ツリーオブジェクトのSHA-1名(以下で定義)。特定の時点でのディレクトリの内容を表します。
</li><li class="listitem">
親(親達)(parent(s)):
  プロジェクトの履歴の直前のステップを表す、いくつかのコミットのSHA-1名。上記の例には1つの親があります。マージコミットには複数のコミットが含まれる場合があります。親のないコミットは「ルート」コミット(root
  commit)と呼ばれ、プロジェクトの初期リビジョンを表します。各プロジェクトには、少なくとも1つのルート(root)が必要です。プロジェクトは複数のルーツ(roots)を持つこともできますが、それは一般的ではありません(または必ずしも良い考えではありません)。
</li><li class="listitem">
作者(an author): この変更の責任者の名前とその日付。
</li><li class="listitem">
コミッター(a committer)：実際にコミットを作成した人の名前と、コミットが行われた日付。
  これは、作者(auther)とは異なる場合があります。たとえば、作者がパッチを作成し、それを使用してコミットを作成した人に電子メールで送信した場合です。
</li><li class="listitem">
このコミットを説明するコメント。
</li></ul></div><p>注意:
コミット自体には、実際に何が変更されたかに関する情報は含まれていないことに注意してください。すべての変更は、このコミットによって参照されるツリーの内容を、その親に関連付けられているツリーと比較することによって計算されます。特に、Gitはファイルの名前変更を明示的に記録しようとはしませんが、パスの変更時に同じファイルデータが存在することで名前変更が示唆される場合を特定できます。
(たとえば、 <a class="ulink" href="git-diff.html" target="_top">git-diff(1)</a> の <code class="literal">-M</code> オプションを参照してください。)</p><p>コミットは通常、 <a class="ulink" href="git-commit.html" target="_top">git-commit(1)</a>
によって作成されます。これにより、親が通常は現在のHEADであり、ツリーが現在インデックスに格納されているコンテンツから取得されるコミットが作成されます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tree-object"></a>Tree Object</h3></div></div></div><p>汎用性の高い <a class="ulink" href="git-show.html" target="_top">git-show(1)</a> コマンドを使用してツリーオブジェクトを調べることもできますが、あなたは
<a class="ulink" href="git-ls-tree.html" target="_top">git-ls-tree(1)</a> で詳細を確認できます。</p><pre class="screen">$ git ls-tree fb3a8bdd0ce
100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c    .gitignore
100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d    .mailmap
100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3    COPYING
040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745    Documentation
100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200    GIT-VERSION-GEN
100644 blob 289b046a443c0647624607d471289b2c7dcd470b    INSTALL
100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1    Makefile
100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52    README
...</pre><p>ご覧のとおり、ツリーオブジェクトにはエントリのリストが含まれており、各エントリにはモード(mode)とオブジェクトタイプ(object
type)とSHA-1名(SHA-1 name)と名前(name)があり、名前でソートされています。これは、単一のディレクトリツリーの内容を表します。</p><p>オブジェクトタイプは、ファイルの内容を表すブロブ(blob)でも、サブディレクトリの内容を表す別のツリーでもかまいません。
ツリー(tree)とブロブ(blob)は、他のすべてのオブジェクトと同様に、その内容のSHA-1ハッシュによって名前が付けられるため、内容(再帰的にすべてのサブディレクトリの内容を含む)が同一である場合に限り、2つのツリーは同じSHA-1名を持ちます。これにより、Gitは、同じオブジェクト名を持つエントリを無視できるため、2つの関連するツリーオブジェクト間の違いをすばやく判断できます。</p><p>(注意: サブモジュールが存在する場合、ツリーにはエントリとしてコミットが含まれる場合もあります。その文書については、<a class="xref" href="#submodules" title="Chapter 8. Submodules">Chapter 8, <i>Submodules</i></a>
を参照してください。)</p><p>注意: すべてのファイルのモードが644または755であることに注意してください。Gitは実際には実行可能ビット(executable
bit)にのみ注意を払います。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="blob-object"></a>Blob Object</h3></div></div></div><p>あなたは <a class="ulink" href="git-show.html" target="_top">git-show(1)</a> を使用して、ブロブ(blob)の内容を調べることができます。たとえば、上のツリーから
<code class="literal">COPYING</code> のエントリのブロブを取得します:</p><pre class="screen">$ git show 6ff87c4664

 Note that the only valid version of the GPL as far as this project
 is concerned is _this_ particular version of the license (ie v2, not
 v2.2 or v3.x or whatever), unless explicitly otherwise stated.
...</pre><p>「ブロブ」(blob)オブジェクトは、データのバイナリブロブ(バイナリの小さい塊)に他なりません。それは他のものを参照したり、いかなる種類の属性も持っていません。</p><p>ブロブはそのデータによって完全に定義されるため、ディレクトリツリー(またはリポジトリの複数の異なるバージョン)内の2つのファイルの内容が同じである場合、それらは同じブロブオブジェクトを共有します。オブジェクトはディレクトリツリー内の場所から完全に独立しており、ファイルの名前を変更しても、ファイルが関連付けられているオブジェクトは変更されません。</p><p>注意: &lt;revision&gt;:&lt;path&gt; 構文で <a class="ulink" href="git-show.html" target="_top">git-show(1)</a>
を使用すると、任意のツリーまたはブロブオブジェクトを調べることができることに注意してください。これは、現在チェックアウトされていないツリーの内容を参照する場合に役立つことがあります。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trust"></a>Trust(信頼性)</h3></div></div></div><p>あなたが、とあるソースからブロブのSHA-1名を受け取り、そのコンテンツを別の(おそらく信頼できない)ソースから受け取った場合でも、SHA-1名が一致する限り、それらの内容が正しいと信頼できます。これは、SHA-1が、同じハッシュを生成する異なるコンテンツを見つけることが不可能になるように設計されているためです。</p><p>同様に、あなたがディレクトリ全体のコンテンツを信頼するためには、最上位ツリーオブジェクトのSHA-1名を信頼する事だけでよいのです。信頼できるソースからコミットのSHA-1名を受け取った場合、あなたは、そのコミットの親を介して到達可能なコミットの履歴全体、およびそれらのコミットによって参照されるツリーのすべてのコンテンツを簡単に確認できます。</p><p>したがって、システムに実際の信頼を導入するには、トップレベルのコミットの名前を含む「1つの」特別なメモにデジタル署名するだけです。あなたのデジタル署名は、あなたがそのコミットを信頼していることを他の人に示し、コミットの履歴の不変性は、彼らが履歴全体を信頼できることを他の人に伝えます。</p><p>いいかえると、あなたは、トップコミットの名前(SHA-1ハッシュ)を通知する一通の電子メールを送信するだけでアーカイブ全体を簡単に検証し、GPG/PGPなどを使用してその電子メールにデジタル署名することができます。</p><p>これを支援するために、Gitはタグオブジェクトも提供しています…</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tag-object"></a>Tag Object</h3></div></div></div><p>タグオブジェクトには、オブジェクトとオブジェクトタイプとタグ名とタグを作成した人の名前("tagger")と、
<a class="ulink" href="git-cat-file.html" target="_top">git-cat-file(1)</a> を使用して確認できるように、署名を含む可能性のあるメッセージが含まれます:</p><pre class="screen">$ git cat-file tag v1.5.0
object 437b1b20df4b356c9342dac8d38849f24ef44f27
type commit
tag v1.5.0
tagger Junio C Hamano &lt;junkio@cox.net&gt; 1171411200 +0000

GIT 1.5.0
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui
nLE/L9aUXdWeTFPron96DLA=
=2E+0
-----END PGP SIGNATURE-----</pre><p>タグオブジェクトを作成および検証する方法については、 <a class="ulink" href="git-tag.html" target="_top">git-tag(1)</a> コマンドを参照してください。 (注意:
<a class="ulink" href="git-tag.html" target="_top">git-tag(1)</a>を使用して、「軽量タグ」(lightweight
tags)を作成することもできます。これは、タグオブジェクトではなく、名前が <code class="literal">refs/tags/</code> で始まる単純な参照です)。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pack-files"></a>Gitがオブジェクトを効率的に保存する方法: pack files</h3></div></div></div><p>新しく作成されたオブジェクトは、最初にオブジェクトのSHA-1ハッシュにちなんで名付けられたファイル名のファイルとして作成されます(
<code class="literal">.git/objects</code> に保存されます)。</p><p>残念ながら、プロジェクトに多くのオブジェクトがあると、このシステムは非効率になります。 古いプロジェクトで以下を試してください:</p><pre class="screen">$ git count-objects
6930 objects, 47620 kilobytes</pre><p>最初の数は、個々のファイルに保持されているオブジェクトの数です。 2つ目は、これらの「緩い」オブジェクト("loose"
objects)が占めるスペースの量です。</p><p>あなたは、これらの緩いオブジェクトを「パックファイル」(pack
file)に移動することで、スペースを節約し、Gitを高速化できます。このファイルには、オブジェクトのグループが効率的な圧縮形式で保存されます。
パックファイルのフォーマットの詳細については、 <a class="ulink" href="gitformat-pack.html" target="_top">gitformat-pack(5)</a> をご覧ください。</p><p>緩いオブジェクトをパックに入れるには、 git repack を実行するだけです:</p><pre class="screen">$ git repack
Counting objects: 6020, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6020/6020), done.
Writing objects: 100% (6020/6020), done.
Total 6020 (delta 4070), reused 0 (delta 0)</pre><p>これにより、現在アンパックされているすべてのオブジェクトを含む単一の「パックファイル」が .git/objects/pack/ に作成されます。
あなたは、その後、以下を実行できます:</p><pre class="screen">$ git prune</pre><p>これは、今やパックに格納済の緩いオブジェクト("loose"
objects)をすべて削除します。これにより、参照されていないオブジェクトも削除されます(たとえば、 <code class="literal">git reset</code>
を使用してコミットを削除すると作成される可能性があります)。 <code class="literal">.git/objects</code>
ディレクトリを確認するか、以下を実行することで、緩んだオブジェクトがなくなったことを確認できます。</p><pre class="screen">$ git count-objects
0 objects, 0 kilobytes</pre><p>オブジェクトファイルはなくなりましたが、それらのオブジェクトを参照するコマンドは、以前とまったく同じように機能します。</p><p><a class="ulink" href="git-gc.html" target="_top">git-gc(1)</a>
コマンドは、パッキング(packing)やプルーニング(pruning)を実行します。このため、通常、あなたに必要な高レベルのコマンドはこのコマンドだけです。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dangling-objects"></a>Dangling objects(宙ぶらりんオブジェクト)</h3></div></div></div><p><a class="ulink" href="git-fsck.html" target="_top">git-fsck(1)</a> コマンドは、宙ぶらりんオブジェクト(dangling
objects)について文句を言うことがあります。それらは問題ではありません。</p><p>宙ぶらりんオブジェクトの最も一般的な原因は、ブランチをリベースしたか、ブランチをリベースした他の誰かからプルしたことです。
<a class="xref" href="#cleaning-up-history" title="Chapter 5. Rewriting history and maintaining patch series">Chapter 5, <i>Rewriting history and maintaining patch series</i></a> を参照してください。
その場合、元のブランチの古いヘッドは、それが指しているすべてのものと同様に、まだ存在しています。ブランチポインタ自体は、別のポインタに置き換えたため、存在していません。</p><p>宙ぶらりんオブジェクトを引き起こす他の状況もあります。たとえば、ファイルに「git
add」を実行したために「宙ぶらりんブロブ」が発生する可能性があります。実際にコミットして全体像の一部にする前に、そのファイル内の別の何かを変更し、その更新されたものをコミットした場合—この時最初に追加した古い状態は、コミットまたはツリーによってポイントされないため、宙ぶらりんブロブオブジェクトになります。</p><p>同様に、 "ort" マージ戦略が実行され、交差マージ(criss-cross
merge)があり、したがって複数のマージベースがあることがわかった場合(これはかなり珍しいですが、実際に発生します)、一時的な内部マージベースとして1つの一時的な中間ツリーを生成します。そして、それらは実際のオブジェクトですが、最終結果はそれらを指すことにはならないため、リポジトリ内で「宙ぶらりん」になります(または、交差マージが多数あり、マージベースが3つ以上ある場合は、さらに多くの可能性があります)。</p><p>一般的に、宙ぶらりんオブジェクトは心配する必要はありません。それらは非常に役立つことさえあります。あなたが何かを台無しにした場合、宙ぶらりんオブジェクトはあなたがあなたの古いツリーを回復する方法になることができます(たとえば、リベースを行った後で、本当はリベースをやりたくなかった気づきました。持っている宙ぶらりんオブジェクトを確認して、ヘッドを古い宙ぶらりん状態にリセットすることができます)。</p><p>コミットの場合は、あなたは以下を使用できます:</p><pre class="screen">$ gitk &lt;dangling-commit-sha-goes-here&gt; --not --all</pre><p>これは、指定されたコミットから到達可能なすべての履歴を要求しますが、ブランチ、タグ、またはその他の参照からは要求しません。
必要なものであると判断した場合は、いつでも新しい参照を作成できます。たとえば、</p><pre class="screen">$ git branch recovered-branch &lt;dangling-commit-sha-goes-here&gt;</pre><p>ブロブとツリーの場合、同じことはできませんが、それでも調べることができます。 あなたはただ以下のようにするだけです。</p><pre class="screen">$ git show &lt;dangling-blob/tree-sha-goes-here&gt;</pre><p>ブロブの内容が何であるか(または、ツリーの場合、基本的にそのディレクトリの <code class="literal">ls</code>
したのが何であるか)を示すために、それはあなたに宙ぶらりんオブジェクトを残した操作が何であったかについてのいくらかの考えを与えるかもしれません。</p><p>通常、宙ぶらりんのブロブやツリーはあまり興味深くはありません。ほとんどの場合、それらは中途のマージベースであるか(手動で修正した競合するマージがあった場合、ブローブにはマージからの競合マーカーが含まれることがよくあります)、または、<code class="literal">git
fetch</code> で、あなたが ^C
か何かで中断すると、オブジェクトデータベースに新しいオブジェクトの一部を残す事が発生しますが、それらは役に立たない単なる宙ぶらりんです。</p><p>とにかく、あなたは宙ぶらりん状態に興味がないと確信したら、あなたは到達できないすべてのオブジェクトを削除できます:</p><pre class="screen">$ git prune</pre><p>そしてそれらは消え去ります。(あなたは、静止した、活動していないリポジトリでのみ <code class="literal">git prune</code>
を実行すべきです。これは、ファイルシステムのfsckリカバリを実行するようなものです。あなたはfsckを、ファイルシステムがマウントされている間は実行したくないでしょう。同様に
<code class="literal">git prune</code>
は、リポジトリへの同時アクセスの場合でも害を及ぼさないように設計されていますが、紛らわしいメッセージや恐ろしいメッセージを受け取る可能性があります。）</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="recovering-from-repository-corruption"></a>破損したリポジトリの回復</h3></div></div></div><p>設計上、Gitは信頼できるデータを慎重に扱います。ただし、Git自体にバグがない場合でも、ハードウェアまたはオペレーティングシステムのエラーによってデータが破損する可能性があります。</p><p>このような問題に対する最初の防御策はバックアップです。cloneを使用するか、cp、tar、またはその他のバックアップメカニズムを使用して、Gitディレクトリをバックアップできます。</p><p>最後の手段として、破損したオブジェクトを検索し、手動で置き換えることができます。その処理でさらに破損してしまう場合に備えて、これを試行する前にリポジトリをバックアップしてください。</p><p>私達は、問題は単一の欠落または破損したブロブであると想定しますが、これは解決可能な問題である場合があります。
(欠落しているツリー、特にコミットを回復することは*非常に*困難です)。</p><p>開始する前に、破損があることを確認し、 <a class="ulink" href="git-fsck.html" target="_top">git-fsck(1)</a>
を使用して破損がどこにあるかを把握します。これにはけっこう時間がかかる場合があります。</p><p>出力が次のようになっているとします:</p><pre class="screen">$ git fsck --full --no-dangling
broken link from    tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8
              to    blob 4b9458b3786228369c63936db65827de3cc06200
missing blob 4b9458b3786228369c63936db65827de3cc06200</pre><p>これで、ブロブ 4b9458b3 が欠落しており、ツリー 2d9263c6
がそれを指していることがわかります。欠落しているブロブブジェクトのコピーが1つだけ見つかった場合は、おそらく他のリポジトリで、それを
<code class="literal">.git/objects/4b/9458b3...</code> に移動して実行できます。
しかし、あなたはそれができなかったということにしましょう。そうするってぇと、あなたは <a class="ulink" href="git-ls-tree.html" target="_top">git-ls-tree(1)</a>
を使用して、それを指しているツリーを調べることができます。これにより、以下のような出力が得られるかもしれません:</p><pre class="screen">$ git ls-tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8
100644 blob 8d14531846b95bfa3564b58ccfb7913a034323b8    .gitignore
100644 blob ebf9bf84da0aab5ed944264a5db2a65fe3a3e883    .mailmap
100644 blob ca442d313d86dc67e0a2e5d584b465bd382cbf5c    COPYING
...
100644 blob 4b9458b3786228369c63936db65827de3cc06200    myfile
...</pre><p>これで、欠落しているブロブが <code class="literal">myfile</code> という名前のファイルのデータであることがわかりました。
また、ディレクトリを特定できる可能性もあります。たとえば、「somedirectory」にあるとします。
運が良ければ、不足しているコピーは、作業ツリーの <code class="literal">somedirectory/myfile</code> でチェックアウトしたコピーと同じである可能性があります。
<a class="ulink" href="git-hash-object.html" target="_top">git-hash-object(1)</a> を使用して、それが正しいかどうかをテストできます:</p><pre class="screen">$ git hash-object -w somedirectory/myfile</pre><p>これにより、 somedirectory/myfile の内容を含むブロブオブジェクトが作成および保存され、そのオブジェクトのSHA-1が出力されます。
運が良ければ、4b9458b3786228369c63936db65827de3cc06200
になる可能性があります。その場合は、あなたの推測が正しかったということで、破損が修正されます。</p><p>それ以外の場合は、より多くの情報が必要です。あなたはファイルのどのバージョンが失われたかをどのように知ればよいのでしょうか？</p><p>これを行う最も簡単な方法は以下のとおりです:</p><pre class="screen">$ git log --raw --all --full-history -- somedirectory/myfile</pre><p>あなたは生の出力を問い合わせたので、あなたは以下のようなものを得ます。</p><pre class="screen">commit abc
Author:
Date:
...
:100644 100644 4b9458b newsha M somedirectory/myfile


commit xyz
Author:
Date:

...
:100644 100644 oldsha 4b9458b M somedirectory/myfile</pre><p>これは、ファイルの直前のバージョンが「newsha」であり、直前のバージョンが「oldsha」であったことを示しています。
また、oldshaから4b9458bへの変更、および4b9458bからnewshaへの変更に伴うコミットメッセージも分かります。</p><p>十分に小さな変更をコミットしている場合は、中間状態4b9458bの内容が再構築するのに適している可能性があります。</p><p>もしそれが可能でであれば、あなたは不足しているオブジェクトを以下のように再作成できます。</p><pre class="screen">$ git hash-object -w &lt;recreated-file&gt;</pre><p>そしてあなたのリポジトリは再び正常になります。</p><p>(ところで、あなたは <code class="literal">fsck</code> を無視する事がでます。以下の通り始めます。</p><pre class="screen">$ git log --raw --all</pre><p>そして、その全体の中で行方不明のオブジェクト(4b9458b)のshaを探しました。そうするかどうかはあなた次第です—Gitは多くの情報を*持っていて*、それはただ1つの特定のブロブバージョンを失っているだけです。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="the-index"></a>The index</h2></div></div></div><p>インデックスは、ソートされたパス名のリストを含むバイナリファイル(通常は <code class="literal">.git/index</code>
に保持されます)であり、それぞれパーミッションとブロブオブジェクトのSHA-1を含んでいます。 <a class="ulink" href="git-ls-files.html" target="_top">git-ls-files(1)</a>
は、インデックスの内容を表示できます。</p><pre class="screen">$ git ls-files --stage
100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0       .gitignore
100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0       .mailmap
100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0       COPYING
100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0       Documentation/.gitignore
100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0       Documentation/Makefile
...
100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0       xdiff/xtypes.h
100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0       xdiff/xutils.c
100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0       xdiff/xutils.h</pre><p>注意:
古いドキュメントでは、「現在のディレクトリキャッシュ」または単に「キャッシュ」と呼ばれるインデックスが表示される場合があることに注意してください。
これには3つの重要な特性があります:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
インデックスには、単一の(一意に決定された)ツリーオブジェクトを生成するために必要なすべての情報が含まれています。
</p><p class="simpara">たとえば、 <a class="ulink" href="git-commit.html" target="_top">git-commit(1)</a>
を実行すると、インデックスからこのツリーオブジェクトが生成され、オブジェクトデータベースに保存され、新しいコミットに関連付けられたツリーオブジェクトとして使用されます。</p></li><li class="listitem"><p class="simpara">
インデックスを使用すると、インデックスが定義するツリーオブジェクトと作業ツリーをすばやく比較できます。
</p><p class="simpara">これは、エントリごとにいくつかの追加データ(最終変更時刻など)を保存することによって行われます。このデータは上に表示されず、作成されたツリーオブジェクトに保存されませんが、作業ディレクトリ内のどのファイルがインデックスに保存されているものと異なるかをすばやく判断するために使用できるため、Gitはそのようなファイルからすべてのデータを読み取って変更を探す必要がありません。</p></li><li class="listitem"><p class="simpara">
異なるツリーオブジェクト間のマージの競合に関する情報を効率的に表すことができるため、各パス名を、関連するツリーに関する十分な情報に関連付けて、それらの間で3方向のマージを作成できます。
</p><p class="simpara">私達はマージ中に、インデックスが1つのファイルの複数のバージョン（「ステージ」と呼ばれる）を格納できることを
<a class="xref" href="#conflict-resolution" title="マージ作業中に競合解決の助けを得る">the section called “マージ作業中に競合解決の助けを得る”</a> で確認しました。上記の <a class="ulink" href="git-ls-files.html" target="_top">git-ls-files(1)</a>
出力の3番目の列はステージ番号であり、マージの競合があるファイルの場合は0以外の値を取ります。</p></li></ol></div><p>したがって、インデックスは一種の一時的なステージング領域であり、作業中のツリーで埋められます。</p><p>あなたがインデックスを完全に吹き飛ばしても、それが記述されたツリーの名前を持っている限り、通常、情報は失われていません。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="submodules"></a>Chapter 8. Submodules</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#pitfalls-with-submodules">サブモジュールの落とし穴</a></span></dt></dl></div><p>大規模なプロジェクトは、多くの場合、より小さな自己完結型のモジュールで構成されます。たとえば、組み込みLinuxディストリビューションのソースツリーには、いくつかのローカルな変更を加えたディストリビューション内のすべてのソフトウェアが含まれます。例えば動画プレーヤーは、特定の既知の動作バージョンの解凍ライブラリに対して構築する必要がある場合があります。複数の独立したプログラムがすべて同じビルドスクリプトを共有する場合があります。</p><p>一元化されたリビジョン管理システムでは、これは多くの場合、すべてのモジュールを1つのリポジトリに含めることで実現されます。
開発者は、すべてのモジュールをチェックアウトすることも、操作する必要のあるモジュールのみをチェックアウトすることもできます。
物事を移動したり、APIや翻訳を更新したりしながら、1回のコミットで複数のモジュール間でファイルを変更することもできます。</p><p>Gitでは部分的なチェックアウトが許可されていないため、Gitでこのアプローチを複製すると、開発者は触れたくないモジュールのローカルコピーを保持する必要があります。巨大なチェックアウトでのコミットは、Gitがすべてのディレクトリをスキャンして変更を確認する必要があるため、あなたが期待するよりもずっと遅くなります。モジュールに多くのローカル履歴がある場合、クローン操作は永遠に終わりません。</p><p>プラス面として、分散型リビジョン管理システムは、外部ソースとはるかにうまく統合できます。
一元化されたモデルでは、外部プロジェクトの単一の任意のスナップショットが独自のリビジョン管理からエクスポートされ、ベンダーブランチのローカルリビジョン管理にインポートされます。すべての歴史は隠されています。分散リビジョン管理を使用すると、外部履歴全体のクローンを作成し、開発をより簡単に追跡して、ローカルの変更を再マージできます。</p><p>Gitはサブモジュールのサポートにより、リポジトリに外部プロジェクトのチェックアウトをサブディレクトリとして含めることができます。サブモジュールは独自のIDを維持します。サブモジュールサポートは、サブモジュールリポジトリの場所とコミットIDを格納するだけなので、包含するプロジェクト("superproject")を複製する他の開発者は、同一リビジョンのすべてのサブモジュールを簡単に複製できます。スーパープロジェクトの部分的なチェックアウトができます。あなたはサブモジュールのクローンを作成しない、一部、またはすべてを複製するようにGitに指示できます。</p><p><a class="ulink" href="git-submodule.html" target="_top">git-submodule(1)</a> コマンドは、Git1.5.3以降で使用できます。Git
1.5.2を使用しているユーザーは、リポジトリでサブモジュールのコミットを検索し、手動でチェックアウトできます。それ以前のバージョンはサブモジュールをまったく認識しません。</p><p>サブモジュールのサポートがどのように機能するかを確認するには、ここで、後でサブモジュールとして使用できる4つのリポジトリ例を作成します:</p><pre class="screen">$ mkdir ~/git
$ cd ~/git
$ for i in a b c d
do
        mkdir $i
        cd $i
        git init
        echo "module $i" &gt; $i.txt
        git add $i.txt
        git commit -m "Initial commit, submodule $i"
        cd ..
done</pre><p>次に、スーパープロジェクトを作成し、すべてのサブモジュールを追加します:</p><pre class="screen">$ mkdir super
$ cd super
$ git init
$ for i in a b c d
do
        git submodule add ~/git/$i $i
done</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>！スーパープロジェクトを公開する予定がある場合は、ここでローカルURLを使用してはいけません！</p></div><p><code class="literal">git submodule</code> が作成したファイルをご覧下さい:</p><pre class="screen">$ ls -a
.  ..  .git  .gitmodules  a  b  c  d</pre><p><code class="literal">git submodule add &lt;repo&gt; &lt;path&gt;</code> コマンドは以下のことを行います:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
サブモジュールを <code class="literal">&lt;repo&gt;</code> から現在のディレクトリの下の指定された <code class="literal">&lt;path&gt;</code>
  に複製し、デフォルトでmasterブランチをチェックアウトします。
</li><li class="listitem">
サブモジュールのクローンパスを <a class="ulink" href="gitmodules.html" target="_top">gitmodules(5)</a>
  ファイルに追加し、このファイルをインデックスに追加して、コミットの準備をします。
</li><li class="listitem">
サブモジュールの現在のコミットIDをインデックスに追加し、コミットの準備をします。
</li></ul></div><p>スーパープロジェクトをコミットします:</p><pre class="screen">$ git commit -m "Add submodules a, b, c and d."</pre><p>次に、スーパープロジェクトのクローンを作成します:</p><pre class="screen">$ cd ..
$ git clone super cloned
$ cd cloned</pre><p>サブモジュールディレクトリは存在しますが、空です:</p><pre class="screen">$ ls -a a
.  ..
$ git submodule status
-d266b9873ad50488163457f025db7cdd9683d88b a
-e81d457da15309b4fef4249aba9b50187999670d b
-c1536a972b9affea0f16e0680ba87332dc059146 c
-d96249ff5d57de5de093e6baff9e0aafa5276a74 d</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>上記のコミットオブジェクト名はユーザーによって異なりますが、リポジトリのHEADコミットオブジェクト名と一致している必要があります。 <code class="literal">git
ls-remote ../a</code> を実行することで確認できます。</p></div><p>サブモジュールを引き出すのは2段階のプロセスです。 最初に <code class="literal">git submodule init</code> を実行して、サブモジュールリポジトリのURLを
<code class="literal">.git/config</code> に追加します:</p><pre class="screen">$ git submodule init</pre><p>次に、 <code class="literal">git submodule update</code>
を使用してリポジトリのクローンを作成し、スーパープロジェクトでチェックアウトされているコミットを確認します:</p><pre class="screen">$ git submodule update
$ cd a
$ ls -a
.  ..  .git  a.txt</pre><p><code class="literal">git submodule update</code> と <code class="literal">git submodule add</code> の大きな違いの1つは、 <code class="literal">git submodule
update</code>
がブランチの先端ではなく、特定のコミットをチェックアウトすることです。これは、タグをチェックアウトするようなものです。ヘッドが切り離されているため、あなたはブランチで作業していません。</p><pre class="screen">$ git branch
* (detached from d266b98)
  master</pre><p>サブモジュール内で変更を加えたい場合で、ヘッドが切り離されている場合は、ブランチを作成またはチェックアウトし、変更を加え、サブモジュール内で変更を公開してから、スーパープロジェクトを更新して新しいコミットを参照する必要があります:</p><pre class="screen">$ git switch master</pre><p>または</p><pre class="screen">$ git switch -c fix-up</pre><p>してから</p><pre class="screen">$ echo "adding a line again" &gt;&gt; a.txt
$ git commit -a -m "Updated the submodule from within the superproject."
$ git push
$ cd ..
$ git diff
diff --git a/a b/a
index d266b98..261dfac 160000
--- a/a
+++ b/a
@@ -1 +1 @@
-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b
+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24
$ git add a
$ git commit -m "Updated submodule a."
$ git push</pre><p>サブモジュールも更新する場合は、 <code class="literal">git pull</code> の後に <code class="literal">git submodule update</code> を実行する必要があります。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pitfalls-with-submodules"></a>サブモジュールの落とし穴</h2></div></div></div><p>サブモジュールの変更を参照するスーパープロジェクトに変更を公開する前に、必ずサブモジュールの変更を公開してください。サブモジュールの変更を公開するのを忘れると、他の人はリポジトリのクローンを作成できなくなります:</p><pre class="screen">$ cd ~/git/super/a
$ echo i added another line to this file &gt;&gt; a.txt
$ git commit -a -m "doing it wrong this time"
$ cd ..
$ git add a
$ git commit -m "Updated submodule a again."
$ git push
$ cd ~/git/cloned
$ git pull
$ git submodule update
error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.
Did you forget to 'git add'?
Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'</pre><p>古いバージョンのGitでは、サブモジュールで新しいファイルや変更されたファイルをコミットすることを簡単に忘れてしまう可能性があります。これにより、サブモジュールの変更をプッシュしないのと同様の問題が発生します。
Git 1.7.0以降、スーパープロジェクトの <code class="literal">git status</code> と <code class="literal">git diff</code>
はどちらも、サブモジュールが誤ってそのような状態になるのを防ぐために、新しいファイルまたは変更されたファイルが含まれている場合に変更されたものとして表示します。
<code class="literal">git diff</code> は、パッチ出力を生成するとき、または <code class="literal">--submodule</code> オプションとともに使用するときに、作業ツリー側に
<code class="literal">-dirty</code> と付加します:</p><pre class="screen">$ git diff
diff --git a/sub b/sub
--- a/sub
+++ b/sub
@@ -1 +1 @@
-Subproject commit 3f356705649b5d566d97ff843cf193359229a453
+Subproject commit 3f356705649b5d566d97ff843cf193359229a453-dirty
$ git diff --submodule
Submodule sub 3f35670..3f35670-dirty:</pre><p>また、スーパープロジェクトでこれまでに記録されたコミットを超えて、サブモジュールのブランチを巻き戻さないでください。</p><p>最初にブランチをチェックアウトせずにサブモジュール内で変更を加えてコミットした場合、 <code class="literal">git submodule update</code>
を実行するのは安全ではありません。 それらは黙って上書きされます:</p><pre class="screen">$ cat a.txt
module a
$ echo line added from private2 &gt;&gt; a.txt
$ git commit -a -m "line added inside private2"
$ cd ..
$ git submodule update
Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'
$ cd a
$ cat a.txt
module a</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>その変更は、サブモジュールのreflogに引き続き表示されます。</p></div><p>サブモジュールの作業ツリーにコミットされていない変更がある場合、 <code class="literal">git submodule update</code> はそれらを上書きしません。
代わりに、ダーティブランチから切り替えることができないという通常の警告が表示されます。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="low-level-operations"></a>Chapter 9. Low-level Git operations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#object-manipulation">Object access and manipulation</a></span></dt><dt><span class="section"><a href="#the-workflow">The Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#working-directory-to-index">working directory → index</a></span></dt><dt><span class="section"><a href="#index-to-object-database">index → object database</a></span></dt><dt><span class="section"><a href="#object-database-to-index">object database → index</a></span></dt><dt><span class="section"><a href="#index-to-working-directory">index → working directory</a></span></dt><dt><span class="section"><a href="#tying-it-all-together">全てを結び付ける</a></span></dt></dl></dd><dt><span class="section"><a href="#examining-the-data">Examining the data</a></span></dt><dt><span class="section"><a href="#merging-multiple-trees">Merging multiple trees</a></span></dt><dt><span class="section"><a href="#merging-multiple-trees-2">Merging multiple trees, continued</a></span></dt></dl></div><p>高レベルのコマンドの多くは、かつては低レベルのGitコマンドの小さなコアを使用するシェルスクリプトとして実装されていました。これらは、Gitで通常とは異なることを行う場合、またはGitの内部動作を理解する方法としても役立ちます。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object-manipulation"></a>Object access and manipulation</h2></div></div></div><p><a class="ulink" href="git-cat-file.html" target="_top">git-cat-file(1)</a> コマンドは、任意のオブジェクトの内容を表示できますが、通常は、より高いレベルの
<a class="ulink" href="git-show.html" target="_top">git-show(1)</a> の方が便利です。</p><p><a class="ulink" href="git-commit-tree.html" target="_top">git-commit-tree(1)</a> コマンドを使用すると、任意の親とツリーを使用してコミットを構築できます。</p><p>ツリーは <a class="ulink" href="git-write-tree.html" target="_top">git-write-tree(1)</a> で作成でき、そのデータには <a class="ulink" href="git-ls-tree.html" target="_top">git-ls-tree(1)</a>
でアクセスできます。 2つのツリーを <a class="ulink" href="git-diff-tree.html" target="_top">git-diff-tree(1)</a> で比較できます。</p><p>タグは <a class="ulink" href="git-mktag.html" target="_top">git-mktag(1)</a> で作成され、署名は <a class="ulink" href="git-verify-tag.html" target="_top">git-verify-tag(1)</a> で確認できますが、通常は両方に
<a class="ulink" href="git-tag.html" target="_top">git-tag(1)</a> を使用する方が簡単です。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="the-workflow"></a>The Workflow</h2></div></div></div><p><a class="ulink" href="git-commit.html" target="_top">git-commit(1)</a> や <a class="ulink" href="git-restore.html" target="_top">git-restore(1)</a>
などの高レベルの操作は、作業ツリー、インデックス、およびオブジェクトデータベース間でデータを移動することによって機能します。
Gitは、これらの各ステップを個別に実行する低レベルの操作を提供します。</p><p>通常、すべてのGit操作はインデックスファイルで機能します。一部の操作はインデックスファイルに対して*純粋に*機能します(インデックスの現在の状態を示す)が、ほとんどの操作は、インデックスファイルとデータベースまたは作業ディレクトリの間でデータを移動します。
したがって、Git操作には4つの主要な組み合わせがあります:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="working-directory-to-index"></a>working directory → index</h3></div></div></div><p><a class="ulink" href="git-update-index.html" target="_top">git-update-index(1)</a> コマンドは、作業ディレクトリからの情報でインデックスを更新します。
通常、以下のように、更新するファイル名を指定するだけでインデックス情報を更新します:</p><pre class="screen">$ git update-index filename</pre><p>ただし、ファイル名のグロブなどでよくある間違いを避けるために、コマンドは通常、まったく新しいエントリを追加したり、古いエントリを削除したりしません。つまり、通常は既存のキャッシュエントリを更新するだけです。</p><p>つまり、特定のファイルがもう存在しないこと、または新しいファイルを追加する必要があることをGitに伝えるには、それぞれ <code class="literal">--remove</code> フラグと
<code class="literal">--add</code> フラグを使用する必要があります。</p><p>注意！ <code class="literal">--remove</code>
フラグは、そのフラグの後ろに記述されたファイル名が必ずしも削除されることを意味しません。ファイルがディレクトリ構造にまだ存在する場合、インデックスは削除されずに新しいステータスで更新されます。
<code class="literal">--remove</code>
が意味する唯一のことは、update-indexが削除されたファイルを有効なものと見なし、ファイルが実際に存在しなくなった場合、それに応じてインデックスを更新することです。</p><p>特別な場合として、 <code class="literal">git update-index --refresh</code>
を実行することもできます。これにより、各インデックスの「統計」情報が現在の統計情報と一致するように更新されます。オブジェクトのステータス自体は「更新されません」。オブジェクトが古いバッキングストアオブジェクトとまだ一致するかどうかをすばやくテストするために使用されるフィールドのみが更新されます。</p><p>以前紹介した <a class="ulink" href="git-add.html" target="_top">git-add(1)</a> は、 <a class="ulink" href="git-update-index.html" target="_top">git-update-index(1)</a> の単なるラッパーです。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-to-object-database"></a>index → object database</h3></div></div></div><p>あなたは、プログラムを使用して、現在のインデックスファイルを「ツリー」オブジェクトに書き込みます</p><pre class="screen">$ git write-tree</pre><p>これにはオプションはありません。現在のインデックスをその状態を説明するツリーオブジェクトのセットに書き出すだけです。そして結果の最上位ツリーの名前が返されます。
そのツリーを使用して、いつでも別の方向からインデックスを再生成できます:</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="object-database-to-index"></a>object database → index</h3></div></div></div><p>オブジェクトデータベースから「ツリー」ファイルを読み取り、それを使用して現在のインデックスにデータを入力します(そして上書きします。後で復元する可能性のある未保存の状態がインデックスに含まれている場合は、やってはいけません！)。通常の操作は以下の通り</p><pre class="screen">$ git read-tree &lt;SHA-1 of tree&gt;</pre><p>これで、インデックスファイルは前に保存したツリーと同等になります。
ただし、これは「インデックス」ファイルのみです。作業ディレクトリの内容は変更されていません。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-to-working-directory"></a>index → working directory</h3></div></div></div><p>ファイルを「チェックアウト」することにより、インデックスから作業ディレクトリを更新します。これはあまり一般的な操作ではありません。通常はファイルを更新したままにし、作業ディレクトリに書き込むのではなく、作業ディレクトリの変更についてインデックスファイルに通知するためです(つまり、
<code class="literal">git update-index</code> )。</p><p>ただし、新しいバージョンにジャンプしたり、他の人のバージョンをチェックアウトしたり、以前のツリーを復元したりする場合は、インデックスファイルにread-treeを入力してから、結果をチェックアウトする必要があります。</p><pre class="screen">$ git checkout-index filename</pre><p>または、すべてのインデックスをチェックアウトする場合は、 <code class="literal">-a</code> を使用します。</p><p>注意！ <code class="literal">git checkout-index</code>
は通常、古いファイルの上書きを拒否するため、古いバージョンのツリーが既にチェックアウトされている場合は、 <code class="literal">-f</code> フラグを指定する( <code class="literal">-a</code> フラグ
または filename より前に指定する)とチェックアウトを強制します。</p><p>最後に、これまでの範疇にない半端な話題をいくつか:</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tying-it-all-together"></a>全てを結び付ける</h3></div></div></div><p><code class="literal">git write-tree</code>
でインスタンス化したツリーをコミットするには、そのツリーとその背後にある履歴(最も注目すべきは、履歴上、その前にあった「親」のコミットです)を参照する「commit」オブジェクトを作成します。</p><p>通常、「コミット」には1つの親があります。つまり、特定の変更が行われる前のツリーの以前の状態です。ただし、2つ以上の親コミットを持つ場合もあります。その場合、そのようなコミットは、他のコミットによって表される2つ以上の以前の状態をまとめる(「マージする」)ため、「マージ」と呼びます。</p><p>つまり、「ツリー」は作業ディレクトリの特定のディレクトリ状態を表し、「コミット」は時間内のその状態を表し、どのようにしてそこに到達したかを説明します。</p><p>コミット時の状態を説明するツリーと親のリストをオブジェクトに与えることで、コミットオブジェクトを作成します:</p><pre class="screen">$ git commit-tree &lt;tree&gt; -p &lt;parent&gt; [(-p &lt;parent2&gt;)...]</pre><p>次に、stdinでコミットの理由を示します(パイプまたはファイルからのリダイレクト、またはttyで入力するだけ)。</p><p><code class="literal">git commit-tree</code> は、そのコミットを表すオブジェクトの名前を返します。あなたはそれを後で使用できるように保存しておくべきです。
通常、新しい <code class="literal">HEAD</code>
状態をコミットし、Gitはその状態に関するメモをどこに保存するかを気にしませんが、実際には、最後にコミットされた状態が何であったかを常に確認できるように、
<code class="literal">.git/HEAD</code> が指すファイルに結果を書き込む傾向があります。</p><p>以下は、さまざまな部分がどのように組み合わされるかを示す図です:</p><pre class="screen">                     commit-tree
                      commit obj
                       +----+
                       |    |
                       |    |
                       V    V
                    +-----------+
                    | Object DB |
                    |  Backing  |
                    |   Store   |
                    +-----------+
                       ^
           write-tree  |     |
             tree obj  |     |
                       |     |  read-tree
                       |     |  tree obj
                             V
                    +-----------+
                    |   Index   |
                    |  "cache"  |
                    +-----------+
         update-index  ^
             blob obj  |     |
                       |     |
    checkout-index -u  |     |  checkout-index
             stat      |     |  blob obj
                             V
                    +-----------+
                    |  Working  |
                    | Directory |
                    +-----------+</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examining-the-data"></a>Examining the data</h2></div></div></div><p>あなたはさまざまなヘルパーツールを使用して、オブジェクトデータベースとインデックスに表示されているデータを調べることができます。すべてのオブジェクトについて、
<a class="ulink" href="git-cat-file.html" target="_top">git-cat-file(1)</a> を使用して、オブジェクトに関する詳細を調べることができます:</p><pre class="screen">$ git cat-file -t &lt;objectname&gt;</pre><p>上記はオブジェクトのタイプを表示します。タイプを取得すると(もっとも、通常はオブジェクトの配置場所で自明ではありますけれども)、以下を使用できます</p><pre class="screen">$ git cat-file blob|tree|commit|tag &lt;objectname&gt;</pre><p>とすると、その内容を表示します。 注意！ ツリーの内容はバイナリです。よって、その内容を表示するための「git
ls-tree」と呼ばれる特別なヘルパーが、内容のバイナリをより読みやすい形式に変換します。</p><p>「コミット」オブジェクトは小さく、かなり自明である傾向があるため、それらを確認することは特に有益です。 特に、あなたが <code class="literal">.git/HEAD</code>
に先頭コミット名を付けるという規則に従うと、以下のことができます。</p><pre class="screen">$ git cat-file commit HEAD</pre><p>は、先頭コミットが何であったかを表示します。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="merging-multiple-trees"></a>Merging multiple trees</h2></div></div></div><p>Gitは、3方向マージを実行するのに役立ちます。これは、マージ手順を数回繰り返すことで、多方向マージに使用できます。
通常の状況では、3方向マージ(2ラインの履歴の調整)を1回だけ実行して結果をコミットしますが、必要に応じて、一度に複数のブランチをマージできます。</p><p>3方向マージを実行するには、マージする2つのコミットから開始し、最も近い共通の親(3番目のコミット)を見つけて、これら3つのコミットに対応するツリーを比較します。</p><p>マージの「ベース」を取得するには、2つのコミットの共通の親を検索します:</p><pre class="screen">$ git merge-base &lt;commit1&gt; &lt;commit2&gt;</pre><p>これにより、両方が基づいているコミットの名前が出力されます。これらのコミットのツリーオブジェクトを検索する必要があります。これは、以下の方法で簡単に実行できます</p><pre class="screen">$ git cat-file commit &lt;commitname&gt; | head -1</pre><p>これは、ツリーオブジェクト情報は常にコミットオブジェクトの最初の行にからです。</p><p>マージする3つのツリー(1つの「元の」ツリー（別名共通ツリー）と2つの「結果」ツリー（別名マージするブランチ))が分かったら、インデックスに「マージ」読み取りを行います。
古いインデックスの内容を破棄する必要がある場合には文句を言うので、それらをコミット済であることをことを確認する必要があります。実際、通常は常に最後のコミットに対してマージを実行します(したがって、とにかく現在のインデックスにあるものと一致する必要があります)。</p><p>マージを行うには以下を行います</p><pre class="screen">$ git read-tree -m -u &lt;origtree&gt; &lt;yourtree&gt; &lt;targettree&gt;</pre><p>これにより、とるにたりない些細な3方向マージ操作(trivial merge operations)の全てがインデックスファイルに対して直接実行され、
<code class="literal">git write-tree</code> を使用して結果を書き出すことができます。(訳注:trivial;ラテン語「3
本の道が合する所，ありふれたこと」の意がある)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="merging-multiple-trees-2"></a>Merging multiple trees, continued</h2></div></div></div><p>悲しいことに、多くのマージはとるにたりないものでもなく些細なものでもありません。
追加、移動、または削除されたファイルがある場合、または両方のブランチが同じファイルを変更した場合は、「マージエントリ」を含むインデックスツリーが残ります。
このようなインデックスツリーはツリーオブジェクトに書き出すことはできません。結果を書き出す前に、他のツールを使用してこのようなマージの衝突を解決する必要があります。</p><p>このようなインデックスの状態は、 <code class="literal">git ls-files --unmerged</code> コマンドで調べることができます。 たとえば:</p><pre class="screen">$ git read-tree -m $orig HEAD $target
$ git ls-files --unmerged
100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1       hello.c
100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2       hello.c
100644 cc44c73eb783565da5831b4d820c962954019b69 3       hello.c</pre><p><code class="literal">git ls-files --unmerged</code> 出力の各行は、ブロブモードビット、ブロブ SHA-1、「ステージ番号」、ファイル名 です。
「ステージ番号」は、Gitがどのツリーから来たかを示す方法です。ステージ1は「$orig」ツリーに対応し、ステージ2は「HEAD」ツリーに対応し、ステージ3は「$target」ツリーに対応します。</p><p>ささいなマージは <code class="literal">git read-tree -m</code> 内で行われると先に述べました。 たとえば、ファイルが <code class="literal">$orig</code> から、 <code class="literal">HEAD</code>
または <code class="literal">$target</code> に変更されなかった場合、または同様に、ファイルが <code class="literal">$orig</code> から <code class="literal">HEAD</code> に変更され、かつ、 <code class="literal">$orig</code> が
<code class="literal">$target</code> に変更された場合、最終的な結果は明らかに <code class="literal">HEAD</code> にあるものです。上記の例が示すのは、ファイル <code class="literal">hello.c</code> が
<code class="literal">$orig</code> から <code class="literal">HEAD</code> に、かつ、 <code class="literal">$ orig</code> から <code class="literal">$target</code>
に別の方法で変更されたことです。これは、以下のように、あなたのお気に入りの3方向マージプログラム、例えば、これら3つのステージのブロブオブジェクトに対する
<code class="literal">diff3</code> または <code class="literal">merge</code> またはGit独自の merge-file を実行することで解決できます:</p><pre class="screen">$ git cat-file blob 263414f &gt;hello.c~1
$ git cat-file blob 06fa6a2 &gt;hello.c~2
$ git cat-file blob cc44c73 &gt;hello.c~3
$ git merge-file hello.c~2 hello.c~1 hello.c~3</pre><p>これにより、競合がある場合は競合マーカーとともに、マージ結果が <code class="literal">hello.c~2</code>
ファイルに残ります。マージ結果が理にかなっていることを確認した後、あなたは、このファイルの最終的なマージ結果が何であるかをGitに伝えることができます:</p><pre class="screen">$ mv -f hello.c~2 hello.c
$ git update-index hello.c</pre><p>パスが「マージされていない」状態の場合、そのパスに対して <code class="literal">git update-index</code>
を実行すると、Gitにパスを解決済みとしてマークするように指示します。</p><p>上記は、内部で概念的に何が起こるかを理解するのに役立つ、最下位レベルでのGitマージの説明です。 実際には、Git自体でさえも、このために <code class="literal">git
cat-file</code> を3回実行する人は誰もいません。ステージを一時ファイルに抽出し、その上で「マージ」スクリプトを呼び出す <code class="literal">git
merge-index</code> プログラムがあります:</p><pre class="screen">$ git merge-index git-merge-one-file hello.c</pre><p>そして、これが、より高いレベルの <code class="literal">git merge -s resolve</code> の実装になっています。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="hacking-git"></a>Chapter 10. Hacking Git</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#object-details">Object storage format</a></span></dt><dt><span class="section"><a href="#birdview-on-the-source-code">Gitのソースコードを俯瞰する</a></span></dt></dl></div><p>この章では、おそらくGit開発者だけが理解する必要があるGit実装の内部の詳細について説明します。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="object-details"></a>Object storage format</h2></div></div></div><p>すべてのオブジェクトには、オブジェクトの形式(つまり、オブジェクトの使用方法や他のオブジェクトの参照方法)を識別する、静的に決定された「タイプ」(
"type" )があります。 現在、「blob」、「tree」、「commit」、「tag」の4つの異なるオブジェクトタイプがあります。</p><p>オブジェクトタイプに関係なく、すべてのオブジェクトは次の特性を共有します:
すべてzlibで圧縮され、タイプを指定するだけでなく、オブジェクト内のデータに関するサイズ情報も提供するヘッダーがあります。オブジェクトの名前付けに使用されるSHA-1ハッシュは、
元のデータ＋ヘッダー のハッシュであるため、 <code class="literal">sha1sum</code> <span class="emphasis"><em>file</em></span> は <span class="emphasis"><em>file</em></span> のオブジェクト名と一致しないことに注意してください。</p><p>その結果、オブジェクトの一般的な整合性は、オブジェクトの内容やタイプに関係なく常にテストできます。すべてのオブジェクトは、
(a)ハッシュがファイルの内容と一致、かつ、 (b)オブジェクトが、 <code class="literal">&lt;ascii type without space&gt; + &lt;space&gt; +
&lt;ascii decimal size&gt; + &lt;byte\0&gt; + &lt;binary object data&gt;</code>
というシーケンスのバイトストリームへちゃんと解凍できることで検証できます。</p><p>構造化オブジェクトは、その構造と他のオブジェクトへの接続をさらに検証できます。
これは通常、すべてのオブジェクトの完全な依存関係グラフを生成し、（ハッシュを介して表面的な一貫性を検証するだけでなく）内部の一貫性を検証する
<code class="literal">gitfsck</code> プログラムを使用して行われます。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="birdview-on-the-source-code"></a>Gitのソースコードを俯瞰する</h2></div></div></div><p>新しい開発者がGitのソースコードを見つけるのは必ずしも簡単ではありません。この節では、あなたがどこから始めればよいかを示すちょっとしたガイダンスを提供します。</p><p>開始するのに適した場所は、最初のコミットの内容から始めることです:</p><pre class="screen">$ git switch --detach e83c5163</pre><p>最初のリビジョンは、Gitが今日持っているほとんどすべての基礎を築きますが、一度に読むには十分小さくまとまっています。</p><p>そのリビジョン以降、用語が変更されていることに注意してください。 たとえば、そのリビジョンのREADMEは、 "changeset"
という単語を使用して、今、 <a class="link" href="#def_commit_object">commit</a> と呼んでいるものを説明しています。</p><p>また、それを「キャッシュ」と呼ぶのではなく、「インデックス」と呼びます。 ただし、このファイルは引き続き <code class="literal">cache.h</code> と呼ばれます。備考:
これを変更する理由はたいしたものではありません。GitのすべてのCソースでincludeされている基本的なヘッダーファイルであるため、他に適切な単一の名前がないためです。</p><p>あなたが最初のコミットでGitの考え方を把握したなら、あなたはより新しいバージョンをチェックして、 <code class="literal">cache.h</code> と` object.h` と
<code class="literal">commit.h</code> を読み下すべきです。</p><p>初期のGitは、(UNIXの伝統でである)非常に単純なプログラムの集まりであり、スクリプトで使用して、出力を別のプログラムにパイプしていました。
新しいものをテストするのが簡単だったので、これは初期開発に適していました。ただし、最近、これらのパーツの多くが組み込みになり、コアの一部が「解放」(
"libified" )されました。つまり、パフォーマンス、移植性、およびコードの重複を避けるために libgit.a に配置されました。</p><p>今や、あなたはインデックスが何であるか(および、対応するデータ構造を <code class="literal">cache.h</code> で探す)、そして最初のメンバーである <code class="literal">struct
object</code> から共通の構造を継承するオブジェクトタイプ(blobs と trees と commits と
tags)がいくつかあることがわかりました(したがって、たとえば <code class="literal">(struct object *)commit</code> をキャストして
、 <code class="literal">&amp;commit-&gt;object</code> と同じようにすることができます。つまり、オブジェクト名とフラグを取得します)。</p><p>ここで、この情報を吸収するために一服するとしましょう。</p><p>次のステップ: オブジェクトの命名に慣れてください。 <a class="xref" href="#naming-commits" title="Naming commits">the section called “Naming commits”</a> を読んでください。
オブジェクトに名前を付ける方法はたくさんあります(リビジョンだけではありません！)。 これらはすべて <code class="literal">sha1_name.c</code> で処理されます。 関数
<code class="literal">get_sha1()</code> をざっと見てください。特別な処理の多くは、 <code class="literal">get_sha1_basic()</code> などの関数によって実行されます。</p><p>リビジョンウォーカー。これはGitの最も解放(libified)された部分にあなたがうまく適応できるようにします。</p><p>基本から行きましょう。 <code class="literal">git log</code> の初期バージョンは、シェルスクリプトでした:</p><pre class="screen">$ git-rev-list --pretty $(git-rev-parse --default HEAD "$@") | \
        LESS=-S ${PAGER:-less}</pre><p>これはどういう意味か？</p><p><code class="literal">git rev-list</code>
は、リビジョンウォーカーのオリジナルバージョンであり、「常に」stdoutにリビジョンのリストを出力します。ほとんどの新しいGitコマンドは <code class="literal">git
rev-list</code> を使用するスクリプトとして開始されるため、これは引き続き機能し続ける必要があります。</p><p><code class="literal">gitrev-parse</code>
はもはやそれほど重要ではありません。これは、スクリプトによって呼び出されたさまざまな配管コマンドに関連するオプションを除外するためにのみ使用されました。</p><p><code class="literal">git rev-list</code> が行ったことのほとんどは、 <code class="literal">revision.c</code> と <code class="literal">revision.h</code> に含まれています。 オプションを
<code class="literal">rev_info</code> という名前の構造体でラップします。この構造体は、どのリビジョンをどのように歩くか(walk)などを制御します。</p><p><code class="literal">git rev-parse`の元々の仕事は、今や関数 `setup_revisions()</code>
によって実行されるようになりました。この関数は、リビジョンとリビジョンウォーカーの一般的なコマンドラインオプションを解析します。この情報は、後で使用できるように構造体
<code class="literal">rev_info</code> に保存されます。 あなたは <code class="literal">setup_revisions()</code>
を呼び出した後、独自のコマンドラインオプション解析を行うことができます。 その後、初期化のために <code class="literal">prepare_revision_walk()</code>
を呼び出す必要があります。その後は、関数 <code class="literal">get_revision()</code> を使用してコミットを1つずつ取得できます。</p><p>リビジョンウォーキング処理の詳細に興味があるなら <code class="literal">cmd_log()</code> の最初の実装をご覧ください。 <code class="literal">git show
v1.3.0~155^2~4</code> を呼び出し、その関数までスクロールダウンします( <code class="literal">setup_pager()</code>
を直接呼び出す必要がなくなったことに注意してください)。</p><p>今日では <code class="literal">git log</code> は組み込みです。つまり、コマンド <code class="literal">git</code> に含まれていることを意味します。ビルトインのソースは、</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">cmd_&lt;bla&gt;</code> と呼ばれる関数で、通常は <code class="literal">builtin.h</code> で宣言され、<code class="literal">builtin/&lt;bla.c&gt;</code>
  で定義されます(Gitの古いバージョンでは、代わりに <code class="literal">builtin-&lt;bla&gt;.c</code> に含まれていたことに注意してください)。
</li><li class="listitem">
<code class="literal">git.c</code> の <code class="literal">commands[]</code> 配列のエントリ、および
</li><li class="listitem">
<code class="literal">Makefile</code> の <code class="literal">BUILTIN_OBJECTS</code> エントリ。
</li></ul></div><p>しばしば1つのソースファイルに複数のビルトインが含まれている場合があります。たとえば、 <code class="literal">cmd_whatchanged()</code> と
<code class="literal">cmd_log()</code> はどちらも、かなりのコードを共有しているため、 <code class="literal">builtin/log.c</code> にあります。その場合、それらが存在する <code class="literal">.c</code>
ファイルのように名前が付けられていないコマンドは、 <code class="literal">Makefile</code> の <code class="literal">BUILT_INS</code> にリストされている必要があります。</p><p>`git log`は、元のスクリプトよりもC言語版の方が複雑に見えますが、これにより、柔軟性とパフォーマンスが大幅に向上します。</p><p>ここでも、一息入れることをお勧めします。</p><p>レッスン3:
ソースコードを読んで学習します。マヂで、それはGitの機構について学ぶための最良の方法です(あなたが基本的な概念を知った後であれば、ですが)。</p><p>そして、あなたが興味を持っている事について考えてください、例えば、「どうすればそれのオブジェクト名を知っているだけでブロブ(blob)にアクセスできますか？」。
最初のステップは、それを実行できるGitコマンドを見つけることです。 この例では、 <code class="literal">git show</code> または <code class="literal">git cat-file</code>
のいずれかです。</p><p>ここでは分かりやすくするために、 <code class="literal">git cat-file</code> を使用します。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
これは配管コマンドで、そして
</li><li class="listitem">
それは最初のコミットに見つかりました(文字通り <code class="literal">cat-file.c</code> として約20のリビジョンを経ただけで、ビルトインになったときに
  <code class="literal">builtin/cat-file.c</code> に名前が変更され、その後10に満たないバージョンが表示されました)。
</li></ul></div><p>したがって、 <code class="literal">builtin/cat-file.c</code> を調べ、 <code class="literal">cmd_cat_file()</code> を検索して、それが何をするかを調べます。</p><pre class="screen">        git_config(git_default_config);
        if (argc != 3)
                usage("git cat-file [-t|-s|-e|-p|&lt;type&gt;] &lt;sha1&gt;");
        if (get_sha1(argv[2], sha1))
                die("Not a valid object name %s", argv[2]);</pre><p>自明な詳細は飛ばしましょう。 ここで本当に興味深いのは、 <code class="literal">get_sha1()</code> の呼び出しだけです。 <code class="literal">argv[2]</code>
をオブジェクト名として解釈しようとし、現在のリポジトリに存在するオブジェクトを参照している場合は、結果のSHA-1を変数 <code class="literal">sha1</code> に書き込みます。</p><p>ここで興味深いのは以下の2つです:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
`get_sha1()`は成功で0を返します。これは一部の新しいGitハッカーを驚かせるかもしれませんが、UNIXには、さまざまなエラーの場合にさまざまな負の数を返し、成功した場合は0を返すという長い伝統があります。
</li><li class="listitem">
<code class="literal">get_sha1()</code> の関数シグネチャの変数 <code class="literal">sha1</code> は <code class="literal">unsigned char *</code> ですが、実際には <code class="literal">unsigned
  char[20]</code> へのポインタであることが期待されています。この変数には、指定されたコミットの160ビットのSHA-1が含まれます。SHA-1が
  <code class="literal">unsigned char *</code> として渡される場合は常に、 <code class="literal">char *</code>
  として渡される16進文字のASCII表現とは対照的に、バイナリ表現であることに注意してください。
</li></ul></div><p>コード全体でこれらの両方が表示されます。</p><p>さて、肝心の部分は:</p><pre class="screen">        case 0:
                buf = read_object_with_reference(sha1, argv[1], &amp;size, NULL);</pre><p>これはブロブ(実際にはブロブだけでなくあらゆるタイプのオブジェクト)を読み取る方法です。 関数
<code class="literal">read_object_with_reference()</code> が実際にどのように機能するかを知るには、(Gitのリポジトリで <code class="literal">git grep
read_object_with | grep ":[a-z]"</code> などして)そのソースコードを探して拝んでください。</p><p>結果の使用方法を確認するには、 <code class="literal">cmd_cat_file()</code> を読んでください:</p><pre class="screen">        write_or_die(1, buf, size);</pre><p>機能を探す場所がわからない場合があります。このような多くの場合、 <code class="literal">git log</code> の出力を検索してから、対応するコミットを <code class="literal">git show</code>
すると役に立ちます。</p><p>例: <code class="literal">git bundle</code> のテストケースがあったことはわかっているが、それがどこにあったか覚えていない場合(はいもちろん、あなたは <code class="literal">git
grep bundle t/</code> できますが、そーゆー事を言いたい訳じゃない):</p><pre class="screen">$ git log --no-merges t/</pre><p>ページャー(<code class="literal">less</code>)の中で、 "bundle" を検索し、数行前に戻って、それがコミット 18449ab0
にあることを確認します。このオブジェクト名をコピーして、コマンドラインに貼り付けます。</p><pre class="screen">$ git show 18449ab0</pre><p>できた！</p><p>別の例: スクリプトを組み込みにするために何をすべきかを調べます:</p><pre class="screen">$ git log --no-merges --diff-filter=A builtin/*.c</pre><p>ほらこのとおり。Gitは実際、Git自体のソースを見つけるのに最適なツールです！</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="glossary"></a>Chapter 11. Git用語集</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#git-explained">Git解説</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="git-explained"></a>Git解説</h2></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<a name="def_alternate_object_database"></a>alternate object database
</span></dt><dd>
        代役(alternate)メカニズムを介して、 <a class="link" href="#def_repository">リポジトリ</a> は
        <a class="link" href="#def_object_database">オブジェクトデータベース</a> の一部を "alternate" (代役)
        呼ばれる別のオブジェクトデータベースから継承できます。
</dd><dt><span class="term">
<a name="def_bare_repository"></a>bare repository
</span></dt><dd>
        ベアリポジトリは通常、適切な名前の<a class="link" href="#def_directory">ディレクトリ</a>で、接尾辞は <code class="literal">.git</code>
        で、リビジョン管理下にあるファイルのローカルでチェックアウトされたコピーはありません。つまり、通常は非表示の <code class="literal">.git</code>
        サブディレクトリに存在するすべてのGit管理ファイルと制御ファイルは、代わりに <code class="literal">repository.git</code>
        ディレクトリに直接存在し、他のファイルは存在せず、チェックアウトされません。通常、公開リポジトリの発行者は、ベアリポジトリを利用可能にします。
</dd><dt><span class="term">
<a name="def_blob_object"></a>blob object(ブロブオブジェクト)
</span></dt><dd>
        型の無い<a class="link" href="#def_object">オブジェクト</a>。例:ファイルの中身。
</dd><dt><span class="term">
<a name="def_branch"></a>branch
</span></dt><dd>
        「ブランチ」は開発ラインです。ブランチの最新の<a class="link" href="#def_commit">コミット</a>は、そのブランチの先端(the tip of that
        branch)と呼ばれます。ブランチの先端はブランチ<a class="link" href="#def_head">head</a>によって参照され、ブランチで追加の開発が行われると前進します。単一のGit
        <a class="link" href="#def_repository">リポジトリ</a>は任意の数のブランチを追跡できますが、あなたの<a class="link" href="#def_working_tree">作業ツリー</a>はそのうちの1つ(「current
        branch」(現在のブランチ)または「checked out branch」(チェックアウトされたブランチ))に関連付けられ、
        <a class="link" href="#def_HEAD">HEAD</a> はそのブランチを指します。
</dd><dt><span class="term">
<a name="def_cache"></a>cache
</span></dt><dd>
        廃止。 <a class="link" href="#def_index">index</a> を使ってください。
</dd><dt><span class="term">
<a name="def_chain"></a>chain(チェーン,チェイン)
</span></dt><dd>
        オブジェクトのリスト。リスト内の各 <a class="link" href="#def_object">オブジェクト</a> には、その後ろへの参照が含まれます(たとえば、
        <a class="link" href="#def_commit">コミット</a> の後ろはその <a class="link" href="#def_parent">親</a> の1つである可能性があります)。
</dd><dt><span class="term">
<a name="def_changeset"></a>changeset
</span></dt><dd>
        "<a class="link" href="#def_commit">コミット</a>" の BitKeeper/cvsps での言い方です。 Git
        は変更(change)ではなく状態(state)を保存するため、Gitでコミットを「changeset」と呼ぶのはナンセンスです。
</dd><dt><span class="term">
<a name="def_checkout"></a>checkout
</span></dt><dd>
        <a class="link" href="#def_working_tree">作業ツリー</a>の全部または一部を<a class="link" href="#def_object_database">オブジェクトデータベース</a>の<a class="link" href="#def_tree_object">ツリーオブジェクト</a>または<a class="link" href="#def_blob_object">ブロブ</a>で更新し、作業ツリー全体が新しい<a class="link" href="#def_branch">ブランチ</a>を指している場合は、<a class="link" href="#def_index">インデックス</a>と<a class="link" href="#def_HEAD">HEAD</a>を更新する操作。
</dd><dt><span class="term">
<a name="def_cherry-picking"></a>cherry-picking(チェリーピック,チェリーピッキング)
</span></dt><dd>
        <a class="link" href="#def_SCM">SCM</a> の専門用語では、 "cherry pick"
        (つまみ食い)とは、一連の変更(通常はコミット)から変更のサブセットを選択し、それらを別のコードベースの上に新しい一連の変更として記録することを意味します。Gitでは、これは
        "git cherry-pick"
        コマンドによって実行され、既存の<a class="link" href="#def_commit">コミット</a>によって導入された変更を抽出し、現在の<a class="link" href="#def_branch">ブランチ</a>の先端に基づいてそれを新しいコミットとして記録します。
</dd><dt><span class="term">
<a name="def_clean"></a>clean
</span></dt><dd>
        現在の<a class="link" href="#def_head">ヘッド</a>が参照する<a class="link" href="#def_revision">リビジョン</a>と<a class="link" href="#def_working_tree">作業ツリー</a>が完全に一致(correspond)しているのであれば、その<a class="link" href="#def_working_tree">作業ツリー</a>はクリーンです。「<a class="link" href="#def_dirty">dirty</a>」も参照下さい。
</dd><dt><span class="term">
<a name="def_commit"></a>commit
</span></dt><dd><p class="simpara">
        名詞として:
        Gitの履歴における一つのポイント。プロジェクトの履歴全体は、相互に関連する一連のコミットとして表されます。「コミット」という言葉は、他のリビジョン管理システムが「リビジョン」または「バージョン」という言葉を使用するのと同じ場所で、Gitによってよく使用されます。
        <a class="link" href="#def_commit_object">コミットオブジェクト</a> の省略形としても使用されます。
</p><p class="simpara">動詞として(コミットする):
<a class="link" href="#def_index">インデックス</a>の現在の状態を表す新しいコミットを作成し、その新しいコミットをポイントするように<a class="link" href="#def_HEAD">HEAD</a>を進めることにより、プロジェクトの状態の新しいスナップショットをGit履歴に保存する操作。</p></dd><dt><span class="term">
<a name="def_commit_object"></a>commit object
</span></dt><dd>
        <a class="link" href="#def_parent">親</a>、コミッター、作者、日付、保存されたリビジョンの最上位<a class="link" href="#def_directory">ディレクトリ</a>に対応する<a class="link" href="#def_tree_object">ツリーオブジェクト</a>など、特定の<a class="link" href="#def_revision">リビジョン</a>に関する情報を含む<a class="link" href="#def_object">オブジェクト</a>。
</dd><dt><span class="term">
<a name="def_commit-ish"></a>commit-ish (also committish)(コミットっぽい;コミット風)
</span></dt><dd>
        <a class="link" href="#def_commit_object">コミットオブジェクト</a>または、<a class="link" href="#def_commit_object">コミットオブジェクト</a>に再帰的に逆参照可能な<a class="link" href="#def_object">オブジェクト</a>。
        <a class="link" href="#def_commit_object">コミットオブジェクト</a>や、<a class="link" href="#def_commit_object">コミットオブジェクト</a>を指す<a class="link" href="#def_tag_object">タグオブジェクト</a>や、<a class="link" href="#def_commit_object">コミットオブジェクト</a>を指す<a class="link" href="#def_tag_object">タグオブジェクト</a>を指す<a class="link" href="#def_tag_object">タグオブジェクト</a>などは全てcommit-ish(commit-ishes)です。
</dd><dt><span class="term">
<a name="def_core_git"></a>core Git
</span></dt><dd>
        Gitの基本的なデータ構造とユーティリティ。これは、限定的なソースコード管理ツールのみです。
</dd><dt><span class="term">
<a name="def_DAG"></a>DAG
</span></dt><dd>
        有向非巡回グラフ(Directed acyclic graph)。 <a class="link" href="#def_commit_object">コミットオブジェクト</a>
        は、(有向の)親を持ち、コミットオブジェクトのグラフが非巡回(同じ <a class="link" href="#def_object">オブジェクト</a> で開始・終了する
        <a class="link" href="#def_chain">チェイン</a> はありません)であるため有向非巡回グラフを形成します。
</dd><dt><span class="term">
<a name="def_dangling_object"></a>dangling object
</span></dt><dd>
        (ぶらぶら揺れるオブジェクト)他の<a class="link" href="#def_unreachable_object">到達不能オブジェクト</a>からでも到達できない<a class="link" href="#def_unreachable_object">到達不能オブジェクト</a>。
        danglingオブジェクトには、<a class="link" href="#def_repository">リポジトリ</a>内の任意のrefまたは<a class="link" href="#def_object">オブジェクト</a>からの参照はありません。
</dd><dt><span class="term">
<a name="def_detached_HEAD"></a>detached HEAD
</span></dt><dd><p class="simpara">
        通常、<a class="link" href="#def_HEAD">HEAD</a>は<a class="link" href="#def_branch">ブランチ</a>の名前を格納し、HEADが示す履歴を操作するコマンドは、HEADが指すブランチの先端につながる履歴を操作します。
        ただし、Gitでは、必ずしも特定のブランチの先端ではない任意の<a class="link" href="#def_commit">コミット</a>を<a class="link" href="#def_checkout">チェックアウト</a>することもできます。このような状態のHEADを「detached」(切り離されている、デタッチされている)と呼びます。
</p><p class="simpara">注意: 現在のブランチの履歴を操作するコマンド(たとえば、その上に新しい履歴を構築するための <code class="literal">git
commit</code>)は、HEADがデタッチされている間も機能することに注意してください。それらは、ブランチに影響を与えることなく、更新された履歴の先端を指すようにHEADを更新します。現在のブランチに関する情報を更新または照会するコマンド(たとえば、現在のブランチが統合するリモートトラッキングブランチを設定する
<code class="literal">git branch --set-upstream-to</code>)は、この状態で問い合わせる(実際の)現在のブランチがないため、明らかに機能しません。</p></dd><dt><span class="term">
<a name="def_directory"></a>directory
</span></dt><dd>
        あなたが "ls" で得られる一覧の事 :-)
</dd><dt><span class="term">
<a name="def_dirty"></a>dirty
</span></dt><dd>
        <a class="link" href="#def_working_tree">作業ツリー</a>で、現在の<a class="link" href="#def_branch">ブランチ</a>に対して<a class="link" href="#def_commit">コミット</a>されてない変更が含まれている場合、「<a class="link" href="#def_working_tree">作業ツリー</a>はダーティーである」と言われます。
</dd><dt><span class="term">
<a name="def_evil_merge"></a>evil merge
</span></dt><dd>
        邪悪なマージとは、どの <a class="link" href="#def_parent">親</a> にも表示されない変更を導入する <a class="link" href="#def_merge">マージ</a> です。
</dd><dt><span class="term">
<a name="def_fast_forward"></a>fast-forward
</span></dt><dd>
        fast-forward(早送り)は、とある<a class="link" href="#def_revision">リビジョン</a>に、その子孫である別の<a class="link" href="#def_branch">ブランチ</a>の変更をマージする特殊なタイプの<a class="link" href="#def_merge">マージ</a>です。このような場合、新しい<a class="link" href="#def_merge">マージ</a><a class="link" href="#def_commit">コミット</a>を行うのではなく、マージするブランチと同じリビジョンを指すようにブランチを更新するだけです。これは、リモート<a class="link" href="#def_repository">リポジトリ</a>の<a class="link" href="#def_remote_tracking_branch">リモート追跡ブランチ</a>で頻繁に発生します。
</dd><dt><span class="term">
<a name="def_fetch"></a>fetch
</span></dt><dd>
        <a class="link" href="#def_branch">ブランチ</a>をフェッチするということは、リモート<a class="link" href="#def_repository">リポジトリ</a>からブランチの<a class="link" href="#def_head_ref">head         ref</a>を取得して、ローカルの<a class="link" href="#def_object_database">オブジェクトデータベース</a>に欠落しているオブジェクトを見つけ、そして欠落したオブジェクトを取得することを意味します。
        <a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a> も参照してください。
</dd><dt><span class="term">
<a name="def_file_system"></a>file system
</span></dt><dd>
        リーナス・トーバルズは当初、Gitをユーザー空間ファイルシステム、つまりファイルとディレクトリを保持するインフラストラクチャとして設計しました。これにより、Gitの効率と速度が保証されました。
</dd><dt><span class="term">
<a name="def_git_archive"></a>Git archive
</span></dt><dd>
        <a class="link" href="#def_repository">リポジトリ</a> の同義語(arch people 向け)。
</dd><dt><span class="term">
<a name="def_gitfile"></a>gitfile
</span></dt><dd>
        実際のリポジトリであるディレクトリを指す、作業ツリーのルートにあるプレーンファイル <code class="literal">.git</code>
</dd><dt><span class="term">
<a name="def_grafts"></a>grafts
</span></dt><dd><p class="simpara">
        graftsは、コミットの偽の祖先情報を記録することで、他の点では異なる2つの開発ラインを結合できます。こうすることで、ある<a class="link" href="#def_commit">コミット</a>が持つ<a class="link" href="#def_parent">親</a>の組を、コミット作成時に記録されたものとは異なるものとして
        Git に見せかけることができるのです。これは <code class="literal">.git/info/grafts</code> ファイルを介して構成されます。
</p><p class="simpara">注意: graftsメカニズムは時代遅れであり、リポジトリ間でオブジェクトを転送する際に問題が発生する可能性があることに注意してください。
同じことを行うためのより柔軟で堅牢なシステムについては、 <a class="ulink" href="git-replace.html" target="_top">git-replace(1)</a> を参照してください。</p></dd><dt><span class="term">
<a name="def_hash"></a>hash
</span></dt><dd>
        Gitの文脈では <a class="link" href="#def_object_name">オブジェクト名</a> と同義語。
</dd><dt><span class="term">
<a name="def_head"></a>head
</span></dt><dd>
        <a class="link" href="#def_branch">ブランチ</a> の先端にある <a class="link" href="#def_commit">コミット</a> への、 <a class="link" href="#def_ref">名付けられた参照</a>
        です。パックされた参照を使用する場合を除いて、headは <code class="literal">$GIT_DIR/refs/heads/</code> ディレクトリのファイルに保存されます。
        (linkgit: git-pack-refs[1] を参照してください。)
</dd><dt><span class="term">
<a name="def_HEAD"></a>HEAD
</span></dt><dd>
        現在の<a class="link" href="#def_branch">ブランチ</a>。
        より詳細に言うと、あなたの<a class="link" href="#def_working_tree">作業ツリー</a>は通常、HEADによって参照されるツリーの状態から派生します。HEADは、リポジトリ内の<a class="link" href="#def_head">head</a>達のうちの一つへの参照です。ただし、<a class="link" href="#def_detached_HEAD">detached         HEAD</a>をの場合は、任意のコミットを直接参照しています。
</dd><dt><span class="term">
<a name="def_head_ref"></a>head ref
</span></dt><dd>
        <a class="link" href="#def_head">head</a> の同義語。
</dd><dt><span class="term">
<a name="def_hook"></a>hook
</span></dt><dd>
        いくつかのGitコマンドの通常の実行中に、開発者が機能を追加したりチェックしたりできるようにするオプションのスクリプトを呼び出します。通常、フックを使用すると、コマンドを事前に確認して中止することができ、そしてまた、操作の完了後に事後通知を行うことができます。フックスクリプトは
        <code class="literal">$GIT_DIR/hooks/</code> ディレクトリにあり、ファイル名から <code class="literal">.sample</code>
        サフィックスを削除するだけで有効になります。以前のバージョンのGitでは、それらを実行可能にする必要がありました。
</dd><dt><span class="term">
<a name="def_index"></a>index
</span></dt><dd>
        状態情報を含むファイルのコレクションで、その内容はオブジェクトとして保存されます。インデックスは、あなたの<a class="link" href="#def_working_tree">作業ツリー</a>の保存バージョンです。正直なところ、これには、<a class="link" href="#def_merge">マージ</a>のときに使用される、作業ツリーの2番目および3番目のバージョンを含めることもできます。
</dd><dt><span class="term">
<a name="def_index_entry"></a>index entry
</span></dt><dd>
        <a class="link" href="#def_index">インデックス</a>に保存されている特定のファイルに関する情報。<a class="link" href="#def_merge">マージ</a>が開始されたが、まだ終了していない場合(つまり、インデックスにそのファイルの複数のバージョンが含まれている場合)、インデックスエントリをマージ解除(unmerge)できます。
</dd><dt><span class="term">
<a name="def_master"></a>master
</span></dt><dd>
        デフォルトの開発 <a class="link" href="#def_branch">ブランチ</a> 。 Git <a class="link" href="#def_repository">リポジトリ</a>
        を作成するたびに、「master」という名前のブランチが作成され、アクティブなブランチになります。
        ほとんどのローカル開発に含まれていますが、これは純粋に慣例によるものであり、必須ではありません。
</dd><dt><span class="term">
<a name="def_merge"></a>merge
</span></dt><dd><p class="simpara">
        動詞として:
        別の<a class="link" href="#def_branch">ブランチ</a>(あるいは外部の<a class="link" href="#def_repository">リポジトリ</a>から)の内容を現在のブランチに取り込むこと。マージされたブランチが別のリポジトリからのものである場合、これは最初にリモートブランチを<a class="link" href="#def_fetch">フェッチ</a>し、次に結果を現在のブランチにマージすることによって行われます。このフェッチ操作とマージ操作の組み合わせは、<a class="link" href="#def_pull">プル(pull)</a>と呼ばれます。マージは、ブランチが分岐してから行われた変更を識別し、それらすべての変更を一緒に適用する自動プロセスによって実行されます。変更が競合する場合は、マージを完了するために手動による介入が必要になる場合があります。
</p><p class="simpara">名詞として:
<a class="link" href="#def_fast_forward">fast-forward</a>でない限り、マージ成功の結果として、マージされた<a class="link" href="#def_branch">ブランチ</a>の先端を<a class="link" href="#def_parent">親</a>に持つ新しい<a class="link" href="#def_commit">コミット</a>が作成されます。このコミットは「マージコミット」と呼ばれます。または単に「マージ」と呼ばれることもあります。</p></dd><dt><span class="term">
<a name="def_object"></a>object(オブジェクト)
</span></dt><dd>
        Gitの保管ユニット(unit of storage)。その内容による <a class="link" href="#def_SHA1">SHA-1</a>
        によって一意に識別されます。したがって、オブジェクトを変更することはできません。
</dd><dt><span class="term">
<a name="def_object_database"></a>object database
</span></dt><dd>
        「オブジェクト」の組を格納し、個々の<a class="link" href="#def_object">オブジェクト</a>はその<a class="link" href="#def_object_name">オブジェクト名</a>によって識別されます。オブジェクトは通常、
        <code class="literal">$GIT_DIR/objects/</code> にあります。
</dd><dt><span class="term">
<a name="def_object_identifier"></a>object identifier(オブジェクトID)
</span></dt><dd>
        <a class="link" href="#def_object_name">object name</a> (オブジェクト名)の同義語
</dd><dt><span class="term">
<a name="def_object_name"></a>object name(オブジェクト名)
</span></dt><dd>
        <a class="link" href="#def_object">オブジェクト&gt; の一意の識別子。オブジェクト名は通常、40文字の16進文字列で表されます。一般に         &lt;&lt;def_SHA1</a> とも呼ばれます。
</dd><dt><span class="term">
<a name="def_object_type"></a>object type(オブジェクトタイプ)
</span></dt><dd>
        「<a class="link" href="#def_commit_object">コミット</a> 識別子」または「<a class="link" href="#def_tree_object">ツリー</a>
        識別子」または「<a class="link" href="#def_tag_object">タグ</a> 識別子」または「<a class="link" href="#def_blob_object">ブロブ</a> 識別子」のいずれかで、
        <a class="link" href="#def_object">オブジェクト</a> のタイプを表します。
</dd><dt><span class="term">
<a name="def_octopus"></a>octopus
</span></dt><dd>
        3つ以上(more than two)のブランチをマージします
</dd><dt><span class="term">
<a name="def_origin"></a>origin
</span></dt><dd>
        デフォルトの上流(upstream)<a class="link" href="#def_repository">リポジトリ</a>。ほとんどのプロジェクトには、追跡する上流プロジェクトが少なくとも1つあります。デフォルトでは、「origin」がその目的で使用されます。新しい上流更新分は、
        origin/name-of-upstream-branch という名前の
        <a class="link" href="#def_remote_tracking_branch">リモート追跡ブランチ</a>にフェッチされます。これは、 <code class="literal">git branch-r</code>
        を使用して確認できます。
</dd><dt><span class="term">
<a name="def_overlay"></a>overlay
</span></dt><dd>
        <code class="literal">cp -R</code>
        が宛先ディレクトリの内容を更新するのと同様に、ファイルを更新して作業ディレクトリに追加するのみで削除を行いません。これは、<a class="link" href="#def_index">インデックス</a>または<a class="link" href="#def_tree-ish">ツリー風の何か(tree-ish)</a>からファイルをチェックアウトするときの<a class="link" href="#def_checkout">checkout</a>のデフォルトモードです。対照的に、オーバーレイなしモード(no-overlay
        mode)では、 <code class="literal">rsync --delete</code> と同様に、ソース側に存在しない追跡ファイルは削除されます。
</dd><dt><span class="term">
<a name="def_pack"></a>pack
</span></dt><dd>
        1つのファイルに圧縮されたオブジェクトの組(スペースを節約するため、またはそれらを効率的に送信するため)。
</dd><dt><span class="term">
<a name="def_pack_index"></a>pack index
</span></dt><dd>
        パックの内容に効率的にアクセスするのに役立つ、<a class="link" href="#def_pack">パック</a>内のオブジェクトの識別子とその他の情報のリスト。
</dd><dt><span class="term">
<a name="def_pathspec"></a>pathspec
</span></dt><dd><p class="simpara">
        Gitコマンドでパスを制限するために使用されるパターン。
</p><p class="simpara">Pathspecs are used on the command line of "git ls-files", "git ls-tree",
"git add", "git grep", "git diff", "git checkout", and many other commands
to limit the scope of operations to some subset of the tree or working
tree.  See the documentation of each command for whether paths are relative
to the current directory or toplevel.  The pathspec syntax is as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
どのパスもそれ自体と一致します
</li><li class="listitem">
最後がスラッシュであるpathspecは、ディレクトリプレフィックスを表します。そのpathspecのスコープは、そのサブツリーに制限されています。
</li><li class="listitem">
pathspecの残りの部分は、pathnameの残りの部分のパターンです。 ディレクトリプレフィックスに関連するパスは、 fnmatch(3)
  を使用してそのパターンと照合されます。特に、 <span class="emphasis"><em>*</em></span> と <span class="emphasis"><em>?</em></span> はディレクトリ区切り文字と一致させる事ができます。
</li></ul></div><p class="simpara">たとえば、 <code class="literal">Documentation/*.jpg</code> は、 <code class="literal">Documentation/chapter_1/figure_1.jpg</code>
を含む、Documentationサブツリー内のすべての <code class="literal">.jpg</code> ファイルと一致します。</p><p class="simpara">コロン(<code class="literal">:</code>)で始まるpathspecには特別な意味があります。短い形式では、先頭のコロン(<code class="literal">:</code>)の後に0個以上の「魔法記号」(magic
signature)(オプションで別のコロン(<code class="literal">:</code>)で終了)が続き、残りはパスと照合するパターンです。「魔法記号」は、英数字、グロブ、正規表現の特殊文字でもコロンでもないASCII記号で構成されます。パターンが「魔法記号」シンボルセットに属さず、コロンではない文字で始まる場合、「魔法記号」を終了するオプションのコロンは省略できます。</p><p class="simpara">長い形式では、先頭のコロン(<code class="literal">:</code>)の後に開き括弧(<code class="literal">(</code>) 、0個以上の「魔法単語」(magic
words)のコンマ区切りリスト、および閉じ括弧(<code class="literal">)</code>) が続き、残りは次のパターンです。パスと一致します。</p><p class="simpara">コロンのみのpathspecは、「pathspecがない」ことを意味します。 この形式は、他のpathspecと組み合わせないでください。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
top
</span></dt><dd>
        魔法単語 <code class="literal">top</code> (魔法記号: <code class="literal">/</code>)は、サブディレクトリ内からコマンドを実行している場合でも、作業ツリーのルートからパターンを一致させます。
</dd><dt><span class="term">
literal
</span></dt><dd>
        <code class="literal">*</code> または <code class="literal">?</code> などのパターンのワイルドカードはリテラル文字として扱われます。
</dd><dt><span class="term">
icase
</span></dt><dd>
        (英文字の)大文字小文字区別せずにマッチ
</dd><dt><span class="term">
glob
</span></dt><dd><p class="simpara">
        Gitはパターンを、 FNM_PATHNAMEフラグを指定した fnmatch(3)
        に消費されるのに適したシェルグロブとして扱います。パターン内のワイルドカードは、パス名内の / と一致しません。
        たとえば、「Documentation/*.html」は「Documentation/git.html」と一致しますが、「Documentation/ppc/ppc.html」または「tools/perf/Documentation/perf.html」とは一致しません。
</p><p class="simpara">フルパス名と一致するパターンの2つの連続するアスタリスク <code class="literal">**</code> は、特別な意味を持つ場合があります:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
先頭の <code class="literal">**</code> の後にスラッシュが続く場合は、すべてのディレクトリで一致することを意味します。たとえば、 <code class="literal">**/foo</code> は、パターン <code class="literal">foo</code>
   と同じように、ファイルまたはディレクトリ <code class="literal">foo</code> のどこにでも一致します。 <code class="literal">**/foo/bar</code> は、ディレクトリ <code class="literal">foo</code>
   の直下にあるファイルまたはディレクトリ <code class="literal">bar</code> と一致します。
</li><li class="listitem">
末尾の <code class="literal">/**</code> は、内部のすべてに一致します(matches everything inside)。たとえば、 <code class="literal">abc/**</code> は、
   <code class="literal">.gitignore</code> ファイルの場所を基準にして、ディレクトリ "abc" 内のすべてのファイルと無限の深さで一致します。
</li><li class="listitem">
スラッシュの後に2つの連続するアスタリスクが続く場合、スラッシュは0個以上のディレクトリに一致します。 たとえば、 <code class="literal">a/**/b</code> は <code class="literal">a/b</code> 、
   <code class="literal">a/x/b</code> 、<code class="literal">a/x/y/b</code> などと一致します。
</li><li class="listitem"><p class="simpara">
他の連続するアスタリスクは無効と見なされます。
</p><p class="simpara">グロブ魔法はリテラル魔法と互換性がありません。</p></li></ul></div></dd><dt><span class="term">
attr
</span></dt><dd><p class="simpara">
<code class="literal">attr:</code> の後には、スペースで区切られた「属性要件」(attribute
requirements)のリストがあります。パスが一致すると見なされるには、これらすべてを満たす必要があります。これは、通常の非魔法pathspecパターンマッチングに追加されます。
<a class="ulink" href="gitattributes.html" target="_top">gitattributes(5)</a> 参照。
</p><p class="simpara">パスの各属性要件は、以下のいずれかの形式を取ります:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">ATTR</code> では、属性 <code class="literal">ATTR</code> を設定する必要があります。
</li><li class="listitem">
<code class="literal">-ATTR</code> では、属性 <code class="literal">ATTR</code> が設定されていない必要があります。
</li><li class="listitem">
<code class="literal">ATTR = VALUE</code> では、属性 <code class="literal">ATTR</code> を文字列 <code class="literal">VALUE</code> に設定する必要があります。
</li><li class="listitem"><p class="simpara">
<code class="literal">!ATTR</code> では、属性 <code class="literal">ATTR</code> が指定されていない必要があります。
</p><p class="simpara">注意: ツリーオブジェクトと照合する場合、属性は、指定されたツリーオブジェクトからではなく、作業ツリーから取得されることに注意してください。</p></li></ul></div></dd><dt><span class="term">
exclude
</span></dt><dd>
        パスが非除外パススペックと一致すると、すべての除外パススペック(魔法記号: <code class="literal">!</code> またはその同義語
        <code class="literal">^</code>)が実行されます。一致する場合、パスは無視されます。非除外パススペックがない場合、パススペックなしで呼び出されたかのように、除外が結果セットに適用されます。
</dd></dl></div></dd><dt><span class="term">
<a name="def_parent"></a>parent(親)
</span></dt><dd>
        <a class="link" href="#def_commit_object">コミットオブジェクト</a>には、開発ラインで論理的に前にあったもののリスト、つまり親が含まれています(あるいは、前・親が無い場合は空です)。
</dd><dt><span class="term">
<a name="def_pickaxe"></a>pickaxe
</span></dt><dd>
        <a class="link" href="#def_pickaxe">pickaxe</a>(ピカクス;十字鋤;鶴嘴;つるはし)という用語は、特定のテキスト文字列を追加または削除する変更を選択するのに役立つdiffcoreルーチンのオプションを指します。
        <code class="literal">--pickaxe-all</code>
        オプションを使用すると、特定のテキスト行などを導入または削除した完全な<a class="link" href="#def_changeset">チェンジセット</a>を表示するために使用できます。
        <a class="ulink" href="git-diff.html" target="_top">git-diff(1)</a> を参照してください。
</dd><dt><span class="term">
<a name="def_plumbing"></a>plumbing(配管)
</span></dt><dd>
        <a class="link" href="#def_core_git">core Git</a> のキュートな呼び方。
</dd><dt><span class="term">
<a name="def_porcelain"></a>porcelain(磁器)
</span></dt><dd>
        <a class="link" href="#def_core_git">core         Git</a>に依存するプログラムとプログラムスイートのキュートな名前で、コアGitへの高レベルのアクセスを示します。磁器(porcelain)は、<a class="link" href="#def_plumbing">配管(plumbing)</a>よりも多くの<a class="link" href="#def_SCM">SCM</a>インターフェースを公開します。
</dd><dt><span class="term">
<a name="def_per_worktree_ref"></a>per-worktree ref
</span></dt><dd>
        Refs that are per-<a class="link" href="#def_worktree">worktree</a>, rather than global.  This is
        presently only <a class="link" href="#def_HEAD">HEAD</a> and any refs that start with
        <code class="literal">refs/bisect/</code>, but might later include other unusual refs.
</dd><dt><span class="term">
<a name="def_pseudoref"></a>pseudoref
</span></dt><dd>
        疑似参照(pseudoref)は <code class="literal">$GIT_DIR</code>
        の下にあるファイルのクラスであり、rev-parseしたときrefのように動作しますが、それはgitによって特別扱されます。疑似参照はすべて大文字の名前を持ち、かつ、常に<a class="link" href="#def_SHA1">SHA-1</a>とそれに続く空白(whitespace)で構成される行で始まります。したがって、HEADは疑似参照ではありません。なぜならHEADはシンボリック参照である場合があるためです。オプションで、いくつかの追加データが含まれる場合があります。例としては
        <code class="literal">MERGE_HEAD</code> と <code class="literal">CHERRY_PICK_HEAD</code> があります。 <a class="link" href="#def_per_worktree_ref">per-worktree         refs</a> とは異なり、これらのファイルはシンボリックrefにすることはできず、reflogを含めることはできません。
        また、通常のref更新機構を使用して更新することもできません。代わりに、ファイルに直接書き込むことによって更新されます。ただし、それらはrefであるかのように読み取ることができるため、
        <code class="literal">git rev-parse MERGE_HEAD</code> は機能します。
</dd><dt><span class="term">
<a name="def_pull"></a>pull
</span></dt><dd>
        <a class="link" href="#def_branch">ブランチ</a>をプルするとは、それを<a class="link" href="#def_fetch">フェッチ</a>し<a class="link" href="#def_merge">マージ</a>することを意味します。
        <a class="ulink" href="git-pull.html" target="_top">git-pull(1)</a> も参照してください。
</dd><dt><span class="term">
<a name="def_push"></a>push
</span></dt><dd>
        <a class="link" href="#def_branch">ブランチ</a>をプッシュするとは、リモート<a class="link" href="#def_repository">リポジトリ</a>からブランチの<a class="link" href="#def_head_ref">ヘッド参照</a>を取得し、それがブランチのローカルヘッド参照の祖先であるかどうかを確認し、そしてその場合ローカルヘッド参照から<a class="link" href="#def_reachable">到達可能</a>であり、かつ、リモートリポジトリに欠落しているすべてのオブジェクトを、リモート<a class="link" href="#def_object_database">オブジェクトデータベース</a>に持っていき、リモートヘッド参照を更新します。リモート<a class="link" href="#def_head">ヘッド</a>がローカルヘッドの祖先でない場合、プッシュは失敗します。
</dd><dt><span class="term">
<a name="def_reachable"></a>reachable(到達可能)
</span></dt><dd>
        特定の<a class="link" href="#def_commit">コミット</a>のすべての祖先は、その特定のコミットから到達可能(reachable)であると言われます。より一般的には、<a class="link" href="#def_tag">タグ</a>付けしたものだったり、親またはツリーへの<a class="link" href="#def_commit_object">コミットオブジェクト</a>だったり、<a class="link" href="#def_tree_object">ツリー</a>に含まれるツリーやブロブだったり、をたどる<a class="link" href="#def_chain">チェーン</a>によって、ある<a class="link" href="#def_object">オブジェクト</a>から別の<a class="link" href="#def_object">オブジェクト</a>に到達できる場合に到達が可能です。
</dd><dt><span class="term">
<a name="def_rebase"></a>rebase
</span></dt><dd>
        一連の変更を<a class="link" href="#def_branch">ブランチ</a>から別のベースに再適用し、そのブランチの<a class="link" href="#def_head">ヘッド</a>を再適用した結果にリセットします。
</dd><dt><span class="term">
<a name="def_ref"></a>ref
</span></dt><dd><p class="simpara">
        オブジェクト名または別のrefを指す <code class="literal">refs/</code> で始まる名前(例: <code class="literal">refs/heads/master</code>;別のrefを指すrefは
        <a class="link" href="#def_symref">シンボリックref</a> と呼ぶ)。便宜上、Gitコマンドの引数として使用する場合は <code class="literal">refs/</code>
        を省略できる場合があります。詳細については <a class="ulink" href="gitrevisions.html" target="_top">gitrevisions(7)</a> を参照してください。 refs は
        <a class="link" href="#def_repository">repository</a> に保存されます。
</p><p class="simpara">ref名前空間は階層的です。さまざまなサブ階層がさまざまな目的で使用されます(たとえば、 <code class="literal">refs/heads/</code>
階層はローカルブランチを表すために使用されます)。</p><p class="simpara"><code class="literal">refs/</code> で始まらない特別な目的のrefがいくつかあります。最も注目すべき例は <code class="literal">HEAD</code> です。</p></dd><dt><span class="term">
<a name="def_reflog"></a>reflog
</span></dt><dd>
        reflogは、refのローカルの「履歴」を示します。
        つまり、このリポジトリの最後の3番目のリビジョンが何であったか、およびこのリポジトリの昨日の午後9時14分時点での「現在の状態」が何であったかを知ることができます。詳細については
        <a class="ulink" href="git-reflog.html" target="_top">git-reflog(1)</a> を参照してください。
</dd><dt><span class="term">
<a name="def_refspec"></a>refspec
</span></dt><dd>
        「refspec」は、<a class="link" href="#def_fetch">フェッチ</a>や<a class="link" href="#def_push">プッシュ</a>によって使用され、リモート<a class="link" href="#def_ref">ref</a>とローカルrefの間のマッピングを記述します。
</dd><dt><span class="term">
<a name="def_remote"></a>remote repository
</span></dt><dd>
        同じプロジェクトを追跡するために使用されるが、別の場所にある<a class="link" href="#def_repository">リポジトリ</a>。リモートと通信するには、<a class="link" href="#def_fetch">フェッチ</a>または<a class="link" href="#def_push">プッシュ</a>を参照してください。
</dd><dt><span class="term">
<a name="def_remote_tracking_branch"></a>remote-tracking branch
</span></dt><dd>
        別の<a class="link" href="#def_repository">リポジトリ</a>からの変更を追跡するために使用される<a class="link" href="#def_ref">ref</a>。 これは通常、
        <code class="literal">refs/remotes/foo/bar</code>
        のように見え(「foo」という名前のリモートで「bar」という名前のブランチを追跡することを示します)、構成されたフェッチ<a class="link" href="#def_refspec">refspec</a>の右側(right-hand-side)に一致します。リモート追跡ブランチには、直接の変更を含めたり、ローカルコミットを行ったりしないでください。
</dd><dt><span class="term">
<a name="def_repository"></a>repository
</span></dt><dd>
        &lt;&lt;
        def_ref,refs&gt;&gt;のコレクションと、refから<a class="link" href="#def_reachable">到達可能</a>なすべてのオブジェクトを含む<a class="link" href="#def_object_database">オブジェクトデータベース</a>。1つまたは複数の<a class="link" href="#def_porcelain">磁器</a>コマンドからのメタデータが付随している可能性があります。リポジトリは、<a class="link" href="#def_alternate_object_database">代替メカニズム</a>を介してオブジェクトデータベースを他のリポジトリと共有できます。
</dd><dt><span class="term">
<a name="def_resolve"></a>resolve
</span></dt><dd>
        失敗した自動 <a class="link" href="#def_merge">マージ</a> が残したものを手動で修正する操作。
</dd><dt><span class="term">
<a name="def_revision"></a>revision
</span></dt><dd>
        <a class="link" href="#def_commit">コミット</a> (名詞) の同義語
</dd><dt><span class="term">
<a name="def_rewind"></a>rewind(巻き戻し)
</span></dt><dd>
        開発の一部を破棄する、つまり、 <a class="link" href="#def_head">head</a> を以前の <a class="link" href="#def_revision">リビジョン</a> に割り当てる。
</dd><dt><span class="term">
<a name="def_SCM"></a>SCM
</span></dt><dd>
        Source code management (tool).
</dd><dt><span class="term">
<a name="def_SHA1"></a>SHA-1
</span></dt><dd>
        セキュアハッシュアルゴリズム1(Secure Hash Algorithm 1);暗号化ハッシュ関数。
        Git界隈では<a class="link" href="#def_object_name">オブジェクト名</a>の同義語として使用されます。
</dd><dt><span class="term">
<a name="def_shallow_clone"></a>shallow clone
</span></dt><dd>
        ほとんどの場合 <a class="link" href="#def_shallow_repository">shallowリポジトリ</a> の同義語ですが、この言い方は、 <code class="literal">git clone
        --depth=...</code> コマンドを実行して作成されたこと明言したものです。
</dd><dt><span class="term">
<a name="def_shallow_repository"></a>shallow repository
</span></dt><dd>
        浅いリポジトリ(shallow repository)には不完全な履歴があり、そのコミットの一部では親が削除されて(cauterized
        away)います(言い換えると、Gitは、コミットオブジェクトに記録があっても、これらのコミットには親がないふりをするように指示されます)。これは、アップストリームで記録された実際の履歴がはるかに大きい場合でも、プロジェクトの最近の履歴のみに関心がある場合に役立つことがあります。浅いリポジトリは、
        <a class="ulink" href="git-clone.html" target="_top">git-clone(1)</a> に <code class="literal">--depth</code> オプションを指定することで作成され、その履歴は後で
        <a class="ulink" href="git-fetch.html" target="_top">git-fetch(1)</a> で深めることができます。
</dd><dt><span class="term">
<a name="def_stash"></a>stash entry
</span></dt><dd>
        <a class="link" href="#def_dirty">ダーティ</a> な作業ディレクトリの内容とインデックスを、将来の再利用のために一時的に保存するのに使用される
        <a class="link" href="#def_object">オブジェクト</a> 。
</dd><dt><span class="term">
<a name="def_submodule"></a>submodule
</span></dt><dd>
        とあるリポジトリの内部で、それとは別個のプロジェクトの履歴を保持する <a class="link" href="#def_repository">リポジトリ</a>
        (ここで、その、とあるリポジトリを <a class="link" href="#def_superproject">スーパープロジェクト</a> と呼びます)。
</dd><dt><span class="term">
<a name="def_superproject"></a>superproject
</span></dt><dd>
        作業ツリー内の他のプロジェクトのリポジトリを <a class="link" href="#def_submodule">サブモジュール</a> として参照する
        <a class="link" href="#def_repository">リポジトリ</a> 。
        スーパープロジェクトは、含まれているサブモジュールのコミットオブジェクトの名前を知っています(ただし、そのコピーは保持していません)。
</dd><dt><span class="term">
<a name="def_symref"></a>symref
</span></dt><dd>
        シンボリックref(シンボリック参照): <a class="link" href="#def_SHA1">SHA-1</a> ID自体を含む代わりに「ref:
        refs/some/thing」の形式であり、参照されると、この参照を再帰的に逆参照します。 <span class="emphasis"><em><a class="link" href="#def_HEAD">HEAD</a></em></span>
        はsymrefの代表的な例です。シンボリックrefは <a class="ulink" href="git-symbolic-ref.html" target="_top">git-symbolic-ref(1)</a> コマンドで操作されます。
</dd><dt><span class="term">
<a name="def_tag"></a>tag
</span></dt><dd>
        任意のタイプのオブジェクトを指す <code class="literal">refs/tags/</code> 名前空間の下の<a class="link" href="#def_ref">ref</a>(通常、タグは
        <a class="link" href="#def_tag_object">タグ</a> または <a class="link" href="#def_commit_object">コミットオブジェクト</a>
        のいずれかを指します)。<a class="link" href="#def_head">head</a>とは対照的に、タグは <code class="literal">commit</code>
        コマンドによって更新されません。Gitタグは、Lispタグとは何の関係もありません(Git界隈では、それは<a class="link" href="#def_object_type">オブジェクトタイプ</a>と呼ばれます)。タグは通常、コミットの祖先<a class="link" href="#def_chain">チェーン</a>の特定のポイントをマークするために使用されます。
</dd><dt><span class="term">
<a name="def_tag_object"></a>tag object
</span></dt><dd>
        別のオブジェクトを指す<a class="link" href="#def_ref">ref</a>を含む<a class="link" href="#def_object">オブジェクト</a>。これには、<a class="link" href="#def_commit_object">コミットオブジェクト</a>のようにメッセージを含めることができます。またPGP署名を含めることもでき、その場合、「署名付きタグオブジェクト」(signed
        tag object)と呼ばれます。
</dd><dt><span class="term">
<a name="def_topic_branch"></a>topic branch
</span></dt><dd>
        開発者が概念的な開発ラインを識別するために使用する通常のGit<a class="link" href="#def_branch">ブランチ</a>。(従来のSCMに比べて)ブランチは非常に簡単で処理コストが掛からないため、それぞれが非常に明確に定義された概念または小さな増分であるが関連する変更を含む、いくつかの小さなブランチを持つことが望ましい場合がよくあります。
</dd><dt><span class="term">
<a name="def_tree"></a>tree
</span></dt><dd>
        <a class="link" href="#def_working_tree">作業ツリー</a>、または、<a class="link" href="#def_tree_object">ツリーオブジェクト</a>とそれに依存する<a class="link" href="#def_blob_object">ブロブ</a>やツリーオブジェクト(つまり、作業ツリーの保存された表現)、のいずれか。
</dd><dt><span class="term">
<a name="def_tree_object"></a>tree object
</span></dt><dd>
        ファイル名とモードのリスト、および関連するブロブやツリーオブジェクトへのrefを含む<a class="link" href="#def_object">オブジェクト</a>。&lt;&lt;
        def_tree,ツリー&gt;&gt;と<a class="link" href="#def_directory">ディレクトリ</a>は同じ意味です。
</dd><dt><span class="term">
<a name="def_tree-ish"></a>tree-ish (also treeish)
</span></dt><dd>
        ツリーっぽい何か。ツリーオブジェクトに再帰的に逆参照できる <a class="link" href="#def_tree_object">ツリーオブジェクト</a> または
        <a class="link" href="#def_object">オブジェクト</a> です。 <a class="link" href="#def_commit_object">コミットオブジェクト</a> を逆参照すると、その
        <a class="link" href="#def_revision">リビジョン</a> の最上位 <a class="link" href="#def_directory">ディレクトリ&gt;         に対応するツリーオブジェクトが生成されます。※右記は全てツリーっぽい(tree-ish)モノです:         &lt;&lt;def_commit-ish</a> 、ツリーオブジェクト、ツリーオブジェクトを指す
        <a class="link" href="#def_tag_object">タグオブジェクト</a> 、タグオブジェクトを指すタグオブジェクト
</dd><dt><span class="term">
<a name="def_unmerged_index"></a>unmerged index
</span></dt><dd>
        マージされていない<a class="link" href="#def_index_entry">インデックスエントリ</a>を含む<a class="link" href="#def_index">インデックス</a>。
</dd><dt><span class="term">
<a name="def_unreachable_object"></a>unreachable object
</span></dt><dd>
        <a class="link" href="#def_branch">ブランチ</a> または <a class="link" href="#def_tag">タグ</a> またはその他の参照から <a class="link" href="#def_reachable">到達可能</a>
        ではない(辿れない、ポイントされてない) <a class="link" href="#def_object">オブジェクト</a> 。
</dd><dt><span class="term">
<a name="def_upstream_branch"></a>upstream branch
</span></dt><dd>
        当該のブランチからマージされる(または当該のブランチがリベースされる)デフォルトの<a class="link" href="#def_branch">ブランチ</a>。これは、
        <code class="literal">branch.&lt;name&gt;.remote</code> や <code class="literal">branch.&lt;name&gt;.merge</code> を介して構成されます。Aのアップストリームブランチが
        <code class="literal">origin/B</code> の場合、「Aは <code class="literal">origin/B</code> を追跡しています」と言うことがあります。
</dd><dt><span class="term">
<a name="def_working_tree"></a>working tree
</span></dt><dd>
        実際にチェックアウトされたファイル群のツリー。 作業ツリーには通常、 <a class="link" href="#def_HEAD">HEAD</a>
        コミットのツリーの内容に加えて、任意の、まだコミットされていないローカルの変更が含まれています。
</dd><dt><span class="term">
<a name="def_worktree"></a>worktree
</span></dt><dd>
        A repository can have zero (i.e. bare repository) or one or more worktrees
        attached to it. One "worktree" consists of a "working tree" and repository
        metadata, most of which are shared among other worktrees of a single
        repository, and some of which are maintained separately per worktree
        (e.g. the index, HEAD and pseudorefs like MERGE_HEAD, per-worktree refs and
        per-worktree configuration file).
</dd></dl></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="git-quick-start"></a>Appendix A. Git Quick Reference</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#quick-creating-a-new-repository">Creating a new repository</a></span></dt><dt><span class="section"><a href="#managing-branches">Managing branches</a></span></dt><dt><span class="section"><a href="#exploring-history">Exploring history</a></span></dt><dt><span class="section"><a href="#making-changes">Making changes</a></span></dt><dt><span class="section"><a href="#merging">Merging</a></span></dt><dt><span class="section"><a href="#sharing-your-changes">Sharing your changes</a></span></dt><dt><span class="section"><a href="#repository-maintenance">Repository maintenance</a></span></dt></dl></div><p>これは主要なコマンドの簡単な要約です。ここまでの章を読めば、これらがどのように機能するか、より詳細に説明してあります。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quick-creating-a-new-repository"></a>Creating a new repository</h2></div></div></div><p>tarballから持ってくる:</p><pre class="screen">$ tar xzf project.tar.gz
$ cd project
$ git init
Initialized empty Git repository in .git/
$ git add .
$ git commit</pre><p>リモートのリポジトリから持ってくる:</p><pre class="screen">$ git clone git://example.com/pub/project.git
$ cd project</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="managing-branches"></a>Managing branches</h2></div></div></div><pre class="screen">$ git branch                    # list all local branches in this repo
$ git switch test               # switch working directory to branch "test"
$ git branch new                # create branch "new" starting at current HEAD
$ git branch -d new             # delete branch "new"</pre><p>現在のHEAD(デフォルト)に基づいて新しいブランチを作成する代わりに、以下を使用します:</p><pre class="screen">$ git branch new test    # branch named "test"
$ git branch new v2.6.15 # tag named v2.6.15
$ git branch new HEAD^   # commit before the most recent
$ git branch new HEAD^^  # commit before that
$ git branch new test~10 # ten commits before tip of branch "test"</pre><p>新しいブランチを作成と同時にその新しいブランチに切り替えます:</p><pre class="screen">$ git switch -c new v2.6.15</pre><p>あなたがクローンを作成した元のリポジトリから持ってきてブランチを更新・調査します:</p><pre class="screen">$ git fetch             # update
$ git branch -r         # list
  origin/master
  origin/next
  ...
$ git switch -c masterwork origin/master</pre><p>別のリポジトリからブランチを取得し、あなたのリポジトリで新しい名前を付けます:</p><pre class="screen">$ git fetch git://example.com/project.git theirbranch:mybranch
$ git fetch git://example.com/project.git v2.6.15:mybranch</pre><p>定期的に使用するリポジトリのリストを保持します:</p><pre class="screen">$ git remote add example git://example.com/project.git
$ git remote                    # list remote repositories
example
origin
$ git remote show example       # get details
* remote example
  URL: git://example.com/project.git
  Tracked remote branches
    master
    next
    ...
$ git fetch example             # update branches from example
$ git branch -r                 # list all remote branches</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exploring-history"></a>Exploring history</h2></div></div></div><pre class="screen">$ gitk                      # visualize and browse history
$ git log                   # list all commits
$ git log src/              # ...modifying src/
$ git log v2.6.15..v2.6.16  # ...in v2.6.16, not in v2.6.15
$ git log master..test      # ...in branch test, not in branch master
$ git log test..master      # ...in branch master, but not in test
$ git log test...master     # ...in one branch, not in both
$ git log -S'foo()'         # ...where difference contain "foo()"
$ git log --since="2 weeks ago"
$ git log -p                # show patches as well
$ git show                  # most recent commit
$ git diff v2.6.15..v2.6.16 # diff between two tagged versions
$ git diff v2.6.15..HEAD    # diff with current head
$ git grep "foo()"          # search working directory for "foo()"
$ git grep v2.6.15 "foo()"  # search old tree for "foo()"
$ git show v2.6.15:a.txt    # look at old version of a.txt</pre><p>デグレ(regression)を探します:</p><pre class="screen">$ git bisect start
$ git bisect bad                # current version is bad
$ git bisect good v2.6.13-rc2   # last known good revision
Bisecting: 675 revisions left to test after this
                                # test here, then:
$ git bisect good               # if this revision is good, or
$ git bisect bad                # if this revision is bad.
                                # repeat until done.</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="making-changes"></a>Making changes</h2></div></div></div><p>Gitにあなたが誰なのか教えてやってください:</p><pre class="screen">$ cat &gt;&gt;~/.gitconfig &lt;&lt;\EOF
[user]
        name = Your Name Comes Here
        email = you@yourdomain.example.com
EOF</pre><p>次のコミットに含めるファイルの内容を選択してから、コミットします:</p><pre class="screen">$ git add a.txt    # updated file
$ git add b.txt    # new file
$ git rm c.txt     # old file
$ git commit</pre><p>または、ワンステップでコミットを準備・作成します:</p><pre class="screen">$ git commit d.txt # use latest content only of d.txt
$ git commit -a    # use latest content of all tracked files</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="merging"></a>Merging</h2></div></div></div><pre class="screen">$ git merge test   # merge branch "test" into the current branch
$ git pull git://example.com/project.git master
                   # fetch and merge in remote branch
$ git pull . test  # equivalent to git merge test</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sharing-your-changes"></a>Sharing your changes</h2></div></div></div><p>パッチの輸出入(inport/export):</p><pre class="screen">$ git format-patch origin..HEAD # format a patch for each commit
                                # in HEAD but not in origin
$ git am mbox # import patches from the mailbox "mbox"</pre><p>別のGitリポジトリからブランチをフェッチしてから、現在のブランチにマージします:</p><pre class="screen">$ git pull git://example.com/project.git theirbranch</pre><p>現在のブランチにマージする前に、フェッチしたブランチをローカルブランチに保存します:</p><pre class="screen">$ git pull git://example.com/project.git theirbranch:mybranch</pre><p>ローカルブランチでコミットを作成した後、あなたのコミットでリモートブランチを更新します:</p><pre class="screen">$ git push ssh://example.com/project.git mybranch:theirbranch</pre><p>リモートブランチとローカルブランチの両方に "test" という名前が付けられている場合:</p><pre class="screen">$ git push ssh://example.com/project.git test</pre><p>頻繁に使用されるリモートリポジトリのショートカットバージョン:</p><pre class="screen">$ git remote add example ssh://example.com/project.git
$ git push example test</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repository-maintenance"></a>Repository maintenance</h2></div></div></div><p>破損(corruption)を確認します:</p><pre class="screen">$ git fsck</pre><p>再圧縮し、未使用の残骸を取り除きます:</p><pre class="screen">$ git gc</pre></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="todo"></a>Appendix B. Notes and todo list for this manual</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#todo-list">Todo list</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="todo-list"></a>Todo list</h2></div></div></div><p>これらは未だ作業中です。</p><p>基本的な要件:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Gitの特別な知識がなくても、UNIXコマンドラインの基本を理解していれば、インテリジェントな人であれば最初から最後まで読みやすくする必要があります。必要に応じて、その他の前提条件が発生したときに具体的に言及する必要があります。
</li><li class="listitem">
可能な場合は常に、セクションの見出しで、実行方法を説明するタスクを、必要以上の知識を必要としない言語で明確に説明する必要があります。たとえば、 "the
  <code class="literal">git am</code> command" ではなく "importing patches into a project" です。
</li></ul></div><p>明確な章の依存関係グラフを作成する方法を考えてください。これにより、人々は必ずしもその間のすべてを読むことなく、重要なトピックにたどり着くことができます。</p><p>省略されている他のものについては、 <code class="literal">Documentation/</code> を浚ってください。特に:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
howtoと
</li><li class="listitem">
<code class="literal">technical/</code> のいくつかと
</li><li class="listitem">
フック
</li><li class="listitem">
<a class="ulink" href="git.html" target="_top">git(1)</a> のコマンドの一覧
</li></ul></div><p>メールアーカイブをスキャンして、省略されている他のものを探します</p><p>マニュアルページをスキャンして、このマニュアルが提供するよりも多くの背景を想定しているものがあるかどうかを確認します。</p><p>より良い例を追加します。 クックブックの例だけのセクションを記述するのは良い考えです。
たいてい「高度な例」セクションを標準の章の最後のセクションにしますよね？</p><p>必要に応じて、用語集への相互参照を含めます。</p><p>CVSやSubversionや一連のリリースtarballのインポートなど、他のバージョン管理システムの操作に関するセクションを追加します。</p><p>配管コマンドの使用とスクリプトの作成に関する章を作成します。</p><p>代替、clone -reference、等。</p><p>リポジトリの破損からの回復の詳細は、以下:
        <a class="ulink" href="https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/" target="_top">https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/</a>
        <a class="ulink" href="https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/" target="_top">https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/</a></p></div></div></div></body></html>
