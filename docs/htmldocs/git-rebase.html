<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>git-rebase(1)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
git-rebase(1) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>git-rebase -
   別のベース先端の上にコミットを再適用します
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]
        [--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]
<em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
        --root [&lt;branch&gt;]
<em>git rebase</em> (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>If <code>&lt;branch&gt;</code> is specified, <code>git rebase</code> will perform an automatic <code>git
switch &lt;branch&gt;</code> before doing anything else.  Otherwise it remains on the
current branch.</p></div>
<div class="paragraph"><p>If <code>&lt;upstream&gt;</code> is not specified, the upstream configured in
<code>branch.&lt;name&gt;.remote</code> and <code>branch.&lt;name&gt;.merge</code> options will be used (see
<a href="git-config.html">git-config(1)</a> for details) and the <code>--fork-point</code> option is
assumed.  If you are currently not on any branch or if the current branch
does not have a configured upstream, the rebase will abort.</p></div>
<div class="paragraph"><p>All changes made by commits in the current branch but that are not in
<code>&lt;upstream&gt;</code> are saved to a temporary area.  This is the same set of commits
that would be shown by <code>git log &lt;upstream&gt;..HEAD</code>; or by <code>git log
'fork_point'..HEAD</code>, if <code>--fork-point</code> is active (see the description on
<code>--fork-point</code> below); or by <code>git log HEAD</code>, if the <code>--root</code> option is
specified.</p></div>
<div class="paragraph"><p>The current branch is reset to <code>&lt;upstream&gt;</code> or <code>&lt;newbase&gt;</code> if the <code>--onto</code>
option was supplied.  This has the exact same effect as <code>git reset --hard
&lt;upstream&gt;</code> (or <code>&lt;newbase&gt;</code>). <code>ORIG_HEAD</code> is set to point at the tip of the
branch before the reset.</p></div>
<div class="paragraph"><p>The commits that were previously saved into the temporary area are then
reapplied to the current branch, one by one, in order. Note that any commits
in <code>HEAD</code> which introduce the same textual changes as a commit in
<code>HEAD..&lt;upstream&gt;</code> are omitted (i.e., a patch already accepted upstream with
a different commit message or timestamp will be skipped).</p></div>
<div class="paragraph"><p>It is possible that a merge failure will prevent this process from being
completely automatic.  You will have to resolve any such merge failure and
run <code>git rebase --continue</code>.  Another option is to bypass the commit that
caused the merge failure with <code>git rebase --skip</code>.  To check out the
original <code>&lt;branch&gt;</code> and remove the <code>.git/rebase-apply</code> working files, use
the command <code>git rebase --abort</code> instead.</p></div>
<div class="paragraph"><p>以下の履歴が存在し、現在のブランチが <code>topic</code> であるとします:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>          A---B---C topic
         /
    D---E---F---G master</code></pre>
</div></div>
<div class="paragraph"><p>この時点で、以下のコマンドのいずれかを実行します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase master
git rebase master topic</code></pre>
</div></div>
<div class="paragraph"><p>そうすると以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                  A'--B'--C' topic
                 /
    D---E---F---G master</code></pre>
</div></div>
<div class="paragraph"><p><strong>注意</strong> : 後者の形式は、
<code>git checkout topic</code> の後に <code>git rebase master</code> が続く省略形です。
リベースが終了すると、チェックアウトされたブランチ(<code>topic</code>)のままになります。</p></div>
<div class="paragraph"><p>If the upstream branch already contains a change you have made (e.g.,
because you mailed a patch which was applied upstream), then that commit
will be skipped and warnings will be issued (if the <em>merge</em> backend is
used).  For example, running <code>git rebase master</code> on the following history
(in which <code>A'</code> and <code>A</code> introduce the same set of changes, but have different
committer information):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>          A---B---C topic
         /
    D---E---A'---F master</code></pre>
</div></div>
<div class="paragraph"><p>これの結果は以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                   B'---C' topic
                  /
    D---E---A'---F master</code></pre>
</div></div>
<div class="paragraph"><p>これは、あるブランチに基づいてトピックブランチを別のブランチに移植し、 <code>rebase --onto</code>
を使用して、トピックブランチを後者のブランチからフォークしたふりをする方法です。</p></div>
<div class="paragraph"><p>まず、「topic」がブランチ「next」に基づいているとしましょう。
たとえば「topic」で開発された機能は、「next」にあるいくつかの機能に依存しています。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</code></pre>
</div></div>
<div class="paragraph"><p>我々は <em>topic</em> をブランチ <em>master</em>
からフォークさせたいのです。たとえば「topic」が依存する機能が、より安定した「master」ブランチにマージされたためです。
ツリーを以下のようにしたいわけです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</code></pre>
</div></div>
<div class="paragraph"><p>これは、以下のコマンドを使用して取得できます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto master next topic</code></pre>
</div></div>
<div class="paragraph"><p><code>--onto</code> オプションの別の例は、ブランチの一部をリベースすることです。 以下のような状況の場合:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</code></pre>
</div></div>
<div class="paragraph"><p>そして、以下のコマンドを実行します</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto master topicA topicB</code></pre>
</div></div>
<div class="paragraph"><p>そうすると結果は以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</code></pre>
</div></div>
<div class="paragraph"><p>これは、topicBがtopicAに依存していない場合に役立ちます。</p></div>
<div class="paragraph"><p>コミットの範囲は、リベースで削除することもできます。以下の状況の場合:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    E---F---G---H---I---J  topicA</code></pre>
</div></div>
<div class="paragraph"><p>そして、以下のコマンドを実行します</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto topicA~5 topicA~3 topicA</code></pre>
</div></div>
<div class="paragraph"><p>上記を実行すると、以下のようにコミットFとGが削除されます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    E---H'---I'---J'  topicA</code></pre>
</div></div>
<div class="paragraph"><p>This is useful if F and G were flawed in some way, or should not be part of
topicA.  Note that the argument to <code>--onto</code> and the <code>&lt;upstream&gt;</code> parameter
can be any valid commit-ish.</p></div>
<div class="paragraph"><p>In case of conflict, <code>git rebase</code> will stop at the first problematic commit
and leave conflict markers in the tree.  You can use <code>git diff</code> to locate
the markers (&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to resolve the conflict.  For each file
you edit, you need to tell Git that the conflict has been resolved,
typically this would be done with</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git add &lt;filename&gt;</code></pre>
</div></div>
<div class="paragraph"><p>競合を手動で解決し、あなたが望んだ解決策でインデックスを更新した後、以下のコマンドでリベースプロセスを続行できます</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --continue</code></pre>
</div></div>
<div class="paragraph"><p>あるいは、以下のように <code>git rebase</code> を元に戻す(undo)こともできます</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --abort</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_options">OPTIONS</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--onto &lt;newbase&gt;</code>
</dt>
<dd>
<p>
        Starting point at which to create the new commits. If the <code>--onto</code> option is
        not specified, the starting point is <code>&lt;upstream&gt;</code>.  May be any valid commit,
        and not just an existing branch name.
</p>
<div class="paragraph"><p>特別な場合として、マージベースが1つしかない場合は、あなたはAとBのマージベースのショートカットとして "A...B"
を使用できます。最大でAとBのいずれかを省略できます。その場合、デフォルトでHEADになります。</p></div>
</dd>
<dt class="hdlist1">
<code>--keep-base</code>
</dt>
<dd>
<p>
        Set the starting point at which to create the new commits to the merge base
        of <code>&lt;upstream&gt;</code> and <code>&lt;branch&gt;</code>. Running <code>git rebase --keep-base &lt;upstream&gt;
        &lt;branch&gt;</code> is equivalent to running <code>git rebase --onto &lt;upstream&gt;...&lt;branch&gt;
        &lt;upstream&gt; &lt;branch&gt;</code>.
</p>
<div class="paragraph"><p>このオプションは、アップストリームブランチの先頭で機能を開発している場合に役立ちます。この機能が働いている間に、アップストリームのブランチが進むことがあり、アップストリームの先頭にリベースを続けるのは得策ではなく、ベースのコミットをそのままにしておくことがあります。</p></div>
<div class="paragraph"><p>Although both this option and <code>--fork-point</code> find the merge base between
<code>&lt;upstream&gt;</code> and <code>&lt;branch&gt;</code>, this option uses the merge base as the
<em>starting point</em> on which new commits will be created, whereas
<code>--fork-point</code> uses the merge base to determine the <em>set of commits</em> which
will be rebased.</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
&lt;upstream&gt;
</dt>
<dd>
<p>
        比較するアップストリームブランチ。既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。デフォルトは、現在のブランチ用に構成されたアップストリームです。
</p>
</dd>
<dt class="hdlist1">
&lt;branch&gt;
</dt>
<dd>
<p>
        Working branch; defaults to <code>HEAD</code>.
</p>
</dd>
<dt class="hdlist1">
<code>--continue</code>
</dt>
<dd>
<p>
        マージの競合を解決した後、リベースプロセスを再開します。
</p>
</dd>
<dt class="hdlist1">
<code>--abort</code>
</dt>
<dd>
<p>
        Abort the rebase operation and reset HEAD to the original branch. If
        <code>&lt;branch&gt;</code> was provided when the rebase operation was started, then <code>HEAD</code>
        will be reset to <code>&lt;branch&gt;</code>. Otherwise <code>HEAD</code> will be reset to where it was
        when the rebase operation was started.
</p>
</dd>
<dt class="hdlist1">
<code>--quit</code>
</dt>
<dd>
<p>
        Abort the rebase operation but <code>HEAD</code> is not reset back to the original
        branch. The index and working tree are also left unchanged as a result. If a
        temporary stash entry was created using <code>--autostash</code>, it will be saved to
        the stash list.
</p>
</dd>
<dt class="hdlist1">
<code>--apply</code>
</dt>
<dd>
<p>
        適用戦略(applying strategies)を使用してリベースします(内部で <code>git-am</code>
        を呼び出します)。このオプションは、マージバックエンドがapplyのすべてを処理すると、将来的には動作しなくなる可能性があります。
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--empty={drop,keep,ask}</code>
</dt>
<dd>
<p>
        How to handle commits that are not empty to start and are not clean
        cherry-picks of any upstream commit, but which become empty after rebasing
        (because they contain a subset of already upstream changes).  With drop (the
        default), commits that become empty are dropped.  With keep, such commits
        are kept.  With ask (implied by <code>--interactive</code>), the rebase will halt when
        an empty commit is applied allowing you to choose whether to drop it, edit
        files more, or just commit the empty changes.  Other options, like <code>--exec</code>,
        will use the default of drop unless <code>-i</code>/<code>--interactive</code> is explicitly
        specified.
</p>
<div class="paragraph"><p>Note that commits which start empty are kept (unless <code>--no-keep-empty</code> is
specified), and commits which are clean cherry-picks (as determined by <code>git
log --cherry-mark ...</code>) are detected and dropped as a preliminary step
(unless <code>--reapply-cherry-picks</code> is passed).</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--no-keep-empty</code>
</dt>
<dt class="hdlist1">
<code>--keep-empty</code>
</dt>
<dd>
<p>
        Do not keep commits that start empty before the rebase (i.e. that do not
        change anything from its parent) in the result.  The default is to keep
        commits which start empty, since creating such commits requires passing the
        <code>--allow-empty</code> override flag to <code>git commit</code>, signifying that a user is
        very intentionally creating such a commit and thus wants to keep it.
</p>
<div class="paragraph"><p>対話的なリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。
このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などの為の便利なショートカットとして存在します。</p></div>
<div class="paragraph"><p>For commits which do not start empty but become empty after rebasing, see
the <code>--empty</code> flag.</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--reapply-cherry-picks</code>
</dt>
<dt class="hdlist1">
<code>--no-reapply-cherry-picks</code>
</dt>
<dd>
<p>
        我先にドロップしてしまうのではなく、アップストリームコミットのすべてのクリーンなチェリーピックを再適用します。
        （これらのコミットがリベース後に空になった場合、それらにはすでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は
        `--empty`フラグによって制御されます。）
</p>
<div class="paragraph"><p>By default (or if <code>--no-reapply-cherry-picks</code> is given), these commits will
be automatically dropped.  Because this necessitates reading all upstream
commits, this can be expensive in repos with a large number of upstream
commits that need to be read.  When using the <em>merge</em> backend, warnings will
be issued for each dropped commit (unless <code>--quiet</code> is given). Advice will
also be issued unless <code>advice.skippedCherryPicks</code> is set to false (see
<a href="git-config.html">git-config(1)</a>).</p></div>
<div class="paragraph"><p><code>--reapply-cherry-picks</code>
を使用すると、リベースはすべてのアップストリームコミットの読み取りを放棄できるため、パフォーマンスが向上する可能性があります。</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--allow-empty-message</code>
</dt>
<dd>
<p>
        何も操作しません。空のメッセージでコミットをリベースすると失敗(fail)しますが、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできます。つまり、空のメッセージでコミットしても、リベースは停止(halt)しません。
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--skip</code>
</dt>
<dd>
<p>
        現在のパッチをスキップして、リベースプロセスを再開します。
</p>
</dd>
<dt class="hdlist1">
<code>--edit-todo</code>
</dt>
<dd>
<p>
        対話リベース中にToDoリストを編集します。
</p>
</dd>
<dt class="hdlist1">
<code>--show-current-patch</code>
</dt>
<dd>
<p>
        対話的なリベース、または、競合のためにリベースが停止されたときに、現在のパッチを表示します。 これは <code>git show REBASE_HEAD</code>
        と同等です。
</p>
</dd>
<dt class="hdlist1">
<code>-m</code>
</dt>
<dt class="hdlist1">
<code>--merge</code>
</dt>
<dd>
<p>
        マージ戦略(merging strategies)を使用してリベースします(デフォルト)。
</p>
<div class="paragraph"><p>Note that a rebase merge works by replaying each commit from the working
branch on top of the <code>&lt;upstream&gt;</code> branch.  Because of this, when a merge
conflict happens, the side reported as <em>ours</em> is the so-far rebased series,
starting with <code>&lt;upstream&gt;</code>, and <em>theirs</em> is the working branch.  In other
words, the sides are swapped.</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-s &lt;strategy&gt;</code>
</dt>
<dt class="hdlist1">
<code>--strategy=&lt;strategy&gt;</code>
</dt>
<dd>
<p>
        デフォルトの <code>ort</code> の代わりに、指定のマージ戦略を使用します。 このオプションは <code>--merge</code> の指定を含んでいます。
</p>
<div class="paragraph"><p>Because <code>git rebase</code> replays each commit from the working branch on top of
the <code>&lt;upstream&gt;</code> branch using the given strategy, using the <code>ours</code> strategy
simply empties all patches from the <code>&lt;branch&gt;</code>, which makes little sense.</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-X &lt;strategy-option&gt;</code>
</dt>
<dt class="hdlist1">
<code>--strategy-option=&lt;strategy-option&gt;</code>
</dt>
<dd>
<p>
        &lt;strategy-option&gt;をマージ戦略に渡します。 これは <code>--merge</code> の指定を含んでいて、戦略が指定されていない場合は <code>-s
        ort</code> を意味します。 <code>-m</code> オプションにて上記で述べたように、「ours」と「theirs」が逆になっていることに注意してください。
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--rerere-autoupdate</code>
</dt>
<dt class="hdlist1">
<code>--no-rerere-autoupdate</code>
</dt>
<dd>
<p>
        After the rerere mechanism reuses a recorded resolution on the current
        conflict to update the files in the working tree, allow it to also update
        the index with the result of resolution.  <code>--no-rerere-autoupdate</code> is a good
        way to double-check what <code>rerere</code> did and catch potential mismerges, before
        committing the result to the index with a separate <code>git add</code>.
</p>
</dd>
<dt class="hdlist1">
<code>-S[&lt;keyid&gt;]</code>
</dt>
<dt class="hdlist1">
<code>--gpg-sign[=&lt;keyid&gt;]</code>
</dt>
<dt class="hdlist1">
<code>--no-gpg-sign</code>
</dt>
<dd>
<p>
        GPG署名コミットです。 <code>keyid</code> 引数はオプションであり、デフォルトでコミッターIDになります。
        指定する場合は、スペースなしでオプションに串刺しする必要があります。 <code>--no-gpg-sign</code> は、<code>commit.gpgSign</code>
        構成変数と、それより前で指定した <code>--gpg-sign</code> オプションの、その両方を打ち消すのに役立ちます。
</p>
</dd>
<dt class="hdlist1">
<code>-q</code>
</dt>
<dt class="hdlist1">
<code>--quiet</code>
</dt>
<dd>
<p>
        Be quiet. Implies <code>--no-stat</code>.
</p>
</dd>
<dt class="hdlist1">
<code>-v</code>
</dt>
<dt class="hdlist1">
<code>--verbose</code>
</dt>
<dd>
<p>
        Be verbose. Implies <code>--stat</code>.
</p>
</dd>
<dt class="hdlist1">
<code>--stat</code>
</dt>
<dd>
<p>
        最後のリベース以降にアップストリームで変更されたもののdiffstatを表示します。 diffstatは、構成オプション rebase.stat
        によっても制御されます。
</p>
</dd>
<dt class="hdlist1">
<code>-n</code>
</dt>
<dt class="hdlist1">
<code>--no-stat</code>
</dt>
<dd>
<p>
        リベース処理の一部としてdiffstatを表示しないでください。
</p>
</dd>
<dt class="hdlist1">
<code>--no-verify</code>
</dt>
<dd>
<p>
        このオプションは、リベース前のフック(pre-rebase hook)をバイパスします。 <a href="githooks.html">githooks(5)</a> も参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--verify</code>
</dt>
<dd>
<p>
        Allows the pre-rebase hook to run, which is the default.  This option can be
        used to override <code>--no-verify</code>.  See also <a href="githooks.html">githooks(5)</a>.
</p>
</dd>
<dt class="hdlist1">
<code>-C&lt;n&gt;</code>
</dt>
<dd>
<p>
        Ensure at least <code>&lt;n&gt;</code> lines of surrounding context match before and after
        each change.  When fewer lines of surrounding context exist they all must
        match.  By default no context is ever ignored.  Implies <code>--apply</code>.
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--no-ff</code>
</dt>
<dt class="hdlist1">
<code>--force-rebase</code>
</dt>
<dt class="hdlist1">
<code>-f</code>
</dt>
<dd>
<p>
        変更されていないコミットを早送りす(fast-forward)るのではなく、リベースされたすべてのコミットを個別にリプレイします。これにより、リベースされたブランチの履歴全体が新しいコミットで構成されることが保証されます。
</p>
<div class="paragraph"><p>トピックブランチのマージを取り消した後にこのオプションを使うと便利です。このオプションはトピックブランチを新しいコミットで再作成するので、「戻しを戻す」(revert
the reversion)必要はありません (詳細は
<a href="howto/revert-a-faulty-merge.html">revert-a-faulty-merge How-To</a>
をご覧ください)。</p></div>
</dd>
<dt class="hdlist1">
<code>--fork-point</code>
</dt>
<dt class="hdlist1">
<code>--no-fork-point</code>
</dt>
<dd>
<p>
        Use reflog to find a better common ancestor between <code>&lt;upstream&gt;</code> and
        <code>&lt;branch&gt;</code> when calculating which commits have been introduced by
        <code>&lt;branch&gt;</code>.
</p>
<div class="paragraph"><p>When <code>--fork-point</code> is active, <em>fork_point</em> will be used instead of
<code>&lt;upstream&gt;</code> to calculate the set of commits to rebase, where <em>fork_point</em>
is the result of <code>git merge-base --fork-point &lt;upstream&gt; &lt;branch&gt;</code> command
(see <a href="git-merge-base.html">git-merge-base(1)</a>).  If <em>fork_point</em> ends up being empty, the
<code>&lt;upstream&gt;</code> will be used as a fallback.</p></div>
<div class="paragraph"><p>If <code>&lt;upstream&gt;</code> is given on the command line, then the default is
<code>--no-fork-point</code>, otherwise the default is <code>--fork-point</code>. See also
<code>rebase.forkpoint</code> in <a href="git-config.html">git-config(1)</a>.</p></div>
<div class="paragraph"><p>If your branch was based on <code>&lt;upstream&gt;</code> but <code>&lt;upstream&gt;</code> was rewound and
your branch contains commits which were dropped, this option can be used
with <code>--keep-base</code> in order to drop those commits from your branch.</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--ignore-whitespace</code>
</dt>
<dd>
<p>
        差分を調整しようとするときは、空白の違いを無視してください。現在、各バックエンドはこの振る舞いの近似を実装しています:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
apply backend
</dt>
<dd>
<p>
        When applying a patch, ignore changes in whitespace in context
        lines. Unfortunately, this means that if the "old" lines being replaced by
        the patch differ only in whitespace from the existing file, you will get a
        merge conflict instead of a successful patch application.
</p>
</dd>
<dt class="hdlist1">
merge backend
</dt>
<dd>
<p>
        Treat lines with only whitespace changes as unchanged when merging.
        Unfortunately, this means that any patch hunks that were intended to modify
        whitespace and nothing else will be dropped, even if the other side had no
        changes that conflicted.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
<code>--whitespace=&lt;option&gt;</code>
</dt>
<dd>
<p>
        This flag is passed to the <code>git apply</code> program (see <a href="git-apply.html">git-apply(1)</a>)
        that applies the patch.  Implies <code>--apply</code>.
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--committer-date-is-author-date</code>
</dt>
<dd>
<p>
        現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。このオプションは、
        <code>--force-rebase</code> の指定を含んでいます。
</p>
</dd>
<dt class="hdlist1">
<code>--ignore-date</code>
</dt>
<dt class="hdlist1">
<code>--reset-author-date</code>
</dt>
<dd>
<p>
        元のコミットの作成者の日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者の日付として使用します。 このオプションは、
        <code>--force-rebase</code> の指定を含んでいます。
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--signoff</code>
</dt>
<dd>
<p>
        すべてのリベースされたコミットに <code>Signed-off-by</code> トレーラーを追加します。注意: <code>--interactive</code>
        が指定されている場合、pick または edit または reword のマークが付けられたコミットのみにトレーラーが追加されることに注意してください。
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-i</code>
</dt>
<dt class="hdlist1">
<code>--interactive</code>
</dt>
<dd>
<p>
        リベースされようとしているコミットのリストを作成します。リベースする前に、ユーザーにそのリストを編集させます。このモードは、コミットの分割にも使用できます（以下の「SPLITTING
        COMMITS」を参照）。
</p>
<div class="paragraph"><p>コミットリストの書式は、構成オプション rebase.instructionFormat
を設定することで変更できます。カスタマイズされた命令書式では、書式の前に長いコミットハッシュが自動的に追加されます。</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-r</code>
</dt>
<dt class="hdlist1">
<code>--rebase-merges[=(rebase-cousins|no-rebase-cousins)]</code>
</dt>
<dd>
<p>
        デフォルトでは、リベースはtodoリストからマージコミットを削除し、リベースされたコミットを単一の線形ブランチに配置します。
        <code>--rebase-merges</code>
        を使用すると、リベースは代わりに、マージコミットを再作成することにより、リベースされるコミット内の分岐構造を保持しようとします。これらのマージコミットで解決されたマージの競合または手動の修正(amend)は、手動で
        解決/再適用 する必要があります。
</p>
<div class="paragraph"><p>デフォルト、または <code>no-rebase-cousins</code> が指定された場合、直接の祖先として <code>&lt;upstream&gt;</code>
を持たないコミットは元の分岐点を保持します。つまり、 <a href="git-log.html">git-log(1)</a> の <code>--ancestry-path</code>
オプションによって除外されるコミットは、デフォルトで元の祖先を保持します。 <code>rebase-cousins</code>
モードがオンになっている場合、そのようなコミットは代わりに <code>&lt;upstream&gt;</code> （または指定されている場合は <code>&lt;onto&gt;</code>
）にリベースされます。</p></div>
<div class="paragraph"><p>現在、 <code>ort</code> マージ戦略を使用してのみマージコミットを再作成することが可能です。異なるマージ戦略は、明示的な <code>exec git merge -s
&lt;strategy&gt; [...]</code> コマンドを介してのみ使用できます。</p></div>
<div class="paragraph"><p>下記の「REBASING MERGES」と「INCOMPATIBLE OPTIONS」も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-x &lt;cmd&gt;</code>
</dt>
<dt class="hdlist1">
<code>--exec &lt;cmd&gt;</code>
</dt>
<dd>
<p>
        Append "exec &lt;cmd&gt;" after each line creating a commit in the final
        history. <code>&lt;cmd&gt;</code> will be interpreted as one or more shell commands. Any
        command that fails will interrupt the rebase, with exit code 1.
</p>
<div class="paragraph"><p><code>--exec</code> の1つのインスタンスを複数のコマンドで使用することにより、複数のコマンドを実行できます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."</code></pre>
</div></div>
<div class="paragraph"><p>または、複数の <code>--exec</code> を指定します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i --exec "cmd1" --exec "cmd2" --exec ...</code></pre>
</div></div>
<div class="paragraph"><p>If <code>--autosquash</code> is used, <code>exec</code> lines will not be appended for the
intermediate commits, and will only appear at the end of each squash/fixup
series.</p></div>
<div class="paragraph"><p>これは内部で <code>--interactive</code> 機構を使用しますが、明示的な <code>--interactive</code> の指定なしで実行できます。</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--root</code>
</dt>
<dd>
<p>
        Rebase all commits reachable from <code>&lt;branch&gt;</code>, instead of limiting them with
        an <code>&lt;upstream&gt;</code>.  This allows you to rebase the root commit(s) on a branch.
        When used with <code>--onto</code>, it will skip changes already contained in
        <code>&lt;newbase&gt;</code> (instead of <code>&lt;upstream&gt;</code>) whereas without <code>--onto</code> it will
        operate on every change.
</p>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--autosquash</code>
</dt>
<dt class="hdlist1">
<code>--no-autosquash</code>
</dt>
<dd>
<p>
        コミットログメッセージが「squash! &#8230;」または「fixup! &#8230;」または「amend! &#8230;」で始まり、同一の <code>...</code>
        に一致するコミットがすでにtodoリストにある場合、 <code>rebase -i</code>
        のtodoリストを自動的に変更して、squashするようにマークされたコミットが、変更するコミットの直後に来るようにし、移動したコミットのアクションをそれぞれ
        <code>pick</code> から、 <code>squash</code> または <code>fixup</code> または <code>fixup-C</code> に変更します。  コミットの件名が一致する場合、または
        <code>...</code> がコミットのハッシュを参照する場合、コミットは <code>...</code> と一致します。フォールバックとして、コミットサブジェクトの部分一致も機能します。
        fixup/amend/squash コミットを作成するための推奨される方法は、 <a href="git-commit.html">git-commit(1)</a> のそれぞれ
        <code>--fixup</code> または <code>--fixup=amend:</code> または <code>--fixup=reword:</code> と、<code>--squash</code>
        オプションを使用することです。
</p>
<div class="paragraph"><p>構成変数 <code>rebase.autoSquash</code> を使用して <code>--autosquash</code>
オプションがデフォルトで有効になっている場合、このオプションを使用して、この設定をオーバーライドおよび無効にすることができます。</p></div>
<div class="paragraph"><p>下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>--autostash</code>
</dt>
<dt class="hdlist1">
<code>--no-autostash</code>
</dt>
<dd>
<p>
        操作を開始する前に一時的なスタッシュエントリを自動的に作成し、操作の終了後に適用します。これは、汚れたワークツリー(dirty
        worktree)でリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のスタッシュアプリケーションは、重要な競合を引き起こす可能性があります。
</p>
</dd>
<dt class="hdlist1">
<code>--reschedule-failed-exec</code>
</dt>
<dt class="hdlist1">
<code>--no-reschedule-failed-exec</code>
</dt>
<dd>
<p>
        失敗した <code>exec</code> コマンドを自動的に再スケジュールします。 これは、対話モード(または <code>--exec</code>
        オプションが提供された場合)でのみ意味があります。
</p>
<div class="paragraph"><p>このオプションは、リベースが開始されると適用されますが、これは、 <code>rebase.rescheduleFailedExec</code>
構成(<a href="git-config.html">git-config(1)</a> または
下記「CONFIGURATION」参照)、またはこのオプションが提供されているかどうかに基づいて、最初にリベース全体に設定されます。でなければ、開始時の明示的な
<code>--no-reschedule-failed-exec</code> が、 <code>rebase.rescheduleFailedExec=true</code>
構成の存在によって上書きされます。</p></div>
</dd>
<dt class="hdlist1">
<code>--update-refs</code>
</dt>
<dt class="hdlist1">
<code>--no-update-refs</code>
</dt>
<dd>
<p>
        Automatically force-update any branches that point to commits that are being
        rebased. Any branches that are checked out in a worktree are not updated in
        this way.
</p>
<div class="paragraph"><p>If the configuration variable <code>rebase.updateRefs</code> is set, then this option
can be used to override and disable this setting.</p></div>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_incompatible_options_互換性の無いオプション">INCOMPATIBLE OPTIONS(互換性の無いオプション)</h2>
<div class="sectionbody">
<div class="paragraph"><p>これらのオプション:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--apply</code>
</p>
</li>
<li>
<p>
<code>--whitespace</code>
</p>
</li>
<li>
<p>
<code>-C</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>は、以下のオプションと互換性がありません:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--merge</code>
</p>
</li>
<li>
<p>
<code>--strategy</code>
</p>
</li>
<li>
<p>
<code>--strategy-option</code>
</p>
</li>
<li>
<p>
<code>--allow-empty-message</code>
</p>
</li>
<li>
<p>
<code>--[no-]autosquash</code>
</p>
</li>
<li>
<p>
<code>--rebase-merges</code>
</p>
</li>
<li>
<p>
<code>--interactive</code>
</p>
</li>
<li>
<p>
<code>--exec</code>
</p>
</li>
<li>
<p>
<code>--no-keep-empty</code>
</p>
</li>
<li>
<p>
<code>--empty=</code>
</p>
</li>
<li>
<p>
<code>--reapply-cherry-picks</code>
</p>
</li>
<li>
<p>
<code>--edit-todo</code>
</p>
</li>
<li>
<p>
<code>--update-refs</code>
</p>
</li>
<li>
<p>
<code>--root</code> 。<code>--onto</code> と組み合わせて使用する場合。
</p>
</li>
</ul></div>
<div class="paragraph"><p>さらに、以下のオプションの組み合わせには互換性がありません:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--keep-base</code> と <code>--onto</code>
</p>
</li>
<li>
<p>
<code>--keep-base</code> と <code>--root</code>
</p>
</li>
<li>
<p>
<code>--fork-point</code> と <code>--root</code>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_behavioral_differences_振る舞いの違い">BEHAVIORAL DIFFERENCES(振る舞いの違い)</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>git rebase</code> has two primary backends: <em>apply</em> and <em>merge</em>.  (The <em>apply</em>
backend used to be known as the <em>am</em> backend, but the name led to confusion
as it looks like a verb instead of a noun.  Also, the <em>merge</em> backend used
to be known as the interactive backend, but it is now used for
non-interactive cases as well.  Both were renamed based on lower-level
functionality that underpinned each.) There are some subtle differences in
how these two backends behave:</p></div>
<div class="sect2">
<h3 id="_空のコミット">空のコミット</h3>
<div class="paragraph"><p>The <em>apply</em> backend unfortunately drops intentionally empty commits, i.e.
commits that started empty, though these are rare in practice.  It also
drops commits that become empty and has no option for controlling this
behavior.</p></div>
<div class="paragraph"><p>The <em>merge</em> backend keeps intentionally empty commits by default (though
with <code>-i</code> they are marked as empty in the todo list editor, or they can be
dropped automatically with <code>--no-keep-empty</code>).</p></div>
<div class="paragraph"><p>Similar to the apply backend, by default the merge backend drops commits
that become empty unless <code>-i</code>/<code>--interactive</code> is specified (in which case it
stops and asks the user what to do).  The merge backend also has an
<code>--empty={drop,keep,ask}</code> option for changing the behavior of handling
commits that become empty.</p></div>
</div>
<div class="sect2">
<h3 id="_ディレクトリ名変更の検知">ディレクトリ名変更の検知</h3>
<div class="paragraph"><p>Due to the lack of accurate tree information (arising from constructing fake
ancestors with the limited information available in patches), directory
rename detection is disabled in the <em>apply</em> backend.  Disabled directory
rename detection means that if one side of history renames a directory and
the other adds new files to the old directory, then the new files will be
left behind in the old directory without any warning at the time of rebasing
that you may want to move these files into the new directory.</p></div>
<div class="paragraph"><p>Directory rename detection works with the <em>merge</em> backend to provide you
warnings in such cases.</p></div>
</div>
<div class="sect2">
<h3 id="_context">Context</h3>
<div class="paragraph"><p>The <em>apply</em> backend works by creating a sequence of patches (by calling
<code>format-patch</code> internally), and then applying the patches in sequence
(calling <code>am</code> internally).  Patches are composed of multiple hunks, each
with line numbers, a context region, and the actual changes.  The line
numbers have to be taken with some fuzz, since the other side will likely
have inserted or deleted lines earlier in the file.  The context region is
meant to help find how to adjust the line numbers in order to apply the
changes to the right lines.  However, if multiple areas of the code have the
same surrounding lines of context, the wrong one can be picked.  There are
real-world cases where this has caused commits to be reapplied incorrectly
with no conflicts reported.  Setting <code>diff.context</code> to a larger value may
prevent such types of problems, but increases the chance of spurious
conflicts (since it will require more lines of matching context to apply).</p></div>
<div class="paragraph"><p>The <em>merge</em> backend works with a full copy of each relevant file, insulating
it from these types of problems.</p></div>
</div>
<div class="sect2">
<h3 id="_labelling_of_conflicts_markers">Labelling of conflicts markers</h3>
<div class="paragraph"><p>When there are content conflicts, the merge machinery tries to annotate each
side&#8217;s conflict markers with the commits where the content came from.  Since
the <em>apply</em> backend drops the original information about the rebased commits
and their parents (and instead generates new fake commits based off limited
information in the generated patches), those commits cannot be identified;
instead it has to fall back to a commit summary.  Also, when
<code>merge.conflictStyle</code> is set to <code>diff3</code> or <code>zdiff3</code>, the <em>apply</em> backend
will use "constructed merge base" to label the content from the merge base,
and thus provide no information about the merge base commit whatsoever.</p></div>
<div class="paragraph"><p>The <em>merge</em> backend works with the full commits on both sides of history and
thus has no such limitations.</p></div>
</div>
<div class="sect2">
<h3 id="_フック">フック</h3>
<div class="paragraph"><p>The <em>apply</em> backend has not traditionally called the post-commit hook, while
the <em>merge</em> backend has.  Both have called the post-checkout hook, though
the <em>merge</em> backend has squelched its output.  Further, both backends only
call the post-checkout hook with the starting point commit of the rebase,
not the intermediate commits nor the final commit.  In each case, the
calling of these hooks was by accident of implementation rather than by
design (both backends were originally implemented as shell scripts and
happened to invoke other commands like <code>git checkout</code> or <code>git commit</code> that
would call the hooks).  Both backends should have the same behavior, though
it is not entirely clear which, if any, is correct.  We will likely make
rebase stop calling either of these hooks in the future.</p></div>
</div>
<div class="sect2">
<h3 id="_interruptability_割り込み可能性">Interruptability(割り込み可能性)</h3>
<div class="paragraph"><p>The <em>apply</em> backend has safety problems with an ill-timed interrupt; if the
user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase
can enter a state where it cannot be aborted with a subsequent <code>git rebase
--abort</code>.  The <em>merge</em> backend does not appear to suffer from the same
shortcoming.  (See
<a href="https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/">https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/</a> for details.)</p></div>
</div>
<div class="sect2">
<h3 id="_commit_rewording">Commit Rewording</h3>
<div class="paragraph"><p>When a conflict occurs while rebasing, rebase stops and asks the user to
resolve.  Since the user may need to make notable changes while resolving
conflicts, after conflicts are resolved and the user has run <code>git rebase
--continue</code>, the rebase should open an editor and ask the user to update the
commit message.  The <em>merge</em> backend does this, while the <em>apply</em> backend
blindly applies the original commit message.</p></div>
</div>
<div class="sect2">
<h3 id="_miscellaneous_differences">Miscellaneous differences</h3>
<div class="paragraph"><p>ほとんどの人がおそらく取るに足らないと考えるであろうが、完全性のために言及されているいくつかの振る舞いの違いがあります:</p></div>
<div class="ulist"><ul>
<li>
<p>
Reflog: 2つのバックエンドは、reflogで行われた変更を説明するときに異なる表現を使用しますが、どちらも「リベース」という単語を使用します。
</p>
</li>
<li>
<p>
進行状況、情報、エラーメッセージ について:
  2つのバックエンドは、わずかに異なる進行状況と情報メッセージを提供します。また、applyバックエンドはエラーメッセージ（「Your files
  would be overwritten&#8230;」など）をstdoutに書き込み、mergeバックエンドはそれらをstderrに書き込みます。
</p>
<div class="ulist"><ul>
<li>
<p>
State directories: The two backends keep their state in different
  directories under <code>.git/</code>
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_merge_strategies">MERGE STRATEGIES</h2>
<div class="sectionbody">
<div class="paragraph"><p>マージ機構(<code>git merge</code> と <code>git pull</code> コマンド)では、バックエンドの「マージ戦略」を <code>-s</code>
オプションで選択することができます。 いくつかの戦略では、独自のオプションを指定することができます。これは、 <code>git merge</code> や <code>git
pull</code> に <code>-X&lt;option&gt;</code> 引数として渡すことができます。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ort
</dt>
<dd>
<p>
        これは、1つのブランチをプルまたはマージするときのデフォルトのマージ戦略です。この戦略では、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。これにより、Linux
        2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。さらに、この戦略では、名前の変更を伴うマージを検出して処理できます。検出されたコピーは使用しません。このアルゴリズムの名前は
        "Ostensibly Recursive&#8217;s Twin"
        (表面上は再帰の双子)の頭文字を取ったものであり、以前のデフォルトのアルゴリズムである「recursive」の代わりとして作成されたという事実に由来しています。
</p>
<div class="paragraph"><p><code>ort</code> 戦略は、以下のオプションを取ることができます:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ours
</dt>
<dd>
<p>
        このオプションは、「our」バージョンを優先することにより、競合するハンクをクリーンに自動解決するように強制します。
        our側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリファイルの場合、内容全体がour側から取得されます。
</p>
<div class="paragraph"><p>これを「ours」マージ戦略と混同しないでください。この戦略では、他のツリーに何が含まれているのかさえまったく調べません。それは他のツリーが行ったすべてを破棄し、「our」履歴にはその中で起こったすべてが含まれていると宣言します。</p></div>
</dd>
<dt class="hdlist1">
theirs
</dt>
<dd>
<p>
        これは「ours」の反対です。 「ours」とは異なり、このmergeオプションを混同する「theirs」マージ戦略はないことに注意してください。
</p>
</dd>
<dt class="hdlist1">
ignore-space-change
</dt>
<dt class="hdlist1">
ignore-all-space
</dt>
<dt class="hdlist1">
ignore-space-at-eol
</dt>
<dt class="hdlist1">
ignore-cr-at-eol
</dt>
<dd>
<p>
        指示されたタイプの空白(whitespace)の変更を含む行を、3方向マージのために変更されていないものとして扱います。行に対する、他の変更と空白(whitespace)の変更との混合は、無視されません。
        <a href="git-diff.html">git-diff(1)</a> の <code>-b</code> と <code>-w</code> と <code>--ignore-space-at-eol</code> と
        <code>--ignore-cr-at-eol</code> も参照してください。
</p>
<div class="ulist"><ul>
<li>
<p>
「their」バージョンが行に空白の変更のみを導入する場合、「our」バージョンが使用されます。
</p>
</li>
<li>
<p>
「our」バージョンで空白の変更が導入されたが、「their」バージョンに大幅な変更が含まれている場合は、「their」バージョンが使用されます。
</p>
</li>
<li>
<p>
それ以外の場合、マージは通常の方法で進行します。
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
renormalize
</dt>
<dd>
<p>
        これにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインが実行されます。このオプションは、ブランチをさまざまなクリーンフィルターまたは行末正規化ルールとマージするときに使用することを目的としています。詳細については、
        <a href="gitattributes.html">gitattributes(5)</a> の「Merging branches with differing checkin/checkout
        attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)を参照してください。
</p>
</dd>
<dt class="hdlist1">
no-renormalize
</dt>
<dd>
<p>
        <code>renormalize</code> オプションを無効にします。 これは、 <code>merge.renormalize</code> 構成変数をオーバーライドします。
</p>
</dd>
<dt class="hdlist1">
find-renames[=&lt;n&gt;]
</dt>
<dd>
<p>
        名前変更(rename)の検出をオンにし、オプションで類似性のしきい値(similarity threshold)を設定します。これがデフォルトです。
        これは、 <code>merge.renames</code> 構成変数をオーバーライドします。 <a href="git-diff.html">git-diff(1)</a> の <code>--find-renames</code>
        も参照してください。
</p>
</dd>
<dt class="hdlist1">
rename-threshold=&lt;n&gt;
</dt>
<dd>
<p>
        <code>find-renames=&lt;n&gt;</code> の非推奨の同義語。
</p>
</dd>
<dt class="hdlist1">
subtree[=&lt;path&gt;]
</dt>
<dd>
<p>
        このオプションは「subtree」戦略をさらに発展させたもので、2つの木をマージする際に、どのようにずらせば互いにマッチするかを推測するものである。その代わり、指定されたパスは、2つの木の形が一致するように前置される(または、最初から取り除かれる)。
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
recursive
</dt>
<dd>
<p>
        これは、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。
        これにより、Linux
        2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。
        さらに、これにより、名前変更を含むマージを検出して処理できます。  検出されたコピーは使用しません。 これは、Git v0.99.9k 〜
        v2.33.0 まで、2つのヘッドを解決するためのデフォルトの戦略でした。
</p>
<div class="paragraph"><p>「recursive」(再帰的)戦略は「ort」と同じオプションを取る。 しかし、「ort」が無視する3つのオプション(上記には書かれていない)があり、
「recursive」戦略で有用となる可能性がある:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
patience
</dt>
<dd>
<p>
        <code>diff-algorithm=patience</code> の非推奨の同義語。
</p>
</dd>
<dt class="hdlist1">
diff-algorithm=[patience|minimal|histogram|myers]
</dt>
<dd>
<p>
        マージ中に別の差分アルゴリズムを使用すると、重要でない一致行(異なる関数の中括弧など)が原因で発生するミスマージを回避できます。
        <a href="git-diff.html">git-diff(1)</a> <code>--diff-algorithm</code> も参照してください。注意: 特に、「ort」は
        <code>diff-algorithm=histogram</code> を使用しますが、「recursive」はデフォルトで 「diff.algorithm」
        設定を使う事に注意して下さい。
</p>
</dd>
<dt class="hdlist1">
no-renames
</dt>
<dd>
<p>
        名前変更(rename)の検出をオフにします。 これは、<code>merge.renames</code> 構成変数をオーバーライドします。
        <a href="git-diff.html">git-diff(1)</a> の <code>--no-renames</code> も参照してください。
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
resolve
</dt>
<dd>
<p>
        これは、3方向マージアルゴリズムを使用して、2つのヘッド（つまり、現在のブランチとプルした別のブランチ）のみを解決できます。
        交差マージ(criss-cross merge)のあいまいさを注意深く検出しようとします。 名前の変更は処理しません。
</p>
</dd>
<dt class="hdlist1">
octopus
</dt>
<dd>
<p>
        これにより、3つ以上のヘッドを持つケースが解決されますが、手動解決が必要な複雑なマージの実行は拒否されます。これは主に、トピックの分岐ヘッドを纏めるために使用されることを意図しています。これは、複数のブランチをプルまたはマージする場合のデフォルトのマージ戦略です。
</p>
</dd>
<dt class="hdlist1">
ours
</dt>
<dd>
<p>
        これにより、任意の数のヘッドが解決されますが、結果として得られるマージのツリーは常に現在のブランチヘッドのツリーであり、他のすべてのブランチからのすべての変更を事実上無視します。
        これは、サイドブランチの古い開発履歴に取って代わるために使用されることを意図しています。 これは、「recursive」マージ戦略の <code>-Xours</code>
        オプションとは異なることに注意してください。
</p>
</dd>
<dt class="hdlist1">
subtree
</dt>
<dd>
<p>
        これは改造された「ort」戦略です。
        ツリーAとBをマージするとき、BがAのサブツリーに対応する場合、同じレベルのツリーを読み取るのではなく、Bは最初にAのツリー構造に一致するように調整されます。
        この調整は、共通の祖先ツリーに対しても行われます。
</p>
</dd>
</dl></div>
<div class="paragraph"><p>3方向マージ(デフォルトの「ort」を含む)を使用する戦略では、両方のブランチで変更が行われたが、後で一方のブランチで元に戻された場合、その変更はマージされた結果に表示されます。一部の人々は、この振る舞いを混乱させると感じています。これは、個々のコミットではなく、ヘッドとマージベースのみがマージの実行時に考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンに置き換えます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_notes">NOTES</h2>
<div class="sectionbody">
<div class="paragraph"><p>You should understand the implications of using <code>git rebase</code> on a repository
that you share.  See also RECOVERING FROM UPSTREAM REBASE below.</p></div>
<div class="paragraph"><p>When the rebase is run, it will first execute a <code>pre-rebase</code> hook if one
exists.  You can use this hook to do sanity checks and reject the rebase if
it isn&#8217;t appropriate.  Please see the template <code>pre-rebase</code> hook script for
an example.</p></div>
<div class="paragraph"><p>Upon completion, <code>&lt;branch&gt;</code> will be the current branch.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_interactive_mode">INTERACTIVE MODE</h2>
<div class="sectionbody">
<div class="paragraph"><p>対話的にリベースするということは、あなたがリベースされるコミットを編集する機会があることを意味します。コミットを並べ替えたり、削除したりできます(不良パッチやその他の不要なパッチを削除します)。</p></div>
<div class="paragraph"><p>対話モードは、以下のタイプの作業フローを対象としています:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
素晴らしいアイデアを思いついた
</p>
</li>
<li>
<p>
コードをハックハック
</p>
</li>
<li>
<p>
提出用のシリーズを準備
</p>
</li>
<li>
<p>
送信
</p>
</li>
</ol></div>
<div class="paragraph"><p>ここで、 (2) は以下のいくつかの作業で構成されています</p></div>
<div class="paragraph"><p>a) 普段</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
コミットに値する何かを終える
</p>
</li>
<li>
<p>
コミットする
</p>
</li>
</ol></div>
<div class="paragraph"><p>b) 独立した修正</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
何かが機能しないことに気付く
</p>
</li>
<li>
<p>
そいつを修正
</p>
</li>
<li>
<p>
それをコミットする
</p>
</li>
</ol></div>
<div class="paragraph"><p>bの(2)
で修正したコミットがパッチシリーズの中に深く埋もれているために、完全ではないコミットに戻せない(amend)ことがあります。これこそが対話型リベースの目的です。たくさんの
"a" と "b" の後に、コミットを並べ替えたり編集したり、複数のコミットをひとつにまとめたりするために使用します。</p></div>
<div class="paragraph"><p>そのまま保持したい最後のコミットから開始します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i &lt;after-this-commit&gt;</code></pre>
</div></div>
<div class="paragraph"><p>エディターは、あなたの現在のブランチのすべてのコミット(マージコミットは無視)で起動されます。これは、指定のコミットの後に発生します。あなたは、このリストのコミットを心ゆくまで並べ替えたり、削除したりできます。そして、リストは多かれ少なかれ以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...</code></pre>
</div></div>
<div class="paragraph"><p>1行説明は、純粋にあなたの備忘のためです。 <code>git rebase</code> はそれらを参照せず、コミット名（この例では "deadbee" と
"fa1afe1" ）を参照するため、名前を削除または編集しないでください。</p></div>
<div class="paragraph"><p>By replacing the command "pick" with the command "edit", you can tell <code>git
rebase</code> to stop after applying that commit, so that you can edit the files
and/or the commit message, amend the commit, and continue rebasing.</p></div>
<div class="paragraph"><p>リベースを中断するには(<code>edit</code> コマンドと同様、ただし最初にコミットを選択せずに)、 <code>break</code> コマンドを使用します。</p></div>
<div class="paragraph"><p>あなたがコミットのコミットメッセージを編集したいだけの場合は、コマンド <code>pick</code> をコマンド <code>reword</code> に置き換えます。</p></div>
<div class="paragraph"><p>コミットを削除するには、コマンド <code>pick</code> を <code>drop</code> に置き換えるか、あるいはマッチする行を削除します。</p></div>
<div class="paragraph"><p>2つ以上のコミットを1つにまとめる場合は、2番目以降のコミットのコマンド pick を squash または fixup
に置き換えます。コミットに異なる作者がいた場合、折りたたまれたコミットは最初のコミットの作者に帰属します。折りたたまれたコミットに対して推奨されるコミットメッセージは、最初のコミットのメッセージと
squash コマンドで識別されるメッセージを連結したもので、 <code>fixup -c</code>
が使用されていない限り、fixupコマンドで識別されるコミットのメッセージは省略されます。<code>fixup -c</code>
が使用された場合、提案されたコミットメッセージは <code>fixup -c</code> コミットのメッセージのみであり、エディタが開いてメッセージを編集できます。
<code>fixup -c</code> コミットの内容(パッチ)は、折りたたまれたコミットに引き続き組み込まれます。 <code>fixup -c</code>
コミットが複数ある場合は、最後のコミットからのメッセージが使用されます。あなたは  <code>fixup -C</code> を使用して、エディターを開かないことを除いて
<code>fixup -c</code> と同じ動作をさせることもできます。</p></div>
<div class="paragraph"><p><code>git rebase</code> will stop when "pick" has been replaced with "edit" or when a
command fails due to merge errors. When you are done editing and/or
resolving conflicts you can continue with <code>git rebase --continue</code>.</p></div>
<div class="paragraph"><p>For example, if you want to reorder the last 5 commits, such that what was
<code>HEAD~4</code> becomes the new <code>HEAD</code>. To achieve that, you would call <code>git
rebase</code> like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i HEAD~5</code></pre>
</div></div>
<div class="paragraph"><p>そして、最初のパッチをリストの最後に移動します。</p></div>
<div class="paragraph"><p>たとえば、あなたが以下のような履歴を持っているなら、マージコミットを再作成することをお勧めします:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>           X
            \
         A---M---B
        /
---o---O---P---Q</code></pre>
</div></div>
<div class="paragraph"><p>Suppose you want to rebase the side branch starting at "A" to "Q". Make sure
that the current <code>HEAD</code> is "B", and call</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i -r --onto Q O</code></pre>
</div></div>
<div class="paragraph"><p>コミットの並べ替えと編集は通常、テストされていない中間ステップを作成します。テストを実行するか、少なくとも「exec」コマンド(ショートカット「x」)を使用して履歴の中間ポイントで再コンパイルすることにより、履歴の編集で何も壊れていないことを確認することをお勧めします。これを行うには、以下のようなToDoリストを作成します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...</code></pre>
</div></div>
<div class="paragraph"><p>コマンドが失敗すると（つまり、0以外のステータスで終了すると）、対話的リベースが停止(stop)し、あなたには問題を修正する機会が与えられます。あなたは
<code>git rebase --continue</code> で続行できます。</p></div>
<div class="paragraph"><p>「exec」コマンドは、シェル(<code>$SHELL</code> で指定されたもの、または <code>$SHELL</code>
が設定されていない場合はデフォルトのシェル)でコマンドを起動するため、シェル機能("cd"、"&gt;"、";"
など)を使用できます。コマンドは、作業ツリーのルートから実行されます。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i --exec "make test"</code></pre>
</div></div>
<div class="paragraph"><p>このコマンドを使用すると、あなたは中間コミット(intermediate
commits)がコンパイル可能であることを確認できます。ToDoリストは以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_splitting_commits">SPLITTING COMMITS</h2>
<div class="sectionbody">
<div class="paragraph"><p>In interactive mode, you can mark commits with the action "edit".  However,
this does not necessarily mean that <code>git rebase</code> expects the result of this
edit to be exactly one commit.  Indeed, you can undo the commit, or you can
add other commits.  This can be used to split a commit into two:</p></div>
<div class="ulist"><ul>
<li>
<p>
Start an interactive rebase with <code>git rebase -i &lt;commit&gt;^</code>, where <code>&lt;commit&gt;</code>
  is the commit you want to split.  In fact, any commit range will do, as long
  as it contains that commit.
</p>
</li>
<li>
<p>
あなたが分割したいコミットを、 アクション <code>edit</code> でマークします。
</p>
</li>
<li>
<p>
When it comes to editing that commit, execute <code>git reset HEAD^</code>.  The effect
  is that the <code>HEAD</code> is rewound by one, and the index follows suit.  However,
  the working tree stays the same.
</p>
</li>
<li>
<p>
Now add the changes to the index that you want to have in the first commit.
  You can use <code>git add</code> (possibly interactively) or <code>git gui</code> (or both) to do
  that.
</p>
</li>
<li>
<p>
最新の適切なコミットメッセージを使用して、最新の「現在のインデックス」をコミットします。
</p>
</li>
<li>
<p>
作業ツリーがクリーンになるまで、最後の2つの手順を繰り返します。
</p>
</li>
<li>
<p>
<code>git rebase --continue</code> でリベースを続行します。
</p>
</li>
</ul></div>
<div class="paragraph"><p>If you are not absolutely sure that the intermediate revisions are
consistent (they compile, pass the testsuite, etc.) you should use <code>git
stash</code> to stash away the not-yet-committed changes after each commit, test,
and amend the commit if fixes are necessary.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_recovering_from_upstream_rebase">RECOVERING FROM UPSTREAM REBASE</h2>
<div class="sectionbody">
<div class="paragraph"><p>他の人がベースにしているブランチをリベースする (あるいは他の形で書き換える)
のは悪い考えです。そのブランチの下流の人は、自分の履歴を手動で修正することを余儀なくされます。
このセクションでは、下流側の視点から見た修正の方法を説明します。 しかし、本当の意味での修正は、そもそも上流のリベースを行わないことです。</p></div>
<div class="paragraph"><p>説明のために、誰かが「subsystem」ブランチを開発し、この「subsystem」に依存する「topic」に取り組んでいる状況にあると仮定します。たぶん以下のような履歴です:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \
          o---o---o---o---o  subsystem
                           \
                            *---*---*  topic</code></pre>
</div></div>
<div class="paragraph"><p><code>subsystem</code> が <code>master</code> に対してリベースされる場合、以下が発生します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                           \
                            *---*---*  topic</code></pre>
</div></div>
<div class="paragraph"><p>これで、あなたは通常どおり開発を続行し、最終的に <code>topic</code> を <code>subsystem</code> にマージすると、 以下のように、 <code>subsystem</code>
からのコミットは永久に複製されたままになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                           \                         /
                            *---*---*-..........-*--*  topic</code></pre>
</div></div>
<div class="paragraph"><p>このような重複は、履歴が乱雑になり、追跡が困難になるため、一般的に眉をひそめられる行為です。これをクリーンアップするには、「topic」のコミットを新しい「subsystem」の先端に移植する必要があります。つまり、「topic」をリベースする必要があります。これは影響が波及します。「topic」の下流にいる人もリベースを余儀なくされます！</p></div>
<div class="paragraph"><p>2種類の修正パターン(簡単な場合と難しい場合)があります。以下のサブセクションで議論します:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
簡単な場合: 変更は文字通り同じ(same)
</dt>
<dd>
<p>
        これは、 <code>subsystem</code> のリベースが単純なリベースであり、競合がなかった場合に発生します。
</p>
</dd>
<dt class="hdlist1">
難しい場合: 変更は同じではありません
</dt>
<dd>
<p>
        これは、「subsystem」のリベースで競合が発生した場合、または <code>--interactive</code>
        を使用してコミットを省略(omit)、edit、squash、fixupした場合に発生します。または、アップストリームで  <code>commit
        --amend</code> や、 <code>reset</code> や、
        <a href="https://github.com/newren/git-filter-repo"><code>filter-repo</code></a>
        のような完全な履歴書き換えコマンドのいずれかを使用した場合に発生します。
</p>
</dd>
</dl></div>
<div class="sect2">
<h3 id="_簡単な場合">簡単な場合</h3>
<div class="paragraph"><p><code>subsystem</code> の変更点(diffの内容に基づくパッチID)がリベース <code>subsystem</code>
の前と後で文字通り同じである場合にのみ動作します。</p></div>
<div class="paragraph"><p>その場合、 <code>git rebase</code>
は新しいアップストリームにすでに存在する変更をスキップすることを知っているため、修正は簡単です(<code>--reapply-cherry-picks</code>
が指定されていない場合)。 だから(あなたが「topic」にいると仮定して、)あなたが以下のようにすれば、</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    $ git rebase subsystem</code></pre>
</div></div>
<div class="paragraph"><p>あなたは修正された履歴で終わります。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
                                 \
                                  o'--o'--o'--o'--o'  subsystem
                                                   \
                                                    *---*---*  topic</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_難しい場合">難しい場合</h3>
<div class="paragraph"><p><code>subsystem</code> の変更がリベース前の変更に正確に対応していない場合、事態はさらに複雑になります。</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">「簡単な場合の回復」は、難しい場合でも成功するように見えることがありますが、
      意図しない結果をもたらす可能性があります。
      たとえば、 <code>git rebase --interactive</code>
      を介して削除されたコミットが「復活」します！</td>
</tr></table>
</div>
<div class="paragraph"><p>The idea is to manually tell <code>git rebase</code> "where the old <em>subsystem</em> ended
and your <em>topic</em> began", that is, what the old merge base between them was.
You will have to find a way to name the last commit of the old <em>subsystem</em>,
for example:</p></div>
<div class="ulist"><ul>
<li>
<p>
With the <em>subsystem</em> reflog: after <code>git fetch</code>, the old tip of <em>subsystem</em>
  is at <code>subsystem@{1}</code>.  Subsequent fetches will increase the number.  (See
  <a href="git-reflog.html">git-reflog(1)</a>.)
</p>
</li>
<li>
<p>
<code>topic</code> の先端に関連して: <code>topic</code> に3つのコミットがあることを知っているので、 <code>subsystem</code> の古い先端は
  <code>topic~3</code> でなければなりません。
</p>
</li>
</ul></div>
<div class="paragraph"><p>次に、あなたは以下のように言って、古い <code>subsystem..topic</code> を新しい先端に移植できます(reflogの場合、すでに <code>topic</code>
にいると仮定します):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    $ git rebase --onto subsystem subsystem@{1}</code></pre>
</div></div>
<div class="paragraph"><p>「悪い場合」のリカバリの波及効果は特に悪いです。「topic」の下流にある「全て」で「悪い場合」のリカバリを実行する必要があります。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rebasing_merges">REBASING MERGES</h2>
<div class="sectionbody">
<div class="paragraph"><p>対話的リベースコマンドは、元々、個々のパッチシリーズを処理するために設計されました。そのため、開発者がブランチの作業中にその時点で最新の「master」をマージした可能性があり、最終的にすべてのコミットを「master」にリベースする(マージコミットをスキップする)ため、マージコミットをtodoリストから除外することは理にかなっています。</p></div>
<div class="paragraph"><p>ただし、開発者がマージコミットを再作成する正当な理由があります。それは複数の相互に関連するブランチで作業するときに、ブランチ構造(または「コミットトポロジ」）を維持するためです。</p></div>
<div class="paragraph"><p>次の例では、開発者はボタンの定義方法をリファクタリングするトピックブランチと、そのリファクタリングを使用して[バグの報告]ボタンを実装する別のトピックブランチで作業します。
<code>git log --graph --format=%s -5</code> の出力は以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>*   Merge branch 'report-a-bug'
|\
| * Add the feedback button
* | Merge branch 'refactor-button'
|\ \
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one</code></pre>
</div></div>
<div class="paragraph"><p>開発者は、ブランチトポロジを維持しながら、これらのコミットを新しい <code>master</code>
にリベースしたい場合があります。たとえば、最初のトピックブランチが2番目のブランチよりもはるかに早く <code>master</code>
に統合されると予想される場合、たとえば、マージの競合を解決して、 <code>master</code> にしたDownloadButtonクラスへの変更を解決します。</p></div>
<div class="paragraph"><p>このリベースは、 <code>--rebase-merges</code> オプションを使用して実行できます。 以下のようなToDoリストが生成されます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>label onto

# Branch: refactor-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor-button

# Branch: report-a-bug
reset refactor-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report-a-bug

reset onto
merge -C a1b2c3 refactor-button # Merge 'refactor-button'
merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'</code></pre>
</div></div>
<div class="paragraph"><p>通常の対話的リベースとは対照的に、 <code>pick</code> コマンドに加えて <code>label</code> と <code>reset</code> と`merge` コマンドがあります。</p></div>
<div class="paragraph"><p><code>label</code>
コマンドは、そのコマンドが実行されるときに、ラベルを現在のHEADに関連付けます。これらのラベルは、ワークツリーローカル参照(<code>refs/rewritten/&lt;label&gt;</code>)として作成され、リベースが終了すると削除されます。こうすれば、同じリポジトリにリンクされている複数のワークツリーでのリベース操作が相互に干渉することはありません。
<code>label</code> コマンドが失敗した場合、すぐに再スケジュールされ、続行する方法について役立つメッセージが表示されます。</p></div>
<div class="paragraph"><p><code>reset</code> コマンドは、HEADとインデックスとワークツリーを指定されたリビジョンにリセットします。 これは <code>exec git reset
--hard &lt;label&gt;</code> に似ていますが、追跡していないファイルの上書きを拒否します。 <code>reset</code>
コマンドが失敗すると、すぐに再スケジュールされ、todoリストを編集する方法がわかりやすく表示されます(これは通常、 <code>reset</code>
コマンドがtodoリストに手動で挿入され、タイプミスが含まれている場合に発生します)。</p></div>
<div class="paragraph"><p><code>merge</code> コマンドは、指定されたリビジョンをその時点でHEADであるものにマージします。 <code>-C
&lt;original-commit&gt;`を使用すると、指定されたマージコミットのコミットメッセージが使用されます。  `-C</code> が小文字の <code>-c</code>
に変更されると、ユーザーがメッセージを編集できるように、マージが成功した後にメッセージがエディターで開かれます。</p></div>
<div class="paragraph"><p>マージの競合以外の理由で <code>merge</code> コマンドが失敗した場合(つまり、マージ操作が開始されなかった場合)、コマンドは直ちに再スケジュールされます。</p></div>
<div class="paragraph"><p>デフォルトでは、「merge」コマンドは通常のマージには「ort」マージ戦略を使用し、タコマージ(octopus
merges)には「octopus」マージ戦略を使用します。リベースを呼び出すときに <code>--strategy</code>
引数を使用して、すべてのマージのデフォルト戦略を指定できます。または、 <code>exec</code> コマンドを使用して明示的に <code>--strategy</code> 引数を伴った
<code>git merge</code> を呼び出すことにより、コマンドの対話リスト内の特定のマージをオーバーライドできます。注意:このように明示的に <code>git
merge</code> を呼び出す場合、マージするブランチを参照するために、ラベルがワークツリーローカル参照であるという事実(たとえば、 ref
<code>refs/rewritten/onto</code> はラベル <code>onto</code> に対応します)を利用できることに注意してください。</p></div>
<div class="paragraph"><p>注意: 最初のコマンド(<code>label onto</code>)は、コミットがリベースされるリビジョンにラベルを付けます。 <code>onto`という名前は単なる慣例で、
`--onto</code> オプションにちなんでいます。</p></div>
<div class="paragraph"><p><code>merge &lt;merge-head&gt;</code>
の形式のコマンドを追加することにより、完全に新しいマージコミットを最初から導入することもできます。この形式は、暫定的なコミットメッセージを生成し、常にエディターを開いてユーザーが編集できるようにします。これは便利です。例えば、トピックブランチが複数の懸念事項に対処していることが判明し、2つ以上のトピックブランチに分割したい場合です。以下のToDoリストを検討してみてください:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1.3
pick fdbaec Fix detection of cURL in CMake on Windows</code></pre>
</div></div>
<div class="paragraph"><p>CMakeに関連しないこのリストの1つのコミットは、CMakeに切り替えることによって発生したすべてのバグの修正に取り組むことによって動機付けられた可能性がありますが、しかし、それは別の懸念に対処します。このブランチを2つのトピックブランチに分割するには、ToDoリストを以下のように編集できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>label onto

pick afbecd http: add support for TLS v1.3
label tlsv1.3

reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake

reset onto
merge tlsv1.3
merge cmake</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration">CONFIGURATION</h2>
<div class="sectionbody">
<div class="paragraph"><p>このセクションの以下のすべては、 <a href="git-config.html">git-config(1)</a> ドキュメントの抜粋です。 内容は
<a href="git-config.html">git-config(1)</a> ドキュメント にあるものと同一です:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
rebase.backend
</dt>
<dd>
<p>
        リベースに使用するデフォルトのバックエンド。 可能な選択肢は、「apply」または「merge」です。
        将来、mergeバックエンドがapplyバックエンドの残りのすべての機能を取得した場合、この設定は使用されなくなる可能性があります。
</p>
</dd>
<dt class="hdlist1">
rebase.stat
</dt>
<dd>
<p>
        最後のリベース以降にアップストリームで変更されたもののdiffstatを表示するかどうか。デフォルトではFalseです。
</p>
</dd>
<dt class="hdlist1">
rebase.autoSquash
</dt>
<dd>
<p>
        trueに設定されている場合、デフォルトで <code>--autosquash</code> オプションを有効にします。
</p>
</dd>
<dt class="hdlist1">
rebase.autoStash
</dt>
<dd>
<p>
        trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。これは、ダーティワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、
        <a href="git-rebase.html">git-rebase(1)</a> の <code>--no-autostash</code> および <code>--autostash</code>
        オプションでオーバーライドできます。 デフォルトはfalseです。
</p>
</dd>
<dt class="hdlist1">
rebase.updateRefs
</dt>
<dd>
<p>
        If set to true enable <code>--update-refs</code> option by default.
</p>
</dd>
<dt class="hdlist1">
rebase.missingCommitsCheck
</dt>
<dd>
<p>
        「warn」に設定すると、 <code>git rebase -i</code>
        は、一部のコミットが削除された場合(たとえば、行が削除された場合)に警告を出力しますが、リベースは続行されます。
        「error」に設定すると、前記の警告が出力され、リベースが停止(stop)します。 <code>git rebase --edit-todo</code>
        を使用して、エラーを修正できます。 「ignore」に設定すると、チェックは行われません。
        警告やエラーなしにコミットをドロップするには、todoリストの <code>drop</code> コマンドを使用します。 デフォルトは「ignore」です。
</p>
</dd>
<dt class="hdlist1">
rebase.instructionFormat
</dt>
<dd>
<p>
        <a href="git-log.html">git-log(1)</a>
        で指定されている、対話的リベース中にToDoリストに使用される書式文字列。書式では、自動的に長いコミットハッシュが書式の前に付加されます。
</p>
</dd>
<dt class="hdlist1">
rebase.abbreviateCommands
</dt>
<dd>
<p>
        trueに設定すると、  <code>git rebase</code> はtodoリストで省略コマンド名を使用し、以下のようになります:
</p>
<div class="listingblock">
<div class="content">
<pre><code>        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        ...</code></pre>
</div></div>
<div class="paragraph"><p>上記は以下の省略形です:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        ...</code></pre>
</div></div>
<div class="paragraph"><p>デフォルトではfalseです。</p></div>
</dd>
<dt class="hdlist1">
rebase.rescheduleFailedExec
</dt>
<dd>
<p>
        失敗した <code>exec</code> コマンドを自動的に再スケジュールします。 これは、対話モード (または <code>--exec</code>
        オプションが指定されている場合)でのみ意味があります。これは  <code>--reschedule-failed-exec</code> オプションを指定するのと同じです。
</p>
</dd>
<dt class="hdlist1">
rebase.forkPoint
</dt>
<dd>
<p>
        falseに設定されている場合、デフォルトで <code>--no-fork-point</code> オプションを設定します。
</p>
</dd>
<dt class="hdlist1">
sequence.editor
</dt>
<dd>
<p>
        リベース命令ファイル(rebase instruction file)を編集するために <code>git rebase -i</code>
        によって使用されるテキストエディタ。この値は、使用時にシェルによって解釈されることを意図しています。 これは、
        <code>GIT_SEQUENCE_EDITOR</code>
        環境変数によってオーバーライドできます。構成されていない場合は、代わりにデフォルトのコミットメッセージエディタが使用されます。
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2022-09-25 22:03:31 JST
</div>
</div>
</body>
</html>
