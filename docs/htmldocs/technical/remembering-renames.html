<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>Remembering renames</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(1);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Remembering renames</h1>
<span id="revdate">2023-07-22</span>
<div id="toc">
  <div id="toctitle">Outline:</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_はじめに">はじめに</h2>
<div class="sectionbody">
<div class="paragraph"><p>リベースとチェリーピックには一連のマージが含まれ、その結果は新しいひとり親コミット(single-parent commits)として記録されます。 これらのマージの1番目の親の側は「上流」(upstream)側を表し、多くの場合、2 番目の親の側よりもはるかに大きな変更セットが含まれます。 従来、一連のマージの最初の親側の名前変更は、マージごとに繰り返し再検出されていました。 このファイルは、すべてのマージが自動でクリーン(つまり、競合がなく、ユーザー入力または編集のために中断(interrupt)されない)であると仮定して、最適化として、履歴の上流側で名前変更を記憶することが、リベースおよびチェリーピック中に安全かつ効果的である理由を説明します。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_0_仮定">0. 仮定</h2>
<div class="sectionbody">
<div class="paragraph"><p>1つ目と2つ目の仮定はこのドキュメント全体に渡る仮定です:</p></div>
<div class="ulist"><ul>
<li>
<p>
リベース/チェリーピック がマージ機構を呼び出すと、コミット達が移植される上流側が1番目の親の側として扱われます
</p>
</li>
<li>
<p>
すべてのマージは完全に自動化されています
</p>
</li>
</ul></div>
<div class="paragraph"><p>3つ目の仮定は、セクション 2 〜 5 が対象で、議論をシンプルにするための仮定です。これについては セクション 8 で説明します:</p></div>
<div class="ulist"><ul>
<li>
<p>
ディレクトリの名前変更は発生しません
</p>
</li>
</ul></div>
<div class="paragraph"><p>それぞれの仮定とそれを含める理由について、詳しく説明します:</p></div>
<div class="paragraph"><p>最初の仮定は、この文書の目的をより明確にするためのものです。 最適化の実装は実際、これには依存しません。 ただし、rebase と cherry-pick の両方が実装された方法を反映しているため、この仮定はすべての場合に当てはまります。 そしてまた、 cherry-pick と rebase の実装は、下位互換性の理由により簡単には変更できません(たとえば、 <code>git checkout</code> のドキュメントの <code>--ours</code> フラグと <code>--theirs</code> フラグに関する議論、特に rebase での動作に関するコメントを参照してください)。 ただし、最適化により、1番目の親のチェック(checking first-parent-ness)が回避されます。 最適化を有効にする代わりの条件をチェックするため、 cherry-pick と rebase が使用する親の順序が変更された場合でも引き続き機能します。 しかし、この仮定を行うことで、このドキュメントがより明確になり、すべての例を 2 回繰り返す必要がなくなります。</p></div>
<div class="paragraph"><p>2番目の仮定に違反した場合、最適化は単純にオフになるため、その後を考慮する必要はありません。 2番目の仮定は、「ユーザーが競合を解決したり、ファイルをさらに編集または微調整したりするために中断(interrupt)されることはない」とも言えます。 実際のリベースとチェリーピックはしばしば中断(interrupt)されますが(ユーザーが停止と編集を要求した対話的なリベースであるか、ユーザーが解決する必要がある競合があったため)、名前変更のキャッシュはディスクに保存されないので、ユーザーが操作を解決するためにリベースまたはチェリーピックが停止(stop)すると直ちに破棄されます。</p></div>
<div class="paragraph"><p>3番目の仮定により、セクション 2〜5 がより単純になり、この最適化が安全で効果的である理由の基礎を人々が理解できるようになります。その後、セクション 8 で詳細に取り組むことができます。 ディレクトリの名前変更が発生したときに、merge.directoryRenames のデフォルトが <code>conflict</code> に設定されていることは、ユーザーが競合を解決するために操作が停止(stop)し、キャッシュが破棄されることを意味することにも注意してください。つまり、最適化は適用されません。 したがって、ディレクトリの名前変更に具体的に対処する必要がある唯一の理由は、一部のユーザーが merge.directoryRenames を <code>true</code> に設定して、マージが自動的に続行できるようにするためです。 この構成設定でも最適化は安全ですが、その理由を示すためにさらにいくつかのケースについて説明する必要があります。 この議論についてはセクション 8 にて行います。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_1_リベースとチェリーピッキングの仕組み">1. リベースとチェリーピッキングの仕組み</h2>
<div class="sectionbody">
<div class="paragraph"><p>以下の図について考えてみましょう(git-rebase マニュアルページより):</p></div>
<div class="literalblock">
<div class="content">
<pre><code>      A---B---C topic
     /
D---E---F---G main</code></pre>
</div></div>
<div class="paragraph"><p>topic を main にリベースまたはチェリーピッキングした後、以下のようになります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>              A'--B'--C' topic
             /
D---E---F---G main</code></pre>
</div></div>
<div class="paragraph"><p>コミット A' と B' と C' がどのように作成されるかというと、一連のマージによって行われます。この場合、リベースまたはチェリーピックは、特殊なマージ操作にて 3 つの A-B-C コミットのそれぞれを順番に使用します。 ここで、マージ操作の 3 つのコミットに、 MERGE_BASE と、MERGE_SIDE1 と MERGE_SIDE2 というラベルを付けることにしましょう。 この図では、その 3 つのマージのそれぞれに対する 3 つのコミットは以下のようになります:</p></div>
<div class="paragraph"><p>To create A':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E
MERGE_SIDE1:  G
MERGE_SIDE2:  A</code></pre>
</div></div>
<div class="paragraph"><p>To create B':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A
MERGE_SIDE1:  A'
MERGE_SIDE2:  B</code></pre>
</div></div>
<div class="paragraph"><p>To create C':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   B
MERGE_SIDE1:  B'
MERGE_SIDE2:  C</code></pre>
</div></div>
<div class="paragraph"><p>ときどき、これらの 3 方向のマージが行われることに驚かれることがあります。 これらの 3 方向のマージを理解するには、これらを少し異なる観点から見ることが役に立ちます。 たとえば、 C' の作成は、以下のいずれかとして観る事ができます:</p></div>
<div class="ulist"><ul>
<li>
<p>
BとCの間の変更をB&#8217;に適用(apply)します
</p>
</li>
<li>
<p>
BとB&#8217;の間の変更をCに適用(apply)します
</p>
</li>
</ul></div>
<div class="paragraph"><p>概念的には、上記の 2 つの文は、少なくともあなたがコミットの記録を決定する前の時点では、B と B' と C の 3 方向マージと同一です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_2_与えられたピックでの_merge_side1_の名前変更が_常に_次のピックの_merge_side1_での名前変更のスーパーセットである理由">2. 与えられたピックでの MERGE_SIDE1 の名前変更が、「常に」次のピックの MERGE_SIDE1 での名前変更のスーパーセットである理由。</h2>
<div class="sectionbody">
<div class="paragraph"><p>マージ機構は、MERGE_BASE と MERGE_SIDE1 と MERGE_SIDE2 から供給されるファイル名を使用します。 以下の 3 つの条件のいずれかでのみ、コンテンツを別のファイル名に移動(move)します:</p></div>
<div class="ulist"><ul>
<li>
<p>
競合の解決中にユーザーが両方の競合の断片を利用できるようにするため (例: ディレクトリ/ファイルの競合、シンボリックリンク対通常ファイル等のような 追加/追加タイプ の競合)
</p>
</li>
<li>
<p>
MERGE_SIDE1 がファイルの名前変更したとき。
</p>
</li>
<li>
<p>
MERGE_SIDE2 がファイルの名前変更したとき。
</p>
</li>
</ul></div>
<div class="paragraph"><p>まず、cherry-pick または rebase シーケンスの 1 番目と 2 番目のピックに含まれるコミットを思い出してください:</p></div>
<div class="paragraph"><p>To create A':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E
MERGE_SIDE1:  G
MERGE_SIDE2:  A</code></pre>
</div></div>
<div class="paragraph"><p>To create B':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A
MERGE_SIDE1:  A'
MERGE_SIDE2:  B</code></pre>
</div></div>
<div class="paragraph"><p>そして、特に、 E と G の間の名前変更は、 A と A' の間の名前変更のスーパーセットであることを示す必要があります。</p></div>
<div class="paragraph"><p>A' は最初のマージで作成されます。 A' は、上記 3 つの理由のいずれかのみで名前変更されます。 最初のケースである競合では、キャッシュが削除され、この最適化が有効にならない状況が発生するため、このケースを考慮する必要はありません。 3 番目のケースである MERGE_SIDE2 の名前変更 (つまり、G から A へ) は、A' に表れますが、A にも表れます&#8201;&#8212;&#8201;したがって、 A と A' を比較すると、そのパスは名前変更として表示されません。 名前の変更が A' に表れる唯一の方法は、MERGE_SIDE1 による名前変更です。 それゆえ、A と A' の間のすべての名前変更は、E と G の間の名前変更のサブセットです。 同様に、E と G の間のすべての名前変更は、A と A' の間の名前変更のスーパーセットです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_3_与えられたピックで_merge_side1_の名前を変更すると_次のピックでも常に_merge_side1_の名前が変更される理由">3. 与えられたピックで MERGE_SIDE1 の名前を変更すると、次のピックでも常に MERGE_SIDE1 の名前が変更される理由。</h2>
<div class="sectionbody">
<div class="paragraph"><p>最初の 2 つのピックをもう一度見てみましょう:</p></div>
<div class="paragraph"><p>To create A':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E
MERGE_SIDE1:  G
MERGE_SIDE2:  A</code></pre>
</div></div>
<div class="paragraph"><p>To create B':</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A
MERGE_SIDE1:  A'
MERGE_SIDE2:  B</code></pre>
</div></div>
<div class="paragraph"><p>次に、最初のピックでの MERGE_SIDE1 からの任意の名前変更、つまり E から G への任意の名前変更を見てみましょう。デモンストレーションのために、ファイル名「oldfile」と「newfile」を使用してみることにします。 その最初のピックは次のように機能します。 つまり、名前の変更が検出されると、マージ機構は以下の 3 方向のコンテンツ マージを実行します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>E:oldfile
G:newfile
A:oldfile</code></pre>
</div></div>
<div class="paragraph"><p>そして新しい結果を生成します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>A':newfile</code></pre>
</div></div>
<div class="paragraph"><p>上記で、E→A が oldfile の名前変更しなかったと仮定したことに注意してください。 そのMERGE_SIDEが名前を変更した場合は、名前変更/名前変更(1to2) の競合が発生している可能性が高く、リベースまたはチェリーピック操作が停止(halt)し、名前変更のメモリ内キャッシュが削除(drop)されるため、これ以降を考慮する必要はありません。 E→A がファイルの名前を変更するだけでなく、 newfile に名前を変更するという特別なケースでは、名前変更による競合はなく、マージは成功します。 この特殊なケースでは、2 回目のマージで MERGE_BASE 内の A:newfile が検出されるため、名前変更はキャッシュに有効ではありません (t6429 の新しいテストケースの「rename same file identically」(同一ファイルを全く同じに名前変更する)という説明も参照してください)。 したがって、 rename/rename(1to1) は、キャッシュから名前変更を刈り込み、それらの名前変更に関連付けられた現在および主要なディレクトリの dir_rename_counts を減らすことによって、特別に処理する必要があります。 または、これらは非常にまれであるため、名前の変更/名前の変更(1to1)が発生したときに名前の記憶の最適化を無効にして、簡単な方法を取ることができます。</p></div>
<div class="paragraph"><p>さて、前の段落では、 E→A で oldfile の名前を変更する特殊なケースについて説明しましたけれども、引き続き A で oldfile の名前が変更されていないと仮定して議論を続行すします。</p></div>
<div class="paragraph"><p>B' を作成するための図によると、 MERGE_SIDE1 には A から A' への変更が含まれます。 そのため私達は A:oldfile と A':newfile が名前変更として表れるかどうかに興味があるのです。 以下ご留意下さい:</p></div>
<div class="ulist"><ul>
<li>
<p>
A':oldfile はなくなります(なぜなら、マージ機構で破棄検出(break detection)を行わず、 G:newfile が名前変更として検出されたため、G:oldfile が存在する可能性はありませんでした。 よって結果に「oldfile」はありません)。
</p>
</li>
<li>
<p>
A:newfile はなくります (もしあった場合、名前変更/追加 の競合が発生していたはずです)。
</p>
</li>
<li>
<p>
明らかに、 A:oldfile と A':newfile は「関連」(related)があります(A':newfile は、 A:oldfile を含むクリーンな 3 方向のコンテンツ マージから派生したものです)。
</p>
</li>
</ul></div>
<div class="paragraph"><p>上記の 3 番目のポイントについても説明できます。3 方向のコンテンツのマージは、ベースと一方の側の違いを他方の側に適用することと見なすこともできます。 したがって、 E:oldfile と G:newfile の間の変更(関連していると検出されたもの、つまり 50% 未満の変更)を A:oldfile に適用することによって、 A':newfile が作成されたと見なすことができます。</p></div>
<div class="paragraph"><p>したがって、 A:oldfile と A':newfile は、 E:oldfile と G:newfile が関連しているのと同じように関連しています&#8201;&#8212;&#8201;これらはまったく同一の違いがあります。 後者は名前変更として検出されたので、 A:oldfile と A':newfile もほとんど常に名前変更として検出できるはずです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_3_に対する反例の詳細な説明">4. #3 に対する反例の詳細な説明。</h2>
<div class="sectionbody">
<div class="paragraph"><p>セクション 3 で、rename/rename(1to1) (つまり、両サイドが同一の方法でファイルの名前を変更すること) が 1 つの反例であることを既に述べました。 しかし、もっと興味深いのは、なぜ A:oldfile と A':newfile が名前変更として「ほぼ」常に検出可能であると述べたときに、「ほぼ」という言葉を使用する必要があったのかということです。</p></div>
<div class="paragraph"><p>セクション 3 で述べた以前のポイントを繰り返しましょう:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>A':newfile は、E:oldfile と G:newfile の間の変更を
A:oldfile に適用することによって作成されました。
E:oldfile と G:newfile の間の変更は、 E:oldfile のサイズの 50% 未満でした。</code></pre>
</div></div>
<div class="paragraph"><p>E:oldfile のサイズの 50% 未満であった変更が、 A:oldfile のサイズの 50% 未満であるならば、 A:oldfile と A':newfile では名前変更として検出されます。 ただし、 E:oldfile と A:oldfile の間で劇的なサイズの縮小がある場合 (ただし、E:oldfile、G:newfile、および A:oldfile の間の変更は依然として何らかの形できれいにマージされるとして)、従来の名前変更検出では A:oldfile と A':newfile の間の名前変更が検出されません。</p></div>
<div class="paragraph"><p>これが発生する可能性のある例を以下に示します:</p></div>
<div class="ulist"><ul>
<li>
<p>
E:oldfileには20行あります
</p>
</li>
<li>
<p>
G:newfileは、ファイルの先頭に10行の新しい行を追加しました
</p>
</li>
<li>
<p>
A:oldfileは、ファイルの最初の3行を保持し、残りをすべて削除しました。
</p>
</li>
</ul></div>
<div class="paragraph"><p>そうすると:</p></div>
<div class="ulist"><ul>
<li>
<p>
&#8658; A':newfileには13行あり、そのうちの3行は A:oldfile の行と一致します。
</p>
</li>
</ul></div>
<div class="paragraph"><p>E:oldfile → G:newfile は名前変更として検出されますが、 A:oldfile と A':newfile は検出されません。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_4_の特殊なケースが_マージ機構での3方向コンテンツマージのためにファイルをペアリングするために使用するのに依然として完全に合理的である理由と_それらがマージの正確さに影響を与えない理由">5. #4 の特殊なケースが、マージ機構での3方向コンテンツマージのためにファイルをペアリングするために使用するのに依然として完全に合理的である理由と、それらがマージの正確さに影響を与えない理由。</h2>
<div class="sectionbody">
<div class="paragraph"><p>rename/rename(1to1) の場合、 A:newfile と A':newfile は 「同一」ファイル名を使用するため、名前変更しません。 ただし、同一ファイル名のファイルは、3方向コンテンツマージ用の組にする(pair up)のに明らかに問題ありません(マージ機構は破壊検出(break detection)を採用していないため)。 したがって、この興味深い反例のケースは、rename/rename(1to1) ケースではなく、A が oldfile の名前変更しなかったケースです。 これは、セクション 3 と 4 でほとんどの時間を議論に費やしたケースです。 このセクションの残りの部分では、そのケースについても説明します。</p></div>
<div class="paragraph"><p>では、 A:oldfile と A':newfile が名前変更として検出されない場合でも、マージ機構で3方向のコンテンツをマージするためにそれらを組(pair)にすることが合理的なのはなぜでしょうか? これには複数の理由があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
セクション 3 と 4 で述べたように、 A:oldfile と A':newfile の差分は、E:oldfile と G:newfile の差分と「正確に」同じです。 後者のペアは名前変更として検出されたため、A:oldfile と A':newfile を名前変更として扱うことにユーザーが驚くことはないようです。
</p>
</li>
<li>
<p>
実際、 <code>oldfile</code> と <code>newfile</code> は、E..G チェーンでの構成方法が原因で、ある時点で名前変更として検出されました。 そして、私達はこの リベース/チェリーピック ですでにその情報を使用しました。 ユーザーは、私たちがファイルを名前変更として扱い続けていることに驚くことはまずなく、その理由をすぐに理解できると思います。
</p>
</li>
<li>
<p>
ファイルを名前変更としてマークまたは宣言することは、マージの最終目標ではありません。 マージでは、名前変更を使用して、3方向のコンテンツマージでペアにするのが適切なファイルを決定します。
</p>
</li>
<li>
<p>
A:oldfile と A':newfile は、「既に」 3方向のコンテンツマージでペアになっています。つまりそれは A':newfile がどのように作成されたかという事です。 実際、その3方向のコンテンツマージはクリーンでした。 したがって、後の3方向のコンテンツマージでそれらを再度使用することは非常に合理的です。
</p>
</li>
</ul></div>
<div class="paragraph"><p>ただし、上記では一般的なシナリオに焦点を当てています。 考えうる異常なシナリオをすべて見て、最適化なしと最適化ありを比較してみましょう。 以下の理論的なケースを検討してみてください。 そして、私達は以下のそれぞれについて掘り下げて、可能なものと、可能な場合の意味を判断します:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
最適化を行わないと、2回目のマージで競合が発生します。 最適化を行っても、2回目のマージで競合が発生します。 質問: これらの競合は紛らわしいほどの差異でしょうか？ ある場合においてはより良いでしょうか？
</p>
</li>
<li>
<p>
最適化を行わないと、2回目のマージで競合は発生しません。 最適化を行っても、2回目のマージで競合は発生しません。 質問:これらのマージは同一ですか？
</p>
</li>
<li>
<p>
最適化を行わないと、2回目のマージで競合が発生します。 最適化を行うと、2回目のマージで競合は発生しません。 質問: こあれはありえますか？ バグまたは、バグフィックスまた、それ以外の何かか？
</p>
</li>
<li>
<p>
最適化を行わないと、2回目のマージで競合は発生しません。 最適化を行うと、2回目のマージで競合が発生します。 質問: こあれはありえますか？ バグまたは、バグフィックスまた、それ以外の何かか？
</p>
</li>
</ol></div>
<div class="paragraph"><p>私は 4 つのケースすべてを検討しますが、順不同です。</p></div>
<div class="paragraph"><p>4番目のケースは不可能です。 名前変更の記憶の最適化を行わないコードで競合が発生しないようにするには、 B:oldfile が A:oldfile と正確に一致する必要があります&#8201;&#8212;&#8201;一致しない場合は、変更/削除 の競合が発生します。 A:oldfile が B:oldfile と正確に一致する場合、A:oldfile と、A':newfile と B:oldfile の間の3方向のコンテンツマージは競合せず、結果として A' からの newfile のバージョンを提供します。</p></div>
<div class="paragraph"><p>そして4番目のケースと同一のロジックにより、2 番目のケースは実際には同一のマージになります。 A:oldfile が B:oldfile と正確に一致する場合、検出されない名前変更はこのように言います「ええっと、一方が &#8216;oldfile` を変更せず、もう一方がそれを削除したようです。よってそれを削除します。 そして、 A に <code>newfile</code> という名前の新しいファイルがあるので、そのままにしておきます。」 これは、 A:oldfile と A&#8217;:newfile と B:oldfile の3方向のコンテンツマージと同一の結果をもたらします&#8201;&#8212;&#8201;A' からの newfile のバージョンを含む oldfile の削除が結果に表れます。</p></div>
<div class="paragraph"><p>3番目のケースは興味深いです。 これは、A:oldfile と A':newfile が十分に類似しているだけでなく、それらの間の変更が A:oldfile と B:oldfile の間の変更と競合しなかったことを意味します。 これは、ファイルが 3 方向のコンテンツ マージで使用できるほど類似しているという私たちの推測を検証したものでして、つまり、このように使用したことは完全に正しいと思われます。 (補足: ここでの 1 つの特定の例は、啓発的かもしれません。 B が A の直接の復帰(revert)であるとしましょう。A は B の直接の親であるため、B は明らかに A の完全な復帰(revert)でした。 コミットを選択できる場合は、その即時の復帰(revert)も選択できるはずです。 ただし、これは面白いレアケース(corner cases)の 1 つです。 この最適化がなければ、コミットをきれいに選択することに成功しましたが、E:oldfile と A:oldfile のサイズが異なるため、直ちに戻す(revert)ためにそれをチェリーピック(cherry-pick)することはできません。)</p></div>
<div class="paragraph"><p>考慮すべきなのは最初のケースのみです&#8201;&#8212;&#8201;それは最適化の有無にかかわらず競合が発生した場合です。 最適化を行わないと、 変更/削除 の競合が発生し、 A':newfile と B:oldfile の両方がツリーに残され、ユーザーが処理できるようになり、2 つの潜在的な類似性についてのヒントがなくなります。 最適化により、 A:oldfile と A':newfile と B:oldfile が 3 方向のコンテンツマージされ、ファイルが関連していると思われる競合マーカーが表示されますが、ユーザーには解決する機会が与えられます。 前述したように、「oldfile」と「newfile」は E と G の間だったので、ユーザーは「oldfile」と「newfile」を関連性があるものとして扱っていることに驚かないと思います。 いずれにせよ、どちらの場合も競合に遭遇し、ユーザーに知っていることを伝え、解決するように依頼したため、このケースは心配する必要がはありません。</p></div>
<div class="paragraph"><p>つまり、要約すると、ケース 4 は不可能であり、ケース 2 は同一の振る舞いをもたらし、ケース 1 と 3 は、最適化を使用しない場合と同じか、またはより良い振る舞いをもたらすように見えます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_無関係_irrelevant_な名前のスキップとの相互作用">6. 「無関係」(irrelevant)な名前のスキップとの相互作用</h2>
<div class="sectionbody">
<div class="paragraph"><p>以前の最適化では、「無関係」(irrelevant)と見なされるパスの名前変更検出をスキップしていました。 たとえば、以下のコミットを参照してください:</p></div>
<div class="ulist"><ul>
<li>
<p>
32a56dfb99 ("merge-ort: precompute subset of sources for which we need rename detection", 2021-03-11)(訳注:名前変更の検出が必要なソースのサブセットを事前計算する)
</p>
</li>
<li>
<p>
2fd9eda462 ("merge-ort: precompute whether directory rename detection is needed", 2021-03-11)(訳注:ディレクトリ名変更の検出が必要かどうかを事前計算する)
</p>
</li>
<li>
<p>
9bd342137e ("diffcore-rename: determine which relevant_sources are no longer relevant", 2021-03-13)(訳注:関連性がなくなった related_sources を特定する)
</p>
</li>
</ul></div>
<div class="paragraph"><p>関連性は常に、履歴の「相手側」(other side)が何をしたかによって決定されます。たとえば、 our side が名前を変更したファイルを変更したり、 our side が名前を変更したディレクトリにファイルを追加したりします。 これは、リベースまたはチェリーピックでシリーズの最初のコミットを選択するときに「無関係」(irrelevant)であるパスが、次のコミットを選択するときに突然「関連あり」(relevant)になる可能性があることを意味します。</p></div>
<div class="paragraph"><p>この結果、関連するパスの名前変更検出結果のみをキャッシュすることができ、そしてそれゆえに、後続のコミットで関連性を再確認する必要があります。 これらの後続のコミットに、名前変更の検出に関連する追加のパスがある場合は、名前変更の検出をやり直す必要があります&#8201;&#8212;&#8201;ただし、名前変更がまだ検出されていないパスに限定することはできます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_キャッシュする必要があるその他のアイテム">7. キャッシュする必要があるその他のアイテム</h2>
<div class="sectionbody">
<div class="paragraph"><p>私達は、名前変更だけでなく、それ以上のものをキャッシュしなければならないことがわかりました。 私達は以下もキャッシュします:</p></div>
<div class="olist upperalpha"><ol class="upperalpha">
<li>
<p>
非名前変更(non-renames)(つまり ペアでない削除(unpaired deletes))
</p>
</li>
<li>
<p>
ディレクトリ内の名前変更の数
</p>
</li>
<li>
<p>
RELEVANT_LOCATION としてマークされていたが、 RELEVANT_NO_MORE にダウングレードされたソース
</p>
</li>
<li>
<p>
マージに含まれるトップレベルのツリー
</p>
</li>
</ol></div>
<div class="paragraph"><p>これらはすべて以下のとおり struct rename_info に格納されます</p></div>
<div class="ulist"><ul>
<li>
<p>
cached_pairs (値が NULL の場合のみ、実際の名前変更とともに)
</p>
</li>
<li>
<p>
dir_rename_counts
</p>
</li>
<li>
<p>
cached_irrelevant
</p>
</li>
<li>
<p>
merge_trees
</p>
</li>
</ul></div>
<div class="paragraph"><p>(A) の理由は、セクション 6 で説明した最適化をスキップする無関係な名前変更に由来します。 無関係な名前変更がスキップされるという事実は、検出された可能性のある名前変更のサブセットのみを取得することを意味し、後続のコミットでは、残りの名前変更のサブセットに対してアップストリーム側で名前変更検出を実行する必要がある場合があります(その後のコミットに関連する名前変更を取得するため)。 対になっていない削除は名前変更の検出にも関与するため、移植(transplant)するすべてのコミットでそれらのパスがアップストリーム側で対になっていないままであることを繰り返し確認したくありません。</p></div>
<div class="paragraph"><p>(B) の理由は、diffcore_rename_extended() が、ディレクトリの名前変更の検出に必要なディレクトリごとの名前変更の数を生成するものであり、 diffcore_rename_extended() を再度実行しない場合は、以前の実行での dir_rename_counts を含む出力が必要です。</p></div>
<div class="paragraph"><p>&#169; の理由は、merge-ort のツリー トラバーサルがこれらのパスが関連性があると再び判断する(RELEVANT_LOCATION としてマークする)ためですが、それらが RELEVANT_NO_MORE にダウングレードされたという事実は、ディレクトリの名前変更の検出に必要な情報が dir_rename_counts に既に含まれていることを意味します。 (後続のコミットで RELEVANT_CONTENT になるパスは、cached_irrelevant から削除されます。)</p></div>
<div class="paragraph"><p>(D) の理由は、名前変更の記憶の最適化を使用できるかどうかをどのように判断するかです。 特に、一連のマージが以下のようになっていることを思い出してください:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Merge 1:
MERGE_BASE:   E
MERGE_SIDE1:  G
MERGE_SIDE2:  A
=&gt; Creates    A'</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Merge 2:
MERGE_BASE:   A
MERGE_SIDE1:  A'
MERGE_SIDE2:  B
=&gt; Creates    B'</code></pre>
</div></div>
<div class="paragraph"><p>この最適化を可能にするのは、ツリー A と A' が Merge 1 と Merge 2 の両方に表示され、A が A' の親であるという事実です。 そのため、次にマージするように求められたものと比較するために、ツリーを保存します。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_ディレクトリ名変更の検出が上記とどのように相互作用するか_また_merge_directoryrenames_が_true_に設定されている場合でも_この最適化が依然として安全である理由">8. ディレクトリ名変更の検出が上記とどのように相互作用するか、また、 merge.directoryRenames が「true」に設定されている場合でも、この最適化が依然として安全である理由。</h2>
<div class="sectionbody">
<div class="paragraph"><p>仮定セクションで述べたように:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>"""
…ディレクトリの名前変更が発生したときに、merge.directoryRenames のデフォルトが
`conflict` に設定されていることは、ユーザーが競合を解決するために操作が停止(stop)し、
キャッシュが破棄されることを意味することにも注意してください。
つまり、最適化は適用されません。
したがって、ディレクトリの名前変更に具体的に対処する必要がある唯一の理由は、
一部のユーザーが merge.directoryRenames を `true` に設定して、
マージが自動的に続行できるようにするためです。
"""</code></pre>
</div></div>
<div class="paragraph"><p>特定のピックが次のピックにどのように影響するかを調べる必要があることを思い出してください。 それでは、セクション 1 の図の最初の 2 つのピックをもう一度見てみましょう:</p></div>
<div class="paragraph"><p>最初のピックは、以下 3 方向のマージを行います</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E
MERGE_SIDE1:  G
MERGE_SIDE2:  A
=&gt; creates A'</code></pre>
</div></div>
<div class="paragraph"><p>2 番目のピックは、以下の 3 方向マージを行います</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A
MERGE_SIDE1:  A'
MERGE_SIDE2:  B
=&gt; creates B'</code></pre>
</div></div>
<div class="paragraph"><p>現在、ディレクトリの名前変更検出が存在するため、履歴の一方がディレクトリを名前変更し、もう一方が古いディレクトリに新しいファイルを追加した場合、マージ(merge.directoryRenames=true を使用)によってファイルを新しいディレクトリに移動できます。 古いディレクトリに新しいファイルを追加するには、質的に異なる 2 つの方法があります。 新しいファイルを作成するか、ファイル名を名前変更してそのディレクトリにします。 また、ディレクトリの名前変更は履歴のどちらの側でも実行できるため、考慮すべき 4 つのケースがあります:</p></div>
<div class="ulist"><ul>
<li>
<p>
MERGE_SIDE1は old dir を名前変更し、 MERGE_SIDE2は新しいファイルを old dir に追加します
</p>
</li>
<li>
<p>
MERGE_SIDE1は old dir を名前変更し、 MERGE_SIDE2はファイルの名前を old dir に名前変更します
</p>
</li>
<li>
<p>
MERGE_SIDE1は新しいファイルを old dir に追加し、MERGE_SIDE2は old dir を名前変更します
</p>
</li>
<li>
<p>
MERGE_SIDE1はファイルの名前を old dir に名前変更し、MERGE_SIDE2は old dir を名前変更します
</p>
</li>
</ul></div>
<div class="paragraph"><p>これら 4 つのケースを検討する前に、最後に 1 つ注意してください。ディレクトリの名前変更の検出に関して、この最適化をどのように実装するかについて、これらすべてのケースを検討する際に留意する必要があるいくつかの重要な性質があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
ディレクトリの名前変更を適用(apply)した「後」に、名前変更のキャッシュ(rename caching)が発生します
</p>
</li>
<li>
<p>
ディレクトリの名前変更検出によって作成された名前変更は、ディレクトリの名前変更を行った履歴の側(the side of history)に記録されます。
</p>
</li>
<li>
<p>
<code>{oldname =&gt; {newname =&gt; count}}</code> の入れ子になったマップである dir_rename_counts も、実行と実行の間に渡ってキャッシュされます。 これは基本的に、ディレクトリの名前変更検出もキャッシュされることを意味しますが、名前変更をキャッシュする履歴側のみです (このドキュメントに関する限り、MERGE_SIDE1。 「0.仮定」のセクションを参照してください)。 これらのカウントに関する 2 つの興味深いサブノートがあります:
</p>
<div class="ulist"><ul>
<li>
<p>
指定された側(side)で名前変更検出を再度実行する必要がある場合(例: 一部のパスは、以前にはなかった名前変更検出に関連しています)は、dir_rename_counts をクリアして再計算し、cached_pairs を使用します。 これを行うことが重要な理由は、RELEVANT_LOCATION 周辺の最適化が存在するためです。これにより、ディレクトリの名前変更検出のために不要な名前変更を計算したり、無関係なディレクトリの dir_rename_counts を計算したりできなくなります。 ただし、その後のマージでは、同じ名前またはディレクトリが必要になる場合があります。 このような場合に dir_rename_counts を「修正」する最も簡単な方法は、単に再計算することです。
</p>
</li>
<li>
<p>
rename/rename(1to1) エントリをキャッシュから刈り込み(prune)する場合は、dir_rename_counts を更新して、関連するディレクトリと関連する親ディレクトリの数を減らす必要もあります(名前変更が最初に見つかったときに diffcore-rename.c の update_dir_rename_counts() がインクリメントしたものを元に戻すため)。 代わりに、非常にまれな 名前変更/名前変更(1to1) のケースが発生したときに名前変更の記憶の最適化を無効にすると、上記のように、次に名前変更の検出が発生したときに dir_rename_counts が再計算されます。
</p>
</li>
</ul></div>
</li>
<li>
<p>
選択する複数のコミットがある側は、名前変更をキャッシュしない履歴の側(side)です。 したがって、ディレクトリ名変更検出 (常に過半数を埋める) によって行われるものを除いて、ディレクトリ内の名前変更の数を変更するための追加のコミットはありません。
</p>
</li>
<li>
<p>
以下に示すように、キャッシュする「名前変更」は、ディレクトリの名前変更によってわずかに変更されます。
</p>
</li>
</ul></div>
<div class="paragraph"><p>さて、これらの注意事項を整理して、4 つのケースを順番に見ていきます:</p></div>
<div class="paragraph"><p>ケース 1: MERGE_SIDE1 は old dir の名前変更し、 MERGE_SIDE2 は old dir に新しいファイルを追加します</p></div>
<div class="paragraph"><p>このケースは以下のようになります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E,   Has olddir/
MERGE_SIDE1:  G,   Renames olddir/ -&gt; newdir/
MERGE_SIDE2:  A,   Adds olddir/newfile
=&gt; creates    A',  With newdir/newfile</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A,   Has olddir/newfile
MERGE_SIDE1:  A',  Has newdir/newfile
MERGE_SIDE2:  B,   Modifies olddir/newfile
=&gt; expected   B',  with threeway-merged newdir/newfile from above</code></pre>
</div></div>
<div class="paragraph"><p>最適化されるこの場合、最初のコミット後に以下の点に注意してください:</p></div>
<div class="ulist"><ul>
<li>
<p>
MERGE_SIDE1 は olddir/ → newdir/ を記憶します
</p>
</li>
<li>
<p>
MERGE_SIDE1 は olddir/newfile → newdir/newfile をキャッシュしました
</p>
</li>
</ul></div>
<div class="paragraph"><p>上記のキャッシュされた名前変更を考えると、2番目のマージは、 A → A' からの名前変更検出を実行する必要なく、期待どおりに続行できます。</p></div>
<div class="paragraph"><p>Case 2: MERGE_SIDE1 は old dir を名前変更し、 MERGE_SIDE2 はファイルの名前を old dir に名前変更します</p></div>
<div class="paragraph"><p>このケースは以下のようになります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E    oldfile, olddir/
MERGE_SIDE1:  G    oldfile, olddir/ -&gt; newdir/
MERGE_SIDE2:  A    oldfile -&gt; olddir/newfile
=&gt; creates    A',  With newdir/newfile representing original oldfile</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A    olddir/newfile
MERGE_SIDE1:  A'   newdir/newfile
MERGE_SIDE2:  B    modify olddir/newfile
=&gt; expected   B',  with threeway-merged newdir/newfile from above</code></pre>
</div></div>
<div class="paragraph"><p>最適化されるこの場合、最初のコミット後に以下の点に注意してください:</p></div>
<div class="ulist"><ul>
<li>
<p>
MERGE_SIDE1 は olddir/ → newdir/ を記憶します
</p>
</li>
<li>
<p>
MERGE_SIDE1 は olddir/newfile → newdir/newfile をキャッシュします(oldfile → newdir/newfile ではありません。 possible_cache_new_pair() 内の (p&#8594;status == <em>R</em> &amp;&amp; new_path) の場合と比較してください)
</p>
</li>
</ul></div>
<div class="paragraph"><p>上記のキャッシュされた名前変更を考えると、2番目のマージは、 A → A' からの名前変更検出を実行する必要なく、期待どおりに続行できます。</p></div>
<div class="paragraph"><p>ケース 3: MERGE_SIDE1は新しいファイルを「古いディレクトリ」に追加し、MERGE_SIDE2は「古いディレクトリ」を名前変更します</p></div>
<div class="paragraph"><p>このケースは以下のようになります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E,   Has olddir/
MERGE_SIDE1:  G,   Adds olddir/newfile
MERGE_SIDE2:  A,   Renames olddir/ -&gt; newdir/
=&gt; creates    A',  With newdir/newfile</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A,   Has newdir/, but no notion of newdir/newfile
MERGE_SIDE1:  A',  Has newdir/newfile
MERGE_SIDE2:  B,   Has newdir/, but no notion of newdir/newfile
=&gt; expected   B',  with newdir/newfile from A'</code></pre>
</div></div>
<div class="paragraph"><p>この場合、最適化により、最初のコミット後に MERGE_SIDE1 の名前変更がなく、MERGE_SIDE2 の名前変更が破棄されることに注意してください。 しかし、2 回目のマージでは名前変更する必要がなかったので、これで問題ありません。</p></div>
<div class="paragraph"><p>ケース 4: MERGE_SIDE1 はファイルの名前を old dir に名前変更し、MERGE_SIDE2 は old dir を名前変更します</p></div>
<div class="paragraph"><p>このケースは以下のようになります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   E,   Has olddir/
MERGE_SIDE1:  G,   Renames oldfile -&gt; olddir/newfile
MERGE_SIDE2:  A,   Renames olddir/ -&gt; newdir/
=&gt; creates    A',  With newdir/newfile representing original oldfile</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>MERGE_BASE:   A,   Has oldfile
MERGE_SIDE1:  A',  Has newdir/newfile
MERGE_SIDE2:  B,   Modifies oldfile
=&gt; expected   B',  with threeway-merged newdir/newfile from above</code></pre>
</div></div>
<div class="paragraph"><p>最適化されるこの場合、最初のコミット後に以下の点に注意してください:</p></div>
<div class="ulist"><ul>
<li>
<p>
MERGE_SIDE1 は oldfile → newdir/newfile を記憶します(oldfile → olddir/newfile ではありません。 possible_cache_new_pair() 内の p&#8594;status == <em>R</em> の下の 2番目のブロックの場合と比較してください)
</p>
</li>
<li>
<p>
MERGE_SIDE1 のみが記憶されているため、 MERGE_SIDE2 の名前変更は破棄されます
</p>
</li>
</ul></div>
<div class="paragraph"><p>上記のキャッシュされた名前変更を考えると、2番目のマージは、 A → A' からの名前変更検出を実行する必要なく、期待どおりに続行できます。</p></div>
<div class="paragraph"><p>Finally, I&#8217;ll just note here that interactions with the skip-irrelevant-renames optimization means we sometimes don&#8217;t detect renames for any files within a directory that was renamed, in which case we will not have been able to detect any rename for the directory itself. In such a case, we do not know whether the directory was renamed; we want to be careful to avoid caching some kind of "this directory was not renamed" statement. If we did, then a subsequent commit being rebased could add a file to the old directory, and the user would expect it to end up in the correct directory&#8201;&#8212;&#8201;something our erroneous "this directory was not renamed" cache would preclude.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-07-18 11:06:04 JST
</div>
</div>
</body>
</html>
