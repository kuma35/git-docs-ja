# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2022-05-14 18:37+0900\n"
"PO-Revision-Date: 2022-05-15 04:12+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/technical/chunk-format.txt:2
#, no-wrap
msgid "Chunk-based file formats"
msgstr "Chunk-based file formats"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:11
msgid ""
"Some file formats in Git use a common concept of \"chunks\" to describe "
"sections of the file. This allows structured access to a large file by "
"scanning a small \"table of contents\" for the remaining data. This common "
"format is used by the `commit-graph` and `multi-pack-index` files. See link:"
"technical/pack-format.html[the `multi-pack-index` format] and link:technical/"
"commit-graph-format.html[the `commit-graph` format] for how they use the "
"chunks to describe structured data."
msgstr ""
"Gitの一部のファイル形式では、「チャンク」(chunks)という共通の概念を使用して"
"ファイルのセクションを記述します。 これは、残りのデータに対して小さな「目次」"
"(table of contents)をスキャンすることで、大きなファイルへの構造化されたアクセ"
"スを可能にします。 この共通形式は、`commit-graph` ファイルと `multi-pack-"
"index` ファイルで使用されます。 チャンクを使用して構造化データを記述する方法"
"については、 link:technical/pack-format.html[the `multi-pack-index` format] "
"と link:technical/commit-graph-format.html[the `commit-graph` format] を参照"
"してください。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:16
msgid ""
"A chunk-based file format begins with some header information custom to that "
"format. That header should include enough information to identify the file "
"type, format version, and number of chunks in the file. From this "
"information, that file can determine the start of the chunk-based region."
msgstr "チャンクベースファイル形式(chunk-based file format)は、その形式に合わせたヘッダー情報から始まります。 そのヘッダーには、ファイルタイプ、形式バージョン、ファイル内のチャンクの数、を識別するのに十分な情報が含まれている必要があります。 この情報から、そのファイルはチャンクベース領域(chunk-based region)の開始を決定する事ができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:20
msgid ""
"The chunk-based region starts with a table of contents describing where each "
"chunk starts and ends. This consists of (C+1) rows of 12 bytes each, where C "
"is the number of chunks. Consider the following table:"
msgstr "チャンクベース領域(chunk-based region)は、各チャンクの開始と終了を説明する目次(table of contents)で始まります。 これは、各行(row)12バイトの (C+1)行(row)で構成されます。ここで、Cはチャンクの数です。 以下の表をじっくり見やがれしてください。"

#. type: delimited block -
#: ../Documentation-sedout/technical/chunk-format.txt:28
#, no-wrap
msgid ""
"  | Chunk ID (4 bytes) | Chunk Offset (8 bytes) |\n"
"  |--------------------|------------------------|\n"
"  | ID[0]              | OFFSET[0]              |\n"
"  | ...                | ...                    |\n"
"  | ID[C]              | OFFSET[C]              |\n"
"  | 0x0000             | OFFSET[C+1]            |\n"
msgstr ""
"  | Chunk ID (4 bytes) | Chunk Offset (8 bytes) |\n"
"  |--------------------|------------------------|\n"
"  | ID[0]              | OFFSET[0]              |\n"
"  | ...                | ...                    |\n"
"  | ID[C]              | OFFSET[C]              |\n"
"  | 0x0000             | OFFSET[C+1]            |\n"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:32
msgid ""
"Each row consists of a 4-byte chunk identifier (ID) and an 8-byte offset.  "
"Each integer is stored in network-byte order."
msgstr ""
"各行(row)は、4バイトのチャンク識別子(ID)と8バイトのオフセットで構成されます。"
"各整数はネットワークバイトオーダーで格納されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:38
msgid ""
"The chunk identifier `ID[i]` is a label for the data stored within this fill "
"from `OFFSET[i]` (inclusive) to `OFFSET[i+1]` (exclusive). Thus, the size of "
"the `i`th chunk is equal to the difference between `OFFSET[i+1]` and "
"`OFFSET[i]`. This requires that the chunk data appears contiguously in the "
"same order as the table of contents."
msgstr "チャンク識別子 `ID[i]` は、 `OFFSET[i]` (含む) から `OFFSET[i+1]` (含まない) (訳注: OFFSET[i] <= ID[i]のデータ < OFFSET[i+1]) までの、このフィル内に格納されたデータのラベルです。したがって、 `i` 番目のチャンクのサイズは、`OFFSET[i+1]` と `OFFSET[i]` の差に等しくなります(訳注: つまり、サイズ = OFFSET[i+1] - OFFSET[i])。 このためには、チャンクデータが目次と同じ順序で連続して表れる必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:42
msgid ""
"The final entry in the table of contents must be four zero bytes. This "
"confirms that the table of contents is ending and provides the offset for "
"the end of the chunk-based data."
msgstr "目次の最後のエントリは、4つのゼロバイトである必要があります。 これにより、目次が終了していることが確認され、チャンクベースのデータの終了のオフセットが提供されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:45
msgid ""
"Note: The chunk-based format expects that the file contains _at least_ a "
"trailing hash after `OFFSET[C+1]`."
msgstr "注意: チャンクベース形式では、ファイルの `OFFSET[C+1]` の後に、「少なくとも」末尾のハッシュ(trailing hash)が含まれている必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:49
msgid ""
"Functions for working with chunk-based file formats are declared in `chunk-"
"format.h`. Using these methods provide extra checks that assist developers "
"when creating new file formats."
msgstr "チャンクベースのファイル形式を操作するための関数は、 `chunk-format.h` で宣言されています。 これらのメソッドを使用すると、開発者が新しいファイル形式を作成するときに役立つ追加のチェックが提供されます。"

#. type: Title -
#: ../Documentation-sedout/technical/chunk-format.txt:51
#, no-wrap
msgid "Writing chunk-based file formats"
msgstr "Writing chunk-based file formats"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:58
msgid ""
"To write a chunk-based file format, create a `struct chunkfile` by calling "
"`init_chunkfile()` and pass a `struct hashfile` pointer. The caller is "
"responsible for opening the `hashfile` and writing header information so the "
"file format is identifiable before the chunk-based format begins."
msgstr "チャンクベースファイル形式を作成するには、 `init_chunkfile()_ を呼び出して `struct chunkfile` を作成し、 `struct hashfile` ポインタを渡します。 呼び出し元は、 `hashfile` を開き、ヘッダー情報を書き込む責任があります。これにより、チャンクベース形式が始まる前にファイル形式を識別できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:63
msgid ""
"Then, call `add_chunk()` for each chunk that is intended for write. This "
"populates the `chunkfile` with information about the order and size of each "
"chunk to write. Provide a `chunk_write_fn` function pointer to perform the "
"write of the chunk data upon request."
msgstr "次に、書き込み用のチャンクごとに `add_chunk()` を呼び出します。 これにより、`chunkfile` に書き込む各チャンクの順序とサイズに関する情報が入力されます。 要求に応じてチャンクデータの書き込みを実行するための `chunk_write_fn` 関数ポインタを提供します。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:67
msgid ""
"Call `write_chunkfile()` to write the table of contents to the `hashfile` "
"followed by each of the chunks. This will verify that each chunk wrote the "
"expected amount of data so the table of contents is correct."
msgstr "`write_chunkfile()` を呼び出して、目次(table of contents)を `hashfile` に書き込み、その後に各チャンクを書き込みます。 これにより、各チャンクが予想される量のデータを書き込んだことを確認し、目次が正しいことを確認します。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:71
msgid ""
"Finally, call `free_chunkfile()` to clear the `struct chunkfile` data. The "
"caller is responsible for finalizing the `hashfile` by writing the trailing "
"hash and closing the file."
msgstr "最後に、 `free_chunkfile()` を呼び出して、 `structc hunkfile` データをクリアします。 呼び出し元は、末尾のハッシュ(trailing hash)を書き込んでファイルを閉じることにより、 `hashfile` を完成させる責任があります。"

#. type: Title -
#: ../Documentation-sedout/technical/chunk-format.txt:73
#, no-wrap
msgid "Reading chunk-based file formats"
msgstr "Reading chunk-based file formats"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:78
msgid ""
"To read a chunk-based file format, the file must be opened as a memory-"
"mapped region. The chunk-format API expects that the entire file is mapped "
"as a contiguous memory region."
msgstr "チャンクベースファイル形式を読み取るには、ファイルをメモリマップ領域(memory-mapped region)として開く必要があります。 チャンク形式のAPIは、ファイル全体が連続したメモリ領域としてマップされることを想定しています。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:80
msgid "Initialize a `struct chunkfile` pointer with `init_chunkfile(NULL)`."
msgstr "`init_chunkfile(NULL)` で `struct chunkfile` ポインタを初期化します。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:85
msgid ""
"After reading the header information from the beginning of the file, "
"including the chunk count, call `read_table_of_contents()` to populate the "
"`struct chunkfile` with the list of chunks, their offsets, and their sizes."
msgstr "ファイルの先頭からチャンクカウント(chunk count)を含むヘッダー情報を読み取った後、 `read_table_of_contents()` を呼び出して、 `structc hunkfile` にチャンクのリスト、それらのオフセット、およびそれらのサイズを入力します。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:88
msgid ""
"Extract the data information for each chunk using `pair_chunk()` or "
"`read_chunk()`:"
msgstr "`pair_chunk()` または `read_chunk()` を使用して、各チャンクのデータ情報を抽出します:"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:92
msgid ""
"`pair_chunk()` assigns a given pointer with the location inside the memory-"
"mapped file corresponding to that chunk's offset. If the chunk does not "
"exist, then the pointer is not modified."
msgstr "`pair_chunk()` は、そのチャンクのオフセットに対応するメモリマップされたファイル(memory-mapped file)内の場所に特定のポインタを割り当てます。 チャンクが存在しない場合、ポインターは変更されません。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:98
msgid ""
"`read_chunk()` takes a `chunk_read_fn` function pointer and calls it with "
"the appropriate initial pointer and size information. The function is not "
"called if the chunk does not exist. Use this method to read chunks if you "
"need to perform immediate parsing or if you need to execute logic based on "
"the size of the chunk."
msgstr "`read_chunk()` は、 `chunk_read_fn` 関数ポインタを受け取り、適切な初期ポインタとサイズ情報を使用して呼び出します。 チャンクが存在しない場合、関数は呼び出されません。 即時パース(immediate parsing)を実行する必要がある場合、またはチャンクのサイズに基づいてロジックを実行する必要がある場合は、このメソッドを使用してチャンクを読み取ります。"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:103
msgid ""
"After calling these methods, call `free_chunkfile()` to clear the `struct "
"chunkfile` data. This will not close the memory-mapped region.  Callers are "
"expected to own that data for the timeframe the pointers into the region are "
"needed."
msgstr "これらのメソッドを呼び出した後、 `free_chunkfile()` を呼び出して `structc hunkfile` データをクリアします。 これにより、メモリマップ領域は閉じられません。 呼び出し元は、領域へのポインタが必要とされている間はデータを所有しつづけることが期待されます。"

#. type: Title -
#: ../Documentation-sedout/technical/chunk-format.txt:105
#, no-wrap
msgid "Examples"
msgstr "Examples"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:109
msgid ""
"These file formats use the chunk-format API, and can be used as examples for "
"future formats:"
msgstr "これらのファイル形式はチャンク形式のAPIを使用しており、将来の形式の例として使用できます:"

#. type: Labeled list
#: ../Documentation-sedout/technical/chunk-format.txt:110
#, no-wrap
msgid "commit-graph"
msgstr "commit-graph"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:115
msgid ""
"see `write_commit_graph_file()` and `parse_commit_graph()` in `commit-graph."
"c` for how the chunk-format API is used to write and parse the commit-graph "
"file format documented in link:technical/commit-graph-format.html[the commit-"
"graph file format]."
msgstr "link:technical/commit-graph-format.html[the commit-graph file format] に記載されているcommit-graphファイル形式の書き込みとパースにチャンク形式APIを使用する方法については、 `commit-graph.c` の `write_commit_graph_file()` と `parse_commit_graph()`を参照してください。"

#. type: Labeled list
#: ../Documentation-sedout/technical/chunk-format.txt:115
#, no-wrap
msgid "multi-pack-index"
msgstr "multi-pack-index"

#. type: Plain text
#: ../Documentation-sedout/technical/chunk-format.txt:119
msgid ""
"see `write_midx_internal()` and `load_multi_pack_index()` in `midx.c` for "
"how the chunk-format API is used to write and parse the multi-pack-index "
"file format documented in link:technical/pack-format.html[the multi-pack-"
"index file format]."
msgstr "link:technical/pack-format.html[the multi-pack-index file format] に記載されているマルチパックインデックスファイル形式の書き込みとパースにチャンク形式APIを使用する方法については、 `midx.c` の `write_midx_internal()` と `load_multi_pack_index()`を参照してください。"
