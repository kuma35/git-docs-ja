# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-01 00:25+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation/git-checkout.txt:2
#, no-wrap
msgid "git-checkout(1)"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:5
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:7
msgid "git-checkout - Switch branches or restore working tree files"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:9
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:18
#, no-wrap
msgid ""
"'git checkout' [-q] [-f] [-m] [<branch>]\n"
"'git checkout' [-q] [-f] [-m] --detach [<branch>]\n"
"'git checkout' [-q] [-f] [-m] [--detach] <commit>\n"
"'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <new_branch>] "
"[<start_point>]\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] "
"<pathspec>...\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] "
"--pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]\n"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:20
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:25
msgid ""
"Updates files in the working tree to match the version in the index or the "
"specified tree.  If no pathspec was given, 'git checkout' will also update "
"`HEAD` to set the specified branch as the current branch."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:26
#, no-wrap
msgid "'git checkout' [<branch>]"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:32
msgid ""
"To prepare for working on `<branch>`, switch to it by updating the index and "
"the files in the working tree, and by pointing `HEAD` at the branch. Local "
"modifications to the files in the working tree are kept, so that they can be "
"committed to the `<branch>`."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:36
msgid ""
"If `<branch>` is not found but there does exist a tracking branch in exactly "
"one remote (call it `<remote>`) with a matching name and `--no-guess` is not "
"specified, treat as equivalent to"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:39 ../Documentation/git-checkout.txt:184
#, no-wrap
msgid "$ git checkout -b <branch> --track <remote>/<branch>\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:45
msgid ""
"You could omit `<branch>`, in which case the command degenerates to \"check "
"out the current branch\", which is a glorified no-op with rather expensive "
"side-effects to show only the tracking information, if exists, for the "
"current branch."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:46
#, no-wrap
msgid "'git checkout' -b|-B <new_branch> [<start point>]"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:54
msgid ""
"Specifying `-b` causes a new branch to be created as if "
"linkgit:git-branch[1] were called and then checked out.  In this case you "
"can use the `--track` or `--no-track` options, which will be passed to 'git "
"branch'.  As a convenience, `--track` without `-b` implies branch creation; "
"see the description of `--track` below."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:57
msgid ""
"If `-B` is given, `<new_branch>` is created if it doesn't exist; otherwise, "
"it is reset. This is the transactional equivalent of"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:61
#, no-wrap
msgid ""
"$ git branch -f <branch> [<start point>]\n"
"$ git checkout <branch>\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:65
msgid ""
"that is to say, the branch is not reset/created unless \"git checkout\" is "
"successful."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:66
#, no-wrap
msgid "'git checkout' --detach [<branch>]"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:67
#, no-wrap
msgid "'git checkout' [--detach] <commit>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:75
msgid ""
"Prepare to work on top of `<commit>`, by detaching `HEAD` at it (see "
"\"DETACHED HEAD\" section), and updating the index and the files in the "
"working tree.  Local modifications to the files in the working tree are "
"kept, so that the resulting working tree will be the state recorded in the "
"commit plus the local modifications."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:79
msgid ""
"When the `<commit>` argument is a branch name, the `--detach` option can be "
"used to detach `HEAD` at the tip of the branch (`git checkout <branch>` "
"would check out that branch without detaching `HEAD`)."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:81
msgid "Omitting `<branch>` detaches `HEAD` at the tip of the current branch."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:82
#, no-wrap
msgid ""
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] "
"<pathspec>..."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:83
#, no-wrap
msgid ""
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] "
"--pathspec-from-file=<file> [--pathspec-file-nul]"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:90
msgid ""
"Overwrite the contents of the files that match the pathspec.  When the "
"`<tree-ish>` (most often a commit) is not given, overwrite working tree with "
"the contents in the index.  When the `<tree-ish>` is given, overwrite both "
"the index and the working tree with the contents at the `<tree-ish>`."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:98
msgid ""
"The index may contain unmerged entries because of a previous failed merge.  "
"By default, if you try to check out such an entry from the index, the "
"checkout operation will fail and nothing will be checked out.  Using `-f` "
"will ignore these unmerged entries.  The contents from a specific side of "
"the merge can be checked out of the index by using `--ours` or `--theirs`.  "
"With `-m`, changes made to the working tree file can be discarded to "
"re-create the original conflicted merge result."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:99
#, no-wrap
msgid "'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:104
msgid ""
"This is similar to the previous mode, but lets you use the interactive "
"interface to show the \"diff\" output and choose which hunks to use in the "
"result.  See below for the description of `--patch` option."
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:106
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:107
#, no-wrap
msgid "-q"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:108
#, no-wrap
msgid "--quiet"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:110
msgid "Quiet, suppress feedback messages."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:111
#, no-wrap
msgid "--progress"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:112
#, no-wrap
msgid "--no-progress"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:117
msgid ""
"Progress status is reported on the standard error stream by default when it "
"is attached to a terminal, unless `--quiet` is specified. This flag enables "
"progress reporting even if not attached to a terminal, regardless of "
"`--quiet`."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:118
#, no-wrap
msgid "-f"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:119
#, no-wrap
msgid "--force"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:123
msgid ""
"When switching branches, proceed even if the index or the working tree "
"differs from `HEAD`.  This is used to throw away local changes."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:126
msgid ""
"When checking out paths from the index, do not fail upon unmerged entries; "
"instead, unmerged entries are ignored."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:127
#, no-wrap
msgid "--ours"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:128
#, no-wrap
msgid "--theirs"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:131
msgid ""
"When checking out paths from the index, check out stage #2 ('ours') or #3 "
"('theirs') for unmerged paths."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:136
msgid ""
"Note that during `git rebase` and `git pull --rebase`, 'ours' and 'theirs' "
"may appear swapped; `--ours` gives the version from the branch the changes "
"are rebased onto, while `--theirs` gives the version from the branch that "
"holds your work that is being rebased."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:146
msgid ""
"This is because `rebase` is used in a workflow that treats the history at "
"the remote as the shared canonical one, and treats the work done on the "
"branch you are rebasing as the third-party work to be integrated, and you "
"are temporarily assuming the role of the keeper of the canonical history "
"during the rebase.  As the keeper of the canonical history, you need to view "
"the history from the remote as `ours` (i.e. \"our shared canonical "
"history\"), while what you did on your side branch as `theirs` (i.e. \"one "
"contributor's work on top of it\")."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:147
#, no-wrap
msgid "-b <new_branch>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:150
msgid ""
"Create a new branch named `<new_branch>` and start it at `<start_point>`; "
"see linkgit:git-branch[1] for details."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:151
#, no-wrap
msgid "-B <new_branch>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:156
msgid ""
"Creates the branch `<new_branch>` and start it at `<start_point>`; if it "
"already exists, then reset it to `<start_point>`. This is equivalent to "
"running \"git branch\" with \"-f\"; see linkgit:git-branch[1] for details."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:157
#, no-wrap
msgid "-t"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:158
#, no-wrap
msgid "--track"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:161
msgid ""
"When creating a new branch, set up \"upstream\" configuration. See "
"\"--track\" in linkgit:git-branch[1] for details."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:171
msgid ""
"If no `-b` option is given, the name of the new branch will be derived from "
"the remote-tracking branch, by looking at the local part of the refspec "
"configured for the corresponding remote, and then stripping the initial part "
"up to the \"*\".  This would tell us to use `hack` as the local branch when "
"branching off of `origin/hack` (or `remotes/origin/hack`, or even "
"`refs/remotes/origin/hack`).  If the given name has no slash, or the above "
"guessing results in an empty name, the guessing is aborted.  You can "
"explicitly give a name with `-b` in such a case."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:172
#, no-wrap
msgid "--no-track"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:175
msgid ""
"Do not set up \"upstream\" configuration, even if the "
"`branch.autoSetupMerge` configuration variable is true."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:176
#, no-wrap
msgid "--guess"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:177
#, no-wrap
msgid "--no-guess"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:181
msgid ""
"If `<branch>` is not found but there does exist a tracking branch in exactly "
"one remote (call it `<remote>`) with a matching name, treat as equivalent to"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:194
msgid ""
"If the branch exists in multiple remotes and one of them is named by the "
"`checkout.defaultRemote` configuration variable, we'll use that one for the "
"purposes of disambiguation, even if the `<branch>` isn't unique across all "
"remotes. Set it to e.g. `checkout.defaultRemote=origin` to always checkout "
"remote branches from there if `<branch>` is ambiguous but exists on the "
"'origin' remote. See also `checkout.defaultRemote` in linkgit:git-config[1]."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:196
msgid "`--guess` is the default behavior. Use `--no-guess` to disable it."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:199
msgid ""
"The default behavior can be set via the `checkout.guess` configuration "
"variable."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:200
#, no-wrap
msgid "-l"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:203
msgid "Create the new branch's reflog; see linkgit:git-branch[1] for details."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:204
#, no-wrap
msgid "-d"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:205
#, no-wrap
msgid "--detach"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:211
msgid ""
"Rather than checking out a branch to work on it, check out a commit for "
"inspection and discardable experiments.  This is the default behavior of "
"`git checkout <commit>` when `<commit>` is not a branch name.  See the "
"\"DETACHED HEAD\" section below for details."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:212
#, no-wrap
msgid "--orphan <new_branch>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:218
msgid ""
"Create a new 'orphan' branch, named `<new_branch>`, started from "
"`<start_point>` and switch to it.  The first commit made on this new branch "
"will have no parents and it will be the root of a new history totally "
"disconnected from all the other branches and commits."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:223
msgid ""
"The index and the working tree are adjusted as if you had previously run "
"`git checkout <start_point>`.  This allows you to start a new history that "
"records a set of paths similar to `<start_point>` by easily running `git "
"commit -a` to make the root commit."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:229
msgid ""
"This can be useful when you want to publish the tree from a commit without "
"exposing its full history. You might want to do this to publish an open "
"source branch of a project whose current tree is \"clean\", but whose full "
"history contains proprietary or otherwise encumbered bits of code."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:236
msgid ""
"If you want to start a disconnected history that records a set of paths that "
"is totally different from the one of `<start_point>`, then you should clear "
"the index and the working tree right after creating the orphan branch by "
"running `git rm -rf .` from the top level of the working tree.  Afterwards "
"you will be ready to prepare your new files, repopulating the working tree, "
"by copying them from elsewhere, extracting a tarball, etc."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:237
#, no-wrap
msgid "--ignore-skip-worktree-bits"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:242
msgid ""
"In sparse checkout mode, `git checkout -- <paths>` would update only entries "
"matched by `<paths>` and sparse patterns in "
"`$GIT_DIR/info/sparse-checkout`. This option ignores the sparse patterns and "
"adds back any files in `<paths>`."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:243
#, no-wrap
msgid "-m"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:244
#, no-wrap
msgid "--merge"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:253
msgid ""
"When switching branches, if you have local modifications to one or more "
"files that are different between the current branch and the branch to which "
"you are switching, the command refuses to switch branches in order to "
"preserve your modifications in context.  However, with this option, a "
"three-way merge between the current branch, your working tree contents, and "
"the new branch is done, and you will be on the new branch."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:258
msgid ""
"When a merge conflict happens, the index entries for conflicting paths are "
"left unmerged, and you need to resolve the conflicts and mark the resolved "
"paths with `git add` (or `git rm` if the merge should result in deletion of "
"the path)."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:261
msgid ""
"When checking out paths from the index, this option lets you recreate the "
"conflicted merge in the specified paths."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:263
msgid "When switching branches with `--merge`, staged changes may be lost."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:264
#, no-wrap
msgid "--conflict=<style>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:270
msgid ""
"The same as `--merge` option above, but changes the way the conflicting "
"hunks are presented, overriding the `merge.conflictStyle` configuration "
"variable.  Possible values are \"merge\" (default) and \"diff3\" (in "
"addition to what is shown by \"merge\" style, shows the original contents)."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:271
#, no-wrap
msgid "-p"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:272
#, no-wrap
msgid "--patch"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:277
msgid ""
"Interactively select hunks in the difference between the `<tree-ish>` (or "
"the index, if unspecified) and the working tree.  The chosen hunks are then "
"applied in reverse to the working tree (and if a `<tree-ish>` was specified, "
"the index)."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:281
msgid ""
"This means that you can use `git checkout -p` to selectively discard edits "
"from your current working tree. See the ``Interactive Mode'' section of "
"linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:284
msgid ""
"Note that this option uses the no overlay mode by default (see also "
"`--overlay`), and currently doesn't support overlay mode."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:285
#, no-wrap
msgid "--ignore-other-worktrees"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:290
msgid ""
"`git checkout` refuses when the wanted ref is already checked out by another "
"worktree. This option makes it check the ref out anyway. In other words, the "
"ref can be held by more than one worktree."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:291
#, no-wrap
msgid "--overwrite-ignore"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:292
#, no-wrap
msgid "--no-overwrite-ignore"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:296
msgid ""
"Silently overwrite ignored files when switching branches. This is the "
"default behavior. Use `--no-overwrite-ignore` to abort the operation when "
"the new branch contains ignored files."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:297
#, no-wrap
msgid "--recurse-submodules"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:298
#, no-wrap
msgid "--no-recurse-submodules"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:306
msgid ""
"Using `--recurse-submodules` will update the content of all active "
"submodules according to the commit recorded in the superproject. If local "
"modifications in a submodule would be overwritten the checkout will fail "
"unless `-f` is used. If nothing (or `--no-recurse-submodules`)  is used, "
"submodules working trees will not be updated.  Just like "
"linkgit:git-submodule[1], this will detach `HEAD` of the submodule."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:307
#, no-wrap
msgid "--overlay"
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:308
#, no-wrap
msgid "--no-overlay"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:314
msgid ""
"In the default overlay mode, `git checkout` never removes files from the "
"index or the working tree.  When specifying `--no-overlay`, files that "
"appear in the index and working tree, but not in `<tree-ish>` are removed, "
"to make them match `<tree-ish>` exactly."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:315
#, no-wrap
msgid "--pathspec-from-file=<file>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:322
msgid ""
"Pathspec is passed in `<file>` instead of commandline args. If `<file>` is "
"exactly `-` then standard input is used. Pathspec elements are separated by "
"LF or CR/LF. Pathspec elements can be quoted as explained for the "
"configuration variable `core.quotePath` (see linkgit:git-config[1]). See "
"also `--pathspec-file-nul` and global `--literal-pathspecs`."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:323
#, no-wrap
msgid "--pathspec-file-nul"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:327
msgid ""
"Only meaningful with `--pathspec-from-file`. Pathspec elements are separated "
"with NUL character and all other characters are taken literally (including "
"newlines and quotes)."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:328
#, no-wrap
msgid "<branch>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:334
msgid ""
"Branch to checkout; if it refers to a branch (i.e., a name that, when "
"prepended with \"refs/heads/\", is a valid ref), then that branch is checked "
"out. Otherwise, if it refers to a valid commit, your `HEAD` becomes "
"\"detached\" and you are no longer on any branch (see below for details)."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:338
msgid ""
"You can use the `@{-N}` syntax to refer to the N-th last branch/commit "
"checked out using \"git checkout\" operation. You may also specify `-` which "
"is synonymous to `@{-1}`."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:342
msgid ""
"As a special case, you may use `A...B` as a shortcut for the merge base of "
"`A` and `B` if there is exactly one merge base. You can leave out at most "
"one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:343
#, no-wrap
msgid "<new_branch>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:345
msgid "Name for the new branch."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:346
#, no-wrap
msgid "<start_point>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:349
msgid ""
"The name of a commit at which to start the new branch; see "
"linkgit:git-branch[1] for details. Defaults to `HEAD`."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:353 ../Documentation/git-checkout.txt:361
msgid ""
"As a special case, you may use `\"A...B\"` as a shortcut for the merge base "
"of `A` and `B` if there is exactly one merge base. You can leave out at most "
"one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:354
#, no-wrap
msgid "<tree-ish>"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:357
msgid ""
"Tree to checkout from (when paths are given). If not specified, the index "
"will be used."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:362
#, no-wrap
msgid "\\--"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:364
msgid "Do not interpret any more arguments as options."
msgstr ""

#. type: Labeled list
#: ../Documentation/git-checkout.txt:365
#, no-wrap
msgid "<pathspec>..."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:367
msgid "Limits the paths affected by the operation."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:369
msgid "For more details, see the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:371
#, no-wrap
msgid "DETACHED HEAD"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:375
msgid ""
"`HEAD` normally refers to a named branch (e.g. `master`). Meanwhile, each "
"branch refers to a specific commit. Let's look at a repo with three commits, "
"one of them tagged, and with branch `master` checked out:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:384
#, no-wrap
msgid ""
"           HEAD (refers to branch 'master')\n"
"            |\n"
"            v\n"
"a---b---c  branch 'master' (refers to commit 'c')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:391
msgid ""
"When a commit is created in this state, the branch is updated to refer to "
"the new commit. Specifically, 'git commit' creates a new commit `d`, whose "
"parent is commit `c`, and then updates branch `master` to refer to new "
"commit `d`. `HEAD` still refers to branch `master` and so indirectly now "
"refers to commit `d`:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:394 ../Documentation/git-checkout.txt:429 ../Documentation/git-checkout.txt:446
#, no-wrap
msgid "$ edit; git add; git commit\n"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:402
#, no-wrap
msgid ""
"               HEAD (refers to branch 'master')\n"
"                |\n"
"                v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:408
msgid ""
"It is sometimes useful to be able to checkout a commit that is not at the "
"tip of any named branch, or even to create a new commit that is not "
"referenced by a named branch. Let's look at what happens when we checkout "
"commit `b` (here we show two ways this may be done):"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:412
#, no-wrap
msgid ""
"$ git checkout v2.0  # or\n"
"$ git checkout master^^\n"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:420
#, no-wrap
msgid ""
"   HEAD (refers to commit 'b')\n"
"    |\n"
"    v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:426
msgid ""
"Notice that regardless of which checkout command we use, `HEAD` now refers "
"directly to commit `b`. This is known as being in detached `HEAD` state.  It "
"means simply that `HEAD` refers to a specific commit, as opposed to "
"referring to a named branch. Let's see what happens when we create a commit:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:439
#, no-wrap
msgid ""
"     HEAD (refers to commit 'e')\n"
"      |\n"
"      v\n"
"      e\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:443
msgid ""
"There is now a new commit `e`, but it is referenced only by `HEAD`. We can "
"of course add yet another commit in this state:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:456
#, no-wrap
msgid ""
"\t HEAD (refers to commit 'f')\n"
"\t  |\n"
"\t  v\n"
"      e---f\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:460
msgid ""
"In fact, we can perform all the normal Git operations. But, let's look at "
"what happens when we then checkout `master`:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:463
#, no-wrap
msgid "$ git checkout master\n"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:471
#, no-wrap
msgid ""
"               HEAD (refers to branch 'master')\n"
"      e---f     |\n"
"     /          v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:478
msgid ""
"It is important to realize that at this point nothing refers to commit "
"`f`. Eventually commit `f` (and by extension commit `e`) will be deleted by "
"the routine Git garbage collection process, unless we create a reference "
"before that happens. If we have not yet moved away from commit `f`, any of "
"these will create a reference to it:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:483
#, no-wrap
msgid ""
"$ git checkout -b foo   <1>\n"
"$ git branch foo        <2>\n"
"$ git tag foo           <3>\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:488
msgid ""
"creates a new branch `foo`, which refers to commit `f`, and then updates "
"`HEAD` to refer to branch `foo`. In other words, we'll no longer be in "
"detached `HEAD` state after this command."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:491
msgid ""
"similarly creates a new branch `foo`, which refers to commit `f`, but leaves "
"`HEAD` detached."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:494
msgid ""
"creates a new tag `foo`, which refers to commit `f`, leaving `HEAD` "
"detached."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:499
msgid ""
"If we have moved away from commit `f`, then we must first recover its object "
"name (typically by using git reflog), and then we can create a reference to "
"it. For example, to see the last two commits to which `HEAD` referred, we "
"can use either of these commands:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:503
#, no-wrap
msgid ""
"$ git reflog -2 HEAD # or\n"
"$ git log -g -2 HEAD\n"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:506
#, no-wrap
msgid "ARGUMENT DISAMBIGUATION"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:516
msgid ""
"When there is only one argument given and it is not `--` (e.g. `git checkout "
"abc`), and when the argument is both a valid `<tree-ish>` (e.g. a branch "
"`abc` exists) and a valid `<pathspec>` (e.g. a file or a directory whose "
"name is \"abc\" exists), Git would usually ask you to disambiguate.  Because "
"checking out a branch is so common an operation, however, `git checkout abc` "
"takes \"abc\" as a `<tree-ish>` in such a situation.  Use `git checkout -- "
"<pathspec>` if you want to checkout these paths out of the index."
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:518
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:523
msgid ""
"The following sequence checks out the `master` branch, reverts the "
"`Makefile` to two revisions back, deletes `hello.c` by mistake, and gets it "
"back from the index."
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:529
#, no-wrap
msgid ""
"$ git checkout master             <1>\n"
"$ git checkout master~2 Makefile  <2>\n"
"$ rm -f hello.c\n"
"$ git checkout hello.c            <3>\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:532
msgid "switch branch"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:533
msgid "take a file out of another commit"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:534
msgid "restore `hello.c` from the index"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:537
msgid "If you want to check out _all_ C source files out of the index, you can say"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:540
#, no-wrap
msgid "$ git checkout -- '*.c'\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:546
msgid ""
"Note the quotes around `*.c`.  The file `hello.c` will also be checked out, "
"even though it is no longer in the working tree, because the file globbing "
"is used to match entries in the index (not in the working tree by the "
"shell)."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:550
msgid ""
"If you have an unfortunate branch that is named `hello.c`, this step would "
"be confused as an instruction to switch to that branch.  You should instead "
"write:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:553
#, no-wrap
msgid "$ git checkout -- hello.c\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:557
msgid ""
"After working in the wrong branch, switching to the correct branch would be "
"done using:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:560
#, no-wrap
msgid "$ git checkout mytopic\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:565
msgid ""
"However, your \"wrong\" branch and correct `mytopic` branch may differ in "
"files that you have modified locally, in which case the above checkout would "
"fail like this:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:569
#, no-wrap
msgid ""
"$ git checkout mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:573
msgid ""
"You can give the `-m` flag to the command, which would try a three-way "
"merge:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:577
#, no-wrap
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:582
msgid ""
"After this three-way merge, the local modifications are _not_ registered in "
"your index file, so `git diff` would show you what changes you made since "
"the tip of the new branch."
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:585
msgid ""
"When a merge conflict happens during switching branches with the `-m` "
"option, you would see something like this:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:591
#, no-wrap
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
"ERROR: Merge conflict in frotz\n"
"fatal: merge program failed\n"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:597
msgid ""
"At this point, `git diff` shows the changes cleanly merged as in the "
"previous example, as well as the changes in the conflicted files.  Edit and "
"resolve the conflict and mark it resolved with `git add` as usual:"
msgstr ""

#. type: delimited block -
#: ../Documentation/git-checkout.txt:601
#, no-wrap
msgid ""
"$ edit frotz\n"
"$ git add frotz\n"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:604
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:607
msgid "linkgit:git-switch[1], linkgit:git-restore[1]"
msgstr ""

#. type: Title -
#: ../Documentation/git-checkout.txt:609
#, no-wrap
msgid "GIT"
msgstr ""

#. type: Plain text
#: ../Documentation/git-checkout.txt:610
msgid "Part of the linkgit:git[1] suite"
msgstr ""
