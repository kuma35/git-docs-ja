# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 04:38+0900\n"
"PO-Revision-Date: 2022-02-01 01:33+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/git-read-tree.txt:2
#, no-wrap
msgid "git-read-tree(1)"
msgstr "git-read-tree(1)"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:5
#, no-wrap
msgid "NAME"
msgstr "NAME"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:7
msgid "git-read-tree - Reads tree information into the index"
msgstr ""

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:10
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:16
#, no-wrap
msgid ""
"'git read-tree' [[-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>]\n"
"\t\t[-u [--exclude-per-directory=<gitignore>] | -i]]\n"
"\t\t[--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"
msgstr ""
"'git read-tree' [[-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>]\n"
"\t\t[-u [--exclude-per-directory=<gitignore>] | -i]]\n"
"\t\t[--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:19
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:23
msgid ""
"Reads the tree information given by <tree-ish> into the index, but does not "
"actually *update* any of the files it \"caches\". (see: linkgit:git-checkout-"
"index[1])"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:28
msgid ""
"Optionally, it can merge a tree into the index, perform a fast-forward (i.e. "
"2-way) merge, or a 3-way merge, with the `-m` flag.  When used with `-m`, "
"the `-u` flag causes it to also update the files in the work tree with the "
"result of the merge."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:31
msgid ""
"Trivial merges are done by 'git read-tree' itself.  Only conflicting paths "
"will be in unmerged state when 'git read-tree' returns."
msgstr ""

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:33
#, no-wrap
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:34
#, no-wrap
msgid "`-m`"
msgstr "`-m`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:39
msgid ""
"Perform a merge, not just a read.  The command will refuse to run if your "
"index file has unmerged entries, indicating that you have not finished "
"previous merge you started."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:40
#, no-wrap
msgid "`--reset`"
msgstr "`--reset`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:44
msgid ""
"Same as -m, except that unmerged entries are discarded instead of failing. "
"When used with `-u`, updates leading to loss of working tree changes will "
"not abort the operation."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:45
#, no-wrap
msgid "`-u`"
msgstr "`-u`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:48
msgid ""
"After a successful merge, update the files in the work tree with the result "
"of the merge."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:49
#, no-wrap
msgid "`-i`"
msgstr "`-i`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:57
msgid ""
"Usually a merge requires the index file as well as the files in the working "
"tree to be up to date with the current head commit, in order not to lose "
"local changes.  This flag disables the check with the working tree and is "
"meant to be used when creating a merge of trees that are not directly "
"related to the current working tree status into a temporary index file."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:58
#, no-wrap
msgid "`-n`"
msgstr "`-n`"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:59
#, no-wrap
msgid "`--dry-run`"
msgstr "`--dry-run`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:62
msgid ""
"Check if the command would error out, without updating the index or the "
"files in the working tree for real."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:63
#, no-wrap
msgid "`-v`"
msgstr "`-v`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:65
msgid "Show the progress of checking files out."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:66
#, no-wrap
msgid "`--trivial`"
msgstr "`--trivial`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:71
msgid ""
"Restrict three-way merge by 'git read-tree' to happen only if there is no "
"file-level merging required, instead of resolving merge for trivial cases "
"and leaving conflicting files unresolved in the index."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:72
#, no-wrap
msgid "`--aggressive`"
msgstr "`--aggressive`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:78
msgid ""
"Usually a three-way merge by 'git read-tree' resolves the merge for really "
"trivial cases and leaves other cases unresolved in the index, so that "
"porcelains can implement different merge policies.  This flag makes the "
"command resolve a few more cases internally:"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:81
msgid ""
"when one side removes a path and the other side leaves the path unmodified.  "
"The resolution is to remove that path."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:82
msgid "when both sides remove a path.  The resolution is to remove that path."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:84
msgid ""
"when both sides add a path identically.  The resolution is to add that path."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:85
#, no-wrap
msgid "`--prefix=<prefix>`"
msgstr "`--prefix=<prefix>`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:90
msgid ""
"Keep the current index contents, and read the contents of the named tree-ish "
"under the directory at `<prefix>`.  The command will refuse to overwrite "
"entries that already existed in the original index file."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:91
#, no-wrap
msgid "`--exclude-per-directory=<gitignore>`"
msgstr "`--exclude-per-directory=<gitignore>`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:105
msgid ""
"When running the command with `-u` and `-m` options, the merge result may "
"need to overwrite paths that are not tracked in the current branch.  The "
"command usually refuses to proceed with the merge to avoid losing such a "
"path.  However this safety valve sometimes gets in the way.  For example, it "
"often happens that the other branch added a file that used to be a generated "
"file in your branch, and the safety valve triggers when you try to switch to "
"that branch after you ran `make` but before running `make clean` to remove "
"the generated file.  This option tells the command to read per-directory "
"exclude file (usually '.gitignore') and allows such an untracked but "
"explicitly ignored file to be overwritten."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:106
#, no-wrap
msgid "`--index-output=<file>`"
msgstr "`--index-output=<file>`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:117
msgid ""
"Instead of writing the results out to `$GIT_INDEX_FILE`, write the resulting "
"index in the named file.  While the command is operating, the original index "
"file is locked with the same mechanism as usual.  The file must allow to be "
"rename(2)ed into from a temporary file that is created next to the usual "
"index file; typically this means it needs to be on the same filesystem as "
"the index file itself, and you need write permission to the directories the "
"index file and index output file are located in."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:118
#, no-wrap
msgid "`--[no-]recurse-submodules`"
msgstr "`--[no-]recurse-submodules`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:123
msgid ""
"Using --recurse-submodules will update the content of all active submodules "
"according to the commit recorded in the superproject by calling read-tree "
"recursively, also setting the submodules' HEAD to be detached at that commit."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:124
#, no-wrap
msgid "`--no-sparse-checkout`"
msgstr "`--no-sparse-checkout`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:127
msgid "Disable sparse checkout support even if `core.sparseCheckout` is true."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:128
#, no-wrap
msgid "`--empty`"
msgstr "`--empty`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:131
msgid "Instead of reading tree object(s) into the index, just empty it."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:132
#, no-wrap
msgid "`-q`"
msgstr "`-q`"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:133
#, no-wrap
msgid "`--quiet`"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:135
msgid "Quiet, suppress feedback messages."
msgstr ""

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:136
#, no-wrap
msgid "<tree-ish#>"
msgstr "<tree-ish#>"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:138
msgid "The id of the tree object(s) to be read/merged."
msgstr ""

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:141
#, no-wrap
msgid "MERGING"
msgstr "MERGING"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:146
msgid ""
"If `-m` is specified, 'git read-tree' can perform 3 kinds of merge, a single "
"tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a "
"3-way merge if 3 or more trees are provided."
msgstr ""

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:149
#, no-wrap
msgid "Single Tree Merge"
msgstr "Single Tree Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:155
msgid ""
"If only 1 tree is specified, 'git read-tree' operates as if the user did not "
"specify `-m`, except that if the original index has an entry for a given "
"pathname, and the contents of the path match with the tree being read, the "
"stat info from the index is used. (In other words, the index's stat()s take "
"precedence over the merged tree's)."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:159
msgid ""
"That means that if you do a `git read-tree -m <newtree>` followed by a `git "
"checkout-index -f -u -a`, the 'git checkout-index' only checks out the stuff "
"that really changed."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:162
msgid ""
"This is used to avoid unnecessary false hits when 'git diff-files' is run "
"after 'git read-tree'."
msgstr ""

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:165
#, no-wrap
msgid "Two Tree Merge"
msgstr "Two Tree Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:171
msgid ""
"Typically, this is invoked as `git read-tree -m $H $M`, where $H is the head "
"commit of the current repository, and $M is the head of a foreign tree, "
"which is simply ahead of $H (i.e. we are in a fast-forward situation)."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:174
msgid ""
"When two trees are specified, the user is telling 'git read-tree' the "
"following:"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:176
msgid "The current index and work tree is derived from $H, but"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:177
msgid "the user may have local changes in them since $H."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:179
msgid "The user wants to fast-forward to $M."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:185
msgid ""
"In this case, the `git read-tree -m $H $M` command makes sure that no local "
"change is lost as the result of this \"merge\".  Here are the \"carry forward"
"\" rules, where \"I\" denotes the index, \"clean\" means that index and work "
"tree coincide, and \"exists\"/\"nothing\" refer to the presence of a path in "
"the specified commit:"
msgstr ""

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:196
#, no-wrap
msgid ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"
msgstr ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:201
#, no-wrap
msgid ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"
msgstr ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:206
#, no-wrap
msgid ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"
msgstr ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:211
#, no-wrap
msgid ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"
msgstr ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:216
#, no-wrap
msgid ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"
msgstr ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:225
#, no-wrap
msgid ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"
msgstr ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:231
msgid ""
"In all \"keep index\" cases, the index entry stays as in the original index "
"file.  If the entry is not up to date, 'git read-tree' keeps the copy in the "
"work tree intact when operating under the -u flag."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:242
msgid ""
"When this form of 'git read-tree' returns successfully, you can see which of "
"the \"local changes\" that you made were carried forward by running `git "
"diff-index --cached $M`.  Note that this does not necessarily match what "
"`git diff-index --cached $H` would have produced before such a two tree "
"merge.  This is because of cases 18 and 19 --- if you already had the "
"changes in $M (e.g. maybe you picked it up via e-mail in a patch form), `git "
"diff-index --cached $H` would have told you about the change before this "
"merge, but it would not show in `git diff-index --cached $M` output after "
"the two-tree merge."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:249
msgid ""
"Case 3 is slightly tricky and needs explanation.  The result from this rule "
"logically should be to remove the path if the user staged the removal of the "
"path and then switching to a new branch.  That however will prevent the "
"initial checkout from happening, so the rule is modified to use M (new tree) "
"only when the content of the index is empty.  Otherwise the removal of the "
"path is kept as long as $H and $M are the same."
msgstr ""

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:251
#, no-wrap
msgid "3-Way Merge"
msgstr "3-Way Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:254
msgid ""
"Each \"index\" entry has two bits worth of \"stage\" state. stage 0 is the "
"normal one, and is the only one you'd see in any kind of normal use."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:257
msgid ""
"However, when you do 'git read-tree' with three trees, the \"stage\" starts "
"out at 1."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:259
msgid "This means that you can do"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:262
#, no-wrap
msgid "$ git read-tree -m <tree1> <tree2> <tree3>\n"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:270
msgid ""
"and you will end up with an index with all of the <tree1> entries in "
"\"stage1\", all of the <tree2> entries in \"stage2\" and all of the <tree3> "
"entries in \"stage3\".  When performing a merge of another branch into the "
"current branch, we use the common ancestor tree as <tree1>, the current "
"branch head as <tree2>, and the other branch head as <tree3>."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:274
msgid ""
"Furthermore, 'git read-tree' has special-case logic that says: if you see a "
"file that matches in all respects in the following states, it \"collapses\" "
"back to \"stage0\":"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:278
msgid ""
"stage 2 and 3 are the same; take one or the other (it makes no difference - "
"the same work has been done on our branch in stage 2 and their branch in "
"stage 3)"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:283
msgid ""
"stage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our "
"branch in stage 2 did not do anything since the ancestor in stage 1 while "
"their branch in stage 3 worked on it)"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:286
msgid ""
"stage 1 and stage 3 are the same and stage 2 is different take stage 2 (we "
"did something while they did nothing)"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:290
msgid ""
"The 'git write-tree' command refuses to write a nonsensical tree, and it "
"will complain about unmerged entries if it sees a single entry that is not "
"stage 0."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:296
msgid ""
"OK, this all sounds like a collection of totally nonsensical rules, but it's "
"actually exactly what you want in order to do a fast merge. The different "
"stages represent the \"result tree\" (stage 0, aka \"merged\"), the original "
"tree (stage 1, aka \"orig\"), and the two trees you are trying to merge "
"(stage 2 and 3 respectively)."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:301
msgid ""
"The order of stages 1, 2 and 3 (hence the order of three <tree-ish> command-"
"line arguments) are significant when you start a 3-way merge with an index "
"file that is already populated.  Here is an outline of how the algorithm "
"works:"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:304
msgid ""
"if a file exists in identical format in all three trees, it will "
"automatically collapse to \"merged\" state by 'git read-tree'."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:309
msgid ""
"a file that has _any_ difference what-so-ever in the three trees will stay "
"as separate entries in the index. It's up to \"porcelain policy\" to "
"determine how to remove the non-0 stages, and insert a merged version."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:314
msgid ""
"the index file saves and restores with all this information, so you can "
"merge things incrementally, but as long as it has entries in stages 1/2/3 (i."
"e., \"unmerged entries\") you can't write the result. So now the merge "
"algorithm ends up being really simple:"
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:317
msgid ""
"you walk the index in order, and ignore all entries of stage 0, since "
"they've already been done."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:321
msgid ""
"if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know "
"it's been removed from both trees (it only existed in the original tree), "
"and you remove that entry."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:326
msgid ""
"if you find a matching \"stage2\" and \"stage3\" tree, you remove one of "
"them, and turn the other into a \"stage0\" entry. Remove any matching "
"\"stage1\" entry if it exists too.  .. all the normal trivial rules .."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:331
msgid ""
"You would normally use 'git merge-index' with supplied 'git merge-one-file' "
"to do this last step.  The script updates the files in the working tree as "
"it merges each path and at the end of a successful merge."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:339
msgid ""
"When you start a 3-way merge with an index file that is already populated, "
"it is assumed that it represents the state of the files in your work tree, "
"and you can even have files with changes unrecorded in the index file.  It "
"is further assumed that this state is \"derived\" from the stage 2 tree.  "
"The 3-way merge refuses to run if it finds an entry in the original index "
"file that does not match stage 2."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:344
msgid ""
"This is done to prevent you from losing your work-in-progress changes, and "
"mixing your random changes in an unrelated merge commit.  To illustrate, "
"suppose you start from what has been committed last to your repository:"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:348
#, no-wrap
msgid ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"
msgstr ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:353
msgid ""
"You do random edits, without running 'git update-index'.  And then you "
"notice that the tip of your \"upstream\" tree has advanced since you pulled "
"from him:"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:357
#, no-wrap
msgid ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"
msgstr ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:363
msgid ""
"Your work tree is still based on your HEAD ($JC), but you have some edits "
"since.  Three-way merge makes sure that you have not added or modified index "
"entries since $JC, and if you haven't, then does the right thing.  So with "
"the following sequence:"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:369
#, no-wrap
msgid ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"
msgstr ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:374
msgid ""
"what you would commit is a pure merge between $JC and $LT without your work-"
"in-progress changes, and your work tree would be updated to the result of "
"the merge."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:378
msgid ""
"However, if you have local changes in the working tree that would be "
"overwritten by this merge, 'git read-tree' will refuse to run to prevent "
"your changes from being lost."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:388
msgid ""
"In other words, there is no need to worry about what exists only in the "
"working tree.  When you have local changes in a part of the project that is "
"not involved in the merge, your changes do not interfere with the merge, and "
"are kept intact.  When they *do* interfere, the merge does not even start "
"('git read-tree' complains loudly and fails without modifying anything).  In "
"such a case, you can simply continue doing what you were in the middle of "
"doing, and when your working tree is ready (i.e. you have finished your work-"
"in-progress), attempt the merge again."
msgstr ""

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:391
#, no-wrap
msgid "SPARSE CHECKOUT"
msgstr "SPARSE CHECKOUT"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:396
msgid ""
"\"Sparse checkout\" allows populating the working directory sparsely.  It "
"uses the skip-worktree bit (see linkgit:git-update-index[1]) to tell Git "
"whether a file in the working directory is worth looking at."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:405
msgid ""
"'git read-tree' and other merge-based commands ('git merge', 'git "
"checkout'...) can help maintaining the skip-worktree bitmap and working "
"directory update. `$GIT_DIR/info/sparse-checkout` is used to define the skip-"
"worktree reference bitmap. When 'git read-tree' needs to update the working "
"directory, it resets the skip-worktree bit in the index based on this file, "
"which uses the same syntax as .gitignore files.  If an entry matches a "
"pattern in this file, skip-worktree will not be set on that entry. "
"Otherwise, skip-worktree will be set."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:409
msgid ""
"Then it compares the new skip-worktree value with the previous one. If skip-"
"worktree turns from set to unset, it will add the corresponding file back. "
"If it turns from unset to set, that file will be removed."
msgstr ""

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:413
msgid ""
"While `$GIT_DIR/info/sparse-checkout` is usually used to specify what files "
"are in, you can also specify what files are _not_ in, using negate patterns. "
"For example, to remove the file `unwanted`:"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:417
#, no-wrap
msgid ""
"/*\n"
"!unwanted\n"
msgstr ""
"/*\n"
"!unwanted\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:425
msgid ""
"Another tricky thing is fully repopulating the working directory when you no "
"longer want sparse checkout. You cannot just disable \"sparse checkout\" "
"because skip-worktree bits are still in the index and your working directory "
"is still sparsely populated. You should re-populate the working directory "
"with the `$GIT_DIR/info/sparse-checkout` file content as follows:"
msgstr ""

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:428
#, no-wrap
msgid "/*\n"
msgstr "/*\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:434
msgid ""
"Then you can disable sparse checkout. Sparse checkout support in 'git read-"
"tree' and similar commands is disabled by default. You need to turn `core."
"sparseCheckout` on in order to have sparse checkout support."
msgstr ""

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:437
#, no-wrap
msgid "SEE ALSO"
msgstr "SEE ALSO"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:440
msgid ""
"linkgit:git-write-tree[1]; linkgit:git-ls-files[1]; linkgit:gitignore[5]; "
"linkgit:git-sparse-checkout[1];"
msgstr "linkgit:git-write-tree[1]; linkgit:git-ls-files[1]; linkgit:gitignore[5]; linkgit:git-sparse-checkout[1];"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:442
#, no-wrap
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:443
msgid "Part of the linkgit:git[1] suite"
msgstr "Part of the linkgit:git[1] suite"
