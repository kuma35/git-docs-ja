# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 3.0\n"
"POT-Creation-Date: 2023-07-18 11:05+0900\n"
"PO-Revision-Date: 2024-01-22 08:16+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/git-read-tree.txt:2
#, no-wrap
msgid "git-read-tree(1)"
msgstr "git-read-tree(1)"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:5
#, no-wrap
msgid "NAME"
msgstr "NAME"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:7
msgid "git-read-tree - Reads tree information into the index"
msgstr "git-read-tree - ツリー情報をインデックスに読み込みます"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:10
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:15
#, no-wrap
msgid ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)\n"
"\t\t[-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"
msgstr ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)\n"
"\t\t[-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:18
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:22
msgid ""
"Reads the tree information given by <tree-ish> into the index, but does not "
"actually *update* any of the files it \"caches\". (see: linkgit:git-checkout-"
"index[1])"
msgstr ""
"<tree-ish> によって指定されたツリー情報をインデックスに読み込みますが、"
"「キャッシュする」ファイルは実際には「更新」されません。 (linkgit:git-"
"checkout-index[1] 参照)"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:27
msgid ""
"Optionally, it can merge a tree into the index, perform a fast-forward (i.e. "
"2-way) merge, or a 3-way merge, with the `-m` flag.  When used with `-m`, "
"the `-u` flag causes it to also update the files in the work tree with the "
"result of the merge."
msgstr ""
"オプションで、ツリーをインデックスにマージしたり、早送り(fast-forward)(つま"
"り、2方向)マージを実行したり、 `-m` フラグを使用して3方向マージを実行したりで"
"きます。 `-u` フラグを `-m` と一緒に使用すると、マージの結果で作業ツリー内の"
"ファイルも更新されます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:30
msgid ""
"Trivial merges are done by 'git read-tree' itself.  Only conflicting paths "
"will be in unmerged state when 'git read-tree' returns."
msgstr ""
"trivial(些細な)マージは、 `git read-tree` 自体によって行われます。 `git read-"
"tree` から戻ると、競合するパスのみがマージされていない状態になります。"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:32
#, no-wrap
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:33
#, no-wrap
msgid "`-m`"
msgstr "`-m`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:38
msgid ""
"Perform a merge, not just a read.  The command will refuse to run if your "
"index file has unmerged entries, indicating that you have not finished "
"previous merge you started."
msgstr ""
"読み取りだけでなく、マージを実行します。インデックスファイルにマージされてい"
"ないエントリがある場合、コマンドは実行を拒否します。これは、以前に開始した"
"マージが完了していないことを示します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:39
#, no-wrap
msgid "`--reset`"
msgstr "`--reset`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:44
msgid ""
"Same as -m, except that unmerged entries are discarded instead of failing.  "
"When used with `-u`, updates leading to loss of working tree changes or "
"untracked files or directories will not abort the operation."
msgstr ""
"`-m` と同じですが、マージされていないエントリが失敗する代わりに破棄される点が"
"異なります。 `-u` と一緒に使うと、作業ツリーの変更が失われる原因になる更新に"
"よって、または、追跡されていないファイルやディレクトリが失われる原因になる更"
"新によって、操作を中止(abort)されることはありません。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:45
#, no-wrap
msgid "`-u`"
msgstr "`-u`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:48
msgid ""
"After a successful merge, update the files in the work tree with the result "
"of the merge."
msgstr "マージが成功したら、マージの結果で作業ツリーのファイルを更新します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:49
#, no-wrap
msgid "`-i`"
msgstr "`-i`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:57
msgid ""
"Usually a merge requires the index file as well as the files in the working "
"tree to be up to date with the current head commit, in order not to lose "
"local changes.  This flag disables the check with the working tree and is "
"meant to be used when creating a merge of trees that are not directly "
"related to the current working tree status into a temporary index file."
msgstr ""
"通常、マージでは、ローカルの変更が失われないように、インデックスファイルと作"
"業ツリー内のファイルが現在のヘッドコミットで最新である必要があります。 このフ"
"ラグは、作業ツリーでのチェックを無効にし、現在の作業ツリーのステータスに直接"
"関係しないツリーを一時的なインデックスファイルにマージするときに使用すること"
"を目的としています。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:58
#, no-wrap
msgid "`-n`"
msgstr "`-n`"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:59
#, no-wrap
msgid "`--dry-run`"
msgstr "`--dry-run`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:62
msgid ""
"Check if the command would error out, without updating the index or the "
"files in the working tree for real."
msgstr ""
"作業ツリー内のインデックスまたはファイルを実際に更新せずに、コマンドがエラー"
"になるかどうかを確認します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:63
#, no-wrap
msgid "`-v`"
msgstr "`-v`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:65
msgid "Show the progress of checking files out."
msgstr "ファイルのチェックアウトの進行状況を表示します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:66
#, no-wrap
msgid "`--trivial`"
msgstr "`--trivial`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:71
msgid ""
"Restrict three-way merge by 'git read-tree' to happen only if there is no "
"file-level merging required, instead of resolving merge for trivial cases "
"and leaving conflicting files unresolved in the index."
msgstr ""
"trivial(些細な)ケースでマージ解決作業し、競合するファイルをインデックスに未解"
"決のままにする代わりに、 `git read-tree` による3方向マージを、ファイルレベル"
"のマージが必要ない場合にのみ発生するように制限します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:72
#, no-wrap
msgid "`--aggressive`"
msgstr "`--aggressive`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:78
msgid ""
"Usually a three-way merge by 'git read-tree' resolves the merge for really "
"trivial cases and leaves other cases unresolved in the index, so that "
"porcelains can implement different merge policies.  This flag makes the "
"command resolve a few more cases internally:"
msgstr ""
"通常、 `git read-tree` による3方向のマージは、本当にtrivial(些細な)ケースの"
"マージを解決し、他のケースはインデックスに未解決のままにして、磁器コマンドが"
"さまざまなマージポリシーを実装できるようにします。このフラグにより、コマンド"
"はさらにいくつかのケースを内部的に解決します:"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:81
msgid ""
"when one side removes a path and the other side leaves the path unmodified.  "
"The resolution is to remove that path."
msgstr ""
"一方の側がパスを削除し、もう一方の側がパスを変更しないままにする場合。 解決策"
"は、そのパスを削除することです。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:82
msgid "when both sides remove a path.  The resolution is to remove that path."
msgstr "両側でパスを削除したとき。 解決策は、そのパスを削除することです。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:84
msgid ""
"when both sides add a path identically.  The resolution is to add that path."
msgstr ""
"両側で同じようにパスを追加する場合。 解決策は、そのパスを追加することです。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:85
#, no-wrap
msgid "`--prefix=<prefix>`"
msgstr "`--prefix=<prefix>`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:90
msgid ""
"Keep the current index contents, and read the contents of the named tree-ish "
"under the directory at `<prefix>`.  The command will refuse to overwrite "
"entries that already existed in the original index file."
msgstr ""
"現在のインデックスの内容を保持し、 `<prefix>` のディレクトリの下にある名前付"
"きtree-ishの内容を読み取ります。このコマンドは、元のインデックスファイルにす"
"でに存在しているエントリの上書きを拒否します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:91
#, no-wrap
msgid "`--index-output=<file>`"
msgstr "`--index-output=<file>`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:102
msgid ""
"Instead of writing the results out to `$GIT_INDEX_FILE`, write the resulting "
"index in the named file.  While the command is operating, the original index "
"file is locked with the same mechanism as usual.  The file must allow to be "
"rename(2)ed into from a temporary file that is created next to the usual "
"index file; typically this means it needs to be on the same filesystem as "
"the index file itself, and you need write permission to the directories the "
"index file and index output file are located in."
msgstr ""
"結果を `$GIT_INDEX_FILE` に書き出す代わりに、結果のインデックスを名前付きファ"
"イルに書き込みます。コマンドの動作中は、元のインデックスファイルが通常と同じ"
"メカニズムでロックされます。ファイルは、通常のインデックスファイルの隣に作成"
"される一時ファイルから名前を変更できるようにする必要があります(rename(2))。通"
"常、これは、インデックスファイル自体と同じファイルシステム上にある必要があ"
"り、インデックスファイルとインデックス出力ファイルが配置されているディレクト"
"リへの書き込み権限が必要であることを意味します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:103
#, no-wrap
msgid "`--[no-]recurse-submodules`"
msgstr "`--[no-]recurse-submodules`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:108
msgid ""
"Using --recurse-submodules will update the content of all active submodules "
"according to the commit recorded in the superproject by calling read-tree "
"recursively, also setting the submodules' HEAD to be detached at that commit."
msgstr ""
"`--recurse-submodules` を使用すると、スーパープロジェクトに記録されたコミット"
"に従ってすべてのアクティブなサブモジュールのコンテンツが更新され、read-treeが"
"再帰的に呼び出され、そのコミット時にサブモジュールのHEADが切り離される"
"(detach)ように設定されます。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:109
#, no-wrap
msgid "`--no-sparse-checkout`"
msgstr "`--no-sparse-checkout`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:112
msgid "Disable sparse checkout support even if `core.sparseCheckout` is true."
msgstr ""
"`core.sparseCheckout`がtrueの場合でも、スパースチェックアウト(sparse "
"checkout)のサポートを無効にします。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:113
#, no-wrap
msgid "`--empty`"
msgstr "`--empty`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:116
msgid "Instead of reading tree object(s) into the index, just empty it."
msgstr "ツリーオブジェクトをインデックスに読み込む代わりに、空にします。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:117
#, no-wrap
msgid "`-q`"
msgstr "`-q`"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:118
#, no-wrap
msgid "`--quiet`"
msgstr "`--quiet`"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:120
msgid "Quiet, suppress feedback messages."
msgstr "静かにし、フィードバックメッセージを抑制します。"

#. type: Labeled list
#: ../Documentation-sedout/git-read-tree.txt:121
#, no-wrap
msgid "<tree-ish#>"
msgstr "<tree-ish#>"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:123
msgid "The id of the tree object(s) to be read/merged."
msgstr "読み取られる/マージされる ツリーオブジェクトのID。"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:126
#, no-wrap
msgid "MERGING"
msgstr "MERGING"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:131
msgid ""
"If `-m` is specified, 'git read-tree' can perform 3 kinds of merge, a single "
"tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a "
"3-way merge if 3 or more trees are provided."
msgstr ""
"`-m` が指定されている場合、 `git read-tree` は3種類のマージを提供します。1つ"
"のツリーのみが指定されている場合は単一のツリーマージ(single tree merge)、2つ"
"のツリーとの早送り(fast-forward)マージ(two tree merge)、3つ以上のツリーが指定"
"されている3方向マージです(3-way merge)。"

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:134
#, no-wrap
msgid "Single Tree Merge"
msgstr "Single Tree Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:140
msgid ""
"If only 1 tree is specified, 'git read-tree' operates as if the user did not "
"specify `-m`, except that if the original index has an entry for a given "
"pathname, and the contents of the path match with the tree being read, the "
"stat info from the index is used. (In other words, the index's stat()s take "
"precedence over the merged tree's)."
msgstr ""
"ツリーが 1 つだけ指定されている場合、 `git read-tree` はユーザーが `-m` を指"
"定しなかったかのように動作しますが、 元のインデックスに特定のパス名のエントリ"
"があり、パスの内容が読み取られるツリーと一致する場合、インデックスの統計情報"
"が使用されます。(言い換えれば、インデックスの stat() はマージされたツリーのも"
"のよりも優先されます)。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:144
msgid ""
"That means that if you do a `git read-tree -m <newtree>` followed by a `git "
"checkout-index -f -u -a`, the 'git checkout-index' only checks out the stuff "
"that really changed."
msgstr ""
"つまり、 `git read-tree -m <newtree>` の後に `git checkout-index -f -u -a` を"
"実行すると、 `git checkout-index` は本当に変更されたものだけをチェックアウト"
"します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:147
msgid ""
"This is used to avoid unnecessary false hits when 'git diff-files' is run "
"after 'git read-tree'."
msgstr ""
"これは、 `git read-tree` の後に `git diff-files` を実行したときに不要な誤検出"
"を避けるために使用します。"

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:150
#, no-wrap
msgid "Two Tree Merge"
msgstr "Two Tree Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:156
msgid ""
"Typically, this is invoked as `git read-tree -m $H $M`, where $H is the head "
"commit of the current repository, and $M is the head of a foreign tree, "
"which is simply ahead of $H (i.e. we are in a fast-forward situation)."
msgstr ""
"通常、これは `git read-tree -m $H $M` として呼び出されます。ここで、$H は現在"
"のリポジトリのヘッドコミットであり、$M は $H の前にある外部ツリーのヘッドです"
"(つまり、早送り(fast-forward)の状況にあります)。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:159
msgid ""
"When two trees are specified, the user is telling 'git read-tree' the "
"following:"
msgstr ""
"2つのツリーが指定されている場合、ユーザーは `git read-tree` に以下のように指"
"示している事になります:"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:161
msgid "The current index and work tree is derived from $H, but"
msgstr "現在のインデックスと作業ツリーは$Hから派生していますが、"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:162
msgid "the user may have local changes in them since $H."
msgstr "ユーザーは$H以降にローカルで変更を加えている可能性があります。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:164
msgid "The user wants to fast-forward to $M."
msgstr "ユーザーは$Mに早送り(fast-forward)したいと考えています。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:170
msgid ""
"In this case, the `git read-tree -m $H $M` command makes sure that no local "
"change is lost as the result of this \"merge\".  Here are the \"carry "
"forward\" rules, where \"I\" denotes the index, \"clean\" means that index "
"and work tree coincide, and \"exists\"/\"nothing\" refer to the presence of "
"a path in the specified commit:"
msgstr ""
"この場合、 `git read-tree -m $H $M` コマンドは、この「マージ」の結果として"
"ローカルの変更が失われないことを確認します。 「繰越」(carry forward)ルールは"
"次のとおりです。「I」はインデックスを示し、「clean」はインデックスと作業ツ"
"リーが一致することを意味し、「exists」/「nothing」 は指定されたコミットにパス"
"が存在することを示します:"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:181
#, no-wrap
msgid ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"
msgstr ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:186
#, no-wrap
msgid ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"
msgstr ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:191
#, no-wrap
msgid ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"
msgstr ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:196
#, no-wrap
msgid ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"
msgstr ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:201
#, no-wrap
msgid ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"
msgstr ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"

#. type: delimited block .
#: ../Documentation-sedout/git-read-tree.txt:210
#, no-wrap
msgid ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"
msgstr ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:216
msgid ""
"In all \"keep index\" cases, the index entry stays as in the original index "
"file.  If the entry is not up to date, 'git read-tree' keeps the copy in the "
"work tree intact when operating under the -u flag."
msgstr ""
"すべての「インデックスを保持する」場合、インデックスエントリは元のインデック"
"スファイルと同じままです。 エントリが最新でない場合、 `git read-tree` は `-"
"u` フラグの下で動作しているときに作業ツリー内のコピーをそのまま保持します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:227
msgid ""
"When this form of 'git read-tree' returns successfully, you can see which of "
"the \"local changes\" that you made were carried forward by running `git "
"diff-index --cached $M`.  Note that this does not necessarily match what "
"`git diff-index --cached $H` would have produced before such a two tree "
"merge.  This is because of cases 18 and 19 -- if you already had the changes "
"in $M (e.g. maybe you picked it up via e-mail in a patch form), `git diff-"
"index --cached $H` would have told you about the change before this merge, "
"but it would not show in `git diff-index --cached $M` output after the two-"
"tree merge."
msgstr ""
"この形式の `git read-tree` から正常に返ると、 `git diff-index --cached $M` を"
"実行することで、行った「ローカル変更」のどれが繰り越されたかを確認できます。 "
"これは、このような2つのツリーがマージされる前に `git diff-index --cached $H` "
"が生成したものと必ずしも一致しないことに注意してください。 これは、上記ケース"
"18と19が原因です -- すでに$Mに変更があった場合(たとえば、パッチ形式で電子メー"
"ルで取得した場合)、 `git diff-index --cached $H` は、このマージの前に変更につ"
"いて通知しますが、 2ツリーのマージ後の `git diff-index --cached $M` 出力には"
"表示されません。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:234
msgid ""
"Case 3 is slightly tricky and needs explanation.  The result from this rule "
"logically should be to remove the path if the user staged the removal of the "
"path and then switching to a new branch.  That however will prevent the "
"initial checkout from happening, so the rule is modified to use M (new tree) "
"only when the content of the index is empty.  Otherwise the removal of the "
"path is kept as long as $H and $M are the same."
msgstr ""
"上記ケース3は少しトリッキーで、説明が必要です。 このルールの結果は、論理的に"
"は、ユーザーがパスの削除をステージングしてから新しいブランチに切り替えた場合"
"に、パスを削除することです。 ただし、これにより最初のチェックアウトが行われな"
"いため、インデックスの内容が空の場合にのみM(新しいツリー)を使用するようにルー"
"ルが変更されます。 それ以外の場合、パスの削除は、$Hと$Mが同じである限り保持さ"
"れます。"

#. type: Title ~
#: ../Documentation-sedout/git-read-tree.txt:236
#, no-wrap
msgid "3-Way Merge"
msgstr "3-Way Merge"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:239
msgid ""
"Each \"index\" entry has two bits worth of \"stage\" state. stage 0 is the "
"normal one, and is the only one you'd see in any kind of normal use."
msgstr ""
"各「インデックス」エントリには、2ビット相当の「ステージ」状態があります。ス"
"テージ0は通常のステージであり、通常の使用で見られる唯一のステージです。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:242
msgid ""
"However, when you do 'git read-tree' with three trees, the \"stage\" starts "
"out at 1."
msgstr ""
"しかしながら、あなたが3つのツリーで `git read-tree` を実行すると、「ステー"
"ジ」は1から始まります。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:244
msgid "This means that you can do"
msgstr "これはあなたが以下のようにできることを意味します"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:247
#, no-wrap
msgid "$ git read-tree -m <tree1> <tree2> <tree3>\n"
msgstr "$ git read-tree -m <tree1> <tree2> <tree3>\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:255
msgid ""
"and you will end up with an index with all of the <tree1> entries in "
"\"stage1\", all of the <tree2> entries in \"stage2\" and all of the <tree3> "
"entries in \"stage3\".  When performing a merge of another branch into the "
"current branch, we use the common ancestor tree as <tree1>, the current "
"branch head as <tree2>, and the other branch head as <tree3>."
msgstr ""
"そうすると、「stage1」にすべての<tree1>エントリ、「stage2」にすべての<tree2>"
"エントリ、「stage3」にすべての<tree3>エントリを持つインデックスが作成されま"
"す。 別のブランチを現在のブランチにマージする場合、共通の祖先ツリーを<tree1>"
"として、現在のブランチヘッドを<tree2>として、他のブランチヘッドを<tree3>とし"
"て使用します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:259
msgid ""
"Furthermore, 'git read-tree' has special-case logic that says: if you see a "
"file that matches in all respects in the following states, it \"collapses\" "
"back to \"stage0\":"
msgstr ""
"さらに、 `git read-tree` には、以下のような特殊なケースのロジックがあります。"
"以下の状態ですべての点で一致するファイルを見つけると、「折りたたみ」"
"(collapse)して `stage0` に戻します:"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:263
msgid ""
"stage 2 and 3 are the same; take one or the other (it makes no difference - "
"the same work has been done on our branch in stage 2 and their branch in "
"stage 3)"
msgstr ""
"ステージ2と3は同一です。 どちらか一方を取ります(違いはありません。ステージ2の"
"ブランチとステージ3のブランチで同じ作業が行われました)"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:268
msgid ""
"stage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our "
"branch in stage 2 did not do anything since the ancestor in stage 1 while "
"their branch in stage 3 worked on it)"
msgstr ""
"ステージ1とステージ2は同じで、ステージ3は異なります。ステージ3を取得します"
"（ステージ2のブランチは、ステージ3のブランチが作業している間、ステージ1の祖先"
"以降何もしませんでした）"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:271
msgid ""
"stage 1 and stage 3 are the same and stage 2 is different take stage 2 (we "
"did something while they did nothing)"
msgstr ""
"ステージ1とステージ3は同じで、ステージ2は異なります。ステージ2を使用します(私"
"達は何もしなかったのに何かをしました)"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:275
msgid ""
"The 'git write-tree' command refuses to write a nonsensical tree, and it "
"will complain about unmerged entries if it sees a single entry that is not "
"stage 0."
msgstr ""
"`git write-tree` コマンドは、無意味なツリーの書き込みを拒否し、ステージ0では"
"ない単一のエントリを検出すると、マージされていないエントリについて文句を言い"
"ます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:281
msgid ""
"OK, this all sounds like a collection of totally nonsensical rules, but it's "
"actually exactly what you want in order to do a fast merge. The different "
"stages represent the \"result tree\" (stage 0, aka \"merged\"), the original "
"tree (stage 1, aka \"orig\"), and the two trees you are trying to merge "
"(stage 2 and 3 respectively)."
msgstr ""
"ええ、これはすべてまったく無意味なルールのコレクションのように聞こえますが、"
"実際には、高速マージを実行するために必要なものです。 異なるステージは、「結果"
"ツリー」(result tree)(ステージ0、別名「merged」)、元のツリー(original tree)"
"(ステージ1、別名「orig」）、およびマージしようとしている2つのツリー（それぞれ"
"ステージ2と3）を表します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:286
msgid ""
"The order of stages 1, 2 and 3 (hence the order of three <tree-ish> command-"
"line arguments) are significant when you start a 3-way merge with an index "
"file that is already populated.  Here is an outline of how the algorithm "
"works:"
msgstr ""
"すでに入力されているインデックスファイルを使用して3方向マージを開始する場合、"
"ステージ1、2、および3の順序(つまり、3つの<tree-ish>コマンドライン引数の順序)"
"は重要です。アルゴリズムの仕組みの概要は以下のとおりです:"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:289
msgid ""
"if a file exists in identical format in all three trees, it will "
"automatically collapse to \"merged\" state by 'git read-tree'."
msgstr ""
"ファイルが3つのツリーすべてに同じ形式で存在する場合、ファイルは `git read-"
"tree` によって自動的に「マージされた」状態(merged state)に折りたたまれ"
"(collapse)ます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:294
msgid ""
"a file that has _any_ difference what-so-ever in the three trees will stay "
"as separate entries in the index. It's up to \"porcelain policy\" to "
"determine how to remove the non-0 stages, and insert a merged version."
msgstr ""
"3つのツリーに違いがあるファイルは、インデックス内の別々のエントリとして残りま"
"す。0以外のステージを削除し、マージされたバージョンを挿入する方法を決定するの"
"は、「磁器ポリシー」(porcelain policy)次第です。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:299
msgid ""
"the index file saves and restores with all this information, so you can "
"merge things incrementally, but as long as it has entries in stages 1/2/3 (i."
"e., \"unmerged entries\") you can't write the result. So now the merge "
"algorithm ends up being really simple:"
msgstr ""
"インデックスファイルはこれらすべての情報を保存および復元するため、段階的に"
"マージできますが、ステージ 1/2/3 のエントリ(つまり、「マージされていないエン"
"トリ」)がある限り、結果を書き込むことはできません。したがって、マージアルゴリ"
"ズムは非常に単純になります:"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:302
msgid ""
"you walk the index in order, and ignore all entries of stage 0, since "
"they've already been done."
msgstr ""
"あなたはインデックスを順番に歩きます。ステージ0のすべてのエントリはすでに完了"
"しているため、無視します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:306
msgid ""
"if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know "
"it's been removed from both trees (it only existed in the original tree), "
"and you remove that entry."
msgstr ""
"「stage1」が見つかったが、一致する「stage2」または「stage3」がない場合は、両"
"方のツリーから削除されたことがわかり(元のツリーにのみ存在した)、そのエントリ"
"を削除します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:311
msgid ""
"if you find a matching \"stage2\" and \"stage3\" tree, you remove one of "
"them, and turn the other into a \"stage0\" entry. Remove any matching "
"\"stage1\" entry if it exists too.  .. all the normal trivial rules .."
msgstr ""
"一致する「stage2」および「stage3」ツリーが見つかった場合は、それらの1つを削除"
"し、もう1つを「stage0」エントリに変換します。 一致する「stage1」エントリも存"
"在する場合は削除します。  .. すべての通常のtrivial(些細な)ルール .."

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:316
msgid ""
"You would normally use 'git merge-index' with supplied 'git merge-one-file' "
"to do this last step.  The script updates the files in the working tree as "
"it merges each path and at the end of a successful merge."
msgstr ""
"この最後のステップを実行するには、通常、提供された `git merge-one-file` とと"
"もに `git merge-index` を使用します。 スクリプトは、各パスをマージし、マージ"
"が正常に終了すると、作業ツリー内のファイルを更新します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:324
msgid ""
"When you start a 3-way merge with an index file that is already populated, "
"it is assumed that it represents the state of the files in your work tree, "
"and you can even have files with changes unrecorded in the index file.  It "
"is further assumed that this state is \"derived\" from the stage 2 tree.  "
"The 3-way merge refuses to run if it finds an entry in the original index "
"file that does not match stage 2."
msgstr ""
"すでに入力されているインデックスファイルを使用して3方向マージを開始すると、そ"
"れが作業ツリー内のファイルの状態を表していると見なされ、変更がインデックス"
"ファイルに記録されていないファイルを作成することもできます。 さらに、この状態"
"はステージ2ツリーから「派生」していると想定されます。 元のインデックスファイ"
"ルでステージ2と一致しないエントリが見つかった場合、3方向マージは実行を拒否し"
"ます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:329
msgid ""
"This is done to prevent you from losing your work-in-progress changes, and "
"mixing your random changes in an unrelated merge commit.  To illustrate, "
"suppose you start from what has been committed last to your repository:"
msgstr ""
"これは、進行中の変更が失われたり、無関係なマージコミットでランダムな変更が混"
"在したりするのを防ぐために行われます。ここでは説明のために、あなたのリポジト"
"リに最後にコミットされたものから開始するとします:"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:333
#, no-wrap
msgid ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"
msgstr ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:338
msgid ""
"You do random edits, without running 'git update-index'.  And then you "
"notice that the tip of your \"upstream\" tree has advanced since you pulled "
"from him:"
msgstr ""
"あなたは `git update-index` を実行せずに、ランダムに編集します。 そして、あな"
"たは彼(him)からpullしてからあなたの「上流」のツリーの先端が進んだことに気づき"
"ます:"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:342
#, no-wrap
msgid ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"
msgstr ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:348
msgid ""
"Your work tree is still based on your HEAD ($JC), but you have some edits "
"since.  Three-way merge makes sure that you have not added or modified index "
"entries since $JC, and if you haven't, then does the right thing.  So with "
"the following sequence:"
msgstr ""
"作業ツリーはまだHEAD($JC)に基づいていますが、あなたはそれ以降、いくつか編集し"
"ています。3方向マージは、 $JC 以降にインデックスエントリを追加または変更して"
"いないことを確認し、追加していない場合は、正しいことを行います。 したがって、"
"以下のシーケンス:"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:354
#, no-wrap
msgid ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"
msgstr ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:359
msgid ""
"what you would commit is a pure merge between $JC and $LT without your work-"
"in-progress changes, and your work tree would be updated to the result of "
"the merge."
msgstr ""
"これは、コミットするのは、進行中の作業を変更せずに$JCと$LTを純粋にマージする"
"ことであり、作業ツリーはマージの結果に更新されます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:363
msgid ""
"However, if you have local changes in the working tree that would be "
"overwritten by this merge, 'git read-tree' will refuse to run to prevent "
"your changes from being lost."
msgstr ""
"ただし、このマージによって上書きされる作業ツリーにローカルの変更がある場合、"
"変更が失われるのを防ぐために、 `git read-tree` は実行を拒否します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:373
msgid ""
"In other words, there is no need to worry about what exists only in the "
"working tree.  When you have local changes in a part of the project that is "
"not involved in the merge, your changes do not interfere with the merge, and "
"are kept intact.  When they *do* interfere, the merge does not even start "
"('git read-tree' complains loudly and fails without modifying anything).  In "
"such a case, you can simply continue doing what you were in the middle of "
"doing, and when your working tree is ready (i.e. you have finished your work-"
"in-progress), attempt the merge again."
msgstr ""
"つまり、作業ツリーにのみ存在するものについて心配する必要はありません。 マージ"
"に関係しないプロジェクトの一部にローカルの変更がある場合、変更はマージに干渉"
"せず、そのまま保持されます。 それらが干渉する場合、マージは開始されません"
"(`git read-tree` は大声で文句を言い、何も変更せずに失敗します)。 このような場"
"合は、実行中の作業を続行し、作業ツリーの準備ができたら(つまり、進行中の作業が"
"終了したら)、マージを再試行します。"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:376
#, no-wrap
msgid "SPARSE CHECKOUT"
msgstr "SPARSE CHECKOUT"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:385
msgid ""
"Note: The skip-worktree capabilities in linkgit:git-update-index[1] and "
"`read-tree` predated the introduction of linkgit:git-sparse-checkout[1].  "
"Users are encouraged to use the `sparse-checkout` command in preference to "
"these plumbing commands for sparse-checkout/skip-worktree related needs.  "
"However, the information below might be useful to users trying to understand "
"the pattern style used in non-cone mode of the `sparse-checkout` command."
msgstr ""
"注意: linkgit:git-update-index[1] と `read-tree` の skip-worktree 機能は、"
"linkgit:git-sparse-checkout[1] の導入以前の機能です。 ユーザーは、 sparse-"
"checkout/skip-worktree 関連の需要に対して、 これらの配管コマンドよりも優先し"
"て `sparse-checkout` コマンドを使用することをお勧めします。 ただし、以下の情"
"報は、`sparse-checkout` コマンドの非円錐(non-cone)モードで使用されるパター"
"ン・スタイルを理解しようとしているユーザーにとって役立つ場合があります。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:389
msgid ""
"\"Sparse checkout\" allows populating the working directory sparsely.  It "
"uses the skip-worktree bit (see linkgit:git-update-index[1]) to tell Git "
"whether a file in the working directory is worth looking at."
msgstr ""
"「スパースチェックアウト」(Sparse checkout)を使用すると、作業ディレクトリにま"
"ばらに(sparsely)データを入力できます。 skip-worktreeビット(linkgit:git-"
"update-index[1] 参照)を使用して、作業ディレクトリ内のファイルを確認する価値が"
"あるかどうかをGitに通知します。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:399
msgid ""
"'git read-tree' and other merge-based commands ('git merge', 'git "
"checkout'...) can help maintaining the skip-worktree bitmap and working "
"directory update. `$GIT_DIR/info/sparse-checkout` is used to define the skip-"
"worktree reference bitmap. When 'git read-tree' needs to update the working "
"directory, it resets the skip-worktree bit in the index based on this file, "
"which uses the same syntax as .gitignore files.  If an entry matches a "
"pattern in this file, or the entry corresponds to a file present in the "
"working tree, then skip-worktree will not be set on that entry. Otherwise, "
"skip-worktree will be set."
msgstr ""
"`git read-tree` およびその他のマージベースコマンド(`git merge` 、 `git "
"checkout` …)は、skip-worktreeビットマップと作業ディレクトリの更新を維持するの"
"に役立ちます。`$GIT_DIR/info/sparse-checkout` は、skip-worktree参照ビットマッ"
"プを定義するために使用されます。 `git read-tree`  が作業ディレクトリを更新す"
"る必要がある場合、このファイルに基づいてインデックスのskip-worktreeビットをリ"
"セットします。これは、 `.gitignore` ファイルと同じ構文を使用します。 エントリ"
"がこのファイルのパターンとマッチする場合、または、エントリが作業ツリーに存在"
"するファイルに対応する場合、 skip-worktree はそのエントリに設定されません。 "
"それ以外の場合は、skip-worktree が設定されます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:403
msgid ""
"Then it compares the new skip-worktree value with the previous one. If skip-"
"worktree turns from set to unset, it will add the corresponding file back. "
"If it turns from unset to set, that file will be removed."
msgstr ""
"次に、新しいskip-worktree値を前の値と比較します。 skip-worktreeがsetからunset"
"に変わると、対応するファイルが追加されます。 unsetからsetに変わると、そのファ"
"イルは削除されます。"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:407
msgid ""
"While `$GIT_DIR/info/sparse-checkout` is usually used to specify what files "
"are in, you can also specify what files are _not_ in, using negate patterns. "
"For example, to remove the file `unwanted`:"
msgstr ""
"通常、 `$GIT_DIR/info/sparse-checkout` はどのファイルが含まれているかを指定す"
"るために使用されますが、否定パターンを使用して、どのファイルが含まれていない"
"かを指定することもできます。 たとえば、ファイル `unwanted` を削除するには以下"
"のようにします:"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:411
#, no-wrap
msgid ""
"/*\n"
"!unwanted\n"
msgstr ""
"/*\n"
"!unwanted\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:419
msgid ""
"Another tricky thing is fully repopulating the working directory when you no "
"longer want sparse checkout. You cannot just disable \"sparse checkout\" "
"because skip-worktree bits are still in the index and your working directory "
"is still sparsely populated. You should re-populate the working directory "
"with the `$GIT_DIR/info/sparse-checkout` file content as follows:"
msgstr ""
"もう1つの注意が必要なのは、スパースチェックアウトが不要になったときに作業ディ"
"レクトリを完全に再設定することです。 skip-worktreeビットはまだインデックスに"
"あり、作業ディレクトリはまだまばらに(sparsely)配置されているため、「スパース"
"チェックアウト」を無効にすることはできません。 以下のように、作業ディレクトリ"
"に `$GIT_DIR/info/sparse-checkout` ファイルの内容を再入力する必要があります:"

#. type: delimited block -
#: ../Documentation-sedout/git-read-tree.txt:422
#, no-wrap
msgid "/*\n"
msgstr "/*\n"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:428
msgid ""
"Then you can disable sparse checkout. Sparse checkout support in 'git read-"
"tree' and similar commands is disabled by default. You need to turn `core."
"sparseCheckout` on in order to have sparse checkout support."
msgstr ""
"その後、スパースチェックアウトを無効にできます。 `git read-tree` および同様の"
"コマンドでのスパースチェックアウトのサポートはデフォルトで無効になっていま"
"す。 スパースチェックアウトをサポートするには、 `core.sparseCheckout` をオン"
"にする必要があります。"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:431
#, no-wrap
msgid "SEE ALSO"
msgstr "SEE ALSO"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:434
msgid ""
"linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], "
"linkgit:git-sparse-checkout[1]"
msgstr ""
"linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], "
"linkgit:git-sparse-checkout[1]"

#. type: Title -
#: ../Documentation-sedout/git-read-tree.txt:436
#, no-wrap
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: ../Documentation-sedout/git-read-tree.txt:437
msgid "Part of the linkgit:git[1] suite"
msgstr "Part of the linkgit:git[1] suite"
