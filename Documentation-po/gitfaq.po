# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 04:38+0900\n"
"PO-Revision-Date: 2021-12-02 03:44+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/gitfaq.txt:2
#, no-wrap
msgid "gitfaq(7)"
msgstr "gitfaq(7)"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:5
#, no-wrap
msgid "NAME"
msgstr "NAME"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:7
msgid "gitfaq - Frequently asked questions about using Git"
msgstr "gitfaq - Gitの使用に関するよくある質問(FAQ)"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:9
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:11
msgid "gitfaq"
msgstr "gitfaq"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:13
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:18
msgid ""
"The examples in this FAQ assume a standard POSIX shell, like `bash` or "
"`dash`, and a user, A U Thor, who has the account `author` on the hosting "
"provider `git.example.org`."
msgstr "このFAQの例では、 `bash` や `dash` などの標準のPOSIXシェルと、ホスティングプロバイダー `git.example.org` にアカウント `author` を持つユーザー A U Thor を想定しています。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:20
#, no-wrap
msgid "Configuration"
msgstr "Configuration"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:23
#, no-wrap
msgid "What should I put in `user.name`?"
msgstr "`user.name` には何を入れるべきですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:28
msgid ""
"You should put your personal name, generally a form using a given name and "
"family name.  For example, the current maintainer of Git uses \"Junio C "
"Hamano\".  This will be the name portion that is stored in every commit you "
"make."
msgstr "個人名、通常は名前とファミリーネームを使用した形式を入力する必要があります。たとえば、Gitの現在のメンテナは \"Junio C Hamano\" (濱野 純)を使用しています。 これは、コミットするたびに保存される名前の部分になります。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:31
msgid ""
"This configuration doesn't have any effect on authenticating to remote "
"services; for that, see `credential.username` in linkgit:git-config[1]."
msgstr "この構成は、リモートサービスへの認証には影響しません。 そのためには、 linkgit:git-config[1] の `credential.username` を参照してください。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:33
#, no-wrap
msgid "What does `http.postBuffer` really do?"
msgstr "`http.postBuffer` は実際には何をしますか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:39
msgid ""
"This option changes the size of the buffer that Git uses when pushing data "
"to a remote over HTTP or HTTPS.  If the data is larger than this size, "
"libcurl, which handles the HTTP support for Git, will use chunked transfer "
"encoding since it isn't known ahead of time what the size of the pushed data "
"will be."
msgstr "このオプションは、HTTPまたはHTTPSを介してデータをリモートにプッシュするときにGitが使用するバッファーのサイズを変更します。データがこのサイズより大きい場合、GitのHTTPサポートを処理するlibcurlは、プッシュされたデータのサイズが事前にわからないため、チャンク転送エンコーディングを使用します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:48
msgid ""
"Leaving this value at the default size is fine unless you know that either "
"the remote server or a proxy in the middle doesn't support HTTP/1.1 (which "
"introduced the chunked transfer encoding) or is known to be broken with "
"chunked data.  This is often (erroneously) suggested as a solution for "
"generic push problems, but since almost every server and proxy supports at "
"least HTTP/1.1, raising this value usually doesn't solve most push "
"problems.  A server or proxy that didn't correctly support HTTP/1.1 and "
"chunked transfer encoding wouldn't be that useful on the Internet today, "
"since it would break lots of traffic."
msgstr "リモートサーバーまたは中間のプロキシが、(チャンク転送エンコーディングを導入している) HTTP/1.1 をサポートしていないか、チャンクデータが壊れていることがわかっている場合を除いて、この値をデフォルトサイズのままにしておくことは問題ありません。これは一般的なプッシュ問題の解決策として、(誤って)提案されることがよくありますが、ほとんどすべてのサーバーとプロキシが少なくとも HTTP/1.1 はサポートしているため、この値を上げてもほとんどのプッシュ問題は解決されません。 HTTP/1.1 とチャンク転送エンコーディングを正しくサポートしていなかったサーバーまたはプロキシは、大量のトラフィックを遮断するため、今日のインターネットでは無用の長物です。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:53
msgid ""
"Note that increasing this value will increase the memory used on every "
"relevant push that Git does over HTTP or HTTPS, since the entire buffer is "
"allocated regardless of whether or not it is all used.  Thus, it's best to "
"leave it at the default unless you are sure you need a different value."
msgstr "注意: この値を増やすと、GitがHTTPまたはHTTPSを介して行うすべての関連プッシュで使用されるメモリが増えることに注意してください。これは、すべてが使用されているかどうかに関係なく、バッファ全体が割り当てられるためです。したがって、別の値が必要であることが確実でない限り、デフォルトのままにしておくことをお勧めします。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:55
#, no-wrap
msgid "How do I configure a different editor?"
msgstr "別のエディタを構成するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:61
msgid ""
"If you haven't specified an editor specifically for Git, it will by default "
"use the editor you've configured using the `VISUAL` or `EDITOR` environment "
"variables, or if neither is specified, the system default (which is usually "
"`vi`).  Since some people find `vi` difficult to use or prefer a different "
"editor, it may be desirable to change the editor used."
msgstr "Git専用のエディターを指定していない場合は、デフォルトで、「VISUAL」または「EDITOR」環境変数を使用して構成したエディターが使用されます。どちらも指定されていない場合は、システムのデフォルト(通常は「vi」)が使用されます。 `vi` は使いにくい、または別のエディターを好む人もいるため、使用するエディターを変更することが望ましい場合があります。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:67
msgid ""
"If you want to configure a general editor for most programs which need one, "
"you can edit your shell configuration (e.g., `~/.bashrc` or `~/.zshenv`) to "
"contain a line setting the `EDITOR` or `VISUAL` environment variable to an "
"appropriate value.  For example, if you prefer the editor `nano`, then you "
"could write the following:"
msgstr "エディタを必要とするプログラム用に、あなたがエディタを構成したい場合、シェル構成(つまり、 `~/.bashrc` とか `~/.zshenv`)を編集して、 `EDITOR` または `VISUAL` 環境変数に適切な値に設定する行を含めることができます。たとえば、エディタ `nano` が必要な場合は、以下のように記述できます:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:70
#, no-wrap
msgid "export VISUAL=nano\n"
msgstr "export VISUAL=nano\n"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:76
msgid ""
"If you want to configure an editor specifically for Git, you can either set "
"the `core.editor` configuration value or the `GIT_EDITOR` environment "
"variable.  You can see linkgit:git-var[1] for details on the order in which "
"these options are consulted."
msgstr "あなたがGit専用のエディタを構成したい場合は、 `core.editor` 構成 または `GIT_EDITOR` 環境変数を設定できます。これらのオプションが参照される順序の詳細については linkgit:git-var[1] を参照してください。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:85
msgid ""
"Note that in all cases, the editor value will be passed to the shell, so any "
"arguments containing spaces should be appropriately quoted.  Additionally, "
"if your editor normally detaches from the terminal when invoked, you should "
"specify it with an argument that makes it not do that, or else Git will not "
"see any changes.  An example of a configuration addressing both of these "
"issues on Windows would be the configuration `\"C:\\Program Files\\Vim\\gvim."
"exe\" --nofork`, which quotes the filename with spaces and specifies the `--"
"nofork` option to avoid backgrounding the process."
msgstr "注意: いずれの場合も、エディタの値はシェルに渡されるため、スペースを含む引数は適切に引用符で囲む必要があることに注意してください。さらに、エディタが呼び出されたとき、通常ターミナルからデタッチするタイプのエディタ場合は、それを行わないようにする引数を指定して指定する必要があります。そうしないと、Gitはエディタでの変更を認識しません。 Windowsでこれらの問題の両方に対処する構成の例は、構成 `\"C:\\Program Files\\Vim\\gvim.exe\" --nofork` です。これは、空白を含んだファイル名をクォートし、プロセスのバックグラウンド実行を回避するため `--nofork` オプションを指定します。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:87
#, no-wrap
msgid "Credentials"
msgstr "Credentials"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:90
#, no-wrap
msgid "How do I specify my credentials when pushing over HTTP?"
msgstr "HTTPでプッシュするときに資格情報を指定するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:99
msgid ""
"The easiest way to do this is to use a credential helper via the `credential."
"helper` configuration.  Most systems provide a standard choice to integrate "
"with the system credential manager.  For example, Git for Windows provides "
"the `wincred` credential manager, macOS has the `osxkeychain` credential "
"manager, and Unix systems with a standard desktop environment can use the "
"`libsecret` credential manager.  All of these store credentials in an "
"encrypted store to keep your passwords or tokens secure."
msgstr "これを行う最も簡単な方法は、 `credential.helper` 構成を介して資格情報ヘルパーを使用することです。ほとんどのシステムは、システム資格情報マネージャーと統合するための標準的な選択肢を提供します。たとえば、Git for Windowsは「wincred」資格情報マネージャーを提供し、macOSは「osxkeychain」資格情報マネージャーを提供し、標準デスクトップ環境を備えたUnixシステムは「libsecret」資格情報マネージャーを使用できます。 これらはすべて、パスワードまたはトークンを安全に保つために暗号化されたストアに資格情報を保存します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:104
msgid ""
"In addition, you can use the `store` credential manager which stores in a "
"file in your home directory, or the `cache` credential manager, which does "
"not permanently store your credentials, but does prevent you from being "
"prompted for them for a certain period of time."
msgstr "さらに、ホームディレクトリのファイルに保存する `store` 資格情報マネージャー、または資格情報を永続的に保存しないが、特定の時間、資格情報の入力を求められないようにする `cache` 資格情報マネージャーを使用できます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:109
msgid ""
"You can also just enter your password when prompted.  While it is possible "
"to place the password (which must be percent-encoded) in the URL, this is "
"not particularly secure and can lead to accidental exposure of credentials, "
"so it is not recommended."
msgstr "プロンプトが表示されたら、パスワードを入力することもできます。 URLにパスワード(パーセントエンコードする必要があります)を配置することは可能ですが、これは全然安全じゃ無く、誤って資格情報が公開される可能性があるため、お勧めしません。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:111
#, no-wrap
msgid "How do I read a password or token from an environment variable?"
msgstr "環境変数からパスワードまたはトークンを読み取るにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:115
msgid ""
"The `credential.helper` configuration option can also take an arbitrary "
"shell command that produces the credential protocol on standard output.  "
"This is useful when passing credentials into a container, for example."
msgstr "`credential.helper` 構成オプションは、標準出力で資格情報プロトコルを生成する任意のシェルコマンドを受け取ることもできます。これは、たとえば、資格情報をコンテナに渡すときに役立ちます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:119
msgid ""
"Such a shell command can be specified by starting the option value with an "
"exclamation point.  If your password or token were stored in the "
"`GIT_TOKEN`, you could run the following command to set your credential "
"helper:"
msgstr "このようなシェルコマンドは、オプション値を感嘆符(`!`)で開始することで指定できます。パスワードまたはトークンが `GIT_TOKEN` に保存されている場合は、以下のコマンドを実行して資格情報ヘルパーを設定できます:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:123
#, no-wrap
msgid ""
"$ git config credential.helper \\\n"
"\t'!f() { echo username=author; echo \"password=$GIT_TOKEN\"; };f'\n"
msgstr ""
"$ git config credential.helper \\\n"
"\t'!f() { echo username=author; echo \"password=$GIT_TOKEN\"; };f'\n"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:126
#, no-wrap
msgid "How do I change the password or token I've saved in my credential manager?"
msgstr "資格情報マネージャーに保存したパスワードまたはトークンを変更するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:133
msgid ""
"Usually, if the password or token is invalid, Git will erase it and prompt "
"for a new one.  However, there are times when this doesn't always happen.  "
"To change the password or token, you can erase the existing credentials and "
"then Git will prompt for new ones.  To erase credentials, use a syntax like "
"the following (substituting your username and the hostname):"
msgstr "通常、パスワードまたはトークンが無効な場合、Gitはそれを消去し、新しいものを要求します。ただし、これが常に発生するとは限りません。パスワードまたはトークンを変更するには、既存の資格情報を消去してください。そうすればGitが新しい資格情報の入力を求めます。資格情報を消去するには、以下の構文を使用します(ユーザー名(「author」の部分)とホスト名(「git.example.org」の部分)をあなた自身のに置き換えてください):"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:136
#, no-wrap
msgid "$ echo url=https://author@git.example.org | git credential reject\n"
msgstr "$ echo url=https://author@git.example.org | git credential reject\n"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:139
#, no-wrap
msgid "How do I use multiple accounts with the same hosting provider using HTTP?"
msgstr "HTTPを使用して同じホスティングプロバイダーで複数のアカウントを使用するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:150
msgid ""
"Usually the easiest way to distinguish between these accounts is to use the "
"username in the URL.  For example, if you have the accounts `author` and "
"`committer` on `git.example.org`, you can use the URLs https://author@git."
"example.org/org1/project1.git and https://committer@git.example.org/org2/"
"project2.git.  This way, when you use a credential helper, it will "
"automatically try to look up the correct credentials for your account.  If "
"you already have a remote set up, you can change the URL with something like "
"`git remote set-url origin https://author@git.example.org/org1/project1.git` "
"(see linkgit:git-remote[1] for details)."
msgstr "通常、これらのアカウントを区別する最も簡単な方法は、URLでユーザー名を使用することです。 たとえば、 `git.example.org` にアカウント `author` と `committer` がある場合、URLに https://author@git.example.org/org1/project1.git と https://committer@git.example.org/org2/project2.git を使用できます。このように、資格情報ヘルパーを使用すると、アカウントの正しい資格情報が自動的に検索されます。すでにリモートを設定している場合は `git remote set-url origin https://author@git.example.org/org1/project1.git` としてURLを変更できます(詳細は linkgit:git-remote[1] を参照)。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:152
#, no-wrap
msgid "How do I use multiple accounts with the same hosting provider using SSH?"
msgstr "SSHを使用して同じホスティングプロバイダーで複数のアカウントを使用するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:160
msgid ""
"With most hosting providers that support SSH, a single key pair uniquely "
"identifies a user.  Therefore, to use multiple accounts, it's necessary to "
"create a key pair for each account.  If you're using a reasonably modern "
"OpenSSH version, you can create a new key pair with something like `ssh-"
"keygen -t ed25519 -f ~/.ssh/id_committer`.  You can then register the public "
"key (in this case, `~/.ssh/id_committer.pub`; note the `.pub`) with the "
"hosting provider."
msgstr "SSHをサポートするほとんどのホスティングプロバイダーでは、単一のキーペアがユーザーを一意に識別します。したがって、複数のアカウントを使用するには、アカウントごとにキーペアを作成する必要があります。適度に最新のOpenSSHバージョンを使用している場合は `ssh-keygen -t ed25519 -f ~/.ssh/id_committer` などとして新しいキーペアを作成できます。次に、公開鍵(この場合は `~/.ssh/id_committer.pub` ※拡張子 `.pub` に注意) をホスティングプロバイダーに登録できます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:166
msgid ""
"Most hosting providers use a single SSH account for pushing; that is, all "
"users push to the `git` account (e.g., `git@git.example.org`).  If that's "
"the case for your provider, you can set up multiple aliases in SSH to make "
"it clear which key pair to use.  For example, you could write something like "
"the following in `~/.ssh/config`, substituting the proper private key file:"
msgstr "ほとんどのホスティングプロバイダーは、プッシュに単一のSSHアカウントを使用します。つまり、すべてのユーザーが `git` アカウント(例: `git@git.example.org`)にプッシュします。プロバイダーの場合は、SSHで複数のエイリアスを設定して、使用するキーペアを明確にすることができます。たとえば、以下のようなのを `~/.ssh/config` に記述して、適切な秘密鍵ファイルに置き換えることができます:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:182
#, no-wrap
msgid ""
"# This is the account for author on git.example.org.\n"
"Host example_author\n"
"\tHostName git.example.org\n"
"\tUser git\n"
"\t# This is the key pair registered for author with git.example.org.\n"
"\tIdentityFile ~/.ssh/id_author\n"
"\tIdentitiesOnly yes\n"
"# This is the account for committer on git.example.org.\n"
"Host example_committer\n"
"\tHostName git.example.org\n"
"\tUser git\n"
"\t# This is the key pair registered for committer with git.example.org.\n"
"\tIdentityFile ~/.ssh/id_committer\n"
"\tIdentitiesOnly yes\n"
msgstr ""
"# This is the account for author on git.example.org.\n"
"Host example_author\n"
"\tHostName git.example.org\n"
"\tUser git\n"
"\t# This is the key pair registered for author with git.example.org.\n"
"\tIdentityFile ~/.ssh/id_author\n"
"\tIdentitiesOnly yes\n"
"# This is the account for committer on git.example.org.\n"
"Host example_committer\n"
"\tHostName git.example.org\n"
"\tUser git\n"
"\t# This is the key pair registered for committer with git.example.org.\n"
"\tIdentityFile ~/.ssh/id_committer\n"
"\tIdentitiesOnly yes\n"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:187
msgid ""
"Then, you can adjust your push URL to use `git@example_author` or "
"`git@example_committer` instead of `git@example.org` (e.g., `git remote set-"
"url git@example_author:org1/project1.git`)."
msgstr "こうすれば、あなたはプッシュURLを調整して、 `git@example.org` の代わりに `git@example_author` または `git@example_committer` を使用できます(例: `git remote set-url git@example_author:org1/project1.git`) 。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:189
#, no-wrap
msgid "Common Issues"
msgstr "Common Issues"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:192
#, no-wrap
msgid "I've made a mistake in the last commit.  How do I change it?"
msgstr "前回のコミットでミスをしました。どうすれば変更できますか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:199
msgid ""
"You can make the appropriate change to your working tree, run `git add "
"<file>` or `git rm <file>`, as appropriate, to stage it, and then `git "
"commit --amend`.  Your change will be included in the commit, and you'll be "
"prompted to edit the commit message again; if you wish to use the original "
"message verbatim, you can use the `--no-edit` option to `git commit` in "
"addition, or just save and quit when your editor opens."
msgstr "作業ツリーに適切な変更を加え、必要に応じて `git add <file>` または `git rm <file>` を実行してステージングしてから、 `git commit --amend` を実行できます。変更はコミットに含まれ、コミットメッセージを再度編集するように求められます。元のメッセージをそのまま使用したい場合は、 `--no-edit` オプションを伴ってて `git commit` を使用するか、または、エディタが開いたら何もせず保存して終了して済ませることもできます。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:201
#, no-wrap
msgid "I've made a change with a bug and it's been included in the main branch.  How should I undo it?"
msgstr "バグで変更を加えましたが、それは既にメインブランチに含まれてしまっています。どうすれば元に戻すことができますか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:208
msgid ""
"The usual way to deal with this is to use `git revert`.  This preserves the "
"history that the original change was made and was a valuable contribution, "
"but also introduces a new commit that undoes those changes because the "
"original had a problem.  The commit message of the revert indicates the "
"commit which was reverted and is usually edited to include an explanation as "
"to why the revert was made."
msgstr "これに対処する通常の方法は、 `git revert` を使用することです。これにより、元の変更が行われて貴重な貢献であった、という履歴が保持されるとともに、元の変更に問題があったためにそれらの変更を元に戻す新しいコミットも導入されます。revertのコミットメッセージは、復帰(revert)されたコミットを示し、通常、復帰(revert)が行われた理由に関する説明を含むように編集されます。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:210
#, no-wrap
msgid "How do I ignore changes to a tracked file?"
msgstr "追跡されているファイルへの変更を無視するにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:216
msgid ""
"Git doesn't provide a way to do this.  The reason is that if Git needs to "
"overwrite this file, such as during a checkout, it doesn't know whether the "
"changes to the file are precious and should be kept, or whether they are "
"irrelevant and can safely be destroyed.  Therefore, it has to take the safe "
"route and always preserve them."
msgstr "Gitはこれを行う方法を提供していません。 その理由は、チェックアウト中など、Gitがこのファイルを上書きする必要がある場合、ファイルへの変更が貴重で保持されるべきかどうか、または無関係で安全に破棄できるかどうかがわからないためです。したがって、安全なルートを取り、常にそれらを保存する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:220
msgid ""
"It's tempting to try to use certain features of `git update-index`, namely "
"the assume-unchanged and skip-worktree bits, but these don't work properly "
"for this purpose and shouldn't be used this way."
msgstr "`git update-index` の特定の機能、つまり、assume-unchangedビットとskip-worktreeビットを使おうとするのは魅力的ですが、これらはこの目的には適切に機能しないため、このように使用しないでください。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:225
msgid ""
"If your goal is to modify a configuration file, it can often be helpful to "
"have a file checked into the repository which is a template or set of "
"defaults which can then be copied alongside and modified as appropriate.  "
"This second, modified file is usually ignored to prevent accidentally "
"committing it."
msgstr "あなたの目的が構成ファイルを変更することの場合は、テンプレートまたはデフォルトのセットであるファイルをリポジトリにチェックインして、一緒にコピーして必要に応じて変更できると便利なことがよくあります。この場合の変更されたファイルは、誤ってコミットすることを防ぐために、通常は無視されます。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:227
#, no-wrap
msgid "I asked Git to ignore various files, yet they are still tracked"
msgstr "さまざまなファイルを無視するようにGitに依頼したはずなのに、それらはまだ追跡されています"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:235
msgid ""
"A `gitignore` file ensures that certain file(s) which are not tracked by Git "
"remain untracked.  However, sometimes particular file(s) may have been "
"tracked before adding them into the `.gitignore`, hence they still remain "
"tracked.  To untrack and ignore files/patterns, use `git rm --cached <file/"
"pattern>` and add a pattern to `.gitignore` that matches the <file>.  See "
"linkgit:gitignore[5] for details."
msgstr "`gitignore` ファイルは、Gitによって追跡されていない特定のファイルが追跡されないままであることを保証します。ただし、特定のファイルが `.gitignore` に追加される前に追跡されている場合は追跡されたままになります。ファイル/パターン を追跡解除して無視するには、 `git rm --cached <file/pattern>` を使用し、 <file> に一致するパターンを `.gitignore` に追加します。詳細については linkgit:gitignore[5] を参照してください。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:237
#, no-wrap
msgid "How do I know if I want to do a fetch or a pull?"
msgstr "フェッチまたはプルのどちらを実行すればよいか知るにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:243
msgid ""
"A fetch stores a copy of the latest changes from the remote repository, "
"without modifying the working tree or current branch.  You can then at your "
"leisure inspect, merge, rebase on top of, or ignore the upstream changes.  A "
"pull consists of a fetch followed immediately by either a merge or rebase.  "
"See linkgit:git-pull[1]."
msgstr "フェッチは、作業ツリーや現在のブランチを変更せずに、リモートリポジトリからの最新の変更のコピーを保存します。その後、自由に、アップストリームの変更を検査、マージ、リベース、または無視することができます。プルは、フェッチとその直後のマージまたはリベースで構成されます。 linkgit:git-pull[1] を参照してください。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:245
#, no-wrap
msgid "Merging and Rebasing"
msgstr "Merging and Rebasing"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:248
#, no-wrap
msgid "What kinds of problems can occur when merging long-lived branches with squash merges?"
msgstr "寿命の長いブランチをスカッシュマージとマージすると、どのような問題が発生する可能性がありますか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:254
msgid ""
"In general, there are a variety of problems that can occur when using squash "
"merges to merge two branches multiple times.  These can include seeing extra "
"commits in `git log` output, with a GUI, or when using the `...` notation to "
"express a range, as well as the possibility of needing to re-resolve "
"conflicts again and again."
msgstr "一般に、スカッシュマージを使用して2つのブランチを複数回マージすると、さまざまな問題が発生する可能性があります。これには、GUIを使用した場合、または `...`表記を使用して範囲を表す場合に、 `git log` 出力で追加のコミットが表示されることや、競合を何度も再解決する必要がある可能性が含まれます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:263
msgid ""
"When Git does a normal merge between two branches, it considers exactly "
"three points: the two branches and a third commit, called the _merge base_, "
"which is usually the common ancestor of the commits.  The result of the "
"merge is the sum of the changes between the merge base and each head.  When "
"you merge two branches with a regular merge commit, this results in a new "
"commit which will end up as a merge base when they're merged again, because "
"there is now a new common ancestor.  Git doesn't have to consider changes "
"that occurred before the merge base, so you don't have to re-resolve any "
"conflicts you resolved before."
msgstr "Gitが2つのブランチ間で通常のマージを行う場合、正確に3者が考慮されます。2つのブランチと、通常は2つのコミットの共通の祖先である「マージベース」(merge base)と呼ばれる3番目のコミットです。マージの結果は、マージベースと各headの間の変更の合計です。2つのブランチを通常のマージコミットでマージすると、新しい共通の祖先を持つ、新しいコミットが発生し、再度マージされるときはそれが最終的なマージベースになります。そうすると、Gitは、マージベースの前に発生した変更を考慮する必要がないため、以前に解決した競合を再解決する必要がありません。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:272
msgid ""
"When you perform a squash merge, a merge commit isn't created; instead, the "
"changes from one side are applied as a regular commit to the other side.  "
"This means that the merge base for these branches won't have changed, and so "
"when Git goes to perform its next merge, it considers all of the changes "
"that it considered the last time plus the new changes.  That means any "
"conflicts may need to be re-resolved.  Similarly, anything using the `...` "
"notation in `git diff`, `git log`, or a GUI will result in showing all of "
"the changes since the original merge base."
msgstr "スカッシュマージを実行する場合、マージコミットは作成されません。代わりに、一方の側からの変更は、もう一方の側への通常のコミットとして適用されます。つまり、これらのブランチのマージベースは変更されないため、Gitが次のマージを実行するときに、前回考慮したすべての変更と新しい変更が考慮されます。つまり、競合を再解決する必要があるかもしれません。 同様に、 `git diff` または `git log` またはGUIで `...` 表記を使用すると、元のマージベース以降のすべての変更が表示されます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:275
msgid ""
"As a consequence, if you want to merge two long-lived branches repeatedly, "
"it's best to always use a regular merge commit."
msgstr "結果として、2つの長期間有効なブランチを繰り返しマージする場合は、常に通常のマージコミットを使用するのが最善です。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:277
#, no-wrap
msgid "If I make a change on two branches but revert it on one, why does the merge of those branches include the change?"
msgstr "2つのブランチに変更を加えた後、それを1つに戻した場合、それら2つのブランチのマージに変更が含まれるのはなぜですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:284
msgid ""
"By default, when Git does a merge, it uses a strategy called the `ort` "
"strategy, which does a fancy three-way merge.  In such a case, when Git "
"performs the merge, it considers exactly three points: the two heads and a "
"third point, called the _merge base_, which is usually the common ancestor "
"of those commits.  Git does not consider the history or the individual "
"commits that have happened on those branches at all."
msgstr "デフォルトでは、Gitがマージを行うとき、それは「ort」戦略と呼ばれる戦略を使用します。これは、派手な3者間マージ(fancy three-way merge)を行います。 このような場合、Gitはマージを実行するときに、正確に3つのポイントを考慮します。2つのheadと、通常はこれらのコミットの共通の祖先である「マージベース」(merge base)と呼ばれる3番目のポイントです。 Gitは、これらのブランチで発生した履歴や個々のコミットをまったく考慮しません。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:289
msgid ""
"As a result, if both sides have a change and one side has reverted that "
"change, the result is to include the change.  This is because the code has "
"changed on one side and there is no net change on the other, and in this "
"scenario, Git adopts the change."
msgstr "その結果、両方の側に変更があり、一方の側がその変更を元に戻した場合、結果には変更が含まれます。 これは、コードが一方の側で変更され、もう一方の側では正味の変更がないためです。このシナリオでは、Gitが変更を採用します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:296
msgid ""
"If this is a problem for you, you can do a rebase instead, rebasing the "
"branch with the revert onto the other branch.  A rebase in this scenario "
"will revert the change, because a rebase applies each individual commit, "
"including the revert.  Note that rebases rewrite history, so you should "
"avoid rebasing published branches unless you're sure you're comfortable with "
"that.  See the NOTES section in linkgit:git-rebase[1] for more details."
msgstr "これが問題になる場合は、代わりにリベースを実行して、ブランチを他のブランチに戻すことでリベースすることができます。このシナリオでのリベースは変更を元に戻します。これは、リベースが元に戻すことを含め、個々のコミットを適用するためです。リベースは書き換え履歴(rewrite history)をリベースするため、問題がない場合を除いて、公開されたブランチのリベースは避けてください。詳細については、 linkgit:git-rebase[1]のNOTESセクションを参照してください。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:298
#, no-wrap
msgid "Hooks"
msgstr "Hooks"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:301
#, no-wrap
msgid "How do I use hooks to prevent users from making certain changes?"
msgstr "フックを使用して、ユーザーが特定の変更を行うのを妨げるにはどうすればよいですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:306
msgid ""
"The only safe place to make these changes is on the remote repository (i.e., "
"the Git server), usually in the `pre-receive` hook or in a continuous "
"integration (CI) system.  These are the locations in which policy can be "
"enforced effectively."
msgstr "これらの変更を行うための唯一の安全な場所は、リモートリポジトリ(つまり、Gitサーバー)で、通常は `pre-receive` フックまたは継続的インテグレーション(CI)システムです。これらは、ポリシーを効果的に実施できる場所です。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:314
msgid ""
"It's common to try to use `pre-commit` hooks (or, for commit messages, "
"`commit-msg` hooks) to check these things, which is great if you're working "
"as a solo developer and want the tooling to help you.  However, using hooks "
"on a developer machine is not effective as a policy control because a user "
"can bypass these hooks with `--no-verify` without being noticed (among "
"various other ways).  Git assumes that the user is in control of their local "
"repositories and doesn't try to prevent this or tattle on the user."
msgstr "`pre-commit` フック(または、コミットメッセージの場合は `commit-msg` フック)を使用してこれらをチェックするのが一般的です。これは、単独の開発者として作業していて、ツールが役立つことを望んでいる場合に最適です。ただし、開発者のマシンでフックを使用することは、ユーザーが(他のさまざまな方法の中でも)気付かれることなく `--no-verify` でこれらのフックをバイパスできるため、ポリシーコントロールとしては効果的ではありません。 Gitは、ユーザーがローカルリポジトリを管理していることを前提としており、これを防止したり、ユーザーを攻撃したりすることはありません。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:319
msgid ""
"In addition, some advanced users find `pre-commit` hooks to be an impediment "
"to workflows that use temporary commits to stage work in progress or that "
"create fixup commits, so it's better to push these kinds of checks to the "
"server anyway."
msgstr "さらに、一部の上級ユーザーは、「pre-commit」フックが、一時的なコミットを使用して進行中の作業をステージングしたり、修正コミットを作成したりするワークフローの障害であると感じているため、とにかくこれらの種類のチェックはサーバーに押しやることをお勧めします。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:321
#, no-wrap
msgid "Cross-Platform Issues"
msgstr "Cross-Platform Issues"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:324
#, no-wrap
msgid "I'm on Windows and my text files are detected as binary."
msgstr "Windowsを使用していますが、テキストファイルがバイナリとして検出されます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:333
msgid ""
"Git works best when you store text files as UTF-8.  Many programs on Windows "
"support UTF-8, but some do not and only use the little-endian UTF-16 format, "
"which Git detects as binary.  If you can't use UTF-8 with your programs, you "
"can specify a working tree encoding that indicates which encoding your files "
"should be checked out with, while still storing these files as UTF-8 in the "
"repository.  This allows tools like linkgit:git-diff[1] to work as expected, "
"while still allowing your tools to work."
msgstr "Gitは、テキストファイルをUTF-8として保存する場合に最適に機能します。Windows上の多くのプログラムはUTF-8をサポートしていますが、Gitがバイナリとして検出するリトルエンディアンのUTF-16形式を使用していないプログラムもあります。プログラムでUTF-8を使用できない場合は、これらのファイルをUTF-8としてリポジトリに保存しながら、ファイルをチェックアウトするエンコードを示す作業ツリーエンコーディング(working tree encoding)を指定できます。これにより、 linkgit:git-diff[1] などのツールを期待どおりに機能させながら、ツールを機能させることができます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:337
msgid ""
"To do so, you can specify a linkgit:gitattributes[5] pattern with the "
"`working-tree-encoding` attribute.  For example, the following pattern sets "
"all C files to use UTF-16LE-BOM, which is a common encoding on Windows:"
msgstr "これを行うには、 `working-tree-encoding` 属性を使用して linkgit:gitattributes[5] パターンを指定できます。たとえば、以下のパターンは、Windowsで一般的なエンコーディングである UTF-16LE-BOM を使用するようにすべてのC言語ファイルを設定します:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:340
#, no-wrap
msgid "*.c\tworking-tree-encoding=UTF-16LE-BOM\n"
msgstr "*.c\tworking-tree-encoding=UTF-16LE-BOM\n"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:347
msgid ""
"You will need to run `git add --renormalize` to have this take effect.  Note "
"that if you are making these changes on a project that is used across "
"platforms, you'll probably want to make it in a per-user configuration file "
"or in the one in `$GIT_DIR/info/attributes`, since making it in a `."
"gitattributes` file in the repository will apply to all users of the "
"repository."
msgstr "これを有効にするには、 `git add --renormalize` を実行する必要があります。プラットフォーム間で使用されるプロジェクトでこれらの変更を行う場合は、ユーザーごとの構成ファイルまたは `$GIT_DIR/info/attributes` の構成ファイルで行う必要があることに注意してください。リポジトリ内の `.gitattributes` ファイルは、リポジトリのすべてのユーザーに適用されます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:350
msgid ""
"See the following entry for information about normalizing line endings as "
"well, and see linkgit:gitattributes[5] for more information about attribute "
"files."
msgstr "行末の正規化については以下のエントリを参照してください。属性ファイルの詳細については、linkgit:gitattributes[5] を参照してください。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:352
#, no-wrap
msgid "I'm on Windows and git diff shows my files as having a `^M` at the end."
msgstr "Windowsの git diff はファイルの最後に `^M` があると表示します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:357
msgid ""
"By default, Git expects files to be stored with Unix line endings.  As such, "
"the carriage return (`^M`) that is part of a Windows line ending is shown "
"because it is considered to be trailing whitespace.  Git defaults to showing "
"trailing whitespace only on new lines, not existing ones."
msgstr "デフォルトでは、GitはファイルがUnixの行末で保存されることを想定しています。そのため、Windowsの行末の一部であるキャリッジリターン(`^M`)は、末尾の空白と見なされるため、表示されます。Gitはデフォルトで、既存の行ではなく、新しい行にのみ末尾の空白を表示します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:362
msgid ""
"You can store the files in the repository with Unix line endings and convert "
"them automatically to your platform's line endings.  To do that, set the "
"configuration option `core.eol` to `native` and see the following entry for "
"information about how to configure files as text or binary."
msgstr "ファイルをUnixの行末でリポジトリに保存し、プラットフォームの行末に自動的に変換できます。 これを行うには、構成オプション `core.eol` を `native` に設定し、以下のエントリで、ファイルをテキストまたはバイナリとして構成する方法について確認してください。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:365
msgid ""
"You can also control this behavior with the `core.whitespace` setting if you "
"don't wish to remove the carriage returns from your line endings."
msgstr "行末からキャリッジリターン(CR;\\x0d)を削除したくない場合は、 `core.whitespace` 設定を使用してこの動作を制御することもできます。"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:367
#, no-wrap
msgid "Why do I have a file that's always modified?"
msgstr "常に変更されるファイルがあるのはなぜですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:374
msgid ""
"Internally, Git always stores file names as sequences of bytes and doesn't "
"perform any encoding or case folding.  However, Windows and macOS by default "
"both perform case folding on file names.  As a result, it's possible to end "
"up with multiple files or directories whose names differ only in case.  Git "
"can handle this just fine, but the file system can store only one of these "
"files, so when Git reads the other file to see its contents, it looks "
"modified."
msgstr "内部的には、Gitは常にファイル名をバイトのシーケンスとして保存し、エンコードや大文字と小文字の区別は行いません。 ただし、WindowsとmacOSはどちらも、デフォルトでファイル名に対して大文字と小文字を区別します。その結果、大文字と小文字が区別される場合にのみ名前が異なる複数のファイルまたはディレクトリが作成される可能性があります。Gitはこれを問題なく処理できますが、ファイルシステムはこれらのファイルの1つしか保存できないため、Gitが他のファイルを読み取ってその内容を確認すると、変更されているように見えます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:378
msgid ""
"It's best to remove one of the files such that you only have one file.  You "
"can do this with commands like the following (assuming two files `AFile.txt` "
"and `afile.txt`) on an otherwise clean working tree:"
msgstr "ファイルが1つだけになるように、ファイルの1つを削除することをお勧めします。これは、以下のようなコマンド(2つのファイル `AFile.txt` と`afile.txt` を想定)を使用して、他の点ではクリーンな作業ツリーで実行できます:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:383
#, no-wrap
msgid ""
"$ git rm --cached AFile.txt\n"
"$ git commit -m 'Remove files conflicting in case'\n"
"$ git checkout .\n"
msgstr ""
"$ git rm --cached AFile.txt\n"
"$ git commit -m 'Remove files conflicting in case'\n"
"$ git checkout .\n"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:389
msgid ""
"This avoids touching the disk, but removes the additional file.  Your "
"project may prefer to adopt a naming convention, such as all-lowercase "
"names, to avoid this problem from occurring again; such a convention can be "
"checked using a `pre-receive` hook or as part of a continuous integration "
"(CI) system."
msgstr "これにより、ディスクへの変更は回避され、追加のファイルは削除されます。プロジェクトでは、この問題が再発しないように、すべて小文字の名前などの命名規則を採用することをお勧めします。このような規則は、 `pre-receive` フックを使用して、または継続的インテグレーション(CI)システムにてチェックできます。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:394
msgid ""
"It is also possible for perpetually modified files to occur on any platform "
"if a smudge or clean filter is in use on your system but a file was "
"previously committed without running the smudge or clean filter.  To fix "
"this, run the following on an otherwise clean working tree:"
msgstr "システムでスマッジまたはクリーンフィルター(a smudge or clean filter)が使用されているが、スマッジまたはクリーンフィルターを実行せずにファイルが以前にコミットされた場合、任意のプラットフォームで永続的に変更されたファイルが発生する可能性もあります。これを修正するには、他の点ではクリーンな作業ツリーで以下を実行します:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:397
#, no-wrap
msgid "$ git add --renormalize .\n"
msgstr "$ git add --renormalize .\n"

#. type: Labeled list
#: ../Documentation-sedout/gitfaq.txt:400
#, no-wrap
msgid "What's the recommended way to store files in Git?"
msgstr "Gitにファイルを保存するための推奨の方法は何ですか？"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:407
msgid ""
"While Git can store and handle any file of any type, there are some settings "
"that work better than others.  In general, we recommend that text files be "
"stored in UTF-8 without a byte-order mark (BOM) with LF (Unix-style) "
"endings.  We also recommend the use of UTF-8 (again, without BOM) in commit "
"messages.  These are the settings that work best across platforms and with "
"tools such as `git diff` and `git merge`."
msgstr "Gitはあらゆるタイプのあらゆるファイルを保存および処理できますが、他の設定よりもうまく機能する設定がいくつかあります。一般に、テキストファイルは、LF(Unixスタイル)で終わるバイト順マーク(BOM)なしでUTF-8に保存することをお勧めします。また、コミットメッセージでUTF-8(ここでもBOMなし)を使用することをお勧めします。これらは、プラットフォーム間や  `git diff` や `git merge` などのツールで最適に機能する設定です。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:415
msgid ""
"Additionally, if you have a choice between storage formats that are text "
"based or non-text based, we recommend storing files in the text format and, "
"if necessary, transforming them into the other format.  For example, a text-"
"based SQL dump with one record per line will work much better for diffing "
"and merging than an actual database file.  Similarly, text-based formats "
"such as Markdown and AsciiDoc will work better than binary formats such as "
"Microsoft Word and PDF."
msgstr "さらに、テキストベースまたは非テキストベースのストレージ形式を選択できる場合は、ファイルをテキスト形式で保存し、必要に応じて他の形式に変換することをお勧めします。たとえば、1行に1つのレコードを持つテキストベースのSQLダンプは、実際のデータベースファイルよりも差分とマージにはるかに適しています。同様に、MarkdownやAsciiDocなどのテキストベースの形式は、MicrosoftWordやPDFなどのバイナリ形式よりもうまく機能します。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:420
msgid ""
"Similarly, storing binary dependencies (e.g., shared libraries or JAR files) "
"or build products in the repository is generally not recommended.  "
"Dependencies and build products are best stored on an artifact or package "
"server with only references, URLs, and hashes stored in the repository."
msgstr "同様に、バイナリ依存関係(共有ライブラリやJARファイルなど)を格納したり、リポジトリに製品をビルドしたりすることは、通常はお勧めしません。依存関係とビルド製品は、リポジトリに保存されている参照、URL、ハッシュのみを使用して、アーティファクトサーバーまたはパッケージサーバーに保存するのが最適です。"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:425
msgid ""
"We also recommend setting a linkgit:gitattributes[5] file to explicitly mark "
"which files are text and which are binary.  If you want Git to guess, you "
"can set the attribute `text=auto`.  For example, the following might be "
"appropriate in some projects:"
msgstr "また、 linkgit:gitattributes[5] ファイルを設定して、どのファイルがテキストでどのファイルがバイナリであるかを明示的にマークすることをお勧めします。Gitに推測させたい場合は、属性 `text=auto` を設定できます。 たとえば、一部のプロジェクトでは以下の設定が適切な場合があります:"

#. type: delimited block -
#: ../Documentation-sedout/gitfaq.txt:433
#, no-wrap
msgid ""
"# By default, guess.\n"
"*\ttext=auto\n"
"# Mark all C files as text.\n"
"*.c\ttext\n"
"# Mark all JPEG files as binary.\n"
"*.jpg\tbinary\n"
msgstr ""
"# By default, guess.\n"
"*\ttext=auto\n"
"# Mark all C files as text.\n"
"*.c\ttext\n"
"# Mark all JPEG files as binary.\n"
"*.jpg\tbinary\n"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:438
msgid ""
"These settings help tools pick the right format for output such as patches "
"and result in files being checked out in the appropriate line ending for the "
"platform."
msgstr "これらの設定は、ツールがパッチなどの出力に適切な形式を選択するのに役立ち、プラットフォームに適切な行末コードでファイルがチェックアウトされます。"

#. type: Title -
#: ../Documentation-sedout/gitfaq.txt:440
#, no-wrap
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: ../Documentation-sedout/gitfaq.txt:441
msgid "Part of the linkgit:git[1] suite"
msgstr "Part of the linkgit:git[1] suite"
