# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 04:37+0900\n"
"PO-Revision-Date: 2022-04-04 05:45+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/git-merge-base.txt:2
#, no-wrap
msgid "git-merge-base(1)"
msgstr "git-merge-base(1)"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:5
#, no-wrap
msgid "NAME"
msgstr "NAME"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:7
msgid "git-merge-base - Find as good common ancestors as possible for a merge"
msgstr "git-merge-base - マージのために可能な限り良い共通の祖先を見つけます"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:10
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:17
#, no-wrap
msgid ""
"'git merge-base' [-a|--all] <commit> <commit>...\n"
"'git merge-base' [-a|--all] --octopus <commit>...\n"
"'git merge-base' --is-ancestor <commit> <commit>\n"
"'git merge-base' --independent <commit>...\n"
"'git merge-base' --fork-point <ref> [<commit>]\n"
msgstr ""
"'git merge-base' [-a|--all] <commit> <commit>...\n"
"'git merge-base' [-a|--all] --octopus <commit>...\n"
"'git merge-base' --is-ancestor <commit> <commit>\n"
"'git merge-base' --independent <commit>...\n"
"'git merge-base' --fork-point <ref> [<commit>]\n"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:19
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:27
msgid ""
"'git merge-base' finds best common ancestor(s) between two commits to use in "
"a three-way merge.  One common ancestor is 'better' than another common "
"ancestor if the latter is an ancestor of the former.  A common ancestor that "
"does not have any better common ancestor is a 'best common ancestor', i.e. a "
"'merge base'.  Note that there can be more than one merge base for a pair of "
"commits."
msgstr "`git merge-base` は、3方向マージで使用する2つのコミット間で最良の共通の祖先を探します。「ある共通の祖先」の祖先が、「別の共通の祖先」である場合、「ある共通の祖先」は「別の共通の祖先」よりも「より良い」です。より良い共通の祖先を持たない共通の祖先は、「最良の共通の祖先」、つまり「マージベース」です。注意: コミットのペアに対して複数のマージベースが存在する可能性があることに注意してください。"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:29
#, no-wrap
msgid "OPERATION MODES"
msgstr "OPERATION MODES"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:33
msgid ""
"As the most common special case, specifying only two commits on the command "
"line means computing the merge base between the given two commits."
msgstr "最も一般的な特別のケースとして、コマンドラインで2つのコミットのみを指定することは、指定された2つのコミット間のマージベースを計算することを意味します。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:38
msgid ""
"More generally, among the two commits to compute the merge base from, one is "
"specified by the first commit argument on the command line; the other commit "
"is a (possibly hypothetical) commit that is a merge across all the remaining "
"commits on the command line."
msgstr "より一般的には、マージベースを計算する2つのコミットのうち、1つはコマンドラインの最初のコミット引数で指定されます。もう1つのコミットは、コマンドラインの残りのすべてのコミットをマージする(おそらく仮想の)コミットです。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:42
msgid ""
"As a consequence, the 'merge base' is not necessarily contained in each of "
"the commit arguments if more than two commits are specified. This is "
"different from linkgit:git-show-branch[1] when used with the `--merge-base` "
"option."
msgstr "結果として、3つ以上のコミットが指定されている場合、「マージベース」は必ずしも各コミット引数に含まれているとは限りません。 これは、 `--merge-base` オプションを伴った linkgit:git-show-branch[1] とは異なります。"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:43
#, no-wrap
msgid "`--octopus`"
msgstr "`--octopus`"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:47
msgid ""
"Compute the best common ancestors of all supplied commits, in preparation "
"for an n-way merge.  This mimics the behavior of 'git show-branch --merge-"
"base'."
msgstr "n方向マージの準備として、提供されたすべてのコミットの最良の共通の祖先を計算します。これは、 `git show-branch --merge-base` の振る舞いを模倣しています。"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:48
#, no-wrap
msgid "`--independent`"
msgstr "`--independent`"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:54
msgid ""
"Instead of printing merge bases, print a minimal subset of the supplied "
"commits with the same ancestors.  In other words, among the commits given, "
"list those which cannot be reached from any other.  This mimics the behavior "
"of 'git show-branch --independent'."
msgstr "マージベースを出力する代わりに、提供されたコミットの最小限のサブセットを同一祖先で出力します。言い換えれば、与えられたコミットの中にで他から到達できないコミットをリストします。これは、 `git show-branch --independent` の振る舞いを模倣しています。"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:55
#, no-wrap
msgid "`--is-ancestor`"
msgstr "`--is-ancestor`"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:59
msgid ""
"Check if the first <commit> is an ancestor of the second <commit>, and exit "
"with status 0 if true, or with status 1 if not.  Errors are signaled by a "
"non-zero status that is not 1."
msgstr "1番目の <commit> が2番目の <commit> の祖先であるかどうかを確認し、trueの場合はステータス0で終了し、そうでない場合はステータス1で終了します。 エラーは、1では無い、かつ、ゼロ以外のステータスによって通知されます。"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:60
#, no-wrap
msgid "`--fork-point`"
msgstr "`--fork-point`"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:68
msgid ""
"Find the point at which a branch (or any history that leads to <commit>) "
"forked from another branch (or any reference)  <ref>. This does not just "
"look for the common ancestor of the two commits, but also takes into account "
"the reflog of <ref> to see if the history leading to <commit> forked from an "
"earlier incarnation of the branch <ref> (see discussion on this mode below)."
msgstr "ブランチ(または <commit> につながる履歴)が、別のブランチ(または参照) <ref> から分岐したポイントを見つけます。これは、2つのコミットの共通の祖先を探すだけでなく、 <ref> のreflogを考慮して、 <commit> につながる履歴がブランチ <ref> の以前の実体(incarnation)から分岐したかどうかを確認します(下記の、このモードに関するdiscussionを参照してください)。"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:70
#, no-wrap
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:71
#, no-wrap
msgid "`-a`"
msgstr "`-a`"

#. type: Labeled list
#: ../Documentation-sedout/git-merge-base.txt:72
#, no-wrap
msgid "`--all`"
msgstr "`--all`"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:74
msgid "Output all merge bases for the commits, instead of just one."
msgstr "1つだけではなく、コミットのすべてのマージベースを出力します。"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:76
#, no-wrap
msgid "DISCUSSION"
msgstr "DISCUSSION"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:80
msgid ""
"Given two commits 'A' and 'B', `git merge-base A B` will output a commit "
"which is reachable from both 'A' and 'B' through the parent relationship."
msgstr "2つのコミット「A」と「B」が与えられると、「git merge-base A B」は、親子関係を辿って「A」と「B」の両方から到達可能なコミットを出力します。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:82
msgid "For example, with this topology:"
msgstr "たとえば、このトポロジでは以下のようになります:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:87
#, no-wrap
msgid ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"
msgstr ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:90
msgid "the merge base between 'A' and 'B' is '1'."
msgstr "「A」と「B」の間のマージベースは「1」です。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:94
msgid ""
"Given three commits 'A', 'B' and 'C', `git merge-base A B C` will compute "
"the merge base between 'A' and a hypothetical commit 'M', which is a merge "
"between 'B' and 'C'.  For example, with this topology:"
msgstr "3つのコミット「A」、「B」、「C」が与えられると、「git merge-base A B C」は、「A」と仮想のコミット「M」の間のマージベースを計算します。仮想のコミット「M」は、「B」と「C」のマージです。たとえば、このトポロジでは以下のようになります:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:101
#, no-wrap
msgid ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:105
msgid ""
"the result of `git merge-base A B C` is '1'.  This is because the equivalent "
"topology with a merge commit 'M' between 'B' and 'C' is:"
msgstr "`git merge-base A B C` の結果は「1」です。 これは、「B」と「C」の間にマージコミット「M」がある同等のトポロジが以下のとおりであるためです:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:113
#, no-wrap
msgid ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:118
msgid ""
"and the result of `git merge-base A M` is '1'.  Commit '2' is also a common "
"ancestor between 'A' and 'M', but '1' is a better common ancestor, because "
"'2' is an ancestor of '1'.  Hence, '2' is not a merge base."
msgstr "そして、 `git merge-base A M` の結果は「1」です。 コミット「2」も「A」と「M」の間の共通の祖先ですが、「2」は「1」の祖先であるため、「1」の方がよりよい共通の祖先です。 したがって、「2」はマージベースではありません。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:121
msgid ""
"The result of `git merge-base --octopus A B C` is '2', because '2' is the "
"best common ancestor of all commits."
msgstr "`git merge-base --octopus A B C` の結果は「2」です。これは、「2」がすべてのコミットの中で最も共通の祖先であるためです。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:124
msgid ""
"When the history involves criss-cross merges, there can be more than one "
"'best' common ancestor for two commits.  For example, with this topology:"
msgstr "履歴に交差マージ(criss-cross merges)が含まれる場合、2つのコミットに対して「最良の」共通の祖先が複数存在する可能性があります。 たとえば、このトポロジでは以下のようになります:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:131
#, no-wrap
msgid ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"
msgstr ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:136
msgid ""
"both '1' and '2' are merge-bases of A and B.  Neither one is better than the "
"other (both are 'best' merge bases).  When the `--all` option is not given, "
"it is unspecified which best one is output."
msgstr "「1」と「2」はどちらもAとBのマージベースです。どちらももう一方よりも優れているわけではありません（どちらも「最良の」マージベースです）。 `--all` オプションが指定されていない場合、どちらの最良のマージベースが出力されるかは指定されていません。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:141
msgid ""
"A common idiom to check \"fast-forward-ness\" between two commits A and B is "
"(or at least used to be) to compute the merge base between A and B, and "
"check if it is the same as A, in which case, A is an ancestor of B.  You "
"will see this idiom used often in older scripts."
msgstr "2つのコミットAとBの間の「早送り性」(fast-forward-ness)をチェックする、という慣用句は、AとBの間のマージベースを計算し(少なくとも以前はそうでした)、それがAと同一かどうかをチェックすることで、その場合AはBの祖先です。この慣用句は古いスクリプトでよく使用されます。"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:148
#, no-wrap
msgid ""
"A=$(git rev-parse --verify A)\n"
"if test \"$A\" = \"$(git merge-base A B)\"\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""
"A=$(git rev-parse --verify A)\n"
"if test \"$A\" = \"$(git merge-base A B)\"\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:151
msgid "In modern git, you can say this in a more direct way:"
msgstr "現在gitでは、あなたは以下のように、これをより直接的な方法で言うことができます:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:157
#, no-wrap
msgid ""
"if git merge-base --is-ancestor A B\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""
"if git merge-base --is-ancestor A B\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:160
msgid "instead."
msgstr "このように、上記にとって代わります。"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:162
#, no-wrap
msgid "Discussion on fork-point mode"
msgstr "Discussion on fork-point mode"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:168
msgid ""
"After working on the `topic` branch created with `git switch -c topic origin/"
"master`, the history of remote-tracking branch `origin/master` may have been "
"rewound and rebuilt, leading to a history of this shape:"
msgstr "`git switch -c topic origin/master` で作成された `topic` ブランチで作業した後、リモート追跡ブランチ `origin/master` の履歴が巻き戻されて再構築された可能性があり、以下形の履歴につながります:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:177
#, no-wrap
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:184
msgid ""
"where `origin/master` used to point at commits B0, B1, B2 and now it points "
"at B, and your `topic` branch was started on top of it back when `origin/"
"master` was at B0, and you built three commits, D0, D1, and D, on top of "
"it.  Imagine that you now want to rebase the work you did on the topic on "
"top of the updated origin/master."
msgstr "ここで、 `origin/master` はコミットB0、B1、B2を指していましたが、現在はBを指しています。そして、 `origin/master` がB0にあったときに、あなたの `topic` ブランチがその上で開始されました。あなたは、その上に、D0、D1、Dの3つのコミットを作成しました。あなたは更新された origin/master の上に、トピックで行った作業をリベースしたいとします。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:190
msgid ""
"In such a case, `git merge-base origin/master topic` would return the parent "
"of B0 in the above picture, but B0^..D is *not* the range of commits you "
"would want to replay on top of B (it includes B0, which is not what you "
"wrote; it is a commit the other side discarded when it moved its tip from B0 "
"to B1)."
msgstr "このような場合、 `git merge-base origin/master topic` は上の図のB0の親を返しますが、 `B0^..D` はBの上でリプレイしたいコミットの範囲ではありません(これには、あなたが書いたものではないB0が含まれます。これは、先端をB0からB1に移動したときに破棄された自分側で無い側(the other side)のコミットです)。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:198
msgid ""
"`git merge-base --fork-point origin/master topic` is designed to help in "
"such a case.  It takes not only B but also B0, B1, and B2 (i.e. old tips of "
"the remote-tracking branches your repository's reflog knows about) into "
"account to see on which commit your topic branch was built and finds B0, "
"allowing you to replay only the commits on your topic, excluding the commits "
"the other side later discarded."
msgstr "`git merge-base --fork-point origin/master topic` は、このような場合に役立つように設計されています。 Bだけでなく、B0、B1、およびB2も(つまり、リポジトリのreflogが知っているリモート追跡ブランチの古い先端も)考慮に入れて、あなたのtopicブランチが構築されたコミットを確認し、B0を見つけます。これにより、topicのコミットのみをリプレイできます。ただし、自分の側で無い側(the other side)で後で破棄されるコミットは除きます。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:200
msgid "Hence"
msgstr "したがって、以下は"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:202
#, no-wrap
msgid "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"
msgstr "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:204
msgid "will find B0, and"
msgstr "B0 を見つけ、そして"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:206
#, no-wrap
msgid "    $ git rebase --onto origin/master $fork_point topic\n"
msgstr "    $ git rebase --onto origin/master $fork_point topic\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:209
msgid ""
"will replay D0, D1 and D on top of B to create a new history of this shape:"
msgstr "以下の形の新しい履歴を作成するために、B の上で D0 と D1 と D をリプレイします:"

#. type: delimited block .
#: ../Documentation-sedout/git-merge-base.txt:218
#, no-wrap
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:226
msgid ""
"A caveat is that older reflog entries in your repository may be expired by "
"`git gc`.  If B0 no longer appears in the reflog of the remote-tracking "
"branch `origin/master`, the `--fork-point` mode obviously cannot find it and "
"fails, avoiding to give a random and useless result (such as the parent of "
"B0, like the same command without the `--fork-point` option gives)."
msgstr "注意点としては、リポジトリ内の古いreflogエントリが `git gc` によって期限切れになる可能性があることです。 B0がリモート追跡ブランチ `origin/ master` のreflogに表示されなくなった場合、`--fork-point` モードは明らかにそれを見つけることができず失敗し、ランダムで役に立たない結果(`--fork-point` オプション無しの同じコマンドが返すB0の親など)を与えることを避けます。"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:237
msgid ""
"Also, the remote-tracking branch you use the `--fork-point` mode with must "
"be the one your topic forked from its tip.  If you forked from an older "
"commit than the tip, this mode would not find the fork point (imagine in the "
"above sample history B0 did not exist, origin/master started at B1, moved to "
"B2 and then B, and you forked your topic at origin/master^ when origin/"
"master was B1; the shape of the history would be the same as above, without "
"B0, and the parent of B1 is what `git merge-base origin/master topic` "
"correctly finds, but the `--fork-point` mode will not, because it is not one "
"of the commits that used to be at the tip of origin/master)."
msgstr "また、 `--fork-point` モードを使用するリモート追跡ブランチは、あなたのトピックがその先端から分岐したものである必要があります。先端よりも古いコミットからフォークした場合、このモードではフォークポイントが見つかりません。(上記の履歴例でB0が存在せず、 origin/master がB1で始まり、B2、次にBに移動し、 origin/master がB1のときに、 `origin/master^` でトピックをフォークしたと想像してください。履歴の形は上記と同じですが、B0はありません。B1の親は、 `git merge-base origin/master topic` が正しく検出するものですが、 `--fork-point` モードは検出しません。なぜなら origin/master の先端にあったコミットの1つではないためです。）"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:240
#, no-wrap
msgid "See also"
msgstr "See also"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:244
msgid ""
"linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"
msgstr "linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"

#. type: Title -
#: ../Documentation-sedout/git-merge-base.txt:246
#, no-wrap
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: ../Documentation-sedout/git-merge-base.txt:247
msgid "Part of the linkgit:git[1] suite"
msgstr "Part of the linkgit:git[1] suite"
