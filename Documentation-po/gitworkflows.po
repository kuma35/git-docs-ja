# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-01 00:25+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation/gitworkflows.txt:2
#, no-wrap
msgid "gitworkflows(7)"
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:5
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:7
msgid "gitworkflows - An overview of recommended workflows with Git"
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:9
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:12
#, no-wrap
msgid "git *\n"
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:15
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:21
msgid ""
"This document attempts to write down and motivate some of the workflow "
"elements used for `git.git` itself.  Many ideas apply in general, though the "
"full workflow is rarely required for smaller projects with fewer people "
"involved."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:26
msgid ""
"We formulate a set of 'rules' for quick reference, while the prose tries to "
"motivate each of them.  Do not always take them literally; you should value "
"good reasons for your actions higher than manpages such as this one."
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:29
#, no-wrap
msgid "SEPARATE CHANGES"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:37
msgid ""
"As a general rule, you should try to split your changes into small logical "
"steps, and commit each of them.  They should be consistent, working "
"independently of any later commits, pass the test suite, etc.  This makes "
"the review process much easier, and the history much more useful for later "
"inspection and analysis, for example with linkgit:git-blame[1] and "
"linkgit:git-bisect[1]."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:46
msgid ""
"To achieve this, try to split your work into small steps from the very "
"beginning. It is always easier to squash a few commits together than to "
"split one big commit into several.  Don't be afraid of making too small or "
"imperfect steps along the way. You can always go back later and edit the "
"commits with `git rebase --interactive` before you publish them.  You can "
"use `git stash push --keep-index` to run the test suite independent of other "
"uncommitted changes; see the EXAMPLES section of linkgit:git-stash[1]."
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:49
#, no-wrap
msgid "MANAGING BRANCHES"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:54
msgid ""
"There are two main tools that can be used to include changes from one branch "
"on another: linkgit:git-merge[1] and linkgit:git-cherry-pick[1]."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:58
msgid ""
"Merges have many advantages, so we try to solve as many problems as possible "
"with merges alone.  Cherry-picking is still occasionally useful; see "
"\"Merging upwards\" below for an example."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:66
msgid ""
"Most importantly, merging works at the branch level, while cherry-picking "
"works at the commit level.  This means that a merge can carry over the "
"changes from 1, 10, or 1000 commits with equal ease, which in turn means the "
"workflow scales much better to a large number of contributors (and "
"contributions).  Merges are also easier to understand because a merge commit "
"is a \"promise\" that all changes from all its parents are now included."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:69
msgid ""
"There is a tradeoff of course: merges require a more careful branch "
"management.  The following subsections discuss the important points."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:72
#, no-wrap
msgid "Graduation"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:77
msgid ""
"As a given feature goes from experimental to stable, it also \"graduates\" "
"between the corresponding branches of the software.  `git.git` uses the "
"following 'integration branches':"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:80
msgid ""
"'maint' tracks the commits that should go into the next \"maintenance "
"release\", i.e., update of the last released stable version;"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:82
msgid "'master' tracks the commits that should go into the next release;"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:85
msgid ""
"'next' is intended as a testing branch for topics being tested for stability "
"for master."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:87
msgid "There is a fourth official branch that is used slightly differently:"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:91
msgid ""
"'seen' (patches seen by the maintainer) is an integration branch for things "
"that are not quite ready for inclusion yet (see \"Integration Branches\" "
"below)."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:94
msgid ""
"Each of the four branches is usually a direct descendant of the one above "
"it."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:98
msgid ""
"Conceptually, the feature enters at an unstable branch (usually 'next' or "
"'seen'), and \"graduates\" to 'master' for the next release once it is "
"considered stable enough."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:101
#, no-wrap
msgid "Merging upwards"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:106
msgid ""
"The \"downwards graduation\" discussed above cannot be done by actually "
"merging downwards, however, since that would merge 'all' changes on the "
"unstable branch into the stable one.  Hence the following:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:107
#, no-wrap
msgid "Merge upwards"
msgstr ""

#. type: Named 'caption' AttributeList argument for style 'caption'
#: ../Documentation/gitworkflows.txt:108 ../Documentation/gitworkflows.txt:139 ../Documentation/gitworkflows.txt:172 ../Documentation/gitworkflows.txt:200
#, no-wrap
msgid "Rule: "
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:113
msgid ""
"Always commit your fixes to the oldest supported branch that requires them.  "
"Then (periodically) merge the integration branches upwards into each other."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:120
msgid ""
"This gives a very controlled flow of fixes.  If you notice that you have "
"applied a fix to e.g. 'master' that is also required in 'maint', you will "
"need to cherry-pick it (using linkgit:git-cherry-pick[1])  downwards.  This "
"will happen a few times and is nothing to worry about unless you do it very "
"frequently."
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:123 ../Documentation/gitworkflows.txt:138
#, no-wrap
msgid "Topic branches"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:127
msgid ""
"Any nontrivial feature will require several patches to implement, and may "
"get extra bugfixes or improvements during its lifetime."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:133
msgid ""
"Committing everything directly on the integration branches leads to many "
"problems: Bad commits cannot be undone, so they must be reverted one by one, "
"which creates confusing histories and further error potential when you "
"forget to revert part of a group of changes.  Working in parallel mixes up "
"the changes, creating further confusion."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:137
msgid ""
"Use of \"topic branches\" solves these problems.  The name is pretty self "
"explanatory, with a caveat that comes from the \"merge upwards\" rule above:"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:144
msgid ""
"Make a side branch for every topic (feature, bugfix, ...). Fork it off at "
"the oldest integration branch that you will eventually want to merge it "
"into."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:147
msgid "Many things can then be done very naturally:"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:154
msgid ""
"To get the feature/bugfix into an integration branch, simply merge it.  If "
"the topic has evolved further in the meantime, merge again.  (Note that you "
"do not necessarily have to merge it to the oldest integration branch first.  "
"For example, you can first merge a bugfix to 'next', give it some testing "
"time, and merge to 'maint' when you know it is stable.)"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:158
msgid ""
"If you find you need new features from the branch 'other' to continue "
"working on your topic, merge 'other' to 'topic'.  (However, do not do this "
"\"just habitually\", see below.)"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:161
msgid ""
"If you find you forked off the wrong branch and want to move it \"back in "
"time\", use linkgit:git-rebase[1]."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:165
msgid ""
"Note that the last point clashes with the other two: a topic that has been "
"merged elsewhere should not be rebased.  See the section on RECOVERING FROM "
"UPSTREAM REBASE in linkgit:git-rebase[1]."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:169
msgid ""
"We should point out that \"habitually\" (regularly for no real reason)  "
"merging an integration branch into your topics -- and by extension, merging "
"anything upstream into anything downstream on a regular basis"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:170
msgid "is frowned upon:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:171
#, no-wrap
msgid "Merge to downstream only at well-defined points"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:177
msgid ""
"Do not merge to downstream except with a good reason: upstream API changes "
"affect your branch; your branch no longer merges to upstream cleanly; etc."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:185
msgid ""
"Otherwise, the topic that was merged to suddenly contains more than a single "
"(well-separated) change.  The many resulting small merges will greatly "
"clutter up history.  Anyone who later investigates the history of a file "
"will have to find out whether that merge affected the topic in development.  "
"An upstream might even inadvertently be merged into a \"more stable\" "
"branch.  And so on."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:188
#, no-wrap
msgid "Throw-away integration"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:195
msgid ""
"If you followed the last paragraph, you will now have many small topic "
"branches, and occasionally wonder how they interact.  Perhaps the result of "
"merging them does not even work? But on the other hand, we want to avoid "
"merging them anywhere \"stable\" because such merges cannot easily be "
"undone."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:198
msgid ""
"The solution, of course, is to make a merge that we can undo: merge into a "
"throw-away branch."
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:199
#, no-wrap
msgid "Throw-away integration branches"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:204
msgid ""
"To test the interaction of several topics, merge them into a throw-away "
"branch.  You must never base any work on such a branch!"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:211
msgid ""
"If you make it (very) clear that this branch is going to be deleted right "
"after the testing, you can even publish this branch, for example to give the "
"testers a chance to work with it, or other developers a chance to see if "
"their in-progress work will be compatible.  `git.git` has such an official "
"throw-away integration branch called 'seen'."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:214
#, no-wrap
msgid "Branch management for a release"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:219
msgid ""
"Assuming you are using the merge approach discussed above, when you are "
"releasing your project you will need to do some additional branch management "
"work."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:222
msgid ""
"A feature release is created from the 'master' branch, since 'master' tracks "
"the commits that should go into the next feature release."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:227
msgid ""
"The 'master' branch is supposed to be a superset of 'maint'. If this "
"condition does not hold, then 'maint' contains some commits that are not "
"included on 'master'. The fixes represented by those commits will therefore "
"not be included in your feature release."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:229
msgid "To verify that 'master' is indeed a superset of 'maint', use git log:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:230
#, no-wrap
msgid "Verify 'master' is a superset of 'maint'"
msgstr ""

#. type: Named 'caption' AttributeList argument for style 'caption'
#: ../Documentation/gitworkflows.txt:231 ../Documentation/gitworkflows.txt:243 ../Documentation/gitworkflows.txt:273 ../Documentation/gitworkflows.txt:282 ../Documentation/gitworkflows.txt:302 ../Documentation/gitworkflows.txt:369 ../Documentation/gitworkflows.txt:383 ../Documentation/gitworkflows.txt:404 ../Documentation/gitworkflows.txt:426 ../Documentation/gitworkflows.txt:441 ../Documentation/gitworkflows.txt:455
#, no-wrap
msgid "Recipe: "
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:234
msgid "`git log master..maint`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:238
msgid ""
"This command should not list any commits.  Otherwise, check out 'master' and "
"merge 'maint' into it."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:241
msgid ""
"Now you can proceed with the creation of the feature release. Apply a tag to "
"the tip of 'master' indicating the release version:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:242
#, no-wrap
msgid "Release tagging"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:246
msgid "`git tag -s -m \"Git X.Y.Z\" vX.Y.Z master`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:253
msgid ""
"You need to push the new tag to a public Git server (see \"DISTRIBUTED "
"WORKFLOWS\" below). This makes the tag available to others tracking your "
"project. The push could also trigger a post-update hook to perform "
"release-related items such as building release tarballs and preformatted "
"documentation pages."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:257
msgid ""
"Similarly, for a maintenance release, 'maint' is tracking the commits to be "
"released. Therefore, in the steps above simply tag and push 'maint' rather "
"than 'master'."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:260
#, no-wrap
msgid "Maintenance branch management after a feature release"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:263
msgid "After a feature release, you need to manage your maintenance branches."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:267
msgid ""
"First, if you wish to continue to release maintenance fixes for the feature "
"release made before the recent one, then you must create another branch to "
"track commits for that previous release."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:271
msgid ""
"To do this, the current maintenance branch is copied to another branch named "
"with the previous release version number (e.g. maint-X.Y.(Z-1)  where X.Y.Z "
"is the current release)."
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:272
#, no-wrap
msgid "Copy maint"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:276
msgid "`git branch maint-X.Y.(Z-1) maint`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:280
msgid ""
"The 'maint' branch should now be fast-forwarded to the newly released code "
"so that maintenance fixes can be tracked for the current release:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:281
#, no-wrap
msgid "Update maint to new release"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:285
msgid "`git checkout maint`"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:286
msgid "`git merge --ff-only master`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:292
msgid ""
"If the merge fails because it is not a fast-forward, then it is possible "
"some fixes on 'maint' were missed in the feature release.  This will not "
"happen if the content of the branches was verified as described in the "
"previous section."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:295
#, no-wrap
msgid "Branch management for next and seen after a feature release"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:300
msgid ""
"After a feature release, the integration branch 'next' may optionally be "
"rewound and rebuilt from the tip of 'master' using the surviving topics on "
"'next':"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:301
#, no-wrap
msgid "Rewind and rebuild next"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:305
msgid "`git switch -C next master`"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:306
msgid "`git merge ai/topic_in_next1`"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:307
msgid "`git merge ai/topic_in_next2`"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:308
msgid "..."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:318
msgid ""
"The advantage of doing this is that the history of 'next' will be clean. For "
"example, some topics merged into 'next' may have initially looked promising, "
"but were later found to be undesirable or premature.  In such a case, the "
"topic is reverted out of 'next' but the fact remains in the history that it "
"was once merged and reverted. By recreating 'next', you give another "
"incarnation of such topics a clean slate to retry, and a feature release is "
"a good point in history to do so."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:321
msgid ""
"If you do this, then you should make a public announcement indicating that "
"'next' was rewound and rebuilt."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:325
msgid ""
"The same rewind and rebuild process may be followed for 'seen'. A public "
"announcement is not necessary since 'seen' is a throw-away branch, as "
"described above."
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:328
#, no-wrap
msgid "DISTRIBUTED WORKFLOWS"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:333
msgid ""
"After the last section, you should know how to manage topics.  In general, "
"you will not be the only person working on the project, so you will have to "
"share your work."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:339
msgid ""
"Roughly speaking, there are two important workflows: merge and patch.  The "
"important difference is that the merge workflow can propagate full history, "
"including merges, while patches cannot.  Both workflows can be used in "
"parallel: in `git.git`, only subsystem maintainers use the merge workflow, "
"while everyone else sends patches."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:344
msgid ""
"Note that the maintainer(s) may impose restrictions, such as "
"\"Signed-off-by\" requirements, that all commits/patches submitted for "
"inclusion must adhere to.  Consult your project's documentation for more "
"information."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:347
#, no-wrap
msgid "Merge workflow"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:352
msgid ""
"The merge workflow works by copying branches between upstream and "
"downstream.  Upstream can merge contributions into the official history; "
"downstream base their work on the official history."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:354
msgid "There are three main tools that can be used for this:"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:357
msgid ""
"linkgit:git-push[1] copies your branches to a remote repository, usually to "
"one that can be read by all involved parties;"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:360
msgid "linkgit:git-fetch[1] that copies remote branches to your repository; and"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:362
msgid "linkgit:git-pull[1] that does fetch and merge in one go."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:365
msgid ""
"Note the last point.  Do 'not' use 'git pull' unless you actually want to "
"merge the remote branch."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:367
msgid "Getting changes out is easy:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:368
#, no-wrap
msgid "Push/pull: Publishing branches/topics"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:373
msgid "`git push <remote> <branch>` and tell everyone where they can fetch from."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:378
msgid ""
"You will still have to tell people by other means, such as mail.  (Git "
"provides the linkgit:git-request-pull[1] to send preformatted pull requests "
"to upstream maintainers to simplify this task.)"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:381
msgid ""
"If you just want to get the newest copies of the integration branches, "
"staying up to date is easy too:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:382
#, no-wrap
msgid "Push/pull: Staying up to date"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:386
msgid "Use `git fetch <remote>` or `git remote update` to stay up to date."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:390
msgid ""
"Then simply fork your topic branches from the stable remotes as explained "
"earlier."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:394
msgid ""
"If you are a maintainer and would like to merge other people's topic "
"branches to the integration branches, they will typically send a request to "
"do so by mail.  Such a request looks like"
msgstr ""

#. type: delimited block -
#: ../Documentation/gitworkflows.txt:398
#, no-wrap
msgid ""
"Please pull from\n"
"    <url> <branch>\n"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:402
msgid "In that case, 'git pull' can do the fetch and merge in one go, as follows."
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:403
#, no-wrap
msgid "Push/pull: Merging remote topics"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:407
msgid "`git pull <url> <branch>`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:414
msgid ""
"Occasionally, the maintainer may get merge conflicts when they try to pull "
"changes from downstream.  In this case, they can ask downstream to do the "
"merge and resolve the conflicts themselves (perhaps they will know better "
"how to resolve them).  It is one of the rare cases where downstream 'should' "
"merge from upstream."
msgstr ""

#. type: Title ~
#: ../Documentation/gitworkflows.txt:417
#, no-wrap
msgid "Patch workflow"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:424
msgid ""
"If you are a contributor that sends changes upstream in the form of emails, "
"you should use topic branches as usual (see above).  Then use "
"linkgit:git-format-patch[1] to generate the corresponding emails (highly "
"recommended over manually formatting them because it makes the maintainer's "
"life easier)."
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:425
#, no-wrap
msgid "format-patch/am: Publishing branches/topics"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:430
msgid ""
"`git format-patch -M upstream..topic` to turn them into preformatted patch "
"files"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:431
msgid "`git send-email --to=<recipient> <patches>`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:435
msgid ""
"See the linkgit:git-format-patch[1] and linkgit:git-send-email[1] manpages "
"for further usage notes."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:439
msgid ""
"If the maintainer tells you that your patch no longer applies to the current "
"upstream, you will have to rebase your topic (you cannot use a merge because "
"you cannot format-patch merges):"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:440
#, no-wrap
msgid "format-patch/am: Keeping topics up to date"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:444
msgid "`git pull --rebase <url> <branch>`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:449
msgid ""
"You can then fix the conflicts during the rebase.  Presumably you have not "
"published your topic other than by mail, so rebasing it is not a problem."
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:453
msgid ""
"If you receive such a patch series (as maintainer, or perhaps as a reader of "
"the mailing list it was sent to), save the mails to files, create a new "
"topic branch and use 'git am' to import the commits:"
msgstr ""

#. type: Block title
#: ../Documentation/gitworkflows.txt:454
#, no-wrap
msgid "format-patch/am: Importing patches"
msgstr ""

#. type: delimited block =
#: ../Documentation/gitworkflows.txt:458
msgid "`git am < patch`"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:464
msgid ""
"One feature worth pointing out is the three-way merge, which can help if you "
"get conflicts: `git am -3` will use index information contained in patches "
"to figure out the merge base.  See linkgit:git-am[1] for other options."
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:467
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:476
msgid ""
"linkgit:gittutorial[7], linkgit:git-push[1], linkgit:git-pull[1], "
"linkgit:git-merge[1], linkgit:git-rebase[1], linkgit:git-format-patch[1], "
"linkgit:git-send-email[1], linkgit:git-am[1]"
msgstr ""

#. type: Title -
#: ../Documentation/gitworkflows.txt:478
#, no-wrap
msgid "GIT"
msgstr ""

#. type: Plain text
#: ../Documentation/gitworkflows.txt:479
msgid "Part of the linkgit:git[1] suite"
msgstr ""
