# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 05:36+0900\n"
"PO-Revision-Date: 2022-07-05 19:42+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:12
#, no-wrap
msgid ""
"From:\tJunio C Hamano <gitster@pobox.com>\n"
"To:\tgit@vger.kernel.org\n"
"Cc:\tPetr Baudis <pasky@suse.cz>, Linus Torvalds <torvalds@osdl.org>\n"
"Subject: Re: sending changesets from the middle of a git tree\n"
"Date:\tSun, 14 Aug 2005 18:37:39 -0700\n"
"Abstract: In this article, JC talks about how he rebases the\n"
" public \"seen\" branch using the core Git tools when he updates\n"
" the \"master\" branch, and how \"rebase\" works.  Also discussed\n"
" is how this applies to individual developers who sends patches\n"
" upstream.\n"
"Content-type: text/asciidoc\n"
msgstr ""
"From:\tJunio C Hamano <gitster@pobox.com>\n"
"To:\tgit@vger.kernel.org\n"
"Cc:\tPetr Baudis <pasky@suse.cz>, Linus Torvalds <torvalds@osdl.org>\n"
"Subject: Re: sending changesets from the middle of a git tree\n"
"Date:\tSun, 14 Aug 2005 18:37:39 -0700\n"
"Abstract: この記事では、JCが `master` ブランチを更新するときに\n"
" コアGitツールを使用してパブリック `seen` ブランチを\n"
" リベースする方法と、 `rebase` がどのように機能するかについて\n"
" 説明します。 また、パッチをアップストリームに送信する個々の\n"
" 開発者に、これがどのように適用されるかについても説明します。 \n"
"Content-type: text/asciidoc\n"

#. type: Title =
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:14
#, no-wrap
msgid "How to rebase from an internal branch"
msgstr "How to rebase from an internal branch"

#. type: delimited block -
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:18
#, no-wrap
msgid "Petr Baudis <pasky@suse.cz> writes:\n"
msgstr "Petr Baudis <pasky@suse.cz> writes:\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:27
#, no-wrap
msgid ""
"> Dear diary, on Sun, Aug 14, 2005 at 09:57:13AM CEST, I got a letter\n"
"> where Junio C Hamano <junkio@cox.net> told me that...\n"
">> Linus Torvalds <torvalds@osdl.org> writes:\n"
">>\n"
">> > Junio, maybe you want to talk about how you move patches from your\n"
">> > \"seen\" branch to the real branches.\n"
">>\n"
"> Actually, wouldn't this be also precisely for what StGIT is intended to?\n"
msgstr ""
"> Dear diary, on Sun, Aug 14, 2005 at 09:57:13AM CEST, I got a letter\n"
"> where Junio C Hamano <junkio@cox.net> told me that...\n"
">> Linus Torvalds <torvalds@osdl.org> writes:\n"
">>\n"
">> > Junioさん、「seen」ブランチから実際のブランチにパッチを移動させる\n"
">> > 方法についてお話いただけますか？\n"
">>\n"
"> 実際、これもStGITが意図していることにぴったり当てはまるのではないでしょうか？\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:32
msgid ""
"Exactly my feeling.  I was sort of waiting for Catalin to speak up.  With "
"its basing philosophical ancestry on quilt, this is the kind of task StGIT "
"is designed to do."
msgstr "まさに私の思っている通りの事です。私は Catalin が声を上げるのを(ちょっと)待っていました。 quilt を哲学的な祖先とする StGIT は、このような作業を行うために設計されているのです。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:35
msgid ""
"I just have done a simpler one, this time using only the core Git tools."
msgstr "今回は、Gitのコアツールだけを使った、よりシンプルなものを作ってみました。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:40
msgid ""
"I had a handful of commits that were ahead of master in 'seen', and I wanted "
"to add some documentation bypassing my usual habit of placing new things in "
"'seen' first.  At the beginning, the commit ancestry graph looked like this:"
msgstr "`seen` で `master` よりも進んでいるコミットがひと握りほどあり、 私は `seen` で新しいものを最初に配置するという通常の習慣をバイパスして、いくつかのドキュメントを追加したいと思いました。 当初、コミットの家系図は以下のようになっていました:"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:43
#, no-wrap
msgid ""
"\t\t\t     *\"seen\" head\n"
"    master --> #1 --> #2 --> #3\n"
msgstr ""
"\t\t\t     *\"seen\" head\n"
"    master --> #1 --> #2 --> #3\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:45
msgid "So I started from master, made a bunch of edits, and committed:"
msgstr "それで、私は master から始めて、たくさんの編集をして、そしてコミットしました:"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:50
#, no-wrap
msgid ""
"    $ git checkout master\n"
"    $ cd Documentation; ed git.txt ...\n"
"    $ cd ..; git add Documentation/*.txt\n"
"    $ git commit -s\n"
msgstr ""
"    $ git checkout master\n"
"    $ cd Documentation; ed git.txt ...\n"
"    $ cd ..; git add Documentation/*.txt\n"
"    $ git commit -s\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:52
msgid "After the commit, the ancestry graph would look like this:"
msgstr "コミット後、家系図は以下のようになっています:"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:57
#, no-wrap
msgid ""
"\t\t\t      *\"seen\" head\n"
"    master^ --> #1 --> #2 --> #3\n"
"          \\\n"
"            \\---> master\n"
msgstr ""
"\t\t\t      *\"seen\" head\n"
"    master^ --> #1 --> #2 --> #3\n"
"          \\\n"
"            \\---> master\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:60
msgid ""
"The old master is now master^ (the first parent of the master).  The new "
"master commit holds my documentation updates."
msgstr "古い masterは 現在の `master^`(masterの最初の親)になりました。 新しい master のコミットは、ドキュメントの更新を保持しています。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:62
msgid "Now I have to deal with \"seen\" branch."
msgstr "いまや、私は「seen」ブランチへの対処をしなければなりません。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:76
msgid ""
"This is the kind of situation I used to have all the time when Linus was the "
"maintainer and I was a contributor, when you look at \"master\" branch being "
"the \"maintainer\" branch, and \"seen\" branch being the \"contributor\" "
"branch.  Your work started at the tip of the \"maintainer\" branch some time "
"ago, you made a lot of progress in the meantime, and now the maintainer "
"branch has some other commits you do not have yet.  And \"git rebase\" was "
"written with the explicit purpose of helping to maintain branches like \"seen"
"\".  You _could_ merge master to 'seen' and keep going, but if you "
"eventually want to cherrypick and merge some but not necessarily all changes "
"back to the master branch, it often makes later operations for _you_ easier "
"if you rebase (i.e. carry forward your changes) \"seen\" rather than merge.  "
"So I ran \"git rebase\":"
msgstr "Linusがメンテナーであり、私がコントリビューターであったとき、「master」ブランチは「maintainer」ブランチであり、「seen」ブランチが「contributor」ブランチであるという状況でした。 あなた作業の少し前に「maintainer」ブランチの先端で始まり、その後沢山の作業を進めました。そして今、 maintainer にはまだあなたが持っていない他のコミットがいくつかあります。 そして、「git rebase」は、「seen」のようなブランチの維持を支援するという明確な目的で書かれました。 master を「seen」にマージして続行することも可能ですが、最終的に一部の変更を master ブランチにマージして戻す場合は、マージするのではなく `seen` をリベースする(つまり、あなたの変更を繰り越す)と、その後のあなたの操作が簡単になることがよくあります。 だから私は「git rebase」を実行しました:"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:79
#, no-wrap
msgid ""
"    $ git checkout seen\n"
"    $ git rebase master seen\n"
msgstr ""
"    $ git checkout seen\n"
"    $ git rebase master seen\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:83
msgid ""
"What this does is to pick all the commits since the current branch (note "
"that I now am on \"seen\" branch) forked from the master branch, and forward "
"port these changes."
msgstr "これは、masterブランチからフォークされた現在のブランチ(現在、私は「seen」ブランチにいることに注意してください)以降のすべてのコミットを選択し、これらの変更を転送することです。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:87
#, no-wrap
msgid ""
"    master^ --> #1 --> #2 --> #3\n"
"\t  \\                                  *\"seen\" head\n"
"            \\---> master --> #1' --> #2' --> #3'\n"
msgstr ""
"    master^ --> #1 --> #2 --> #3\n"
"\t  \\                                  *\"seen\" head\n"
"            \\---> master --> #1' --> #2' --> #3'\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:92
msgid ""
"The diff between master^ and #1 is applied to master and committed to create "
"#1' commit with the commit information (log, author and date) taken from "
"commit #1.  On top of that #2' and #3' commits are made similarly out of #2 "
"and #3 commits."
msgstr "`master^` と #1  の diff は master に適用され、コミット #1 から取得したコミット情報(ログ、作成者、日付)を使用して `#1'` コミットを作成するようにコミットされます。 その上で、 `#2'` と `#3'` コミットは、 #2 と #3 のコミットから同様に行われます。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:97
msgid ""
"Old #3 is not recorded in any of the .git/refs/heads/ file anymore, so after "
"doing this you will have dangling commit if you ran fsck-cache, which is "
"normal.  After testing \"seen\", you can run \"git prune\" to get rid of "
"those original three commits."
msgstr "古い #3 は `.git/refs/heads/` ファイルのいずれにも記録されなくなったため、これを実行した後、fsck-cache を実行すると、宙ぶらりんコミット(dangling commit)が発生します。これは正常です。 「seen」をテストした後、「git prune」を実行して、元の3つのコミットを取り除くことができます。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:100
msgid ""
"While I am talking about \"git rebase\", I should talk about how to do "
"cherrypicking using only the core Git tools."
msgstr "「git rebase」について話すにあたって、コアGitツールのみを使用してチェリーピッキングを行う方法について話しておきましょう。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:102
msgid "Let's go back to the earlier picture, with different labels."
msgstr "以前の図に戻りましょう。でも、ラベルは以前と異なります。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:105
msgid ""
"You, as an individual developer, cloned upstream repository and made a "
"couple of commits on top of it."
msgstr "あなたは個人開発者として、上流のリポジトリをクローンし、そのリポジトリでいくつかのコミットを行いました。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:108
#, no-wrap
msgid ""
"                              *your \"master\" head\n"
"   upstream --> #1 --> #2 --> #3\n"
msgstr ""
"                              *your \"master\" head\n"
"   upstream --> #1 --> #2 --> #3\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:112
msgid ""
"You would want changes #2 and #3 incorporated in the upstream, while you "
"feel that #1 may need further improvements.  So you prepare #2 and #3 for e-"
"mail submission."
msgstr "あなたは、変更 #2 と #3 をアップストリームに組み込む必要がありますが、 あなたは #1 には更に改善が必要だと思いました。 したがって、あなたは電子メール送信用に #2 と #3 を準備します。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:114
#, no-wrap
msgid "    $ git format-patch master^^ master\n"
msgstr "    $ git format-patch master^^ master\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:121
msgid ""
"This creates two files, 0001-XXXX.patch and 0002-XXXX.patch.  Send them out "
"\"To: \" your project maintainer and \"Cc: \" your mailing list.  You could "
"use contributed script git-send-email if your host has necessary perl "
"modules for this, but your usual MUA would do as long as it does not corrupt "
"whitespaces in the patch."
msgstr "これにより、 0001-XXXX.patch と 0002-XXXX.patch の2つのファイルが作成されます。 それらを \"To: \" であなたのプロジェクトメンテナと、\"Cc: \" であなたのメーリングリストに送信します。 ホストにこれに必要なperlモジュールがある場合は、提供されたスクリプト git-send-email を使用できますが、パッチ内の空白(whitespaces)が破損しない限り、あなたは通常のMUAを使用できます。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:124
msgid ""
"Then you would wait, and you find out that the upstream picked up your "
"changes, along with other changes."
msgstr "それからしばらく待つと、あなたは、アップストリームが他の変更とともにあなたの変更を取得したことが分かります。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:130
#, no-wrap
msgid ""
"   where                      *your \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C\n"
"                                                *upstream head\n"
msgstr ""
"   where                      *your \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C\n"
"                                                *upstream head\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:136
msgid ""
"The two commits #2' and #3' in the above picture record the same changes "
"your e-mail submission for #2 and #3 contained, but probably with the new "
"sign-off line added by the upstream maintainer and definitely with different "
"committer and ancestry information, they are different objects from #2 and "
"#3 commits."
msgstr "上の図の2つのコミット `#2'` と  `#3'` は、 #2 と #3 を含む電子メール送信に同一の変更を記録しますが、おそらく上流のメンテナによって追加された新しい sign-off 行と、間違いなく異なるコミッター名と家系情報(ancestry information)があり、それらは #2 と #3 のコミットとは異なるオブジェクトです。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:138
msgid "You fetch from upstream, but not merge."
msgstr "あなたはアップストリームからフェッチしますが、マージはしません。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:140
#, no-wrap
msgid "    $ git fetch upstream\n"
msgstr "    $ git fetch upstream\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:144
msgid ""
"This leaves the updated upstream head in .git/FETCH_HEAD but does not touch "
"your .git/HEAD or .git/refs/heads/master.  You run \"git rebase\" now."
msgstr "これにより、更新されたアップストリームヘッドは .git/FETCH_HEAD に残りますが、 .git/HEAD または .git/refs/heads/master には影響しません。 ここで「git rebase」を実行します。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:146
#, no-wrap
msgid "    $ git rebase FETCH_HEAD master\n"
msgstr "    $ git rebase FETCH_HEAD master\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:152
msgid ""
"Earlier, I said that rebase applies all the commits from your branch on top "
"of the upstream head.  Well, I lied.  \"git rebase\" is a bit smarter than "
"that and notices that #2 and #3 need not be applied, so it only applies #1.  "
"The commit ancestry graph becomes something like this:"
msgstr "以前、私は、リベースはブランチからのすべてのコミットをアップストリームヘッドの上に適用すると言いました。 ええと、それは嘘です。「git rebase」はそれよりも少し賢く、 #2 と #3 を適用する必要がないので、 #1 のみを適用します。 コミットの家系図は以下のようになります:"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:159
#, no-wrap
msgid ""
"   where                     *your old \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\                      your new \"master\" head*\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C --> #1'\n"
"                                                *upstream\n"
"                                                head\n"
msgstr ""
"   where                     *your old \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\                      your new \"master\" head*\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C --> #1'\n"
"                                                *upstream\n"
"                                                head\n"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:163
msgid ""
"Again, \"git prune\" would discard the disused commits #1-#3 and you "
"continue on starting from the new \"master\" head, which is the #1' commit."
msgstr "繰り返しになりますが、「git prune」は、使用されなくなったコミット #1〜#3 を破棄し、新しい「master」ヘッド(`#1'` コミット)から開始し、続けます。"

#. type: Plain text
#: ../Documentation-sedout/howto/rebase-from-internal-branch.txt:164
msgid "-jc"
msgstr "-jc"
