# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-02 01:07+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:12
#, no-wrap
msgid ""
"From:\tJunio C Hamano <gitster@pobox.com>\n"
"To:\tgit@vger.kernel.org\n"
"Cc:\tPetr Baudis <pasky@suse.cz>, Linus Torvalds <torvalds@osdl.org>\n"
"Subject: Re: sending changesets from the middle of a git tree\n"
"Date:\tSun, 14 Aug 2005 18:37:39 -0700\n"
"Abstract: In this article, JC talks about how he rebases the\n"
" public \"seen\" branch using the core Git tools when he updates\n"
" the \"master\" branch, and how \"rebase\" works.  Also discussed\n"
" is how this applies to individual developers who sends patches\n"
" upstream.\n"
"Content-type: text/asciidoc\n"
msgstr ""

#. type: Title =
#: ../Documentation/howto/rebase-from-internal-branch.txt:14
#, no-wrap
msgid "How to rebase from an internal branch"
msgstr ""

#. type: delimited block -
#: ../Documentation/howto/rebase-from-internal-branch.txt:18
#, no-wrap
msgid "Petr Baudis <pasky@suse.cz> writes:\n"
msgstr ""

#. type: delimited block -
#: ../Documentation/howto/rebase-from-internal-branch.txt:27
#, no-wrap
msgid ""
"> Dear diary, on Sun, Aug 14, 2005 at 09:57:13AM CEST, I got a letter\n"
"> where Junio C Hamano <junkio@cox.net> told me that...\n"
">> Linus Torvalds <torvalds@osdl.org> writes:\n"
">>\n"
">> > Junio, maybe you want to talk about how you move patches from your\n"
">> > \"seen\" branch to the real branches.\n"
">>\n"
"> Actually, wouldn't this be also precisely for what StGIT is intended to?\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:32
msgid ""
"Exactly my feeling.  I was sort of waiting for Catalin to speak up.  With "
"its basing philosophical ancestry on quilt, this is the kind of task StGIT "
"is designed to do."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:35
msgid "I just have done a simpler one, this time using only the core Git tools."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:40
msgid ""
"I had a handful of commits that were ahead of master in 'seen', and I wanted "
"to add some documentation bypassing my usual habit of placing new things in "
"'seen' first.  At the beginning, the commit ancestry graph looked like this:"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:43
#, no-wrap
msgid ""
"\t\t\t     *\"seen\" head\n"
"    master --> #1 --> #2 --> #3\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:45
msgid "So I started from master, made a bunch of edits, and committed:"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:50
#, no-wrap
msgid ""
"    $ git checkout master\n"
"    $ cd Documentation; ed git.txt ...\n"
"    $ cd ..; git add Documentation/*.txt\n"
"    $ git commit -s\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:52
msgid "After the commit, the ancestry graph would look like this:"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:57
#, no-wrap
msgid ""
"\t\t\t      *\"seen\" head\n"
"    master^ --> #1 --> #2 --> #3\n"
"          \\\n"
"            \\---> master\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:60
msgid ""
"The old master is now master^ (the first parent of the master).  The new "
"master commit holds my documentation updates."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:62
msgid "Now I have to deal with \"seen\" branch."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:76
msgid ""
"This is the kind of situation I used to have all the time when Linus was the "
"maintainer and I was a contributor, when you look at \"master\" branch being "
"the \"maintainer\" branch, and \"seen\" branch being the \"contributor\" "
"branch.  Your work started at the tip of the \"maintainer\" branch some time "
"ago, you made a lot of progress in the meantime, and now the maintainer "
"branch has some other commits you do not have yet.  And \"git rebase\" was "
"written with the explicit purpose of helping to maintain branches like "
"\"seen\".  You _could_ merge master to 'seen' and keep going, but if you "
"eventually want to cherrypick and merge some but not necessarily all changes "
"back to the master branch, it often makes later operations for _you_ easier "
"if you rebase (i.e. carry forward your changes) \"seen\" rather than merge.  "
"So I ran \"git rebase\":"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:79
#, no-wrap
msgid ""
"    $ git checkout seen\n"
"    $ git rebase master seen\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:83
msgid ""
"What this does is to pick all the commits since the current branch (note "
"that I now am on \"seen\" branch) forked from the master branch, and forward "
"port these changes."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:87
#, no-wrap
msgid ""
"    master^ --> #1 --> #2 --> #3\n"
"\t  \\                                  *\"seen\" head\n"
"            \\---> master --> #1' --> #2' --> #3'\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:92
msgid ""
"The diff between master^ and #1 is applied to master and committed to create "
"#1' commit with the commit information (log, author and date) taken from "
"commit #1.  On top of that #2' and #3' commits are made similarly out of #2 "
"and #3 commits."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:97
msgid ""
"Old #3 is not recorded in any of the .git/refs/heads/ file anymore, so after "
"doing this you will have dangling commit if you ran fsck-cache, which is "
"normal.  After testing \"seen\", you can run \"git prune\" to get rid of "
"those original three commits."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:100
msgid ""
"While I am talking about \"git rebase\", I should talk about how to do "
"cherrypicking using only the core Git tools."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:102
msgid "Let's go back to the earlier picture, with different labels."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:105
msgid ""
"You, as an individual developer, cloned upstream repository and made a "
"couple of commits on top of it."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:108
#, no-wrap
msgid ""
"                              *your \"master\" head\n"
"   upstream --> #1 --> #2 --> #3\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:112
msgid ""
"You would want changes #2 and #3 incorporated in the upstream, while you "
"feel that #1 may need further improvements.  So you prepare #2 and #3 for "
"e-mail submission."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:114
#, no-wrap
msgid "    $ git format-patch master^^ master\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:121
msgid ""
"This creates two files, 0001-XXXX.patch and 0002-XXXX.patch.  Send them out "
"\"To: \" your project maintainer and \"Cc: \" your mailing list.  You could "
"use contributed script git-send-email if your host has necessary perl "
"modules for this, but your usual MUA would do as long as it does not corrupt "
"whitespaces in the patch."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:124
msgid ""
"Then you would wait, and you find out that the upstream picked up your "
"changes, along with other changes."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:130
#, no-wrap
msgid ""
"   where                      *your \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C\n"
"                                                *upstream head\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:136
msgid ""
"The two commits #2' and #3' in the above picture record the same changes "
"your e-mail submission for #2 and #3 contained, but probably with the new "
"sign-off line added by the upstream maintainer and definitely with different "
"committer and ancestry information, they are different objects from #2 and "
"#3 commits."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:138
msgid "You fetch from upstream, but not merge."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:140
#, no-wrap
msgid "    $ git fetch upstream\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:144
msgid ""
"This leaves the updated upstream head in .git/FETCH_HEAD but does not touch "
"your .git/HEAD or .git/refs/heads/master.  You run \"git rebase\" now."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:146
#, no-wrap
msgid "    $ git rebase FETCH_HEAD master\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:152
msgid ""
"Earlier, I said that rebase applies all the commits from your branch on top "
"of the upstream head.  Well, I lied.  \"git rebase\" is a bit smarter than "
"that and notices that #2 and #3 need not be applied, so it only applies #1.  "
"The commit ancestry graph becomes something like this:"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:159
#, no-wrap
msgid ""
"   where                     *your old \"master\" head\n"
"  upstream --> #1 --> #2 --> #3\n"
"    used   \\                      your new \"master\" head*\n"
"   to be     \\--> #A --> #2' --> #3' --> #B --> #C --> #1'\n"
"                                                *upstream\n"
"                                                head\n"
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:163
msgid ""
"Again, \"git prune\" would discard the disused commits #1-#3 and you "
"continue on starting from the new \"master\" head, which is the #1' commit."
msgstr ""

#. type: Plain text
#: ../Documentation/howto/rebase-from-internal-branch.txt:164
msgid "-jc"
msgstr ""
