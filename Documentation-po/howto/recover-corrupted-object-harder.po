# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 2.0\n"
"POT-Creation-Date: 2022-09-24 21:43+0900\n"
"PO-Revision-Date: 2022-10-13 04:51+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:7
#, no-wrap
msgid ""
"Date: Wed, 16 Oct 2013 04:34:01 -0400\n"
"From: Jeff King <peff@peff.net>\n"
"Subject: pack corruption post-mortem\n"
"Abstract: Recovering a corrupted object\n"
" when no good copy is available.\n"
"Content-type: text/asciidoc\n"
msgstr ""
"Date: Wed, 16 Oct 2013 04:34:01 -0400\n"
"From: Jeff King <peff@peff.net>\n"
"Subject: pack corruption post-mortem\n"
"Abstract: 適切なコピーが利用できない場合に、\n"
" 破損したオブジェクトを回復します。\n"
"Content-type: text/asciidoc\n"

#. type: Title =
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:9
#, no-wrap
msgid "How to recover an object from scratch"
msgstr "How to recover an object from scratch"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:16
msgid ""
"I was recently presented with a repository with a corrupted packfile, and "
"was asked if the data was recoverable. This post-mortem describes the steps "
"I took to investigate and fix the problem. I thought others might find the "
"process interesting, and it might help somebody in the same situation."
msgstr ""
"私は、最近、破損したパックファイルを含むリポジトリを提示され、データが回復可"
"能かどうかを尋ねられました。 この事後分析では、問題を調査して修正するために私"
"が行った手順について説明します。 他の人がこのプロセスを興味深いと思うかもしれ"
"ないし、同じ状況の誰かを助ける事になるかもしれないと思ったからです。"

#. type: delimited block *
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:21
msgid ""
"Note: In this case, no good copy of the repository was available. For the "
"much easier case where you can get the corrupted object from elsewhere, see "
"link:recover-corrupted-blob-object.html[this howto]."
msgstr ""
"注意: このケースではリポジトリの適切なコピーは利用できませんでした。 破損した"
"オブジェクトを他の場所から取得できる、はるかに簡単なケースについては、 link:"
"recover-corrupted-blob-object.html[this howto] を参照してください。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:26
msgid ""
"I started with an fsck, which found a problem with exactly one object (I've "
"used $pack and $obj below to keep the output readable, and also because I'll "
"refer to them later):"
msgstr ""
"私はfsckで始め、1つのオブジェクトで問題が見つかりました(出力を読みやすくする"
"ために、また、後で私が引用しやすくするために、以下で $pack と $obj を使用しま"
"した):"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:33
#, no-wrap
msgid ""
"    $ git fsck\n"
"    error: $pack SHA1 checksum mismatch\n"
"    error: index CRC mismatch for object $obj from $pack at offset 51653873\n"
"    error: inflate: data stream error (incorrect data check)\n"
"    error: cannot unpack $obj from $pack at offset 51653873\n"
msgstr ""
"    $ git fsck\n"
"    error: $pack SHA1 checksum mismatch\n"
"    error: index CRC mismatch for object $obj from $pack at offset 51653873\n"
"    error: inflate: data stream error (incorrect data check)\n"
"    error: cannot unpack $obj from $pack at offset 51653873\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:38
msgid ""
"The pack checksum failing means a byte is munged somewhere, and it is "
"presumably in the object mentioned (since both the index checksum and zlib "
"were failing)."
msgstr ""
"パックチェックサムが失敗したということは、バイトがどこかで変更されたことを意"
"味し、それはおそらく言及されたオブジェクトにあります(インデックスチェックサム"
"とzlibの両方が失敗したため)。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:44
msgid ""
"Reading the zlib source code, I found that \"incorrect data check\" means "
"that the adler-32 checksum at the end of the zlib data did not match the "
"inflated data. So stepping the data through zlib would not help, as it did "
"not fail until the very end, when we realize the CRC does not match.  The "
"problematic bytes could be anywhere in the object data."
msgstr ""
"私はzlibのソースコードを読んで、「incorrect data check」とは、zlibデータの最"
"後にある adler-32 チェックサムが展開したデータと一致しなかったことを意味する"
"ことがわかりました。 したがって、データをzlibを介してステップ実行しても、CRC"
"が一致しないことが分かる最後の時点まで失敗しないので、役に立ちません。 問題の"
"あるバイトは、オブジェクトデータのどこにでもある可能性があります。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:47
msgid ""
"The first thing I did was pull the broken data out of the packfile. I needed "
"to know how big the object was, which I found out with:"
msgstr ""
"私が最初にしたことは、壊れたデータをパックファイルから引き出すことでした。 私"
"はオブジェクトの大きさを知る必要がありました:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:52
#, no-wrap
msgid ""
"    $ git show-index <$idx | cut -d' ' -f1 | sort -n | grep -A1 51653873\n"
"    51653873\n"
"    51664736\n"
msgstr ""
"    $ git show-index <$idx | cut -d' ' -f1 | sort -n | grep -A1 51653873\n"
"    51653873\n"
"    51664736\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:59
msgid ""
"Show-index gives us the list of objects and their offsets. We throw away "
"everything but the offsets, and then sort them so that our interesting "
"offset (which we got from the fsck output above) is followed immediately by "
"the offset of the next object. Now we know that the object data is 10863 "
"bytes long, and we can grab it with:"
msgstr ""
"show-indexは、オブジェクトとそのオフセットのリストを提供します。 オフセット以"
"外のすべてを破棄し、次にそれらを並べ替えて、興味深いオフセット(上記のfsck出力"
"から取得)の直後に次のオブジェクトのオフセットが続くようにします。 これで、オ"
"ブジェクトデータの長さが10863バイトであることがわかり、以下のコマンドで取得で"
"きます:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:62
#, no-wrap
msgid "  dd if=$pack of=object bs=1 skip=51653873 count=10863\n"
msgstr "  dd if=$pack of=object bs=1 skip=51653873 count=10863\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:67
msgid ""
"I inspected a hexdump of the data, looking for any obvious bogosity (e.g., a "
"4K run of zeroes would be a good sign of filesystem corruption). But "
"everything looked pretty reasonable."
msgstr ""
"私はデータの16進ダンプを調べて、明らかなボゴシティを探しました(たとえば、4Kの"
"ゼロの連続はファイルシステムの破損の良い兆候です)。 しかし、すべてがかなり合"
"理的に見えました。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:75
msgid ""
"Note that the \"object\" file isn't fit for feeding straight to zlib; it has "
"the git packed object header, which is variable-length. We want to strip "
"that off so we can start playing with the zlib data directly. You can either "
"work your way through it manually (the format is described in linkgit:"
"gitformat-pack[5]), or you can walk through it in a debugger. I did the "
"latter, creating a valid pack like:"
msgstr "「オブジェクト」ファイルは、zlibに直接送り込むには適していないことに注意してください。 可変長のgitパックオブジェクトヘッダーがあります。 zlibデータを直接操作できるように、これを取り除きます。 手動で作業するか(形式は linkgit:gitformat-pack[5] で説明されています)、デバッガーで操作することができます。 私は後者を行い、以下のような有効なパックを作成しました:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:86
#, no-wrap
msgid ""
"    # pack magic and version\n"
"    printf 'PACK\\0\\0\\0\\2' >tmp.pack\n"
"    # pack has one object\n"
"    printf '\\0\\0\\0\\1' >>tmp.pack\n"
"    # now add our object data\n"
"    cat object >>tmp.pack\n"
"    # and then append the pack trailer\n"
"    /path/to/git.git/t/helper/test-tool sha1 -b <tmp.pack >trailer\n"
"    cat trailer >>tmp.pack\n"
msgstr ""
"    # pack magic and version\n"
"    printf 'PACK\\0\\0\\0\\2' >tmp.pack\n"
"    # pack has one object\n"
"    printf '\\0\\0\\0\\1' >>tmp.pack\n"
"    # now add our object data\n"
"    cat object >>tmp.pack\n"
"    # and then append the pack trailer\n"
"    /path/to/git.git/t/helper/test-tool sha1 -b <tmp.pack >trailer\n"
"    cat trailer >>tmp.pack\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:92
msgid ""
"and then running \"git index-pack tmp.pack\" in the debugger (stop at "
"unpack_raw_entry). Doing this, I found that there were 3 bytes of header "
"(and the header itself had a sane type and size). So I stripped those off "
"with:"
msgstr ""
"次に、デバッガーで `git index-pack tmp.pack` を実行します(unpack_raw_entryで"
"停止します)。 これを行うと、3バイトのヘッダーがあることがわかりました(ヘッ"
"ダー自体は適切なタイプとサイズでした)。 なので私はそれらを以下のように取り除"
"きました:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:95
#, no-wrap
msgid "    dd if=object of=zlib bs=1 skip=3\n"
msgstr "    dd if=object of=zlib bs=1 skip=3\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:104
msgid ""
"I ran the result through zlib's inflate using a custom C program. And while "
"it did report the error, I did get the right number of output bytes (i.e., "
"it matched git's size header that we decoded above). But feeding the result "
"back to \"git hash-object\" didn't produce the same sha1. So there were some "
"wrong bytes, but I didn't know which. The file happened to be C source code, "
"so I hoped I could notice something obviously wrong with it, but I didn't. I "
"even got it to compile!"
msgstr ""
"カスタムCプログラムを使用して、zlibでの解凍を介して結果を実行しました。 そし"
"て、それはエラーを報告はしましたが、正しい数の出力バイトを取得しました(つま"
"り、上記でデコードしたgitのサイズヘッダーと一致しました)。 しかし、結果を "
"`git hash-object` にフィードバックしても、同じsha1は生成されませんでした。 つ"
"まり、間違ったバイトがいくつかありましたが、どれかわからないということです。 "
"このファイルはたまたまCのソースコードだったので、明らかに何か問題があることに"
"気付くといいのですが、私は気づきませんでした。 それはコンパイルもできました！"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:109
msgid ""
"I also tried comparing it to other versions of the same path in the "
"repository, hoping that there would be some part of the diff that didn't "
"make sense. Unfortunately, this happened to be the only revision of this "
"particular file in the repository, so I had nothing to compare against."
msgstr ""
"また、リポジトリ内の同じパスの他のバージョンと比較してみました。意味のない"
"diffの一部があることを期待していました。 しかし残念ながら、これはたまたまリポ"
"ジトリ内のこの特定のファイルの唯一のリビジョンであったため、比較するものは何"
"もありませんでした。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:115
msgid ""
"So I took a different approach. Working under the guess that the corruption "
"was limited to a single byte, I wrote a program to munge each byte "
"individually, and try inflating the result. Since the object was only 10K "
"compressed, that worked out to about 2.5M attempts, which took a few minutes."
msgstr ""
"なので私は別のアプローチを取りました。 破損は1バイトに限定されているという推"
"測の下で、各バイトを個別に処理するプログラムを作成し、結果を解凍させてみまし"
"た。 オブジェクトはわずか10Kに圧縮されていたため、約250万回の試行に成功し、そ"
"れは数分かかりました。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:117
msgid "The program I used is here:"
msgstr "私が使用したプログラムはコレです:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:124
#, no-wrap
msgid ""
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <string.h>\n"
"#include <signal.h>\n"
"#include <zlib.h>\n"
msgstr ""
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <string.h>\n"
"#include <signal.h>\n"
"#include <zlib.h>\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:131
#, no-wrap
msgid ""
"static int try_zlib(unsigned char *buf, int len)\n"
"{\n"
"\t/* make this absurdly large so we don't have to loop */\n"
"\tstatic unsigned char out[1024*1024];\n"
"\tz_stream z;\n"
"\tint ret;\n"
msgstr ""
"static int try_zlib(unsigned char *buf, int len)\n"
"{\n"
"\t/* make this absurdly large so we don't have to loop */\n"
"\tstatic unsigned char out[1024*1024];\n"
"\tz_stream z;\n"
"\tint ret;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:134
#, no-wrap
msgid ""
"\tmemset(&z, 0, sizeof(z));\n"
"\tinflateInit(&z);\n"
msgstr ""
"\tmemset(&z, 0, sizeof(z));\n"
"\tinflateInit(&z);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:139
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:293
#, no-wrap
msgid ""
"\tz.next_in = buf;\n"
"\tz.avail_in = len;\n"
"\tz.next_out = out;\n"
"\tz.avail_out = sizeof(out);\n"
msgstr ""
"\tz.next_in = buf;\n"
"\tz.avail_in = len;\n"
"\tz.next_out = out;\n"
"\tz.avail_out = sizeof(out);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:144
#, no-wrap
msgid ""
"\tret = inflate(&z, 0);\n"
"\tinflateEnd(&z);\n"
"\treturn ret >= 0;\n"
"}\n"
msgstr ""
"\tret = inflate(&z, 0);\n"
"\tinflateEnd(&z);\n"
"\treturn ret >= 0;\n"
"}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:152
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:321
#, no-wrap
msgid ""
"/* eye candy */\n"
"static int counter = 0;\n"
"static void progress(int sig)\n"
"{\n"
"\tfprintf(stderr, \"\\r%d\", counter);\n"
"\talarm(1);\n"
"}\n"
msgstr ""
"/* eye candy */\n"
"static int counter = 0;\n"
"static void progress(int sig)\n"
"{\n"
"\tfprintf(stderr, \"\\r%d\", counter);\n"
"\talarm(1);\n"
"}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:159
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"\t/* oversized so we can read the whole buffer in */\n"
"\tunsigned char buf[1024*1024];\n"
"\tint len;\n"
"\tunsigned i, j;\n"
msgstr ""
"int main(void)\n"
"{\n"
"\t/* oversized so we can read the whole buffer in */\n"
"\tunsigned char buf[1024*1024];\n"
"\tint len;\n"
"\tunsigned i, j;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:162
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:420
#, no-wrap
msgid ""
"\tsignal(SIGALRM, progress);\n"
"\talarm(1);\n"
msgstr ""
"\tsignal(SIGALRM, progress);\n"
"\talarm(1);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:168
#, no-wrap
msgid ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\tfor (i = 0; i < len; i++) {\n"
"\t\tunsigned char c = buf[i];\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tbuf[i] = j;\n"
msgstr ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\tfor (i = 0; i < len; i++) {\n"
"\t\tunsigned char c = buf[i];\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tbuf[i] = j;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:175
#, no-wrap
msgid ""
"\t\t\tcounter++;\n"
"\t\t\tif (try_zlib(buf, len))\n"
"\t\t\t\tprintf(\"i=%d, j=%x\\n\", i, j);\n"
"\t\t}\n"
"\t\tbuf[i] = c;\n"
"\t}\n"
msgstr ""
"\t\t\tcounter++;\n"
"\t\t\tif (try_zlib(buf, len))\n"
"\t\t\t\tprintf(\"i=%d, j=%x\\n\", i, j);\n"
"\t\t}\n"
"\t\tbuf[i] = c;\n"
"\t}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:180
#, no-wrap
msgid ""
"\talarm(0);\n"
"\tfprintf(stderr, \"\\n\");\n"
"\treturn 0;\n"
"}\n"
msgstr ""
"\talarm(0);\n"
"\tfprintf(stderr, \"\\n\");\n"
"\treturn 0;\n"
"}\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:183
msgid "I compiled and ran with:"
msgstr "私は以下のようにしてコンパイルして実行しました:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:187
#, no-wrap
msgid ""
"  gcc -Wall -Werror -O3 munge.c -o munge -lz\n"
"  ./munge <zlib\n"
msgstr ""
"  gcc -Wall -Werror -O3 munge.c -o munge -lz\n"
"  ./munge <zlib\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:193
msgid ""
"There were a few false positives early on (if you write \"no data\" in the "
"zlib header, zlib thinks it's just fine :) ). But I got a hit about halfway "
"through:"
msgstr ""
"初期の段階でいくつかの誤検知がありました(zlibヘッダーに「no data」と記述した"
"場合、zlibはそれで問題ないと見なします :) )。 しかし、私は途中でヒットしまし"
"た:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:196
#, no-wrap
msgid "  i=5642, j=c7\n"
msgstr "  i=5642, j=c7\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:201
msgid ""
"I let it run to completion, and got a few more hits at the end (where it was "
"munging the CRC to match our broken data). So there was a good chance this "
"middle hit was the source of the problem."
msgstr ""
"私はそれを最後まで実行させ、最後にさらにいくつかのヒットを取得しました(壊れた"
"データと一致するようにCRCを変更していました)。 したがって、この途中のヒットが"
"問題の原因である可能性が高いです。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:205
msgid ""
"I confirmed by tweaking the byte in a hex editor, zlib inflating the result "
"(no errors!), and then piping the output into \"git hash-object\", which "
"reported the sha1 of the broken object. Success!"
msgstr ""
"16進エディターでバイトを微調整し、結果をzlibで解凍して(エラーなし！)、出力を"
"「git hash-object」にパイプして、壊れたオブジェクトのsha1を報告することで確認"
"しました。 成功です！"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:207
msgid "I fixed the packfile itself with:"
msgstr "私はパックファイル自体を以下のようにして修正しました:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:212
#, no-wrap
msgid ""
"  chmod +w $pack\n"
"  printf '\\xc7' | dd of=$pack bs=1 seek=51659518 conv=notrunc\n"
"  chmod -w $pack\n"
msgstr ""
"  chmod +w $pack\n"
"  printf '\\xc7' | dd of=$pack bs=1 seek=51659518 conv=notrunc\n"
"  chmod -w $pack\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:218
msgid ""
"The `\\xc7` comes from the replacement byte our \"munge\" program found.  "
"The offset 51659518 is derived by taking the original object offset "
"(51653873), adding the replacement offset found by \"munge\" (5642), and "
"then adding back in the 3 bytes of git header we stripped."
msgstr ""
"`\\xc7` は、「munge」プログラムが見つけた置換バイトに由来します。 オフセット "
"51659518 は、元のオブジェクトオフセット(51653873)を取得し、「munge」(5642)に"
"よって検出された置換オフセットを追加してから、削除した3バイトのgitヘッダーを"
"追加して取得します。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:220
msgid "After that, \"git fsck\" ran clean."
msgstr "その後、 「git fsck」はクリーンに実行されました。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:225
msgid ""
"As for the corruption itself, I was lucky that it was indeed a single byte. "
"In fact, it turned out to be a single bit. The byte 0xc7 was corrupted to "
"0xc5. So presumably it was caused by faulty hardware, or a cosmic ray."
msgstr ""
"破損自体に関しては、それが確かに1バイトであったことは幸運でした。 実際、それ"
"は1ビットであることが判明しました。 バイト0xc7 が 0xc5 に破損しました。 した"
"がって、おそらくそれは欠陥のあるハードウェア、または宇宙線によって引き起こさ"
"れたのでしょう。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:229
msgid ""
"And the aborted attempt to look at the inflated output to see what was "
"wrong? I could have looked forever and never found it. Here's the diff "
"between what the corrupted data inflates to, versus the real data:"
msgstr ""
"そして、何が悪かったのかを見るために解凍した出力を見るという中止された試み"
"は？ 私は永遠に見て、それを見つけることができなかったかもしれません。 破損し"
"たデータを解凍したものと実際のデータの違いは以下のとおりです:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:233
#, no-wrap
msgid ""
"  -       cp = strtok (arg, \"+\");\n"
"  +       cp = strtok (arg, \".\");\n"
msgstr ""
"  -       cp = strtok (arg, \"+\");\n"
"  +       cp = strtok (arg, \".\");\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:239
msgid ""
"It tweaked one byte and still ended up as valid, readable C that just "
"happened to do something totally different! One takeaway is that on a less "
"unlucky day, looking at the zlib output might have actually been helpful, as "
"most random changes would actually break the C code."
msgstr ""
"それは1バイトを微調整しましたが、それでも、まったく異なることをしただけの、有"
"効で読み取り可能なC言語のソースコードになりました！  一つの収穫として、不運で"
"ない日であれば、ほとんどのランダムな変更はC言語のソースコードを壊してしまうの"
"で、zlibの出力を見ることは実際に役に立ったかもしれません。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:244
msgid ""
"But more importantly, git's hashing and checksumming noticed a problem that "
"easily could have gone undetected in another system. The result still "
"compiled, but would have caused an interesting bug (that would have been "
"blamed on some random commit)."
msgstr ""
"しかし、さらに重要なことは、gitのハッシュとチェックサムは、別のシステムでは簡"
"単に検出されない可能性のある問題に気付いた事です。その結果、コンパイルはでき"
"ましたが、興味深いバグが発生したことでしょう(手当たりしだいのコミットのせいに"
"されたかもしれません)。"

#. type: Title -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:247
#, no-wrap
msgid "The adventure continues..."
msgstr "The adventure continues..."

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:253
msgid ""
"I ended up doing this again! Same entity, new hardware. The assumption at "
"this point is that the old disk corrupted the packfile, and then the "
"corruption was migrated to the new hardware (because it was done by rsync or "
"similar, and no fsck was done at the time of migration)."
msgstr ""
"私はまたやらかしてしまいました！ 同じ事を、新しいハードウェアで。 この時点で"
"の想定は、古いディスクがpackfileを破損し、その破損が新しいハードウェアに移行"
"されたというものです(rsyncなどによって行われ、移行時にfsckが行われなかったた"
"め)。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:262
msgid ""
"This time, the affected blob was over 20 megabytes, which was far too large "
"to do a brute-force on. I followed the instructions above to create the "
"`zlib` file. I then used the `inflate` program below to pull the corrupted "
"data from that. Examining that output gave me a hint about where in the file "
"the corruption was. But now I was working with the file itself, not the zlib "
"contents. So knowing the sha1 of the object and the approximate area of the "
"corruption, I used the `sha1-munge` program below to brute-force the correct "
"byte."
msgstr ""
"今回、影響を受けたブロブは20メガバイトを超えていましたが、これは大きすぎて力"
"づくでとは行きませんでした。 私は上記の手順に従って、 `zlib` ファイルを作成し"
"ました。 次に、以下の `inflate` プログラムを使用して、破損したデータをそこか"
"らプルしました。 その出力を調べると、ファイルのどこに破損があったかについての"
"ヒントが得られました。 しかし、今回はzlibの内容ではなく、ファイル自体を操作し"
"ていました。 そのため、オブジェクトのsha1と破損のおおよその領域を知って、以下"
"の `sha1-munge` プログラムを使用して、正しいバイトを力づくで割り出しました。"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:265
msgid ""
"Here's the inflate program (it's essentially `gunzip` but without the `.gz` "
"header processing):"
msgstr ""
"これが解凍(inflate)プログラムです(基本的には `gunzip` ですが、 `.gz` ヘッダー"
"処理はありません):"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:271
#, no-wrap
msgid ""
"#include <stdio.h>\n"
"#include <string.h>\n"
"#include <zlib.h>\n"
"#include <stdlib.h>\n"
msgstr ""
"#include <stdio.h>\n"
"#include <string.h>\n"
"#include <zlib.h>\n"
"#include <stdlib.h>\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:284
#, no-wrap
msgid ""
"int main(int argc, char **argv)\n"
"{\n"
"\t/*\n"
"\t * oversized so we can read the whole buffer in;\n"
"\t * this could actually be switched to streaming\n"
"\t * to avoid any memory limitations\n"
"\t */\n"
"\tstatic unsigned char buf[25 * 1024 * 1024];\n"
"\tstatic unsigned char out[25 * 1024 * 1024];\n"
"\tint len;\n"
"\tz_stream z;\n"
"\tint ret;\n"
msgstr ""
"int main(int argc, char **argv)\n"
"{\n"
"\t/*\n"
"\t * oversized so we can read the whole buffer in;\n"
"\t * this could actually be switched to streaming\n"
"\t * to avoid any memory limitations\n"
"\t */\n"
"\tstatic unsigned char buf[25 * 1024 * 1024];\n"
"\tstatic unsigned char out[25 * 1024 * 1024];\n"
"\tint len;\n"
"\tz_stream z;\n"
"\tint ret;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:288
#, no-wrap
msgid ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\tmemset(&z, 0, sizeof(z));\n"
"\tinflateInit(&z);\n"
msgstr ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\tmemset(&z, 0, sizeof(z));\n"
"\tinflateInit(&z);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:297
#, no-wrap
msgid ""
"\tret = inflate(&z, 0);\n"
"\tif (ret != Z_OK && ret != Z_STREAM_END)\n"
"\t\tfprintf(stderr, \"initial inflate failed (%d)\\n\", ret);\n"
msgstr ""
"\tret = inflate(&z, 0);\n"
"\tif (ret != Z_OK && ret != Z_STREAM_END)\n"
"\t\tfprintf(stderr, \"initial inflate failed (%d)\\n\", ret);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:302
#, no-wrap
msgid ""
"\tfprintf(stderr, \"outputting %lu bytes\", z.total_out);\n"
"\tfwrite(out, 1, z.total_out, stdout);\n"
"\treturn 0;\n"
"}\n"
msgstr ""
"\tfprintf(stderr, \"outputting %lu bytes\", z.total_out);\n"
"\tfwrite(out, 1, z.total_out, stdout);\n"
"\treturn 0;\n"
"}\n"

#. type: Plain text
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:305
msgid "And here is the `sha1-munge` program:"
msgstr "そして、以下が `sha1-munge` プログラムです:"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:313
#, no-wrap
msgid ""
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <string.h>\n"
"#include <signal.h>\n"
"#include <openssl/sha.h>\n"
"#include <stdlib.h>\n"
msgstr ""
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <string.h>\n"
"#include <signal.h>\n"
"#include <openssl/sha.h>\n"
"#include <stdlib.h>\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:356
#, no-wrap
msgid ""
"static const signed char hexval_table[256] = {\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 00-07 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 08-0f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 10-17 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 18-1f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 20-27 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 28-2f */\n"
"\t  0,  1,  2,  3,  4,  5,  6,  7,\t\t/* 30-37 */\n"
"\t  8,  9, -1, -1, -1, -1, -1, -1,\t\t/* 38-3f */\n"
"\t -1, 10, 11, 12, 13, 14, 15, -1,\t\t/* 40-47 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 48-4f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 50-57 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 58-5f */\n"
"\t -1, 10, 11, 12, 13, 14, 15, -1,\t\t/* 60-67 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 68-67 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 70-77 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 78-7f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 80-87 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 88-8f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 90-97 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 98-9f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* a0-a7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* a8-af */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* b0-b7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* b8-bf */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* c0-c7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* c8-cf */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* d0-d7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* d8-df */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* e0-e7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* e8-ef */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* f0-f7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* f8-ff */\n"
"};\n"
msgstr ""
"static const signed char hexval_table[256] = {\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 00-07 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 08-0f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 10-17 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 18-1f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 20-27 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 28-2f */\n"
"\t  0,  1,  2,  3,  4,  5,  6,  7,\t\t/* 30-37 */\n"
"\t  8,  9, -1, -1, -1, -1, -1, -1,\t\t/* 38-3f */\n"
"\t -1, 10, 11, 12, 13, 14, 15, -1,\t\t/* 40-47 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 48-4f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 50-57 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 58-5f */\n"
"\t -1, 10, 11, 12, 13, 14, 15, -1,\t\t/* 60-67 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 68-67 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 70-77 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 78-7f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 80-87 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 88-8f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 90-97 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* 98-9f */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* a0-a7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* a8-af */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* b0-b7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* b8-bf */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* c0-c7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* c8-cf */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* d0-d7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* d8-df */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* e0-e7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* e8-ef */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* f0-f7 */\n"
"\t -1, -1, -1, -1, -1, -1, -1, -1,\t\t/* f8-ff */\n"
"};\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:361
#, no-wrap
msgid ""
"static inline unsigned int hexval(unsigned char c)\n"
"{\n"
"return hexval_table[c];\n"
"}\n"
msgstr ""
"static inline unsigned int hexval(unsigned char c)\n"
"{\n"
"return hexval_table[c];\n"
"}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:382
#, no-wrap
msgid ""
"static int get_sha1_hex(const char *hex, unsigned char *sha1)\n"
"{\n"
"\tint i;\n"
"\tfor (i = 0; i < 20; i++) {\n"
"\t\tunsigned int val;\n"
"\t\t/*\n"
"\t\t * hex[1]=='\\0' is caught when val is checked below,\n"
"\t\t * but if hex[0] is NUL we have to avoid reading\n"
"\t\t * past the end of the string:\n"
"\t\t */\n"
"\t\tif (!hex[0])\n"
"\t\t\treturn -1;\n"
"\t\tval = (hexval(hex[0]) << 4) | hexval(hex[1]);\n"
"\t\tif (val & ~0xff)\n"
"\t\t\treturn -1;\n"
"\t\t*sha1++ = val;\n"
"\t\thex += 2;\n"
"\t}\n"
"\treturn 0;\n"
"}\n"
msgstr ""
"static int get_sha1_hex(const char *hex, unsigned char *sha1)\n"
"{\n"
"\tint i;\n"
"\tfor (i = 0; i < 20; i++) {\n"
"\t\tunsigned int val;\n"
"\t\t/*\n"
"\t\t * hex[1]=='\\0' is caught when val is checked below,\n"
"\t\t * but if hex[0] is NUL we have to avoid reading\n"
"\t\t * past the end of the string:\n"
"\t\t */\n"
"\t\tif (!hex[0])\n"
"\t\t\treturn -1;\n"
"\t\tval = (hexval(hex[0]) << 4) | hexval(hex[1]);\n"
"\t\tif (val & ~0xff)\n"
"\t\t\treturn -1;\n"
"\t\t*sha1++ = val;\n"
"\t\thex += 2;\n"
"\t}\n"
"\treturn 0;\n"
"}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:393
#, no-wrap
msgid ""
"int main(int argc, char **argv)\n"
"{\n"
"\t/* oversized so we can read the whole buffer in */\n"
"\tstatic unsigned char buf[25 * 1024 * 1024];\n"
"\tchar header[32];\n"
"\tint header_len;\n"
"\tunsigned char have[20], want[20];\n"
"\tint start, len;\n"
"\tSHA_CTX orig;\n"
"\tunsigned i, j;\n"
msgstr ""
"int main(int argc, char **argv)\n"
"{\n"
"\t/* oversized so we can read the whole buffer in */\n"
"\tstatic unsigned char buf[25 * 1024 * 1024];\n"
"\tchar header[32];\n"
"\tint header_len;\n"
"\tunsigned char have[20], want[20];\n"
"\tint start, len;\n"
"\tSHA_CTX orig;\n"
"\tunsigned i, j;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:398
#, no-wrap
msgid ""
"\tif (!argv[1] || get_sha1_hex(argv[1], want)) {\n"
"\t\tfprintf(stderr, \"usage: sha1-munge <sha1> [start] <file.in\\n\");\n"
"\t\treturn 1;\n"
"\t}\n"
msgstr ""
"\tif (!argv[1] || get_sha1_hex(argv[1], want)) {\n"
"\t\tfprintf(stderr, \"usage: sha1-munge <sha1> [start] <file.in\\n\");\n"
"\t\treturn 1;\n"
"\t}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:403
#, no-wrap
msgid ""
"\tif (argv[2])\n"
"\t\tstart = atoi(argv[2]);\n"
"\telse\n"
"\t\tstart = 0;\n"
msgstr ""
"\tif (argv[2])\n"
"\t\tstart = atoi(argv[2]);\n"
"\telse\n"
"\t\tstart = 0;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:407
#, no-wrap
msgid ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\theader_len = sprintf(header, \"blob %d\", len) + 1;\n"
"\tfprintf(stderr, \"using header: %s\\n\", header);\n"
msgstr ""
"\tlen = read(0, buf, sizeof(buf));\n"
"\theader_len = sprintf(header, \"blob %d\", len) + 1;\n"
"\tfprintf(stderr, \"using header: %s\\n\", header);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:417
#, no-wrap
msgid ""
"\t/*\n"
"\t * We keep a running sha1 so that if you are munging\n"
"\t * near the end of the file, we do not have to re-sha1\n"
"\t * the unchanged earlier bytes\n"
"\t */\n"
"\tSHA1_Init(&orig);\n"
"\tSHA1_Update(&orig, header, header_len);\n"
"\tif (start)\n"
"\t\tSHA1_Update(&orig, buf, start);\n"
msgstr ""
"\t/*\n"
"\t * We keep a running sha1 so that if you are munging\n"
"\t * near the end of the file, we do not have to re-sha1\n"
"\t * the unchanged earlier bytes\n"
"\t */\n"
"\tSHA1_Init(&orig);\n"
"\tSHA1_Update(&orig, header, header_len);\n"
"\tif (start)\n"
"\t\tSHA1_Update(&orig, buf, start);\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:424
#, no-wrap
msgid ""
"\tfor (i = start; i < len; i++) {\n"
"\t\tunsigned char c;\n"
"\t\tSHA_CTX x;\n"
msgstr ""
"\tfor (i = start; i < len; i++) {\n"
"\t\tunsigned char c;\n"
"\t\tSHA_CTX x;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:440
#, no-wrap
msgid ""
"#if 0\n"
"\t\t/*\n"
"\t\t * deletion -- this would not actually work in practice,\n"
"\t\t * I think, because we've already committed to a\n"
"\t\t * particular size in the header. Ditto for addition\n"
"\t\t * below. In those cases, you'd have to do the whole\n"
"\t\t * sha1 from scratch, or possibly keep three running\n"
"\t\t * \"orig\" sha1 computations going.\n"
"\t\t */\n"
"\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\tSHA1_Update(&x, buf + i + 1, len - i - 1);\n"
"\t\tSHA1_Final(have, &x);\n"
"\t\tif (!memcmp(have, want, 20))\n"
"\t\t\tprintf(\"i=%d, deletion\\n\", i);\n"
"#endif\n"
msgstr ""
"#if 0\n"
"\t\t/*\n"
"\t\t * deletion -- this would not actually work in practice,\n"
"\t\t * I think, because we've already committed to a\n"
"\t\t * particular size in the header. Ditto for addition\n"
"\t\t * below. In those cases, you'd have to do the whole\n"
"\t\t * sha1 from scratch, or possibly keep three running\n"
"\t\t * \"orig\" sha1 computations going.\n"
"\t\t * JP: 削除 -- 私が考えるに、\n"
"\t\t * これは実際にはうまくいかないと思います。\n"
"\t\t * なぜなら、私たちはすでにヘッダーで特定のサイズに\n"
"\t\t * コミットしているからです。以下の追加(addition)も\n"
"\t\t * 同様です。このような場合、sha1全体を一からやり直すか、\n"
"\t\t * あるいは3つの「orig」sha1計算を実行し続ける必要が\n"
"\t\t * あるでしょう。\n"
"\t\t */\n"
"\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\tSHA1_Update(&x, buf + i + 1, len - i - 1);\n"
"\t\tSHA1_Final(have, &x);\n"
"\t\tif (!memcmp(have, want, 20))\n"
"\t\t\tprintf(\"i=%d, deletion\\n\", i);\n"
"#endif\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:450
#, no-wrap
msgid ""
"\t\t/*\n"
"\t\t * replacement -- note that this tries each of the 256\n"
"\t\t * possible bytes. If you suspect a single-bit flip,\n"
"\t\t * it would be much shorter to just try the 8\n"
"\t\t * bit-flipped variants.\n"
"\t\t */\n"
"\t\tc = buf[i];\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tbuf[i] = j;\n"
msgstr ""
"\t\t/*\n"
"\t\t * replacement -- note that this tries each of the 256\n"
"\t\t * possible bytes. If you suspect a single-bit flip,\n"
"\t\t * it would be much shorter to just try the 8\n"
"\t\t * bit-flipped variants.\n"
"\t\t * JP: 置換 -- これは256の可能なバイトをそれぞれ\n"
"\t\t * 試行することに注意してください。もし1ビット反転が\n"
"\t\t * 疑われるなら、8ビット反転したものを試す方が\n"
"\t\t * ずっと短いでしょう。\n"
"\t\t */\n"
"\t\tc = buf[i];\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tbuf[i] = j;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:458
#, no-wrap
msgid ""
"\t\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\t\tSHA1_Update(&x, buf + i, len - i);\n"
"\t\t\tSHA1_Final(have, &x);\n"
"\t\t\tif (!memcmp(have, want, 20))\n"
"\t\t\t\tprintf(\"i=%d, j=%02x\\n\", i, j);\n"
"\t\t}\n"
"\t\tbuf[i] = c;\n"
msgstr ""
"\t\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\t\tSHA1_Update(&x, buf + i, len - i);\n"
"\t\t\tSHA1_Final(have, &x);\n"
"\t\t\tif (!memcmp(have, want, 20))\n"
"\t\t\t\tprintf(\"i=%d, j=%02x\\n\", i, j);\n"
"\t\t}\n"
"\t\tbuf[i] = c;\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:471
#, no-wrap
msgid ""
"#if 0\n"
"\t\t/* addition */\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tunsigned char extra = j;\n"
"\t\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\t\tSHA1_Update(&x, &extra, 1);\n"
"\t\t\tSHA1_Update(&x, buf + i, len - i);\n"
"\t\t\tSHA1_Final(have, &x);\n"
"\t\t\tif (!memcmp(have, want, 20))\n"
"\t\t\t\tprintf(\"i=%d, addition=%02x\", i, j);\n"
"\t\t}\n"
"#endif\n"
msgstr ""
"#if 0\n"
"\t\t/* addition */\n"
"\t\tfor (j = 0; j <= 0xff; j++) {\n"
"\t\t\tunsigned char extra = j;\n"
"\t\t\tmemcpy(&x, &orig, sizeof(x));\n"
"\t\t\tSHA1_Update(&x, &extra, 1);\n"
"\t\t\tSHA1_Update(&x, buf + i, len - i);\n"
"\t\t\tSHA1_Final(have, &x);\n"
"\t\t\tif (!memcmp(have, want, 20))\n"
"\t\t\t\tprintf(\"i=%d, addition=%02x\", i, j);\n"
"\t\t}\n"
"#endif\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:475
#, no-wrap
msgid ""
"\t\tSHA1_Update(&orig, buf + i, 1);\n"
"\t\tcounter++;\n"
"\t}\n"
msgstr ""
"\t\tSHA1_Update(&orig, buf + i, 1);\n"
"\t\tcounter++;\n"
"\t}\n"

#. type: delimited block -
#: ../Documentation-sedout/howto/recover-corrupted-object-harder.txt:480
#, no-wrap
msgid ""
"\talarm(0);\n"
"\tfprintf(stderr, \"\\r%d\\n\", counter);\n"
"\treturn 0;\n"
"}\n"
msgstr ""
"\talarm(0);\n"
"\tfprintf(stderr, \"\\r%d\\n\", counter);\n"
"\treturn 0;\n"
"}\n"
