# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-02 01:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation/technical/pack-format.txt:2
#, no-wrap
msgid "Git pack format"
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:4
#, no-wrap
msgid "Checksums and object IDs"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:9
msgid ""
"In a repository using the traditional SHA-1, pack checksums, index "
"checksums, and object IDs (object names) mentioned below are all computed "
"using SHA-1.  Similarly, in SHA-256 repositories, these values are computed "
"using SHA-256."
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:10
#, no-wrap
msgid "pack-*.pack files have the following format:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:13
msgid "A header appears at the beginning and consists of the following:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:15
#, no-wrap
msgid "4-byte signature:\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:16
#, no-wrap
msgid "The signature is: {'P', 'A', 'C', 'K'}\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:18
msgid "4-byte version number (network byte order):"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:19
msgid "Git currently accepts version number 2 or 3 but"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:20
#, no-wrap
msgid "generates version 2 only.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:22
msgid "4-byte number of objects contained in the pack (network byte order)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:25
msgid ""
"Observation: we cannot have more than 4G versions ;-) and more than 4G "
"objects in a pack."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:28
msgid ""
"The header is followed by number of object entries, each of which looks like "
"this:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:32
#, no-wrap
msgid ""
"(undeltified representation)\n"
"n-byte type and length (3-bit type, (n-1)*7+4-bit length)\n"
"compressed data\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:36
msgid ""
"(deltified representation)  n-byte type and length (3-bit type, "
"(n-1)*7+4-bit length)  base object name if OBJ_REF_DELTA or a negative "
"relative"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:38
msgid ""
"offset from the delta object's position in the pack if this is an "
"OBJ_OFS_DELTA object"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:39
#, no-wrap
msgid "compressed delta data\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:42
msgid ""
"Observation: length of each object is encoded in a variable length format "
"and is not constrained to 32-bit or anything."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:44
msgid "The trailer records a pack checksum of all of the above."
msgstr ""

#. type: Title ===
#: ../Documentation/technical/pack-format.txt:45
#, no-wrap
msgid "Object types"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:48
msgid "Valid object types are:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:50
msgid "OBJ_COMMIT (1)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:51
msgid "OBJ_TREE (2)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:52
msgid "OBJ_BLOB (3)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:53
msgid "OBJ_TAG (4)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:54
msgid "OBJ_OFS_DELTA (6)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:55
msgid "OBJ_REF_DELTA (7)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:57
msgid "Type 5 is reserved for future expansion. Type 0 is invalid."
msgstr ""

#. type: Title ===
#: ../Documentation/technical/pack-format.txt:58
#, no-wrap
msgid "Size encoding"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:66
msgid ""
"This document uses the following \"size encoding\" of non-negative integers: "
"From each byte, the seven least significant bits are used to form the "
"resulting integer. As long as the most significant bit is 1, this process "
"continues; the byte with MSB 0 provides the last seven bits.  The seven-bit "
"chunks are concatenated. Later values are more significant."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:69
msgid ""
"This size encoding should not be confused with the \"offset encoding\", "
"which is also used in this document."
msgstr ""

#. type: Title ===
#: ../Documentation/technical/pack-format.txt:70
#, no-wrap
msgid "Deltified representation"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:76
msgid ""
"Conceptually there are only four object types: commit, tree, tag and "
"blob. However to save space, an object could be stored as a \"delta\" of "
"another \"base\" object. These representations are assigned new types "
"ofs-delta and ref-delta, which is only valid in a pack file."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:82
msgid ""
"Both ofs-delta and ref-delta store the \"delta\" to be applied to another "
"object (called 'base object') to reconstruct the object. The difference "
"between them is, ref-delta directly encodes base object name. If the base "
"object is in the same pack, ofs-delta encodes the offset of the base object "
"in the pack instead."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:87
msgid ""
"The base object could also be deltified if it's in the same pack.  Ref-delta "
"can also refer to an object outside the pack (i.e. the so-called \"thin "
"pack\"). When stored on disk however, the pack should be self contained to "
"avoid cyclic dependency."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:98
msgid ""
"The delta data starts with the size of the base object and the size of the "
"object to be reconstructed. These sizes are encoded using the size encoding "
"from above.  The remainder of the delta data is a sequence of instructions "
"to reconstruct the object from the base object. If the base object is "
"deltified, it must be converted to canonical form first. Each instruction "
"appends more and more data to the target object until it's complete. There "
"are two supported instructions so far: one for copy a byte range from the "
"source object and one for inserting new data embedded in the instruction "
"itself."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:102
msgid ""
"Each instruction has variable length. Instruction type is determined by the "
"seventh bit of the first octet. The following diagrams follow the convention "
"in RFC 1951 (Deflate compressed data format)."
msgstr ""

#. type: Title ====
#: ../Documentation/technical/pack-format.txt:103
#, no-wrap
msgid "Instruction to copy from base object"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:108
#, no-wrap
msgid ""
"  "
"+----------+---------+---------+---------+---------+-------+-------+-------+\n"
"  | 1xxxxxxx | offset1 | offset2 | offset3 | offset4 | size1 | size2 | size3 "
"|\n"
"  "
"+----------+---------+---------+---------+---------+-------+-------+-------+\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:112
msgid ""
"This is the instruction format to copy a byte range from the source "
"object. It encodes the offset to copy from and the number of bytes to "
"copy. Offset and size are in little-endian order."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:118
msgid ""
"All offset and size bytes are optional. This is to reduce the instruction "
"size when encoding small offsets or sizes. The first seven bits in the first "
"octet determines which of the next seven octets is present. If bit zero is "
"set, offset1 is present. If bit one is set offset2 is present and so on."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:123
msgid ""
"Note that a more compact instruction does not change offset and size "
"encoding. For example, if only offset2 is omitted like below, offset3 still "
"contains bits 16-23. It does not become offset2 and contains bits 8-15 even "
"if it's right next to offset1."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:127
#, no-wrap
msgid ""
"  +----------+---------+---------+\n"
"  | 10000101 | offset1 | offset3 |\n"
"  +----------+---------+---------+\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:132
msgid ""
"In its most compact form, this instruction only takes up one byte (0x80) "
"with both offset and size omitted, which will have default values "
"zero. There is another exception: size zero is automatically converted to "
"0x10000."
msgstr ""

#. type: Title ====
#: ../Documentation/technical/pack-format.txt:133
#, no-wrap
msgid "Instruction to add new data"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:138
#, no-wrap
msgid ""
"  +----------+============+\n"
"  | 0xxxxxxx |    data    |\n"
"  +----------+============+\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:143
msgid ""
"This is the instruction to construct target object without the base "
"object. The following data is appended to the target object. The first seven "
"bits of the first octet determines the size of data in bytes. The size must "
"be non-zero."
msgstr ""

#. type: Title ====
#: ../Documentation/technical/pack-format.txt:144
#, no-wrap
msgid "Reserved instruction"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:149
#, no-wrap
msgid ""
"  +----------+============\n"
"  | 00000000 |\n"
"  +----------+============\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:151
msgid "This is the instruction reserved for future expansion."
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:152
#, no-wrap
msgid "Original (version 1) pack-*.idx files have the following format:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:159
msgid ""
"The header consists of 256 4-byte network byte order integers.  N-th entry "
"of this table records the number of objects in the corresponding pack, the "
"first byte of whose object name is less than or equal to N.  This is called "
"the 'first-level fan-out' table."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:162
msgid ""
"The header is followed by sorted 24-byte entries, one entry per object in "
"the pack.  Each entry is:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:166
#, no-wrap
msgid ""
"4-byte network byte order integer, recording where the\n"
"object is stored in the packfile as the offset from the\n"
"beginning.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:168
msgid "one object name of the appropriate size."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:170
msgid "The file is concluded with a trailer:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:173
#, no-wrap
msgid ""
"A copy of the pack checksum at the end of the corresponding\n"
"packfile.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:175 ../Documentation/technical/pack-format.txt:276
msgid "Index checksum of all of the above."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:177
msgid "Pack Idx file:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:182
#, no-wrap
msgid ""
"+--------------------------------+\n"
"fanout\t    | fanout[0] = 2 (for example)    |-.\n"
"table\t    +--------------------------------+ |\n"
"\t    | fanout[1]                      | |\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:183
#, no-wrap
msgid "|\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:186
#, no-wrap
msgid ""
"| fanout[2]                      | |\n"
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n"
"| fanout[255] = total objects    |---.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:209
#, no-wrap
msgid ""
"+--------------------------------+ | |\n"
"main\t    | offset                         | | |\n"
"index\t    | object name 00XXXXXXXXXXXXXXXX | | |\n"
"table\t    +--------------------------------+ | |\n"
"\t    | offset                         | | |\n"
"\t    | object name 00XXXXXXXXXXXXXXXX | | |\n"
"\t    +--------------------------------+<+ |\n"
"\t  .-| offset                         |   |\n"
"\t  | | object name 01XXXXXXXXXXXXXXXX |   |\n"
"\t  | +--------------------------------+   |\n"
"\t  | | offset                         |   |\n"
"\t  | | object name 01XXXXXXXXXXXXXXXX |   |\n"
"\t  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   |\n"
"\t  | | offset                         |   |\n"
"\t  | | object name FFXXXXXXXXXXXXXXXX |   |\n"
"\t--| +--------------------------------+<--+\n"
"trailer\t  | | packfile checksum              |\n"
"\t  | +--------------------------------+\n"
"\t  | | idxfile checksum               |\n"
"\t  | +--------------------------------+\n"
"          .-------.\n"
"                  |\n"
"Pack file entry: <+\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:231
#, no-wrap
msgid ""
"     packed object header:\n"
"\t1-byte size extension bit (MSB)\n"
"\t       type (next 3 bit)\n"
"\t       size0 (lower 4-bit)\n"
"        n-byte sizeN (as long as MSB is set, each 7-bit)\n"
"\t\tsize0..sizeN form 4+7+7+..+7 bit integer, size0\n"
"\t\tis the least significant part, and sizeN is the\n"
"\t\tmost significant part.\n"
"     packed object data:\n"
"        If it is not DELTA, then deflated bytes (the size above\n"
"\t\tis the size before compression).\n"
"\tIf it is REF_DELTA, then\n"
"\t  base object name (the size above is the\n"
"\t\tsize of the delta data that follows).\n"
"          delta data, deflated.\n"
"\tIf it is OFS_DELTA, then\n"
"\t  n-byte offset (see below) interpreted as a negative\n"
"\t\toffset from the type-byte of the header of the\n"
"\t\tofs-delta entry (the size above is the size of\n"
"\t\tthe delta data that follows).\n"
"\t  delta data, deflated.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:238
#, no-wrap
msgid ""
"     offset encoding:\n"
"\t  n bytes with MSB set in all but the last one.\n"
"\t  The offset is then the number constructed by\n"
"\t  concatenating the lower 7 bit of each byte, and\n"
"\t  for n >= 2 adding 2^7 + 2^14 + ... + 2^(7*(n-1))\n"
"\t  to the result.\n"
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:241
#, no-wrap
msgid "Version 2 pack-*.idx files support packs larger than 4 GiB, and"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:243
#, no-wrap
msgid "   have some other reorganizations.  They have the format:\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:246
msgid "A 4-byte magic number '\\377tOc' which is an unreasonable fanout[0] value."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:248
msgid "A 4-byte version number (= 2)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:250
msgid "A 256-entry fan-out table just like v1."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:254
msgid ""
"A table of sorted object names.  These are packed together without offset "
"values to reduce the cache footprint of the binary search for a specific "
"object name."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:259
msgid ""
"A table of 4-byte CRC32 values of the packed object data.  This is new in v2 "
"so compressed data can be copied directly from pack to pack during repacking "
"without undetected data corruption."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:264
msgid ""
"A table of 4-byte offset values (in network byte order).  These are usually "
"31-bit pack file offsets, but large offsets are encoded as an index into the "
"next table with the msbit set."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:269
msgid ""
"A table of 8-byte offset entries (empty for pack files less than 2 GiB).  "
"Pack files are organized with heavily used objects toward the front, so most "
"object references should not need to refer to this table."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:271
msgid "The same trailer as a v1 pack file:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:274
#, no-wrap
msgid ""
"A copy of the pack checksum at the end of\n"
"corresponding packfile.\n"
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:277
#, no-wrap
msgid "pack-*.rev files have the format:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:280
msgid "A 4-byte magic number '0x52494458' ('RIDX')."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:282
msgid "A 4-byte version identifier (= 1)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:284
msgid "A 4-byte hash function identifier (= 1 for SHA-1, 2 for SHA-256)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:288
msgid ""
"A table of index positions (one per packed object, num_objects in total, "
"each a 4-byte unsigned integer in network order), sorted by their "
"corresponding offsets in the packfile."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:290
msgid "A trailer, containing a:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:292
#, no-wrap
msgid "checksum of the corresponding packfile, and\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:294
msgid "a checksum of all of the above."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:296 ../Documentation/technical/pack-format.txt:307
msgid "All 4-byte numbers are in network order."
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:297
#, no-wrap
msgid "multi-pack-index (MIDX) files have the following format:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:300
msgid "The multi-pack-index files refer to multiple pack-files and loose objects."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:305
msgid ""
"In order to allow extensions that add extra data to the MIDX, we organize "
"the body into \"chunks\" and provide a lookup table at the beginning of the "
"body. The header includes certain length values, such as the number of "
"packs, the number of base MIDX files, hash lengths and types."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:309
msgid "HEADER:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:312
#, no-wrap
msgid ""
"\t4-byte signature:\n"
"\t    The signature is: {'M', 'I', 'D', 'X'}\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:315
#, no-wrap
msgid ""
"\t1-byte version number:\n"
"\t    Git only writes or recognizes version 1.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:323
#, no-wrap
msgid ""
"\t1-byte Object Id Version\n"
"\t    We infer the length of object IDs (OIDs) from this value:\n"
"\t\t1 => SHA-1\n"
"\t\t2 => SHA-256\n"
"\t    If the hash type does not match the repository's hash algorithm,\n"
"\t    the multi-pack-index file should be ignored with a warning\n"
"\t    presented to the user.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:325
#, no-wrap
msgid "\t1-byte number of \"chunks\"\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:328
#, no-wrap
msgid ""
"\t1-byte number of base multi-pack-index files:\n"
"\t    This value is currently always zero.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:330
#, no-wrap
msgid "\t4-byte number of pack files\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:332
msgid "CHUNK LOOKUP:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:338
#, no-wrap
msgid ""
"\t(C + 1) * 12 bytes providing the chunk offsets:\n"
"\t    First 4 bytes describe chunk id. Value 0 is a terminating label.\n"
"\t    Other 8 bytes provide offset in current file for chunk to start.\n"
"\t    (Chunks are provided in file-order, so you can infer the length\n"
"\t    using the next chunk position if necessary.)\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:341
#, no-wrap
msgid ""
"\tThe CHUNK LOOKUP matches the table of contents from\n"
"\tlink:technical/chunk-format.html[the chunk-based file format].\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:345
#, no-wrap
msgid ""
"\tThe remaining data in the body is described one chunk at a time, and\n"
"\tthese chunks may be given in any order. Chunks are required unless\n"
"\totherwise specified.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:347
msgid "CHUNK DATA:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:353
#, no-wrap
msgid ""
"\tPackfile Names (ID: {'P', 'N', 'A', 'M'})\n"
"\t    Stores the packfile names as concatenated, null-terminated strings.\n"
"\t    Packfiles must be listed in lexicographic order for fast lookups by\n"
"\t    name. This is the only chunk not guaranteed to be a multiple of four\n"
"\t    bytes in length, so should be the last chunk for alignment reasons.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:358
#, no-wrap
msgid ""
"\tOID Fanout (ID: {'O', 'I', 'D', 'F'})\n"
"\t    The ith entry, F[i], stores the number of OIDs with first\n"
"\t    byte at most i. Thus F[255] stores the total\n"
"\t    number of objects.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:362
#, no-wrap
msgid ""
"\tOID Lookup (ID: {'O', 'I', 'D', 'L'})\n"
"\t    The OIDs for all objects in the MIDX are stored in lexicographic\n"
"\t    order in this chunk.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:375
#, no-wrap
msgid ""
"\tObject Offsets (ID: {'O', 'O', 'F', 'F'})\n"
"\t    Stores two 4-byte values for every object.\n"
"\t    1: The pack-int-id for the pack storing this object.\n"
"\t    2: The offset within the pack.\n"
"\t\tIf all offsets are less than 2^32, then the large offset chunk\n"
"\t\twill not exist and offsets are stored as in IDX v1.\n"
"\t\tIf there is at least one offset value larger than 2^32-1, then\n"
"\t\tthe large offset chunk must exist, and offsets larger than\n"
"\t\t2^31-1 must be stored in it instead. If the large offset chunk\n"
"\t\texists and the 31st bit is on, then removing that bit reveals\n"
"\t\tthe row in the large offsets containing the 8-byte offset of\n"
"\t\tthis object.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:378
#, no-wrap
msgid ""
"\t[Optional] Object Large Offsets (ID: {'L', 'O', 'F', 'F'})\n"
"\t    8-byte offsets into large packfiles.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:380
msgid "TRAILER:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:382
#, no-wrap
msgid "\tIndex checksum of the above contents.\n"
msgstr ""

#. type: Title ==
#: ../Documentation/technical/pack-format.txt:383
#, no-wrap
msgid "multi-pack-index reverse indexes"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:387
msgid ""
"Similar to the pack-based reverse index, the multi-pack index can also be "
"used to generate a reverse index."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:393
msgid ""
"Instead of mapping between offset, pack-, and index position, this reverse "
"index maps between an object's position within the MIDX, and that object's "
"position within a pseudo-pack that the MIDX describes (i.e., the ith entry "
"of the multi-pack reverse index holds the MIDX position of ith object in "
"pseudo-pack order)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:399
msgid ""
"To clarify the difference between these orderings, consider a multi-pack "
"reachability bitmap (which does not yet exist, but is what we are building "
"towards here). Each bit needs to correspond to an object in the MIDX, and so "
"we need an efficient mapping from bit position to MIDX position."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:405
msgid ""
"One solution is to let bits occupy the same position in the oid-sorted index "
"stored by the MIDX. But because oids are effectively random, their resulting "
"reachability bitmaps would have no locality, and thus compress poorly. (This "
"is the reason that single-pack bitmaps use the pack ordering, and not the "
".idx ordering, for the same purpose.)"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:412
msgid ""
"So we'd like to define an ordering for the whole MIDX based around pack "
"ordering, which has far better locality (and thus compresses more "
"efficiently). We can think of a pseudo-pack created by the concatenation of "
"all of the packs in the MIDX. E.g., if we had a MIDX with three packs (a, b, "
"c), with 10, 15, and 20 objects respectively, we can imagine an ordering of "
"the objects like:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:414
#, no-wrap
msgid "    |a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:418
msgid ""
"where the ordering of the packs is defined by the MIDX's pack list, and then "
"the ordering of objects within each pack is the same as the order in the "
"actual packfile."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:425
msgid ""
"Given the list of packs and their counts of objects, you can naïvely "
"reconstruct that pseudo-pack ordering (e.g., the object at position 27 must "
"be (c,1) because packs \"a\" and \"b\" consumed 25 of the slots). But "
"there's a catch. Objects may be duplicated between packs, in which case the "
"MIDX only stores one pointer to the object (and thus we'd want only one slot "
"in the bitmap)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:434
msgid ""
"Callers could handle duplicates themselves by reading objects in order of "
"their bit-position, but that's linear in the number of objects, and much too "
"expensive for ordinary bitmap lookups. Building a reverse index solves this, "
"since it is the logical inverse of the index, and that index has already "
"removed duplicates. But, building a reverse index on the fly can be "
"expensive. Since we already have an on-disk format for pack-based reverse "
"indexes, let's reuse it for the MIDX's pseudo-pack, too."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:440
msgid ""
"Objects from the MIDX are ordered as follows to string together the "
"pseudo-pack. Let `pack(o)` return the pack from which `o` was selected by "
"the MIDX, and define an ordering of packs based on their numeric ID (as "
"stored by the MIDX). Let `offset(o)` return the object offset of `o` within "
"`pack(o)`. Then, compare `o1` and `o2` as follows:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:443
msgid ""
"If one of `pack(o1)` and `pack(o2)` is preferred and the other is not, then "
"the preferred one sorts first."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:447
msgid ""
"(This is a detail that allows the MIDX bitmap to determine which pack should "
"be used by the pack-reuse mechanism, since it can ask the MIDX for the pack "
"containing the object at bit position 0)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:450
msgid ""
"If `pack(o1) ≠ pack(o2)`, then sort the two objects in descending order "
"based on the pack ID."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:454
msgid ""
"Otherwise, `pack(o1) = pack(o2)`, and the objects are sorted in pack-order "
"(i.e., `o1` sorts ahead of `o2` exactly when `offset(o1)  < offset(o2)`)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:458
msgid ""
"In short, a MIDX's pseudo-pack is the de-duplicated concatenation of objects "
"in packs stored by the MIDX, laid out in pack order, and the packs arranged "
"in MIDX order (with the preferred pack coming first)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/pack-format.txt:464
msgid ""
"Finally, note that the MIDX's reverse index is not stored as a chunk in the "
"multi-pack-index itself. This is done because the reverse index includes the "
"checksum of the pack or MIDX to which it belongs, which makes it impossible "
"to write in the MIDX. To avoid races when rewriting the MIDX, a MIDX reverse "
"index includes the MIDX's checksum in its filename (e.g., "
"`multi-pack-index-xyz.rev`)."
msgstr ""
