# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 2.0\n"
"POT-Creation-Date: 2022-09-24 21:41+0900\n"
"PO-Revision-Date: 2022-10-13 04:31+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/technical/rerere.txt:2
#, no-wrap
msgid "Rerere"
msgstr "Rerere"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:5
msgid "This document describes the rerere logic."
msgstr "このドキュメントでは、rerereのロジックについて説明します。"

#. type: Title -
#: ../Documentation-sedout/technical/rerere.txt:7
#, no-wrap
msgid "Conflict normalization"
msgstr "競合の正規化"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:14
msgid ""
"To ensure recorded conflict resolutions can be looked up in the rerere "
"database, even when branches are merged in a different order, different "
"branches are merged that result in the same conflict, or when different "
"conflict style settings are used, rerere normalizes the conflicts before "
"writing them to the rerere database."
msgstr ""
"記録された競合解決をrerereデータベースで確実に検索できるように、ブランチが異"
"なる順序でマージされた場合でも、 異なるブランチがマージされて同一の競合が発生"
"するか、または、異なる競合スタイル設定が使用されている場合、rerereはそれらを"
"rerereデータベースに書き込む前に競合を正規化します。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:20
msgid ""
"Different conflict styles and branch names are normalized by stripping the "
"labels from the conflict markers, and removing the common ancestor version "
"from the `diff3` or `zdiff3` conflict styles.  Branches that are merged in "
"different order are normalized by sorting the conflict hunks.  More on each "
"of those steps in the following sections."
msgstr "競合マーカーからラベルを取り除き、そして、 `diff3` または `zdiff3` 競合スタイルから共通の祖先のバージョンを削除することにより、異なる競合スタイルとブランチ名が正規化されます。 異なる順序でマージされるブランチは、競合ハンクを並べ替えることによって正規化されます。 以下のセクションで、これらの各ステップについて詳しく説明します。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:24
msgid ""
"Once these two normalization operations are applied, a conflict ID is "
"calculated based on the normalized conflict, which is later used by rerere "
"to look up the conflict in the rerere database."
msgstr ""
"これらの2つの正規化操作が適用されると、正規化された競合に基づいて競合IDが計算"
"されます。これは、後でrerereが、rerereデータベースで競合を検索するために使用"
"します。"

#. type: Title ~
#: ../Documentation-sedout/technical/rerere.txt:26
#, no-wrap
msgid "Removing the common ancestor version"
msgstr "Removing the common ancestor version"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:34
msgid ""
"Say we have three branches AB, AC and AC2.  The common ancestor of these "
"branches has a file with a line containing the string \"A\" (for brevity "
"this is called \"line A\" in the rest of the document).  In branch AB this "
"line is changed to \"B\", in AC, this line is changed to \"C\", and branch "
"AC2 is forked off of AC, after the line was changed to \"C\"."
msgstr ""
"AB、AC、AC2 の3つのブランチがあるとします。 これらのブランチの共通の祖先に"
"は、文字列「A」の行を含むファイルがあります(簡潔にするために、これはドキュメ"
"ントの残りの部分では「行A」と呼びます)。 ブランチABでは、この行は「B」に変更"
"され、ACでは、この行は「C」に変更され、ブランチAC2は、行が「C」に変更された"
"後、ACから分岐します。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:37
msgid ""
"Forking a branch ABAC off of branch AB and then merging AC into it, we get a "
"conflict like the following:"
msgstr ""
"ブランチABACをブランチABからフォークし、ACをブランチABにマージすると、以下の"
"ような競合が発生します:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:43
#, no-wrap
msgid ""
"    <<<<<<< HEAD\n"
"    B\n"
"    =======\n"
"    C\n"
"    >>>>>>> AC\n"
msgstr ""
"    <<<<<<< HEAD\n"
"    B\n"
"    =======\n"
"    C\n"
"    >>>>>>> AC\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:47
msgid ""
"Doing the analogous with AC2 (forking a branch ABAC2 off of branch AB and "
"then merging branch AC2 into it), using the diff3 or zdiff3 conflict style, "
"we get a conflict like the following:"
msgstr "AC2と同様のことを行うと(ブランチABからブランチABAC2をフォークし、次にブランチAC2をそれにマージする)、diff3 または zdiff3 競合スタイルを使用して、以下のような競合が発生します:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:55
#, no-wrap
msgid ""
"    <<<<<<< HEAD\n"
"    B\n"
"    ||||||| merged common ancestors\n"
"    A\n"
"    =======\n"
"    C\n"
"    >>>>>>> AC2\n"
msgstr ""
"    <<<<<<< HEAD\n"
"    B\n"
"    ||||||| merged common ancestors\n"
"    A\n"
"    =======\n"
"    C\n"
"    >>>>>>> AC2\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:57
msgid "By resolving this conflict, to leave line D, the user declares:"
msgstr "この競合を解決して行Dを残すために、ユーザーは以下のように宣言します:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:61
#, no-wrap
msgid ""
"    After examining what branches AB and AC did, I believe that making\n"
"    line A into line D is the best thing to do that is compatible with\n"
"    what AB and AC wanted to do.\n"
msgstr ""
"    ABとACのブランチが何をしたかを調べた後、\n"
"    行Aを行Dにすることが、\n"
"    ABとACがやりたかったことと互換性のある最善の方法であると私は信じています。\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:64
msgid ""
"As branch AC2 refers to the same commit as AC, the above implies that this "
"is also compatible what AB and AC2 wanted to do."
msgstr ""
"ブランチAC2はACと同じコミットを参照するため、上記は、これがABとAC2が実行した"
"かったこととも互換性があることを意味します。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:69
msgid ""
"By extension, this means that rerere should recognize that the above "
"conflicts are the same.  To do this, the labels on the conflict markers are "
"stripped, and the common ancestor version is removed.  The above examples "
"would both result in the following normalized conflict:"
msgstr ""
"ひいては、これは、rerereが上記の競合が同一であることを認識する必要があること"
"を意味します。 これを行うには、競合マーカーのラベルを削除し、共通の祖先バー"
"ジョンを削除します。 上記の例は両方とも、以下の正規化された競合を引き起こしま"
"す:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:75
#, no-wrap
msgid ""
"    <<<<<<<\n"
"    B\n"
"    =======\n"
"    C\n"
"    >>>>>>>\n"
msgstr ""
"    <<<<<<<\n"
"    B\n"
"    =======\n"
"    C\n"
"    >>>>>>>\n"

#. type: Title ~
#: ../Documentation-sedout/technical/rerere.txt:77
#, no-wrap
msgid "Sorting hunks"
msgstr "Sorting hunks"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:82
msgid ""
"As before, lets imagine that a common ancestor had a file with line A its "
"early part, and line X in its late part.  And then four branches are forked "
"that do these things:"
msgstr ""
"上記同様に、共通の祖先が、前半に行A、後期に行Xのファイルを持っていたと想像し"
"てみてください。 そして、これらのことを行う4つのブランチがフォークされます:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:84
msgid "AB: changes A to B"
msgstr "AB: changes A to B"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:85
msgid "AC: changes A to C"
msgstr "AC: changes A to C"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:86
msgid "XY: changes X to Y"
msgstr "XY: changes X to Y"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:87
msgid "XZ: changes X to Z"
msgstr "XZ: changes X to Z"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:93
msgid ""
"Now, forking a branch ABAC off of branch AB and then merging AC into it, and "
"forking a branch ACAB off of branch AC and then merging AB into it, would "
"yield the conflict in a different order.  The former would say \"A became B "
"or C, what now?\" while the latter would say \"A became C or B, what now?\""
msgstr ""
"ここで、ブランチABACをブランチABからフォークしてから、ACをそれにマージし、ブ"
"ランチACABをブランチACからフォークしてから、ABをブランチにマージすると、異な"
"る順序で競合が発生します。 前者は「Aが、BかCになった、今は何？」と言うでしょ"
"う。 後者は「Aが、CまたはBになった、今は何？」と言うでしょう。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:96
msgid ""
"As a reminder, the act of merging AC into ABAC and resolving the conflict to "
"leave line D means that the user declares:"
msgstr ""
"思い出してください、ACをABACにマージし、競合を解決して行Dを残すという行為は、"
"ユーザーが以下の宣言をすることを意味します:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:100
#, no-wrap
msgid ""
"    After examining what branches AB and AC did, I believe that\n"
"    making line A into line D is the best thing to do that is\n"
"    compatible with what AB and AC wanted to do.\n"
msgstr ""
"    ABとACのブランチが何をしたかを調べた後、\n"
"    行Aを行Dにすることが、\n"
"    ABとACがやりたかったことと互換性のある最善の方法であると私は信じています。\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:104
msgid ""
"So the conflict we would see when merging AB into ACAB should be resolved "
"the same way---it is the resolution that is in line with that declaration."
msgstr ""
"したがって、ABをACABにマージするときに発生する競合は、同一の方法で解決する必"
"要があります -- その宣言に沿った決断です。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:108
msgid ""
"Imagine that similarly previously a branch XYXZ was forked from XY, and XZ "
"was merged into it, and resolved \"X became Y or Z\" into \"X became W\"."
msgstr ""
"同様に、以前にブランチXYXZがXYからフォークされ、XZがそれにマージされ、「Xが、"
"YまたはZになった」を「XがWになった」に解決されたと想像してください。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:113
msgid ""
"Now, if a branch ABXY was forked from AB and then merged XY, then ABXY would "
"have line B in its early part and line Y in its later part.  Such a merge "
"would be quite clean.  We can construct 4 combinations using these four "
"branches ((AB, AC) x (XY, XZ))."
msgstr ""
"ここで、ブランチABXYがABから分岐され、XYがマージされた場合、ABXYの初期部分に"
"は行Bがあり、後期部分には行Yがあります。 このようなマージは非常にクリーンで"
"す。 これらの4つのブランチ（`(AB, AC) x (XY, XZ)`)を使用して4つの組み合わせを"
"構築できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:118
msgid ""
"Merging ABXY and ACXZ would make \"an early A became B or C, a late X became "
"Y or Z\" conflict, while merging ACXY and ABXZ would make \"an early A "
"became C or B, a late X became Y or Z\".  We can see there are 4 "
"combinations of (\"B or C\", \"C or B\") x (\"X or Y\", \"Y or X\")."
msgstr ""
"ABXYとACXZをマージすると、「初期のAが、BまたはCになり、後期のXが、YまたはZに"
"なります」という競合が発生し、ACXYとABXZをマージすると、「初期のAが、CまたはB"
"になり、後期のX、がYまたはZになります」。 これで（\"BまたはC\"、 \"CまたはB"
"\"）x（ \"XまたはY\"、 \"YまたはX\"）の4つの組み合わせがあることがわかりま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:123
msgid ""
"By sorting, the conflict is given its canonical name, namely, \"an early "
"part became B or C, a late part became X or Y\", and whenever any of these "
"four patterns appear, and we can get to the same conflict and resolution "
"that we saw earlier."
msgstr ""
"並べ替えることにより、競合には「初期部分がBまたはCになり、後期部分がXまたはY"
"になります」という正規の名前が付けられ、これら4つのパターンのいずれかが表示さ"
"れるたびに、先ほど見た同一の競合と解決に到達できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:126
msgid ""
"Without the sorting, we'd have to somehow find a previous resolution from "
"combinatorial explosion."
msgstr ""
"並べ替えがないと、組み合わせの爆発から以前の解決策をどうにかして見つける必要"
"があります。"

#. type: Title ~
#: ../Documentation-sedout/technical/rerere.txt:128
#, no-wrap
msgid "Conflict ID calculation"
msgstr "Conflict ID calculation"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:137
msgid ""
"Once the conflict normalization is done, the conflict ID is calculated as "
"the sha1 hash of the conflict hunks appended to each other, separated by "
"<NUL> characters.  The conflict markers are stripped out before the sha1 is "
"calculated.  So in the example above, where we merge branch AC which changes "
"line A to line C, into branch AB, which changes line A to line C, the "
"conflict ID would be SHA1('B<NUL>C<NUL>')."
msgstr "競合の正規化が行われると、競合IDは、<NUL>文字で区切られ、競合ハンクのお互いを合わせたモノのsha1ハッシュとして計算されます。 競合マーカーは、sha1が計算される前に削除されます。 したがって、上記の例では、行Aを行Cに変更するブランチACを、行Aを行Cに変更するブランチABにマージすると、競合IDは SHA1(`B <NUL> C <NUL>`)になります。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:141
msgid ""
"If there are multiple conflicts in one file, the sha1 is calculated the same "
"way with all hunks appended to each other, in the order in which they appear "
"in the file, separated by a <NUL> character."
msgstr ""
"1つのファイルに複数の競合がある場合、sha1は同じ方法で計算され、すべてのハンク"
"がファイルに表示される順序で<NUL>文字で区切られてお互いに合わせられます。"

#. type: Title ~
#: ../Documentation-sedout/technical/rerere.txt:143
#, no-wrap
msgid "Nested conflicts"
msgstr "Nested conflicts"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:151
msgid ""
"Nested conflicts are handled very similarly to \"simple\" conflicts.  "
"Similar to simple conflicts, the conflict is first normalized by stripping "
"the labels from conflict markers, stripping the common ancestor version, and "
"the sorting the conflict hunks, both for the outer and the inner conflict.  "
"This is done recursively, so any number of nested conflicts can be handled."
msgstr ""
"入れ子になった競合は、「単純な」競合と非常によく似た処理が行われます。 単純な"
"競合と同様に、競合は最初に、競合マーカーからラベルを削除し、共通の祖先バー"
"ジョンを削除し、外部と内部の両方の競合について競合ハンクを並べ替えることに"
"よって正規化されます。 これは再帰的に実行されるため、入れ子になった競合をいく"
"つでも処理できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:155
msgid ""
"Note that this only works for conflict markers that \"cleanly nest\".  If "
"there are any unmatched conflict markers, rerere will fail to handle the "
"conflict and record a conflict resolution."
msgstr ""
"注意：これは、「きれいに入れ子になった」競合マーカーに対してのみ機能すること"
"に注意してください。 一致しない競合マーカーがある場合、rerereは競合の処理と競"
"合解決の記録に失敗します。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:159
msgid ""
"The only difference is in how the conflict ID is calculated.  For the inner "
"conflict, the conflict markers themselves are not stripped out before "
"calculating the sha1."
msgstr ""
"唯一の違いは、競合IDの計算方法にあります。 内部競合の場合、sha1を計算する前に"
"競合マーカー自体が削除されません。"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:161
msgid "Say we have the following conflict for example:"
msgstr "たとえば、以下の競合があるとします:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:171
#, no-wrap
msgid ""
"    <<<<<<< HEAD\n"
"    1\n"
"    =======\n"
"    <<<<<<< HEAD\n"
"    3\n"
"    =======\n"
"    2\n"
"    >>>>>>> branch-2\n"
"    >>>>>>> branch-3~\n"
msgstr ""
"    <<<<<<< HEAD\n"
"    1\n"
"    =======\n"
"    <<<<<<< HEAD\n"
"    3\n"
"    =======\n"
"    2\n"
"    >>>>>>> branch-2\n"
"    >>>>>>> branch-3~\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:174
msgid ""
"After stripping out the labels of the conflict markers, and sorting the "
"hunks, the conflict would look as follows:"
msgstr ""
"競合マーカーのラベルを取り除き、ハンクを並べ替えると、競合は以下のようになり"
"ます:"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:184
#, no-wrap
msgid ""
"    <<<<<<<\n"
"    1\n"
"    =======\n"
"    <<<<<<<\n"
"    2\n"
"    =======\n"
"    3\n"
"    >>>>>>>\n"
"    >>>>>>>\n"
msgstr ""
"    <<<<<<<\n"
"    1\n"
"    =======\n"
"    <<<<<<<\n"
"    2\n"
"    =======\n"
"    3\n"
"    >>>>>>>\n"
"    >>>>>>>\n"

#. type: Plain text
#: ../Documentation-sedout/technical/rerere.txt:186
msgid ""
"and finally the conflict ID would be calculated as: `sha1('1<NUL><<<<<<<"
"\\n3\\n=======\\n2\\n>>>>>>><NUL>')`"
msgstr ""
"最後に、競合IDは次のように計算されます。 `sha1('1<NUL><<<<<<<\\n3\\n======="
"\\n2\\n>>>>>>><NUL>')` "
