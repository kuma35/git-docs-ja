# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2023-07-18 11:06+0900\n"
"PO-Revision-Date: 2021-12-31 08:18+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/technical/parallel-checkout.txt:2
#, no-wrap
msgid "Parallel Checkout Design Notes"
msgstr "Parallel Checkout Design Notes"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:9
msgid ""
"The \"Parallel Checkout\" feature attempts to use multiple processes to "
"parallelize the work of uncompressing the blobs, applying in-core filters, "
"and writing the resulting contents to the working tree during a checkout "
"operation. It can be used by all checkout-related commands, such as `clone`, "
"`checkout`, `reset`, `sparse-checkout`, and others."
msgstr ""
"「並列チェックアウト」(Parallel Checkout)機能は、複数のプロセスを使用して、ブ"
"ロブの圧縮解除、コア内フィルターの適用、およびチェックアウト操作中に結果のコ"
"ンテンツを作業ツリーに書き込む作業を並列化しようとします。 これは、 `clone` "
"や `checkout` や `reset` や` sparse-checkout` などのすべてのチェックアウト関"
"連コマンドで使用できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:11
msgid "These commands share the following basic structure:"
msgstr "これらのコマンドは、以下の共通の基本構造を持っています:"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:13
msgid "Step 1: Read the current index file into memory."
msgstr "ステップ1: 現在のインデックスファイルをメモリに読み込みます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:16
msgid ""
"Step 2: Modify the in-memory index based upon the command, and temporarily "
"mark all cache entries that need to be updated."
msgstr ""
"ステップ2: コマンドに基づいてメモリ内インデックスを変更し、更新が必要なすべて"
"のキャッシュエントリに一時的なマークを付けます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:21
msgid ""
"Step 3: Populate the working tree to match the new candidate index.  This "
"includes iterating over all of the to-be-updated cache entries and delete, "
"create, or overwrite the associated files in the working tree."
msgstr ""
"ステップ3: 新しい候補インデックスに一致するように作業ツリーにデータを配置しま"
"す。これには、更新されるすべてのキャッシュエントリの反復と、作業ツリー内の関"
"連ファイルの削除、作成、または上書き作業が含まれます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:23
msgid "Step 4: Write the new index to disk."
msgstr "ステップ4: 新しいインデックスをディスクに書き込みます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:25
msgid "Step 3 is the focus of the \"parallel checkout\" effort described here."
msgstr "ステップ3が、ここで説明する「並列チェックアウト」作業の焦点です。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:27
#, no-wrap
msgid "Sequential Implementation"
msgstr "Sequential Implementation"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:32
msgid ""
"For the purposes of discussion here, the current sequential implementation "
"of Step 3 is divided in 3 parts, each one implemented in its own function:"
msgstr ""
"ここで説明する、ステップ3の現在の実装は、3つの部分に分かれており、それぞれが"
"独自の機能で実装されています。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:37
msgid ""
"Step 3a: `unpack-trees.c:check_updates()` contains a series of sequential "
"loops iterating over the `cache_entry`'s array. The main loop in this "
"function calls the Step 3b function for each of the to-be-updated entries."
msgstr ""
"ステップ3a: `unpack-trees.c:check_updates()` には、 `cache_entry` の配列を反"
"復処理する一連の処理ループが含まれています。この関数のメインループは、更新さ"
"れるエントリごとに ステップ3b 関数を呼び出します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:42
msgid ""
"Step 3b: `entry.c:checkout_entry()` examines the existing working tree for "
"file conflicts, collisions, and unsaved changes. It removes files and "
"creates leading directories as necessary. It calls the Step 3c function for "
"each entry to be written."
msgstr ""
"ステップ3b: `entry.c:checkout_entry()` は、ファイルの競合、衝突、および保存さ"
"れていない変更について、既存の作業ツリーを調べます。必要に応じてファイルを削"
"除し、先頭のディレクトリを作成します。書き込まれるエントリごとに ステップ3c "
"関数を呼び出します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:47
msgid ""
"Step 3c: `entry.c:write_entry()` loads the blob into memory, smudges it if "
"necessary, creates the file in the working tree, writes the smudged "
"contents, calls `fstat()` or `lstat()`, and updates the associated "
"`cache_entry` struct with the stat information gathered."
msgstr ""
"ステップ3c: ： `entry.c:write_entry()` はブロブをメモリにロードし、必要に応じ"
"てsmudgeし、作業ツリーにファイルを作成し、smudgeされたコンテンツを書き込み、 "
"`fstat()` または `lstat()` を呼び出します。収集された統計情報で、関連する "
"`cache_entry` 構造体を更新します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:53
msgid ""
"It wouldn't be safe to perform Step 3b in parallel, as there could be race "
"conditions between file creations and removals. Instead, the parallel "
"checkout framework lets the sequential code handle Step 3b, and uses "
"parallel workers to replace the sequential `entry.c:write_entry()` calls "
"from Step 3c."
msgstr ""
"ファイルの作成と削除の間に競合状態が発生する可能性があるため、ステップ3bを並"
"行して実行することは安全ではありません。代わりに、並列チェックアウトフレーム"
"ワークにより、シーケンシャルコードでステップ3bを処理し、並列ワーカーを使用し"
"て、ステップ3cからのシーケンシャル `entry.c:write_entry()` 関数呼び出しを置き"
"換えます。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:55
#, no-wrap
msgid "Rejected Multi-Threaded Solution"
msgstr "Rejected Multi-Threaded Solution"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:67
#, fuzzy
#| msgid ""
#| "The most \"straightforward\" implementation would be to spread the set of "
#| "to-be-updated cache entries across multiple threads. But due to the "
#| "thread-unsafe functions in the ODB code, we would have to use locks to "
#| "coordinate the parallel operation. An early prototype of this solution "
#| "showed that the multi-threaded checkout would bring performance "
#| "improvements over the sequential code, but there was still too much lock "
#| "contention. A `perf` profiling indicated that around 20% of the runtime "
#| "during a local Linux clone (on an SSD) was spent in locking functions.  "
#| "For this reason this approach was rejected in favor of using multiple "
#| "child processes, which led to a better performance."
msgid ""
"The most \"straightforward\" implementation would be to spread the set of to-"
"be-updated cache entries across multiple threads. But due to the thread-"
"unsafe functions in the object database code, we would have to use locks to "
"coordinate the parallel operation. An early prototype of this solution "
"showed that the multi-threaded checkout would bring performance improvements "
"over the sequential code, but there was still too much lock contention. A "
"`perf` profiling indicated that around 20% of the runtime during a local "
"Linux clone (on an SSD) was spent in locking functions.  For this reason "
"this approach was rejected in favor of using multiple child processes, which "
"led to a better performance."
msgstr ""
"最も「簡単な」(straightforward)実装は、更新されるキャッシュエントリのセットを"
"複数のスレッドに分散させることです。ただし、ODBコードのスレッドセーフでない関"
"数のため、並列操作を調整するためにロックを使用する必要があります。このソ"
"リューションの初期のプロトタイプは、マルチスレッドチェックアウトによってシー"
"ケンシャルコードよりもパフォーマンスが向上することを示していましたが、それで"
"もロックの競合が多すぎました。 `perf` プロファイリングは、(SSD上の)ローカル"
"Linuxクローン中のランタイムの約20％が機能のロックに費やされたことを示しまし"
"た。このため、このアプローチはリジェクトされ、複数の子プロセスを使用すること"
"により、パフォーマンスが向上しました。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:69
#, no-wrap
msgid "Multi-Process Solution"
msgstr "Multi-Process Solution"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:75
msgid ""
"Parallel checkout alters the aforementioned Step 3 to use multiple "
"`checkout--worker` background processes to distribute the work. The long-"
"running worker processes are controlled by the foreground Git command using "
"the existing run-command API."
msgstr ""
"並列チェックアウトは、前述のステップ3を変更して、複数の `checkout--worker` "
"バックグラウンドプロセスを使用して作業を分散します。長時間実行されるワーカー"
"プロセスは、既存のrun-command APIを使用するフォアグラウンドGitコマンドによっ"
"て制御されます。"

#. type: Title ~
#: ../Documentation-sedout/technical/parallel-checkout.txt:77
#, no-wrap
msgid "Overview"
msgstr "Overview"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:81
msgid ""
"Step 3b is only slightly altered; for each entry to be checked out, the main "
"process performs the following steps:"
msgstr ""
"ステップ3bはわずかに変更されています。チェックアウトするエントリごとに、メイ"
"ンプロセスは以下の手順を実行します:"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:85
msgid ""
"M1: Check whether there is any untracked or unclean file in the working tree "
"which would be overwritten by this entry, and decide whether to proceed "
"(removing the file(s)) or not."
msgstr ""
"M1: 作業ツリーに、このエントリによって上書きされる、追跡されていないファイル"
"またはクリーンでないファイルがあるかどうかを確認し、続行する(ファイルを削除す"
"る)かどうかを決定します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:87
msgid "M2: Create the leading directories."
msgstr "M2: 先頭のディレクトリを作成します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:89
msgid "M3: Load the conversion attributes for the entry's path."
msgstr "M3: エントリのパスの変換属性をロードします。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:95
msgid ""
"M4: Check, based on the entry's type and conversion attributes, whether the "
"entry is eligible for parallel checkout (more on this later). If it is "
"eligible, enqueue the entry and the loaded attributes to later write the "
"entry in parallel. If not, write the entry right away, using the default "
"sequential code."
msgstr ""
"M4: エントリのタイプと変換属性に基づいて、エントリが並列チェックアウトの対象"
"であるかどうかを確認します(詳しくは後述します)。適格である場合は、エントリと"
"ロードされた属性をキューに入れて、後でエントリを並行して書き込みます。そうで"
"ない場合は、デフォルトのシーケンシャルコードを使用して、すぐにエントリを記述"
"します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:103
msgid ""
"Note: we save the conversion attributes associated with each entry because "
"the workers don't have access to the main process' index state, so they "
"can't load the attributes by themselves (and the attributes are needed to "
"properly smudge the entry). Additionally, this has a positive impact on "
"performance as (1) we don't need to load the attributes twice and (2) the "
"attributes machinery is optimized to handle paths in sequential order."
msgstr ""
"注: ワーカーはメインプロセスのインデックス状態にアクセスできないため、各エン"
"トリに関連付けられた変換属性を保存します。そのため、ワーカーは属性を自分で"
"ロードできません(また、属性はエントリを適切にsmudgeするために必要です)。 さら"
"に、これは、 (1)属性を2回ロードする必要がなく、 (2)属性機構がパスを順番に処理"
"するように最適化されているため、パフォーマンスにプラスの影響を与えます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:111
msgid ""
"After all entries have passed through the above steps, the main process "
"checks if the number of enqueued entries is sufficient to spread among the "
"workers. If not, it just writes them sequentially. Otherwise, it spawns the "
"workers and distributes the queued entries uniformly in continuous chunks. "
"This aims to minimize the chances of two workers writing to the same "
"directory simultaneously, which could increase lock contention in the kernel."
msgstr ""
"すべてのエントリが上記の手順を通過した後、メインプロセスは、キューに入れられ"
"たエントリの数がワーカー間で分散するのに十分であるかどうかを確認します。 そう"
"でない場合は、それらを順番に書き込みます。それ以外の場合は、ワーカーを生成"
"し、キューに入れられたエントリを連続したチャンクに均一に分散します。これは、2"
"人のワーカーが同じディレクトリに同時に書き込む可能性を最小限に抑えることを目"
"的としています。これにより、カーネルでのロックの競合が増える可能性がありま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:113
msgid "Then, for each assigned item, each worker:"
msgstr "次に、割り当てられたアイテムごとに、各ワーカーは以下のようになります:"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:118
msgid ""
"W1: Checks if there is any non-directory file in the leading part of the "
"entry's path or if there already exists a file at the entry' path.  If so, "
"mark the entry with `PC_ITEM_COLLIDED` and skip it (more on this later)."
msgstr ""
"W1: エントリのパスの先頭部分にディレクトリ以外のファイルがあるかどうか、また"
"はエントリのパスにファイルがすでに存在するかどうかを確認します。その場合は、"
"エントリに `PC_ITEM_COLLIDED` のマークを付けてスキップします(これについては後"
"で詳しく説明します)。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:120
msgid "W2: Creates the file (with O_CREAT and O_EXCL)."
msgstr "W2: ファイルを作成します(O_CREAT と O_EXCLを使用)。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:123
msgid "W3: Loads the blob into memory (inflating and delta reconstructing it)."
msgstr "W3: ブロブをメモリにロードします(インフレーションとデルタ再構築)。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:126
msgid ""
"W4: Applies any required in-process filter, like end-of-line conversion and "
"re-encoding."
msgstr ""
"W4: 行末変換や再エンコードなど、必要なインプロセスフィルターを適用します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:128
msgid "W5: Writes the result to the file descriptor opened at W2."
msgstr "W5: 結果を、W2で開かれたファイルデスクリプターに書き込みます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:132
msgid ""
"W6: Calls `fstat()` or lstat()` on the just-written path, and sends the "
"result back to the main process, together with the end status of the "
"operation and the item's identification number."
msgstr ""
"W6: 書き込んだパスで `fstat()`または `lstat()` を呼び出し、操作の終了ステータ"
"スとアイテムの識別番号とともに、結果をメインプロセスに送り返します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:135
msgid ""
"Note that, when possible, steps W3 to W5 are delegated to the streaming "
"machinery, removing the need to keep the entire blob in memory."
msgstr ""
"注意: 可能な場合、ステップW3からW5はストリーミング機構に委任され、ブロブ全体"
"をメモリに保持する必要がなくなることに注意してください。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:139
msgid ""
"If the worker fails to read the blob or to write it to the working tree, it "
"removes the created file to avoid leaving empty files behind. This is the "
"*only* time a worker is allowed to remove a file."
msgstr ""
"ワーカーがブロブの読み取りまたは作業ツリーへの書き込みに失敗した場合、空の"
"ファイルが残らないように、作成されたファイルを削除します。これは、ワーカーが"
"ファイルを削除できる「唯一の」時間です。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:145
msgid ""
"As mentioned earlier, it is the responsibility of the main process to remove "
"any file that blocks the checkout operation (or abort if the removal(s) "
"would cause data loss and the user didn't ask to `--force`).  This is "
"crucial to avoid race conditions and also to properly detect path collisions "
"at Step W1."
msgstr ""
"前述のように、チェックアウト操作をブロックするファイルを削除するのはメインプ"
"ロセスの責任です(または、削除によってデータが失われ、ユーザーが `--force` を"
"要求しなかった場合は中止します)。これは、競合状態を回避し、ステップW1でパスの"
"衝突を適切に検出するために重要です。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:148
msgid ""
"After the workers finish writing the items and sending back the required "
"information, the main process handles the results in two steps:"
msgstr ""
"ワーカーがアイテムの書き込みと必要な情報の返送を完了した後、メインプロセスは"
"以下の2ステップで結果を処理します:"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:152
msgid ""
"First, it updates the in-memory index with the `lstat()` information sent by "
"the workers. (This must be done first as this information might me required "
"in the following step.)"
msgstr ""
"最初に、ワーカーから送信された `lsat()` 情報でメモリ内のインデックスを更新し"
"ます。(この情報は次のステップで必要になる可能性があるため、これを最初に実行す"
"る必要があります。)"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:155
msgid ""
"Then it writes the items which collided on disk (i.e. items marked with "
"`PC_ITEM_COLLIDED`). More on this below."
msgstr ""
"次に、ディスクに、衝突したアイテム(つまり、 `PC_ITEM_COLLIDED` でマークされた"
"アイテム)を書き込みます。これについては、以下で詳しく説明します。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:157
#, no-wrap
msgid "Path Collisions"
msgstr "Path Collisions"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:162
msgid ""
"Path collisions happen when two different paths correspond to the same entry "
"in the file system. E.g. the paths 'a' and 'A' would collide in a case-"
"insensitive file system."
msgstr ""
"パスの衝突は、2つの異なるパスがファイルシステムの同じエントリに対応している場"
"合に発生します。 例えば、パス 'a' と 'A' は、大文字と小文字を区別しないファイ"
"ルシステムで衝突します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:171
msgid ""
"The sequential checkout deals with collisions in the same way that it deals "
"with files that were already present in the working tree before checkout. "
"Basically, it checks if the path that it wants to write already exists on "
"disk, makes sure the existing file doesn't have unsaved data, and then "
"overwrites it. (To be more pedantic: it deletes the existing file and "
"creates the new one.) So, if there are multiple colliding files to be "
"checked out, the sequential code will write each one of them but only the "
"last will actually survive on disk."
msgstr ""
"シーケンシャルチェックアウトは、チェックアウト前に作業ツリーにすでに存在して"
"いたファイルを処理するのと同じ方法で衝突を処理します。基本的には、書き込みた"
"いパスがディスク上に既に存在するかどうかをチェックし、既存のファイルに未保存"
"のデータがないことを確認してから、上書きします。 （よりわかりやすくするため"
"に、既存のファイルを削除して新しいファイルを作成します。）したがって、チェッ"
"クアウトする衝突ファイルが複数ある場合、シーケンシャルなコードではそれぞれを"
"書き込みますが、実際には最後のファイルのみがディスク上に残ります。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:180
msgid ""
"Parallel checkout aims to reproduce the same behavior. However, we cannot "
"let the workers racily write to the same file on disk. Instead, the workers "
"detect when the entry that they want to check out would collide with an "
"existing file, and mark it with `PC_ITEM_COLLIDED`.  Later, the main process "
"can sequentially feed these entries back to `checkout_entry()` without the "
"risk of race conditions. On clone, this also has the effect of marking the "
"colliding entries to later emit a warning for the user, like the classic "
"sequential checkout does."
msgstr ""
"並列チェックアウトは、同じ動作を再現することを目的としています。 ただし、ワー"
"カーにディスク上の同じファイルにあわてて書き込むことはできません。代わりに、"
"ワーカーは、チェックアウトするエントリが既存のファイルと衝突するタイミングを"
"検出し、 `PC_ITEM_COLLIDED` でマークします。 後で、メインプロセスは、競合状態"
"のリスクなしに、これらのエントリを順番に `checkout_entry()` にフィードバック"
"できます。クローンでは、これには、従来のシーケンシャルチェックアウトと同様"
"に、衝突するエントリにマークを付けて、後でユーザーに警告を発する効果もありま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:191
msgid ""
"The workers are able to detect both collisions among the entries being "
"concurrently written and collisions between a parallel-eligible entry and an "
"ineligible entry. The general idea for collision detection is quite "
"straightforward: for each parallel-eligible entry, the main process must "
"remove all files that prevent this entry from being written (before "
"enqueueing it). This includes any non-directory file in the leading path of "
"the entry. Later, when a worker gets assigned the entry, it looks again for "
"the non-directories files and for an already existing file at the entry's "
"path. If any of these checks finds something, the worker knows that there "
"was a path collision."
msgstr ""
"ワーカーは、同時に書き込まれるエントリ間の衝突と、並列適格エントリと不適格エ"
"ントリ間の衝突の両方を検出できます。衝突検出の一般的な考え方は非常に単純で"
"す。並列に適格なエントリごとに、メインプロセスは、このエントリの書き込みを妨"
"げるすべてのファイルを(キューに入れる前に)削除する必要があります。これには、"
"エントリの先頭のパスにあるディレクトリ以外のファイルが含まれます。 後で、ワー"
"カーにエントリが割り当てられると、非ディレクトリファイルと、エントリのパスに"
"ある既存のファイルが再度検索されます。 これらのチェックのいずれかで何かが見つ"
"かった場合、ワーカーはパスの衝突があったことを認識します。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:204
msgid ""
"Because parallel checkout can distinguish path collisions from the case "
"where the file was already present in the working tree before checkout, we "
"could alternatively choose to skip the checkout of colliding entries.  "
"However, each entry that doesn't get written would have NULL `lstat()` "
"fields on the index. This could cause performance penalties for subsequent "
"commands that need to refresh the index, as they would have to go to the "
"file system to see if the entry is dirty. Thus, if we have N entries in a "
"colliding group and we decide to write and `lstat()` only one of them, every "
"subsequent `git-status` will have to read, convert, and hash the written "
"file N - 1 times. By checking out all colliding entries (like the sequential "
"code does), we only pay the overhead once, during checkout."
msgstr ""
"並列チェックアウトでは、パスの衝突を、チェックアウト前にファイルが作業ツリー"
"にすでに存在していた場合と区別できるため、代わりに、衝突するエントリのチェッ"
"クアウトをスキップすることもできます。ただし、書き込まれない各エントリには、"
"インデックスにNULLの `lstat()` フィールドがあります。 これにより、エントリが"
"ダーティであるかどうかを確認するためにファイルシステムに移動する必要があるた"
"め、インデックスを更新する必要がある後続のコマンドのパフォーマンスが低下する"
"可能性があります。 したがって、衝突するグループにN個のエントリがあり、そのう"
"ちの1つだけを書き込み、 `lstat()` を実行することにした場合、後続のすべての "
"`git-status` は、書き込まれたファイルをN-1回読み取り、変換、およびハッシュす"
"る必要があります。衝突するすべてのエントリをチェックアウトすることにより"
"（シーケンシャルコードのように）、チェックアウト中にオーバーヘッドを1回だけ支"
"払います。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:206
#, no-wrap
msgid "Eligible Entries for Parallel Checkout"
msgstr "Eligible Entries for Parallel Checkout"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:211
msgid ""
"As previously mentioned, not all entries passed to `checkout_entry()` will "
"be considered eligible for parallel checkout. More specifically, we exclude:"
msgstr ""
"前述のように、 `checkout_entry()` に渡されたすべてのエントリが並列チェックア"
"ウトの対象と見なされるわけではありません。 具体的には、以下を除外します:"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:218
msgid ""
"Symbolic links; to avoid race conditions that, in combination with path "
"collisions, could cause workers to write files at the wrong place. For "
"example, if we were to concurrently check out a symlink 'a' -> 'b' and a "
"regular file 'A/f' in a case-insensitive file system, we could potentially "
"end up writing the file 'A/f' at 'a/f', due to a race condition."
msgstr ""
"シンボリックリンク。パスの衝突と組み合わせて、ワーカーが間違った場所にファイ"
"ルを書き込む可能性がある競合状態を回避するため。たとえば、大文字と小文字を区"
"別しないファイルシステムでシンボリックリンク 'a' -> 'b' と通常のファイル 'A/"
"f' を同時にチェックアウトすると、競合状態のため `a/f` でファイル 'A/f' を書き"
"込む可能性があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:223
msgid ""
"Regular files that require external filters (either \"one shot\" filters or "
"long-running process filters). These filters are black-boxes to Git and may "
"have their own internal locking or non-concurrent assumptions.  So it might "
"not be safe to run multiple instances in parallel."
msgstr ""
"外部フィルター（「ワンショット」フィルターまたは長時間実行プロセスフィル"
"ター）を必要とする通常のファイル。 これらのフィルターはGitのブラックボックス"
"であり、独自の内部ロックまたは非同時の仮定を持っている場合があります。 した"
"がって、複数のインスタンスを並行して実行することは安全ではない可能性がありま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:228
msgid ""
"Besides, long-running filters may use the delayed checkout feature to "
"postpone the return of some filtered blobs. The delayed checkout queue and "
"the parallel checkout queue are not compatible and should remain separate."
msgstr ""
"さらに、長時間実行されるフィルターは、遅延チェックアウト機能を使用して、フィ"
"ルター処理されたブロブの返送を延期する場合があります。 遅延チェックアウト"
"キューと並列チェックアウトキューは互換性がないため、分離したままにする必要が"
"あります。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:231
msgid ""
"Note: regular files that only require internal filters, like end-of-line "
"conversion and re-encoding, are eligible for parallel checkout."
msgstr ""
"注：行末変換や再エンコードなど、内部フィルターのみを必要とする通常のファイル"
"は、並列チェックアウトの対象となります。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:234
msgid ""
"Ineligible entries are checked out by the classic sequential codepath "
"*before* spawning workers."
msgstr ""
"不適格なエントリは、ワーカーを生成する「前に」従来のシーケンシャルコードパス"
"によってチェックアウトされます。"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:240
msgid ""
"Note: submodules's files are also eligible for parallel checkout (as long as "
"they don't fall into any of the excluding categories mentioned above). But "
"since each submodule is checked out in its own child process, we don't mix "
"the superproject's and the submodules' files in the same parallel checkout "
"process or queue."
msgstr ""
"注：サブモジュールのファイルは、並列チェックアウトの対象にもなります（上記の"
"除外カテゴリのいずれにも該当しない場合）。 ただし、各サブモジュールは独自の子"
"プロセスでチェックアウトされるため、スーパープロジェクトとサブモジュールの"
"ファイルを同じ並列チェックアウトプロセスまたはキューに混在させることはありま"
"せん。"

#. type: Title -
#: ../Documentation-sedout/technical/parallel-checkout.txt:242
#, no-wrap
msgid "The API"
msgstr "The API"

#. type: Plain text
#: ../Documentation-sedout/technical/parallel-checkout.txt:252
msgid ""
"The parallel checkout API was designed with the goal of minimizing changes "
"to the current users of the checkout machinery. This means that they don't "
"have to call a different function for sequential or parallel checkout. As "
"already mentioned, `checkout_entry()` will automatically insert the given "
"entry in the parallel checkout queue when this feature is enabled and the "
"entry is eligible; otherwise, it will just write the entry right away, using "
"the sequential code. In general, callers of the parallel checkout API should "
"look similar to this:"
msgstr ""
"並列チェックアウトAPIは、チェックアウト機構の現在のユーザーへの変更を最小限に"
"抑えることを目的として設計されました。 これは、シーケンシャルまたはパラレル"
"チェックアウトのために別の関数を呼び出す必要がないことを意味します。 すでに述"
"べたように、この機能が有効でエントリが適格である場合、 `checkout_entry()` は"
"指定されたエントリを並列チェックアウトキューに自動的に挿入します。 それ以外の"
"場合は、シーケンシャルコードを使用して、エントリをすぐに書き込みます。 一般"
"に、並列チェックアウトAPIの呼び出し元は以下のようになります:"

#. type: delimited block -
#: ../Documentation-sedout/technical/parallel-checkout.txt:256
#, no-wrap
msgid ""
"int pc_workers, pc_threshold, err = 0;\n"
"struct checkout state;\n"
msgstr ""
"int pc_workers, pc_threshold, err = 0;\n"
"struct checkout state;\n"

#. type: delimited block -
#: ../Documentation-sedout/technical/parallel-checkout.txt:258
#, no-wrap
msgid "get_parallel_checkout_configs(&pc_workers, &pc_threshold);\n"
msgstr "get_parallel_checkout_configs(&pc_workers, &pc_threshold);\n"

#. type: delimited block -
#: ../Documentation-sedout/technical/parallel-checkout.txt:265
#, no-wrap
msgid ""
"/*\n"
" * This check is not strictly required, but it\n"
" * should save some time in sequential mode.\n"
" */\n"
"if (pc_workers > 1)\n"
"\tinit_parallel_checkout();\n"
msgstr ""
"/*\n"
" * This check is not strictly required, but it\n"
" * should save some time in sequential mode.\n"
" */\n"
"if (pc_workers > 1)\n"
"\tinit_parallel_checkout();\n"

#. type: delimited block -
#: ../Documentation-sedout/technical/parallel-checkout.txt:268
#, no-wrap
msgid ""
"for (each cache_entry ce to-be-updated)\n"
"\terr |= checkout_entry(ce, &state, NULL, NULL);\n"
msgstr ""
"for (each cache_entry ce to-be-updated)\n"
"\terr |= checkout_entry(ce, &state, NULL, NULL);\n"

#. type: delimited block -
#: ../Documentation-sedout/technical/parallel-checkout.txt:270
#, no-wrap
msgid "err |= run_parallel_checkout(&state, pc_workers, pc_threshold, NULL, NULL);\n"
msgstr "err |= run_parallel_checkout(&state, pc_workers, pc_threshold, NULL, NULL);\n"
