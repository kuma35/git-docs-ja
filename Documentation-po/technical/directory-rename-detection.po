# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-02 01:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation/technical/directory-rename-detection.txt:2
#, no-wrap
msgid "Directory rename detection"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:8
msgid ""
"Rename detection logic in diffcore-rename that checks for renames of "
"individual files is also aggregated there and then analyzed in either "
"merge-ort or merge-recursive for cases where combinations of renames "
"indicate that a full directory has been renamed."
msgstr ""

#. type: Title -
#: ../Documentation/technical/directory-rename-detection.txt:10
#, no-wrap
msgid "Scope of abilities"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:13
msgid "It is perhaps easiest to start with an example:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:17
msgid ""
"When all of x/a, x/b and x/c have moved to z/a, z/b and z/c, it is likely "
"that x/d added in the meantime would also want to move to z/d by taking the "
"hint that the entire directory 'x' moved to 'z'."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:19
msgid "More interesting possibilities exist, though, such as:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:23
msgid ""
"one side of history renames x -> z, and the other renames some file to x/e, "
"causing the need for the merge to do a transitive rename so that the rename "
"ends up at z/e."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:26
msgid ""
"one side of history renames x -> z, but also renames all files within x.  "
"For example, x/a -> z/alpha, x/b -> z/bravo, etc."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:29
msgid ""
"both 'x' and 'y' being merged into a single directory 'z', with a directory "
"rename being detected for both x->z and y->z."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:33
msgid ""
"not all files in a directory being renamed to the same location; "
"i.e. perhaps most the files in 'x' are now found under 'z', but a few are "
"found under 'w'."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:38
msgid ""
"a directory being renamed, which also contained a subdirectory that was "
"renamed to some entirely different location.  (And perhaps the inner "
"directory itself contained inner directories that were renamed to yet other "
"locations)."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:41
msgid ""
"combinations of the above; see t/t6423-merge-rename-directories.sh for "
"various interesting cases."
msgstr ""

#. type: Title -
#: ../Documentation/technical/directory-rename-detection.txt:43
#, no-wrap
msgid "Limitations -- applicability of directory renames"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:49
msgid ""
"In order to prevent edge and corner cases resulting in either conflicts that "
"cannot be represented in the index or which might be too complex for users "
"to try to understand and resolve, a couple basic rules limit when directory "
"rename detection applies:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:52
msgid ""
"If a given directory still exists on both sides of a merge, we do not "
"consider it to have been renamed."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:57
msgid ""
"If a subset of to-be-renamed files have a file or directory in the way (or "
"would be in the way of each other), \"turn off\" the directory rename for "
"those specific sub-paths and report the conflict to the user."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:62
msgid ""
"If the other side of history did a directory rename to a path that your side "
"of history renamed away, then ignore that particular rename from the other "
"side of history for any implicit directory renames (but warn the user)."
msgstr ""

#. type: Title -
#: ../Documentation/technical/directory-rename-detection.txt:64
#, no-wrap
msgid "Limitations -- detailed rules and testcases"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:69
msgid ""
"t/t6423-merge-rename-directories.sh contains extensive tests and commentary "
"which generate and explore the rules listed above.  It also lists a few "
"additional rules:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:72
msgid ""
"If renames split a directory into two or more others, the directory with the "
"most renames, \"wins\"."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:75
msgid ""
"Only apply implicit directory renames to directories if the other side of "
"history is the one doing the renaming."
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:78
msgid ""
"Do not perform directory rename detection for directories which had no new "
"paths added to them."
msgstr ""

#. type: Title -
#: ../Documentation/technical/directory-rename-detection.txt:80
#, no-wrap
msgid "Limitations -- support in different commands"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:85
msgid ""
"Directory rename detection is supported by 'merge' and 'cherry-pick'.  Other "
"git commands which users might be surprised to see limited or no directory "
"rename detection support in:"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:87
msgid "diff"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:96
#, no-wrap
msgid ""
"Folks have requested in the past that `git diff` detect directory\n"
"renames and somehow simplify its output.  It is not clear whether this\n"
"would be desirable or how the output should be simplified, so this was\n"
"simply not implemented.  Also, while diffcore-rename has most of the\n"
"logic for detecting directory renames, some of the logic is still found\n"
"within merge-ort and merge-recursive.  Fully supporting directory\n"
"rename detection in diffs would require copying or moving the remaining\n"
"bits of logic to the diff machinery.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:98
msgid "am"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:108
#, no-wrap
msgid ""
"git-am tries to avoid a full three way merge, instead calling\n"
"git-apply.  That prevents us from detecting renames at all, which may\n"
"defeat the directory rename detection.  There is a fallback, though; if\n"
"the initial git-apply fails and the user has specified the -3 option,\n"
"git-am will fall back to a three way merge.  However, git-am lacks the\n"
"necessary information to do a \"real\" three way merge.  Instead, it has\n"
"to use build_fake_ancestor() to get a merge base that is missing files\n"
"whose rename may have been important to detect for directory rename\n"
"detection to function.\n"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:110
msgid "rebase"
msgstr ""

#. type: Plain text
#: ../Documentation/technical/directory-rename-detection.txt:118
#, no-wrap
msgid ""
"Since am-based rebases work by first generating a bunch of patches\n"
"(which no longer record what the original commits were and thus don't\n"
"have the necessary info from which we can find a real merge-base), and\n"
"then calling git-am, this implies that am-based rebases will not always\n"
"successfully detect directory renames either (see the 'am' section\n"
"above).  merged-based rebases (rebase -m) and cherry-pick-based rebases\n"
"(rebase -i) are not affected by this shortcoming, and fully support\n"
"directory rename detection.\n"
msgstr ""
