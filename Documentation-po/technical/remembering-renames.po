# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 2.0\n"
"POT-Creation-Date: 2023-07-18 11:06+0900\n"
"PO-Revision-Date: 2023-10-15 10:58+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/technical/remembering-renames.txt:1
#, no-wrap
msgid "remembering-renames.txt"
msgstr "Remembering renames"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:6
#, no-wrap
msgid "Introduction"
msgstr "はじめに"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:17
msgid ""
"Rebases and cherry-picks involve a sequence of merges whose results are "
"recorded as new single-parent commits.  The first parent side of those "
"merges represent the \"upstream\" side, and often include a far larger set "
"of changes than the second parent side.  Traditionally, the renames on the "
"first-parent side of that sequence of merges were repeatedly re-detected for "
"every merge.  This file explains why it is safe and effective during rebases "
"and cherry-picks to remember renames on the upstream side of history as an "
"optimization, assuming all merges are automatic and clean (i.e. no conflicts "
"and not interrupted for user input or editing)."
msgstr ""
"リベースとチェリーピックには一連のマージが含まれ、その結果は新しいひとり親コ"
"ミット(single-parent commits)として記録されます。 これらのマージの1番目の親の"
"側は「上流」(upstream)側を表し、多くの場合、2 番目の親の側よりもはるかに大き"
"な変更セットが含まれます。 従来、一連のマージの最初の親側の名前変更は、マージ"
"ごとに繰り返し再検出されていました。 このファイルは、すべてのマージが自動でク"
"リーン(つまり、競合がなく、ユーザー入力または編集のために中断(interrupt)され"
"ない)であると仮定して、最適化として、履歴の上流側で名前変更を記憶することが、"
"リベースおよびチェリーピック中に安全かつ効果的である理由を説明します。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:18
#, no-wrap
msgid "0. Assumptions"
msgstr "0. 仮定"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:21
msgid "There are two assumptions that will hold throughout this document:"
msgstr "1つ目と2つ目の仮定はこのドキュメント全体に渡る仮定です:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:24
msgid ""
"The upstream side where commits are transplanted to is treated as the first "
"parent side when rebase/cherry-pick call the merge machinery"
msgstr ""
"リベース/チェリーピック がマージ機構を呼び出すと、コミット達が移植される上流"
"側が1番目の親の側として扱われます"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:26
msgid "All merges are fully automatic"
msgstr "すべてのマージは完全に自動化されています"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:29
msgid ""
"and a third that will hold in sections 2-5 for simplicity, that I'll later "
"address in section 8:"
msgstr ""
"3つ目の仮定は、セクション 2 〜 5 が対象で、議論をシンプルにするための仮定で"
"す。これについては セクション 8 で説明します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:31
msgid "No directory renames occur"
msgstr "ディレクトリの名前変更は発生しません"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:34
msgid "Let me explain more about each assumption and why I include it:"
msgstr "それぞれの仮定とそれを含める理由について、詳しく説明します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:49
msgid ""
"The first assumption is merely for the purposes of making this document "
"clearer; the optimization implementation does not actually depend upon it.  "
"However, the assumption does hold in all cases because it reflects the way "
"that both rebase and cherry-pick were implemented; and the implementation of "
"cherry-pick and rebase are not readily changeable for backwards "
"compatibility reasons (see for example the discussion of the --ours and --"
"theirs flag in the documentation of `git checkout`, particularly the "
"comments about how they behave with rebase).  The optimization avoids "
"checking first-parent-ness, though.  It checks the conditions that make the "
"optimization valid instead, so it would still continue working if someone "
"changed the parent ordering that cherry-pick and rebase use.  But making "
"this assumption does make this document much clearer and prevents me from "
"having to repeat every example twice."
msgstr ""
"最初の仮定は、この文書の目的をより明確にするためのものです。 最適化の実装は実"
"際、これには依存しません。 ただし、rebase と cherry-pick の両方が実装された方"
"法を反映しているため、この仮定はすべての場合に当てはまります。 そしてまた、 "
"cherry-pick と rebase の実装は、下位互換性の理由により簡単には変更できません"
"(たとえば、 `git checkout` のドキュメントの `--ours` フラグと `--theirs` フラ"
"グに関する議論、特に rebase での動作に関するコメントを参照してください)。 た"
"だし、最適化により、1番目の親のチェック(checking first-parent-ness)が回避され"
"ます。 最適化を有効にする代わりの条件をチェックするため、 cherry-pick と "
"rebase が使用する親の順序が変更された場合でも引き続き機能します。 しかし、こ"
"の仮定を行うことで、このドキュメントがより明確になり、すべての例を 2 回繰り返"
"す必要がなくなります。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:59
msgid ""
"If the second assumption is violated, then the optimization simply is turned "
"off and thus isn't relevant to consider.  The second assumption can also be "
"stated as \"there is no interruption for a user to resolve conflicts or to "
"just further edit or tweak files\".  While real rebases and cherry-picks are "
"often interrupted (either because it's an interactive rebase where the user "
"requested to stop and edit, or because there were conflicts that the user "
"needs to resolve), the cache of renames is not stored on disk, and thus is "
"thrown away as soon as the rebase or cherry pick stops for the user to "
"resolve the operation."
msgstr ""
"2番目の仮定に違反した場合、最適化は単純にオフになるため、その後を考慮する必要"
"はありません。 2番目の仮定は、「ユーザーが競合を解決したり、ファイルをさらに"
"編集または微調整したりするために中断(interrupt)されることはない」とも言えま"
"す。 実際のリベースとチェリーピックはしばしば中断(interrupt)されますが(ユー"
"ザーが停止と編集を要求した対話的なリベースであるか、ユーザーが解決する必要が"
"ある競合があったため)、名前変更のキャッシュはディスクに保存されないので、ユー"
"ザーが操作を解決するためにリベースまたはチェリーピックが停止(stop)すると直ち"
"に破棄されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:72
msgid ""
"The third assumption makes sections 2-5 simpler, and allows people to "
"understand the basics of why this optimization is safe and effective, and "
"then I can go back and address the specifics in section 8.  It is probably "
"also worth noting that if directory renames do occur, then the default of "
"merge.directoryRenames being set to \"conflict\" means that the operation "
"will stop for users to resolve the conflicts and the cache will be thrown "
"away, and thus that there won't be an optimization to apply.  So, the only "
"reason we need to address directory renames specifically, is that some users "
"will have set merge.directoryRenames to \"true\" to allow the merges to "
"continue to proceed automatically.  The optimization is still safe with this "
"config setting, but we have to discuss a few more cases to show why; this "
"discussion is deferred until section 8."
msgstr ""
"3番目の仮定により、セクション 2〜5 がより単純になり、この最適化が安全で効果的"
"である理由の基礎を人々が理解できるようになります。その後、セクション 8 で詳細"
"に取り組むことができます。 ディレクトリの名前変更が発生したときに、merge."
"directoryRenames のデフォルトが `conflict` に設定されていることは、ユーザーが"
"競合を解決するために操作が停止(stop)し、キャッシュが破棄されることを意味する"
"ことにも注意してください。つまり、最適化は適用されません。 したがって、ディレ"
"クトリの名前変更に具体的に対処する必要がある唯一の理由は、一部のユーザーが "
"merge.directoryRenames を `true` に設定して、マージが自動的に続行できるように"
"するためです。 この構成設定でも最適化は安全ですが、その理由を示すためにさらに"
"いくつかのケースについて説明する必要があります。 この議論についてはセクショ"
"ン 8 にて行います。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:74
#, no-wrap
msgid "1. How rebasing and cherry-picking work"
msgstr "1. リベースとチェリーピッキングの仕組み"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:77
msgid "Consider the following setup (from the git-rebase manpage):"
msgstr "以下の図について考えてみましょう(git-rebase マニュアルページより):"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:81
#, no-wrap
msgid ""
"\t\t     A---B---C topic\n"
"\t\t    /\n"
"\t       D---E---F---G main\n"
msgstr ""
"\t\t     A---B---C topic\n"
"\t\t    /\n"
"\t       D---E---F---G main\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:83
msgid "After rebasing or cherry-picking topic onto main, this will appear as:"
msgstr ""
"topic を main にリベースまたはチェリーピッキングした後、以下のようになります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:87
#, no-wrap
msgid ""
"\t\t\t     A'--B'--C' topic\n"
"\t\t\t    /\n"
"\t       D---E---F---G main\n"
msgstr ""
"\t\t\t     A'--B'--C' topic\n"
"\t\t\t    /\n"
"\t       D---E---F---G main\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:93
msgid ""
"The way the commits A', B', and C' are created is through a series of "
"merges, where rebase or cherry-pick sequentially uses each of the three A-B-"
"C commits in a special merge operation.  Let's label the three commits in "
"the merge operation as MERGE_BASE, MERGE_SIDE1, and MERGE_SIDE2.  For this "
"picture, the three commits for each of the three merges would be:"
msgstr ""
"コミット A' と B' と C' がどのように作成されるかというと、一連のマージによっ"
"て行われます。この場合、リベースまたはチェリーピックは、特殊なマージ操作にて "
"3 つの A-B-C コミットのそれぞれを順番に使用します。 ここで、マージ操作の 3 つ"
"のコミットに、 MERGE_BASE と、MERGE_SIDE1 と MERGE_SIDE2 というラベルを付ける"
"ことにしましょう。 この図では、その 3 つのマージのそれぞれに対する 3 つのコ"
"ミットは以下のようになります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:95
#: ../Documentation-sedout/technical/remembering-renames.txt:142
#: ../Documentation-sedout/technical/remembering-renames.txt:173
msgid "To create A':"
msgstr "To create A':"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:99
#: ../Documentation-sedout/technical/remembering-renames.txt:146
#: ../Documentation-sedout/technical/remembering-renames.txt:177
#, no-wrap
msgid ""
"   MERGE_BASE:   E\n"
"   MERGE_SIDE1:  G\n"
"   MERGE_SIDE2:  A\n"
msgstr ""
"   MERGE_BASE:   E\n"
"   MERGE_SIDE1:  G\n"
"   MERGE_SIDE2:  A\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:101
#: ../Documentation-sedout/technical/remembering-renames.txt:148
#: ../Documentation-sedout/technical/remembering-renames.txt:179
msgid "To create B':"
msgstr "To create B':"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:105
#: ../Documentation-sedout/technical/remembering-renames.txt:152
#: ../Documentation-sedout/technical/remembering-renames.txt:183
#, no-wrap
msgid ""
"   MERGE_BASE:   A\n"
"   MERGE_SIDE1:  A'\n"
"   MERGE_SIDE2:  B\n"
msgstr ""
"   MERGE_BASE:   A\n"
"   MERGE_SIDE1:  A'\n"
"   MERGE_SIDE2:  B\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:107
msgid "To create C':"
msgstr "To create C':"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:111
#, no-wrap
msgid ""
"   MERGE_BASE:   B\n"
"   MERGE_SIDE1:  B'\n"
"   MERGE_SIDE2:  C\n"
msgstr ""
"   MERGE_BASE:   B\n"
"   MERGE_SIDE1:  B'\n"
"   MERGE_SIDE2:  C\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:116
msgid ""
"Sometimes, folks are surprised that these three-way merges are done.  It can "
"be useful in understanding these three-way merges to view them in a slightly "
"different light.  For example, in creating C', you can view it as either:"
msgstr ""
"ときどき、これらの 3 方向のマージが行われることに驚かれることがあります。 こ"
"れらの 3 方向のマージを理解するには、これらを少し異なる観点から見ることが役に"
"立ちます。 たとえば、 C' の作成は、以下のいずれかとして観る事ができます:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:118
msgid "Apply the changes between B & C to B'"
msgstr "BとCの間の変更をB'に適用(apply)します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:119
msgid "Apply the changes between B & B' to C"
msgstr "BとB'の間の変更をCに適用(apply)します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:122
msgid ""
"Conceptually the two statements above are the same as a three-way merge of "
"B, B', and C, at least the parts before you decide to record a commit."
msgstr ""
"概念的には、上記の 2 つの文は、少なくともあなたがコミットの記録を決定する前の"
"時点では、B と B' と C の 3 方向マージと同一です。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:124
#, no-wrap
msgid "2. Why the renames on MERGE_SIDE1 in any given pick are *always* a superset of the renames on MERGE_SIDE1 for the next pick."
msgstr "2. 与えられたピックでの MERGE_SIDE1 の名前変更が、「常に」次のピックの MERGE_SIDE1 での名前変更のスーパーセットである理由。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:129
msgid ""
"The merge machinery uses the filenames it is fed from MERGE_BASE, "
"MERGE_SIDE1, and MERGE_SIDE2.  It will only move content to a different "
"filename under one of three conditions:"
msgstr ""
"マージ機構は、MERGE_BASE と MERGE_SIDE1 と MERGE_SIDE2 から供給されるファイル"
"名を使用します。 以下の 3 つの条件のいずれかでのみ、コンテンツを別のファイル"
"名に移動(move)します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:133
msgid ""
"To make both pieces of a conflict available to a user during conflict "
"resolution (examples: directory/file conflict, add/add type conflict such as "
"symlink vs. regular file)"
msgstr ""
"競合の解決中にユーザーが両方の競合の断片を利用できるようにするため (例: ディ"
"レクトリ/ファイルの競合、シンボリックリンク対通常ファイル等のような 追加/追加"
"タイプ の競合)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:135
msgid "When MERGE_SIDE1 renames the file."
msgstr "MERGE_SIDE1 がファイルの名前変更したとき。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:137
msgid "When MERGE_SIDE2 renames the file."
msgstr "MERGE_SIDE2 がファイルの名前変更したとき。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:140
msgid ""
"First, let's remember what commits are involved in the first and second "
"picks of the cherry-pick or rebase sequence:"
msgstr ""
"まず、cherry-pick または rebase シーケンスの 1 番目と 2 番目のピックに含まれ"
"るコミットを思い出してください:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:155
msgid ""
"So, in particular, we need to show that the renames between E and G are a "
"superset of those between A and A'."
msgstr ""
"そして、特に、 E と G の間の名前変更は、 A と A' の間の名前変更のスーパーセッ"
"トであることを示す必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:166
msgid ""
"A' is created by the first merge.  A' will only have renames for one of the "
"three reasons listed above.  The first case, a conflict, results in a "
"situation where the cache is dropped and thus this optimization doesn't take "
"effect, so we need not consider that case.  The third case, a rename on "
"MERGE_SIDE2 (i.e. from G to A), will show up in A' but it also shows up in A "
"-- therefore when diffing A and A' that path does not show up as a rename.  "
"The only remaining way for renames to show up in A' is for the rename to "
"come from MERGE_SIDE1.  Therefore, all renames between A and A' are a subset "
"of those between E and G.  Equivalently, all renames between E and G are a "
"superset of those between A and A'."
msgstr ""
"A' は最初のマージで作成されます。 A' は、上記 3 つの理由のいずれかのみで名前"
"変更されます。 最初のケースである競合では、キャッシュが削除され、この最適化が"
"有効にならない状況が発生するため、このケースを考慮する必要はありません。 3 番"
"目のケースである MERGE_SIDE2 の名前変更 (つまり、G から A へ) は、A' に表れま"
"すが、A にも表れます -- したがって、 A と A' を比較すると、そのパスは名前変更"
"として表示されません。 名前の変更が A' に表れる唯一の方法は、MERGE_SIDE1 によ"
"る名前変更です。 それゆえ、A と A' の間のすべての名前変更は、E と G の間の名"
"前変更のサブセットです。 同様に、E と G の間のすべての名前変更は、A と A' の"
"間の名前変更のスーパーセットです。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:168
#, no-wrap
msgid "3. Why any rename on MERGE_SIDE1 in any given pick is _almost_  always also a rename on MERGE_SIDE1 for the next pick."
msgstr "3. 与えられたピックで MERGE_SIDE1 の名前を変更すると、次のピックでも常に MERGE_SIDE1 の名前が変更される理由。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:171
msgid "Let's again look at the first two picks:"
msgstr "最初の 2 つのピックをもう一度見てみましょう:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:189
msgid ""
"Now let's look at any given rename from MERGE_SIDE1 of the first pick, i.e.  "
"any given rename from E to G.  Let's use the filenames 'oldfile' and "
"'newfile' for demonstration purposes.  That first pick will function as "
"follows; when the rename is detected, the merge machinery will do a three-"
"way content merge of the following:"
msgstr ""
"次に、最初のピックでの MERGE_SIDE1 からの任意の名前変更、つまり E から G への"
"任意の名前変更を見てみましょう。デモンストレーションのために、ファイル名"
"「oldfile」と「newfile」を使用してみることにします。 その最初のピックは次のよ"
"うに機能します。 つまり、名前の変更が検出されると、マージ機構は以下の 3 方向"
"のコンテンツ マージを実行します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:193
#, no-wrap
msgid ""
"    E:oldfile\n"
"    G:newfile\n"
"    A:oldfile\n"
msgstr ""
"    E:oldfile\n"
"    G:newfile\n"
"    A:oldfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:195
msgid "and produce a new result:"
msgstr "そして新しい結果を生成します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:197
#, no-wrap
msgid "    A':newfile\n"
msgstr "    A':newfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:213
msgid ""
"Note above that I've assumed that E->A did not rename oldfile.  If that side "
"did rename, then we most likely have a rename/rename(1to2) conflict that "
"will cause the rebase or cherry-pick operation to halt and drop the in-"
"memory cache of renames and thus doesn't need to be considered further.  In "
"the special case that E->A does rename the file but also renames it to "
"newfile, then there is no conflict from the renaming and the merge can "
"succeed.  In this special case, the rename is not valid to cache because the "
"second merge will find A:newfile in the MERGE_BASE (see also the new "
"testcases in t6429 with \"rename same file identically\" in their "
"description).  So a rename/rename(1to1) needs to be specially handled by "
"pruning renames from the cache and decrementing the dir_rename_counts in the "
"current and leading directories associated with those renames.  Or, since "
"these are really rare, one could just take the easy way out and disable the "
"remembering renames optimization when a rename/rename(1to1)  happens."
msgstr ""
"上記で、E→A が oldfile の名前変更しなかったと仮定したことに注意してくださ"
"い。 そのMERGE_SIDEが名前を変更した場合は、名前変更/名前変更(1to2) の競合が発"
"生している可能性が高く、リベースまたはチェリーピック操作が停止(halt)し、名前"
"変更のメモリ内キャッシュが削除(drop)されるため、これ以降を考慮する必要はあり"
"ません。 E→A がファイルの名前を変更するだけでなく、 newfile に名前を変更する"
"という特別なケースでは、名前変更による競合はなく、マージは成功します。 この特"
"殊なケースでは、2 回目のマージで MERGE_BASE 内の A:newfile が検出されるため、"
"名前変更はキャッシュに有効ではありません (t6429 の新しいテストケースの"
"「rename same file identically」(同一ファイルを全く同じに名前変更する)という"
"説明も参照してください)。 したがって、 rename/rename(1to1) は、キャッシュから"
"名前変更を刈り込み、それらの名前変更に関連付けられた現在および主要なディレク"
"トリの dir_rename_counts を減らすことによって、特別に処理する必要がありま"
"す。 または、これらは非常にまれであるため、名前の変更/名前の変更(1to1)が発生"
"したときに名前の記憶の最適化を無効にして、簡単な方法を取ることができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:216
msgid ""
"The previous paragraph handled the cases for E->A renaming oldfile, let's "
"continue assuming that oldfile is not renamed in A."
msgstr ""
"さて、前の段落では、 E→A で oldfile の名前を変更する特殊なケースについて説明"
"しましたけれども、引き続き A で oldfile の名前が変更されていないと仮定して議"
"論を続行すします。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:220
msgid ""
"As per the diagram for creating B', MERGE_SIDE1 involves the changes from A "
"to A'.  So, we are curious whether A:oldfile and A':newfile will be viewed "
"as renames.  Note that:"
msgstr ""
"B' を作成するための図によると、 MERGE_SIDE1 には A から A' への変更が含まれま"
"す。 そのため私達は A:oldfile と A':newfile が名前変更として表れるかどうかに"
"興味があるのです。 以下ご留意下さい:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:226
msgid ""
"There will be no A':oldfile (because there could not have been a G:oldfile "
"as we do not do break detection in the merge machinery and G:newfile was "
"detected as a rename, and by the construction of the rename above that "
"merged cleanly, the merge machinery will ensure there is no 'oldfile' in the "
"result)."
msgstr ""
"A':oldfile はなくなります(なぜなら、マージ機構で破棄検出(break detection)を行"
"わず、 G:newfile が名前変更として検出されたため、G:oldfile が存在する可能性は"
"ありませんでした。 よって結果に「oldfile」はありません)。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:229
msgid ""
"There will be no A:newfile (if there had been, we would have had a rename/"
"add conflict)."
msgstr ""
"A:newfile はなくります (もしあった場合、名前変更/追加 の競合が発生していたは"
"ずです)。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:232
msgid ""
"Clearly A:oldfile and A':newfile are \"related\" (A':newfile came from a "
"clean three-way content merge involving A:oldfile)."
msgstr ""
"明らかに、 A:oldfile と A':newfile は「関連」(related)があります(A':newfile "
"は、 A:oldfile を含むクリーンな 3 方向のコンテンツ マージから派生したもので"
"す)。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:238
msgid ""
"We can also expound on the third point above, by noting that three-way "
"content merges can also be viewed as applying the differences between the "
"base and one side to the other side.  Thus we can view A':newfile as having "
"been created by taking the changes between E:oldfile and G:newfile (which "
"were detected as being related, i.e. <50% changed) to A:oldfile."
msgstr ""
"上記の 3 番目のポイントについても説明できます。3 方向のコンテンツのマージは、"
"ベースと一方の側の違いを他方の側に適用することと見なすこともできます。 した"
"がって、 E:oldfile と G:newfile の間の変更(関連していると検出されたもの、つま"
"り 50% 未満の変更)を A:oldfile に適用することによって、 A':newfile が作成され"
"たと見なすことができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:243
msgid ""
"Thus A:oldfile and A':newfile are just as related as E:oldfile and G:newfile "
"are -- they have exactly identical differences.  Since the latter were "
"detected as renames, A:oldfile and A':newfile should also be detectable as "
"renames almost always."
msgstr ""
"したがって、 A:oldfile と A':newfile は、 E:oldfile と G:newfile が関連してい"
"るのと同じように関連しています -- これらはまったく同一の違いがあります。 後者"
"は名前変更として検出されたので、 A:oldfile と A':newfile もほとんど常に名前変"
"更として検出できるはずです。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:245
#, no-wrap
msgid "4. A detailed description of the counter-examples to #3."
msgstr "4. #3 に対する反例の詳細な説明。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:252
msgid ""
"We already noted in section 3 that rename/rename(1to1) (i.e. both sides "
"renaming a file the same way) was one counter-example.  The more interesting "
"bit, though, is why did we need to use the \"almost\" qualifier when stating "
"that A:oldfile and A':newfile are \"almost\" always detectable as renames?"
msgstr ""
"セクション 3 で、rename/rename(1to1) (つまり、両サイドが同一の方法でファイル"
"の名前を変更すること) が 1 つの反例であることを既に述べました。 しかし、もっ"
"と興味深いのは、なぜ A:oldfile と A':newfile が名前変更として「ほぼ」常に検出"
"可能であると述べたときに、「ほぼ」という言葉を使用する必要があったのかという"
"ことです。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:254
msgid "Let's repeat an earlier point that section 3 made:"
msgstr "セクション 3 で述べた以前のポイントを繰り返しましょう:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:258
#, no-wrap
msgid ""
"  A':newfile was created by applying the changes between E:oldfile and\n"
"  G:newfile to A:oldfile.  The changes between E:oldfile and G:newfile were\n"
"  <50% of the size of E:oldfile.\n"
msgstr ""
"  A':newfile は、E:oldfile と G:newfile の間の変更を\n"
"  A:oldfile に適用することによって作成されました。\n"
"  E:oldfile と G:newfile の間の変更は、 E:oldfile のサイズの 50% 未満でした。\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:265
msgid ""
"If those changes that were <50% of the size of E:oldfile are also <50% of "
"the size of A:oldfile, then A:oldfile and A':newfile will be detectable as "
"renames.  However, if there is a dramatic size reduction between E:oldfile "
"and A:oldfile (but the changes between E:oldfile, G:newfile, and A:oldfile "
"still somehow merge cleanly), then traditional rename detection would not "
"detect A:oldfile and A':newfile as renames."
msgstr ""
"E:oldfile のサイズの 50% 未満であった変更が、 A:oldfile のサイズの 50% 未満で"
"あるならば、 A:oldfile と A':newfile では名前変更として検出されます。 ただ"
"し、 E:oldfile と A:oldfile の間で劇的なサイズの縮小がある場合 (ただし、E:"
"oldfile、G:newfile、および A:oldfile の間の変更は依然として何らかの形できれい"
"にマージされるとして)、従来の名前変更検出では A:oldfile と A':newfile の間の"
"名前変更が検出されません。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:267
msgid "Here's an example where that can happen:"
msgstr "これが発生する可能性のある例を以下に示します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:269
msgid "E:oldfile had 20 lines"
msgstr "E:oldfileには20行あります"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:270
msgid "G:newfile added 10 new lines at the beginning of the file"
msgstr "G:newfileは、ファイルの先頭に10行の新しい行を追加しました"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:271
msgid "A:oldfile kept the first 3 lines of the file, and deleted all the rest"
msgstr "A:oldfileは、ファイルの最初の3行を保持し、残りをすべて削除しました。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:273
msgid "then:"
msgstr "そうすると:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:275
msgid ""
"=> A':newfile would have 13 lines, 3 of which matches those in A:oldfile."
msgstr ""
"=> A':newfileには13行あり、そのうちの3行は A:oldfile の行と一致します。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:278
msgid ""
"E:oldfile -> G:newfile would be detected as a rename, but A:oldfile and A':"
"newfile would not be."
msgstr ""
"E:oldfile → G:newfile は名前変更として検出されますが、 A:oldfile と A':"
"newfile は検出されません。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:280
#, no-wrap
msgid "5. Why the special cases in #4 are still fully reasonable to use to pair up files for three-way content merging in the merge machinery, and why they do not affect the correctness of the merge."
msgstr "5. #4 の特殊なケースが、マージ機構での3方向コンテンツマージのためにファイルをペアリングするために使用するのに依然として完全に合理的である理由と、それらがマージの正確さに影響を与えない理由。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:290
msgid ""
"In the rename/rename(1to1) case, A:newfile and A':newfile are not renames "
"since they use the *same* filename.  However, files with the same filename "
"are obviously fine to pair up for three-way content merging (the merge "
"machinery has never employed break detection).  The interesting counter-"
"example case is thus not the rename/rename(1to1) case, but the case where A "
"did not rename oldfile.  That was the case that we spent most of the time "
"discussing in sections 3 and 4.  The remainder of this section will be "
"devoted to that case as well."
msgstr ""
"rename/rename(1to1) の場合、 A:newfile と A':newfile は 「同一」ファイル名を"
"使用するため、名前変更しません。 ただし、同一ファイル名のファイルは、3方向コ"
"ンテンツマージ用の組にする(pair up)のに明らかに問題ありません(マージ機構は破"
"壊検出(break detection)を採用していないため)。 したがって、この興味深い反例の"
"ケースは、rename/rename(1to1) ケースではなく、A が oldfile の名前変更しなかっ"
"たケースです。 これは、セクション 3 と 4 でほとんどの時間を議論に費やしたケー"
"スです。 このセクションの残りの部分では、そのケースについても説明します。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:294
msgid ""
"So, even if A:oldfile and A':newfile aren't detectable as renames, why is it "
"still reasonable to pair them up for three-way content merging in the merge "
"machinery? There are multiple reasons:"
msgstr ""
"では、 A:oldfile と A':newfile が名前変更として検出されない場合でも、マージ機"
"構で3方向のコンテンツをマージするためにそれらを組(pair)にすることが合理的なの"
"はなぜでしょうか? これには複数の理由があります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:299
msgid ""
"As noted in sections 3 and 4, the diff between A:oldfile and A':newfile is "
"*exactly* the same as the diff between E:oldfile and G:newfile.  The latter "
"pair were detected as renames, so it seems unlikely to surprise users for us "
"to treat A:oldfile and A':newfile as renames."
msgstr ""
"セクション 3 と 4 で述べたように、 A:oldfile と A':newfile の差分は、E:"
"oldfile と G:newfile の差分と「正確に」同じです。 後者のペアは名前変更として"
"検出されたため、A:oldfile と A':newfile を名前変更として扱うことにユーザーが"
"驚くことはないようです。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:305
msgid ""
"In fact, \"oldfile\" and \"newfile\" were at one point detected as renames "
"due to how they were constructed in the E..G chain.  And we used that "
"information once already in this rebase/cherry-pick.  I think users would be "
"unlikely to be surprised at us continuing to treat the files as renames and "
"would quickly understand why we had done so."
msgstr ""
"実際、 `oldfile` と `newfile` は、E..G チェーンでの構成方法が原因で、ある時点"
"で名前変更として検出されました。 そして、私達はこの リベース/チェリーピック "
"ですでにその情報を使用しました。 ユーザーは、私たちがファイルを名前変更として"
"扱い続けていることに驚くことはまずなく、その理由をすぐに理解できると思いま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:309
msgid ""
"Marking or declaring files as renames is *not* the end goal for merges.  "
"Merges use renames to determine which files make sense to be paired up for "
"three-way content merges."
msgstr ""
"ファイルを名前変更としてマークまたは宣言することは、マージの最終目標ではあり"
"ません。 マージでは、名前変更を使用して、3方向のコンテンツマージでペアにする"
"のが適切なファイルを決定します。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:314
msgid ""
"A:oldfile and A':newfile were _already_ paired up in a three-way content "
"merge; that is how A':newfile was created.  In fact, that three-way content "
"merge was clean.  So using them again in a later three-way content merge "
"seems very reasonable."
msgstr ""
"A:oldfile と A':newfile は、「既に」 3方向のコンテンツマージでペアになってい"
"ます。つまりそれは A':newfile がどのように作成されたかという事です。 実際、そ"
"の3方向のコンテンツマージはクリーンでした。 したがって、後の3方向のコンテンツ"
"マージでそれらを再度使用することは非常に合理的です。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:320
msgid ""
"However, the above is focusing on the common scenarios.  Let's try to look "
"at all possible unusual scenarios and compare without the optimization to "
"with the optimization.  Consider the following theoretical cases; we will "
"then dive into each to determine which of them are possible, and if so, what "
"they mean:"
msgstr ""
"ただし、上記では一般的なシナリオに焦点を当てています。 考えうる異常なシナリオ"
"をすべて見て、最適化なしと最適化ありを比較してみましょう。 以下の理論的なケー"
"スを検討してみてください。 そして、私達は以下のそれぞれについて掘り下げて、可"
"能なものと、可能な場合の意味を判断します:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:324
msgid ""
"Without the optimization, the second merge results in a conflict.  With the "
"optimization, the second merge also results in a conflict.  Questions: Are "
"the conflicts confusingly different? Better in one case?"
msgstr ""
"最適化を行わないと、2回目のマージで競合が発生します。 最適化を行っても、2回目"
"のマージで競合が発生します。 質問: これらの競合は紛らわしいほどの差異でしょう"
"か？ ある場合においてはより良いでしょうか？"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:328
msgid ""
"Without the optimization, the second merge results in NO conflict.  With the "
"optimization, the second merge also results in NO conflict.  Questions: Are "
"the merges the same?"
msgstr ""
"最適化を行わないと、2回目のマージで競合は発生しません。 最適化を行っても、2回"
"目のマージで競合は発生しません。 質問:これらのマージは同一ですか？"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:332
msgid ""
"Without the optimization, the second merge results in a conflict.  With the "
"optimization, the second merge results in NO conflict.  Questions: Possible? "
"Bug, bugfix, or something else?"
msgstr ""
"最適化を行わないと、2回目のマージで競合が発生します。 最適化を行うと、2回目の"
"マージで競合は発生しません。 質問: こあれはありえますか？ バグまたは、バグ"
"フィックスまた、それ以外の何かか？"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:336
msgid ""
"Without the optimization, the second merge results in NO conflict.  With the "
"optimization, the second merge results in a conflict.  Questions: Possible? "
"Bug, bugfix, or something else?"
msgstr ""
"最適化を行わないと、2回目のマージで競合は発生しません。 最適化を行うと、2回目"
"のマージで競合が発生します。 質問: こあれはありえますか？ バグまたは、バグ"
"フィックスまた、それ以外の何かか？"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:338
msgid "I'll consider all four cases, but out of order."
msgstr "私は 4 つのケースすべてを検討しますが、順不同です。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:345
msgid ""
"The fourth case is impossible.  For the code without the remembering renames "
"optimization to not get a conflict, B:oldfile would need to exactly match A:"
"oldfile -- if it doesn't, there would be a modify/delete conflict.  If A:"
"oldfile matches B:oldfile exactly, then a three-way content merge between A:"
"oldfile, A':newfile, and B:oldfile would have no conflict and just give us "
"the version of newfile from A' as the result."
msgstr ""
"4番目のケースは不可能です。 名前変更の記憶の最適化を行わないコードで競合が発"
"生しないようにするには、 B:oldfile が A:oldfile と正確に一致する必要がありま"
"す -- 一致しない場合は、変更/削除 の競合が発生します。 A:oldfile が B:"
"oldfile と正確に一致する場合、A:oldfile と、A':newfile と B:oldfile の間の3方"
"向のコンテンツマージは競合せず、結果として A' からの newfile のバージョンを提"
"供します。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:354
msgid ""
"From the same logic as the above paragraph, the second case would indeed "
"result in identical merges.  When A:oldfile exactly matches B:oldfile, an "
"undetected rename would say, \"Oh, I see one side didn't modify 'oldfile' "
"and the other side deleted it.  I'll delete it.  And I see you have this "
"brand new file named 'newfile' in A', so I'll keep it.\" That gives the same "
"results as three-way content merging A:oldfile, A':newfile, and B:oldfile -- "
"a removal of oldfile with the version of newfile from A' showing up in the "
"result."
msgstr ""
"そして4番目のケースと同一のロジックにより、2 番目のケースは実際には同一のマー"
"ジになります。 A:oldfile が B:oldfile と正確に一致する場合、検出されない名前"
"変更はこのように言います「ええっと、一方が `oldfile` を変更せず、もう一方がそ"
"れを削除したようです。よってそれを削除します。 そして、 A に `newfile` という"
"名前の新しいファイルがあるので、そのままにしておきます。」 これは、 A:"
"oldfile と A':newfile と B:oldfile の3方向のコンテンツマージと同一の結果をも"
"たらします -- A' からの newfile のバージョンを含む oldfile の削除が結果に表れ"
"ます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:368
msgid ""
"The third case is interesting.  It means that A:oldfile and A':newfile were "
"not just similar enough, but that the changes between them did not conflict "
"with the changes between A:oldfile and B:oldfile.  This would validate our "
"hunch that the files were similar enough to be used in a three-way content "
"merge, and thus seems entirely correct for us to have used them that way.  "
"(Sidenote: One particular example here may be enlightening.  Let's say that "
"B was an immediate revert of A.  B clearly would have been a clean revert of "
"A, since A was B's immediate parent.  One would assume that if you can pick "
"a commit, you should also be able to cherry-pick its immediate revert.  "
"However, this is one of those funny corner cases; without this optimization, "
"we just successfully picked a commit cleanly, but we are unable to cherry-"
"pick its immediate revert due to the size differences between E:oldfile and "
"A:oldfile.)"
msgstr ""
"3番目のケースは興味深いです。 これは、A:oldfile と A':newfile が十分に類似し"
"ているだけでなく、それらの間の変更が A:oldfile と B:oldfile の間の変更と競合"
"しなかったことを意味します。 これは、ファイルが 3 方向のコンテンツ マージで使"
"用できるほど類似しているという私たちの推測を検証したものでして、つまり、この"
"ように使用したことは完全に正しいと思われます。 (補足: ここでの 1 つの特定の例"
"は、啓発的かもしれません。 B が A の直接の復帰(revert)であるとしましょう。A "
"は B の直接の親であるため、B は明らかに A の完全な復帰(revert)でした。 コミッ"
"トを選択できる場合は、その即時の復帰(revert)も選択できるはずです。 ただし、こ"
"れは面白いレアケース(corner cases)の 1 つです。 この最適化がなければ、コミッ"
"トをきれいに選択することに成功しましたが、E:oldfile と A:oldfile のサイズが異"
"なるため、直ちに戻す(revert)ためにそれをチェリーピック(cherry-pick)することは"
"できません。)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:381
msgid ""
"That leaves only the first case to consider -- when we get conflicts both "
"with or without the optimization.  Without the optimization, we'll have a "
"modify/delete conflict, where both A':newfile and B:oldfile are left in the "
"tree for the user to deal with and no hints about the potential similarity "
"between the two.  With the optimization, we'll have a three-way content "
"merged A:oldfile, A':newfile, and B:oldfile with conflict markers suggesting "
"we thought the files were related but giving the user the chance to "
"resolve.  As noted above, I don't think users will find us treating "
"'oldfile' and 'newfile' as related as a surprise since they were between E "
"and G.  In any event, though, this case shouldn't be concerning since we hit "
"a conflict in both cases, told the user what we know, and asked them to "
"resolve it."
msgstr ""
"考慮すべきなのは最初のケースのみです -- それは最適化の有無にかかわらず競合が"
"発生した場合です。 最適化を行わないと、 変更/削除 の競合が発生し、 A':"
"newfile と B:oldfile の両方がツリーに残され、ユーザーが処理できるようになり、"
"2 つの潜在的な類似性についてのヒントがなくなります。 最適化により、 A:"
"oldfile と A':newfile と B:oldfile が 3 方向のコンテンツマージされ、ファイル"
"が関連していると思われる競合マーカーが表示されますが、ユーザーには解決する機"
"会が与えられます。 前述したように、「oldfile」と「newfile」は E と G の間だっ"
"たので、ユーザーは「oldfile」と「newfile」を関連性があるものとして扱っている"
"ことに驚かないと思います。 いずれにせよ、どちらの場合も競合に遭遇し、ユーザー"
"に知っていることを伝え、解決するように依頼したため、このケースは心配する必要"
"がはありません。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:385
msgid ""
"So, in summary, case 4 is impossible, case 2 yields the same behavior, and "
"cases 1 and 3 seem to provide as good or better behavior with the "
"optimization than without."
msgstr ""
"つまり、要約すると、ケース 4 は不可能であり、ケース 2 は同一の振る舞いをもた"
"らし、ケース 1 と 3 は、最適化を使用しない場合と同じか、またはより良い振る舞"
"いをもたらすように見えます。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:387
#, no-wrap
msgid "6. Interaction with skipping of \"irrelevant\" renames"
msgstr "6. 「無関係」(irrelevant)な名前のスキップとの相互作用"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:391
msgid ""
"Previous optimizations involved skipping rename detection for paths "
"considered to be \"irrelevant\".  See for example the following commits:"
msgstr ""
"以前の最適化では、「無関係」(irrelevant)と見なされるパスの名前変更検出をス"
"キップしていました。 たとえば、以下のコミットを参照してください:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:394
msgid ""
"32a56dfb99 (\"merge-ort: precompute subset of sources for which we need "
"rename detection\", 2021-03-11)"
msgstr ""
"32a56dfb99 (\"merge-ort: precompute subset of sources for which we need "
"rename detection\", 2021-03-11)(訳注:名前変更の検出が必要なソースのサブセット"
"を事前計算する)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:396
msgid ""
"2fd9eda462 (\"merge-ort: precompute whether directory rename detection is "
"needed\", 2021-03-11)"
msgstr ""
"2fd9eda462 (\"merge-ort: precompute whether directory rename detection is "
"needed\", 2021-03-11)(訳注:ディレクトリ名変更の検出が必要かどうかを事前計算す"
"る)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:398
msgid ""
"9bd342137e (\"diffcore-rename: determine which relevant_sources are no "
"longer relevant\", 2021-03-13)"
msgstr ""
"9bd342137e (\"diffcore-rename: determine which relevant_sources are no "
"longer relevant\", 2021-03-13)(訳注:関連性がなくなった related_sources を特定"
"する)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:405
msgid ""
"Relevance is always determined by what the _other_ side of history has done, "
"in terms of modifying a file that our side renamed, or adding a file to a "
"directory which our side renamed.  This means that a path that is "
"\"irrelevant\" when picking the first commit of a series in a rebase or "
"cherry-pick, may suddenly become \"relevant\" when picking the next commit."
msgstr ""
"関連性は常に、履歴の「相手側」(other side)が何をしたかによって決定されます。"
"たとえば、 our side が名前を変更したファイルを変更したり、 our side が名前を"
"変更したディレクトリにファイルを追加したりします。 これは、リベースまたはチェ"
"リーピックでシリーズの最初のコミットを選択するときに「無関係」(irrelevant)で"
"あるパスが、次のコミットを選択するときに突然「関連あり」(relevant)になる可能"
"性があることを意味します。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:412
msgid ""
"The upshot of this is that we can only cache rename detection results for "
"relevant paths, and need to re-check relevance in subsequent commits.  If "
"those subsequent commits have additional paths that are relevant for rename "
"detection, then we will need to redo rename detection -- though we can limit "
"it to the paths for which we have not already detected renames."
msgstr ""
"この結果、関連するパスの名前変更検出結果のみをキャッシュすることができ、そし"
"てそれゆえに、後続のコミットで関連性を再確認する必要があります。 これらの後続"
"のコミットに、名前変更の検出に関連する追加のパスがある場合は、名前変更の検出"
"をやり直す必要があります -- ただし、名前変更がまだ検出されていないパスに限定"
"することはできます。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:414
#, no-wrap
msgid "7. Additional items that need to be cached"
msgstr "7. キャッシュする必要があるその他のアイテム"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:417
msgid "It turns out we have to cache more than just renames; we also cache:"
msgstr ""
"私達は、名前変更だけでなく、それ以上のものをキャッシュしなければならないこと"
"がわかりました。 私達は以下もキャッシュします:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:420
msgid "non-renames (i.e. unpaired deletes)"
msgstr "非名前変更(non-renames)(つまり ペアでない削除(unpaired deletes))"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:422
msgid "counts of renames within directories"
msgstr "ディレクトリ内の名前変更の数"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:425
msgid ""
"sources that were marked as RELEVANT_LOCATION, but which were downgraded to "
"RELEVANT_NO_MORE"
msgstr ""
"RELEVANT_LOCATION としてマークされていたが、 RELEVANT_NO_MORE にダウングレー"
"ドされたソース"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:427
msgid "the toplevel trees involved in the merge"
msgstr "マージに含まれるトップレベルのツリー"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:429
msgid "These are all stored in struct rename_info, and respectively appear in"
msgstr "これらはすべて以下のとおり struct rename_info に格納されます"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:431
msgid "cached_pairs (along side actual renames, just with a value of NULL)"
msgstr "cached_pairs (値が NULL の場合のみ、実際の名前変更とともに)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:432
msgid "dir_rename_counts"
msgstr "dir_rename_counts"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:433
msgid "cached_irrelevant"
msgstr "cached_irrelevant"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:434
msgid "merge_trees"
msgstr "merge_trees"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:444
msgid ""
"The reason for (A) comes from the irrelevant renames skipping optimization "
"discussed in section 6.  The fact that irrelevant renames are skipped means "
"we only get a subset of the potential renames detected and subsequent "
"commits may need to run rename detection on the upstream side on a subset of "
"the remaining renames (to get the renames that are relevant for that later "
"commit).  Since unpaired deletes are involved in rename detection too, we "
"don't want to repeatedly check that those paths remain unpaired on the "
"upstream side with every commit we are transplanting."
msgstr ""
"(A) の理由は、セクション 6 で説明した最適化をスキップする無関係な名前変更に由"
"来します。 無関係な名前変更がスキップされるという事実は、検出された可能性のあ"
"る名前変更のサブセットのみを取得することを意味し、後続のコミットでは、残りの"
"名前変更のサブセットに対してアップストリーム側で名前変更検出を実行する必要が"
"ある場合があります(その後のコミットに関連する名前変更を取得するため)。 対に"
"なっていない削除は名前変更の検出にも関与するため、移植(transplant)するすべて"
"のコミットでそれらのパスがアップストリーム側で対になっていないままであること"
"を繰り返し確認したくありません。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:450
msgid ""
"The reason for (B) is that diffcore_rename_extended() is what generates the "
"counts of renames by directory which is needed in directory rename "
"detection, and if we don't run diffcore_rename_extended() again then we need "
"to have the output from it, including dir_rename_counts, from the previous "
"run."
msgstr ""
"(B) の理由は、diffcore_rename_extended() が、ディレクトリの名前変更の検出に必"
"要なディレクトリごとの名前変更の数を生成するものであり、 "
"diffcore_rename_extended() を再度実行しない場合は、以前の実行での "
"dir_rename_counts を含む出力が必要です。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:457
msgid ""
"The reason for (C) is that merge-ort's tree traversal will again think those "
"paths are relevant (marking them as RELEVANT_LOCATION), but the fact that "
"they were downgraded to RELEVANT_NO_MORE means that dir_rename_counts "
"already has the information we need for directory rename detection.  (A path "
"which becomes RELEVANT_CONTENT in a subsequent commit will be removed from "
"cached_irrelevant.)"
msgstr ""
"(C) の理由は、merge-ort のツリー トラバーサルがこれらのパスが関連性があると再"
"び判断する(RELEVANT_LOCATION としてマークする)ためですが、それらが "
"RELEVANT_NO_MORE にダウングレードされたという事実は、ディレクトリの名前変更の"
"検出に必要な情報が dir_rename_counts に既に含まれていることを意味します。 (後"
"続のコミットで RELEVANT_CONTENT になるパスは、cached_irrelevant から削除され"
"ます。)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:461
msgid ""
"The reason for (D) is that is how we determine whether the remember renames "
"optimization can be used.  In particular, remembering that our sequence of "
"merges looks like:"
msgstr ""
"(D) の理由は、名前変更の記憶の最適化を使用できるかどうかをどのように判断する"
"かです。 特に、一連のマージが以下のようになっていることを思い出してください:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:467
#, no-wrap
msgid ""
"   Merge 1:\n"
"   MERGE_BASE:   E\n"
"   MERGE_SIDE1:  G\n"
"   MERGE_SIDE2:  A\n"
"   => Creates    A'\n"
msgstr ""
"   Merge 1:\n"
"   MERGE_BASE:   E\n"
"   MERGE_SIDE1:  G\n"
"   MERGE_SIDE2:  A\n"
"   => Creates    A'\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:473
#, no-wrap
msgid ""
"   Merge 2:\n"
"   MERGE_BASE:   A\n"
"   MERGE_SIDE1:  A'\n"
"   MERGE_SIDE2:  B\n"
"   => Creates    B'\n"
msgstr ""
"   Merge 2:\n"
"   MERGE_BASE:   A\n"
"   MERGE_SIDE1:  A'\n"
"   MERGE_SIDE2:  B\n"
"   => Creates    B'\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:478
msgid ""
"It is the fact that the trees A and A' appear both in Merge 1 and in Merge "
"2, with A as a parent of A' that allows this optimization.  So we store the "
"trees to compare with what we are asked to merge next time."
msgstr ""
"この最適化を可能にするのは、ツリー A と A' が Merge 1 と Merge 2 の両方に表示"
"され、A が A' の親であるという事実です。 そのため、次にマージするように求めら"
"れたものと比較するために、ツリーを保存します。"

#. type: Title ==
#: ../Documentation-sedout/technical/remembering-renames.txt:480
#, no-wrap
msgid "8. How directory rename detection interacts with the above and why this optimization is still safe even if merge.directoryRenames is set to \"true\"."
msgstr "8. ディレクトリ名変更の検出が上記とどのように相互作用するか、また、 merge.directoryRenames が「true」に設定されている場合でも、この最適化が依然として安全である理由。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:483
msgid "As noted in the assumptions section:"
msgstr "仮定セクションで述べたように:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:493
#, no-wrap
msgid ""
"    \"\"\"\n"
"    ...if directory renames do occur, then the default of\n"
"    merge.directoryRenames being set to \"conflict\" means that the operation\n"
"    will stop for users to resolve the conflicts and the cache will be\n"
"    thrown away, and thus that there won't be an optimization to apply.\n"
"    So, the only reason we need to address directory renames specifically,\n"
"    is that some users will have set merge.directoryRenames to \"true\" to\n"
"    allow the merges to continue to proceed automatically.\n"
"    \"\"\"\n"
msgstr ""
"    \"\"\"\n"
"    …ディレクトリの名前変更が発生したときに、merge.directoryRenames のデフォルトが\n"
"    `conflict` に設定されていることは、ユーザーが競合を解決するために操作が停止(stop)し、\n"
"    キャッシュが破棄されることを意味することにも注意してください。\n"
"    つまり、最適化は適用されません。\n"
"    したがって、ディレクトリの名前変更に具体的に対処する必要がある唯一の理由は、\n"
"    一部のユーザーが merge.directoryRenames を `true` に設定して、\n"
"    マージが自動的に続行できるようにするためです。\n"
"    \"\"\"\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:497
msgid ""
"Let's remember that we need to look at how any given pick affects the next "
"one.  So let's again use the first two picks from the diagram in section one:"
msgstr ""
"特定のピックが次のピックにどのように影響するかを調べる必要があることを思い出"
"してください。 それでは、セクション 1 の図の最初の 2 つのピックをもう一度見て"
"みましょう:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:499
#, no-wrap
msgid "  First pick does this three-way merge:\n"
msgstr "最初のピックは、以下 3 方向のマージを行います\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:504
#, no-wrap
msgid ""
"    MERGE_BASE:   E\n"
"    MERGE_SIDE1:  G\n"
"    MERGE_SIDE2:  A\n"
"    => creates A'\n"
msgstr ""
"    MERGE_BASE:   E\n"
"    MERGE_SIDE1:  G\n"
"    MERGE_SIDE2:  A\n"
"    => creates A'\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:506
#, no-wrap
msgid "  Second pick does this three-way merge:\n"
msgstr "2 番目のピックは、以下の 3 方向マージを行います\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:511
#, no-wrap
msgid ""
"    MERGE_BASE:   A\n"
"    MERGE_SIDE1:  A'\n"
"    MERGE_SIDE2:  B\n"
"    => creates B'\n"
msgstr ""
"    MERGE_BASE:   A\n"
"    MERGE_SIDE1:  A'\n"
"    MERGE_SIDE2:  B\n"
"    => creates B'\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:519
msgid ""
"Now, directory rename detection exists so that if one side of history "
"renames a directory, and the other side adds a new file to the old "
"directory, then the merge (with merge.directoryRenames=true) can move the "
"file into the new directory.  There are two qualitatively different ways to "
"add a new file to an old directory: create a new file, or rename a file into "
"that directory.  Also, directory renames can be done on either side of "
"history, so there are four cases to consider:"
msgstr ""
"現在、ディレクトリの名前変更検出が存在するため、履歴の一方がディレクトリを名"
"前変更し、もう一方が古いディレクトリに新しいファイルを追加した場合、マージ"
"(merge.directoryRenames=true を使用)によってファイルを新しいディレクトリに移"
"動できます。 古いディレクトリに新しいファイルを追加するには、質的に異なる 2 "
"つの方法があります。 新しいファイルを作成するか、ファイル名を名前変更してその"
"ディレクトリにします。 また、ディレクトリの名前変更は履歴のどちらの側でも実行"
"できるため、考慮すべき 4 つのケースがあります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:521
msgid "MERGE_SIDE1 renames old dir, MERGE_SIDE2 adds new file to old dir"
msgstr ""
"MERGE_SIDE1は old dir を名前変更し、 MERGE_SIDE2は新しいファイルを old dir に"
"追加します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:522
msgid "MERGE_SIDE1 renames old dir, MERGE_SIDE2 renames file into old dir"
msgstr ""
"MERGE_SIDE1は old dir を名前変更し、 MERGE_SIDE2はファイルの名前を old dir に"
"名前変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:523
msgid "MERGE_SIDE1 adds new file to old dir, MERGE_SIDE2 renames old dir"
msgstr ""
"MERGE_SIDE1は新しいファイルを old dir に追加し、MERGE_SIDE2は old dir を名前"
"変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:524
msgid "MERGE_SIDE1 renames file into old dir, MERGE_SIDE2 renames old dir"
msgstr ""
"MERGE_SIDE1はファイルの名前を old dir に名前変更し、MERGE_SIDE2は old dir を"
"名前変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:529
msgid ""
"One last note before we consider these four cases: There are some important "
"properties about how we implement this optimization with respect to "
"directory rename detection that we need to bear in mind while considering "
"all of these cases:"
msgstr ""
"これら 4 つのケースを検討する前に、最後に 1 つ注意してください。ディレクトリ"
"の名前変更の検出に関して、この最適化をどのように実装するかについて、これらす"
"べてのケースを検討する際に留意する必要があるいくつかの重要な性質があります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:531
msgid "rename caching occurs *after* applying directory renames"
msgstr ""
"ディレクトリの名前変更を適用(apply)した「後」に、名前変更のキャッシュ(rename "
"caching)が発生します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:534
msgid ""
"a rename created by directory rename detection is recorded for the side of "
"history that did the directory rename."
msgstr ""
"ディレクトリの名前変更検出によって作成された名前変更は、ディレクトリの名前変"
"更を行った履歴の側(the side of history)に記録されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:542
msgid ""
"dir_rename_counts, the nested map of `{oldname => {newname => count}}`, is "
"cached between runs as well.  This basically means that directory rename "
"detection is also cached, though only on the side of history that we cache "
"renames for (MERGE_SIDE1 as far as this document is concerned; see the "
"assumptions section).  Two interesting sub-notes about these counts:"
msgstr ""
"`{oldname => {newname => count}}` の入れ子になったマップである "
"dir_rename_counts も、実行と実行の間に渡ってキャッシュされます。 これは基本的"
"に、ディレクトリの名前変更検出もキャッシュされることを意味しますが、名前変更"
"をキャッシュする履歴側のみです (このドキュメントに関する限り、MERGE_SIDE1。 "
"「0.仮定」のセクションを参照してください)。 これらのカウントに関する 2 つの興"
"味深いサブノートがあります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:553
msgid ""
"If we need to perform rename-detection again on the given side (e.g.  some "
"paths are relevant for rename detection that weren't before), then we clear "
"dir_rename_counts and recompute it, making use of cached_pairs.  The reason "
"it is important to do this is optimizations around RELEVANT_LOCATION exist "
"to prevent us from computing unnecessary renames for directory rename "
"detection and from computing dir_rename_counts for irrelevant directories; "
"but those same renames or directories may become necessary for subsequent "
"merges.  The easiest way to \"fix up\" dir_rename_counts in such cases is to "
"just recompute it."
msgstr ""
"指定された側(side)で名前変更検出を再度実行する必要がある場合(例: 一部のパス"
"は、以前にはなかった名前変更検出に関連しています)は、dir_rename_counts をクリ"
"アして再計算し、cached_pairs を使用します。 これを行うことが重要な理由は、"
"RELEVANT_LOCATION 周辺の最適化が存在するためです。これにより、ディレクトリの"
"名前変更検出のために不要な名前変更を計算したり、無関係なディレクトリの "
"dir_rename_counts を計算したりできなくなります。 ただし、その後のマージでは、"
"同じ名前またはディレクトリが必要になる場合があります。 このような場合に "
"dir_rename_counts を「修正」する最も簡単な方法は、単に再計算することです。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:562
msgid ""
"If we prune rename/rename(1to1) entries from the cache, then we also need to "
"update dir_rename_counts to decrement the counts for the involved directory "
"and any relevant parent directories (to undo what update_dir_rename_counts() "
"in diffcore-rename.c incremented when the rename was initially found).  If "
"we instead just disable the remembering renames optimization when the "
"exceedingly rare rename/rename(1to1) cases occur, then dir_rename_counts "
"will get re-computed the next time rename detection occurs, as noted above."
msgstr ""
"rename/rename(1to1) エントリをキャッシュから刈り込み(prune)する場合は、"
"dir_rename_counts を更新して、関連するディレクトリと関連する親ディレクトリの"
"数を減らす必要もあります(名前変更が最初に見つかったときに diffcore-rename.c "
"の update_dir_rename_counts() がインクリメントしたものを元に戻すため)。 代わ"
"りに、非常にまれな 名前変更/名前変更(1to1) のケースが発生したときに名前変更の"
"記憶の最適化を無効にすると、上記のように、次に名前変更の検出が発生したときに "
"dir_rename_counts が再計算されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:567
msgid ""
"the side with multiple commits to pick, is the side of history that we do "
"NOT cache renames for.  Thus, there are no additional commits to change the "
"number of renames in a directory, except for those done by directory rename "
"detection (which always pad the majority)."
msgstr ""
"選択する複数のコミットがある側は、名前変更をキャッシュしない履歴の側(side)で"
"す。 したがって、ディレクトリ名変更検出 (常に過半数を埋める) によって行われる"
"ものを除いて、ディレクトリ内の名前変更の数を変更するための追加のコミットはあ"
"りません。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:570
msgid ""
"the \"renames\" we cache are modified slightly by any directory rename, as "
"noted below."
msgstr ""
"以下に示すように、キャッシュする「名前変更」は、ディレクトリの名前変更によっ"
"てわずかに変更されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:573
msgid ""
"Now, with those notes out of the way, let's go through the four cases in "
"order:"
msgstr "さて、これらの注意事項を整理して、4 つのケースを順番に見ていきます:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:575
msgid ""
"Case 1: MERGE_SIDE1 renames old dir, MERGE_SIDE2 adds new file to old dir"
msgstr ""
"ケース 1: MERGE_SIDE1 は old dir の名前変更し、 MERGE_SIDE2 は old dir に新し"
"いファイルを追加します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:577
#: ../Documentation-sedout/technical/remembering-renames.txt:599
#: ../Documentation-sedout/technical/remembering-renames.txt:623
#: ../Documentation-sedout/technical/remembering-renames.txt:641
msgid "This case looks like this:"
msgstr "このケースは以下のようになります:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:582
#, no-wrap
msgid ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Renames olddir/ -> newdir/\n"
"    MERGE_SIDE2:  A,   Adds olddir/newfile\n"
"    => creates    A',  With newdir/newfile\n"
msgstr ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Renames olddir/ -> newdir/\n"
"    MERGE_SIDE2:  A,   Adds olddir/newfile\n"
"    => creates    A',  With newdir/newfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:587
#, no-wrap
msgid ""
"    MERGE_BASE:   A,   Has olddir/newfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Modifies olddir/newfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"
msgstr ""
"    MERGE_BASE:   A,   Has olddir/newfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Modifies olddir/newfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:589
#: ../Documentation-sedout/technical/remembering-renames.txt:611
#: ../Documentation-sedout/technical/remembering-renames.txt:653
msgid "In this case, with the optimization, note that after the first commit:"
msgstr "最適化されるこの場合、最初のコミット後に以下の点に注意してください:"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:591
#: ../Documentation-sedout/technical/remembering-renames.txt:613
msgid "MERGE_SIDE1 remembers olddir/ -> newdir/"
msgstr "MERGE_SIDE1 は olddir/ → newdir/ を記憶します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:592
msgid "MERGE_SIDE1 has cached olddir/newfile -> newdir/newfile"
msgstr "MERGE_SIDE1 は olddir/newfile → newdir/newfile をキャッシュしました"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:595
#: ../Documentation-sedout/technical/remembering-renames.txt:619
#: ../Documentation-sedout/technical/remembering-renames.txt:662
msgid ""
"Given the cached rename noted above, the second merge can proceed as "
"expected without needing to perform rename detection from A -> A'."
msgstr ""
"上記のキャッシュされた名前変更を考えると、2番目のマージは、 A → A' からの名前"
"変更検出を実行する必要なく、期待どおりに続行できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:597
msgid ""
"Case 2: MERGE_SIDE1 renames old dir, MERGE_SIDE2 renames file into old dir"
msgstr ""
"Case 2: MERGE_SIDE1 は old dir を名前変更し、 MERGE_SIDE2 はファイルの名前を "
"old dir に名前変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:604
#, no-wrap
msgid ""
"    MERGE_BASE:   E    oldfile, olddir/\n"
"    MERGE_SIDE1:  G    oldfile, olddir/ -> newdir/\n"
"    MERGE_SIDE2:  A    oldfile -> olddir/newfile\n"
"    => creates    A',  With newdir/newfile representing original oldfile\n"
msgstr ""
"    MERGE_BASE:   E    oldfile, olddir/\n"
"    MERGE_SIDE1:  G    oldfile, olddir/ -> newdir/\n"
"    MERGE_SIDE2:  A    oldfile -> olddir/newfile\n"
"    => creates    A',  With newdir/newfile representing original oldfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:609
#, no-wrap
msgid ""
"    MERGE_BASE:   A    olddir/newfile\n"
"    MERGE_SIDE1:  A'   newdir/newfile\n"
"    MERGE_SIDE2:  B    modify olddir/newfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"
msgstr ""
"    MERGE_BASE:   A    olddir/newfile\n"
"    MERGE_SIDE1:  A'   newdir/newfile\n"
"    MERGE_SIDE2:  B    modify olddir/newfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:616
msgid ""
"MERGE_SIDE1 has cached olddir/newfile -> newdir/newfile (NOT oldfile -> "
"newdir/newfile; compare to case with (p->status == 'R' && new_path) in "
"possibly_cache_new_pair())"
msgstr ""
"MERGE_SIDE1 は olddir/newfile → newdir/newfile をキャッシュします(oldfile → "
"newdir/newfile ではありません。 possible_cache_new_pair() 内の (p->status == "
"'R' && new_path) の場合と比較してください)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:621
msgid ""
"Case 3: MERGE_SIDE1 adds new file to old dir, MERGE_SIDE2 renames old dir"
msgstr ""
"ケース 3: MERGE_SIDE1は新しいファイルを「古いディレクトリ」に追加し、"
"MERGE_SIDE2は「古いディレクトリ」を名前変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:628
#, no-wrap
msgid ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Adds olddir/newfile\n"
"    MERGE_SIDE2:  A,   Renames olddir/ -> newdir/\n"
"    => creates    A',  With newdir/newfile\n"
msgstr ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Adds olddir/newfile\n"
"    MERGE_SIDE2:  A,   Renames olddir/ -> newdir/\n"
"    => creates    A',  With newdir/newfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:633
#, no-wrap
msgid ""
"    MERGE_BASE:   A,   Has newdir/, but no notion of newdir/newfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Has newdir/, but no notion of newdir/newfile\n"
"    => expected   B',  with newdir/newfile from A'\n"
msgstr ""
"    MERGE_BASE:   A,   Has newdir/, but no notion of newdir/newfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Has newdir/, but no notion of newdir/newfile\n"
"    => expected   B',  with newdir/newfile from A'\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:637
msgid ""
"In this case, with the optimization, note that after the first commit there "
"were no renames on MERGE_SIDE1, and any renames on MERGE_SIDE2 are tossed.  "
"But the second merge didn't need any renames so this is fine."
msgstr ""
"この場合、最適化により、最初のコミット後に MERGE_SIDE1 の名前変更がなく、"
"MERGE_SIDE2 の名前変更が破棄されることに注意してください。 しかし、2 回目の"
"マージでは名前変更する必要がなかったので、これで問題ありません。"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:639
msgid ""
"Case 4: MERGE_SIDE1 renames file into old dir, MERGE_SIDE2 renames old dir"
msgstr ""
"ケース 4: MERGE_SIDE1 はファイルの名前を old dir に名前変更し、MERGE_SIDE2 "
"は old dir を名前変更します"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:646
#, no-wrap
msgid ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Renames oldfile -> olddir/newfile\n"
"    MERGE_SIDE2:  A,   Renames olddir/ -> newdir/\n"
"    => creates    A',  With newdir/newfile representing original oldfile\n"
msgstr ""
"    MERGE_BASE:   E,   Has olddir/\n"
"    MERGE_SIDE1:  G,   Renames oldfile -> olddir/newfile\n"
"    MERGE_SIDE2:  A,   Renames olddir/ -> newdir/\n"
"    => creates    A',  With newdir/newfile representing original oldfile\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:651
#, no-wrap
msgid ""
"    MERGE_BASE:   A,   Has oldfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Modifies oldfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"
msgstr ""
"    MERGE_BASE:   A,   Has oldfile\n"
"    MERGE_SIDE1:  A',  Has newdir/newfile\n"
"    MERGE_SIDE2:  B,   Modifies oldfile\n"
"    => expected   B',  with threeway-merged newdir/newfile from above\n"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:657
msgid ""
"MERGE_SIDE1 remembers oldfile -> newdir/newfile (NOT oldfile -> olddir/"
"newfile; compare to case of second block under p->status == 'R' in "
"possibly_cache_new_pair())"
msgstr ""
"MERGE_SIDE1 は oldfile → newdir/newfile を記憶します(oldfile → olddir/"
"newfile ではありません。 possible_cache_new_pair() 内の p->status == 'R' の下"
"の 2番目のブロックの場合と比較してください)"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:659
msgid "MERGE_SIDE2 renames are tossed because only MERGE_SIDE1 is remembered"
msgstr ""
"MERGE_SIDE1 のみが記憶されているため、 MERGE_SIDE2 の名前変更は破棄されます"

#. type: Plain text
#: ../Documentation-sedout/technical/remembering-renames.txt:672
msgid ""
"Finally, I'll just note here that interactions with the skip-irrelevant-"
"renames optimization means we sometimes don't detect renames for any files "
"within a directory that was renamed, in which case we will not have been "
"able to detect any rename for the directory itself.  In such a case, we do "
"not know whether the directory was renamed; we want to be careful to avoid "
"caching some kind of \"this directory was not renamed\" statement.  If we "
"did, then a subsequent commit being rebased could add a file to the old "
"directory, and the user would expect it to end up in the correct directory "
"-- something our erroneous \"this directory was not renamed\" cache would "
"preclude."
msgstr ""
"最後に、 skip-irrelevant-renames 最適化との相互作用により、名前変更されたディ"
"レクトリ内のすべてのファイルの名前変更検出しない場合があることをここで指摘し"
"ておきます。 このような場合、ディレクトリが名前変更されたかどうかはわかりませ"
"ん。 ある種の「このディレクトリは名前変更されていません」ステートメントを"
"キャッシュしないように注意する必要があります。 もしそうなら、リベースされてい"
"る後続のコミットはファイルを古いディレクトリに追加する可能性があり、ユーザー"
"はそれが正しいディレクトリにあることを期待するでしょう -- つまり「このディレ"
"クトリは名前変更されていません」という誤ったキャッシュが除外されます。"
