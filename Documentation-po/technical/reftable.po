# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 05:35+0900\n"
"PO-Revision-Date: 2022-09-22 16:25+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title -
#: ../Documentation-sedout/technical/reftable.txt:2
#, no-wrap
msgid "reftable"
msgstr "reftable"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:5
#, no-wrap
msgid "Overview"
msgstr "Overview"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:8
#, no-wrap
msgid "Problem statement"
msgstr "Problem statement"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:14
msgid ""
"Some repositories contain a lot of references (e.g. android at 866k, rails "
"at 31k). The existing packed-refs format takes up a lot of space (e.g. 62M), "
"and does not scale with additional references. Lookup of a single reference "
"requires linearly scanning the file."
msgstr "一部のリポジトリにはたくさんの参照が含まれています(例: android の 866k、rails の 31k)。 既存の pack-refs 形式は多くのスペース(たとえば 62M とか)を占有し、追加の参照では拡張できません。 単一の参照を検索するには、ファイルを線形にスキャンする必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:18
msgid ""
"Atomic pushes modifying multiple references require copying the entire "
"packed-refs file, which can be a considerable amount of data moved (e.g. 62M "
"in, 62M out) for even small transactions (2 refs modified)."
msgstr "複数の参照を変更するアトミック・プッシュでは、パックされた参照ファイル全体をコピーする必要があります。これは、(2つの参照が変更されただけの、)小さな取引 (transactions)でも、かなりの量のデータが移動される可能性があります(たとえば、62M の入出力)。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:26
msgid ""
"Repositories with many loose references occupy a large number of disk blocks "
"from the local file system, as each reference is its own file storing 41 "
"bytes (and another file for the corresponding reflog). This negatively "
"affects the number of inodes available when a large number of repositories "
"are stored on the same filesystem. Readers can be penalized due to the "
"larger number of syscalls required to traverse and read the `$GIT_DIR/refs` "
"directory."
msgstr "各参照は 41 バイトを格納する独自のファイル (および対応する reflog 用の別のファイル) であるため、多くの緩い(loose)参照を含むリポジトリは、ローカル・ファイルシステム上で多数のディスク・ブロックを占有します。 これは、多数のリポジトリが同じファイルシステムに保存されている場合に、利用可能な inode の数に悪影響を及ぼします。 `$GIT_DIR/refs` ディレクトリをトラバースして読み取るために必要なシステムコールの数がすごくたくさんになるため、読み取り側は不利(penalize)になる可能性があります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:29
#, no-wrap
msgid "Objectives"
msgstr "Objectives"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:33
msgid ""
"Near constant time lookup for any single reference, even when the repository "
"is cold and not in process or kernel cache."
msgstr "リポジトリがコールドでプロセスやカーネルキャッシュにない場合でも、単一の参照に対してほぼ一定時間の検索(lookup)を可能にする。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:35
msgid ""
"Near constant time verification if an object name is referred to by at least "
"one reference (for allow-tip-sha1-in-want)."
msgstr "オブジェクト名が少なくとも1つの参照によって参照される場合、ほぼ一定時間で検証(verification)を行う(allow-tip-sha1-in-want 用)。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:36
msgid "Efficient enumeration of an entire namespace, such as `refs/tags/`."
msgstr "`refs/tags/` のような名前空間全体の効率的な列挙。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:37
msgid "Support atomic push with `O(size_of_update)` operations."
msgstr "`O(size_of_update)` 操作量によるアトミック(atomic)プッシュをサポートします。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:38
msgid "Combine reflog storage with ref storage for small transactions."
msgstr "小さな取引(transactions)用に reflog ストレージと ref ストレージを組み合わせます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:39
msgid "Separate reflog storage for base refs and historical logs."
msgstr "ベース ref と履歴ログ用の、個別の reflog ストレージ。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:41
#, no-wrap
msgid "Description"
msgstr "Description"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:46
msgid ""
"A reftable file is a portable binary file format customized for reference "
"storage. References are sorted, enabling linear scans, binary search lookup, "
"and range scans."
msgstr "reftable ファイルは、参照ストレージ用にカスタマイズされた可搬性(portable)のあるバイナリ・ファイル形式です。 参照は並べ替えられ、線形スキャン、二分木検索検索(binary search lookup)、範囲スキャンが可能になります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:50
msgid ""
"Storage in the file is organized into variable sized blocks. Prefix "
"compression is used within a single block to reduce disk space. Block size "
"and alignment is tunable by the writer."
msgstr "ファイル内のストレージは、可変サイズのブロックに編成されます。 ディスク領域を削減するために、1 つのブロック内でプレフィックス圧縮が使用されます。 ブロックサイズと揃え幅(alignment)は、ライターによって調整可能です。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:52
#, no-wrap
msgid "Performance"
msgstr "Performance"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:55
msgid "Space used, packed-refs vs. reftable:"
msgstr "使用スペース packed-refs V.S. reftable:"

#. type: Table
#: ../Documentation-sedout/technical/reftable.txt:63
#, no-wrap
msgid ""
"|repository |packed-refs |reftable |% original |avg ref |avg obj\n"
"|android |62.2 M |36.1 M |58.0% |33 bytes |5 bytes\n"
"|rails |1.8 M |1.1 M |57.7% |29 bytes |4 bytes\n"
"|git |78.7 K |48.1 K |61.0% |50 bytes |4 bytes\n"
"|git (heads) |332 b |269 b |81.0% |33 bytes |0 bytes\n"
msgstr ""
"|repository |packed-refs |reftable |% original |avg ref |avg obj\n"
"|android |62.2 M |36.1 M |58.0% |33 bytes |5 bytes\n"
"|rails |1.8 M |1.1 M |57.7% |29 bytes |4 bytes\n"
"|git |78.7 K |48.1 K |61.0% |50 bytes |4 bytes\n"
"|git (heads) |332 b |269 b |81.0% |33 bytes |0 bytes\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:67
msgid ""
"Scan (read 866k refs), by reference name lookup (single ref from 866k refs), "
"and by SHA-1 lookup (refs with that SHA-1, from 866k refs):"
msgstr "スキャン (866k ref の読み取り)と、参照名検索(lookup) (866k refs から 単一 ref を)と、SHA-1 検索(lookup) (866k refs からのその SHA-1 を含む refs):"

#. type: Table
#: ../Documentation-sedout/technical/reftable.txt:75
#, no-wrap
msgid ""
"|format |cache |scan |by name |by SHA-1\n"
"|packed-refs |cold |402 ms |409,660.1 usec |412,535.8 usec\n"
"|packed-refs |hot | |6,844.6 usec |20,110.1 usec\n"
"|reftable |cold |112 ms |33.9 usec |323.2 usec\n"
"|reftable |hot | |20.2 usec |320.8 usec\n"
msgstr ""
"|format |cache |scan |by name |by SHA-1\n"
"|packed-refs |cold |402 ms |409,660.1 usec |412,535.8 usec\n"
"|packed-refs |hot | |6,844.6 usec |20,110.1 usec\n"
"|reftable |cold |112 ms |33.9 usec |323.2 usec\n"
"|reftable |hot | |20.2 usec |320.8 usec\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:78
msgid ""
"Space used for 149,932 log entries for 43,061 refs, reflog vs. reftable:"
msgstr "43,061 refs の 149,932 ログ エントリに使用されるスペース  reflog V.S. reftable:"

#. type: Table
#: ../Documentation-sedout/technical/reftable.txt:84
#, no-wrap
msgid ""
"|format |size |avg entry\n"
"|$GIT_DIR/logs |173 M |1209 bytes\n"
"|reftable |5 M |37 bytes\n"
msgstr ""
"|format |size |avg entry\n"
"|$GIT_DIR/logs |173 M |1209 bytes\n"
"|reftable |5 M |37 bytes\n"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:87
#, no-wrap
msgid "Details"
msgstr "Details"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:90
#, no-wrap
msgid "Peeling"
msgstr "Peeling"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:95
msgid ""
"References stored in a reftable are peeled, a record for an annotated (or "
"signed) tag records both the tag object, and the object it refers to. This "
"is analogous to storage in the packed-refs format."
msgstr "reftable に格納された参照は皮むき(peel)され、注釈付き (または署名付き) タグのレコードは、タグ オブジェクトとそれが参照するオブジェクトの両方を記録します。 これは、packed-refs 形式のストレージに似ています。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:97
#, no-wrap
msgid "Reference name encoding"
msgstr "Reference name encoding"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:101
msgid ""
"Reference names are an uninterpreted sequence of bytes that must pass "
"linkgit:git-check-ref-format[1] as a valid reference name."
msgstr "参照名は解釈されないバイト列で、有効な参照名としては linkgit:git-check-ref-format[1] をパス(pass)しなければなりません。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:103
#, no-wrap
msgid "Key unicity"
msgstr "Key unicity"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:106
msgid "Each entry must have a unique key; repeated keys are disallowed."
msgstr "各エントリには一意のキーが必要です。 キーの繰り返しは許可されません。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:108
#, no-wrap
msgid "Network byte order"
msgstr "Network byte order"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:111
msgid "All multi-byte, fixed width fields are in network byte order."
msgstr "複数バイトの固定幅フィールドは、全てネットワークバイトオーダーです。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:113
#, no-wrap
msgid "Varint encoding"
msgstr "Varint encoding"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:117
msgid ""
"Varint encoding is identical to the ofs-delta encoding method used within "
"pack files."
msgstr "派生(varint)エンコーディングは、パックファイル内で使用される ofs-delta エンコーディング方法と同じです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:119
msgid "Decoder works such as:"
msgstr "デコーダーは以下のとおり機能します:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:126
#, no-wrap
msgid ""
"val = buf[ptr] & 0x7f\n"
"while (buf[ptr] & 0x80) {\n"
"  ptr++\n"
"  val = ((val + 1) << 7) | (buf[ptr] & 0x7f)\n"
"}\n"
msgstr ""
"val = buf[ptr] & 0x7f\n"
"while (buf[ptr] & 0x80) {\n"
"  ptr++\n"
"  val = ((val + 1) << 7) | (buf[ptr] & 0x7f)\n"
"}\n"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:129
#, no-wrap
msgid "Ordering"
msgstr "Ordering"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:132
msgid "Blocks are lexicographically ordered by their first reference."
msgstr "ブロックは、最初の参照によって辞書順(lexicographically ordered)に並べられます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:134
#, no-wrap
msgid "Directory/file conflicts"
msgstr "Directory/file conflicts"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:138
msgid ""
"The reftable format accepts both `refs/heads/foo` and `refs/heads/foo/bar` "
"as distinct references."
msgstr "reftable 形式は、`refs/heads/foo` と `refs/heads/foo/bar` の両方を別個の参照として受け入れます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:143
msgid ""
"This property is useful for retaining log records in reftable, but may "
"confuse versions of Git using `$GIT_DIR/refs` directory tree to maintain "
"references. Users of reftable may choose to continue to reject `foo` and "
"`foo/bar` type conflicts to prevent problems for peers."
msgstr "この特性は、reftable にログ レコードを保持するのに役立ちますが、`$GIT_DIR/refs` ディレクトリ ツリーを使用して参照を維持する Git のバージョンを混乱させる可能性があります。 reftable のユーザーは、ピアの問題を防ぐために、`foo` および `foo/bar` タイプの競合を引き続き拒否することを選択できます。"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:145
#, no-wrap
msgid "File format"
msgstr "File format"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:148
#, no-wrap
msgid "Structure"
msgstr "Structure"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:151
msgid "A reftable file has the following high-level structure:"
msgstr "reftable ファイルには、以下の高レベル構造があります:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:164
#, no-wrap
msgid ""
"first_block {\n"
"  header\n"
"  first_ref_block\n"
"}\n"
"ref_block*\n"
"ref_index*\n"
"obj_block*\n"
"obj_index*\n"
"log_block*\n"
"log_index*\n"
"footer\n"
msgstr ""
"first_block {\n"
"  header\n"
"  first_ref_block\n"
"}\n"
"ref_block*\n"
"ref_index*\n"
"obj_block*\n"
"obj_index*\n"
"log_block*\n"
"log_index*\n"
"footer\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:168
msgid ""
"A log-only file omits the `ref_block`, `ref_index`, `obj_block` and "
"`obj_index` sections, containing only the file header and log block:"
msgstr "ログのみのファイルでは、`ref_block` と `ref_index` と`obj_block` と`obj_index` セクションが省略され、ファイルヘッダーとログブロックのみが含まれます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:176
#, no-wrap
msgid ""
"first_block {\n"
"  header\n"
"}\n"
"log_block*\n"
"log_index*\n"
"footer\n"
msgstr ""
"first_block {\n"
"  header\n"
"}\n"
"log_block*\n"
"log_index*\n"
"footer\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:180
msgid ""
"in a log-only file the first log block immediately follows the file header, "
"without padding to block alignment."
msgstr "ログのみのファイルでは、最初のログ ブロックはファイル ヘッダーの直後に続き、ブロック揃え幅へのパディングは行われません。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:182
#: ../Documentation-sedout/technical/reftable.txt:816
#, no-wrap
msgid "Block size"
msgstr "Block size"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:188
msgid ""
"The file's block size is arbitrarily determined by the writer, and does not "
"have to be a power of 2. The block size must be larger than the longest "
"reference name or log entry used in the repository, as references cannot "
"span blocks."
msgstr "ファイルのブロック・サイズはライター(writer)によって任意に決定され、2 のべき乗である必要はありません。参照は複数のブロックにまたがることができないため、ブロック サイズは、リポジトリで使用される最長の参照名またはログ・エントリよりも大きくする必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:193
msgid ""
"Powers of two that are friendly to the virtual memory system or filesystem "
"(such as 4k or 8k) are recommended. Larger sizes (64k) can yield better "
"compression, with a possible increased cost incurred by readers during "
"access."
msgstr "仮想メモリ・システムまたはファイル・システム (4k や 8k など) に適した 2 の累乗が推奨されます。 サイズが大きい (64k) ほど圧縮率が高くなりますが、アクセス中にリーダー(readers)が負担するコストが増加する可能性があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:195
msgid "The largest block size is `16777215` bytes (15.99 MiB)."
msgstr "最大ブロック サイズは「16777215」バイト (15.99 MiB) です。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:197
#, no-wrap
msgid "Block alignment"
msgstr "Block alignment"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:203
msgid ""
"Writers may choose to align blocks at multiples of the block size by "
"including `padding` filled with NUL bytes at the end of a block to round out "
"to the chosen alignment. When alignment is used, writers must specify the "
"alignment with the file header's `block_size` field."
msgstr "ライター(writers)は、ブロックの末尾に NUL バイトで満たされた「詰物」(padding)を含めることにより、ブロック・サイズの倍数でブロックを揃えて、選択した揃え幅(alignment)に丸めることができます。 揃えを使用する場合、ライターはファイル・ヘッダーの「block_size」フィールドで揃え幅(alignment)を指定する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:209
msgid ""
"Block alignment is not required by the file format. Unaligned files must set "
"`block_size = 0` in the file header, and omit `padding`. Unaligned files "
"with more than one ref block must include the link:#Ref-index[ref index] to "
"support fast lookup. Readers must be able to read both aligned and non-"
"aligned files."
msgstr "このファイル形式では、ブロック揃え幅(alignment)は必須ではありません。 揃えない(unaligned)ファイルは、ファイル・ヘッダーで `block_size = 0` を設定し、「詰物」(padding)を省略しなければなりません。 複数の ref ブロックを含む揃えないファイルには、 link:#Ref-index[ref index] を含めて高速検索をサポートする必要があります。 リーダー(readers)は、揃えるファイルと揃えないファイルの両方を読み取ることができなければなりません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:212
msgid ""
"Very small files (e.g. a single ref block) may omit `padding` and the ref "
"index to reduce total file size."
msgstr "非常に小さなファイル (単一の ref ブロックなど) では、合計ファイル サイズを減らすために「詰物」(padding)とrefインデックスを省略できます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:214
#, no-wrap
msgid "Header (version 1)"
msgstr "Header (version 1)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:217
msgid "A 24-byte header appears at the beginning of the file:"
msgstr "24バイト。ファイルの先頭に 24 バイトのヘッダーが表れます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:224
#, no-wrap
msgid ""
"'REFT'\n"
"uint8( version_number = 1 )\n"
"uint24( block_size )\n"
"uint64( min_update_index )\n"
"uint64( max_update_index )\n"
msgstr ""
"'REFT'\n"
"uint8( version_number = 1 )\n"
"uint24( block_size )\n"
"uint64( min_update_index )\n"
"uint64( max_update_index )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:228
msgid ""
"Aligned files must specify `block_size` to configure readers with the "
"expected block alignment. Unaligned files must set `block_size = 0`."
msgstr "揃えるファイルは、予想されるブロック揃え幅(alignment)でリーダーを構成するために、 `block_size` を指定する必要があります。 揃えないファイルは、`block_size = 0` を設定する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:234
msgid ""
"The `min_update_index` and `max_update_index` describe bounds for the "
"`update_index` field of all log records in this file. When reftables are "
"used in a stack for link:#Update-transactions[transactions], these fields "
"can order the files such that the prior file's `max_update_index + 1` is the "
"next file's `min_update_index`."
msgstr "`min_update_index` と `max_update_index` は、このファイル内のすべてのログ・レコードの `update_index` フィールドの境界を記述します。 link:#Update-transactions[transactions] のスタックで reftable が使用される場合、これらのフィールドは、前のファイルの `max_update_index + 1` が次のファイルの `min_update_index` になるようにファイルを並べ替えることができます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:236
#, no-wrap
msgid "Header (version 2)"
msgstr "Header (version 2)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:239
msgid "A 28-byte header appears at the beginning of the file:"
msgstr "28バイト。ファイルの先頭には28バイトのヘッダーが表れます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:247
#, no-wrap
msgid ""
"'REFT'\n"
"uint8( version_number = 2 )\n"
"uint24( block_size )\n"
"uint64( min_update_index )\n"
"uint64( max_update_index )\n"
"uint32( hash_id )\n"
msgstr ""
"'REFT'\n"
"uint8( version_number = 2 )\n"
"uint24( block_size )\n"
"uint64( min_update_index )\n"
"uint64( max_update_index )\n"
"uint32( hash_id )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:251
msgid ""
"The header is identical to `version_number=1`, with the 4-byte hash ID "
"(\"sha1\" for SHA1 and \"s256\" for SHA-256) append to the header."
msgstr "ヘッダーは「version_number=1」と全く同じで、 4バイトのハッシュID (SHA1 の場合は「sha1」、SHA-256 の場合は「s256」) がヘッダーに追加されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:254
msgid ""
"For maximum backward compatibility, it is recommended to use version 1 when "
"writing SHA1 reftables."
msgstr "下位互換性を最大限に保つために、SHA1 reftable を作成する場合はバージョン 1 を使用することをお勧めします。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:256
#, no-wrap
msgid "First ref block"
msgstr "First ref block"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:261
msgid ""
"The first ref block shares the same block as the file header, and is 24 "
"bytes smaller than all other blocks in the file. The first block immediately "
"begins after the file header, at position 24."
msgstr "最初の ref ブロックは、ファイルヘッダーと同一のブロックを共有し、ファイル内の他のすべてのブロックよりも 24 バイト小さくなります。 最初のブロックは、ファイルヘッダーの直後の 24 番目の位置から始まります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:264
msgid ""
"If the first block is a log block (a log-only file), its block header begins "
"immediately at position 24."
msgstr "最初のブロックがログ・ブロック (ログのみのファイル) の場合、そのブロック・ヘッダーは位置 24 から直ちに始まります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:266
#, no-wrap
msgid "Ref block format"
msgstr "Ref block format"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:269
msgid "A ref block is written as:"
msgstr "ref ブロックは以下のとおり記述されます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:276
#, no-wrap
msgid ""
"'r'\n"
"uint24( block_len )\n"
"ref_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"
msgstr ""
"'r'\n"
"uint24( block_len )\n"
"ref_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:278
#: ../Documentation-sedout/technical/reftable.txt:390
#: ../Documentation-sedout/technical/reftable.txt:467
#, no-wrap
msgid "padding?\n"
msgstr "padding?\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:285
msgid ""
"Blocks begin with `block_type = 'r'` and a 3-byte `block_len` which encodes "
"the number of bytes in the block up to, but not including the optional "
"`padding`. This is always less than or equal to the file's block size. In "
"the first ref block, `block_len` includes 24 bytes for the file header."
msgstr "ブロックは `block_type = 'r'` で始まり、そして 3 バイトの `block_len` はブロック内のバイト数をエンコードしますが、オプションの「詰物」は含みません。 これは、常にファイルのブロック・イズ以下です。 最初の ref ブロックでは、 `block_len` にファイル・ヘッダー用の 24 バイトが含まれます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:290
msgid ""
"The 2-byte `restart_count` stores the number of entries in the "
"`restart_offset` list, which must not be empty. Readers can use "
"`restart_count` to binary search between restarts before starting a linear "
"scan."
msgstr "2 バイトの「restart_count」には、「restart_offset」リストのエントリ数が格納されます。このリストは空であってはなりません。 リーダーは、線形スキャンを開始する前に、「restart_count」を使用して再開区間(between restarts)で二分木検索を行うことができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:296
msgid ""
"Exactly `restart_count` 3-byte `restart_offset` values precedes the "
"`restart_count`. Offsets are relative to the start of the block and refer to "
"the first byte of any `ref_record` whose name has not been prefix "
"compressed. Entries in the `restart_offset` list must be sorted, ascending. "
"Readers can start linear scans from any of these records."
msgstr "正確に `restart_count` の 3 バイトの `restart_offset` 値が `restart_count` に先行します。 オフセットはブロックの開始からの相対であり、名前がプレフィックス圧縮されていない「ref_record」の最初のバイトを参照します。 `restart_offset` リストのエントリは、昇順で並べ替える必要があります。 リーダーは、これらのレコードのいずれかから線形スキャンを開始できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:299
msgid ""
"A variable number of `ref_record` fill the middle of the block, describing "
"reference names and values. The format is described below."
msgstr "可変数の「ref_record」がブロックの中央部を埋め、参照名と値を記述します。 形式は下記のとおりです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:304
msgid ""
"As the first ref block shares the first file block with the file header, all "
"`restart_offset` in the first block are relative to the start of the file "
"(position 0), and include the file header. This forces the first "
"`restart_offset` to be `28`."
msgstr "最初の ref ブロックは最初のファイル・ブロックをファイル・ヘッダーと共有するため、最初のブロックのすべての `restart_offset` はファイルの先頭 (位置 0) からの相対であり、ファイル・ヘッダーを含みます。 これにより、最初の「restart_offset」は強制的に「28」になります。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:306
#, no-wrap
msgid "ref record"
msgstr "ref record"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:310
msgid ""
"A `ref_record` describes a single reference, storing both the name and its "
"value(s). Records are formatted as:"
msgstr "`ref_record` は、名前とその値の両方を格納する単一の参照を記述します。各レコードは以下の形式です:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:317
#, no-wrap
msgid ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | value_type )\n"
"suffix\n"
"varint( update_index_delta )\n"
"value?\n"
msgstr ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | value_type )\n"
"suffix\n"
"varint( update_index_delta )\n"
"value?\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:324
msgid ""
"The `prefix_length` field specifies how many leading bytes of the prior "
"reference record's name should be copied to obtain this reference's name. "
"This must be 0 for the first reference in any block, and also must be 0 for "
"any `ref_record` whose offset is listed in the `restart_offset` table at the "
"end of the block."
msgstr "「prefix_length」フィールドは、この参照の名前を取得するために、前の参照レコードの名前の先頭の何バイトをコピーする必要があるかを指定します。 これは、任意のブロックの最初の参照では 0 でなければならず、ブロックの最後の `restart_offset` テーブルにオフセットがリストされているすべての `ref_record` についても 0 でなければなりません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:326
msgid "Recovering a reference name from any `ref_record` is a simple concat:"
msgstr "任意の `ref_record` から参照名を復元するのは単純な連結です:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:329
#, no-wrap
msgid "this_name = prior_name[0..prefix_length] + suffix\n"
msgstr "this_name = prior_name[0..prefix_length] + suffix\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:333
msgid ""
"The `suffix_length` value provides the number of bytes available in `suffix` "
"to copy from `suffix` to complete the reference name."
msgstr "`suffix_length` 値は、参照名を完成させるために `suffix` からコピーするために `suffix` で利用可能なバイト数を提供します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:337
msgid ""
"The `update_index` that last modified the reference can be obtained by "
"adding `update_index_delta` to the `min_update_index` from the file header: "
"`min_update_index + update_index_delta`."
msgstr "参照を最後に変更した `update_index` は、ファイル・ヘッダーの `min_update_index` に `update_index_delta` を追加することで取得できます: `min_update_index + update_index_delta`"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:340
msgid ""
"The `value` follows. Its format is determined by `value_type`, one of the "
"following:"
msgstr "「値」が続きます。 その形式は、以下のいずれかの「value_type」によって決まります:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:342
msgid "`0x0`: deletion; no value data (see transactions, below)"
msgstr "`0x0`: 削除。値データ無し(下記 transactions 参照)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:343
msgid "`0x1`: one object name; value of the ref"
msgstr "`0x1`: 1つのオブジェクト名。refの値"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:344
msgid "`0x2`: two object names; value of the ref, peeled target"
msgstr "`0x2`: 2つのオブジェクト名。refの値と皮むきされた(peeled)ターゲット"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:345
msgid "`0x3`: symbolic reference: `varint( target_len ) target`"
msgstr "`0x3`: シンボリック参照。 `varint( target_len ) target`"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:348
msgid ""
"Symbolic references use `0x3`, followed by the complete name of the "
"reference target. No compression is applied to the target name."
msgstr "シンボリック参照は `0x3` を使用し、その後に参照ターゲットの完全な名前が続きます。 ターゲット名に圧縮は適用されません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:350
msgid "Types `0x4..0x7` are reserved for future use."
msgstr "`0x4`〜`0x7` 将来の為に予約。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:352
#, no-wrap
msgid "Ref index"
msgstr "Ref index"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:358
msgid ""
"The ref index stores the name of the last reference from every ref block in "
"the file, enabling reduced disk seeks for lookups. Any reference can be "
"found by searching the index, identifying the containing block, and "
"searching within that block."
msgstr "ref インデックスは、ファイル内のすべての ref ブロックからの最後の参照の名前を格納し、検索(lookup)のためのディスク・シークを削減します。 インデックスを検索(search)し、それを含むブロックを特定し、そのブロック内を検索(search)することで、すべての参照を見つける(find)ことができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:369
msgid ""
"The index may be organized into a multi-level index, where the 1st level "
"index block points to additional ref index blocks (2nd level), which may in "
"turn point to either additional index blocks (e.g. 3rd level) or ref blocks "
"(leaf level). Disk reads required to access a ref go up with higher index "
"levels. Multi-level indexes may be required to ensure no single index block "
"exceeds the file format's max block size of `16777215` bytes (15.99 MiB). To "
"achieve constant O(1) disk seeks for lookups the index must be a single "
"level, which is permitted to exceed the file's configured block size, but "
"not the format's max block size of 15.99 MiB."
msgstr "インデックスは、マルチレベル・インデックスに編成することができます。この場合、第 1 レベルのインデックス・ブロックが追加の参照インデックス・ブロック(第2レベル)を指し、さらに追加のインデックス・ブロック (たとえば 第 3 レベル) または参照ブロック (リーフ レベル) を指す場合があります。 ref にアクセスするために必要なディスク読み取りの必要性は、インデックス・レベルが高いほど高くなります。 単一のインデックス・ブロックがファイル形式の最大ブロック サイズ「16777215」バイト (15.99 MiB) を超えないようにするために、複数レベルのインデックスが必要になる場合があります。 検索(lookup)のために一定の O(1) ディスク・シークを実現するには、インデックスは単一レベルである必要があります。これは、ファイルの構成されたブロック・サイズを超えることは許可されていますが、フォーマットの最大ブロック・サイズである 15.99 MiB を超えることは許可されていません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:371
msgid "If present, the ref index block(s) appears after the last ref block."
msgstr "もしあれば、refインデックス・ブロック(達)は最後のrefブロックの後に表れます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:376
msgid ""
"If there are at least 4 ref blocks, a ref index block should be written to "
"improve lookup times. Cold reads using the index require 2 disk reads (read "
"index, read block), and binary searching < 4 blocks also requires <= 2 "
"reads. Omitting the index block from smaller files saves space."
msgstr "少なくとも 4 つの ref ブロックがある場合は、検索(lookup)時間を改善するために ref インデックス・ブロックを書き込む必要があります。 インデックスを使用したコールド読み取りには 2 つのディスク読み取り (インデックス読み取りとブロック読み取り) が必要であり、また、4ブロック未満のバイナリ検索でもディスク読み取りが2回以下必要です。 小さいファイルからインデックス・ブロックを省略すると、スペースが節約されます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:379
msgid ""
"If the file is unaligned and contains more than one ref block, the ref index "
"must be written."
msgstr "ファイルが揃えられておらず、複数の ref ブロックが含まれている場合は、ref インデックスを書き込む必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:381
msgid "Index block format:"
msgstr "インデックス・ブロック形式:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:388
#, no-wrap
msgid ""
"'i'\n"
"uint24( block_len )\n"
"index_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"
msgstr ""
"'i'\n"
"uint24( block_len )\n"
"index_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:395
msgid ""
"The index blocks begin with `block_type = 'i'` and a 3-byte `block_len` "
"which encodes the number of bytes in the block, up to but not including the "
"optional `padding`."
msgstr "インデックス・ブロックは、`block_type = 'i'` で始まり、そして、ブロック内のバイト数をエンコードする 3 バイトの `block_len` は、オプションの「詰物」を含みません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:398
msgid ""
"The `restart_offset` and `restart_count` fields are identical in format, "
"meaning and usage as in ref blocks."
msgstr "`restart_offset` および `restart_count` フィールドの形式と意味と使用法は、 ref ブロックの場合と全く同じです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:403
msgid ""
"To reduce the number of reads required for random access in very large files "
"the index block may be larger than other blocks. However, readers must hold "
"the entire index in memory to benefit from this, so it's a time-space "
"tradeoff in both file size and reader memory."
msgstr "非常に大きなファイルのランダム・アクセスに必要な読み取り回数を減らすために、インデックス・ブロックは他のブロックよりも大きくなる場合があります。 ただし、これを利用するには、リーダーはインデックス全体をメモリに保持する必要があるため、ファイル・サイズとリーダー・メモリの両方で時間と空間のトレードオフになります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:408
msgid ""
"Increasing the file's block size decreases the index size. Alternatively a "
"multi-level index may be used, keeping index blocks within the file's block "
"size, but increasing the number of blocks that need to be accessed."
msgstr "ファイルのブロック・サイズを大きくすると、インデックス・サイズが小さくなります。 別の方法として、複数レベルのインデックスを使用して、インデックス・ブロックをファイルのブロック・サイズ内に保ちながら、アクセスする必要があるブロックの数を増やすこともできます。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:410
#, no-wrap
msgid "index record"
msgstr "index record"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:414
msgid ""
"An index record describes the last entry in another block. Index records are "
"written as:"
msgstr "インデックス・レコードは、別のブロックの最後のエントリを記述します。 インデックス・レコードは以下のとおり記述されます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:420
#, no-wrap
msgid ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | 0 )\n"
"suffix\n"
"varint( block_position )\n"
msgstr ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | 0 )\n"
"suffix\n"
"varint( block_position )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:423
msgid "Index records use prefix compression exactly like `ref_record`."
msgstr "インデックス・レコードは、`ref_record` と正確に同様にプレフィックス圧縮を使用します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:428
msgid ""
"Index records store `block_position` after the suffix, specifying the "
"absolute position in bytes (from the start of the file) of the block that "
"ends with this reference. Readers can seek to `block_position` to begin "
"reading the block header."
msgstr "インデックス・レコードは、サフィックスの後に「block_position」を格納し、この参照で終了するブロックの (ファイルの先頭からの) 絶対位置をバイト単位で指定します。 リーダーは「block_position」へシークして、ブロック・ヘッダーの読み取りを開始できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:432
msgid ""
"Readers must examine the block header at `block_position` to determine if "
"the next block is another level index block, or the leaf-level ref block."
msgstr "リーダーは、`block_position` のブロック・ヘッダーを調べて、次のブロックが別のレベルのインデックス・ブロックであるか、枝葉レベル(leaf-level)の ref ブロックであるかを判断する必要があります。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:434
#: ../Documentation-sedout/technical/reftable.txt:701
#, no-wrap
msgid "Reading the index"
msgstr "Reading the index"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:439
msgid ""
"Readers loading the ref index must first read the footer (below) to obtain "
"`ref_index_position`. If not present, the position will be 0. The "
"`ref_index_position` is for the 1st level root of the ref index."
msgstr "ref インデックスをロードするリーダーは、最初にフッター (下記) を読んで `ref_index_position` を取得する必要があります。 存在しない場合、位置は 0 になります。 `ref_index_position` は、ref インデックスの第 1 レベルのルート(root)用です。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:441
#, no-wrap
msgid "Obj block format"
msgstr "Obj block format"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:445
msgid ""
"Object blocks are optional. Writers may choose to omit object blocks, "
"especially if readers will not use the object name to ref mapping."
msgstr "オブジェクト・ブロックはオプションです。 ライターは、特にリーダーがrefマッピングにオブジェクト名を使用しない場合は、オブジェクト・ブロックを省略することを選択できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:451
msgid ""
"Object blocks use unique, abbreviated 2-32 object name keys, mapping to ref "
"blocks containing references pointing to that object directly, or as the "
"peeled value of an annotated tag. Like ref blocks, object blocks use the "
"file's standard block size. The abbreviation length is available in the "
"footer as `obj_id_len`."
msgstr "オブジェクト・ブロックは、 2 ～ 32 個の一意の短縮オブジェクト名キーを使用し、そのオブジェクトを直接指す参照を含む ref ブロックにマッピングするか、注釈付きタグの皮むきされた値(peeled value)としてマッピングします。 ref ブロックと同様に、オブジェクト・ブロックはファイルの標準ブロック・サイズを使用します。 省略形の長さは、フッターで `obj_id_len` として利用できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:456
msgid ""
"To save space in small files, object blocks may be omitted if the ref index "
"is not present, as brute force search will only need to read a few ref "
"blocks. When missing, readers should brute force a linear search of all "
"references to lookup by object name."
msgstr "小さなファイルのスペースを節約するために、ref インデックスが存在しない場合はオブジェクト・ブロックを省略できます。力づくで検索(brute force search)を行う場合はいくつかの ref ブロックを読み取るだけでよいためです。 欠落がある場合、リーダーは、オブジェクト名で検索(lookup)するすべての参照の線形検索を力ずくで実行する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:458
msgid "An object block is written as:"
msgstr "オブジェクト・ブロックは以下のとおり記述されます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:465
#, no-wrap
msgid ""
"'o'\n"
"uint24( block_len )\n"
"obj_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"
msgstr ""
"'o'\n"
"uint24( block_len )\n"
"obj_record+\n"
"uint24( restart_offset )+\n"
"uint16( restart_count )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:471
msgid ""
"Fields are identical to ref block. Binary search using the restart table "
"works the same as in reference blocks."
msgstr "フィールドは ref ブロックの場合と全く同じです。 再開表(restart table)を使用した二分木探索は、参照ブロックの場合と全く同一に機能します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:476
msgid ""
"Because object names are abbreviated by writers to the shortest unique "
"abbreviation within the reftable, obj key lengths have a variable length. "
"Their length must be at least 2 bytes. Readers must compare only for common "
"prefix match within an obj block or obj index."
msgstr "オブジェクト名はライターによって reftable 内の最も短い一意の略語に省略されるため、オブジェクト・キーの長さは可変長になります。 それらの長さは少なくとも 2 バイトでなければなりません。 リーダーは、オブジェクト・ブロックまたはオブジェクト・インデックス内の一般的なプレフィックスの一致についてのみ比較する必要があります。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:478
#, no-wrap
msgid "obj record"
msgstr "obj record"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:482
msgid ""
"An `obj_record` describes a single object abbreviation, and the blocks "
"containing references using that unique abbreviation:"
msgstr "`obj_record` は、単一のオブジェクトの略語と、その一意の略語を使用する参照を含むブロックを記述します:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:489
#, no-wrap
msgid ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | cnt_3 )\n"
"suffix\n"
"varint( cnt_large )?\n"
"varint( position_delta )*\n"
msgstr ""
"varint( prefix_length )\n"
"varint( (suffix_length << 3) | cnt_3 )\n"
"suffix\n"
"varint( cnt_large )?\n"
"varint( position_delta )*\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:496
msgid ""
"Like in reference blocks, abbreviations are prefix compressed within an obj "
"block. On large reftables with many unique objects, higher block sizes "
"(64k), and higher restart interval (128), a `prefix_length` of 2 or 3 and "
"`suffix_length` of 3 may be common in obj records (unique abbreviation of "
"5-6 raw bytes, 10-12 hex digits)."
msgstr "参照ブロックと同様に、省略形はオブジェクト・ブロック内でプレフィックス圧縮されます。 多くの一意のオブジェクトや、より大きなブロック・サイズ (64k)や、より長い再開間隔 (128) を持つ大きな reftable では、オブジェクト・レコード内では `prefix_length` の値は2または3で `suffix_length` の値は3が一般的です(5～6バイトである10～12桁の16進数の一意の省略形)。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:500
msgid ""
"Each record contains `position_count` number of positions for matching ref "
"blocks. For 1-7 positions the count is stored in `cnt_3`. When `cnt_3 = 0` "
"the actual count follows in a varint, `cnt_large`."
msgstr "各レコードには、一致する参照ブロックの位置の「position_count」数が含まれます。 1 ～ 7 の位置の場合、カウントは「cnt_3」に格納されます。 `cnt_3 = 0` の場合、実際のカウントは派生(varint) の `cnt_large` に続きます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:504
msgid ""
"The use of `cnt_3` bets most objects are pointed to by only a single "
"reference, some may be pointed to by a couple of references, and very few "
"(if any) are pointed to by more than 7 references."
msgstr "`cnt_3` の使用は、ほとんどのオブジェクトが 1 つの参照のみによって指されていること、いくつかのオブジェクトは 2 つの参照によって指されていること、および 7 つ以上の参照によって指されているオブジェクトは (存在するとしても) 非常に少ないことに賭けます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:512
msgid ""
"A special case exists when `cnt_3 = 0` and `cnt_large = 0`: there are no "
"`position_delta`, but at least one reference starts with this abbreviation. "
"A reader that needs exact reference names must scan all references to find "
"which specific references have the desired object.  Writers should use this "
"format when the `position_delta` list would have overflowed the file's block "
"size due to a high number of references pointing to the same object."
msgstr "`cnt_3 = 0` かつ `cnt_large = 0` である特殊なケースがあります: 「position_delta」はありませんが、少なくとも 1 つの参照がこの省略形で始まります。 正確な参照名が必要なリーダーは、すべての参照をスキャンして、目的のオブジェクトを持つ特定の参照を見つける必要があります。 ライターは、同じオブジェクトを指している多数の参照が原因で「position_delta」リストがファイルのブロック・サイズをオーバーフローした場合に、この形式を使用する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:516
msgid ""
"The first `position_delta` is the position from the start of the file.  "
"Additional `position_delta` entries are sorted ascending and relative to the "
"prior entry, e.g. a reader would perform:"
msgstr "最初の `position_delta` は、ファイルの先頭からの位置です。 追加の「position_delta」エントリは昇順で、前のエントリに対して相対的にソートされます。 リーダーは以下のことを実行します:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:524
#, no-wrap
msgid ""
"pos = position_delta[0]\n"
"prior = pos\n"
"for (j = 1; j < position_count; j++) {\n"
"  pos = prior + position_delta[j]\n"
"  prior = pos\n"
"}\n"
msgstr ""
"pos = position_delta[0]\n"
"prior = pos\n"
"for (j = 1; j < position_count; j++) {\n"
"  pos = prior + position_delta[j]\n"
"  prior = pos\n"
"}\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:532
msgid ""
"With a position in hand, a reader must linearly scan the ref block, starting "
"from the first `ref_record`, testing each reference's object names (for "
"`value_type = 0x1` or `0x2`) for full equality. Faster searching by object "
"name within a single ref block is not supported by the reftable format.  "
"Smaller block sizes reduce the number of candidates this step must consider."
msgstr "位置を取得したら、リーダーは最初の ref_record から開始して ref ブロックを直線的にスキャンし、各参照のオブジェクト名 ( `value_type` = `0x1` または `0x2` ) が完全に等しいかどうかをテストする必要があります。 単一の ref ブロック内のオブジェクト名による高速検索(searching)は、reftable 形式ではサポートされていません。 ブロック・サイズが小さいほど、このステップで考慮する必要がある候補の数が減ります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:534
#, no-wrap
msgid "Obj index"
msgstr "Obj index"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:539
msgid ""
"The obj index stores the abbreviation from the last entry for every obj "
"block in the file, enabling reduced disk seeks for all lookups. It is "
"formatted exactly the same as the ref index, but refers to obj blocks."
msgstr "オブジェクト・インデックスには、ファイル内のすべてのオブジェクト・ブロックの最後のエントリの省略形が格納され、すべての検索(lookup)でのディスク・シークが削減されます。それは ref インデックスと正確に同じフォーマットがなされますが、オブジェクト・ブロックを参照します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:542
msgid ""
"The obj index should be present if obj blocks are present, as obj blocks "
"should only be written in larger files."
msgstr "オブジェクト・ブロックはより大きなファイルにのみ書き込む必要があるため、オブジェクト・ブロックが存在する場合は、オブジェクト・インデックスが存在する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:545
msgid ""
"Readers loading the obj index must first read the footer (below) to obtain "
"`obj_index_position`. If not present, the position will be 0."
msgstr "オブジェクト・インデックスをロードするリーダーは、最初にフッター (下記) を読んで `obj_index_position` を取得する必要があります。 存在しない場合、位置は 0 になります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:547
#, no-wrap
msgid "Log block format"
msgstr "Log block format"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:550
msgid "Unlike ref and obj blocks, log blocks are always unaligned."
msgstr "ref ブロックや obj ブロックとは異なり、ログ ブロックは常に揃えられていません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:555
msgid ""
"Log blocks are variable in size, and do not match the `block_size` specified "
"in the file header or footer. Writers should choose an appropriate buffer "
"size to prepare a log block for deflation, such as `2 * block_size`."
msgstr "ログ・ブロックのサイズは可変であり、ファイル・ヘッダーまたはフッターで指定された「block_size」と一致しません。 ライターは、「2 * block_size」などの適切なバッファ・サイズを選択して、圧縮用のログ・ブロックを準備する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:557
msgid "A log block is written as:"
msgstr "ログ・ブロックは以下のとおり記述されます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:566
#, no-wrap
msgid ""
"'g'\n"
"uint24( block_len )\n"
"zlib_deflate {\n"
"  log_record+\n"
"  uint24( restart_offset )+\n"
"  uint16( restart_count )\n"
"}\n"
msgstr ""
"'g'\n"
"uint24( block_len )\n"
"zlib_deflate {\n"
"  log_record+\n"
"  uint24( restart_offset )+\n"
"  uint16( restart_count )\n"
"}\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:569
msgid "Log blocks look similar to ref blocks, except `block_type = 'g'`."
msgstr "ログ・ブロックは、`block_type = 'g'` を除いて、refブロックと似ています。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:575
msgid ""
"The 4-byte block header is followed by the deflated block contents using "
"zlib deflate. The `block_len` in the header is the inflated size (including "
"4-byte block header), and should be used by readers to preallocate the "
"inflation output buffer. A log block's `block_len` may exceed the file's "
"block size."
msgstr "4バイトのブロック・ヘッダーの後に、zlib圧縮を使用して圧縮されたブロックの内容が続きます。 ヘッダーの「block_len」は膨張したサイズ (4 バイトのブロック・ヘッダーを含む) であり、解凍出力バッファーを事前に割り当てるためにリーダーで使用する必要があります。 ログ・ブロックの「block_len」がファイルのブロック・サイズを超える場合があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:579
msgid ""
"Offsets within the log block (e.g. `restart_offset`) still include the 4-"
"byte header. Readers may prefer prefixing the inflation output buffer with "
"the 4-byte header."
msgstr "ログ・ブロック内のオフセット (「restart_offset」など) には、4 バイトのヘッダーがまだ含まれています。 リーダーは、解凍出力バッファーの前に 4 バイトのヘッダーをプレフィックスすることを好むかもしれません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:584
msgid ""
"Within the deflate container, a variable number of `log_record` describe "
"reference changes. The log record format is described below. See ref block "
"format (above) for a description of `restart_offset` and `restart_count`."
msgstr "圧縮コンテナー内では、可変数の「log_record」が参照の変更を記述します。 ログの記録形式は以下のとおりです。 `restart_offset` と `restart_count` の説明については、「ref block format」(ref ブロック形式)(上述) を参照してください。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:588
msgid ""
"Because log blocks have no alignment or padding between blocks, readers must "
"keep track of the bytes consumed by the inflater to know where the next log "
"block begins."
msgstr "ログ・ブロックにはブロック間の揃え幅(alignment)や詰物(padding)がないため、リーダーは次のログ・ブロックの開始位置を知るために、インフレータによって消費されるバイトを追跡する必要があります。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:590
#, no-wrap
msgid "log record"
msgstr "log record"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:593
msgid "Log record keys are structured as:"
msgstr "ログ・レコード・キーは以下のように構成(structure)されます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:596
#, no-wrap
msgid "ref_name '\\0' reverse_int64( update_index )\n"
msgstr "ref_name '\\0' reverse_int64( update_index )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:601
msgid ""
"where `update_index` is the unique transaction identifier. The "
"`update_index` field must be unique within the scope of a `ref_name`.  See "
"the update transactions section below for further details."
msgstr "ここで、「update_index」は一意の取引(transaction)IDです。 `update_index` フィールドは、 `ref_name` のスコープ内で一意である必要があります。 詳細については、下記「update transactions」(取引更新)セクションを参照してください。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:605
msgid ""
"The `reverse_int64` function inverses the value so lexicographical ordering "
"the network byte order encoding sorts the more recent records with higher "
"`update_index` values first:"
msgstr "`reverse_int64` 関数は値を反転するので、ネットワーク・バイト・オーダー・エンコーディングの辞書式順序付けは、より高い `update_index` 値を持つ新しいレコードが最初になるように並べ替えます:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:610
#, no-wrap
msgid ""
"reverse_int64(int64 t) {\n"
"  return 0xffffffffffffffff - t;\n"
"}\n"
msgstr ""
"reverse_int64(int64 t) {\n"
"  return 0xffffffffffffffff - t;\n"
"}\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:615
msgid ""
"Log records have a similar starting structure to ref and index records, "
"utilizing the same prefix compression scheme applied to the log record key "
"described above."
msgstr "ログ・レコードは、上記のログ・レコード・キーに適用されるのと同じプレフィックス圧縮方式を利用して、ref および index レコードと同様の開始構造(starting structure)を持っています。"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:629
#, no-wrap
msgid ""
"    varint( prefix_length )\n"
"    varint( (suffix_length << 3) | log_type )\n"
"    suffix\n"
"    log_data {\n"
"      old_id\n"
"      new_id\n"
"      varint( name_length    )  name\n"
"      varint( email_length   )  email\n"
"      varint( time_seconds )\n"
"      sint16( tz_offset )\n"
"      varint( message_length )  message\n"
"    }?\n"
msgstr ""
"    varint( prefix_length )\n"
"    varint( (suffix_length << 3) | log_type )\n"
"    suffix\n"
"    log_data {\n"
"      old_id\n"
"      new_id\n"
"      varint( name_length    )  name\n"
"      varint( email_length   )  email\n"
"      varint( time_seconds )\n"
"      sint16( tz_offset )\n"
"      varint( message_length )  message\n"
"    }?\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:632
msgid "Log record entries use `log_type` to indicate what follows:"
msgstr "ログ・レコード・エントリでは、 `log_type` を使用して、以下のことを示します:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:634
msgid "`0x0`: deletion; no log data."
msgstr "`0x0`: 削除。ログデータ無し。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:635
msgid "`0x1`: standard git reflog data using `log_data` above."
msgstr "`0x1`: 上記 `log_data` を使用した標準の git reflog データ。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:640
msgid ""
"The `log_type = 0x0` is mostly useful for `git stash drop`, removing an "
"entry from the reflog of `refs/stash` in a transaction file (below), without "
"needing to rewrite larger files. Readers reading a stack of reflogs must "
"treat this as a deletion."
msgstr "`log_type = 0x0` は、より大きなファイルを書き換える必要なく、取引ファイル(transaction file)(下記) の `refs/stash` の reflog からエントリを削除して、 `git stash drop` に最も役立ちます。 reflog のスタックを読み取るリーダーは、これを削除として扱う必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:643
msgid ""
"For `log_type = 0x1`, the `log_data` section follows linkgit:git-update-"
"ref[1] logging and includes:"
msgstr "「log_type = 0x1」の場合、「log_data」セクションは linkgit:git-update-ref[1] ロギングに従い、以下が含まれます:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:645
msgid "two object names (old id, new id)"
msgstr "2つのオブジェクト名(old id, new id)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:646
msgid "varint string of committer's name"
msgstr "コミッター名の派生文字列(varint string)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:647
msgid "varint string of committer's email"
msgstr "コミッターメールアドレスの派生文字列(varint string)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:648
msgid "varint time in seconds since epoch (Jan 1, 1970)"
msgstr "エポック(Jan 1, 1970)からの経過秒数による派生時間(varint time)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:649
msgid "2-byte timezone offset in minutes (signed)"
msgstr "2バイト。分単位のタイムゾーン・オフセット(signed)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:650
msgid "varint string of message"
msgstr "メッセージの派生文字列(varint string)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:654
msgid ""
"`tz_offset` is the absolute number of minutes from GMT the committer was at "
"the time of the update. For example `GMT-0800` is encoded in reftable as "
"`sint16(-480)` and `GMT+0230` is `sint16(150)`."
msgstr "`tz_offset` は、更新時にコミッターがいたタイムゾーンです(GMT からのオフセットで表される)。 たとえば、`GMT-0800` は reftable で `sint16(-480)` としてエンコードされ、`GMT+0230` は `sint16(150)` としてエンコードされます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:657
msgid ""
"The committer email does not contain `<` or `>`, it's the value normally "
"found between the `<>` in a git commit object header."
msgstr "コミッターの電子メールアドレスには `<` または `>` は含まれません。これは通常、git commit オブジェクト ヘッダーの `<>` の間にある値です。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:660
msgid ""
"The `message_length` may be 0, in which case there was no message supplied "
"for the update."
msgstr "`message_length` は 0 の場合があります。この場合、更新用のメッセージは提供されていません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:664
msgid ""
"Contrary to traditional reflog (which is a file), renames are encoded as a "
"combination of ref deletion and ref creation.  A deletion is a log record "
"with a zero new_id, and a creation is a log record with a zero old_id."
msgstr "従来の reflog (ファイル) とは対照的に、名前の変更は ref 削除と ref 作成の組み合わせとしてエンコードされます。 削除は new_id がゼロのログ・レコードであり、作成は old_id がゼロのログ・レコードです。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:666
#, no-wrap
msgid "Reading the log"
msgstr "Reading the log"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:672
msgid ""
"Readers accessing the log must first read the footer (below) to determine "
"the `log_position`. The first block of the log begins at `log_position` "
"bytes since the start of the file. The `log_position` is not block aligned."
msgstr "ログにアクセスするリーダーは、最初にフッター (下記) を読んで `log_position` を判断する必要があります。 ログの最初のブロックは、ファイルの先頭から `log_position` バイトで始まります。 `log_position` はブロック揃えになっていません。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:674
#, no-wrap
msgid "Importing logs"
msgstr "Importing logs"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:680
msgid ""
"When importing from `$GIT_DIR/logs` writers should globally order all log "
"records roughly by timestamp while preserving file order, and assign unique, "
"increasing `update_index` values for each log line. Newer log records get "
"higher `update_index` values."
msgstr "`$GIT_DIR/logs` からインポートする場合、ライターは、ファイルの順序を維持しながら、すべてのログ・レコードを大まかにタイムスタンプで並べ替え、ログ行ごとに一意の、増加する `update_index` 値を割り当てる必要があります。 新しいログ・レコードほど、「update_index」の値が大きくなります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:684
msgid ""
"Although an import may write only a single reftable file, the reftable file "
"must span many unique `update_index`, as each log line requires its own "
"`update_index` to preserve semantics."
msgstr "インポートは 1 つの reftable ファイルのみを書き込むことができますが、セマンティクスを維持するために各ログ行には独自の `update_index` が必要であるため、 reftable ファイルは多くの一意の `update_index` にまたがる必要があります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:686
#, no-wrap
msgid "Log index"
msgstr "Log index"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:691
msgid ""
"The log index stores the log key (`refname \\0 reverse_int64(update_index)`) "
"for the last log record of every log block in the file, supporting bounded-"
"time lookup."
msgstr "ログ・インデックスは、ファイル内のすべてのログ・ブロックの最後のログ・レコードのログ・キー (`refname \\0 reverse_int64(update_index)`) を格納し、制限時間検索(bounded-time lookup)をサポートします。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:695
msgid ""
"A log index block must be written if 2 or more log blocks are written to the "
"file. If present, the log index appears after the last log block.  There is "
"no padding used to align the log index to block alignment."
msgstr "2 つ以上のログ・ブロックがファイルに書き込まれる場合は、ログ・インデックス・ブロックを書き込む必要があります。 存在する場合、ログ・インデックスは最後のログ・ブロックの後に表れます。 ログ・インデックスをブロック揃え幅(alignment)に揃える(align)ために使用される詰物(padding)はありません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:699
msgid ""
"Log index format is identical to ref index, except the keys are 9 bytes "
"longer to include `'\\0'` and the 8-byte `reverse_int64(update_index)`.  "
"Records use `block_position` to refer to the start of a log block."
msgstr "ログ・インデックスの形式は ref インデックスと同じですが、`'\\0'` と 8 バイトの `reverse_int64(update_index)` を含めるためにキーが 9 バイト長くなります。 レコードは「block_position」を使用してログ・ブロック開始を参照します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:705
msgid ""
"Readers loading the log index must first read the footer (below) to obtain "
"`log_index_position`. If not present, the position will be 0."
msgstr "ログ・インデックスをロードするリーダーは、最初にフッター (下記) を読んで `log_index_position` を取得する必要があります。 存在しない場合、位置は 0 になります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:707
#, no-wrap
msgid "Footer"
msgstr "Footer"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:711
msgid ""
"After the last block of the file, a file footer is written. It begins like "
"the file header, but is extended with additional data."
msgstr "ファイルの最後のブロックの後ろに、ファイル・フッターが書き込まれます。 ファイル・ヘッダーのように始まりますが、追加のデータで拡張されています。"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:714
#, no-wrap
msgid "    HEADER\n"
msgstr "    HEADER\n"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:718
#, no-wrap
msgid ""
"    uint64( ref_index_position )\n"
"    uint64( (obj_position << 5) | obj_id_len )\n"
"    uint64( obj_index_position )\n"
msgstr ""
"    uint64( ref_index_position )\n"
"    uint64( (obj_position << 5) | obj_id_len )\n"
"    uint64( obj_index_position )\n"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:721
#, no-wrap
msgid ""
"    uint64( log_position )\n"
"    uint64( log_index_position )\n"
msgstr ""
"    uint64( log_position )\n"
"    uint64( log_index_position )\n"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:723
#, no-wrap
msgid "    uint32( CRC-32 of above )\n"
msgstr "    uint32( CRC-32 of above )\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:727
msgid ""
"If a section is missing (e.g. ref index) the corresponding position field (e."
"g. `ref_index_position`) will be 0."
msgstr "セクションが欠落している場合 (たとえば ref インデックス)、対応する位置フィールド (たとえば `ref_index_position`) は 0 になります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:729
msgid "`obj_position`: byte position for the first obj block."
msgstr "`obj_position`: 最初のオブジェクト・ブロックのバイト位置。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:731
msgid ""
"`obj_id_len`: number of bytes used to abbreviate object names in obj blocks."
msgstr "`obj_id_len`: オブジェクト・ブロック内の短縮オブジェクト名のために使用されるバイト数。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:732
msgid "`log_position`: byte position for the first log block."
msgstr "`log_position`: 最初のログ・ブロックのバイト位置。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:733
msgid "`ref_index_position`: byte position for the start of the ref index."
msgstr "`ref_index_position`: refインデクス開始のバイト位置。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:734
msgid "`obj_index_position`: byte position for the start of the obj index."
msgstr "`obj_index_position`: オブジェクト・インデックス開始のバイト位置。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:735
msgid "`log_index_position`: byte position for the start of the log index."
msgstr "`log_index_position`: ログ・インデックス開始のバイト位置。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:738
msgid ""
"The size of the footer is 68 bytes for version 1, and 72 bytes for version 2."
msgstr "フッターのサイズは、バージョン 1 で 68 バイト、バージョン 2 で 72 バイトです。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:740
#, no-wrap
msgid "Reading the footer"
msgstr "Reading the footer"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:746
msgid ""
"Readers must first read the file start to determine the version number. Then "
"they seek to `file_length - FOOTER_LENGTH` to access the footer. A trusted "
"external source (such as `stat(2)`) is necessary to obtain `file_length`. "
"When reading the footer, readers must verify:"
msgstr "リーダーは、最初にファイルの先頭を読んでバージョン番号を確認する必要があります。 次に、フッターにアクセスするために「file_length - FOOTER_LENGTH」を探します。 「file_length」を取得するには、信頼できる外部ソース (「stat(2)」など) が必要です。 フッターを読むとき、リーダー以下のことを確認する必要があります:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:748
msgid "4-byte magic is correct"
msgstr "4バイトのマジックが正しい"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:749
msgid "1-byte version number is recognized"
msgstr "1バイトのバージョン番号を認識"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:751
msgid "4-byte CRC-32 matches the other 64 bytes (including magic, and version)"
msgstr "4バイトのCRC-32 は他の 64 バイトと一致します(マジックとバージョンを含む)"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:753
msgid "Once verified, the other fields of the footer can be accessed."
msgstr "検証が完了すると、フッターの他のフィールドにアクセスできるようになります。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:755
#, no-wrap
msgid "Empty tables"
msgstr "Empty tables"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:759
msgid ""
"A reftable may be empty. In this case, the file starts with a header and is "
"immediately followed by a footer."
msgstr "reftable は空である可能性があります。 この場合、ファイルはヘッダーで始まり、すぐにフッターが続きます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:761
#, no-wrap
msgid "Binary search"
msgstr "Binary search"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:767
msgid ""
"Binary search within a block is supported by the `restart_offset` fields at "
"the end of the block. Readers can binary search through the restart table to "
"locate between which two restart points the sought reference or key should "
"appear."
msgstr "ブロック内の二分木検索は、ブロックの末尾にある「restart_offset」フィールドによってサポートされています。 リーダーは、再開表(restart table)を二分木検索して、探している参照またはキーがどの 2 つの再開点(restart points)の間に現れるかどうかを特定できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:771
msgid ""
"Each record identified by a `restart_offset` stores the complete key in the "
"`suffix` field of the record, making the compare operation during binary "
"search straightforward."
msgstr "`restart_offset` によって識別される各レコードは、レコードの `suffix` フィールドに完全なキーを格納し、バイナリ検索中の比較操作を簡単にします。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:776
msgid ""
"Once a restart point lexicographically before the sought reference has been "
"identified, readers can linearly scan through the following record entries "
"to locate the sought record, terminating if the current record sorts after "
"(and therefore the sought key is not present)."
msgstr "求められる参照より辞書的に前の再開点(restart point)が特定されると、リーダーは求められるレコードを見つけるために次のレコードエントリを線形にスキャンすることができ、現在のレコードがソート後であれば（したがって、求められるキーが存在しなければ）終了する。"

#. type: Title +
#: ../Documentation-sedout/technical/reftable.txt:778
#, no-wrap
msgid "Restart point selection"
msgstr "Restart point selection"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:784
msgid ""
"Writers determine the restart points at file creation. The process is "
"arbitrary, but every 16 or 64 records is recommended. Every 16 may be more "
"suitable for smaller block sizes (4k or 8k), every 64 for larger block sizes "
"(64k)."
msgstr "ライターは、ファイルの作成時に再開ポイントを決定します。 処理方法は任意ですが、16 または 64 レコードごとをお勧めします。 小さいブロック・サイズ (4k または 8k) には 16 ごと、大きいブロック・サイズ (64k) には 64 ごとが適している場合があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:787
msgid ""
"More frequent restart points reduces prefix compression and increases space "
"consumed by the restart table, both of which increase file size."
msgstr "再開点(restart points)の頻度が高くなると、プレフィックス圧縮が減少し、再開表(restart table)によって消費される領域が増加します。どちらもファイル・サイズが増加します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:791
msgid ""
"Less frequent restart points makes prefix compression more effective, "
"decreasing overall file size, with increased penalties for readers walking "
"through more records after the binary search step."
msgstr "再スタート・ポイントの頻度が低いと、プレフィックスの圧縮がより効果的になり、全体的なファイル・サイズが小さくなり、二分探索ステップの後でより多くのレコードを参照するリーダーのペナルティが増加します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:793
msgid "A maximum of `65535` restart points per block is supported."
msgstr "ブロックごとに最大「65535」の再スタート点がサポートされています。"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:795
#, no-wrap
msgid "Considerations"
msgstr "Considerations"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:798
#, no-wrap
msgid "Lightweight refs dominate"
msgstr "Lightweight refs dominate"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:804
msgid ""
"The reftable format assumes the vast majority of references are single "
"object names valued with common prefixes, such as Gerrit Code Review's `refs/"
"changes/` namespace, GitHub's `refs/pulls/` namespace, or many lightweight "
"tags in the `refs/tags/` namespace."
msgstr "reftable 形式は、参照の大部分が、 Gerrit Code Review の `refs/changes/` 名前空間、または GitHub の `refs/pulls/` 名前空間、または `refs/tags/` 名前空間です。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:807
msgid ""
"Annotated tags storing the peeled object cost an additional object name per "
"reference."
msgstr "皮剥きされた(peeled)オブジェクトを格納する注釈付きタグには、参照ごとに追加のオブジェクト名が必要です。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:809
#, no-wrap
msgid "Low overhead"
msgstr "Low overhead"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:814
msgid ""
"A reftable with very few references (e.g. git.git with 5 heads) is 269 bytes "
"for reftable, vs. 332 bytes for packed-refs. This supports reftable scaling "
"down for transaction logs (below)."
msgstr "参照がほとんどない reftable (例: 5 つのヘッドを持つ git.git) は、reftable で 269 バイト、packed-ref で 332 バイトです。 これにより、取引ログの参照可能なスケール・ダウンがサポートされます(下記参照)。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:822
msgid ""
"For a Gerrit Code Review type repository with many change refs, larger block "
"sizes (64 KiB) and less frequent restart points (every 64) yield better "
"compression due to more references within the block compressing against the "
"prior reference."
msgstr "多くの変更refがある Gerrit Code Review タイプのリポジトリの場合、ブロック・サイズが大きく (64 KiB)、再開点(restart points)再起動ポイントの頻度が低い (64 KiB ごと) ほどで、ブロック内の参照が前の参照に対して圧縮されるため、圧縮率が向上します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:825
msgid ""
"Larger block sizes reduce the index size, as the reftable will require fewer "
"blocks to store the same number of references."
msgstr "reftable が同じ数の参照を格納するために必要なブロックが少なくなるため、ブロック・サイズが大きくなるとインデックス・サイズが小さくなります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:827
#, no-wrap
msgid "Minimal disk seeks"
msgstr "Minimal disk seeks"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:832
msgid ""
"Assuming the index block has been loaded into memory, binary searching for "
"any single reference requires exactly 1 disk seek to load the containing "
"block."
msgstr "インデックス・ブロックがメモリに読み込まれていると仮定すると、任意の単一参照のバイナリ検索では、包含ブロックを読み込むためにちょうど 1 回のディスク・シークが必要です。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:834
#, no-wrap
msgid "Scans and lookups dominate"
msgstr "Scans and lookups dominate"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:839
msgid ""
"Scanning all references and lookup by name (or namespace such as `refs/heads/"
"`) are the most common activities performed on repositories.  Object names "
"are stored directly with references to optimize this use case."
msgstr "すべての参照を走査(scan)し、名前 (または「refs/heads/」などの名前空間) で検索(lookup)することは、リポジトリで実行される最も一般的なアクティビティです。 このユースケースを最適化するために、オブジェクト名は参照とともに直接保存されます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:841
#, no-wrap
msgid "Logs are infrequently read"
msgstr "Logs are infrequently read"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:845
msgid ""
"Logs are infrequently accessed, but can be large. Deflating log blocks saves "
"disk space, with some increased penalty at read time."
msgstr "ログはめったにアクセスされませんが、サイズが大きくなる可能性があります。 ログ・ブロックを圧縮すると、ディスク・スペースが節約されますが、読み取り時のペナルティがいくらか増加します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:849
msgid ""
"Logs are stored in an isolated section from refs, reducing the burden on "
"reference readers that want to ignore logs. Further, historical logs can be "
"isolated into log-only files."
msgstr "ログは ref から分離されたセクションに保存されるため、ログを無視したい参照リーダーの負担が軽減されます。 さらに、履歴ログをログのみのファイルに分離できます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:851
#, no-wrap
msgid "Logs are read backwards"
msgstr "Logs are read backwards"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:856
msgid ""
"Logs are frequently accessed backwards (most recent N records for master to "
"answer `master@{4}`), so log records are grouped by reference, and sorted "
"descending by update index."
msgstr "ログは頻繁に逆方向にアクセスされるため (master が `master@{4}` に応答する最新の N レコード)、ログ・レコードは参照によってグループ化され、更新インデックスによって降順に並べ替えられます。"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:858
#, no-wrap
msgid "Repository format"
msgstr "Repository format"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:861
#, no-wrap
msgid "Version 1"
msgstr "Version 1"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:864
msgid "A repository must set its `$GIT_DIR/config` to configure reftable:"
msgstr "reftable を設定するには、リポジトリで `$GIT_DIR/config` を設定する必要があります:"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:870
#, no-wrap
msgid ""
"[core]\n"
"    repositoryformatversion = 1\n"
"[extensions]\n"
"    refStorage = reftable\n"
msgstr ""
"[core]\n"
"    repositoryformatversion = 1\n"
"[extensions]\n"
"    refStorage = reftable\n"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:873
#, no-wrap
msgid "Layout"
msgstr "Layout"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:880
msgid ""
"A collection of reftable files are stored in the `$GIT_DIR/reftable/` "
"directory.  Their names should have a random element, such that each "
"filename is globally unique; this helps avoid spurious failures on Windows, "
"where open files cannot be removed or overwritten. It suggested to use `"
"${min_update_index}-${max_update_index}-${random}.ref` as a naming "
"convention."
msgstr "reftable ファイルのコレクションは `$GIT_DIR/reftable/` ディレクトリに保存されます。 それらの名前には、各ファイル名がグローバルに一意になるように、ランダムな要素を含める必要があります。 これにより、開いているファイルを削除または上書きできない Windows での誤ったエラーを回避できます。 その命名規則として `${min_update_index}-${max_update_index}-${random}.ref` を使用することが提案されました。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:883
msgid ""
"Log-only files use the `.log` extension, while ref-only and mixed ref and "
"log files use `.ref`. extension."
msgstr "ログのみのファイルは `.log` 拡張子を使用しますが、 ref のみのファイルや ref とログの混合ファイルは `.ref` 拡張子を使用します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:887
msgid ""
"The stack ordering file is `$GIT_DIR/reftable/tables.list` and lists the "
"current files, one per line, in order, from oldest (base) to newest (most "
"recent):"
msgstr "スタック順序付けファイルは `$GIT_DIR/reftable/tables.list` で、現在のファイルを 1 行に 1 つずつ、もっとも古いの (ベース) から最新 (最新) の順にリストします。"

#. type: delimited block .
#: ../Documentation-sedout/technical/reftable.txt:893
#, no-wrap
msgid ""
"$ cat .git/reftable/tables.list\n"
"00000001-00000001-RANDOM1.log\n"
"00000002-00000002-RANDOM2.ref\n"
"00000003-00000003-RANDOM3.ref\n"
msgstr ""
"$ cat .git/reftable/tables.list\n"
"00000001-00000001-RANDOM1.log\n"
"00000002-00000002-RANDOM2.ref\n"
"00000003-00000003-RANDOM3.ref\n"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:898
msgid ""
"Readers must read `$GIT_DIR/reftable/tables.list` to determine which files "
"are relevant right now, and search through the stack in reverse order (last "
"reftable is examined first)."
msgstr "リーダーは `$GIT_DIR/reftable/tables.list` を読んで現在どのファイルが関連しているかを判断し、逆の順序でスタックを検索(search)する必要があります (最後の reftable が最初に調べられます)。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:902
msgid ""
"Reftable files not listed in `tables.list` may be new (and about to be added "
"to the stack by the active writer), or ancient and ready to be pruned."
msgstr "`tables.list` にリストされていない reftable ファイルは、新しい (そして、アクティブなライターによってスタックに追加されようとしている) か、古くて刈り込みされる準備ができている可能性があります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:904
#, no-wrap
msgid "Backward compatibility"
msgstr "Backward compatibility"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:910
msgid ""
"Older clients should continue to recognize the directory as a git repository "
"so they don't look for an enclosing repository in parent directories. To "
"this end, a reftable-enabled repository must contain the following dummy "
"files"
msgstr "古いクライアントは、ディレクトリを git リポジトリとして認識し続ける必要があるため、親ディレクトリ内のエンクロージング・リポジトリを検索しません。 このため、reftable 対応のリポジトリには以下のダミー・ファイルが含まれている必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:912
msgid "`.git/HEAD`, a regular file containing `ref: refs/heads/.invalid`."
msgstr "`.git/HEAD` は、 `ref: refs/heads/.invalid` を含む通常のファイルです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:913
msgid "`.git/refs/`, a directory"
msgstr "`.git/refs/` はディレクトリです"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:914
msgid "`.git/refs/heads`, a regular file"
msgstr "`.git/refs/heads` は通常ファイルです"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:916
#, no-wrap
msgid "Readers"
msgstr "Readers"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:920
msgid ""
"Readers can obtain a consistent snapshot of the reference space by following:"
msgstr "リーダー(readers)は、以下の方法で参照空間(the reference space)の一貫したスナップショットを取得できます:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:922
msgid "Open and read the `tables.list` file."
msgstr "`tables.list` ファイルをオープンして読みとります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:923
msgid "Open each of the reftable files that it mentions."
msgstr "言及されている各reftableファイルをオープンします。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:924
msgid "If any of the files is missing, goto 1."
msgstr "いずれかのファイルが欠落している場合は、 goto 1"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:925
msgid "Read from the now-open files as long as necessary."
msgstr "現在開いているファイル群から必要なだけ読み取ります。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:927
#, no-wrap
msgid "Update transactions"
msgstr "Update transactions"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:931
msgid ""
"Although reftables are immutable, mutations are supported by writing a new "
"reftable and atomically appending it to the stack:"
msgstr "reftable は不変ですが、新しい reftable を作成し、アトミックにスタックに追加することで変更(mutation)がサポートされます:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:933
msgid "Acquire `tables.list.lock`."
msgstr "`tables.list.lock` を取得します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:934
msgid "Read `tables.list` to determine current reftables."
msgstr "現在の reftable を確認するには、 `tables.list` を読み取ります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:936
msgid "Select `update_index` to be most recent file's `max_update_index + 1`."
msgstr "最新のファイルの「max_update_index + 1」になるように「update_index」を選択します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:937
msgid "Prepare temp reftable `tmp_XXXXXX`, including log entries."
msgstr "ログ・エントリを含む一時 reftable `tmp_XXXXXX` を準備します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:938
msgid "Rename `tmp_XXXXXX` to `${update_index}-${update_index}-${random}.ref`."
msgstr "`tmp_XXXXXX` を `${update_index}-${update_index}-${random}.ref` に名前変更します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:939
msgid "Copy `tables.list` to `tables.list.lock`, appending file from (5)."
msgstr "`tables.list` を `tables.list.lock` にコピーし、(5) のファイルを追加します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:940
#: ../Documentation-sedout/technical/reftable.txt:994
msgid "Rename `tables.list.lock` to `tables.list`."
msgstr "`tables.list.lock` を `tables.list` に名前変更します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:946
msgid ""
"During step 4 the new file's `min_update_index` and `max_update_index` are "
"both set to the `update_index` selected by step 3. All log records for the "
"transaction use the same `update_index` in their keys. This enables later "
"correlation of which references were updated by the same transaction."
msgstr "ステップ 4 では、新しいファイルの `min_update_index` と `max_update_index` は両方とも、ステップ 3 で選択された `update_index` に設定されます。取引のすべてのログ・レコードは、それらのキーで同一の `update_index` を使用します。 これにより、同じ取引によってどの参照が更新されたかを後で関連付けることができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:954
msgid ""
"Because a single `tables.list.lock` file is used to manage locking, the "
"repository is single-threaded for writers. Writers may have to busy-spin "
"(with backoff) around creating `tables.list.lock`, for up to an acceptable "
"wait period, aborting if the repository is too busy to mutate. Application "
"servers wrapped around repositories (e.g. Gerrit Code Review) can layer "
"their own lock/wait queue to improve fairness to writers."
msgstr "単一の `tables.list.lock` ファイルがロックの管理に使用されるため、リポジトリはライター用のシングルスレッドです。 ライターは、許容可能な待機期間まで、 `tables.list.lock` の作成中に (バックオフを伴って) ビジースピンする必要がある場合があり、リポジトリが忙しすぎて変更できない場合は中止します。 リポジトリにラップされたアプリケーション・サーバー (Gerrit Code Review など) は、独自の ロック/待機 キューをレイヤー化して、ライターへの公平性を向上させることができます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:956
#, no-wrap
msgid "Reference deletions"
msgstr "Reference deletions"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:962
msgid ""
"Deletion of any reference can be explicitly stored by setting the `type` to "
"`0x0` and omitting the `value` field of the `ref_record`. This serves as a "
"tombstone, overriding any assertions about the existence of the reference "
"from earlier files in the stack."
msgstr "`type` を `0x0` に設定し、 `ref_record` の `value` フィールドを省略することにより、任意の参照の削除を明示的に保存できます。 これは、スタック内の以前のファイルからの参照の存在に関するアサーションをオーバーライドして、墓標(tombstone)として機能します。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:964
#, no-wrap
msgid "Compaction"
msgstr "Compaction"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:970
msgid ""
"A partial stack of reftables can be compacted by merging references using a "
"straightforward merge join across reftables, selecting the most recent value "
"for output, and omitting deleted references that do not appear in remaining, "
"lower reftables."
msgstr "reftable の部分的なスタックは、reftable 間で単純なマージ結合を使用して参照をマージし、出力用に最新の値を選択し、残りの下位の reftable に表示されない削除された参照を省略することで圧縮できます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:974
msgid ""
"A compacted reftable should set its `min_update_index` to the smallest of "
"the input files' `min_update_index`, and its `max_update_index` likewise to "
"the largest input `max_update_index`."
msgstr "圧縮された reftable は、その `min_update_index` を入力ファイル達の最小の `min_update_index` に設定し、同様にその `max_update_index` を入力ファイル達の最大の `max_update_index` に設定する必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:978
msgid ""
"For sake of illustration, assume the stack currently consists of reftable "
"files (from oldest to newest): A, B, C, and D. The compactor is going to "
"compact B and C, leaving A and D alone."
msgstr "説明のために、スタックが現在 reftable ファイル達 (古いものから新しいものへ) で構成されていると仮定します: A、B、C、および D です。圧縮器(compactor)は B と C を圧縮し、A と D だけを残します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:980
msgid "Obtain lock `tables.list.lock` and read the `tables.list` file."
msgstr "ロック `tables.list.lock` を取得し、そして、 `tables.list` ファイルを読み取ります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:982
msgid ""
"Obtain locks `B.lock` and `C.lock`. Ownership of these locks prevents other "
"processes from trying to compact these files."
msgstr "ロック「B.lock」と「C.lock」を取得します。 これらのロックの所有権により、他のプロセスがこれらのファイルを圧縮しようとするのを防ぎます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:983
msgid "Release `tables.list.lock`."
msgstr "`tables.list.lock` を開放(release)します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:985
msgid ""
"Compact `B` and `C` into a temp file `${min_update_index}-${max_update_index}"
"_XXXXXX`."
msgstr "`B` と `C` を一時ファイル `${min_update_index}-${max_update_index}_XXXXXX` に圧縮します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:986
msgid "Reacquire lock `tables.list.lock`."
msgstr "`tables.list.lock` のロックを取得します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:989
msgid ""
"Verify that `B` and `C` are still in the stack, in that order. This should "
"always be the case, assuming that other processes are adhering to the "
"locking protocol."
msgstr "`B` と `C` がこの順序でまだスタックにあることを確認(verify)します。 他のプロセスがロック・プロトコルに従っていると仮定すると、これは常に当てはまるはずです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:991
msgid ""
"Rename `${min_update_index}-${max_update_index}_XXXXXX` to `"
"${min_update_index}-${max_update_index}-${random}.ref`."
msgstr "`${min_update_index}-${max_update_index}_XXXXXX` を `${min_update_index}-${max_update_index}-${random}.ref` に名前変更します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:993
msgid ""
"Write the new stack to `tables.list.lock`, replacing `B` and `C` with the "
"file from (4)."
msgstr "新しいスタックを「tables.list.lock」に書き込み、「B」と「C」を (4) のファイルに置き換えます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:996
msgid ""
"Delete `B` and `C`, perhaps after a short sleep to avoid forcing readers to "
"backtrack."
msgstr "リーダーがバックトラック(backtrack)を強いられるのを避けるために、おそらく短いsleepの後、 `B` と `C` を削除します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:998
msgid "This strategy permits compactions to proceed independently of updates."
msgstr "この戦略により、更新とは無関係に圧縮を進めることができます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1001
msgid ""
"Each reftable (compacted or not) is uniquely identified by its name, so open "
"reftables can be cached by their name."
msgstr "各 reftable (圧縮されているかどうかに関係なく) はその名前で一意に識別されるため、開いている reftable はその名前でキャッシュできます。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:1003
#, no-wrap
msgid "Windows"
msgstr "Windows"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1008
msgid ""
"On windows, and other systems that do not allow deleting or renaming to open "
"files, compaction may succeed, but other readers may prevent obsolete tables "
"from being deleted."
msgstr "Windows や、ファイルを開くための削除や名前変更を許可しないその他のシステムでは、圧縮は成功する可能性がありますが、他のリーダーでは古いテーブルの削除が妨げられる場合があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1012
msgid ""
"On these platforms, the following strategy can be followed: on closing a "
"reftable stack, reload `tables.list`, and delete any tables no longer "
"mentioned in `tables.list`."
msgstr "これらのプラットフォームでは、次の戦略に従うことができます: reftable スタックを閉じて、 `tables.list` をリロードし、 `tables.list` で言及されなくなったテーブルを削除します。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1015
msgid ""
"Irregular program exit may still leave about unused files. In this case, a "
"cleanup operation should proceed as follows:"
msgstr "イレギュラーなプログラムの終了により、未使用のファイルが残る場合があります。 この場合、クリーンアップ操作は以下のように進める必要があります:"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1017
msgid "take a lock `tables.list.lock` to prevent concurrent modifications"
msgstr "並列変更を防ぐためにロック `tables.list.lock` を取得します"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1018
msgid "refresh the reftable stack, by reading `tables.list`"
msgstr "`tables.list` を読み取って、reftable スタックを更新(refresh)します"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1019
msgid "for each `*.ref` file, remove it if"
msgstr "各 `*.ref` ファイルごとに、以下の場合は削除します"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1020
msgid "it is not mentioned in `tables.list`, and"
msgstr "それは `tables.list` に記載されておらず、"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1021
msgid "its max update_index is not beyond the max update_index of the stack"
msgstr "かつ、その最大 update_index は、スタックの最大 update_index を超えていません"

#. type: Title ~
#: ../Documentation-sedout/technical/reftable.txt:1024
#, no-wrap
msgid "Alternatives considered"
msgstr "Alternatives considered"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:1027
#, no-wrap
msgid "bzip packed-refs"
msgstr "bzip packed-refs"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1033
msgid ""
"`bzip2` can significantly shrink a large packed-refs file (e.g. 62 MiB "
"compresses to 23 MiB, 37%). However the bzip format does not support random "
"access to a single reference. Readers must inflate and discard while "
"performing a linear scan."
msgstr "`bzip2` は、大きなパックされた参照ファイルを大幅に圧縮できます (たとえば、62 MiB は 23 MiB と、37% に圧縮されます)。 ただし、bzip 形式は、単一の参照へのランダム・アクセスをサポートしていません。 リーダーは、リニア・スキャン実行中、解凍と破棄を行う必要があります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1038
msgid ""
"Breaking packed-refs into chunks (individually compressing each chunk)  "
"would reduce the amount of data a reader must inflate, but still leaves the "
"problem of indexing chunks to support readers efficiently locating the "
"correct chunk."
msgstr "パックされた参照をチャンクに分割する (各チャンクを個別に圧縮する) と、リーダーが解凍しなければならないデータの量が減りますが、正しいチャンクを効率的に見つけるリーダーをサポートするために、チャンクにインデックスを付けるという問題が残ります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1041
msgid ""
"Given the compression achieved by reftable's encoding, it does not seem "
"necessary to add the complexity of bzip/gzip/zlib."
msgstr "reftable のエンコーディングによって達成される圧縮を考えると、 bzip/gzip/zlib の複雑さを追加する必要はないようです。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:1043
#, no-wrap
msgid "Michael Haggerty's alternate format"
msgstr "Michael Haggerty's alternate format"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1051
msgid ""
"Michael Haggerty proposed link:https://lore.kernel.org/git/"
"CAMy9T_HCnyc1g8XWOOWhe7nN0aEFyyBskV2aOMb_fe%2BwGvEJ7A%40mail.gmail.com/[an "
"alternate] format to reftable on the Git mailing list. This format uses "
"smaller chunks, without the restart table, and avoids block alignment with "
"padding. Reflog entries immediately follow each ref, and are thus "
"interleaved between refs."
msgstr "Michael Haggerty は、Git メーリング リストで link:https://lore.kernel.org/git/CAMy9T_HCnyc1g8XWOOWhe7nN0aEFyyBskV2aOMb_fe%2BwGvEJ7A%40mail.gmail.com/[an alternate] 形式を reftable に提案しました。 この形式は、再開表(restart table)なしでより小さいチャンクを使用し、詰物によるブロック揃えを回避します。 reflog エントリは各 ref の直後に続くため、ref 間に差し挟まれます。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1055
msgid ""
"Performance testing indicates reftable is faster for lookups (51% faster, "
"11.2 usec vs. 5.4 usec), although reftable produces a slightly larger file "
"(+ ~3.2%, 28.3M vs 29.2M):"
msgstr "性能テストでは、reftable の方が検索(lookup)より高速であることが示されています (51% 高速、11.2 usec 対 5.4 usec)。ただし、reftable はわずかに大きなファイルを生成します (+ ~3.2%、28.3M 対 29.2M):"

#. type: Table
#: ../Documentation-sedout/technical/reftable.txt:1061
#, no-wrap
msgid ""
"|format |size |seek cold |seek hot\n"
"|mh-alt |28.3 M |23.4 usec |11.2 usec\n"
"|reftable |29.2 M |19.9 usec |5.4 usec\n"
msgstr ""
"|format |size |seek cold |seek hot\n"
"|mh-alt |28.3 M |23.4 usec |11.2 usec\n"
"|reftable |29.2 M |19.9 usec |5.4 usec\n"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:1064
#, no-wrap
msgid "JGit Ketch RefTree"
msgstr "JGit Ketch RefTree"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1071
msgid ""
"https://dev.eclipse.org/mhonarc/lists/jgit-dev/msg03073.html[JGit Ketch] "
"proposed link:https://lore.kernel.org/git/CAJo"
"%3DhJvnAPNAdDcAAwAvU9C4RVeQdoS3Ev9WTguHx4fD0V_nOg%40mail.gmail.com/"
"[RefTree], an encoding of references inside Git tree objects stored as part "
"of the repository's object database."
msgstr "https://dev.eclipse.org/mhonarc/lists/jgit-dev/msg03073.html[JGit Ketch] は link:https://lore.kernel.org/git/CAJo%3DhJvnAPNAdDcAAwAvU9C4RVeQdoS3Ev9WTguHx4fD0V_nOg%40mail.gmail.com/[RefTree] を提案しました。 これは、リポジトリのオブジェクト・データベースの一部として格納された Git ツリー・オブジェクト内の参照のエンコーディングです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1078
msgid ""
"The RefTree format adds additional load on the object database storage layer "
"(more loose objects, more objects in packs), and relies heavily on the "
"packer's delta compression to save space. Namespaces which are flat (e.g. "
"thousands of tags in refs/tags) initially create very large loose objects, "
"and so RefTree does not address the problem of copying many references to "
"modify a handful."
msgstr "RefTree 形式は、オブジェクト・データベース・ストレージ層に追加の負荷を加え (より多くの緩いオブジェクト、より多くのパック内のオブジェクト)、スペースを節約するためにパッカーのデルタ圧縮に大きく依存しています。 フラットな名前空間 (例: refs/tags 内の数千のタグ) は、最初は非常に大きな緩いオブジェクトを作成するため、RefTree は多くの参照をコピーして一部を変更するという問題に対処しません。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1083
msgid ""
"Flat namespaces are not efficiently searchable in RefTree, as tree objects "
"in canonical formatting cannot be binary searched. This fails the need to "
"handle a large number of references in a single namespace, such as GitHub's "
"`refs/pulls`, or a project with many tags."
msgstr "フラットな名前空間は、RefTree では効率的に検索できません。標準的な形式のツリー・オブジェクトは二分木検索できないためです。 これは、GitHubの `refs/pulls` のような単一の名前空間で多数の参照を処理する必要性や、多くのタグを持つプロジェクトで失敗します。"

#. type: Title ^
#: ../Documentation-sedout/technical/reftable.txt:1085
#, no-wrap
msgid "LMDB"
msgstr "LMDB"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1091
msgid ""
"David Turner proposed https://lore.kernel.org/git/1455772670-21142-26-git-"
"send-email-dturner@twopensource.com/[using LMDB], as LMDB is lightweight "
"(64k of runtime code) and GPL-compatible license."
msgstr "David Turner は https://lore.kernel.org/git/1455772670-21142-26-git-send-email-dturner@twopensource.com/[using LMDB] を提案しました。これは、LMDB が軽量 (64k のランタイム コード) で、かつ、 GPL互換ライセンス であるためです。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1096
msgid ""
"A downside of LMDB is its reliance on a single C implementation. This makes "
"embedding inside JGit (a popular reimplementation of Git)  difficult, and "
"hoisting onto virtual storage (for JGit DFS) virtually impossible."
msgstr "LMDB の欠点は、単一の C 実装に依存していることです。 これにより、JGit (Git の一般的な再実装) 内への組み込みが困難になり、仮想ストレージ (JGit DFS 用) へのホスティングが事実上不可能になります。"

#. type: Plain text
#: ../Documentation-sedout/technical/reftable.txt:1098
msgid ""
"A common format that can be supported by all major Git implementations (git-"
"core, JGit, libgit2) is strongly preferred."
msgstr "すべての主要な Git 実装 (git-core、JGit、libgit2) でサポートできる共通の形式が強く推奨されます。"
