# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 3.0\n"
"POT-Creation-Date: 2023-08-04 05:27+0900\n"
"PO-Revision-Date: 2023-08-04 05:42+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# query-replace-regexp: \\\\{\([^}]*\)\\\\} → {\1}
#. type: Title -
#: ../Documentation-sedout/revisions.txt:2
#, no-wrap
msgid "SPECIFYING REVISIONS"
msgstr "SPECIFYING REVISIONS"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:9
msgid ""
"A revision parameter '<rev>' typically, but not necessarily, names a commit "
"object.  It uses what is called an 'extended SHA-1' syntax.  Here are "
"various ways to spell object names.  The ones listed near the end of this "
"list name trees and blobs contained in a commit."
msgstr ""
"リビジョンパラメータ `<rev>` は必ずしもそうとは限りませんが、通常はコミットオ"
"ブジェクトに名前を付けます。これは、いわゆる「拡張SHA-1」構文を使用します。 "
"オブジェクト名を綴るにはさまざまな方法があります。このリストの終わり近くにリ"
"ストされているものは、コミットに含まれているツリーとブロブに名前を付けていま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:13
msgid ""
"This document shows the \"raw\" syntax as seen by git. The shell and other "
"UIs might require additional quoting to protect special characters and to "
"avoid word splitting."
msgstr ""
"この文書は、gitで見られる「生の」構文を示しています。シェルおよびその他のUIで"
"は、特殊文字を保護し、単語の分割を回避するために、追加の引用符が必要になる場"
"合があります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:14
#, no-wrap
msgid "'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'"
msgstr "`<sha1>` 例: `dae86e1950b1277e545cee180551750029cfe735`, `dae86e`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:20
msgid ""
"The full SHA-1 object name (40-byte hexadecimal string), or a leading "
"substring that is unique within the repository.  E.g. "
"dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same "
"commit object if there is no other object in your repository whose object "
"name starts with dae86e."
msgstr ""
"完全なSHA-1オブジェクト名(40バイトの16進文字列)、またはリポジトリ内で一意の先"
"頭のsubstring。例えば dae86e1950b1277e545cee180551750029cfe735 と dae86e はど"
"ちらも、リポジトリ内にオブジェクト名が dae86e で始まる他のオブジェクトがない"
"場合、全く同じコミットオブジェクトに名前を付けます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:21
#, no-wrap
msgid "'<describeOutput>', e.g. 'v1.7.4.2-679-g3bee7fb'"
msgstr "`<describeOutput>` 例: `v1.7.4.2-679-g3bee7fb`"

# git describe の出力形式
# v1.7.4.2: そのコミットからさかのぼって最初に見つかるタグ名。
# 679: v1.7.4.2のタグ以降、当該コミットが何番目のコミットになるか。
# g3bee7fb: 先頭のgは、gitの略称。2文字目以降は当該コミットのID。
#. type: Plain text
#: ../Documentation-sedout/revisions.txt:25
msgid ""
"Output from `git describe`; i.e. a closest tag, optionally followed by a "
"dash and a number of commits, followed by a dash, a 'g', and an abbreviated "
"object name."
msgstr ""
"`git describe` からの出力。つまり、現在のコミットから最も近いタグ。オプション"
"で、ダッシュ(-)とそのタグ以降現在のコミットが何番目になるかの数が続き、その後"
"にダッシュ(-)、「g」、および省略されたオブジェクト名が続きます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:26
#, no-wrap
msgid "'<refname>', e.g. 'master', 'heads/master', 'refs/heads/master'"
msgstr "`<refname>` 例: `master`, `heads/master`, `refs/heads/master`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:33
msgid ""
"A symbolic ref name.  E.g. 'master' typically means the commit object "
"referenced by 'refs/heads/master'.  If you happen to have both 'heads/"
"master' and 'tags/master', you can explicitly say 'heads/master' to tell Git "
"which one you mean.  When ambiguous, a '<refname>' is disambiguated by "
"taking the first match in the following rules:"
msgstr ""
"シンボリックref名。例えば `master` は通常、 `refs/heads/master` によって参照"
"されるコミットオブジェクトを意味します。 `heads/master` と `tags/master` の両"
"方がある場合は、あなたは `heads/master` と明示的に指定して、どちらを意味する"
"かをGitに伝えることができます。 あいまいな場合、 `<refname>` は、以下のルール"
"での最初の一致を採用することにより明確になります:"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:38
msgid ""
"If '$GIT_DIR/<refname>' exists, that is what you mean (this is usually "
"useful only for `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, "
"`REBASE_HEAD`, `REVERT_HEAD`, `CHERRY_PICK_HEAD`, `BISECT_HEAD` and "
"`AUTO_MERGE`);"
msgstr ""
"もし `$GIT_DIR/<refname>` が存在するならば、それはあなたが指定した通りのもの"
"です(これは通常、 `HEAD` と `FETCH_HEAD` と `ORIG_HEAD` と `MERGE_HEAD` と "
"`REBASE_HEAD` と `REVERT_HEAD` と `CHERRY_PICK_HEAD` と `BISECT_HEAD` と "
"`AUTO_MERGE` のみで役に立ちます)"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:40
msgid "otherwise, 'refs/<refname>' if it exists;"
msgstr "でなければ `refs/<refname>` が存在すればそれを採用します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:42
msgid "otherwise, 'refs/tags/<refname>' if it exists;"
msgstr "でなければ `refs/tags/<refname>` が存在すればそれを採用します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:44
msgid "otherwise, 'refs/heads/<refname>' if it exists;"
msgstr "でなければ `refs/heads/<refname>` が存在すればそれを採用します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:46
msgid "otherwise, 'refs/remotes/<refname>' if it exists;"
msgstr "でなければ `refs/remotes/<refname>` が存在すればそれを採用します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:48
msgid "otherwise, 'refs/remotes/<refname>/HEAD' if it exists."
msgstr ""
"でなければ `refs/remotes/<refname>/HEAD` が存在すればそれを採用します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:50
#, no-wrap
msgid "`HEAD`"
msgstr "`HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:52
msgid "names the commit on which you based the changes in the working tree."
msgstr "作業ツリーの変更の基となったコミットの名前です。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:52
#, no-wrap
msgid "`FETCH_HEAD`"
msgstr "`FETCH_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:55
msgid ""
"records the branch which you fetched from a remote repository with your last "
"`git fetch` invocation."
msgstr ""
"最後の `git fetch` 呼び出しでリモート・リポジトリからフェッチしたブランチを記"
"録しています。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:55
#, no-wrap
msgid "`ORIG_HEAD`"
msgstr "`ORIG_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:60
msgid ""
"is created by commands that move your `HEAD` in a drastic way ( `git am`, "
"`git merge`, `git rebase`, `git reset`), to record the position of the "
"`HEAD` before their operation, so that you can easily change the tip of the "
"branch back to the state before you ran them."
msgstr ""
"これは、 `HEAD` を大幅に動かすコマンド (`git am` 、`git merge` 、`git "
"rebase` 、`git replace`) によって作成され、 これらのコマンド操作前の `HEAD` "
"の位置を記録します。 ブランチの先端を実行前の状態に簡単に戻すことができます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:60
#, no-wrap
msgid "`MERGE_HEAD`"
msgstr "`MERGE_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:63
msgid ""
"records the commit(s) which you are merging into your branch when you run "
"`git merge`."
msgstr ""
"`git merge` を実行するときにブランチにマージするコミットを記録しています。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:63
#, no-wrap
msgid "`REBASE_HEAD`"
msgstr "`REBASE_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:67
msgid ""
"during a rebase, records the commit at which the operation is currently "
"stopped, either because of conflicts or an `edit` command in an interactive "
"rebase."
msgstr "リベース中、 競合または対話型リベースの `edit` コマンドにより、現在操作が停止(stop)しているコミットを記録しています。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:67
#, no-wrap
msgid "`REVERT_HEAD`"
msgstr "`REVERT_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:69
msgid "records the commit which you are reverting when you run `git revert`."
msgstr "`git revert` を実行したときに元に戻すコミットを記録します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:69
#, no-wrap
msgid "`CHERRY_PICK_HEAD`"
msgstr "`CHERRY_PICK_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:72
msgid ""
"records the commit which you are cherry-picking when you run `git cherry-"
"pick`."
msgstr "`git Cherry-pick` を実行するときにチェリーピッキングしているコミットを記録します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:72
#, no-wrap
msgid "`BISECT_HEAD`"
msgstr "`BISECT_HEAD`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:75
msgid ""
"records the current commit to be tested when you run `git bisect --no-"
"checkout`."
msgstr "`git bisect --no-checkout` の実行中、現在テスト対象のコミットを記録しています。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:75
#, no-wrap
msgid "`AUTO_MERGE`"
msgstr "`AUTO_MERGE`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:79
msgid ""
"records a tree object corresponding to the state the 'ort' merge strategy "
"wrote to the working tree when a merge operation resulted in conflicts."
msgstr "マージ操作で競合が発生した場合に、 「ort」マージ戦略が作業ツリーに書き込んだ状態に対応する、 ツリー・オブジェクトを記録します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:85
msgid ""
"Note that any of the 'refs/*' cases above may come either from the `$GIT_DIR/"
"refs` directory or from the `$GIT_DIR/packed-refs` file.  While the ref name "
"encoding is unspecified, UTF-8 is preferred as some output processing may "
"assume ref names in UTF-8."
msgstr ""
"注意: 上記の `refs/*` の場合、 `$GIT_DIR/refs` ディレクトリまたは `$GIT_DIR/"
"packed-refs` ファイルのいずれかから発生する可能性があることに注意してくださ"
"い。ref名のエンコードは指定されていませんが、一部の出力処理ではUTF-8でref名を"
"想定する場合があるため、UTF-8が推奨されます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:86
#, no-wrap
msgid "'@'"
msgstr "`@`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:88
msgid "'@' alone is a shortcut for `HEAD`."
msgstr "`@` 単独では `HEAD` のショートカットを意味します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:89
#, no-wrap
msgid "'[<refname>]@{<date>}', e.g. 'master@\\{yesterday\\}', 'HEAD@{5 minutes ago}'"
msgstr "`[<refname>]@{<date>}` 例: `master@{yesterday}`, `HEAD@{5 minutes ago}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:100
msgid ""
"A ref followed by the suffix '@' with a date specification enclosed in a "
"brace pair (e.g. '\\{yesterday\\}', '{1 month 2 weeks 3 days 1 hour 1 second "
"ago}' or '{1979-02-26 18:30:00}') specifies the value of the ref at a prior "
"point in time.  This suffix may only be used immediately following a ref "
"name and the ref must have an existing log ('$GIT_DIR/logs/<ref>'). Note "
"that this looks up the state of your *local* ref at a given time; e.g., what "
"was in your local 'master' branch last week. If you want to look at commits "
"made during certain times, see `--since` and `--until`."
msgstr ""
"refの後に接尾辞 `@` が続き、日付指定が中括弧のペアで囲まれています(例: "
"`{yesterday}` 、 `{1 month 2 weeks 3 days 1 hour 1 second ago}` 、"
"`{1979-02-26 18:30:00}` )。これは以前の時点でのrefの値を指定します。この接尾"
"辞は、ref名の直後にのみ使用でき、refには既存のログ( `$GIT_DIR/logs/<ref>` )が"
"必要です。これは、特定の時点での *ローカル* refの状態を検索することに注意して"
"ください。たとえば、先週ローカルの `master` ブランチに何があったか、です。特"
"定の時間に行われたコミットを確認する場合は、 `--since` と `--until` を参照し"
"てください。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:101
#, no-wrap
msgid "'<refname>@{<n>}', e.g. 'master@\\{1\\}'"
msgstr "`<refname>@{<n>}` 例: `master@{1}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:109
msgid ""
"A ref followed by the suffix '@' with an ordinal specification enclosed in a "
"brace pair (e.g. '\\{1\\}', '\\{15\\}') specifies the n-th prior value of "
"that ref.  For example 'master@\\{1\\}' is the immediate prior value of "
"'master' while 'master@\\{5\\}' is the 5th prior value of 'master'. This "
"suffix may only be used immediately following a ref name and the ref must "
"have an existing log ('$GIT_DIR/logs/<refname>')."
msgstr ""
"refの後に接尾辞 `@` が続き、数の指定が中括弧のペアで囲まれている場合(たとえ"
"ば `{1}`, `{15}`)、そのrefのn個前の値を指定します。たとえば `master@{1}` は "
"`master` の直前の値であり、 `master@{5}` は `master` の5個前の値です。この接"
"頭辞は、ref名の直後にのみ使用でき、refには既存のログ( `$GIT_DIR/logs/"
"<refname>` )が必要です。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:110
#, no-wrap
msgid "'@{<n>}', e.g. '@\\{1\\}'"
msgstr "`@{<n>}` 例: `@{1}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:114
msgid ""
"You can use the '@' construct with an empty ref part to get at a reflog "
"entry of the current branch. For example, if you are on branch 'blabla' then "
"'@\\{1\\}' means the same as 'blabla@\\{1\\}'."
msgstr ""
"空のref部分で `@` コンストラクトを使用して、現在のブランチのreflogエントリを"
"取得できます。たとえば、あなたがブランチ `blabla` を使用している場合、 `@{1}"
"` は `blabla@{1}` と同じ意味になります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:115
#, no-wrap
msgid "'@{-<n>}', e.g. '@{-1}'"
msgstr "`@{-<n>}` 例: `@{-1}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:118
msgid ""
"The construct '@{-<n>}' means the <n>th branch/commit checked out before the "
"current one."
msgstr ""
"構成 `@{-<n>}` は、現在のブランチ/コミットの前にチェックアウトされた<n>番目の"
"ブランチ/コミットを意味します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:119
#, no-wrap
msgid "'[<branchname>]@\\{upstream\\}', e.g. 'master@\\{upstream\\}', '@\\{u\\}'"
msgstr "`[<branchname>]@{upstream}` 例: `master@{upstream}`, `@{u}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:124
msgid ""
"A branch B may be set up to build on top of a branch X (configured with "
"`branch.<name>.merge`) at a remote R (configured with `branch.<name>."
"remote`). B@{u} refers to the remote-tracking branch for the branch X taken "
"from remote R, typically found at `refs/remotes/R/X`."
msgstr ""
"ブランチ B は、 リモート R (`branch.<name>.remote` で構成)で、ブランチ X "
"(`branch.<name>.merge` で構成)の上に構築するようにセットアップできます。 "
"`B@{u}` は、リモート R から取られたブランチ X のリモート追跡ブランチを参照"
"し、 通常は `refs/remotes/R/X` にあります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:125
#, no-wrap
msgid "'[<branchname>]@\\{push\\}', e.g. 'master@\\{push\\}', '@\\{push\\}'"
msgstr "`[<branchname>]@{push}` 例: `master@{push}`, `@{push}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:130
msgid ""
"The suffix '@\\{push}' reports the branch \"where we would push to\" if `git "
"push` were run while `branchname` was checked out (or the current `HEAD` if "
"no branchname is specified). Like for '@\\{upstream\\}', we report the "
"remote-tracking branch that corresponds to that branch at the remote."
msgstr ""
"接尾辞 `@\\{push}` は、 `branchname` がチェックアウトされているときに `git "
"push` が実行された場合(またはブランチ名が指定されていない場合は現在の "
"`HEAD` )、「プッシュ先」のブランチを報告します。 `@\\{upstream\\}` の場合と同"
"様に、リモートのブランチに対応するリモート・トラッキング・ブランチを報告しま"
"す。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:132
msgid "Here's an example to make it more clear:"
msgstr "ここで、よりはっきり分かる例を以下に示します:"

#. type: delimited block -
#: ../Documentation-sedout/revisions.txt:137
#, no-wrap
msgid ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"
msgstr ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"

#. type: delimited block -
#: ../Documentation-sedout/revisions.txt:140
#, no-wrap
msgid ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"

#. type: delimited block -
#: ../Documentation-sedout/revisions.txt:143
#, no-wrap
msgid ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:148
msgid ""
"Note in the example that we set up a triangular workflow, where we pull from "
"one location and push to another. In a non-triangular workflow, '@\\{push}' "
"is the same as '@\\{upstream}', and there is no need for it."
msgstr ""
"注意: この例では、ある場所からプルして別の場所にプッシュする三角形のワークフ"
"ローを設定していることに注意してください。非三角形のワークフローでは、 "
"`@\\{push}` は `@\\{upstream}` と同じであり、このようなことをする必要はありま"
"せん。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:151
msgid ""
"This suffix is also accepted when spelled in uppercase, and means the same "
"thing no matter the case."
msgstr ""
"この接尾辞は大文字で綴る場合にも受け入れられ、大文字と小文字を問わず同じこと"
"を意味します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:152
#, no-wrap
msgid "'<rev>{caret}[<n>]', e.g. 'HEAD{caret}, v1.5.1{caret}0'"
msgstr "`<rev>^[<n>]` 例: `HEAD^, v1.5.1^0`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:159
msgid ""
"A suffix '{caret}' to a revision parameter means the first parent of that "
"commit object.  '{caret}<n>' means the <n>th parent (i.e.  '<rev>{caret}' is "
"equivalent to '<rev>{caret}1').  As a special rule, '<rev>{caret}0' means "
"the commit itself and is used when '<rev>' is the object name of a tag "
"object that refers to a commit object."
msgstr ""
"リビジョンパラメータの接尾辞 `^` は、そのコミットオブジェクトの最初の親を意味"
"します。 `^<n>` は <n> 番目の親を意味します(つまり、 `<rev>^` は `<rev>^1` と"
"同じです)。特別ルールとして、 `<rev>^0` はコミット自体を意味し、 `<rev>` がコ"
"ミットオブジェクトを参照するタグオブジェクトのオブジェクト名である場合に使用"
"されます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:160
#, no-wrap
msgid "'<rev>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'"
msgstr "`<rev>~[<n>]` 例: `HEAD~, master~3`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:169
msgid ""
"A suffix '{tilde}' to a revision parameter means the first parent of that "
"commit object.  A suffix '{tilde}<n>' to a revision parameter means the "
"commit object that is the <n>th generation ancestor of the named commit "
"object, following only the first parents.  I.e. '<rev>{tilde}3' is "
"equivalent to '<rev>{caret}{caret}{caret}' which is equivalent to "
"'<rev>{caret}1{caret}1{caret}1'.  See below for an illustration of the usage "
"of this form."
msgstr ""
"リビジョンパラメータの接尾辞 `~` は、そのコミットオブジェクトの最初の親を意味"
"します。リビジョンパラメータの接尾辞 `~<n>` は、最初の親のみに続く、指定され"
"たコミットオブジェクトの <n> 世代の祖先であるコミットオブジェクトを意味しま"
"す。つまり、 `<rev>~3` は `<rev>^^^` と同じで、するってぇと `<rev>^1^1^1` と"
"同じということです。この形式については以下の図を参照してください。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:170
#, no-wrap
msgid "'<rev>{caret}{<type>}', e.g. 'v0.99.8{caret}\\{commit\\}'"
msgstr "`<rev>^{<type>}` 例: `v0.99.8^{commit}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:181
msgid ""
"A suffix '{caret}' followed by an object type name enclosed in brace pair "
"means dereference the object at '<rev>' recursively until an object of type "
"'<type>' is found or the object cannot be dereferenced anymore (in which "
"case, barf).  For example, if '<rev>' is a commit-ish, "
"'<rev>{caret}\\{commit\\}' describes the corresponding commit object.  "
"Similarly, if '<rev>' is a tree-ish, '<rev>{caret}\\{tree\\}' describes the "
"corresponding tree object.  '<rev>{caret}0' is a short-hand for "
"'<rev>{caret}\\{commit\\}'."
msgstr ""
"接尾辞 `^` の後に中括弧のペアで囲まれたオブジェクトタイプ名が続くということ"
"は、タイプ `<type>` のオブジェクトが見つかるか、オブジェクトを逆参照できなく"
"なるまで、 `<rev>` でオブジェクトを再帰的に逆参照する(この場合は、いろいろ一"
"旦飲み込んでしまったのを吐きもどすような感じだぬ)ことを意味します。 たとえ"
"ば、 `<rev>` がコミットっぽい場合、 `<rev>^{commit}` は対応するコミットオブ"
"ジェクトを記述します。同様に、 `<rev>` がツリーっぽい場合、 `<rev>^{tree}` は"
"対応するツリーオブジェクトを記述します。 `<rev>^0` は `<rev>^{commit}` の省略"
"形です。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:186
msgid ""
"'<rev>{caret}\\{object\\}' can be used to make sure '<rev>' names an object "
"that exists, without requiring '<rev>' to be a tag, and without "
"dereferencing '<rev>'; because a tag is already an object, it does not have "
"to be dereferenced even once to get to an object."
msgstr ""
"`<rev>^{object}` を使用すると、 `<rev>` がタグである必要がなく、 `<rev>` を逆"
"参照することなく、 `<rev>` が存在するオブジェクトに名前を付けることができま"
"す。なお、タグはすでにオブジェクトであるため、オブジェクトに到達するために一"
"度も逆参照する必要はありません。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:189
msgid ""
"'<rev>{caret}\\{tag\\}' can be used to ensure that '<rev>' identifies an "
"existing tag object."
msgstr ""
"`<rev>^{tag}` を使用して、 `<rev>` が既存のタグオブジェクトを確実に識別するこ"
"とができます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:190
#, no-wrap
msgid "'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'"
msgstr "`<rev>^{}` 例: `v0.99.8^{}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:195
msgid ""
"A suffix '{caret}' followed by an empty brace pair means the object could be "
"a tag, and dereference the tag recursively until a non-tag object is found."
msgstr ""
"接尾辞 `^` の後に空のブレースペアが続くということは、オブジェクトがタグである"
"可能性があることを意味し、タグ以外のオブジェクトが見つかるまでタグを再帰的に"
"逆参照します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:196
#, no-wrap
msgid "'<rev>{caret}{/<text>}', e.g. 'HEAD^{/fix nasty bug}'"
msgstr "`<rev>^{/<text>}` 例: `HEAD^{/fix nasty bug}`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:202
msgid ""
"A suffix '{caret}' to a revision parameter, followed by a brace pair that "
"contains a text led by a slash, is the same as the ':/fix nasty bug' syntax "
"below except that it returns the youngest matching commit which is reachable "
"from the '<rev>' before '{caret}'."
msgstr ""
"リビジョンパラメータの接尾辞 `^` と、それに続くスラッシュで始まるテキストを含"
"む中括弧のペアは、以下の `:/fix nasty bug` 構文と同じですが、 `^` の前の "
"`<rev>` から到達可能な一致する最も若いコミットを返す点が異なります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:203
#, no-wrap
msgid "':/<text>', e.g. ':/fix nasty bug'"
msgstr "`:/<text>` 例: `:/fix nasty bug`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:216
msgid ""
"A colon, followed by a slash, followed by a text, names a commit whose "
"commit message matches the specified regular expression.  This name returns "
"the youngest matching commit which is reachable from any ref, including "
"HEAD.  The regular expression can match any part of the commit message. To "
"match messages starting with a string, one can use e.g. ':/^foo'. The "
"special sequence ':/!' is reserved for modifiers to what is matched. ':/!-"
"foo' performs a negative match, while ':/!!foo' matches a literal '!' "
"character, followed by 'foo'. Any other sequence beginning with ':/!' is "
"reserved for now.  Depending on the given text, the shell's word splitting "
"rules might require additional quoting."
msgstr ""
"コロンに続いてスラッシュそしてそれに続くテキストは、コミットメッセージが指定"
"された正規表現と一致するコミットを示します。この名前は、HEADを含む任意のrefか"
"ら到達可能な最も若い一致するコミットを返します。正規表現は、コミットメッセー"
"ジの任意の部分に一致できます。文字列で始まるメッセージを照合するには、たとえ"
"ば、 `:/^foo` とします。特別なシーケンス `:/!` はマッチングの修飾子用に予約さ"
"れています。ます。 `:/!-foo` は一致の否定を実行し、 `:/!!foo` はリテラル `!` "
"後に `foo` が続く文字列とマッチします。 `:/!` で始まるその他のシーケンスは今"
"のところ予約されています。指定されたテキストによっては、シェルにより追加の引"
"用符が必要になる場合があります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:217
#, no-wrap
msgid "'<rev>:<path>', e.g. 'HEAD:README', 'master:./README'"
msgstr "`<rev>:<path>` 例: `HEAD:README`, `master:./README`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:225
msgid ""
"A suffix ':' followed by a path names the blob or tree at the given path in "
"the tree-ish object named by the part before the colon.  A path starting "
"with './' or '../' is relative to the current working directory.  The given "
"path will be converted to be relative to the working tree's root directory.  "
"This is most useful to address a blob or tree from a commit or tree that has "
"the same tree structure as the working tree."
msgstr ""
"接尾辞 `:` の後にパス(path)を続けると、コロンの前の部分によって名前が付けられ"
"たツリー風のオブジェクト内の、指定されたパスにあるブロブまたはツリーに名前が"
"付けられます。 `./` または `../` で始まるパスは、現在の作業ディレクトリからの"
"相対パスです。指定のパスは、作業ツリーのルートディレクトリからの相対パスに変"
"換されます。これは、作業ツリーと同じツリー構造を持つコミットまたはツリーから"
"ブロブまたはツリーをアドレス指定するのに最も役立ちます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:226
#, no-wrap
msgid "':[<n>:]<path>', e.g. ':0:README', ':README'"
msgstr "`:[<n>:]<path>` 例: `:0:README`, `:README`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:234
msgid ""
"A colon, optionally followed by a stage number (0 to 3) and a colon, "
"followed by a path, names a blob object in the index at the given path. A "
"missing stage number (and the colon that follows it) names a stage 0 entry. "
"During a merge, stage 1 is the common ancestor, stage 2 is the target "
"branch's version (typically the current branch), and stage 3 is the version "
"from the branch which is being merged."
msgstr ""
"コロンに、オプションでステージ番号(0〜3)とコロンが続き、それにパスが続くと、"
"指定されたパスのインデックス内のブロブオブジェクトに名前を付けます。ステージ"
"番号省略(およびそれに続くコロン)は、ステージ0エントリーを示します。マージ作業"
"中、ステージ1は共通の祖先、ステージ2はターゲットブランチのバージョン(通常は現"
"在のブランチ)、ステージ3はマージされるブランチのバージョンです。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:238
msgid ""
"Here is an illustration, by Jon Loeliger.  Both commit nodes B and C are "
"parents of commit node A.  Parent commits are ordered left-to-right."
msgstr ""
"以下はJon Loeligerによる図解です。コミットノードBとCはどちらもコミットノードA"
"の親です。親コミットは左から右に順序付けられます。"

#. type: delimited block .
#: ../Documentation-sedout/revisions.txt:250
#, no-wrap
msgid ""
"G   H   I   J\n"
" \\ /     \\ /\n"
"  D   E   F\n"
"   \\  |  / \\\n"
"    \\ | /   |\n"
"     \\|/    |\n"
"      B     C\n"
"       \\   /\n"
"        \\ /\n"
"         A\n"
msgstr ""
"G   H   I   J\n"
" \\ /     \\ /\n"
"  D   E   F\n"
"   \\  |  / \\\n"
"    \\ | /   |\n"
"     \\|/    |\n"
"      B     C\n"
"       \\   /\n"
"        \\ /\n"
"         A\n"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:262
#, no-wrap
msgid ""
"    A =      = A^0\n"
"    B = A^   = A^1     = A~1\n"
"    C =      = A^2\n"
"    D = A^^  = A^1^1   = A~2\n"
"    E = B^2  = A^^2\n"
"    F = B^3  = A^^3\n"
"    G = A^^^ = A^1^1^1 = A~3\n"
"    H = D^2  = B^^2    = A^^^2  = A~2^2\n"
"    I = F^   = B^3^    = A^^3^\n"
"    J = F^2  = B^3^2   = A^^3^2\n"
msgstr ""
"    A =      = A^0\n"
"    B = A^   = A^1     = A~1\n"
"    C =      = A^2\n"
"    D = A^^  = A^1^1   = A~2\n"
"    E = B^2  = A^^2\n"
"    F = B^3  = A^^3\n"
"    G = A^^^ = A^1^1^1 = A~3\n"
"    H = D^2  = B^^2    = A^^^2  = A~2^2\n"
"    I = F^   = B^3^    = A^^3^\n"
"    J = F^2  = B^3^2   = A^^3^2\n"

#. type: Title -
#: ../Documentation-sedout/revisions.txt:265
#, no-wrap
msgid "SPECIFYING RANGES"
msgstr "SPECIFYING RANGES"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:269
msgid ""
"History traversing commands such as `git log` operate on a set of commits, "
"not just a single commit."
msgstr ""
"`git log` などの履歴トラバースコマンドは、単一のコミットだけでなく、一連のコ"
"ミットで動作します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:274
msgid ""
"For these commands, specifying a single revision, using the notation "
"described in the previous section, means the set of commits `reachable` from "
"the given commit."
msgstr ""
"これらのコマンドの場合、前のセクションで説明した表記法を使用して単一のリビ"
"ジョンを指定することは、指定のコミットから「到達可能」なコミットの組を意味し"
"ます。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:277
msgid ""
"Specifying several revisions means the set of commits reachable from any of "
"the given commits."
msgstr ""
"複数のリビジョンを指定するということは、指定のコミットのいずれかから到達可能"
"なコミットの組を意味します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:280
msgid ""
"A commit's reachable set is the commit itself and the commits in its "
"ancestry chain."
msgstr ""
"コミットの到達可能な組は、コミット自体とその祖先チェーン内のコミットです。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:283
msgid ""
"There are several notations to specify a set of connected commits (called a "
"\"revision range\"), illustrated below."
msgstr ""
"以下に示すように、接続されたコミット(connected commits)の組(「リビジョン範"
"囲」(revision range)と呼ばれる)を指定するためのいくつかの表記法があります。"

#. type: Title ~
#: ../Documentation-sedout/revisions.txt:286
#, no-wrap
msgid "Commit Exclusions"
msgstr "Commit Exclusions"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:288
#, no-wrap
msgid "'{caret}<rev>' (caret) Notation"
msgstr "`^<rev>` (カレット)記法"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:293
msgid ""
"To exclude commits reachable from a commit, a prefix '{caret}' notation is "
"used.  E.g. '{caret}r1 r2' means commits reachable from 'r2' but exclude the "
"ones reachable from 'r1' (i.e. 'r1' and its ancestors)."
msgstr ""
"とある到達可能なコミットをコミット達から除外するには、接頭辞 `^` 表記を使用し"
"ます。 例えば `^r1 r2` は `r2` から到達可能なコミットだけども、 `r1` から到達"
"可能なコミット(つまり `r1` とその祖先)は除外する事を意味します。"

#. type: Title ~
#: ../Documentation-sedout/revisions.txt:295
#, no-wrap
msgid "Dotted Range Notations"
msgstr "Dotted Range Notations"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:297
#, no-wrap
msgid "The '..' (two-dot) Range Notation"
msgstr "`..` (2ドット)範囲記法"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:303
msgid ""
"The '{caret}r1 r2' set operation appears so often that there is a shorthand "
"for it.  When you have two commits 'r1' and 'r2' (named according to the "
"syntax explained in SPECIFYING REVISIONS above), you can ask for commits "
"that are reachable from r2 excluding those that are reachable from r1 by "
"'{caret}r1 r2' and it can be written as 'r1..r2'."
msgstr ""
"`^r1 r2` 操作は頻繁に表示されるため、省略形があります。(上記の SPECIFYING "
"REVISIONS で説明されている構文に従って名前が付けられている)2つのコミット "
"`r1` と `r2` がある場合、あなたは `^r1 r2` によってr1から到達可能なコミットを"
"取り除き、r2から到達可能なコミットを要求できます。そしてこれは `r1..r2` と書"
"くことができます。"

# ... three-dot が info,html では … 3点リーダに変換されてしまうので バッククォートで囲む `...`
#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:304
#, no-wrap
msgid "The '\\...' (three-dot) Symmetric Difference Notation"
msgstr "`...` (3ドット)対称差記法"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:310
msgid ""
"A similar notation 'r1\\...r2' is called symmetric difference of 'r1' and "
"'r2' and is defined as 'r1 r2 --not $(git merge-base --all r1 r2)'.  It is "
"the set of commits that are reachable from either one of 'r1' (left side) or "
"'r2' (right side) but not from both."
msgstr ""
"似た表記 `r1...r2` は `r1` と `r2` の対称差と呼ばれ、 `r1 r2 --not $(git "
"merge-base --all r1 r2)` として定義されます。 これは、 `r1` (左側)または "
"`r2` (右側)のいずれかから到達可能であるが、両方からは到達できないコミットの組"
"です。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:317
msgid ""
"In these two shorthand notations, you can omit one end and let it default to "
"HEAD.  For example, 'origin..' is a shorthand for 'origin..HEAD' and asks "
"\"What did I do since I forked from the origin branch?\" Similarly, '.."
"origin' is a shorthand for 'HEAD..origin' and asks \"What did the origin do "
"since I forked from them?\" Note that '..' would mean 'HEAD..HEAD' which is "
"an empty range that is both reachable and unreachable from HEAD."
msgstr ""
"これらの2つの省略表記では、一方の端を省略して、デフォルトでHEADにすることがで"
"きます。たとえば、 `origin..` は `origin..HEAD` の省略形であり、「originブラ"
"ンチから分岐(fork)してから何をしましたか？」と尋ねます。 同様に、 `..origin` "
"は `HEAD..origin` の省略形であり、「私がそれらから分岐してから、originは何を"
"しましたか？」と尋ねます。 `..` は `HEAD..HEAD` を意味することに注意してくだ"
"さい。これは、HEADから到達可能および到達不能の両方の空の範囲です。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:324
msgid ""
"Commands that are specifically designed to take two distinct ranges (e.g. "
"\"git range-diff R1 R2\" to compare two ranges) do exist, but they are "
"exceptions.  Unless otherwise noted, all \"git\" commands that operate on a "
"set of commits work on a single revision range.  In other words, writing two "
"\"two-dot range notation\" next to each other, e.g."
msgstr ""
"2つの異なる範囲を取るように特別に設計されたコマンド(たとえば、2つの範囲を比較"
"するための \"git range-diff R1 R2\" ) は存在しますが、それらは例外です。特に"
"明記されていない限り、一連のコミットを操作するすべての \"git\" コマンドは、単"
"一のリビジョン範囲で機能します。言い換えると、2つの「2ドット範囲表記」を隣り"
"合わせに記述します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:326
#, no-wrap
msgid "    $ git log A..B C..D\n"
msgstr "    $ git log A..B C..D\n"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:331
msgid ""
"does *not* specify two revision ranges for most commands.  Instead it will "
"name a single connected set of commits, i.e. those that are reachable from "
"either B or D but are reachable from neither A or C.  In a linear history "
"like this:"
msgstr ""
"ほとんどのコマンドでは2つのリビジョン範囲を指定しません。代わりに、接続された"
"単一のコミットの組、つまりBまたはDのいずれかから到達可能であるが、AまたはCの"
"どちらからも到達可能でないコミットの組に名前を付けます。線形履歴では、以下の"
"ようになります:"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:333
#, no-wrap
msgid "    ---A---B---o---o---C---D\n"
msgstr "    ---A---B---o---o---C---D\n"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:336
msgid ""
"because A and B are reachable from C, the revision range specified by these "
"two dotted ranges is a single commit D."
msgstr ""
"AとBはCから到達可能であるため、これら2つの2ドット範囲記法で指定されたリビジョ"
"ン範囲は単一のコミットDです。"

#. type: Title ~
#: ../Documentation-sedout/revisions.txt:339
#, no-wrap
msgid "Other <rev>{caret} Parent Shorthand Notations"
msgstr "Other <rev>^ Parent Shorthand Notations"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:342
msgid ""
"Three other shorthands exist, particularly useful for merge commits, for "
"naming a set that is formed by a commit and its parent commits."
msgstr ""
"コミットとその親コミットによって形成される組に名前を付けるために、マージコ"
"ミットに特に役立つ他の3つの省略形が存在します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:344
msgid "The 'r1{caret}@' notation means all parents of 'r1'."
msgstr "`r1^@` 表記は、 `r1` のすべての親を意味します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:347
msgid ""
"The 'r1{caret}!' notation includes commit 'r1' but excludes all of its "
"parents.  By itself, this notation denotes the single commit 'r1'."
msgstr ""
"`r1^!` 表記には コミット `r1` が含まれますが、そのすべての親は除外されます。"
"この表記自体は、単一のコミット `r1` を示します。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:354
msgid ""
"The '<rev>{caret}-[<n>]' notation includes '<rev>' but excludes the <n>th "
"parent (i.e. a shorthand for '<rev>{caret}<n>..<rev>'), with '<n>' = 1 if "
"not given. This is typically useful for merge commits where you can just "
"pass '<commit>{caret}-' to get all the commits in the branch that was merged "
"in merge commit '<commit>' (including '<commit>' itself)."
msgstr ""
"`<rev>^-[<n>]` 表記には `<rev>` が含まれますが、 <n> 番目の親(つまり、 "
"`<rev>^<n>..<rev>` の省略形)は除外されます。 <n> が指定されていない場合は "
"`<n>` = 1 とみなします。これは通常、 `<commit>^-` を渡すだけで、マージコミッ"
"ト `<commit>`(`<commit>` 自体を含む)でマージされたブランチ内のすべてのコミッ"
"トを取得できるマージコミットに役立ちます。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:358
msgid ""
"While '<rev>{caret}<n>' was about specifying a single commit parent, these "
"three notations also consider its parents. For example you can say "
"'HEAD{caret}2{caret}@', however you cannot say 'HEAD{caret}@{caret}2'."
msgstr ""
"`<rev>^<n>` は単一のコミット親を指定することに関するものでしたが、これらの3つ"
"の表記はその親も考慮します。たとえば、 `HEAD^2^@` と言うことはできますが、 "
"`HEAD^@^2` と言うことはできません。"

#. type: Title -
#: ../Documentation-sedout/revisions.txt:360
#, no-wrap
msgid "Revision Range Summary"
msgstr "Revision Range Summary"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:362
#, no-wrap
msgid "'<rev>'"
msgstr "`<rev>`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:365
msgid ""
"Include commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr "<rev> から到達可能なコミット(つまり <rev> とその祖先)を含めます。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:366
#, no-wrap
msgid "'{caret}<rev>'"
msgstr "`^<rev>`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:369
msgid ""
"Exclude commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr "<rev> から到達可能なコミット(つまり <rev> とその祖先)を除外します。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:370
#, no-wrap
msgid "'<rev1>..<rev2>'"
msgstr "`<rev1>..<rev2>`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:374
msgid ""
"Include commits that are reachable from <rev2> but exclude those that are "
"reachable from <rev1>.  When either <rev1> or <rev2> is omitted, it defaults "
"to `HEAD`."
msgstr ""
"<rev2> から到達可能なコミットを含めますが、 <rev1> から到達可能なコミットは除"
"外します。 <rev1> または <rev2> のいずれかを省略すると、それらはそれぞれデ"
"フォルトで `HEAD` になります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:375
#, no-wrap
msgid "'<rev1>\\...<rev2>'"
msgstr "`<rev1>...<rev2>`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:379
msgid ""
"Include commits that are reachable from either <rev1> or <rev2> but exclude "
"those that are reachable from both.  When either <rev1> or <rev2> is "
"omitted, it defaults to `HEAD`."
msgstr ""
"<rev1> または <rev2> のいずれかから到達可能なコミットを含めますが、両方から到"
"達可能なコミットは除外します。 <rev1> または <rev2> のいずれかを省略すると、"
"それらはそれぞれデフォルトで `HEAD` になります。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:380
#, no-wrap
msgid "'<rev>{caret}@', e.g. 'HEAD{caret}@'"
msgstr "`<rev>^@` 例: `HEAD^@`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:384
msgid ""
"A suffix '{caret}' followed by an at sign is the same as listing all parents "
"of '<rev>' (meaning, include anything reachable from its parents, but not "
"the commit itself)."
msgstr ""
"接尾辞 `^` の後にアットマーク(`@`)を付けることは、 `<rev>` のすべての親をリス"
"トすることと同じです(つまり、親から到達可能なものはすべて含まれますが、コミッ"
"ト自体は含まれません)。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:385
#, no-wrap
msgid "'<rev>{caret}!', e.g. 'HEAD{caret}!'"
msgstr "`<rev>^!` 例: `HEAD^!`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:389
msgid ""
"A suffix '{caret}' followed by an exclamation mark is the same as giving "
"commit '<rev>' and all its parents prefixed with '{caret}' to exclude them "
"(and their ancestors)."
msgstr ""
"接尾辞 `^` の後に感嘆符(`!`)を付けることは、コミット `<rev>` を指定し、そのす"
"べての親に接頭辞 `^` を付けて、それら(およびその祖先)を除外することと同じで"
"す。"

#. type: Labeled list
#: ../Documentation-sedout/revisions.txt:390
#, no-wrap
msgid "'<rev>{caret}-<n>', e.g. 'HEAD{caret}-, HEAD{caret}-2'"
msgstr "`<rev>^-<n>` 例: `HEAD^-, HEAD^-2`"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:393
msgid "Equivalent to '<rev>{caret}<n>..<rev>', with '<n>' = 1 if not given."
msgstr ""
"`<rev>^<n>..<rev>` と同等であり、 `<n>` が指定されていない場合は `<n>` = 1 で"
"す。"

#. type: Plain text
#: ../Documentation-sedout/revisions.txt:397
msgid ""
"Here are a handful of examples using the Loeliger illustration above, with "
"each step in the notation's expansion and selection carefully spelt out:"
msgstr ""
"上記のLoeliger図解を使用したいくつかの例を以下に示します。表記の拡張と選択"
"は、それぞれ段階が分かるようステップを踏んで説明してあります:"

#. type: delimited block .
#: ../Documentation-sedout/revisions.txt:421
#, no-wrap
msgid ""
"   Args   Expanded arguments    Selected commits\n"
"   D                            G H D\n"
"   D F                          G H I J D F\n"
"   ^G D                         H D\n"
"   ^D B                         E I J F B\n"
"   ^D B C                       E I J F B C\n"
"   C                            I J F C\n"
"   B..C   = ^B C                C\n"
"   B...C  = B ^F C              G H D E B C\n"
"   B^-    = B^..B\n"
"\t  = ^B^1 B              E I J F B\n"
"   C^@    = C^1\n"
"\t  = F                   I J F\n"
"   B^@    = B^1 B^2 B^3\n"
"\t  = D E F               D G H E F I J\n"
"   C^!    = C ^C^@\n"
"\t  = C ^C^1\n"
"\t  = C ^F                C\n"
"   B^!    = B ^B^@\n"
"\t  = B ^B^1 ^B^2 ^B^3\n"
"\t  = B ^D ^E ^F          B\n"
"   F^! D  = F ^I ^J D           G H D F\n"
msgstr ""
"   Args   Expanded arguments    Selected commits\n"
"   D                            G H D\n"
"   D F                          G H I J D F\n"
"   ^G D                         H D\n"
"   ^D B                         E I J F B\n"
"   ^D B C                       E I J F B C\n"
"   C                            I J F C\n"
"   B..C   = ^B C                C\n"
"   B...C  = B ^F C              G H D E B C\n"
"   B^-    = B^..B\n"
"\t  = ^B^1 B              E I J F B\n"
"   C^@    = C^1\n"
"\t  = F                   I J F\n"
"   B^@    = B^1 B^2 B^3\n"
"\t  = D E F               D G H E F I J\n"
"   C^!    = C ^C^@\n"
"\t  = C ^C^1\n"
"\t  = C ^F                C\n"
"   B^!    = B ^B^@\n"
"\t  = B ^B^1 ^B^2 ^B^3\n"
"\t  = B ^D ^E ^F          B\n"
"   F^! D  = F ^I ^J D           G H D F\n"
