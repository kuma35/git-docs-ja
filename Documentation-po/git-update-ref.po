# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: git-docs-ja 0.0\n"
"POT-Creation-Date: 2021-11-04 04:37+0900\n"
"PO-Revision-Date: 2022-04-10 07:09+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: ../Documentation-sedout/git-update-ref.txt:2
#, no-wrap
msgid "git-update-ref(1)"
msgstr "git-update-ref(1)"

#. type: Title -
#: ../Documentation-sedout/git-update-ref.txt:5
#, no-wrap
msgid "NAME"
msgstr "NAME"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:7
msgid "git-update-ref - Update the object name stored in a ref safely"
msgstr "git-update-ref - refに保存されているオブジェクト名を安全に更新します"

#. type: Title -
#: ../Documentation-sedout/git-update-ref.txt:9
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:12
#, no-wrap
msgid "'git update-ref' [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])\n"
msgstr "'git update-ref' [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])\n"

#. type: Title -
#: ../Documentation-sedout/git-update-ref.txt:14
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:18
msgid ""
"Given two arguments, stores the <newvalue> in the <ref>, possibly "
"dereferencing the symbolic refs.  E.g. `git update-ref HEAD <newvalue>` "
"updates the current branch head to the new object."
msgstr "2つの引数が与えられた場合、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。例えば、 `git update-ref HEAD <newvalue>` は、現在のブランチヘッドを新しいオブジェクトに更新します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:27
msgid ""
"Given three arguments, stores the <newvalue> in the <ref>, possibly "
"dereferencing the symbolic refs, after verifying that the current value of "
"the <ref> matches <oldvalue>.  E.g. `git update-ref refs/heads/master "
"<newvalue> <oldvalue>` updates the master branch head to <newvalue> only if "
"its current value is <oldvalue>.  You can specify 40 \"0\" or an empty "
"string as <oldvalue> to make sure that the ref you are creating does not "
"exist."
msgstr "3つの引数が与えられた場合、<ref>の現在の値が<oldvalue>と一致することを確認した後、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。 例えば、 `git update-ref refs/heads/master <newvalue> <oldvalue>` は、現在の値が<oldvalue>の場合にのみ、masterブランチヘッドを<newvalue>に更新します。 あなたは、作成する参照がまだ存在しないこと示すために、40個の\"0\" または 空の文字列を <oldvalue> として指定する事ができます。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:31
msgid ""
"It also allows a \"ref\" file to be a symbolic pointer to another ref file "
"by starting with the four-byte header sequence of \"ref:\"."
msgstr "また、 \"ref:\" という4バイトのヘッダーシーケンスで開始することにより、「ref」ファイルを別のrefファイルへのシンボリックポインタにすることもできます。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:39
msgid ""
"More importantly, it allows the update of a ref file to follow these "
"symbolic pointers, whether they are symlinks or these \"regular file "
"symbolic refs\".  It follows *real* symlinks only if they start with \"refs/"
"\": otherwise it will just try to read them and update them as a regular "
"file (i.e. it will allow the filesystem to follow them, but will overwrite "
"such a symlink to somewhere else with a regular filename)."
msgstr "さらに重要なことは、refファイルの更新は、シンボリックリンクであろうと、これらの「通常のファイルのシンボリック参照」であろうと、これらのシンボリックポインタに従います。 `refs/` で始まる場合にのみ「実際」のシンボリックリンクをたどります。それ以外の場合は、それらを読み取って通常のファイルとして更新しようとします(つまり、ファイルシステムはそれらを追跡できますが、他の場所へのそのようなシンボリックリンクは通常のファイル名で上書きされます)。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:42
msgid ""
"If --no-deref is given, <ref> itself is overwritten, rather than the result "
"of following the symbolic pointers."
msgstr "`--no-deref` を指定すると、シンボリックポインターをたどった結果ではなく、<ref>自体が上書きされます。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:44
msgid "In general, using"
msgstr "一般的には以下ように使います"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:46
#, no-wrap
msgid "\tgit update-ref HEAD \"$head\"\n"
msgstr "\tgit update-ref HEAD \"$head\"\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:48
msgid "should be a _lot_ safer than doing"
msgstr "これは、以下のようにするよりもはるかに安全なはずです"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:50
#, no-wrap
msgid "\techo \"$head\" > \"$GIT_DIR/HEAD\"\n"
msgstr "\techo \"$head\" > \"$GIT_DIR/HEAD\"\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:57
msgid ""
"both from a symlink following standpoint *and* an error checking "
"standpoint.  The \"refs/\" rule for symlinks means that symlinks that point "
"to \"outside\" the tree are safe: they'll be followed for reading but not "
"for writing (so we'll never write through a ref symlink to some other tree, "
"if you have copied a whole archive by creating a symlink tree)."
msgstr "シンボリックリンク追跡とエラーチェックの両方の観点から、シンボリックリンクの \"refs/\" ルールは、ツリーの「外側」を指すシンボリックリンクが安全であることを意味します。つまり、読み取りでは追跡されますが、書き込みでは追跡されません(したがって、シンボリックリンクツリーを作成してアーカイブ全体をコピーした場合は、refシンボリックリンクを介して他のツリーに書き込むことはありません)。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:60
msgid ""
"With `-d` flag, it deletes the named <ref> after verifying it still contains "
"<oldvalue>."
msgstr "`-d` フラグを使用すると、<ref>がまだ<oldvalue>を含んでいることを確認(verify)した後、名前付きの<ref>を削除します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:63
msgid ""
"With `--stdin`, update-ref reads instructions from standard input and "
"performs all modifications together.  Specify commands of the form:"
msgstr "`--stdin` を使用すると、update-refは標準入力から命令を読み取り、すべての変更を一緒に実行します。 以下の形式のコマンドを指定します:"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:73
#, no-wrap
msgid ""
"\tupdate SP <ref> SP <newvalue> [SP <oldvalue>] LF\n"
"\tcreate SP <ref> SP <newvalue> LF\n"
"\tdelete SP <ref> [SP <oldvalue>] LF\n"
"\tverify SP <ref> [SP <oldvalue>] LF\n"
"\toption SP <opt> LF\n"
"\tstart LF\n"
"\tprepare LF\n"
"\tcommit LF\n"
"\tabort LF\n"
msgstr ""
"\tupdate SP <ref> SP <newvalue> [SP <oldvalue>] LF\n"
"\tcreate SP <ref> SP <newvalue> LF\n"
"\tdelete SP <ref> [SP <oldvalue>] LF\n"
"\tverify SP <ref> [SP <oldvalue>] LF\n"
"\toption SP <opt> LF\n"
"\tstart LF\n"
"\tprepare LF\n"
"\tcommit LF\n"
"\tabort LF\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:76
msgid ""
"With `--create-reflog`, update-ref will create a reflog for each ref even if "
"one would not ordinarily be created."
msgstr "`--create-reflog` を使用すると、update-refは、通常は作成されない場合でも、各refのreflogを作成します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:81
msgid ""
"Quote fields containing whitespace as if they were strings in C source code; "
"i.e., surrounded by double-quotes and with backslash escapes.  Use 40 \"0\" "
"characters or the empty string to specify a zero value.  To specify a "
"missing value, omit the value and its preceding SP entirely."
msgstr "Cソースコードの文字列であるかのように空白を含むフィールドをクォートします。 つまり、二重引用符で囲まれ、バックスラッシュ(`\\`)でエスケープされます。 ゼロ値(zero value)を指定するには、40個の \"0\" 文字または空の文字列を使用します。 欠落している値(missing value)を指定するには、値とその前のSPを完全に省略します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:84
msgid ""
"Alternatively, use `-z` to specify in NUL-terminated format, without quoting:"
msgstr "あるいは、 `-z` を使用して、クォートせずにNUL終了形式で指定します:"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:94
#, no-wrap
msgid ""
"\tupdate SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL\n"
"\tcreate SP <ref> NUL <newvalue> NUL\n"
"\tdelete SP <ref> NUL [<oldvalue>] NUL\n"
"\tverify SP <ref> NUL [<oldvalue>] NUL\n"
"\toption SP <opt> NUL\n"
"\tstart NUL\n"
"\tprepare NUL\n"
"\tcommit NUL\n"
"\tabort NUL\n"
msgstr ""
"\tupdate SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL\n"
"\tcreate SP <ref> NUL <newvalue> NUL\n"
"\tdelete SP <ref> NUL [<oldvalue>] NUL\n"
"\tverify SP <ref> NUL [<oldvalue>] NUL\n"
"\toption SP <opt> NUL\n"
"\tstart NUL\n"
"\tprepare NUL\n"
"\tcommit NUL\n"
"\tabort NUL\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:97
msgid ""
"In this format, use 40 \"0\" to specify a zero value, and use the empty "
"string to specify a missing value."
msgstr "この形式では、40個の \"0\" を使用してゼロ値(zero value)を指定し、空の文字列を使用して欠落している値(missing value)を指定します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:101
msgid ""
"In either format, values can be specified in any form that Git recognizes as "
"an object name.  Commands in any other format or a repeated <ref> produce an "
"error.  Command meanings are:"
msgstr "どちらの形式でも、Gitがオブジェクト名として認識する任意の形式で値を指定できます。他の形式のコマンドまたは繰り返される<ref>は、エラーを生成します。 コマンドの意味は以下のとおりです:"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:102
#, no-wrap
msgid "update"
msgstr "update"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:107
msgid ""
"Set <ref> to <newvalue> after verifying <oldvalue>, if given.  Specify a "
"zero <newvalue> to ensure the ref does not exist after the update and/or a "
"zero <oldvalue> to make sure the ref does not exist before the update."
msgstr "指定されている場合は、<oldvalue>を確認した後、<ref>を<newvalue>に設定します。 ゼロ<newvalue>を指定して、更新後にrefが存在しないことを確認(verify)するか、ゼロ<oldvalue>を指定して、更新前にrefが存在しないことを確認(verify)します。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:108
#, no-wrap
msgid "create"
msgstr "create"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:111
msgid ""
"Create <ref> with <newvalue> after verifying it does not exist.  The given "
"<newvalue> may not be zero."
msgstr "存在しないことを確認した後、<newvalue>を使用して<ref>を作成します。 指定された<newvalue>はゼロではない可能性があります。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:112
#, no-wrap
msgid "delete"
msgstr "delete"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:115
msgid ""
"Delete <ref> after verifying it exists with <oldvalue>, if given.  If given, "
"<oldvalue> may not be zero."
msgstr "<oldvalue>が指定されている場合は、それが存在することを確認した後、<ref>を削除します。 指定した場合、<oldvalue>はゼロではない可能性があります。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:116
#, no-wrap
msgid "verify"
msgstr "verify"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:119
msgid ""
"Verify <ref> against <oldvalue> but do not change it.  If <oldvalue> is zero "
"or missing, the ref must not exist."
msgstr "<ref>を<oldvalue>に対して確認(verify)しますが、変更しないでください。 <oldvalue>がゼロ(zero)または欠落(missing)している場合、refは存在してはなりません。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:120
#, no-wrap
msgid "option"
msgstr "option"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:124
msgid ""
"Modify behavior of the next command naming a <ref>.  The only valid option "
"is `no-deref` to avoid dereferencing a symbolic ref."
msgstr "<ref>に名前を付ける次のコマンドの振る舞いを変更します。 唯一の有効なオプションは `no-deref` で、シンボリックrefの逆参照を回避します。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:125
#, no-wrap
msgid "start"
msgstr "start"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:130
msgid ""
"Start a transaction. In contrast to a non-transactional session, a "
"transaction will automatically abort if the session ends without an explicit "
"commit. This command may create a new empty transaction when the current one "
"has been committed or aborted already."
msgstr "トランザクションを開始します。 非トランザクションセッションとは対照的に、セッションが明示的なコミットなしで終了すると、トランザクションは自動的に中止(abort)されます。 このコマンドは、現在のトランザクションがすでにコミットまたは中止(abort)されている場合に、新しい空のトランザクションを作成する場合があります。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:131
#, no-wrap
msgid "prepare"
msgstr "prepare"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:135
msgid ""
"Prepare to commit the transaction. This will create lock files for all "
"queued reference updates. If one reference could not be locked, the "
"transaction will be aborted."
msgstr "トランザクションをコミットする準備をします。 これにより、キューに入れられたすべての参照更新のロックファイルが作成されます。 ロックできない参照がある場合、トランザクションは中止(abort)されます。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:136
#, no-wrap
msgid "commit"
msgstr "commit"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:139
msgid ""
"Commit all reference updates queued for the transaction, ending the "
"transaction."
msgstr "トランザクションのためにキューに入れられたすべての参照更新をコミットし、トランザクションを終了(ending)します。"

#. type: Labeled list
#: ../Documentation-sedout/git-update-ref.txt:140
#, no-wrap
msgid "abort"
msgstr "abort"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:143
msgid ""
"Abort the transaction, releasing all locks if the transaction is in prepared "
"state."
msgstr "トランザクションを中止(abort)し、トランザクションが準備済み状態(prepared state)の場合はすべてのロックを解除します。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:149
msgid ""
"If all <ref>s can be locked with matching <oldvalue>s simultaneously, all "
"modifications are performed.  Otherwise, no modifications are performed.  "
"Note that while each individual <ref> is updated or deleted atomically, a "
"concurrent reader may still see a subset of the modifications."
msgstr "すべての<ref>を一致する<oldvalue>で同時にロックできる場合、すべての変更が実行されます。 それ以外の場合、変更は実行されません。 注意: 個々の<ref>はアトミックに更新または削除されますが、並行読み取り(concurrent reader)では変更のサブセットが表示される場合があることに注意してください。"

#. type: Title -
#: ../Documentation-sedout/git-update-ref.txt:151
#, no-wrap
msgid "LOGGING UPDATES"
msgstr "LOGGING UPDATES"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:159
msgid ""
"If config parameter \"core.logAllRefUpdates\" is true and the ref is one "
"under \"refs/heads/\", \"refs/remotes/\", \"refs/notes/\", or a pseudoref "
"like HEAD or ORIG_HEAD; or the file \"$GIT_DIR/logs/<ref>\" exists then `git "
"update-ref` will append a line to the log file \"$GIT_DIR/logs/<ref>"
"\" (dereferencing all symbolic refs before creating the log name) describing "
"the change in ref value.  Log lines are formatted as:"
msgstr "構成パラメーター `core.logAllRefUpdates `がtrueで、参照が `refs/heads/` の下にある場合、 `refs/remotes/` または `refs/notes/` または HEADやORIG_HEADのような疑似参照 または ファイル `$GIT_DIR/logs/<ref>` が存在する場合に、 `git update-ref` はログファイル `$GIT_DIR/logs/<ref>`  にref値の変更を説明する行を追加します(ログ名を作成する前に、すべてのシンボリックrefを間接参照します)。 ログ行は以下のようにフォーマットされます:"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:161
#, no-wrap
msgid "    oldsha1 SP newsha1 SP committer LF\n"
msgstr "    oldsha1 SP newsha1 SP committer LF\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:166
msgid ""
"Where \"oldsha1\" is the 40 character hexadecimal value previously stored in "
"<ref>, \"newsha1\" is the 40 character hexadecimal value of <newvalue> and "
"\"committer\" is the committer's name, email address and date in the "
"standard Git committer ident format."
msgstr "「oldsha1」は以前に<ref>に保存された40文字の16進値であり、「newsha1」は<newvalue>の40文字の16進値であり、「committer」は標準のGitコミッターID形式のコミッターの名前、メールアドレス、日付です。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:168
msgid "Optionally with -m:"
msgstr "オプションで `-m` と一緒に使用すると:"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:170
#, no-wrap
msgid "    oldsha1 SP newsha1 SP committer TAB message LF\n"
msgstr "    oldsha1 SP newsha1 SP committer TAB message LF\n"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:173
msgid ""
"Where all fields are as described above and \"message\" is the value "
"supplied to the -m option."
msgstr "これは、すべてのフィールドが上記のとおりであり、「message」が `-m` オプションに指定された値です。"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:177
msgid ""
"An update will fail (without changing <ref>) if the current user is unable "
"to create a new log file, append to the existing log file or does not have "
"committer information available."
msgstr "現在のユーザーが新しいログファイルを作成できない場合、既存のログファイルに追加できない場合、またはコミッター情報が利用できない場合、更新は（<ref>を変更せずに）失敗します。"

#. type: Title -
#: ../Documentation-sedout/git-update-ref.txt:179
#, no-wrap
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: ../Documentation-sedout/git-update-ref.txt:180
msgid "Part of the linkgit:git[1] suite"
msgstr "Part of the linkgit:git[1] suite"
