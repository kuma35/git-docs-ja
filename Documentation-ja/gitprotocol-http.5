'\" t
.\"     Title: gitprotocol-http
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GITPROTOCOL\-HTTP" "5" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
gitprotocol-http \- Git HTTPベース・プロトコル
.SH "SYNOPSIS"
.sp
.nf
<over\-the\-wire\-protocol>
.fi
.sp
.SH "DESCRIPTION"
.sp
Git は、2 つの HTTP ベースの転送プロトコルをサポートしています。 接続するサーバー側で標準の HTTP サーバーのみを必要とする「バカ」(dumb)プロトコルと、Git 対応の CGI (またはサーバーモジュール) を必要とする「スマート」プロトコルです。 このドキュメントでは、両方のプロトコルについて説明します。
.sp
設計機能として、スマートクライアントは「バカ」(dumb)プロトコル URL をスマート URL に自動的にアップグレードできます。 これにより、すべてのユーザーが同じ URL を公開できるようになり、接続先(the peers)では利用可能な最も効率的な転送方法(transport)を自動的に選択します。
.SH "URL FORMAT"
.sp
HTTP によってアクセスされる Git リポジトリの URL は、RFC 1738 で文書化されている標準の HTTP URL 構文を使用するため、以下の形式になります:
.sp
.if n \{\
.RS 4
.\}
.nf
http://<host>:<port>/<path>?<searchpart>
.fi
.if n \{\
.RE
.\}
.sp
このドキュメントでは、プレースホルダー \fB$GIT_URL\fR は、エンドユーザーが入力した http:// リポジトリ URL を表すことにします。
.sp
サーバーは、\fB$GIT_URL\fR に一致する場所へのすべてのリクエストを処理するべきです。 これは、Git で使用される「スマート」および「バカ」(dumb) HTTP プロトコルの両方が、ユーザーが指定した \fB$GIT_URL\fR 文字列の末尾に追加のパスコンポーネントを追加することによって動作するためです。
.sp
ルーズオブジェクトをリクエストするバカ(dumb)クライアントの例:
.sp
.if n \{\
.RS 4
.\}
.nf
$GIT_URL:     http://example\&.com:8080/git/repo\&.git
URL request:  http://example\&.com:8080/git/repo\&.git/objects/d0/49f6c27a2244e12041955e262a404c7faba355
.fi
.if n \{\
.RE
.\}
.sp
キャッチオール(catch\-all)ゲートウェイへのスマートリクエストの例:
.sp
.if n \{\
.RS 4
.\}
.nf
$GIT_URL:     http://example\&.com/daemon\&.cgi?svc=git&q=
URL request:  http://example\&.com/daemon\&.cgi?svc=git&q=/info/refs&service=git\-receive\-pack
.fi
.if n \{\
.RE
.\}
.sp
サブモジュール(submodule)へのリクエスト例:
.sp
.if n \{\
.RS 4
.\}
.nf
$GIT_URL:     http://example\&.com/git/repo\&.git/path/submodule\&.git
URL request:  http://example\&.com/git/repo\&.git/path/submodule\&.git/info/refs
.fi
.if n \{\
.RE
.\}
.sp
クライアントは、サーバーに送信されるURLに空のパストークン(\fB//\fR)が表示されるのを防ぐために、ユーザーから与えられた $GIT_URL 文字列から、末尾に \fB/\fR がある場合はそれを削除しなければなりません。 互換性のあるクライアントは、\fB$GIT_URL/info/refs\fR を \fBfoo//info/refs\fR ではなく、\fBfoo/info/refs\fR として展開しなｋればなりません。
.SH "AUTHENTICATION"
.sp
リポジトリへのアクセスに認証が必要な場合は、標準の HTTP 認証が使用され、HTTPサーバーソフトウェアによって構成および強制される場合があります。
.sp
Gitリポジトリは標準パスコンポーネントによってアクセスされるため、サーバー管理者はHTTPサーバー内でディレクトリベースのアクセス許可を使用して、リポジトリ アクセスを制御できます。
.sp
クライアントは、RFC 2617 で説明されているベーシック認証をサポートする必要があります。 サーバーは、Gitサーバーソフトウェアの前に置かれたHTTPサーバーに頼ってベーシック認証をサポートすべきです(SHOULD)。
.sp
サーバーは、認証またはアクセス制御の目的で HTTP クッキーを要求すべきではありません。
.sp
クライアントとサーバーは、ダイジェスト認証など、他の一般的なHTTPベースの認証形式をサポートする場合があります。
.SH "SSL"
.sp
クライアントとサーバーはSSLをサポートするべきです(SHOULD)。特に、ベーシック HTTP 認証に頼る場合にパスワードを保護するためです。
.SH "SESSION STATE"
.sp
Git over HTTP プロトコル (HTTP 自体とよく似ています) は、HTTP サーバー側から見るとステートレスです。 すべての状態は、クライアントプロセスによって保持および管理されなければなりません。 これにより、サーバー側で単純なラウンドロビン負荷分散が可能になり、状態管理について心配する必要がなくなります。
.sp
クライアントは、正しく機能するためにサーバー側に状態管理を要求してはなりません。
.sp
サーバーは、正しく機能するために HTTP Cookie を要求してはなりません。 クライアントは、RFC 2616 (HTTP/1\&.1) で説明されているように、リクエスト処理中に HTTP Cookie を保存および転送できます。 サーバーは、クライアントから送信されたすべての Cookie を無視する必要があります。
.SH "GENERAL REQUEST PROCESSING"
.sp
特に明記されている場合を除き、すべての標準 HTTP 動作は、クライアントとサーバーの両方で想定される必要があります。 これには以下が含まれます(必ずしもこれらに限定されません):
.sp
$GIT_URL にリポジトリがない場合、または $GIT_URL に一致する場所が指すリソースが存在しない場合、サーバーは \fB200 OK\fR 応答で応答してはいけません。 サーバーは、 \fB404 Not Found\fR または \fB410 Gone\fR または要求どおりにリソースが存在することを意味しないその他の適切な HTTP ステータス コードで応答する必要があります。
.sp
$GIT_URL にリポジトリがあるが、アクセスが現在許可されていない場合、サーバーは \fB403 Forbidden\fR HTTP ステータス コードで応答しなければなりません。
.sp
サーバーは、HTTP 1\&.0 と HTTP 1\&.1 の両方をサポートする必要があります。 サーバーは、リクエスト本文とレスポンス本文の両方でチャンクエンコーディングをサポートする必要があります。
.sp
クライアントは、HTTP 1\&.0 と HTTP 1\&.1 の両方をサポートする必要があります。 クライアントは、リクエスト本文とレスポンス本文の両方でチャンクエンコーディングをサポートする必要があります。
.sp
サーバは ETag かつ/または Last\-Modified ヘッダー を返すことがあります。
.sp
クライアントは、If\-Modified\-Since および/または If\-None\-Match リクエストヘッダーを含めることにより、キャッシュされたエンティティを再検証することができます。
.sp
関連するヘッダーがリクエストに表れ、エンティティが変更されていない場合、サーバーは \fB304 Not Modified\fR を返す場合があります。 クライアントは、キャッシュされたエンティティを再利用することにより、 \fB304 Not Modified\fR を \fB200 OK\fR と同じように扱わなければいけません。
.sp
Cache\-Control および/または Expires ヘッダーがキャッシュを許可する場合、クライアントは再検証なしでキャッシュされたエンティティを再利用できます。 クライアントとサーバーは、キャッシュ制御について RFC 2616 に従わなければなりません。
.SH "DISCOVERING REFERENCES"
.sp
すべての HTTP クライアントは、リモートリポジトリで利用可能な参照を検出して、フェッチまたはプッシュ交換を開始する必要があります。
.SS "Dumb Clients"
.sp
「バカ」(dumb)プロトコルのみをサポートする HTTP クライアントは、リポジトリの特別な info/refs ファイルをリクエストして、参照を検出する必要があります。
.sp
バカ(dumb) HTTP クライアントは、検索/クエリ パラメータなしで、 \fB$GIT_URL/info/refs\fR に対して \fBGET\fR リクエストを作成する必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
C: GET $GIT_URL/info/refs HTTP/1\&.0
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1\&.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1\&.0^{}
.fi
.if n \{\
.RE
.\}
.sp
返された info/refs エンティティの Content\-Type は、 \fBtext/plain charset=utf\-8\fR であるべきですが、任意の Content\-Type である場合があります。 クライアントは、返された Content\-Type の検証を試みてはいけません。 バカ(dumb)サーバーは、 \fBapplication/x\-git\-\fR で始まる戻り値のタイプを返してはいけません。
.sp
返されたエンティティのキャッシングを無効にするために、 Cache\-Control ヘッダーが返される場合があります。
.sp
応答クライアントを調べる場合、HTTP ステータス コードのみを調べる必要があります。 有効な応答は、 \fB200 OK\fR または \fB304 Not Modified\fR です。
.sp
返されるコンテンツは、各refとその既知の値を記述した UNIX 形式のテキストファイルです。 ファイルは、C ロケールの順序に従って名前でソートする必要があります。 ファイルには、 \fBHEAD\fR という名前のデフォルトrefを含めるべきではありません。
.sp
.if n \{\
.RS 4
.\}
.nf
info_refs   =  *( ref_record )
ref_record  =  any_ref / peeled_ref
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
any_ref     =  obj\-id HTAB refname LF
peeled_ref  =  obj\-id HTAB refname LF
               obj\-id HTAB refname "^{}" LF
.fi
.if n \{\
.RE
.\}
.SS "Smart Clients"
.sp
「スマート」(smart)プロトコル (または「スマート」プロトコルと「バカ」(dumb)プロトコルの両方) をサポートする HTTP クライアントは、リポジトリの info/refs ファイルに対してパラメーター化された要求を行うことにより、参照を検出する必要があります。
.sp
リクエストには、\fBservice=$servicename\fR というクエリパラメータが 1 つだけ含まれている必要があります。ここで、 \fB$servicename\fR は、クライアントが操作を完了するために接続したいサービス名でなければなりません。 リクエストに追加のクエリパラメータを含めてはいけません。
.sp
.if n \{\
.RS 4
.\}
.nf
C: GET $GIT_URL/info/refs?service=git\-upload\-pack HTTP/1\&.0
.fi
.if n \{\
.RE
.\}
.sp
バカ(dumb)サーバー返答:
.sp
.if n \{\
.RS 4
.\}
.nf
S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1\&.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1\&.0^{}
.fi
.if n \{\
.RE
.\}
.sp
スマートサーバー返答:
.sp
.if n \{\
.RS 4
.\}
.nf
S: 200 OK
S: Content\-Type: application/x\-git\-upload\-pack\-advertisement
S: Cache\-Control: no\-cache
S:
S: 001e# service=git\-upload\-pack\en
S: 0000
S: 004895dcfa3633004da0049d3d0fa03f80589cbcaf31 refs/heads/maint\e0multi_ack\en
S: 003fd049f6c27a2244e12041955e262a404c7faba355 refs/heads/master\en
S: 003c2cb58b79488a98d2721cea644875a8dd0026b115 refs/tags/v1\&.0\en
S: 003fa3c2e2402b99163d1d59756e5f207ae21cccba4c refs/tags/v1\&.0^{}\en
S: 0000
.fi
.if n \{\
.RE
.\}
.sp
クライアントは、 追加パラメーター(Extra Parameters; \fBgitprotocol-pack\fR(5) 参照) を、 Git\-Protocol HTTP ヘッダーでコロンで区切られた文字列として送信できます。
.sp
`\-\-http\-backend\-info\-refs@ オプションを \fBgit-upload-pack\fR(1) に使用します。
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBDumb Server Response\fR
.RS 4
.sp
バカ(dumb)サーバーは、バカサーバー応答形式(the dumb server reply format)で応答しなければなりません。
.sp
バカ(dumb)サーバー応答の詳細な説明については、前述の「dumb clients」セクションを参照してください。
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSmart Server Response\fR
.RS 4
.sp
サーバーがリクエストされたサービス名を認識しない場合、またはリクエストされたサービス名がサーバー管理者によって無効にされている場合、サーバーは \fB403 Forbidden\fR HTTP ステータス コードで応答する必要があります。
.sp
それ以外の場合、スマートサーバーは、リクエストされたサービス名のスマートサーバー返答形式(the smart server reply format)で応答する必要があります。
.sp
Cache\-Control ヘッダーは、返されたエンティティのキャッシュを無効にするために使用する必要があります。
.sp
Content\-Type は \fBapplication/x\-$servicename\-advertisement\fR でなければなりません。 別のコンテンツタイプが返された場合、クライアントはバカ(dumb)プロトコルにフォールバックする必要があります。 バカ(dumb)プロトコルクライアントにフォールバックするとき、クライアントは \fB$GIT_URL/info/refs\fR に追加のリクエストを行うべきではなく、代わりに既に手元にある応答を使用すべきです。 バカ(dumb)プロトコルをサポートしていない場合、クライアントは続行(continue)してはいけません。
.sp
クライアントは、ステータスコードが \fB200 OK\fR または \fB304 Not Modified\fR であることを検証(validate)する必要があります。
.sp
クライアントは、応答エンティティの最初の 5 バイトが正規表現 \fB^[0\-9a\-f]{4}#\fR とマッチすることを検証(validate)する必要があります。 このテストが失敗した場合、クライアントは続行(continue)してはいけません。
.sp
クライアントは、応答全体を一連の pkt\-line レコードとしてパースしなければなりません。
.sp
クライアントは、最初の pkt\-line が \fB# service=$servicename\fR であることを確認(verify)する必要があります。 サーバーは $servicename をリクエストパラメータ値に設定する必要があります。 サーバーは、この行の最後に LF を含める必要があります。 クライアントは、行末の LF を無視する必要があります。
.sp
サーバーは、魔法の \fB0000\fR pkt\-line 終了マーカー(the magic \fB0000\fR end pkt\-line marker)で応答を終了する必要があります。
.sp
返される応答は、各refとその既知の値を説明する pkt\-line ストリームです。 ストリームは、C ロケールの順序に従って名前でソートする必要があります。 ストリームには、最初のrefとして \fBHEAD\fR という名前のデフォルトref照を含める必要があります。 ストリームは、最初のrefの NUL の後ろに機能宣言(capability declarations)を含める必要があります。
.sp
"version=1" が 追加パラメータ(Extra Parameter) として送信された場合、返される応答には "version 1" が含まれます。
.sp
.if n \{\
.RS 4
.\}
.nf
smart_reply     =  PKT\-LINE("# service=$servicename" LF)
                   "0000"
                   *1("version 1")
                   ref_list
                   "0000"
ref_list        =  empty_list / non_empty_list
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
empty_list      =  PKT\-LINE(zero\-id SP "capabilities^{}" NUL cap\-list LF)
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
non_empty_list  =  PKT\-LINE(obj\-id SP name NUL cap_list LF)
                   *ref_record
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
cap\-list        =  capability *(SP capability)
capability      =  1*(LC_ALPHA / DIGIT / "\-" / "_")
LC_ALPHA        =  %x61\-7A
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
ref_record      =  any_ref / peeled_ref
any_ref         =  PKT\-LINE(obj\-id SP name LF)
peeled_ref      =  PKT\-LINE(obj\-id SP name LF)
                   PKT\-LINE(obj\-id SP name "^{}" LF
.fi
.if n \{\
.RE
.\}
.RE
.SH "SMART SERVICE GIT\-UPLOAD\-PACK"
.sp
このサービスは、 \fB$GIT_URL\fR が指すリポジトリから読み込みます。
.sp
クライアントは、最初に \fB$GIT_URL/info/refs?service=git\-upload\-pack\fR を使用して ref 検出を実行しなければなりません。
.sp
.if n \{\
.RS 4
.\}
.nf
C: POST $GIT_URL/git\-upload\-pack HTTP/1\&.0
C: Content\-Type: application/x\-git\-upload\-pack\-request
C:
C: 0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7\en
C: 0032have 441b40d833fdfa93eb2908e52742248faf0ee993\en
C: 0000
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
S: 200 OK
S: Content\-Type: application/x\-git\-upload\-pack\-result
S: Cache\-Control: no\-cache
S:
S: \&.\&.\&.\&.ACK %s, continue
S: \&.\&.\&.\&.NAK
.fi
.if n \{\
.RE
.\}
.sp
クライアントは、キャッシュされた応答を再利用(reuse)または再検証(revalidate)してはなりません。 サーバーは、応答のキャッシュを防ぐために十分な Cache\-Control ヘッダーを含める必要があります。
.sp
サーバーは、ここで定義されたすべての機能をサポートすべきです。
.sp
クライアントは、リクエスト本文で少なくとも 1 つの \fBwant\fR コマンドを送信する必要があります。 サーバーが機能 \fBallow\-tip\-sha1\-in\-want\fR または \fBallow\-reachable\-sha1\-in\-want\fR を宣伝(advertise)しない限り、クライアントは \fBwant\fR コマンドで ref 検出によって取得された応答に表示されなかった ID を参照してはいけません。
.sp
.if n \{\
.RS 4
.\}
.nf
compute_request   =  want_list
                     have_list
                     request_end
request_end       =  "0000" / "done"
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
want_list         =  PKT\-LINE(want SP cap_list LF)
                     *(want_pkt)
want_pkt          =  PKT\-LINE(want LF)
want              =  "want" SP id
cap_list          =  capability *(SP capability)
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
have_list         =  *PKT\-LINE("have" SP id LF)
.fi
.if n \{\
.RE
.\}
.sp
TODO: 更に文書化する
.SS "The Negotiation Algorithm"
.sp
最小パックを選択するための計算は以下のように行われます(C = クライアント、S = サーバー):
.sp
\fB初期化ステップ:\fR
.sp
C: 広告されたref(advertised refs)を取得するためにref検出を使用します。
.sp
C: 検出したオブジェクトを \fBadvertised\fR セットに配置します。
.sp
C: 後で両端にあると判断されるかもしれないオブジェクトを保持するために、 空のセット \fBcommon\fR を作成します。
.sp
C: ref検出中に発見したものに基づいて、クライアントが取得(fetch)したい \fBadvertised\fR オブジェクトの \fBwant\fR セットを構築します。
.sp
C: コミット時間順に並べられたキュー \fBc_pending\fR を開始(最新のものを最初に取り出す(pop))。 すべてのクライアントrefを追加します。 コミットがキューから取り出される(pop)と、その親が自動的に挿入し直されます(SHOULD)。 コミットがキューに入るのはは一度だけでなければなりません。
.sp
\fB1回分の計算ステップ:\fR
.sp
C: \fB$GIT_URL/git\-upload\-pack\fR リクエストを1つ送信します:
.sp
.if n \{\
.RS 4
.\}
.nf
C: 0032want <want #1>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
C: 0032want <want #2>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
\&.\&.\&.\&.
C: 0032have <common #1>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
C: 0032have <common #2>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
\&.\&.\&.\&.
C: 0032have <have #1>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
C: 0032have <have #2>\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.
\&.\&.\&.\&.
C: 0000
.fi
.if n \{\
.RE
.\}
.sp
ストリームは「コマンド群」に編成され、各コマンドは単独で pkt\-line に表れれます。 コマンド行内では、最初の空白までのテキストがコマンド名であり、行の残りの最初の LF までが値です。 コマンド行は、 pkt\-line 値の最後のバイトとしての LF で終了します。
.sp
コマンド群がリクエストストリームに表れる場合、以下の順序でなければなりません:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
"want"
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
"have"
.RE
.sp
ストリームは pkt\-line フラッシュ(\fB0000\fR)によって終了します。
.sp
単一の \fBwant\fR または \fBhave\fR コマンドは、その値として 1 つの 16 進形式のオブジェクト名を持たなければなりません。 複数のオブジェクト名は複数のコマンドを送信する必要があります。 オブジェクト名は、 \fBobject\-format\fR 機能 (デフォルト SHA\-1) によってネゴシエートされたオブジェクトフォーマットを使用して与える必要があります。
.sp
\fBhave\fR リストは、 \fBc_pending\fR から最初の 32 個のコミットを取り出す(pop)ことによって作成されます。 \fBc_pending\fR が空である場合、供給できる量が少なくなります。
.sp
クライアントが 256 の \fBhave\fR コミットを送信し、 \fBs_common\fR からそれらの 1 つをまだ受信していない場合、またはクライアントが \fBc_pending\fR を空にした場合、サーバーに続行しないことを知らせる \fBdone\fR コマンドを含める必要があります:
.sp
.if n \{\
.RS 4
.\}
.nf
C: 0009done
.fi
.if n \{\
.RE
.\}
.sp
S: git\-upload\-pack リクエストをパースする:
.sp
\fBwant\fR 内のすべてのオブジェクトがrefから直に到達可能であることを確認(verify)します。
.sp
サーバーは、履歴または reflog をさかのぼって、気持ち古いリクエストを許可する場合があります。
.sp
\fBwant\fR オブジェクトが受信されない場合は、エラーを送信します: TODO: \fB欲しい\fR 行がリクエストされていない場合はエラーを定義します。
.sp
\fBwant\fR オブジェクトに到達できない場合は、エラーを送信します: TODO: 無効な \fBwant\fR がリクエストされた場合はエラーを定義します。
.sp
空のリスト \fBs_common\fR を作成します。
.sp
もし \fBhave\fR が送信されたら:
.sp
クライアントから提供された順序でオブジェクトをループします。
.sp
各オブジェクトについて、サーバーに ref から到達可能なオブジェクトがある場合は、それを \fBs_common\fR に追加します。 コミットが s_common に追加された場合、祖先が have に含まれていても追加しないでください。
.sp
S: git\-upload\-pack 応答を送信:
.sp
サーバーがパックするオブジェクトの閉じたセットを見つけた場合、またはリクエストが \fBdone\fR で終了した場合、サーバーはパックで応答します。 TODO: パックベースの応答を文書化する
.sp
.if n \{\
.RS 4
.\}
.nf
S: PACK\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
返されるストリームは、 git\-upload\-pack サービスでサポートされている side\-band\-64k プロトコルであり、パックはストリーム 1 に埋め込まれます。サーバー側からの進行状況メッセージは、ストリーム 2 に表示される場合があります。
.sp
ここで、「オブジェクトの閉じたセット」(closed set of objects)とは、すべての \fBwant\fR から少なくとも 1 つの \fBcommon\fR オブジェクトへの少なくとも 1 つのパスを持つように定義されます。
.sp
サーバーがさらに情報を必要とする場合、サーバーは status continue 応答で応答します: TODO: パック以外の応答を文書化する
.sp
C: Parse the upload\-pack response: TODO: Document parsing response
.sp
\fB次の回の計算ステップを実行します。\fR
.SH "SMART SERVICE GIT\-RECEIVE\-PACK"
.sp
このサービスは、 \fB$GIT_URL\fR が指すリポジトリから読み込みます。
.sp
クライアントは、最初に \fB$GIT_URL/info/refs?service=git\-receive\-pack\fR を使用して ref 検出を実行する必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
C: POST $GIT_URL/git\-receive\-pack HTTP/1\&.0
C: Content\-Type: application/x\-git\-receive\-pack\-request
C:
C: \&.\&.\&.\&.0a53e9ddeaddad63ad106860237bbf53411d11a7 441b40d833fdfa93eb2908e52742248faf0ee993 refs/heads/maint\e0 report\-status
C: 0000
C: PACK\&.\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
S: 200 OK
S: Content\-Type: application/x\-git\-receive\-pack\-result
S: Cache\-Control: no\-cache
S:
S: \&.\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
クライアントは、キャッシュされた応答を再利用(reuse)または再検証(revalidate)してはなりません。 サーバーは、応答のキャッシュを防ぐために十分な Cache\-Control ヘッダーを含める必要があります。
.sp
サーバーは、ここで定義されたすべての機能をサポートすべきです。
.sp
クライアントは、リクエスト本文で少なくとも 1 つのコマンドを送信する必要があります。 リクエストボディのコマンド部分内で、クライアントは、ref 検出を通じて取得した ID を old_id として送信する必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
update_request  =  command_list
                   "PACK" <binary data>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
command_list    =  PKT\-LINE(command NUL cap_list LF)
                   *(command_pkt)
command_pkt     =  PKT\-LINE(command LF)
cap_list        =  *(SP capability) SP
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
command         =  create / delete / update
create          =  zero\-id SP new_id SP name
delete          =  old_id SP zero\-id SP name
update          =  old_id SP new_id SP name
.fi
.if n \{\
.RE
.\}
.sp
TODO: 更に文書化する
.SH "REFERENCES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\m[blue]\fBRFC 1738: Uniform Resource Locators (URL)\fR\m[]\&\s-2\u[1]\d\s+2
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\m[blue]\fBRFC 2616: Hypertext Transfer Protocol \(em  HTTP/1\&.1\fR\m[]\&\s-2\u[2]\d\s+2
.RE
.SH "SEE ALSO"
.sp
\fBgitprotocol-pack\fR(5) \fBgitprotocol-capabilities\fR(5)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
RFC 1738: Uniform Resource Locators (URL)
.RS 4
\%http://www.ietf.org/rfc/rfc1738.txt
.RE
.IP " 2." 4
RFC 2616: Hypertext Transfer Protocol \(em  HTTP/1.1
.RS 4
\%http://www.ietf.org/rfc/rfc2616.txt
.RE
