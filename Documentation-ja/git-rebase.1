'\" t
.\"     Title: git-rebase
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-REBASE" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-rebase \- 別のベース先端の上にコミットを再適用します
.SH "SYNOPSIS"
.sp
.nf
\fIgit rebase\fR [\-i | \-\-interactive] [<options>] [\-\-exec <cmd>]
        [\-\-onto <newbase> | \-\-keep\-base] [<upstream> [<branch>]]
\fIgit rebase\fR [\-i | \-\-interactive] [<options>] [\-\-exec <cmd>] [\-\-onto <newbase>]
        \-\-root [<branch>]
\fIgit rebase\fR (\-\-continue | \-\-skip | \-\-abort | \-\-quit | \-\-edit\-todo | \-\-show\-current\-patch)
.fi
.sp
.SH "DESCRIPTION"
.sp
\fB<branch>\fR が指定されている場合、 「git rebase」は他の処理を行う前に自動で \fBgit switch <branch>\fR を実行します。それ以外の場合は、引き続き現在のブランチに滞在しています。
.sp
\fB<upstream>\fR が指定されていない場合、 \fBbranch\&.<name>\&.remote\fR と \fBbranch\&.<name>\&.mergebranch\fR オプションで構成されたアップストリーム(詳細は\fBgit-config\fR(1) 参照) および \fB\-\-fork\-point\fR オプションが想定されています。あなたが現在ブランチを一切使用していない場合、または、現在のブランチにアップストリームが構成されていない場合、リベースは中止(abort)されます。
.sp
現在のブランチでコミットによって行われたが、 \fB<upstream>\fR に無いすべての変更は、一時領域(temporary area)に保存されます。 これは \fBgit log <upstream>\&.\&.HEAD\fR で表示されるのと同じコミットのセットで、または \fB\-\-fork\-point\fR がアクティブな場合 \fBgit log \*(Aqfork_point\*(Aq\&.\&.HEAD\fR で表示されるのと同じコミットのセットで、または \fB\-\-root\fR オプションが指定されている場合 \fBgit log HEAD\fR で表示されるのと同じコミットのセットです。
.sp
現在のブランチは \fB<upstream>\fR にリセットされます。 または \fB\-\-onto\fR オプションが指定されている場合は \fB<newbase>\fR にリセットされます。 これは、 \fBgit reset \-\-hard <upstream>\fR (または \fB<newbase>\fR )とまったく同じ効果があります。 \fBORIG_HEAD\fR は、リセット前にブランチの先端を指すように設定されています。
.sp
以前に一時領域に保存されたコミットは、現在のブランチに1つずつ順番に再適用されます。注意: \fBHEAD\&.\&.<upstream>\fR でのコミットと同一のテキスト変更を導入する \fBHEAD\fR でのコミットは省略されることに注意してください(つまり、異なるコミットメッセージまたはタイムスタンプで、アップストリームで既に受け入れ済のパッチはスキップされます)。
.sp
マージに失敗すると、このプロセスが完全には自動で行われなくなる事があります。あなたは、このようなマージの失敗を解決し、そして \fBgit rebase \-\-continue\fR を実行する必要があります。 別のオプションとしては、 \fBgit rebase \-\-skip\fR でマージの失敗を引き起こしたコミットをバイパスすることです。そして、元の \fB<branch>\fR をチェックアウトし、\fB\&.git/rebase\-apply\fR 作業ファイルを削除するには、代わりにコマンド \fBgit rebase \-\-abort\fR を使用します。
.sp
以下の履歴が存在し、現在のブランチが \fBtopic\fR であるとします:
.sp
.if n \{\
.RS 4
.\}
.nf
          A\-\-\-B\-\-\-C topic
         /
    D\-\-\-E\-\-\-F\-\-\-G master
.fi
.if n \{\
.RE
.\}
.sp
.sp
この時点で、以下のコマンドのいずれかを実行します:
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase master
git rebase master topic
.fi
.if n \{\
.RE
.\}
.sp
そうすると以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                  A\*(Aq\-\-B\*(Aq\-\-C\*(Aq topic
                 /
    D\-\-\-E\-\-\-F\-\-\-G master
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fB注意\fR : 後者の形式は、 \fBgit checkout topic\fR の後に \fBgit rebase master\fR が続く省略形です。 リベースが終了すると、チェックアウトされたブランチ(\fBtopic\fR)のままになります。
.sp
(たとえば、アップストリームに適用されたパッチをメールで送信したため)アップストリームブランチにすでに行った変更が含まれている場合、そのコミットはスキップされ、警告が発行されます(\fBmerge\fR バックエンドが使用されている場合)。たとえば、以下の履歴で \fBgit rebase master\fR を実行します(\fBA\*(Aq\fR と \fBA\fR は同じ変更セットを導入しますが、コミッター情報は異なります):
.sp
.if n \{\
.RS 4
.\}
.nf
          A\-\-\-B\-\-\-C topic
         /
    D\-\-\-E\-\-\-A\*(Aq\-\-\-F master
.fi
.if n \{\
.RE
.\}
.sp
.sp
これの結果は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                   B\*(Aq\-\-\-C\*(Aq topic
                  /
    D\-\-\-E\-\-\-A\*(Aq\-\-\-F master
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、あるブランチに基づいてトピックブランチを別のブランチに移植し、 \fBrebase \-\-onto\fR を使用して、トピックブランチを後者のブランチからフォークしたふりをする方法です。
.sp
まず、「topic」がブランチ「next」に基づいているとしましょう。 たとえば「topic」で開発された機能は、「next」にあるいくつかの機能に依存しています。
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
         \e
          o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  next
                           \e
                            o\-\-\-o\-\-\-o  topic
.fi
.if n \{\
.RE
.\}
.sp
.sp
我々は \fItopic\fR をブランチ \fImaster\fR からフォークさせたいのです。たとえば「topic」が依存する機能が、より安定した「master」ブランチにマージされたためです。 ツリーを以下のようにしたいわけです:
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
        |            \e
        |             o\*(Aq\-\-o\*(Aq\-\-o\*(Aq  topic
         \e
          o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  next
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、以下のコマンドを使用して取得できます:
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-onto master next topic
.fi
.if n \{\
.RE
.\}
.sp
\fB\-\-onto\fR オプションの別の例は、ブランチの一部をリベースすることです。 以下のような状況の場合:
.sp
.if n \{\
.RS 4
.\}
.nf
                            H\-\-\-I\-\-\-J topicB
                           /
                  E\-\-\-F\-\-\-G  topicA
                 /
    A\-\-\-B\-\-\-C\-\-\-D  master
.fi
.if n \{\
.RE
.\}
.sp
.sp
そして、以下のコマンドを実行します
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-onto master topicA topicB
.fi
.if n \{\
.RE
.\}
.sp
そうすると結果は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                 H\*(Aq\-\-I\*(Aq\-\-J\*(Aq  topicB
                /
                | E\-\-\-F\-\-\-G  topicA
                |/
    A\-\-\-B\-\-\-C\-\-\-D  master
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、topicBがtopicAに依存していない場合に役立ちます。
.sp
コミットの範囲は、リベースで削除することもできます。以下の状況の場合:
.sp
.if n \{\
.RS 4
.\}
.nf
    E\-\-\-F\-\-\-G\-\-\-H\-\-\-I\-\-\-J  topicA
.fi
.if n \{\
.RE
.\}
.sp
.sp
そして、以下のコマンドを実行します
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-onto topicA~5 topicA~3 topicA
.fi
.if n \{\
.RE
.\}
.sp
上記を実行すると、以下のようにコミットFとGが削除されます:
.sp
.if n \{\
.RS 4
.\}
.nf
    E\-\-\-H\*(Aq\-\-\-I\*(Aq\-\-\-J\*(Aq  topicA
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、 F と G に何らかの欠陥がある場合、または、topicA の一部であってはならない場合に役立ちます。注意: \fB\-\-onto\fR と \fB<upstream>\fR パラメーターの引数は、任意の有効なコミットっぽい何か(commit\-ish)にすることができることに注意してください。
.sp
競合が発生した場合、 \fBgit rebase\fR は最初の問題のあるコミットで停止し、ツリーに競合マーカーを残します。 あなたは \fBgit diff\fR を使用して、マーカー(\fB<<<<<<\fR)を見つけ、編集して競合を解決できます。編集するファイルごとに、競合が解決されたことをGitに通知する必要があります。通常、これは以下の方法で行います
.sp
.if n \{\
.RS 4
.\}
.nf
git add <filename>
.fi
.if n \{\
.RE
.\}
.sp
競合を手動で解決し、あなたが望んだ解決策でインデックスを更新した後、以下のコマンドでリベースプロセスを続行できます
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-continue
.fi
.if n \{\
.RE
.\}
.sp
あるいは、以下のように \fBgit rebase\fR を元に戻す(undo)こともできます
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-abort
.fi
.if n \{\
.RE
.\}
.SH "OPTIONS"
.PP
\fB\-\-onto <newbase>\fR
.RS 4
新しいコミットを作成する開始点を指定します。
\fB\-\-onto\fR
オプションが指定されていない場合、開始点は
\fB<upstream>\fR
です。これは、既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。
.sp
特別な場合として、マージベースが1つしかない場合は、あなたはAとBのマージベースのショートカットとして "A\&.\&.\&.B" を使用できます。最大でAとBのいずれかを省略できます。その場合、デフォルトでHEADになります。
.RE
.PP
\fB\-\-keep\-base\fR
.RS 4
\fB<upstream>\fR
の
\fB<branch>\fR
のマージベースへの新しいコミットを作成する開始点を設定します。
\fBgit rebase \-\-keep\-base <upstream> <branch>\fR
を実行することは
\fBgit rebase \-\-onto <upstream>\&.\&.\&.<branch> <upstream> <branch>\fR
を実行することと同じです。
.sp
このオプションは、アップストリームブランチの先頭で機能を開発している場合に役立ちます。この機能が働いている間に、アップストリームのブランチが進むことがあり、アップストリームの先頭にリベースを続けるのは得策ではなく、ベースのコミットをそのままにしておくことがあります。
.sp
このオプションと
\fB\-\-fork\-point\fR
はどちらも
\fB<upstream>\fR
と
\fB<branch>\fR
の間のマージベースを検索します。しかし、このオプションは新しいコミットが作成される「開始点」としてマージベースを使用します。一方
\fB\-\-fork\-point\fR
はマージベースを使用して、リベースされる「コミットのセット」を決定します。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
<upstream>
.RS 4
比較するアップストリームブランチ。既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。デフォルトは、現在のブランチ用に構成されたアップストリームです。
.RE
.PP
<branch>
.RS 4
作業するブランチ。デフォルトはHEADです。
.RE
.PP
\fB\-\-continue\fR
.RS 4
マージの競合を解決した後、リベースプロセスを再開します。
.RE
.PP
\fB\-\-abort\fR
.RS 4
リベース操作を中止(abort)し、
\fBHEAD\fR
を元のブランチにリセットします。リベース操作の開始時に
\fB<branch>\fR
が指定された場合、\fBHEAD\fR
は
\fB<branch>\fR
にリセットされます。それ以外の場合、
\fBHEAD\fR
はリベース操作が開始されたときの位置にリセットされます。
.RE
.PP
\fB\-\-quit\fR
.RS 4
リベース操作を中止(abort)しますが、HEADは元のブランチにリセットされません。その結果、インデックスと作業ツリーも変更されません。
\fB\-\-autostash\fR
を使用して一時的なstashエントリが作成された場合、それはstashリストに保存されます。
.RE
.PP
\fB\-\-apply\fR
.RS 4
適用戦略(applying strategies)を使用してリベースします(内部で
\fBgit\-am\fR
を呼び出します)。このオプションは、マージバックエンドがapplyのすべてを処理すると、将来的には動作しなくなる可能性があります。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-empty={drop,keep,ask}\fR
.RS 4
任意のアップストリームコミットの、開始時は空ではなく、かつ、クリーンでは無いチェリーピックであるが、(すでにアップストリームの変更のサブセットが含まれているため、)リベース後に空になるコミットを処理する方法。dropを使用すると、空になるコミットはドロップされます(これがデフォルトです)。keepを使用すると、そのようなコミットは保持されます。 ask を使用すると、空のコミットが適用されるとリベースが停止し、ドロップするか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます(\fB\-\-interactive\fR
の指定を含んでいます)。\fB\-\-exec\fR
などの他のオプションでは、
\fB\-i\fR/\fB\-\-interactive\fR
が明示的に指定されていない限り、デフォルトのドロップが使用されます。
.sp
注意: (\fB\-\-no\-keep\-empty\fR
が指定されていない場合、)空で開始するコミットは保持され、(\fB\-\-reapply\-cherry\-picks\fR
が渡されない限り)準備ステップとして、(
\fBgit log \-\-cherry\-mark \&.\&.\&.\fR
によって決定される)クリーンなチェリーピックであるコミットが検出・ドロップされます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-no\-keep\-empty\fR, \fB\-\-keep\-empty\fR
.RS 4
リベースの前に空で始まるコミット(つまり、親から何も変更していないコミット)を結果に残さないようにします。 なぜなら、そのようなコミットを作成するには
\fBgit commit\fR
に
\fB\-\-allow\-empty\fR
というオーバーライドするフラグを渡す必要があり、これはユーザーが意図的にそのようなコミットを作成し、それを保持したいことを意味しているからです。
.sp
対話的なリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などの為の便利なショートカットとして存在します。
.sp
開始時は空でないが、リベース後に空になるコミットについては、
\fB\-\-empty\fR
フラグを参照してください。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-reapply\-cherry\-picks\fR, \fB\-\-no\-reapply\-cherry\-picks\fR
.RS 4
我先にドロップしてしまうのではなく、アップストリームコミットのすべてのクリーンなチェリーピックを再適用します。 （これらのコミットがリベース後に空になった場合、それらにはすでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は `\-\-empty`フラグによって制御されます。）
.sp
デフォルト(または
\fB\-\-no\-reapply\-cherry\-picks\fR
が指定されている場合)では、これらのコミットは自動的にドロップされます。 これにはすべてのアップストリームコミットを読み取る必要があるため、読み取る必要のあるアップストリームコミットが多数あるリポジトリではコストがかかる可能性があります。
\fBmerge\fR
バックエンドを使用する場合、（\fB\-\-quiet\fR
が指定されていない限り）ドロップされたコミットごとに警告が発行されます。
\fBadvice\&.skippedCherryPicks\fR
がfalseに設定されていない限り、アドバイスも表示されます (\fBgit-config\fR(1)
を参照)。
.sp
\fB\-\-reapply\-cherry\-picks\fR
を使用すると、リベースはすべてのアップストリームコミットの読み取りを放棄できるため、パフォーマンスが向上する可能性があります。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-allow\-empty\-message\fR
.RS 4
何も操作しません。空のメッセージでコミットをリベースすると失敗(fail)しますが、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできます。つまり、空のメッセージでコミットしても、リベースは停止(halt)しません。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-skip\fR
.RS 4
現在のパッチをスキップして、リベースプロセスを再開します。
.RE
.PP
\fB\-\-edit\-todo\fR
.RS 4
対話リベース中にToDoリストを編集します。
.RE
.PP
\fB\-\-show\-current\-patch\fR
.RS 4
対話的なリベース、または、競合のためにリベースが停止されたときに、現在のパッチを表示します。 これは
\fBgit show REBASE_HEAD\fR
と同等です。
.RE
.PP
\fB\-m\fR, \fB\-\-merge\fR
.RS 4
マージ戦略(merging strategies)を使用してリベースします(デフォルト)。
.sp
リベースマージは、<upstream>ブランチの上にある作業ブランチからの各コミットをリプレイすることによって機能することに注意してください。このため、マージの競合が発生した場合、
\fBours\fR
として報告される側は、<upstream>で始まるこれまでのリベースされたシリーズであり、
\fBtheirs\fR
は作業ブランチです。 つまり、サイドが入れ替わっています。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-s <strategy>\fR, \fB\-\-strategy=<strategy>\fR
.RS 4
デフォルトの
\fBort\fR
の代わりに、指定のマージ戦略を使用します。 このオプションは
\fB\-\-merge\fR
の指定を含んでいます。
.sp
\fBgit rebase\fR
は、指定された戦略を使用して<upstream>ブランチの上にある作業ブランチからの各コミットをリプレイするため、
\fBours\fR
戦略を使用すると、<branch>からすべてのパッチが空になります。これはほとんど意味がありません。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-X <strategy\-option>\fR, \fB\-\-strategy\-option=<strategy\-option>\fR
.RS 4
<strategy\-option>をマージ戦略に渡します。 これは
\fB\-\-merge\fR
の指定を含んでいて、戦略が指定されていない場合は
\fB\-s ort\fR
を意味します。
\fB\-m\fR
オプションにて上記で述べたように、「ours」と「theirs」が逆になっていることに注意してください。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-rerere\-autoupdate\fR, \fB\-\-no\-rerere\-autoupdate\fR
.RS 4
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。
\fB\-\-no\-rerere\-autoupdate\fR
は、別の
\fBgit add\fR
で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。
.RE
.PP
\fB\-S[<keyid>]\fR, \fB\-\-gpg\-sign[=<keyid>]\fR, \fB\-\-no\-gpg\-sign\fR
.RS 4
GPG署名コミットです。
\fBkeyid\fR
引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに串刺しする必要があります。
\fB\-\-no\-gpg\-sign\fR
は、\fBcommit\&.gpgSign\fR
構成変数と、それより前で指定した
\fB\-\-gpg\-sign\fR
オプションの、その両方を打ち消すのに役立ちます。
.RE
.PP
\fB\-q\fR, \fB\-\-quiet\fR
.RS 4
静かにします。\fB\-\-no\-stat\fR
の指定を含みます。
.RE
.PP
\fB\-v\fR, \fB\-\-verbose\fR
.RS 4
おしゃべりにします。
\fB\-\-stat\fR
の指定を含みます。
.RE
.PP
\fB\-\-stat\fR
.RS 4
最後のリベース以降にアップストリームで変更されたもののdiffstatを表示します。 diffstatは、構成オプション rebase\&.stat によっても制御されます。
.RE
.PP
\fB\-n\fR, \fB\-\-no\-stat\fR
.RS 4
リベース処理の一部としてdiffstatを表示しないでください。
.RE
.PP
\fB\-\-no\-verify\fR
.RS 4
このオプションは、リベース前のフック(pre\-rebase hook)をバイパスします。
\fBgithooks\fR(5)
も参照してください。
.RE
.PP
\fB\-\-verify\fR
.RS 4
リベース前フック(pre\-rebase hook)の実行を許可します。これがデフォルトです。このオプションは、
\fB\-\-no\-verify\fR
をオーバーライドするために使用できます。
\fBgithooks\fR(5)
も参照してください。
.RE
.PP
\fB\-C<n>\fR
.RS 4
各変更の前後で、少なくとも <n> 行の周囲のコンテキストが一致することを確認する。 周囲の文脈の行数が少ない場合は、すべて一致させなければならない。 デフォルトでは、コンテキストは無視されます。
\fB\-\-apply\fR
の指定を含んでいます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-no\-ff\fR, \fB\-\-force\-rebase\fR, \fB\-f\fR
.RS 4
変更されていないコミットを早送りす(fast\-forward)るのではなく、リベースされたすべてのコミットを個別にリプレイします。これにより、リベースされたブランチの履歴全体が新しいコミットで構成されることが保証されます。
.sp
トピックブランチのマージを取り消した後にこのオプションを使うと便利です。このオプションはトピックブランチを新しいコミットで再作成するので、「戻しを戻す」(revert the reversion)必要はありません (詳細は
\m[blue]\fBrevert\-a\-faulty\-merge How\-To\fR\m[]\&\s-2\u[1]\d\s+2
をご覧ください)。
.RE
.PP
\fB\-\-fork\-point\fR, \fB\-\-no\-fork\-point\fR
.RS 4
<branch>によって導入されたコミットを計算するときに、reflogを使用して、<upstream>と<branch>の間の、より一般的な祖先を見つけます。
.sp
\fB\-\-fork\-point\fR
がアクティブな場合、<upstream>の代わりに
\fBfork_point\fR
を使用して、リベースするコミットのセットを計算します。ここで、
\fBfork_point\fR
は、
\fBgit merge\-base \-\-fork\-point <upstream> <branch>\fR
コマンドの結果です（\fBgit-merge-base\fR(1)
参照）。
\fBfork_point\fR
が空になると、<upstream>がフォールバックとして使用されます。
.sp
コマンドラインで<upstream>が指定されている場合、デフォルトは
\fB\-\-no\-fork\-point\fR
です。それ以外の場合、デフォルトは
\fB\-\-fork\-point\fR
です。
\fBgit-config\fR(1)
の
\fBrebase\&.forkpoint\fR
も参照してください。
.sp
あなたのブランチが<upstream>に基づいていたが、<upstream>が巻き戻され、あなたのブランチにドロップされたコミットが含まれている場合、あなたのブランチからそれらのコミットをドロップするために、このオプションを
\fB\-\-keep\-base\fR
とともに使用できます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-ignore\-whitespace\fR
.RS 4
差分を調整しようとするときは、空白の違いを無視してください。現在、各バックエンドはこの振る舞いの近似を実装しています:
.PP
apply backend
.RS 4
パッチを適用するときは、コンテキスト行の空白(whitespace)の変更を無視してください。残念ながら、これは、パッチによって置き換えられる「古い」行が既存のファイルと空白(whitespace)のみが異なる場合、パッチアプリケーションが成功する代わりに、マージの競合が発生することを意味します。
.RE
.PP
merge backend
.RS 4
空白(whitespace)のみが変更された行は、マージ時に変更されていないものとして扱います。残念ながら、これは、反対側に競合する変更がなかったとしても、空白(whitespace)を変更することを目的としたパッチハンクがドロップされることを意味します。
.RE
.RE
.PP
\fB\-\-whitespace=<option>\fR
.RS 4
このフラグは、パッチを適用する
\fBgit apply\fR
プログラム(\fBgit-apply\fR(1)
参照)に渡されます。
\fB\-\-apply\fR
の指定を含んでいます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-committer\-date\-is\-author\-date\fR
.RS 4
現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。このオプションは、
\fB\-\-force\-rebase\fR
の指定を含んでいます。
.RE
.PP
\fB\-\-ignore\-date\fR, \fB\-\-reset\-author\-date\fR
.RS 4
元のコミットの作成者の日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者の日付として使用します。 このオプションは、
\fB\-\-force\-rebase\fR
の指定を含んでいます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-signoff\fR
.RS 4
すべてのリベースされたコミットに
\fBSigned\-off\-by\fR
トレーラーを追加します。注意:
\fB\-\-interactive\fR
が指定されている場合、pick または edit または reword のマークが付けられたコミットのみにトレーラーが追加されることに注意してください。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-i\fR, \fB\-\-interactive\fR
.RS 4
リベースされようとしているコミットのリストを作成します。リベースする前に、ユーザーにそのリストを編集させます。このモードは、コミットの分割にも使用できます（以下の「SPLITTING COMMITS」を参照）。
.sp
コミットリストの書式は、構成オプション rebase\&.instructionFormat を設定することで変更できます。カスタマイズされた命令書式では、書式の前に長いコミットハッシュが自動的に追加されます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-r\fR, \fB\-\-rebase\-merges[=(rebase\-cousins|no\-rebase\-cousins)]\fR
.RS 4
デフォルトでは、リベースはtodoリストからマージコミットを削除し、リベースされたコミットを単一の線形ブランチに配置します。
\fB\-\-rebase\-merges\fR
を使用すると、リベースは代わりに、マージコミットを再作成することにより、リベースされるコミット内の分岐構造を保持しようとします。これらのマージコミットで解決されたマージの競合または手動の修正(amend)は、手動で 解決/再適用 する必要があります。
.sp
デフォルト、または
\fBno\-rebase\-cousins\fR
が指定された場合、直接の祖先として
\fB<upstream>\fR
を持たないコミットは元の分岐点を保持します。つまり、
\fBgit-log\fR(1)
の
\fB\-\-ancestry\-path\fR
オプションによって除外されるコミットは、デフォルトで元の祖先を保持します。
\fBrebase\-cousins\fR
モードがオンになっている場合、そのようなコミットは代わりに
\fB<upstream>\fR
（または指定されている場合は
\fB<onto>\fR
）にリベースされます。
.sp
現在、
\fBort\fR
マージ戦略を使用してのみマージコミットを再作成することが可能です。異なるマージ戦略は、明示的な
\fBexec git merge \-s <strategy> [\&.\&.\&.]\fR
コマンドを介してのみ使用できます。
.sp
下記の「REBASING MERGES」と「INCOMPATIBLE OPTIONS」も参照してください。
.RE
.PP
\fB\-x <cmd>\fR, \fB\-\-exec <cmd>\fR
.RS 4
最終履歴にコミットを作成する各行の後に
\fBexec <cmd>\fR
を追加します。
\fB<cmd>\fR
は、1つ以上のシェルコマンドとして解釈されます。 失敗したコマンドは、exit code 1でリベースを中断(interrupt)します。
.sp
\fB\-\-exec\fR
の1つのインスタンスを複数のコマンドで使用することにより、複数のコマンドを実行できます:
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-i \-\-exec "cmd1 && cmd2 && \&.\&.\&."
.fi
.if n \{\
.RE
.\}
.sp
または、複数の
\fB\-\-exec\fR
を指定します:
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-i \-\-exec "cmd1" \-\-exec "cmd2" \-\-exec \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
\fB\-\-autosquash\fR
が使用されている場合、
\fBexec\fR
行は中間コミットに追加されず、各 squash/fixup シリーズの最後にのみ現れます。
.sp
これは内部で
\fB\-\-interactive\fR
機構を使用しますが、明示的な
\fB\-\-interactive\fR
の指定なしで実行できます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-root\fR
.RS 4
<upstream>で制限するのではなく、<branch>から到達可能なすべてのコミットをリベースします。 これにより、ブランチのルートコミットをリベースできます。
\fB\-\-onto\fR
と一緒に使用すると、（<upstream>ではなく、）<newbase>にすでに含まれている変更をスキップしますが、
\fB\-\-onto\fR
を使用しない場合は、すべての変更に対して機能します。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-autosquash\fR, \fB\-\-no\-autosquash\fR
.RS 4
コミットログメッセージが「squash! \&...」または「fixup! \&...」または「amend! \&...」で始まり、同一の
\fB\&.\&.\&.\fR
に一致するコミットがすでにtodoリストにある場合、
\fBrebase \-i\fR
のtodoリストを自動的に変更して、squashするようにマークされたコミットが、変更するコミットの直後に来るようにし、移動したコミットのアクションをそれぞれ
\fBpick\fR
から、
\fBsquash\fR
または
\fBfixup\fR
または
\fBfixup\-C\fR
に変更します。 コミットの件名が一致する場合、または
\fB\&.\&.\&.\fR
がコミットのハッシュを参照する場合、コミットは
\fB\&.\&.\&.\fR
と一致します。フォールバックとして、コミットサブジェクトの部分一致も機能します。 fixup/amend/squash コミットを作成するための推奨される方法は、
\fBgit-commit\fR(1)
のそれぞれ
\fB\-\-fixup\fR
または
\fB\-\-fixup=amend:\fR
または
\fB\-\-fixup=reword:\fR
と、\fB\-\-squash\fR
オプションを使用することです。
.sp
構成変数
\fBrebase\&.autoSquash\fR
を使用して
\fB\-\-autosquash\fR
オプションがデフォルトで有効になっている場合、このオプションを使用して、この設定をオーバーライドおよび無効にすることができます。
.sp
下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
.RE
.PP
\fB\-\-autostash\fR, \fB\-\-no\-autostash\fR
.RS 4
操作を開始する前に一時的なスタッシュエントリを自動的に作成し、操作の終了後に適用します。これは、汚れたワークツリー(dirty worktree)でリベースを実行できることを意味します。ただし、注意して使用してください。リベース成功後のスタッシュ適用の際、重要な競合を引き起こす可能性があります。
.RE
.PP
\fB\-\-reschedule\-failed\-exec\fR, \fB\-\-no\-reschedule\-failed\-exec\fR
.RS 4
失敗した
\fBexec\fR
コマンドを自動的に再スケジュールします。 これは、対話モード(または
\fB\-\-exec\fR
オプションが提供された場合)でのみ意味があります。
.sp
このオプションは、リベースが開始されると適用されますが、これは、
\fBrebase\&.rescheduleFailedExec\fR
構成(\fBgit-config\fR(1)
または 下記「CONFIGURATION」参照)、またはこのオプションが提供されているかどうかに基づいて、最初にリベース全体に設定されます。でなければ、開始時の明示的な
\fB\-\-no\-reschedule\-failed\-exec\fR
が、
\fBrebase\&.rescheduleFailedExec=true\fR
構成の存在によって上書きされます。
.RE
.PP
\fB\-\-update\-refs\fR, \fB\-\-no\-update\-refs\fR
.RS 4
リベースされているコミットを指すブランチを自動的に強制更新します。 ワークツリーでチェックアウトされたブランチは、この方法では更新されません。
.sp
構成変数
\fBrebase\&.updateRefs\fR
が設定されている場合、このオプションを使用して、この設定をオーバーライドして無効にすることができます。
.RE
.SH "INCOMPATIBLE OPTIONS(互換性の無いオプション)"
.sp
これらのオプション:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-apply\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-whitespace\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-C\fR
.RE
.sp
は、以下のオプションと互換性がありません:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-merge\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-strategy\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-strategy\-option\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-allow\-empty\-message\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-[no\-]autosquash\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-rebase\-merges\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-interactive\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-exec\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-no\-keep\-empty\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-empty=\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-reapply\-cherry\-picks\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-edit\-todo\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-update\-refs\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-root\fR
。\fB\-\-onto\fR
と組み合わせて使用する場合。
.RE
.sp
さらに、以下のオプションの組み合わせには互換性がありません:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-keep\-base\fR
と
\fB\-\-onto\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-keep\-base\fR
と
\fB\-\-root\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-fork\-point\fR
と
\fB\-\-root\fR
.RE
.SH "BEHAVIORAL DIFFERENCES(振る舞いの違い)"
.sp
git rebaseには、 \fBapply\fR と \fBmerge\fR の2つの主要バックエンドがあります。 (\fBapply\fR バックエンドは以前は \fBam\fR バックエンド と呼ばれていましたが、名詞ではなく動詞のように見えるため混乱を招きました。また、 \fBmerge\fR バックエンドは以前は \fBinteractive\fR バックエンドと呼ばれていましたが、現在は 非対話型の場合にも使用されます。どちらも、それぞれを支える低レベルの機能に基づいて名前が変更されました。）これら2つのバックエンドの振る舞いには微妙な違いがあります:
.SS "空のコミット"
.sp
\fBapply\fR バックエンドは、残念ながら意図的に空のコミット、つまり空で開始されたコミットを削除しますが、これらは実際にはまれです。また、空になるコミットを削除したり、その振る舞いを制御するオプションがありません。
.sp
\fBmerge\fR バックエンドは、デフォルトで意図的に空のコミットを保持します(ただし、 \fB\-i\fR を使用すると、todoリストエディタでemptyとしてマークされます。または、 \fB\-\-no\-keep\-empty\fR を使用して自動的に削除できます)。
.sp
適用バックエンドと同様に、デフォルトでは、mergeバックエンドは、 \fB\-i\fR/\fB\-\-interactive\fR が指定されていない限り、空になるコミットをドロップします(この場合、mergeバックエンドは停止(stop)し、ユーザーに何をすべきかを尋ねます)。mergeバックエンドには、空になったコミットの処理動作を変更するための \fB\-\-empty={drop,keep,ask}\fR オプションもあります。
.SS "ディレクトリ名変更の検知"
.sp
正確なツリー情報が不足している(パッチで利用可能な限られた情報で偽の祖先を構築するために生じる)ため、 \fBapply\fR バックエンドでディレクトリ名変更の検出が無効になっています。 ディレクトリ名前変更の検出が無効になっているということは、 履歴の一方がディレクトリの名前を変更し、 もう一方が古いディレクトリに新しいファイルを追加した場合に、 リベース時にこれらのファイルを新しいディレクトリに移動したいという警告なしに、 新しいファイルが古いディレクトリに残されます。
.sp
ディレクトリ名変更の検出は、 \fBmerge\fR バックエンドと連携して、このような場合に警告を出します。
.SS "Context"
.sp
適用バックエンドは、（内部で \fBformat\-patch\fR を呼び出すことにより、）パッチのシーケンスを作成し、次にパッチを順番に適用することにより（内部で \fBam\fR を呼び出すことにより）機能します。パッチは複数のハンクで構成されており、それぞれに行番号、コンテキストリージョン、および実際の変更が含まれています。反対側がファイルの前に行を挿入または削除した可能性があるため、行番号はある程度曖昧にする必要があります。コンテキスト領域(context region)は、正しい行に変更を適用するために行番号を調整する方法を見つけるのに役立つことを目的としています。ただし、コードの複数の領域に同じ周囲のコンテキスト行がある場合、間違った領域が選択される可能性があります。これにより、競合が報告されずにコミットが誤って再適用される実際のケースがあります。 \fBdiff\&.context\fR をより大きな値に設定すると、このようなタイプの問題を防ぐことができますが、誤った競合の可能性が高くなります（適用するには、一致するコンテキストの行がより多く必要になるため）。
.sp
\fBmerge\fR バックエンドは、関連する各ファイルの完全なコピーを使って動作し、これらの種類の問題からファイルを保護します。
.SS "Labelling of conflicts markers"
.sp
コンテンツの競合がある場合、マージ機構は、コンテンツが由来するコミットでそれぞれの側の競合マーカーに注釈を付けようとします。 \fBapply\fR バックエンドは、リベースされたコミットとその親に関する元の情報を削除するため(代わりに、生成されたパッチの限られた情報に基づいて新しい偽のコミットを生成します)、それらのコミットを識別できません。 代わりに、コミットの要約にフォールバックする必要があります。また、 merge\&.conflictStyle が \fBdiff3\fR または \fBzdiff3\fR に設定されている場合、 \fBapply\fR バックエンドは「構築されたマージベース」を使用してマージベースのコンテンツにラベルを付けるため、マージベースのコミットに関する情報は一切提供されません。
.sp
\fBmerge\fR バックエンドは、履歴の両側で完全なコミットで動作するため、そのような制限はありません。
.SS "フック"
.sp
\fBapply\fR バックエンドは従来、コミット後フック(post\-commit hook)を呼び出していませんでしたが、 \fBmerge\fR バックエンドは呼び出していました。 \fBmerge\fR バックエンドはその出力を黙らせましたが、いまだ両方ともチェックアウト後フック(post\-checkout hook)を呼び出します。さらに、両方のバックエンドは、中間コミットや最終コミットではなく、リベースの開始点コミットでのみチェックアウト後フック(post\-checkout hook)を呼び出します。いずれの場合も、これらのフックの呼び出しは、そう設計したのではなく、実装の偶然によるものでした(両方のバックエンドは元々シェルスクリプトとして実装されており、フックを呼び出す \fBgit checkout ` や `git commit\fR などの他のコマンドをたまたま呼び出していました)。どちらが正しいかは完全には明らかではありませんが、両方のバックエンドの動作は同じであるべきです。将来的には、リベースがこれらのフックのいずれかを呼び出すのを停止する可能性があります。
.SS "Interruptability(割り込み可能性)"
.sp
\fBapply\fR バックエンドには、タイミングの悪い割り込みによる安全上の問題があります。ユーザーが間違ったタイミングで Ctrl\-C を押してリベースを中止しようとすると、リベースは、後続の \fBgit rebase \-\-abort\fR で中止できない状態になる可能性があります。 \fBmerge\fR バックエンドには、同様の欠点は見られません。(詳細については、 \m[blue]\fBhttps://lore\&.kernel\&.org/git/20200207132152\&.GC2868@szeder\&.dev/\fR\m[] を参照してください。)
.SS "Commit Rewording"
.sp
リベース中に競合が発生すると、リベースが停止(stop)し、ユーザーに解決を求めます。 ユーザーは競合の解決中に注目すべき変更を加える必要がある場合があるため、競合が解決され、ユーザーが \fBgit rebase \-\-continue\fR を実行した後、リベースはエディターを開き、ユーザーにコミットメッセージを更新するように依頼する必要があります。 \fBmerge\fR バックエンドはこれを行いますが、 \fBapply\fR バックエンドは元のコミットメッセージを盲目的に適用します。
.SS "Miscellaneous differences"
.sp
ほとんどの人がおそらく取るに足らないと考えるであろうが、完全性のために言及されているいくつかの振る舞いの違いがあります:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Reflog: 2つのバックエンドは、reflogで行われた変更を説明するときに異なる表現を使用しますが、どちらも「リベース」という単語を使用します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
進行状況、情報、エラーメッセージ について: 2つのバックエンドは、わずかに異なる進行状況と情報メッセージを提供します。また、applyバックエンドはエラーメッセージ（「Your files would be overwritten\&...」など）をstdoutに書き込み、mergeバックエンドはそれらをstderrに書き込みます。
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
状態ディレクトリ: 2つのバックエンドは、
\fB\&.git/\fR
の下の異なるディレクトリに状態を保持します
.RE
.RE
.SH "MERGE STRATEGIES"
.sp
マージ機構(\fBgit merge\fR と \fBgit pull\fR コマンド)では、バックエンドの「マージ戦略」を \fB\-s\fR オプションで選択することができます。 いくつかの戦略では、独自のオプションを指定することができます。これは、 \fBgit merge\fR や \fBgit pull\fR に \fB\-X<option>\fR 引数として渡すことができます。
.PP
ort
.RS 4
これは、1つのブランチをプルまたはマージするときのデフォルトのマージ戦略です。この戦略では、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。これにより、Linux 2\&.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。さらに、この戦略では、名前の変更を伴うマージを検出して処理できます。検出されたコピーは使用しません。このアルゴリズムの名前は "Ostensibly Recursive\(cqs Twin" (表面上は再帰の双子)の頭文字を取ったものであり、以前のデフォルトのアルゴリズムである「recursive」の代わりとして作成されたという事実に由来しています。
.sp
\fBort\fR
戦略は、以下のオプションを取ることができます:
.PP
ours
.RS 4
このオプションは、「our」バージョンを優先することにより、競合するハンクをクリーンに自動解決するように強制します。 our側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリファイルの場合、内容全体がour側から取得されます。
.sp
これを「ours」マージ戦略と混同しないでください。この戦略では、他のツリーに何が含まれているのかさえまったく調べません。それは他のツリーが行ったすべてを破棄し、「our」履歴にはその中で起こったすべてが含まれていると宣言します。
.RE
.PP
theirs
.RS 4
これは「ours」の反対です。 「ours」とは異なり、このmergeオプションを混同する「theirs」マージ戦略はないことに注意してください。
.RE
.PP
ignore\-space\-change, ignore\-all\-space, ignore\-space\-at\-eol, ignore\-cr\-at\-eol
.RS 4
指示されたタイプの空白(whitespace)の変更を含む行を、3方向マージのために変更されていないものとして扱います。行に対する、他の変更と空白(whitespace)の変更との混合は、無視されません。
\fBgit-diff\fR(1)
の
\fB\-b\fR
と
\fB\-w\fR
と
\fB\-\-ignore\-space\-at\-eol\fR
と
\fB\-\-ignore\-cr\-at\-eol\fR
も参照してください。
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
「their」バージョンが行に空白の変更のみを導入する場合、「our」バージョンが使用されます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
「our」バージョンで空白の変更が導入されたが、「their」バージョンに大幅な変更が含まれている場合は、「their」バージョンが使用されます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
それ以外の場合、マージは通常の方法で進行します。
.RE
.RE
.PP
renormalize
.RS 4
これにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインが実行されます。このオプションは、ブランチをさまざまなクリーンフィルターまたは行末正規化ルールとマージするときに使用することを目的としています。詳細については、
\fBgitattributes\fR(5)
の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)を参照してください。
.RE
.PP
no\-renormalize
.RS 4
\fBrenormalize\fR
オプションを無効にします。 これは、
\fBmerge\&.renormalize\fR
構成変数をオーバーライドします。
.RE
.PP
find\-renames[=<n>]
.RS 4
名前変更(rename)の検出をオンにし、オプションで類似性のしきい値(similarity threshold)を設定します。これがデフォルトです。 これは、
\fBmerge\&.renames\fR
構成変数をオーバーライドします。
\fBgit-diff\fR(1)
の
\fB\-\-find\-renames\fR
も参照してください。
.RE
.PP
rename\-threshold=<n>
.RS 4
\fBfind\-renames=<n>\fR
の非推奨の同義語。
.RE
.PP
subtree[=<path>]
.RS 4
このオプションは「subtree」戦略をさらに発展させたもので、2つの木をマージする際に、どのようにずらせば互いにマッチするかを推測するものである。その代わり、指定されたパスは、2つの木の形が一致するように前置される(または、最初から取り除かれる)。
.RE
.RE
.PP
recursive
.RS 4
これは、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。 これにより、Linux 2\&.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。 さらに、これにより、名前変更を含むマージを検出して処理できます。 検出されたコピーは使用しません。 これは、Git v0\&.99\&.9k 〜 v2\&.33\&.0 まで、2つのヘッドを解決するためのデフォルトの戦略でした。
.sp
「recursive」(再帰的)戦略は「ort」と同じオプションを取る。 しかし、「ort」が無視する3つのオプション(上記には書かれていない)があり、 「recursive」戦略で有用となる可能性がある:
.PP
patience
.RS 4
\fBdiff\-algorithm=patience\fR
の非推奨の同義語。
.RE
.PP
diff\-algorithm=[patience|minimal|histogram|myers]
.RS 4
マージ中に別の差分アルゴリズムを使用すると、重要でない一致行(異なる関数の中括弧など)が原因で発生するミスマージを回避できます。
\fBgit-diff\fR(1)
\fB\-\-diff\-algorithm\fR
も参照してください。注意: 特に、「ort」は
\fBdiff\-algorithm=histogram\fR
を使用しますが、「recursive」はデフォルトで 「diff\&.algorithm」 設定を使う事に注意して下さい。
.RE
.PP
no\-renames
.RS 4
名前変更(rename)の検出をオフにします。 これは、\fBmerge\&.renames\fR
構成変数をオーバーライドします。
\fBgit-diff\fR(1)
の
\fB\-\-no\-renames\fR
も参照してください。
.RE
.RE
.PP
resolve
.RS 4
これは、3方向マージアルゴリズムを使用して、2つのヘッド（つまり、現在のブランチとプルした別のブランチ）のみを解決できます。 交差マージ(criss\-cross merge)のあいまいさを注意深く検出しようとします。 名前の変更は処理しません。
.RE
.PP
octopus
.RS 4
これにより、3つ以上のヘッドを持つケースが解決されますが、手動解決が必要な複雑なマージの実行は拒否されます。これは主に、トピックの分岐ヘッドを纏めるために使用されることを意図しています。これは、複数のブランチをプルまたはマージする場合のデフォルトのマージ戦略です。
.RE
.PP
ours
.RS 4
これにより、任意の数のヘッドが解決されますが、結果として得られるマージのツリーは常に現在のブランチヘッドのツリーであり、他のすべてのブランチからのすべての変更を事実上無視します。 これは、サイドブランチの古い開発履歴に取って代わるために使用されることを意図しています。 これは、「recursive」マージ戦略の
\fB\-Xours\fR
オプションとは異なることに注意してください。
.RE
.PP
subtree
.RS 4
これは改造された「ort」戦略です。 ツリーAとBをマージするとき、BがAのサブツリーに対応する場合、同じレベルのツリーを読み取るのではなく、Bは最初にAのツリー構造に一致するように調整されます。 この調整は、共通の祖先ツリーに対しても行われます。
.RE
.sp
3方向マージ(デフォルトの「ort」を含む)を使用する戦略では、両方のブランチで変更が行われたが、後で一方のブランチで元に戻された場合、その変更はマージされた結果に表示されます。一部の人々は、この振る舞いを混乱させると感じています。これは、個々のコミットではなく、ヘッドとマージベースのみがマージの実行時に考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンに置き換えます。
.SH "NOTES"
.sp
あなたは共有リポジトリで \fBgit rebase\fR を使用することの意味を理解する必要があります。下記「RECOVERING FROM UPSTREAM REBASE」も参照してください。
.sp
リベースを実行すると、最初にpre\-rebaseフックが存在する場合はそれが実行されます。このフックを使用して、健全性チェックを実行し、適切でない場合はリベースを拒否できます。例については、テンプレートの pre\-rebase hook スクリプトを参照してください。
.sp
完了すると、<branch>が現在のブランチになります。
.SH "INTERACTIVE MODE"
.sp
対話的にリベースするということは、あなたがリベースされるコミットを編集する機会があることを意味します。コミットを並べ替えたり、削除したりできます(不良パッチやその他の不要なパッチを削除します)。
.sp
対話モードは、以下のタイプの作業フローを対象としています:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
素晴らしいアイデアを思いついた
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
コードをハックハック
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
提出用のシリーズを準備
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
送信
.RE
.sp
ここで、 (2) は以下のいくつかの作業で構成されています
.sp
a) 普段
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
コミットに値する何かを終える
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
コミットする
.RE
.sp
b) 独立した修正
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
何かが機能しないことに気付く
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
そいつを修正
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
それをコミットする
.RE
.sp
bの(2) で修正したコミットがパッチシリーズの中に深く埋もれているために、完全ではないコミットに戻せない(amend)ことがあります。これこそが対話型リベースの目的です。たくさんの "a" と "b" の後に、コミットを並べ替えたり編集したり、複数のコミットをひとつにまとめたりするために使用します。
.sp
そのまま保持したい最後のコミットから開始します:
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-i <after\-this\-commit>
.fi
.if n \{\
.RE
.\}
.sp
エディターは、あなたの現在のブランチのすべてのコミット(マージコミットは無視)で起動されます。これは、指定のコミットの後に発生します。あなたは、このリストのコミットを心ゆくまで並べ替えたり、削除したりできます。そして、リストは多かれ少なかれ以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
1行説明は、純粋にあなたの備忘のためです。 \fBgit rebase\fR はそれらを参照せず、コミット名（この例では "deadbee" と "fa1afe1" ）を参照するため、名前を削除または編集しないでください。
.sp
コマンド「pick」をコマンド「edit」に置き換えることで、 \fBgit rebase\fR にそのコミットを適用した後に停止(stop)するように指示できます。これにより、あなたはファイルやコミットメッセージを編集し、コミットを修正(amend)して、リベースを続行できます。
.sp
リベースを中断するには(\fBedit\fR コマンドと同様、ただし最初にコミットを選択せずに)、 \fBbreak\fR コマンドを使用します。
.sp
あなたがコミットのコミットメッセージを編集したいだけの場合は、コマンド \fBpick\fR をコマンド \fBreword\fR に置き換えます。
.sp
コミットを削除するには、コマンド \fBpick\fR を \fBdrop\fR に置き換えるか、あるいはマッチする行を削除します。
.sp
2つ以上のコミットを1つにまとめる場合は、2番目以降のコミットのコマンド pick を squash または fixup に置き換えます。コミットに異なる作者がいた場合、折りたたまれたコミットは最初のコミットの作者に帰属します。折りたたまれたコミットに対して推奨されるコミットメッセージは、最初のコミットのメッセージと squash コマンドで識別されるメッセージを連結したもので、 \fBfixup \-c\fR が使用されていない限り、fixupコマンドで識別されるコミットのメッセージは省略されます。\fBfixup \-c\fR が使用された場合、提案されたコミットメッセージは \fBfixup \-c\fR コミットのメッセージのみであり、エディタが開いてメッセージを編集できます。 \fBfixup \-c\fR コミットの内容(パッチ)は、折りたたまれたコミットに引き続き組み込まれます。 \fBfixup \-c\fR コミットが複数ある場合は、最後のコミットからのメッセージが使用されます。あなたは \fBfixup \-C\fR を使用して、エディターを開かないことを除いて \fBfixup \-c\fR と同じ動作をさせることもできます。
.sp
「git rebase」は、 pick が edit に置き換えられたとき、またはマージエラーのためにコマンドが失敗したときに停止(stop)します。 競合の編集や解決が完了したら、 あなたは \fBgit rebase \-\-continue\fR で続行できます。
.sp
たとえば、最後の5つのコミットを並べ替えて、 HEAD~4 であったものが新しいHEADになるようにします。これを実現するには、以下のように「git rebase」を呼び出します:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rebase \-i HEAD~5
.fi
.if n \{\
.RE
.\}
.sp
.sp
そして、最初のパッチをリストの最後に移動します。
.sp
たとえば、あなたが以下のような履歴を持っているなら、マージコミットを再作成することをお勧めします:
.sp
.if n \{\
.RS 4
.\}
.nf
           X
            \e
         A\-\-\-M\-\-\-B
        /
\-\-\-o\-\-\-O\-\-\-P\-\-\-Q
.fi
.if n \{\
.RE
.\}
.sp
.sp
あなたは A から Q までのブランチをリベースしたいとします。現在のHEADが B であることを確認して、以下を実行します
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rebase \-i \-r \-\-onto Q O
.fi
.if n \{\
.RE
.\}
.sp
.sp
コミットの並べ替えと編集は通常、テストされていない中間ステップを作成します。テストを実行するか、少なくとも「exec」コマンド(ショートカット「x」)を使用して履歴の中間ポイントで再コンパイルすることにより、履歴の編集で何も壊れていないことを確認することをお勧めします。これを行うには、以下のようなToDoリストを作成します:
.sp
.if n \{\
.RS 4
.\}
.nf
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
コマンドが失敗すると（つまり、0以外のステータスで終了すると）、対話的リベースが停止(stop)し、あなたには問題を修正する機会が与えられます。あなたは \fBgit rebase \-\-continue\fR で続行できます。
.sp
「exec」コマンドは、シェル(\fB$SHELL\fR で指定されたもの、または \fB$SHELL\fR が設定されていない場合はデフォルトのシェル)でコマンドを起動するため、シェル機能("cd"、">"、";" など)を使用できます。コマンドは、作業ツリーのルートから実行されます。
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rebase \-i \-\-exec "make test"
.fi
.if n \{\
.RE
.\}
.sp
.sp
このコマンドを使用すると、あなたは中間コミット(intermediate commits)がコンパイル可能であることを確認できます。ToDoリストは以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test
.fi
.if n \{\
.RE
.\}
.sp
.SH "SPLITTING COMMITS"
.sp
対話モードでは、アクション「edit」でコミットをマークできます。 ただし、これは必ずしも「git rebase」がこの編集の結果が正確に1つのコミットであることを期待していることを意味するわけではありません。 実際、あなたはコミットを元に戻す(undo)ことも、他のコミットを追加することもできます。そしてこれは、コミットを2つに分割するために使用できます:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit rebase \-i <commit> ^\fR
を使用して対話的リベースを開始します。ここで、<commit> はあなたが分割したいコミットです。 実際、そのコミットが含まれている限り、どんなコミット範囲でもかまいません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
あなたが分割したいコミットを、 アクション
\fBedit\fR
でマークします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
そのコミットを編集する場合は、
\fBgit reset HEAD^\fR
を実行します。 その効果は、HEADが1つ巻き戻され、インデックスがそれに追随することです。 ただし、作業ツリーは同じままです。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
次に、最初のコミットで必要な変更をインデックスに追加します。 これを行うには、 （おそらく対話的に）\fBgit add\fR
を使うかまたは
\fIgit gui\fR
を使うか（、またはこの両方を使うか)できます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
最新の適切なコミットメッセージを使用して、最新の「現在のインデックス」をコミットします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
作業ツリーがクリーンになるまで、最後の2つの手順を繰り返します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit rebase \-\-continue\fR
でリベースを続行します。
.RE
.sp
あなたが中間リビジョンの一貫性(コンパイル、テストスイートの合格など)が完全には分からない場合は、「git stash」を使用して、各コミット後にまだコミットされていない変更を隠し、修正が必要な場合はコミットをテストして修正する必要があります。
.SH "RECOVERING FROM UPSTREAM REBASE"
.sp
他の人がベースにしているブランチをリベースする (あるいは他の形で書き換える) のは悪い考えです。そのブランチの下流の人は、自分の履歴を手動で修正することを余儀なくされます。 このセクションでは、下流側の視点から見た修正の方法を説明します。 しかし、本当の意味での修正は、そもそも上流のリベースを行わないことです。
.sp
説明のために、誰かが「subsystem」ブランチを開発し、この「subsystem」に依存する「topic」に取り組んでいる状況にあると仮定します。たぶん以下のような履歴です:
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
         \e
          o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  subsystem
                           \e
                            *\-\-\-*\-\-\-*  topic
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fBsubsystem\fR が \fBmaster\fR に対してリベースされる場合、以下が発生します:
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
         \e                       \e
          o\-\-\-o\-\-\-o\-\-\-o\-\-\-o       o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq  subsystem
                           \e
                            *\-\-\-*\-\-\-*  topic
.fi
.if n \{\
.RE
.\}
.sp
.sp
これで、あなたは通常どおり開発を続行し、最終的に \fBtopic\fR を \fBsubsystem\fR にマージすると、 以下のように、 \fBsubsystem\fR からのコミットは永久に複製されたままになります:
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
         \e                       \e
          o\-\-\-o\-\-\-o\-\-\-o\-\-\-o       o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-M  subsystem
                           \e                         /
                            *\-\-\-*\-\-\-*\-\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\-*\-\-*  topic
.fi
.if n \{\
.RE
.\}
.sp
.sp
このような重複は、履歴が乱雑になり、追跡が困難になるため、一般的に眉をひそめられる行為です。これをクリーンアップするには、「topic」のコミットを新しい「subsystem」の先端に移植する必要があります。つまり、「topic」をリベースする必要があります。これは影響が波及します。「topic」の下流にいる人もリベースを余儀なくされます！
.sp
2種類の修正パターン(簡単な場合と難しい場合)があります。以下のサブセクションで議論します:
.PP
簡単な場合: 変更は文字通り同じ(same)
.RS 4
これは、
\fBsubsystem\fR
のリベースが単純なリベースであり、競合がなかった場合に発生します。
.RE
.PP
難しい場合: 変更は同じではありません
.RS 4
これは、「subsystem」のリベースで競合が発生した場合、または
\fB\-\-interactive\fR
を使用してコミットを省略(omit)、edit、squash、fixupした場合に発生します。または、アップストリームで
\fBcommit \-\-amend\fR
や、
\fBreset\fR
や、
\m[blue]\fB\fBfilter\-repo\fR\fR\m[]\&\s-2\u[2]\d\s+2
のような完全な履歴書き換えコマンドのいずれかを使用した場合に発生します。
.RE
.SS "簡単な場合"
.sp
\fBsubsystem\fR の変更点(diffの内容に基づくパッチID)がリベース \fBsubsystem\fR の前と後で文字通り同じである場合にのみ動作します。
.sp
その場合、 \fBgit rebase\fR は新しいアップストリームにすでに存在する変更をスキップすることを知っているため、修正は簡単です(\fB\-\-reapply\-cherry\-picks\fR が指定されていない場合)。 だから(あなたが「topic」にいると仮定して、)あなたが以下のようにすれば、
.sp
.if n \{\
.RS 4
.\}
.nf
    $ git rebase subsystem
.fi
.if n \{\
.RE
.\}
.sp
.sp
あなたは修正された履歴で終わります。
.sp
.if n \{\
.RS 4
.\}
.nf
    o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o  master
                                 \e
                                  o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq\-\-o\*(Aq  subsystem
                                                   \e
                                                    *\-\-\-*\-\-\-*  topic
.fi
.if n \{\
.RE
.\}
.sp
.SS "難しい場合"
.sp
\fBsubsystem\fR の変更がリベース前の変更に正確に対応していない場合、事態はさらに複雑になります。
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
「簡単な場合の回復」は、難しい場合でも成功するように見えることがありますが、 意図しない結果をもたらす可能性があります。 たとえば、 \fBgit rebase \-\-interactive\fR を介して削除されたコミットが「復活」します！
.sp .5v
.RE
.sp
考え方としては、「git rebase」に「古いsubsystemが終了し、あなたのtopicを開始した場所」、つまり、それらの間の古いマージベースが何であったかを手動で伝えることです。 あなたは古いsubsystemの最後のコミットに名前を付ける方法を見つける必要があります。以下に例を示します:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBsubsystem\fR
reflogの場合:
\fBgit fetch\fR
後、\fBsubsystem\fR
の古い先端は
\fBsubsystem@{1}\fR
にあります。それ以降にフェッチすると、その数は増えます。 (\fBgit-reflog\fR(1)
を参照してください)。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBtopic\fR
の先端に関連して:
\fBtopic\fR
に3つのコミットがあることを知っているので、
\fBsubsystem\fR
の古い先端は
\fBtopic~3\fR
でなければなりません。
.RE
.sp
次に、あなたは以下のように言って、古い \fBsubsystem\&.\&.topic\fR を新しい先端に移植できます(reflogの場合、すでに \fBtopic\fR にいると仮定します):
.sp
.if n \{\
.RS 4
.\}
.nf
    $ git rebase \-\-onto subsystem subsystem@{1}
.fi
.if n \{\
.RE
.\}
.sp
.sp
「悪い場合」のリカバリの波及効果は特に悪いです。「topic」の下流にある「全て」で「悪い場合」のリカバリを実行する必要があります。
.SH "REBASING MERGES"
.sp
対話的リベースコマンドは、元々、個々のパッチシリーズを処理するために設計されました。そのため、開発者がブランチの作業中にその時点で最新の「master」をマージした可能性があり、最終的にすべてのコミットを「master」にリベースする(マージコミットをスキップする)ため、マージコミットをtodoリストから除外することは理にかなっています。
.sp
ただし、開発者がマージコミットを再作成する正当な理由があります。それは複数の相互に関連するブランチで作業するときに、ブランチ構造(または「コミットトポロジ」）を維持するためです。
.sp
次の例では、開発者はボタンの定義方法をリファクタリングするトピックブランチと、そのリファクタリングを使用して[バグの報告]ボタンを実装する別のトピックブランチで作業します。 \fBgit log \-\-graph \-\-format=%s \-5\fR の出力は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
*   Merge branch \*(Aqreport\-a\-bug\*(Aq
|\e
| * Add the feedback button
* | Merge branch \*(Aqrefactor\-button\*(Aq
|\e \e
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one
.fi
.if n \{\
.RE
.\}
.sp
.sp
開発者は、ブランチトポロジを維持しながら、これらのコミットを新しい \fBmaster\fR にリベースしたい場合があります。たとえば、最初のトピックブランチが2番目のブランチよりもはるかに早く \fBmaster\fR に統合されると予想される場合、たとえば、マージの競合を解決して、 \fBmaster\fR にしたDownloadButtonクラスへの変更を解決します。
.sp
このリベースは、 \fB\-\-rebase\-merges\fR オプションを使用して実行できます。 以下のようなToDoリストが生成されます:
.sp
.if n \{\
.RS 4
.\}
.nf
label onto

# Branch: refactor\-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor\-button

# Branch: report\-a\-bug
reset refactor\-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report\-a\-bug

reset onto
merge \-C a1b2c3 refactor\-button # Merge \*(Aqrefactor\-button\*(Aq
merge \-C 6f5e4d report\-a\-bug # Merge \*(Aqreport\-a\-bug\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
通常の対話的リベースとは対照的に、 \fBpick\fR コマンドに加えて \fBlabel\fR と \fBreset\fR と`merge` コマンドがあります。
.sp
\fBlabel\fR コマンドは、そのコマンドが実行されるときに、ラベルを現在のHEADに関連付けます。これらのラベルは、ワークツリーローカル参照(\fBrefs/rewritten/<label>\fR)として作成され、リベースが終了すると削除されます。こうすれば、同じリポジトリにリンクされている複数のワークツリーでのリベース操作が相互に干渉することはありません。 \fBlabel\fR コマンドが失敗した場合、すぐに再スケジュールされ、続行する方法について役立つメッセージが表示されます。
.sp
\fBreset\fR コマンドは、HEADとインデックスとワークツリーを指定されたリビジョンにリセットします。 これは \fBexec git reset \-\-hard <label>\fR に似ていますが、追跡していないファイルの上書きを拒否します。 \fBreset\fR コマンドが失敗すると、すぐに再スケジュールされ、todoリストを編集する方法がわかりやすく表示されます(これは通常、 \fBreset\fR コマンドがtodoリストに手動で挿入され、タイプミスが含まれている場合に発生します)。
.sp
\fBmerge\fR コマンドは、指定されたリビジョンをその時点でHEADであるものにマージします。 \fB\-C <original\-commit>`を使用すると、指定されたマージコミットのコミットメッセージが使用されます。 `\-C\fR が小文字の \fB\-c\fR に変更されると、ユーザーがメッセージを編集できるように、マージが成功した後にメッセージがエディターで開かれます。
.sp
マージの競合以外の理由で \fBmerge\fR コマンドが失敗した場合(つまり、マージ操作が開始されなかった場合)、コマンドは直ちに再スケジュールされます。
.sp
デフォルトでは、「merge」コマンドは通常のマージには「ort」マージ戦略を使用し、タコマージ(octopus merges)には「octopus」マージ戦略を使用します。リベースを呼び出すときに \fB\-\-strategy\fR 引数を使用して、すべてのマージのデフォルト戦略を指定できます。または、 \fBexec\fR コマンドを使用して明示的に \fB\-\-strategy\fR 引数を伴った \fBgit merge\fR を呼び出すことにより、コマンドの対話リスト内の特定のマージをオーバーライドできます。注意:このように明示的に \fBgit merge\fR を呼び出す場合、マージするブランチを参照するために、ラベルがワークツリーローカル参照であるという事実(たとえば、 ref \fBrefs/rewritten/onto\fR はラベル \fBonto\fR に対応します)を利用できることに注意してください。
.sp
注意: 最初のコマンド(\fBlabel onto\fR)は、コミットがリベースされるリビジョンにラベルを付けます。 \fBonto`という名前は単なる慣例で、 `\-\-onto\fR オプションにちなんでいます。
.sp
\fBmerge <merge\-head>\fR の形式のコマンドを追加することにより、完全に新しいマージコミットを最初から導入することもできます。この形式は、暫定的なコミットメッセージを生成し、常にエディターを開いてユーザーが編集できるようにします。これは便利です。例えば、トピックブランチが複数の懸念事項に対処していることが判明し、2つ以上のトピックブランチに分割したい場合です。以下のToDoリストを検討してみてください:
.sp
.if n \{\
.RS 4
.\}
.nf
pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1\&.3
pick fdbaec Fix detection of cURL in CMake on Windows
.fi
.if n \{\
.RE
.\}
.sp
.sp
CMakeに関連しないこのリストの1つのコミットは、CMakeに切り替えることによって発生したすべてのバグの修正に取り組むことによって動機付けられた可能性がありますが、しかし、それは別の懸念に対処します。このブランチを2つのトピックブランチに分割するには、ToDoリストを以下のように編集できます:
.sp
.if n \{\
.RS 4
.\}
.nf
label onto

pick afbecd http: add support for TLS v1\&.3
label tlsv1\&.3

reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake

reset onto
merge tlsv1\&.3
merge cmake
.fi
.if n \{\
.RE
.\}
.sp
.SH "CONFIGURATION"
.sp
このセクションの以下のすべては、 \fBgit-config\fR(1) ドキュメントの抜粋です。 内容は \fBgit-config\fR(1) ドキュメント にあるものと同一です:
.PP
rebase\&.backend
.RS 4
リベースに使用するデフォルトのバックエンド。 可能な選択肢は、「apply」または「merge」です。 将来、mergeバックエンドがapplyバックエンドの残りのすべての機能を取得した場合、この設定は使用されなくなる可能性があります。
.RE
.PP
rebase\&.stat
.RS 4
最後のリベース以降にアップストリームで変更されたもののdiffstatを表示するかどうか。デフォルトではFalseです。
.RE
.PP
rebase\&.autoSquash
.RS 4
trueに設定されている場合、デフォルトで
\fB\-\-autosquash\fR
オプションを有効にします。
.RE
.PP
rebase\&.autoStash
.RS 4
trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。これは、ダーティワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、
\fBgit-rebase\fR(1)
の
\fB\-\-no\-autostash\fR
および
\fB\-\-autostash\fR
オプションでオーバーライドできます。 デフォルトはfalseです。
.RE
.PP
rebase\&.updateRefs
.RS 4
trueに設定されている場合、デフォルトで
\fB\-\-update\-refs\fR
オプションを有効にします。
.RE
.PP
rebase\&.missingCommitsCheck
.RS 4
「warn」に設定すると、
\fBgit rebase \-i\fR
は、一部のコミットが削除された場合(たとえば、行が削除された場合)に警告を出力しますが、リベースは続行されます。 「error」に設定すると、前記の警告が出力され、リベースが停止(stop)します。
\fBgit rebase \-\-edit\-todo\fR
を使用して、エラーを修正できます。 「ignore」に設定すると、チェックは行われません。 警告やエラーなしにコミットをドロップするには、todoリストの
\fBdrop\fR
コマンドを使用します。 デフォルトは「ignore」です。
.RE
.PP
rebase\&.instructionFormat
.RS 4
\fBgit-log\fR(1)
で指定されている、対話的リベース中にToDoリストに使用される書式文字列。書式では、自動的に長いコミットハッシュが書式の前に付加されます。
.RE
.PP
rebase\&.abbreviateCommands
.RS 4
trueに設定すると、
\fBgit rebase\fR
はtodoリストで省略コマンド名を使用し、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
上記は以下の省略形です:
.sp
.if n \{\
.RS 4
.\}
.nf
        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
デフォルトではfalseです。
.RE
.PP
rebase\&.rescheduleFailedExec
.RS 4
失敗した
\fBexec\fR
コマンドを自動的に再スケジュールします。 これは、対話モード (または
\fB\-\-exec\fR
オプションが指定されている場合)でのみ意味があります。これは
\fB\-\-reschedule\-failed\-exec\fR
オプションを指定するのと同じです。
.RE
.PP
rebase\&.forkPoint
.RS 4
falseに設定されている場合、デフォルトで
\fB\-\-no\-fork\-point\fR
オプションを設定します。
.RE
.PP
sequence\&.editor
.RS 4
リベース命令ファイル(rebase instruction file)を編集するために
\fBgit rebase \-i\fR
によって使用されるテキストエディタ。この値は、使用時にシェルによって解釈されることを意図しています。 これは、
\fBGIT_SEQUENCE_EDITOR\fR
環境変数によってオーバーライドできます。構成されていない場合は、代わりにデフォルトのコミットメッセージエディタが使用されます。
.RE
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
revert-a-faulty-merge How-To
.RS 4
\%file:///home/hideo/share/doc/git-doc/howto/revert-a-faulty-merge.html
.RE
.IP " 2." 4
\fBfilter-repo\fR
.RS 4
\%https://github.com/newren/git-filter-repo
.RE
