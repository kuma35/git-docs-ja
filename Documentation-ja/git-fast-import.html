<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>git-fast-import(1)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
git-fast-import(1) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>git-fast-import -
   高速Gitデータインポーターのバックエンド
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content">frontend | <em>git fast-import</em> [&lt;options&gt;]</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>このプログラムは通常、エンドユーザーが直接実行したいものではありません。 ほとんどのエンドユーザーは、既存のフロントエンドプログラムの1つを使用したいと考えています。このプログラムは、特定の種類の外部ソースをパースし、そこに保存されているコンテンツを <code>git fast-import</code> に送ります。</p></div>
<div class="paragraph"><p>fast-importは、標準入力から 混合 コマンド/データストリーム を読み取り、1つ以上のパックファイルを現在のリポジトリに直接書き込みます。 EOFが標準入力で受信されると、高速インポートは更新されたブランチとタグの参照を書き出し、新しくインポートされたデータで現在のリポジトリを完全に更新します。</p></div>
<div class="paragraph"><p>高速インポートバックエンド自体は、空のリポジトリ(<code>git init</code> によってすでに初期化されているリポジトリ)にインポートすることも、既存の入力済みリポジトリを増分更新(incrementally update)することもできます。 特定の外部ソースからの増分インポートがサポートされているかどうかは、使用しているフロントエンドプログラムによって異なります。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_options">OPTIONS</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--force</code>
</dt>
<dd>
<p>
        コミットが失われる場合でも(新しいコミットには古いコミットが含まれていないため)、変更された既存のブランチを強制的に更新します。
</p>
</dd>
<dt class="hdlist1">
<code>--quiet</code>
</dt>
<dd>
<p>
        <code>--stats</code> で示される出力を無効にし、正常に実行されると、通常、fast-importをサイレントにします。 ただし、インポートストリームに、ユーザー出力を表示することを目的としたディレクティブ(`progress`ディレクティブなど)がある場合も対応するメッセージが表示されます。
</p>
</dd>
<dt class="hdlist1">
<code>--stats</code>
</dt>
<dd>
<p>
        fast-importが作成したオブジェクト、それらが保存されたパックファイル、およびこの実行中にfast-importによって使用されたメモリに関するいくつかの基本的な統計を表示します。 この出力の表示は現在デフォルトですが、 <code>--quiet</code> を使用して無効にすることができます。
</p>
</dd>
<dt class="hdlist1">
<code>--allow-unsafe-features</code>
</dt>
<dd>
<p>
        <code>feature</code> または <code>option</code> コマンドを使用して、高速インポートストリーム自体の一部として多くのコマンドラインオプションを提供できます。 ただし、これらのオプションの一部は安全ではありません(たとえば、高速インポートでリポジトリの外部のファイルシステムにアクセスできるようにするなど)。 これらのオプションはデフォルトで無効になっていますが、コマンドラインでこのオプションを指定することで許可できます。 これは現在、 <code>export-marks</code> と <code>import-marks</code> と <code>import-marks-if-exists</code> 機能コマンドにのみ影響します。
</p>
<div class="literalblock">
<div class="content">
<pre><code>高速インポートストリームを生成するプログラムを信頼する場合にのみ、このオプションを有効にしてください。 このオプションは、独自のコードを実行することがすでに信頼されているため、 `import` 機能を使用するリモートヘルパーに対して自動的に有効になります。</code></pre>
</div></div>
</dd>
</dl></div>
<div class="sect2">
<h3 id="_options_for_frontends">Options for Frontends</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--cat-blob-fd=&lt;fd&gt;</code>
</dt>
<dd>
<p>
        <code>get-mark</code> と <code>cat-blob</code> と <code>ls</code> クエリへの応答を、 <code>stdout</code> ではなくファイルデスクリプタ&lt;fd&gt;に書き込みます。 エンドユーザー向けの <code>progress</code> 出力を他の出力から分離できるようにします。
</p>
</dd>
<dt class="hdlist1">
<code>--date-format=&lt;fmt&gt;</code>
</dt>
<dd>
<p>
        フロントエンドが高速インポートに提供する日付のタイプを、 <code>author</code> と <code>committer</code> と`tagger` コマンド内で指定します。 サポートされているフォーマットとその構文の詳細については、以下の「Date Formats」を参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--done</code>
</dt>
<dd>
<p>
        ストリームの最後に <code>done</code> コマンドがない場合は、エラーで終了(terminate)します。 このオプションは、フロントエンドがストリームの書き込みを開始する前に終了する原因となるエラーを検出するのに役立つ場合があります。
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_locations_of_marks_files">Locations of Marks Files</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--export-marks=&lt;file&gt;</code>
</dt>
<dd>
<p>
        完了すると、内部マークテーブルを&lt;file&gt;にダンプします。 マークは1行に1つずつ <code>:markid SHA-1</code> として書き込まれます。 フロントエンドは、このファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行(incremental runs)全体でマークテーブルを保存したりできます。 &lt;file&gt;はチェックポイント(または完了)でのみ開かれ(open)、切り捨て(truncate)られるため、同じパスを <code>--import-marks</code> に安全に指定することもできます。
</p>
</dd>
<dt class="hdlist1">
<code>--import-marks=&lt;file&gt;</code>
</dt>
<dd>
<p>
        入力を処理する前に、&lt;file&gt;で指定されたマークをロードします。 入力ファイルは存在し、読み取り可能であり、 <code>--export-marks</code> によって生成されたものと同じ形式を使用する必要があります。 複数のマークのセットをインポートするために、オプションを複数回指定できます。 マークが異なる値に定義されている場合、最後のファイルが優先されます。
</p>
</dd>
<dt class="hdlist1">
<code>--import-marks-if-exists=&lt;file&gt;</code>
</dt>
<dd>
<p>
        <code>--import-marks</code> と同様ですが、エラーが発生する代わりに、ファイルが存在しない場合は黙ってスキップします。
</p>
</dd>
<dt class="hdlist1">
<code>--[no-]relative-marks</code>
</dt>
<dd>
<p>
        <code>--relative-marks</code> を指定した後、 <code>--import-marks=</code> と <code>--export-marks=</code> で指定されたパスは、現在のリポジトリの内部ディレクトリからの相対パスになります。 git-fast-importでは、これはパスが <code>.git/info/fast-import</code> ディレクトリから相対的であることを意味します。 ただし、他のインポーターは別の場所を使用する場合があります。
</p>
<div class="paragraph"><p><code>--(no-)-relative-marks</code> を <code>--(import|export)-marks=</code> と織り交ぜることで、相対マークと非相対マークを組み合わせることができます。</p></div>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_submodule_rewriting">Submodule Rewriting</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--rewrite-submodules-from=&lt;name&gt;:&lt;file&gt;</code>
</dt>
<dt class="hdlist1">
<code>--rewrite-submodules-to=&lt;name&gt;:&lt;file&gt;</code>
</dt>
<dd>
<p>
Rewrite the object IDs for the submodule specified by &lt;name&gt; from the values used in the from &lt;file&gt; to those used in the to &lt;file&gt;. The from marks should have been created by <code>git fast-export</code>, and the to marks should have been created by <code>git fast-import</code> when importing that same submodule.
</p>
<div class="paragraph"><p>&lt;name&gt;は、コロン文字を含まない任意の文字列にすることができますが、対応するマークを指定するときは、両方のオプションで同じ値を使用する必要があります。 &lt;name&gt;の値が異なる複数のサブモジュールを指定できます。 対応するペアでこれらのオプションを使用しないのはエラーです。</p></div>
<div class="paragraph"><p>これらのオプションは、リポジトリをあるハッシュアルゴリズムから別のハッシュアルゴリズムに変換するときに主に役立ちます。 それらがないと、オブジェクトIDを新しいハッシュアルゴリズムに書き込む方法がないため、サブモジュールが検出された場合、fast-importは失敗します。</p></div>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_performance_and_compression_tuning">Performance and Compression Tuning</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--active-branches=&lt;n&gt;</code>
</dt>
<dd>
<p>
        一度にアクティブを維持するブランチの最大数。 詳細については、下記「Memory Utilization」(メモリ使用率)を参照してください。 デフォルトは5です。
</p>
</dd>
<dt class="hdlist1">
<code>--big-file-threshold=&lt;n&gt;</code>
</dt>
<dd>
<p>
        fast-importがデルタを作成しようとするブロブの最大サイズ(バイト単位)。 デフォルトは512m(512 MiB)です。 一部のインポーターは、メモリが制限されているシステムでこの値を下げることを希望する事があります。
</p>
</dd>
<dt class="hdlist1">
<code>--depth=&lt;n&gt;</code>
</dt>
<dd>
<p>
        ブロブとツリーの差分化(deltification)の最大デルタ深度。 デフォルトは50です。
</p>
</dd>
<dt class="hdlist1">
<code>--export-pack-edges=&lt;file&gt;</code>
</dt>
<dd>
<p>
        パックファイルを作成した後、データの行を&lt;file&gt;に出力して、パックファイルのファイル名と、そのパックファイルに書き込まれた各ブランチの最後のコミットをリストします。 この情報は、オブジェクトセットの合計が4 GiBパックファイルの制限を超えるプロジェクトをインポートした後に役立つ場合があります。 これらのコミットは、 <code>git pack-objects</code> の呼び出し中にエッジポイントとして使用できるためです。
</p>
</dd>
<dt class="hdlist1">
<code>--max-pack-size=&lt;n&gt;</code>
</dt>
<dd>
<p>
        各出力パックファイルの最大サイズ。 デフォルトは無制限です。
</p>
</dd>
<dt class="hdlist1">
fastimport.unpackLimit
</dt>
<dd>
<p>
        <a href="git-config.html">git-config(1)</a> 参照
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance">PERFORMANCE</h2>
<div class="sectionbody">
<div class="paragraph"><p>高速インポートの設計により、最小限のメモリ使用量と処理時間で大規模なプロジェクトをインポートできます。 フロントエンドが高速インポートに対応し、一定のデータストリームをフィードできると仮定すると、10年以上の履歴を保持し、100,000以上の個別のコミットを含むプロジェクトのインポート時間は、通常、非常に控えめな(〜$2,000 USD)ハードウェアで、わずか1〜2時間で完了します。</p></div>
<div class="paragraph"><p>ほとんどのボトルネックは、外部ソースデータアクセス(ソースがリビジョンを十分に速く抽出できない)、またはディスクI/O(ディスクがデータを取得するのと同じ速さで高速インポート書き込み)にあるように見えます。 ソースデータが宛先Gitリポジトリとは異なるドライブに保存されている場合、(I/Oの競合が少ないため)、インポートはより高速に実行されます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_development_cost">DEVELOPMENT COST</h2>
<div class="sectionbody">
<div class="paragraph"><p>fast-importの一般的なフロントエンドは、200行程度の Perl/Python/Ruby コードを使用する傾向があります。 ほとんどの開発者は、fast-import、場合によってはGitに初めて触れたとしても、わずか数時間で実用的なインポーターを作成することができました。 ほとんどの変換ツールが使い捨て(一度使用すると、決して振り返ることがない)であることを考えると、これは理想的な状況です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_parallel_operation">PARALLEL OPERATION</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>git push</code> や <code>git fetch</code> と同様に、fast-importによって処理されるインポートは、並列の <code>git repack -a -d</code> や <code>git gc</code> の呼び出し、またはその他のGit操作(<code>git prune</code> を含む、そしてfast-importでは緩いオブジェクト(loose objects)は使用されないため。)と一緒に実行しても安全です。</p></div>
<div class="paragraph"><p>fast-importは、アクティブにインポートしているブランチまたはタグ参照をロックしません。 インポート後、refの更新フェーズで、fast-importは、既存の各ブランチrefをテストして、更新が早送り更新(fast-forward update)になることを確認(verifty)します(refに格納されているコミットは、書き込まれるコミットの新しい履歴に含まれます)。 更新が早送り更新でない場合、fast-importはその参照の更新をスキップし、代わりに警告メッセージを出力します。 fast-importは常にすべてのブランチ参照を更新しようとし、最初の失敗で停止(stop)しません。</p></div>
<div class="paragraph"><p>ブランチの更新は <code>--force</code> を使用して強制できますが、それ以外の場合は静かなリポジトリ(quiet repository)でのみ使用することをお勧めします。 空のリポジトリへの最初のインポートには、 <code>--force</code> を使用する必要はありません。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_technical_discussion">TECHNICAL DISCUSSION</h2>
<div class="sectionbody">
<div class="paragraph"><p>fast-importは、メモリ内の一連のブランチを追跡します。 入力ストリームで <code>commit</code> コマンドを送信することにより、インポートプロセス中の任意の時点で任意のブランチを作成または変更できます。 この設計により、フロントエンドプログラムは無制限の数のブランチを同時に処理し、ソースデータから利用可能な順序でコミットを生成できます。 また、フロントエンドプログラムを大幅に簡素化します。</p></div>
<div class="paragraph"><p>fast-importは、現在の作業ディレクトリまたはその中のファイルを使用または変更しません。 (ただし、 <code>GIT_DIR</code> で参照されるように、現在のGitリポジトリを更新します。) したがって、インポートフロントエンドは、外部ソースからファイルリビジョンを抽出するなど、独自の目的で作業ディレクトリを使用する場合があります。 この、作業ディレクトリの無感知により、ブランチを切り替えるときにコストのかかるファイル更新操作を実行する必要がないため、fast-importを非常に迅速に実行することもできます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_input_format">INPUT FORMAT</h2>
<div class="sectionbody">
<div class="paragraph"><p>(Gitが解釈しない)生のファイルデータを除いて、fast-import入力形式はテキスト(ASCII)ベースです。 このテキストベースの形式は、特にPerl、Python、Rubyなどの高級言語が使用されている場合に、フロントエンドプログラムの開発とデバッグを簡素化します。</p></div>
<div class="paragraph"><p>fast-importは、入力に関して非常に厳密です。 以下でSPと言う場合、「正確に」1つのスペースを意味します。 同様に、LFは1つ(そして1つだけ)の改行を意味し、HTは1つ(そして1つだけ)の水平タブを意味します。追加の空白文字を指定すると、名前の先頭または末尾にスペースが含まれるブランチ名やファイル名などの予期しない結果が発生したり、予期しない入力が発生した場合に高速インポートが早期に終了したりします。</p></div>
<div class="sect2">
<h3 id="_stream_comments">Stream Comments</h3>
<div class="paragraph"><p>フロントエンドのデバッグを支援するために、fast-importは、 <code>#</code> (ASCII シャープ/ハッシュ) で始まり、<code>LF</code> で終わる行を無視します。 コメント行には、LFを含まないバイトのシーケンスを含めることができるため、フロントエンドに固有でfast-importのデータストリームを検査するときに役立つ詳細なデバッグ情報を含めるために使用できます。</p></div>
</div>
<div class="sect2">
<h3 id="_date_formats">Date Formats</h3>
<div class="paragraph"><p>以下の日付形式がサポートされています。 フロントエンドは、<code>--date-format=&lt;fmt&gt;</code> コマンドラインオプションで形式名を渡すことにより、このインポートに使用する形式を選択する必要があります。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>raw</code>
</dt>
<dd>
<p>
        これはGitのネイティブ形式であり、 <code>&lt;time&gt;SP&lt;offutc&gt;</code> です。 <code>--date-format</code> が指定されていない場合は、fast-importのデフォルト形式でもあります。
</p>
<div class="paragraph"><p>イベントの時刻は、UNIXエポック(1970年1月1日午前0時、UTC)からの秒数として <code>&lt;time&gt;</code> で指定され、ASCIIの10進整数として書き込まれます。</p></div>
<div class="paragraph"><p>ローカルオフセットは、UTCからの正または負のオフセットとして <code>&lt;offutc&gt;</code> によって指定されます。 たとえば、EST(UTCから5時間遅れている)は、UTCが「+0000」であるのに対し、「&lt;tz&gt;」は「-0500」で表されます。 ローカルオフセットは <code>&lt;time&gt;</code> には影響しません。 これは、フォーマットルーチンがタイムスタンプを表示するのに役立つアドバイスとしてのみ使用されます。</p></div>
<div class="paragraph"><p>ローカルオフセットがソース素材で使用できない場合は、「+0000」、または最も一般的なローカルオフセットを使用します。 たとえば、多くの組織には、同じ場所とタイムゾーンにいるユーザーだけがアクセスしたことのあるCVSリポジトリがあります。 この場合、UTCからの妥当なオフセットを想定できます。</p></div>
<div class="paragraph"><p><code>rfc2822</code> 形式とは異なり、この形式は非常に厳密です。 フォーマッティングに変化があると、fast-importが値を拒否し、数値の健全性チェックも実行される場合があります。</p></div>
</dd>
<dt class="hdlist1">
<code>raw-permissive</code>
</dt>
<dd>
<p>
        これは、数値エポックとローカルオフセットの健全性チェックが実行されないことを除いて、<code>raw</code> と同じです。 これは、例えば、偽のタイムゾーン値を使用して既存の履歴をフィルタリングまたはインポートしようとする場合に役立ちます。
</p>
</dd>
<dt class="hdlist1">
<code>rfc2822</code>
</dt>
<dd>
<p>
        これは、RFC2822で説明されている標準の電子メール形式です。
</p>
<div class="paragraph"><p>この値は例えば <code>Tue Feb 6 11:22:18 2007 -0500</code> です。 Gitパーサーは正確ですが、ちょっぴり寛大です。 これは、電子メールから受信したパッチを適用するときに <code>git am</code> によって使用されるのと同じパーサーです。</p></div>
<div class="paragraph"><p>一部の不正な形式の文字列が、有効な日付として受け入れられる場合があります。 これらの場合のいくつかでは、Gitは不正な形式の文字列から正しい日付を取得できます。 また、Gitが誤ってパースし、それでも有効と見なす不正な形式の文字列の種類もあります。 ひどくおかしい文字列は拒否されます。</p></div>
<div class="paragraph"><p>上記の`raw`形式とは異なり、RFC2822日付文字列に含まれる タイムゾーン/UTC オフセット情報は、保存前に日付値をUTCに調整するために使用されます。 したがって、この情報が可能な限り正確であることが重要です。</p></div>
<div class="paragraph"><p>もしソース素材がRFC2822スタイルの日付を使っているなら、フロントエンドは(自分でやろうとするよりも、)fast-importにパースと変換を任せるべきです。なぜなら、Gitパーサーは実際によくテストされているからです。</p></div>
<div class="paragraph"><p>フロントエンドは、ソース素材がすでに UNIX-epoch フォーマットを使っていて、そのフォーマットで日付を与えるように言いくるめられる場合、あるいはパースに曖昧さがないため、そのフォーマットが簡単に <code>raw</code> フォーマットに変換できる場合は、 <code>raw</code> フォーマットを優先するべきです。</p></div>
</dd>
<dt class="hdlist1">
<code>now</code>
</dt>
<dd>
<p>
        常に現在の時間とタイムゾーンを使用します。 <code>&lt;when&gt;</code> には常に <code>now</code> というリテラルを指定しなければなりません。
</p>
<div class="paragraph"><p>これはおもちゃのフォーマット(toy format)です。 このシステムの現在の時刻とタイムゾーンは、fast-importによって作成されるときに常にID文字列にコピーされます。 別の時間またはタイムゾーンを指定する方法はありません。</p></div>
<div class="paragraph"><p>この特定の形式は、実装が簡単なために提供されており、作業ディレクトリや <code>git update-index</code> を使用せずに、今すぐ新しいコミットを作成したいプロセスに役立つ場合があります。</p></div>
<div class="paragraph"><p><code>commit</code> で別々の <code>author</code> コマンドと <code>committer</code> コマンドが使用されている場合、システムクロックが2回(コマンドごとに1回)ポーリングされるため、タイムスタンプが一致しない可能性があります。 作者とコミッターの両方のID情報のタイムスタンプが同じであることを確認する唯一の方法は、 <code>author</code> を省略するか(したがって <code>committer</code> からコピーする)、または <code>now</code> 以外の日付形式を使用することです。</p></div>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_commands">Commands</h3>
<div class="paragraph"><p>fast-importは、現在のリポジトリを更新し、現在のインポートプロセスを制御するためのいくつかのコマンドを受け入れます。 各コマンドの詳細(例を含む)については後述します。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>commit</code>
</dt>
<dd>
<p>
        新しいコミットを作成し、新しく作成されたコミットを指すようにブランチを更新することにより、新しいブランチを作成するか、既存のブランチを更新します。
</p>
</dd>
<dt class="hdlist1">
<code>tag</code>
</dt>
<dd>
<p>
        既存のコミットまたはブランチから注釈付きタグオブジェクト(annotated tag object)を作成します。 軽量タグ(Lightweight tags)は、意味のある時点を記録するためには推奨されていないため、このコマンドではサポートされていません。
</p>
</dd>
<dt class="hdlist1">
<code>reset</code>
</dt>
<dd>
<p>
        既存のブランチ(または新しいブランチ)を特定のリビジョンにリセットします。 このコマンドは、ブランチをコミットせずに特定のリビジョンに変更する目的で使用する必要があります。
</p>
</dd>
<dt class="hdlist1">
<code>blob</code>
</dt>
<dd>
<p>
        将来 <code>commit</code> コマンドで使用するために、生のファイルデータをブロブに変換します。 このコマンドはオプションであり、インポートを実行するために必要ではありません。
</p>
</dd>
<dt class="hdlist1">
<code>alias</code>
</dt>
<dd>
<p>
        最初に新しいオブジェクトを作成せずに、マークが特定のオブジェクトを参照していることを記録します。 <code>--import-marks</code> を使用し、欠落しているマークを参照すると fast-import が失敗するため、エイリアスは、刈り込まれたコミットを有効な値(刈り込まれていない最も近い祖先など)に設定する方法を提供できます。
</p>
</dd>
<dt class="hdlist1">
<code>checkpoint</code>
</dt>
<dd>
<p>
        fast-importを強制して、現在のパックファイルを閉じ、一意のSHA-1チェックサムとインデックスを生成して、新しいパックファイルを開始します。 このコマンドはオプションであり、インポートを実行するために必須ではありません。
</p>
</dd>
<dt class="hdlist1">
<code>progress</code>
</dt>
<dd>
<p>
        fast-importにより、行全体が自身の標準出力にエコーされます。このコマンドはオプションであり、インポートを実行するために必要ではありません。
</p>
</dd>
<dt class="hdlist1">
<code>done</code>
</dt>
<dd>
<p>
        ストリームの終わりを示します。 <code>--done</code> コマンドラインオプションまたは <code>feature done</code> コマンドを使用して <code>done</code> 機能が要求された場合を除き、このコマンドはオプションです。
</p>
</dd>
<dt class="hdlist1">
<code>get-mark</code>
</dt>
<dd>
<p>
        fast-import により、マークに対応するSHA-1が、 <code>--cat-blob-fd</code> にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。
</p>
</dd>
<dt class="hdlist1">
<code>cat-blob</code>
</dt>
<dd>
<p>
        fast-importにより、 <code>cat-file --batch</code> 形式のブロブが、 <code>--cat-blob-fd</code> にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。
</p>
</dd>
<dt class="hdlist1">
<code>ls</code>
</dt>
<dd>
<p>
        fast-importにより、ディレクトリエントリを <code>ls-tree</code> 形式で記述した行が、 <code>--cat-blob-fd</code> にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。
</p>
</dd>
<dt class="hdlist1">
<code>feature</code>
</dt>
<dd>
<p>
        指定された機能を有効にします。 これには、fast-importが指定された機能をサポートしている必要があり、サポートしていない場合は中止(abort)されます。
</p>
</dd>
<dt class="hdlist1">
<code>option</code>
</dt>
<dd>
<p>
        フロントエンドのニーズに合わせてストリームセマンティックを変更しないオプションの下にリストされているオプションのいずれかを指定します。 このコマンドはオプションであり、インポートを実行するために必須ではありません。
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_code_commit_code"><code>commit</code></h3>
<div class="paragraph"><p>新しいコミットでブランチを作成または更新し、プロジェクトへの1つの論理的な変更を記録します。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'commit' SP &lt;ref&gt; LF
        mark?
        original-oid?
        ('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF)?
        'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        ('encoding' SP &lt;encoding&gt;)?
        data
        ('from' SP &lt;commit-ish&gt; LF)?
        ('merge' SP &lt;commit-ish&gt; LF)*
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
        LF?</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;ref&gt;</code> はコミットを行うブランチの名前です。 通常、Gitではブランチ名の前に <code>refs/heads/</code> が付いているため、CVSブランチシンボル <code>RELENG-1_0</code> をインポートすると、 <code>&lt;ref&gt;</code> の値に <code>refs/heads/RELENG-1_0</code> が使用されます。 <code>&lt;ref&gt;</code> の値は、Gitで有効なrefnameである必要があります。 <code>LF</code> はGit refnameでは無効であるため、ここではクォートやエスケープ構文はサポートされていません。</p></div>
<div class="paragraph"><p><code>mark</code> コマンドがオプションで表示され、フロントエンドで将来使用するために新しく作成されたコミットへの参照を保存するようにfast-importを要求する場合があります(形式については以下を参照)。 フロントエンドが作成するすべてのコミットにマークを付けることは非常に一般的であり、これにより、インポートされたコミットから将来のブランチを作成できます。</p></div>
<div class="paragraph"><p><code>committer</code> に続く <code>data</code> コマンドは、コミットメッセージを提供する必要があります(<code>data</code> コマンドの構文については以下を参照してください)。 空のコミットメッセージをインポートするには、長さ0のデータを使用します。 コミットメッセージは自由形式であり、Gitによって解釈されません。 fast-importでは他のエンコードを指定できないため、現在はUTF-8でエンコードする必要があります。</p></div>
<div class="paragraph"><p>コミットを作成する前にブランチの内容を更新するために、0個以上の <code>filemodify</code> 、 <code>filedelete</code> 、 <code>filecopy</code> 、 <code>filerename</code> 、 <code>filedeleteall</code> 、 <code>notemodify</code> コマンドを含めることができます。 これらのコマンドは、任意の順序で指定できます。 ただし、 <code>filedeleteall</code> はブランチをクリーンにワイプするため、 <code>filedeleteall</code> コマンドを同じコミット内のすべての <code>filemodify</code> 、 <code>filecopy</code> 、 <code>filerename</code> 、 ` notemodify` コマンドの前に置くことをお勧めします(下記参照)。</p></div>
<div class="paragraph"><p>コマンドの後の <code>LF</code> はオプションです(以前は必須でした)。 下位互換性の理由から、コミットが <code>data</code> コマンドで終了する場合(つまり、 <code>from</code> 、 <code>merge</code> 、 <code>filemodify</code> 、 <code>filedelete</code> 、 <code>filecopy</code> 、 <code>filerename</code> 、 <code>filedeleteall</code> 、 <code>notemodify</code> コマンドがないことに注意してください)の場合、コマンドの最後に1つではなく2つの <code>LF</code> コマンドが表示される場合があります。</p></div>
<div class="sect3">
<h4 id="_code_author_code"><code>author</code></h4>
<div class="paragraph"><p>作者情報がコミッター情報と異なる場合は、オプションで <code>author</code> コマンドが表示されることがあります。 <code>author</code> を省略すると、fast-importはコミットの作者部分にコミッターの情報を自動的に使用します。 <code>author</code> のフィールドの説明については、 <code>committer</code> と同じであるため、以下を参照してください。</p></div>
</div>
<div class="sect3">
<h4 id="_code_committer_code"><code>committer</code></h4>
<div class="paragraph"><p><code>committer</code> コマンドは、誰がこのコミットを行ったのか、いつ行ったのかを示します。</p></div>
<div class="paragraph"><p>ここで、 <code>&lt;name&gt;</code> は個人の表示名(たとえば、 "Com M Itter")であり、 <code>&lt;email&gt;</code> は個人の電子メールアドレス("cm@example.com")です。 <code>LT</code> と <code>GT</code> は、文字通りの小なり記号(\x3c)と大なり記号(\x3e)です。 これらは、行の他のフィールドから電子メールアドレスを区切るために必要です。 <code>&lt;name&gt;</code> と <code>&lt;email&gt;</code> は自由形式であり、 <code>LT</code> 、<code>GT</code> 、 <code>LF</code> を除く任意のバイトシーケンスを含むことができることに注意してください。 <code>&lt;name&gt;</code> は通常UTF-8でエンコードされています。</p></div>
<div class="paragraph"><p>変更時刻は、 <code>--date-format=&lt;fmt&gt;</code> コマンドラインオプションで選択された日付形式を使用して <code>&lt;when&gt;</code> で指定されます。サポートされている形式のセットとその構文については、上記「Date Formats」を参照してください。</p></div>
</div>
<div class="sect3">
<h4 id="_code_encoding_code"><code>encoding</code></h4>
<div class="paragraph"><p>オプションの <code>encoding</code> コマンドは、コミットメッセージのエンコーディングを示します。 ほとんどのコミットはUTF-8であり、エンコードは省略されていますが、これにより、最初に再エンコードせずにコミットメッセージをgitにインポートできます。</p></div>
</div>
<div class="sect3">
<h4 id="_code_from_code"><code>from</code></h4>
<div class="paragraph"><p><code>from</code> コマンドは、このブランチを初期化するコミットを指定するために使用されます。 このリビジョンは、新しいコミットの最初の祖先になります。 このコミットで構築されたツリーの状態は、 <code>from</code> コミットでの状態で始まり、このコミットでのコンテンツの変更によって交換(alter)されます。</p></div>
<div class="paragraph"><p>新しいブランチの最初のコミットで <code>from</code> コマンドを省略すると、fast-importが祖先なしでそのコミットを作成します。 これは、プロジェクトの最初のコミットでのみ必要になる傾向があります。 新しいブランチを作成するときにフロントエンドがすべてのファイルを最初から作成する場合は、 <code>from</code> の代わりに <code>merge</code> コマンドを使用して、空のツリーでコミットを開始できます。 そのブランチの現在のコミットは自動的に新しいコミットの最初の祖先であると見なされるため、既存のブランチでは通常は <code>from</code> コマンドを省略することが望まれます。</p></div>
<div class="paragraph"><p><code>LF</code> は Git refname または SHA-1式では無効であるため、<code>&lt;commit-ish&gt;</code> 内でのクォートまたはエスケープ構文はサポートされていません。</p></div>
<div class="paragraph"><p>ここで、<code>&lt;commit-ish&gt;</code> は以下のいずれかです:</p></div>
<div class="ulist"><ul>
<li>
<p>
fast-importの内部ブランチテーブルにすでに存在する既存のブランチの名前。 fast-importが名前を知らない場合は、SHA-1式として扱われます。
</p>
</li>
<li>
<p>
マーク参照: &lt;idnum&gt; 。ここで、 <code>&lt;idnum&gt;</code> はマーク番号です。
</p>
<div class="paragraph"><p>fast-importがマーク参照を示すために <code>:</code> を使用する理由は、この文字がGitブランチ名では無効であるためです。 先頭 <code>:</code> を使用すると、マーク42(<code>:42</code>)とブランチ42(<code>42</code> または <code>refs/heads/42</code>)、または、たまたま10進数で構成されていた省略形のSHA-1を、簡単に区別できます。</p></div>
<div class="paragraph"><p>マークは、使用する前に( <code>mark</code> を介して)宣言する必要があります。</p></div>
</li>
<li>
<p>
完全な40バイトまたは省略された16進数のコミットSHA-1。
</p>
</li>
<li>
<p>
コミットに解決される有効な Git SHA-1式。 詳細については、 <a href="gitrevisions.html">gitrevisions(7)</a> の「SPECIFYING REVISIONS」を参照してください。
</p>
</li>
<li>
<p>
特別な null SHA-1(40個のゼロ)は、ブランチが削除されることを指定します。
</p>
</li>
</ul></div>
<div class="paragraph"><p>現在のブランチ値から増分インポート(incremental import)を再スタートする特殊なケースは、以下のように記述する必要があります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        from refs/heads/branch^0</code></pre>
</div></div>
<div class="paragraph"><p>fast-importはブランチをそれ自体から開始することを許可しないため、 <code>^0</code> サフィックスが必要です。ブランチは、 <code>from</code> コマンドが入力から読み取られる前にメモリに作成されます。 <code>^0</code> を追加すると、fast-importは、内部ブランチテーブルではなく、Gitのリビジョンパースライブラリを介してコミットを解決し、ブランチの既存の値をロードします。</p></div>
</div>
<div class="sect3">
<h4 id="_code_merge_code"><code>merge</code></h4>
<div class="paragraph"><p>1つの追加の祖先コミットが含まれます。 追加の祖先リンクは、このコミットでツリー状態が構築される方法を変更しません。 新しいブランチを作成するときに <code>from</code> コマンドを省略すると、最初の <code>merge</code> コミットが現在のコミットの最初の祖先になり、ブランチはファイルなしで開始されます。 fast-importでは、コミットごとに無制限の数の <code>merge</code> コマンドが許可されるため、n方向(n-way)マージが確立されます。</p></div>
<div class="paragraph"><p>ここで、 <code>&lt;commit-ish&gt;</code> は、 <code>from</code> でも受け入れられるコミット仕様式のいずれかです(上記参照)。</p></div>
</div>
<div class="sect3">
<h4 id="_code_filemodify_code"><code>filemodify</code></h4>
<div class="paragraph"><p>新しいファイルを追加したり、既存のファイルの内容を変更したりするために <code>commit</code> コマンドに含まれています。 このコマンドには、ファイルの内容を指定する2つの異なる方法があります。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
External data format
</dt>
<dd>
<p>
        ファイルのデータコンテンツは、以前の <code>blob</code> コマンドによってすでに提供されています。フロントエンドはそれに接続する必要があります。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'M' SP &lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで通常、 <code>&lt;dataref&gt;</code> は、前の <code>blob</code> コマンドによって設定されたマーク参照(<code>:&lt;idnum&gt;</code>)か、既存のGitブロブオブジェクトの完全な40バイトのSHA-1である必要があります。 <code>&lt;mode&gt;</code> が <code>040000</code> の場合、 <code>&lt;dataref&gt;</code> は既存のGitツリーオブジェクトの完全な40バイトのSHA-1または <code>--import-marks</code> で設定されたマーク参照である必要があります。</p></div>
</dd>
<dt class="hdlist1">
Inline data format
</dt>
<dd>
<p>
        ファイルのデータコンテンツはまだ提供されていません。 フロントエンドは、この変更コマンドの一部としてそれを提供したいと考えています。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'M' SP &lt;mode&gt; SP 'inline' SP &lt;path&gt; LF
        data</code></pre>
</div></div>
<div class="paragraph"><p><code>data</code> コマンドの詳細については下記参照。</p></div>
</dd>
</dl></div>
<div class="paragraph"><p>どちらの形式でも、 <code>&lt;mode&gt;</code> はファイルエントリのタイプであり、8進数で指定されます。 Gitは以下のモードのみをサポートします:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>100644</code> または <code>644</code> : 通常の(実行可能でない)ファイル。 ほとんどのプロジェクトのファイルの大部分はこのモードを使用しています。迷ったらコレ。
</p>
</li>
<li>
<p>
<code>100755</code> または <code>755</code> : 通常の、しかし実行可能なファイル。
</p>
</li>
<li>
<p>
<code>120000</code>: シンボリックリンク。ファイルの内容がリンクターゲットになります。
</p>
</li>
<li>
<p>
<code>160000</code> : gitlink、オブジェクトのSHA-1は、他のリポジトリのコミットを参照しています。 Gitリンクは、SHAまたはコミットマークを介してのみ指定できます。 これらは、サブモジュールを実装するために使用されます。
</p>
</li>
<li>
<p>
<code>040000</code>: サブディレクトリ。 サブディレクトリは、SHAによって、または <code>--import-marks</code> で設定されたツリーマークを介してのみ指定できます。
</p>
</li>
</ul></div>
<div class="paragraph"><p>どちらの形式でも、 <code>&lt;path&gt;</code> は、追加(まだ存在しない場合)または変更(すでに存在する場合)するファイルの完全なパスです。</p></div>
<div class="paragraph"><p><code>&lt;path&gt;</code> 文字列はUNIXスタイルのディレクトリ区切り文字(スラッシュ <code>/</code>)を使用する必要があり、 <code>LF</code> 以外のバイトを含めることができ、二重引用符(<code>"</code>)で始めることはできません。</p></div>
<div class="paragraph"><p>パスはC言語スタイルの文字列クォートを使用できます。 これはすべての場合に受け入れられ、ファイル名が二重引用符で始まるか、<code>LF</code> を含む場合は必須です。 C言語スタイルのクォートでは、完全な名前を二重引用符で囲み、 <code>LF</code>、 バックスラッシュ(<code>\</code>)、または二重引用符の文字の前に円記号を付けてエスケープする必要があります(例: <code>"path/with\n, \\ and \" in it"</code> )。</p></div>
<div class="paragraph"><p><code>&lt;path&gt;</code> の値は標準形(canonical form)でなければなりません。以下は禁止です:</p></div>
<div class="ulist"><ul>
<li>
<p>
空のディレクトリコンポーネントが含まれている(例: <code>foo//bar</code> は無効)、
</p>
</li>
<li>
<p>
ディレクトリ区切り文字で終了する(例: <code>foo/</code> は無効)、
</p>
</li>
<li>
<p>
ディレクトリ区切り文字で始まる(例: <code>/foo</code> は無効)、
</p>
</li>
<li>
<p>
特別なコンポーネント <code>.</code> または <code>..</code> を含む(例: <code>foo/./bar</code> や <code>foo/../bar</code> は無効)。
</p>
</li>
</ul></div>
<div class="paragraph"><p>ツリーのルートは、 <code>&lt;path&gt;</code> に空の文字列を指定します。</p></div>
<div class="paragraph"><p><code>&lt;path&gt;</code> は常にUTF-8を使用してエンコードすることをお勧めします。</p></div>
</div>
<div class="sect3">
<h4 id="_code_filedelete_code"><code>filedelete</code></h4>
<div class="paragraph"><p>ファイルを削除したり、ブランチからディレクトリ全体を再帰的に削除したりするために <code>commit</code> コマンドに含まれています。 ファイルまたはディレクトリを削除して、その親ディレクトリが空になると、親ディレクトリも自動的に削除されます。 これは、最初の空でないディレクトリまたはルートに到達するまで、ツリーを上流へ連鎖的にたどります(cascade up)。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'D' SP &lt;path&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;path&gt;</code> は、ブランチから削除されるファイルまたはサブディレクトリの完全なパスです。 <code>&lt;path&gt;</code> の詳細な説明については、上記の <code>filemodify</code> を参照してください。</p></div>
</div>
<div class="sect3">
<h4 id="_code_filecopy_code"><code>filecopy</code></h4>
<div class="paragraph"><p>既存のファイルまたはサブディレクトリをブランチ内の別の場所に再帰的にコピーします。 既存のファイルまたはディレクトリが存在する必要があります。 宛先が存在する場合は、ソースからコピーされたコンテンツに完全に置き換えられます。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'C' SP &lt;path&gt; SP &lt;path&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、最初の <code>&lt;path&gt;</code> はソースの場所であり、2番目の <code>&lt;path&gt;</code> は宛先です。 <code>&lt;path&gt;</code> がどのように見えるかの詳細な説明については、上記の <code>filemodify</code> を参照してください。 SPを含むソースパスを使用するには、パスを引用符で囲む必要があります。</p></div>
<div class="paragraph"><p><code>filecopy</code> コマンドの効果は即時です。ソースの場所が宛先にコピーされると、ソースの場所に適用される以降のコマンドは、コピーの宛先に影響を与えません。</p></div>
</div>
<div class="sect3">
<h4 id="_code_filerename_code"><code>filerename</code></h4>
<div class="paragraph"><p>既存のファイルまたはサブディレクトリの名前をブランチ内の別の場所に変更します。 既存のファイルまたはディレクトリが存在する必要があります。 宛先が存在する場合は、ソースディレクトリに置き換えられます。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'R' SP &lt;path&gt; SP &lt;path&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、最初の <code>&lt;path&gt;</code> はソースの場所であり、2番目の <code>&lt;path&gt;</code> は宛先です。 <code>&lt;path&gt;</code> がどのように見えるかの詳細な説明については、上記の <code>filemodify</code> を参照してください。 SPを含むソースパスを使用するには、パスを引用符で囲む必要があります。</p></div>
<div class="paragraph"><p><code>filerename</code> コマンドの効果は即時です。 ソースの場所の名前が宛先に変更されると、ソースの場所に適用される将来のコマンドは、そこに新しいファイルを作成し、名前変更の宛先に影響を与えません。</p></div>
<div class="paragraph"><p>注意: <code>filerename</code> は、 <code>filecopy</code> の後にソースの場所の <code>filedelete</code> が続くのと同じであることに注意してください。 <code>filerename</code> を使用することにはわずかなパフォーマンス上の利点がありますが、その利点は非常に小さいため、ソース素材の 削除/追加ペア を高速インポート用の名前変更に変換する価値はありません。 この <code>filerename</code> コマンドは、名前変更情報がすでにあるフロントエンドを単純化するために提供されており、それを <code>filecopy</code> とそれに続く <code>filedelete</code> に分解する必要はありません。</p></div>
</div>
<div class="sect3">
<h4 id="_code_filedeleteall_code"><code>filedeleteall</code></h4>
<div class="paragraph"><p>ブランチからすべてのファイル(およびすべてのディレクトリ)を削除するために <code>commit</code> コマンドに含まれています。 このコマンドは、内部ブランチ構造をリセットしてファイルを含まないようにし、フロントエンドの関心あるすべてのファイルを最初から追加できるようにします。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'deleteall' LF</code></pre>
</div></div>
<div class="paragraph"><p>このコマンドは、フロントエンドが現在ブランチ上にあるファイルを知らない(あるいは知ろうとしない)ため、コンテンツを更新するための適切な <code>filedelete</code> コマンドを生成できない場合に非常に役立ちます。</p></div>
<div class="paragraph"><p>正しいコンテンツを設定するために <code>filedeleteall</code> の後に必要な <code>filemodify</code> コマンドを発行すると、必要な <code>filemodify</code> および <code>filedelete</code> コマンドのみを送信するのと同じ結果が得られます。 しかし、<code>filedeleteall</code> のアプローチでは、fast-import がアクティブブランチごとに若干多くのメモリの使用を必要する場合があります(ほとんどの大規模プロジェクトでも1 MiB未満ではありますが)。 したがって、コミットの影響を受けるパスのみを簡単に取得できるフロントエンドは、コミットの影響を受けるパスのみを取得することをお勧めします。</p></div>
</div>
<div class="sect3">
<h4 id="_code_notemodify_code"><code>notemodify</code></h4>
<div class="paragraph"><p><code>&lt;commit-ish&gt;</code> に注釈する新しいノートを追加したり、この注釈の内容を変更したりするために <code>commit</code> <code>&lt;notes_ref&gt;</code> コマンドに含まれています。 内部的には、 <code>&lt;commit-ish&gt;</code> パスの <code>filemodify 100644</code> に似ています(サブディレクトリに分割されている可能性があります)。 <code>filedeleteall</code> 以外のコマンドを使用して <code>&lt;notes_ref&gt;</code> ツリーに書き込み、このツリー内の既存のノートをすべて削除することはお勧めしません。 このコマンドには、ノートの内容を指定する2つの異なる方法があります。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
External data format
</dt>
<dd>
<p>
        ノートのデータコンテンツは、以前の <code>blob</code> コマンドによってすでに提供されています。 フロントエンドは、注釈を付けるコミットに接続する必要があります。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'N' SP &lt;dataref&gt; SP &lt;commit-ish&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;dataref&gt;</code> は、前の <code>blob</code> コマンドによって設定されたマーク参照(<code>:&lt;idnum&gt;</code>)、または既存のGitブロブオブジェクトの完全な40バイトのSHA-1のいずれかです。</p></div>
</dd>
<dt class="hdlist1">
Inline data format
</dt>
<dd>
<p>
        ノートのデータ内容はまだ提供されていません。 フロントエンドは、この変更コマンドの一部としてそれを提供したいと考えています。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'N' SP 'inline' SP &lt;commit-ish&gt; LF
        data</code></pre>
</div></div>
<div class="paragraph"><p><code>data</code> コマンドの詳細については下記参照。</p></div>
</dd>
</dl></div>
<div class="paragraph"><p>どちらの形式でも、 <code>&lt;commit-ish&gt;</code> は、 <code>from</code> でも受け入れられるコミット仕様式のいずれかです(上記参照)。</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_code_mark_code"><code>mark</code></h3>
<div class="paragraph"><p>fast-import を手配して現在のオブジェクトへの参照を保存し、フロントエンドがSHA-1を知らなくても、将来の時点でこのオブジェクトを呼び出すことができるようにします。 ここで、現在のオブジェクトは、 <code>mark</code> コマンドが含まれるオブジェクト作成コマンドです。 これは <code>commit</code> や <code>tag</code> や <code>blob</code> にすることができますが、 <code>commit</code> が最も一般的な使用法です。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'mark' SP ':' &lt;idnum&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;idnum&gt;</code> は、フロントエンドによってこのマークに割り当てられた番号です。 <code>&lt;idnum&gt;</code> の値は、ASCIIの10進整数として表されます。 値0は予約されており、マークとして使用することはできません。 1以上の値のみをマークとして使用できます。</p></div>
<div class="paragraph"><p>新しいマークは自動的に作成されます。 同じ <code>&lt;idnum&gt;</code> を別の <code>mark</code> コマンドで再利用するだけで、既存のマークを別のオブジェクトに移動できます。</p></div>
</div>
<div class="sect2">
<h3 id="_code_original_oid_code"><code>original-oid</code></h3>
<div class="paragraph"><p>元のソース管理システムのオブジェクトの名前を提供します。 fast-import はこのディレクティブを単に無視しますが、fast-importにフィードする前にストリームを操作および変更するフィルタープロセスは、この情報を使用する場合があります。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'original-oid' SP &lt;object-identifier&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;object-identifier&gt;</code> は LF を含まない任意の文字列です。</p></div>
</div>
<div class="sect2">
<h3 id="_code_tag_code"><code>tag</code></h3>
<div class="paragraph"><p>特定のコミットを参照する注釈付きタグ(annotated tag)を作成します。 軽量(注釈なし)タグ(lightweight tag)を作成するには、下記 <code>reset</code> コマンドを参照してください。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'tag' SP &lt;name&gt; LF
        mark?
        'from' SP &lt;commit-ish&gt; LF
        original-oid?
        'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        data</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>&lt;name&gt;</code> は作成するタグの名前です。</p></div>
<div class="paragraph"><p>タグ名はGitに保存されるときに自動的に <code>refs/tags/</code> のプレフィックスが付けられるため、CVSブランチシンボル <code>RELENG-1_0-FINAL</code> をインポートすると、 <code>&lt;name&gt;</code> に <code>RELENG-1_0-FINAL</code> だけが使用され、 fast-importは対応するrefを <code>refs/tags/RELENG-1_0-FINAL</code> として書き込みます。</p></div>
<div class="paragraph"><p><code>&lt;name&gt;</code> の値は、Gitで有効なrefnameである必要があるため、スラッシュを含めることができます。 <code>LF</code> はGit refnameでは無効であるため、ここではクォートやエスケープ構文はサポートされていません。</p></div>
<div class="paragraph"><p><code>from</code> コマンドは <code>commit</code> コマンドと同じです。 詳細については、上記を参照してください。</p></div>
<div class="paragraph"><p><code>tagger</code> コマンドは、 <code>commit</code> 内の <code>committer</code> と同じ形式を使用します。 詳細については、再度上記を参照してください。</p></div>
<div class="paragraph"><p><code>tagger</code> に続く <code>data</code> コマンドは、注釈付きのタグメッセージを提供する必要があります(<code>data</code> コマンドの構文については以下を参照してください)。 空のタグメッセージをインポートするには、長さ0のデータを使用します。 タグメッセージは自由形式であり、Gitによって解釈されません。 fast-importでは他のエンコードを指定できないため、現在はUTF-8でエンコードする必要があります。</p></div>
<div class="paragraph"><p>fast-import内からのインポート中に注釈付きタグに署名することはサポートされていません。 フロントエンドは通常そのような署名に入るバイトの完全なセットに(簡単に)アクセスできないため、独自の PGP/GPG 署名を含めることはお勧めしません。 署名が必要な場合は、 <code>reset</code> を使用してfast-import内から軽量タグを作成し、標準の <code>git tag</code> プロセスを使用してそれらのタグの注釈付きバージョンをオフラインで作成します。</p></div>
</div>
<div class="sect2">
<h3 id="_code_reset_code"><code>reset</code></h3>
<div class="paragraph"><p>名前付きブランチを作成(または再作成)します。オプションで、特定のリビジョンから開始します。 resetコマンドを使用すると、フロントエンドは既存のブランチに対して新しい <code>from</code> コマンドを発行したり、新しいコミットを作成せずに既存のコミットから新しいブランチを作成したりできます。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'reset' SP &lt;ref&gt; LF
        ('from' SP &lt;commit-ish&gt; LF)?
        LF?</code></pre>
</div></div>
<div class="paragraph"><p><code>&lt;ref&gt;</code> と <code>&lt;commit-ish&gt;</code> の詳細については、上記 <code>commit</code> と <code>from</code> を参照してください。</p></div>
<div class="paragraph"><p>コマンドの後の <code>LF</code> はオプションです(以前は必須でした)。</p></div>
<div class="paragraph"><p><code>reset</code> コマンドを使用して、軽量(注釈なし)タグ(lightweight tag)を作成することもできます。 例えば:</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>reset refs/tags/938
from :938</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>これはコミットマーク <code>:938</code> が参照するものを参照して、軽量タグ <code>refs/tags/938</code> を作成します。</p></div>
</div>
<div class="sect2">
<h3 id="_code_blob_code"><code>blob</code></h3>
<div class="paragraph"><p>パックファイルに1つのファイルリビジョンを書き込むように要求します。 リビジョンはコミットに接続されていません。 この接続は、割り当てられたマークを介してブロブを参照することにより、後続の <code>commit</code> コマンドで形成する必要があります。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'blob' LF
        mark?
        original-oid?
        data</code></pre>
</div></div>
<div class="paragraph"><p>一部のフロントエンドが独自にブロブのGitSHA-1を生成し、それを直接 <code>commit</code> にフィードすることを選択したため、ここではmarkコマンドはオプションです。 ただし、マークは安価で保管しやすく、使い勝手も良いため、これは一般的にはマークより手間がかかると思われます。</p></div>
</div>
<div class="sect2">
<h3 id="_code_data_code"><code>data</code></h3>
<div class="paragraph"><p>生データ(ブロブ/ファイル コンテンツ または コミットメッセージ または 注釈付きタグメッセージ として使用するため)をfast-importに提供します。 データは、正確なバイトカウントを使用して提供することも、終了行で区切ることもできます。 本番品質の変換を目的とした実際のフロントエンドは、より堅牢でパフォーマンスが高いため、常に正確なバイトカウント形式を使用する必要があります。 区切られた形式は、主にfast-importのテストを目的としています。</p></div>
<div class="paragraph"><p><code>data</code> コマンドの <code>&lt;raw&gt;</code> 部分に表示されるコメント行は、常にデータの本文の一部と見なされるため、fast-importによって無視されることはありません。 これにより、行が <code>#</code> で始まる可能性のある ファイル/メッセージ コンテンツを安全にインポートできます。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Exact byte count format
</dt>
<dd>
<p>
        フロントエンドは、データのバイト数を指定する必要があります。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'data' SP &lt;count&gt; LF
        &lt;raw&gt; LF?</code></pre>
</div></div>
<div class="paragraph"><p>ここで、<code>&lt;count&gt;</code> は <code>&lt;raw&gt;</code> 内に表示される正確なバイト数です。 <code>&lt;count&gt;</code> の値はASCII10進整数として表されます。 <code>&lt;raw&gt;</code> の両側の <code>LF</code> は <code>&lt;count&gt;</code> に含まれず、インポートされたデータに含まれません。</p></div>
<div class="paragraph"><p><code>&lt;raw&gt;</code> の後の <code>LF</code> はオプションです(以前は必須でした)が、推奨されます。 <code>&lt;raw&gt;</code> が <code>LF</code> で終わっていなくても、次のコマンドは常に次の行の列0で開始するため、常にこれを含めると、fast-importストリームのデバッグが容易になります。</p></div>
</dd>
<dt class="hdlist1">
Delimited format
</dt>
<dd>
<p>
        区切り文字列は、データの終わりを示すために使用されます。 fast-importは、区切り文字を検索して長さを計算します。 この形式は主にテストに役立ち、実際のデータにはお勧めしません。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'data' SP '&lt;&lt;' &lt;delim&gt; LF
        &lt;raw&gt; LF
        &lt;delim&gt; LF
        LF?</code></pre>
</div></div>
<div class="paragraph"><p>ここで、<code>&lt;delim&gt;</code> は選択された区切り文字列です。 文字列 <code>&lt;delim&gt;</code> は、 <code>&lt;raw&gt;</code> 内の行に単独で表示されてはなりません。そうしないと、fast-importはデータが実際よりも早く終了すると見なします。 <code>&lt;raw&gt;</code> の直後に続く <code>LF</code> は <code>&lt;raw&gt;</code> の一部です。 これは区切り形式の制限の1つであり、最後のバイトとしてLFを持たないデータチャンクを提供することはできません。</p></div>
<div class="paragraph"><p><code>&lt;delim&gt; LF</code> の後の <code>LF</code> はオプションです(以前は必須でした)。</p></div>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_code_alias_code"><code>alias</code></h3>
<div class="paragraph"><p>最初に新しいオブジェクトを作成せずに、マークが特定のオブジェクトを参照していることを記録します。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'alias' LF
        mark
        'to' SP &lt;commit-ish&gt; LF
        LF?</code></pre>
</div></div>
<div class="paragraph"><p><code>&lt;commit-ish&gt;</code> の詳細については、上記の <code>from</code> を参照してください。</p></div>
</div>
<div class="sect2">
<h3 id="_code_checkpoint_code"><code>checkpoint</code></h3>
<div class="paragraph"><p>fast-importを強制して、現在のパックファイルを閉じ、新しいパックファイルを開始し、現在のすべてのブランチ参照とタグとマークを保存します。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'checkpoint' LF
        LF?</code></pre>
</div></div>
<div class="paragraph"><p>注意: fast-importは、現在のパックファイルが <code>--max-pack-size</code> または 4 GiB のいずれか小さい方の制限に達すると、パックファイルを自動的に切り替えることに注意してください。 自動パックファイル切り替え中、fast-importは、ブランチの参照またはタグまたはマーク を更新しません。</p></div>
<div class="paragraph"><p><code>checkpoint</code> はかなりのCPU時間とディスクI/Oを必要とする可能性があるため(パック全体のSHA-1チェックサムを計算し、対応するインデックスファイルを生成し、refを更新するため)、単一の <code>checkpoint</code> コマンド完了に数分かかる場合があります。</p></div>
<div class="paragraph"><p>フロントエンドは、非常に大規模で長時間実行されるインポート中、または別のGitプロセスにブランチへのアクセスを許可する必要があるときにチェックポイントを発行することを選択できます。 ただし、30 GiB Subversion リポジトリを fast-import によって約3時間でGitにロードできることを考えると、明示的なチェックポイントは必要ない場合があります。</p></div>
<div class="paragraph"><p>コマンドの後の <code>LF</code> はオプションです(以前は必須でした)。</p></div>
</div>
<div class="sect2">
<h3 id="_code_progress_code"><code>progress</code></h3>
<div class="paragraph"><p>コマンドが入力ストリームから処理されるときに、fast-importが <code>progress</code> 行全体を変更せずに標準の出力チャネル(ファイルデスクリプタ 1)に出力します。 それ以外の場合、このコマンドは現在のインポートやfast-importの内部状態には影響しません。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'progress' SP &lt;any&gt; LF
        LF?</code></pre>
</div></div>
<div class="paragraph"><p>コマンドの <code>&lt;any&gt;</code> 部分には、 <code>LF`を含まないバイトシーケンスを含めることができます。 コマンドの後の `LF</code> はオプションです。 呼び出し元は、sedなどのツールを使用して出力を処理し、行の先頭部分を削除したい場合があります。以下に例を示します:</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>frontend | git fast-import | sed 's/^progress //'</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p><code>checkpoint</code> の直後に <code>progress`コマンドを配置すると、 `checkpoint</code> が完了したときにリーダーに通知され、fast-importで更新されたrefに安全にアクセスできます。</p></div>
</div>
<div class="sect2">
<h3 id="_code_get_mark_code"><code>get-mark</code></h3>
<div class="paragraph"><p>fast-importが、標準出力または <code>--cat-blob-fd</code> 引数であらかじめ指定されたファイルディスクリプタに、マークに対応するSHA-1を表示するようにします。 それ以外の場合、コマンドは現在のインポートに影響を与えません。 その目的は、後でコミットがコミットメッセージで参照する可能性のあるSHA-1を取得することです。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'get-mark' SP ':' &lt;idnum&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。</p></div>
</div>
<div class="sect2">
<h3 id="_code_cat_blob_code"><code>cat-blob</code></h3>
<div class="paragraph"><p>fast-importにより、以前に <code>--cat-blob-fd</code> 引数で設定されたファイルデスクリプタにブロブが出力されます。 それ以外の場合、コマンドは現在のインポートに影響を与えません。 その主な目的は、fast-importのメモリにある可能性があるが、ターゲットリポジトリからはアクセスできないブロブを取得することです。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'cat-blob' SP &lt;dataref&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p><code>&lt;dataref&gt;</code> は、以前に設定されたマーク参照(<code>:&lt;idnum&gt;</code>)か、既存または書き込みの準備ができているGitブロブの完全な40バイトのSHA-1のいずれかです。</p></div>
<div class="paragraph"><p>出力は <code>git cat-file --batch</code> と同一形式を使用します:</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>&lt;sha1&gt; SP 'blob' SP &lt;size&gt; LF
&lt;contents&gt; LF</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>このコマンドは、 <code>filemodify</code> ディレクティブを表示できる場所で使用でき、コミットの途中で使用できます。 インラインディレクティブを使用する <code>filemodify</code> の場合、 <code>data</code> ディレクティブの直前に表示することもできます。</p></div>
<div class="paragraph"><p>この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。</p></div>
</div>
<div class="sect2">
<h3 id="_code_ls_code"><code>ls</code></h3>
<div class="paragraph"><p>パスにあるオブジェクトに関する情報を、事前に <code>--cat-blob-fd</code> 引数で指定したファイルディスクリプタへ出力します。 これにより、アクティブなコミットからブロブを表示したり(<code>cat-blob</code> を使用)、以前のコミットからブロブやツリーをコピーして現在のコミットで使用したり(<code>filemodify</code> を使用))することができます。</p></div>
<div class="paragraph"><p><code>ls</code> コマンドは、 <code>filemodify</code> ディレクティブを表示できる場所でも使用でき、コミットの途中で使用できます。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Reading from the active commit
</dt>
<dd>
<p>
        この形式は、<code>commit</code> の途中でのみ使用できます。 パスは、fast-importのアクティブなコミット内のディレクトリエントリに名前を付けます。 この場合、パスはクォートする必要があります。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'ls' SP &lt;path&gt; LF</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
Reading from a named tree
</dt>
<dd>
<p>
        <code>&lt;dataref&gt;</code> は、マーク参照(<code>:&lt;idnum&gt;</code>)、またはGitタグ、コミット、ツリーオブジェクトの完全な40バイトのSHA-1であり、既存または書き込みを待機しています。 パスは、 <code>&lt;dataref&gt;</code> で指定されたツリーの最上位を基準にしています。
</p>
<div class="literalblock">
<div class="content">
<pre><code>        'ls' SP &lt;dataref&gt; SP &lt;path&gt; LF</code></pre>
</div></div>
</dd>
</dl></div>
<div class="paragraph"><p><code>&lt;path&gt;</code> の詳細な説明については、上記の <code>filemodify</code> を参照してください。</p></div>
<div class="paragraph"><p>出力は <code>git ls-tree &lt;tree&gt; -- &lt;path&gt;</code> と同一形式を使用します:</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>&lt;mode&gt; SP ('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT &lt;path&gt; LF</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>&lt;dataref&gt;は、&lt;path&gt;にあるblob、tree、またはcommitオブジェクトを表し、後の <code>get-mark</code> 、 <code>cat-blob</code> 、 <code>filemodify</code> 、 <code>ls</code> コマンドで使用できます。</p></div>
<div class="paragraph"><p>そのパスにファイルまたはサブツリーがない場合、 <code>git fast-import</code> が代わりに報告します</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>missing SP &lt;path&gt; LF</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。</p></div>
</div>
<div class="sect2">
<h3 id="_code_feature_code"><code>feature</code></h3>
<div class="paragraph"><p>fast-importが指定の機能をサポートすることを要求するか、サポートしない場合は中止(abort)します。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        'feature' SP &lt;feature&gt; ('=' &lt;argument&gt;)? LF</code></pre>
</div></div>
<div class="paragraph"><p>コマンドの &lt;feature&gt; 部分は、以下のいずれかになります:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
date-format
</dt>
<dt class="hdlist1">
export-marks
</dt>
<dt class="hdlist1">
relative-marks
</dt>
<dt class="hdlist1">
no-relative-marks
</dt>
<dt class="hdlist1">
force
</dt>
<dd>
<p>
        先頭に <code>--</code> が付いた対応するコマンドラインオプションが、コマンドラインで渡されたかのように動作します(上記 OPTIONS 参照)。
</p>
</dd>
<dt class="hdlist1">
import-marks
</dt>
<dt class="hdlist1">
import-marks-if-exists
</dt>
<dd>
<p>
        <code>--import-marks</code> と同様ですが、2つの点が異なります。まず、ストリームごとに1つの <code>feature import-marks</code> または <code>feature import-marks-if-exists</code> コマンドのみが許可されます。 次に、 <code>--import-marks=</code> または <code>--import-marks-if-exists</code> コマンドラインオプションは、ストリーム内のこれらの「feature」コマンドのいずれかをオーバーライドします。 第3に、対応するコマンドラインオプションのような <code>feature import-marks-if-exists</code> は、存在しないファイルを黙ってスキップします。
</p>
</dd>
<dt class="hdlist1">
get-mark
</dt>
<dt class="hdlist1">
cat-blob
</dt>
<dt class="hdlist1">
ls
</dt>
<dd>
<p>
        バックエンドがそれぞれ <code>get-mark</code> または <code>cat-blob</code> または <code>ls</code> コマンドをサポートしていることを要求します。 指定されたコマンドをサポートしていないバージョンのfast-importは、そのことを示すメッセージとともに終了します。 これにより、サポートされていないコマンドが検出される前にインポートの初期部分で時間を無駄にするのではなく、明確なメッセージでインポートエラーを早期に発生させることができます。
</p>
</dd>
<dt class="hdlist1">
notes
</dt>
<dd>
<p>
        バックエンドが <code>commit</code> コマンドの <code>notemodify</code> (N) サブコマンドをサポートしていることを要求します。 ノートをサポートしていないfast-importのバージョンは、そのことを示すメッセージとともに終了します。
</p>
</dd>
<dt class="hdlist1">
done
</dt>
<dd>
<p>
        <code>done</code> コマンドなしでストリームが終了した場合はエラーになります。 この機能がないと、ストリーム内の便利なポイントでフロントエンドが突然終了する原因となるエラーが検出されなくなる可能性があります。 これは、たとえば、インポートフロントエンドがその下位のgit fast-importインスタンスでSIGTERMまたはSIGKILLを発行せずに、操作の途中で停止した場合に発生する可能性があります。
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_code_option_code"><code>option</code></h3>
<div class="paragraph"><p>指定されたオプションを処理して、git fast-importがフロントエンドのニーズに合った方法で動作するようにします。 フロントエンドで指定されたオプションは、ユーザーがgit fast-import自体に指定したオプションによって上書きされることに注意してください。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    'option' SP &lt;option&gt; LF</code></pre>
</div></div>
<div class="paragraph"><p>コマンドの <code>&lt;option&gt;</code> 部分には、OPTIONSセクションにリストされているオプションのいずれかを含めることができます。これらのオプションは、先頭の <code>--</code> がなくても、インポートのセマンティクスを変更せず、同じように扱われます。</p></div>
<div class="paragraph"><p>optionコマンドは、非オプションコマンドがエラーになった後にオプションコマンドを与えるために、入力の最初のコマンドである必要があります(featureコマンドはカウントされません)。</p></div>
<div class="paragraph"><p>以下のコマンドラインオプションはインポートセマンティクスを変更するため、オプションとして渡されない場合があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
date-format
</p>
</li>
<li>
<p>
import-marks
</p>
</li>
<li>
<p>
export-marks
</p>
</li>
<li>
<p>
cat-blob-fd
</p>
</li>
<li>
<p>
force
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_done_code"><code>done</code></h3>
<div class="paragraph"><p><code>done</code> 機能が使用されていない場合は、EOFが読み取られたかのように扱われます。 これを使用して、fast-importに早期に終了するように指示できます。</p></div>
<div class="paragraph"><p><code>--done</code> コマンドラインオプションまたは <code>feature done</code> コマンドが使用されている場合、 <code>done</code> コマンドは必須であり、ストリームの終わりを示します。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_responses_to_commands">RESPONSES TO COMMANDS</h2>
<div class="sectionbody">
<div class="paragraph"><p>fast-importによって作成された新しいオブジェクトはすぐには利用できません。 ほとんどのfast-importコマンドは、次のチェックポイント(または完了)まで目に見える効果はありません。 フロントエンドは、コマンドが有効になる速度を気にせずに、fast-importの入力パイプを埋めるためのコマンドを送信できます。これにより、スケジューリングが簡素化され、パフォーマンスが向上します。</p></div>
<div class="paragraph"><p>ただし、一部のフロントエンドでは、更新中に現在のリポジトリからデータを読み戻すことができると便利です(たとえば、ソース素材が、以前にインポートされたオブジェクトに適用されるパッチの観点からオブジェクトを記述している場合)。 これは、フロントエンドとfast-importを双方向パイプを介して接続することで実現できます:</p></div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>mkfifo fast-import-output
frontend &lt;fast-import-output |
git fast-import &gt;fast-import-output</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>このように設定されたフロントエンドは、 <code>progress</code> 、 <code>get-mark</code> 、 <code>ls</code> 、 <code>cat-blob</code> コマンドを使用して、進行中のインポートから情報を読み取ることができます。</p></div>
<div class="paragraph"><p>デッドロックを回避するために、このようなフロントエンドは、ブロックする可能性のあるfast-importへの書き込みを実行する前に、 <code>progress</code> 、 <code>ls</code> 、 <code>get-mark</code> 、 <code>cat-blob</code> からの保留中の出力を完全に消費する必要があります。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_crash_reports">CRASH REPORTS</h2>
<div class="sectionbody">
<div class="paragraph"><p>fast-importに無効な入力が指定された場合、ゼロ以外の終了ステータスで終了し、インポート先のGitリポジトリのトップレベルにクラッシュレポートが作成されます。 クラッシュレポートには、内部のfast-import状態のスナップショットと、クラッシュにつながる最も最近のコマンドが含まれています。</p></div>
<div class="paragraph"><p>最近のすべてのコマンド(ストリームコメント、ファイル変更、進行状況コマンドを含む)は、クラッシュレポート内のコマンド履歴に表示されますが、生のファイルデータとコミットメッセージはクラッシュレポートから除外されます。 この除外により、レポートファイル内のスペースが節約され、fast-importが実行中に実行する必要のあるバッファリングの量が削減されます。</p></div>
<div class="paragraph"><p>クラッシュレポートを作成した後、fast-importは現在のパックファイルを閉じ、マークテーブルをエクスポートします。 これにより、フロントエンド開発者はリポジトリの状態を検査し、クラッシュしたポイントからインポートを再開できます。 インポートが正常に完了しなかったため、変更されたブランチとタグはクラッシュ時に更新されません。 ブランチとタグの情報はクラッシュレポートに記載されており、更新が必要な場合は手動で適用する必要があります。</p></div>
<div class="paragraph"><p>クラッシュ例:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        $ cat &gt;in &lt;&lt;END_OF_INPUT
        # my very first test commit
        commit refs/heads/master
        committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
        # who is that guy anyway?
        data &lt;&lt;EOF
        this is my commit
        EOF
        M 644 inline .gitignore
        data &lt;&lt;EOF
        .gitignore
        EOF
        M 777 inline bob
        END_OF_INPUT

        $ git fast-import &lt;in
        fatal: Corrupt mode: M 777 inline bob
        fast-import: dumping crash report to .git/fast_import_crash_8434

        $ cat .git/fast_import_crash_8434
        fast-import crash report:
            fast-import process: 8434
            parent process     : 1391
            at Sat Sep 1 00:58:12 2007

        fatal: Corrupt mode: M 777 inline bob

        Most Recent Commands Before Crash
        ---------------------------------
          # my very first test commit
          commit refs/heads/master
          committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
          # who is that guy anyway?
          data &lt;&lt;EOF
          M 644 inline .gitignore
          data &lt;&lt;EOF
        * M 777 inline bob

        Active Branch LRU
        -----------------
            active_branches = 1 cur, 5 max

          pos  clock name
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           1)      0 refs/heads/master

        Inactive Branches
        -----------------
        refs/heads/master:
          status      : active loaded dirty
          tip commit  : 0000000000000000000000000000000000000000
          old tree    : 0000000000000000000000000000000000000000
          cur tree    : 0000000000000000000000000000000000000000
          commit clock: 0
          last pack   :


        -------------------
        END OF CRASH REPORT</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_tips_and_tricks">TIPS AND TRICKS</h2>
<div class="sectionbody">
<div class="paragraph"><p>以下のヒントとコツは、fast-importのさまざまなユーザーから収集されたものであり、提案として提供されています。</p></div>
<div class="sect2">
<h3 id="_use_one_mark_per_commit">Use One Mark Per Commit</h3>
<div class="paragraph"><p>リポジトリ変換を行うときは、コミットごとに一意のマーク(<code>mark :&lt;n&gt;</code>)を使用し、コマンドラインで <code>--export-marks</code> オプションを指定します。 fast-importは、すべてのマークとそれに対応するGitオブジェクトSHA-1をリストするファイルをダンプします。 フロントエンドがマークをソースリポジトリに結び付けることができる場合、各Gitコミットを対応するソースリビジョンと比較することで、インポートの正確性と完全性を簡単に確認できます。</p></div>
<div class="paragraph"><p>PerforceやSubversionなどのシステムから来る場合、これは非常に単純なはずです。fast-importマークは、Perforceのチェンジセット番号またはSubversionのリビジョン番号でもある可能性があるためです。</p></div>
</div>
<div class="sect2">
<h3 id="_freely_skip_around_branches">Freely Skip Around Branches</h3>
<div class="paragraph"><p>インポート中に一度に1つのブランチに固執するようにフロントエンドをわざわざ最適化しようとしないでください。 これを行うと、fast-importの場合は少し速くなる可能性がありますが、フロントエンドコードの複雑さが大幅に増す傾向があります。</p></div>
<div class="paragraph"><p>高速インポートに組み込まれているブランチLRUは非常に適切に動作する傾向があり、非アクティブなブランチをアクティブ化するコストは非常に低いため、ブランチ間でのバウンスはインポートのパフォーマンスに実質的に影響しません。</p></div>
</div>
<div class="sect2">
<h3 id="_handling_renames">Handling Renames</h3>
<div class="paragraph"><p>名前を変更したファイルまたはディレクトリをインポートするときは、対応するコミット中に古い名前を削除し、新しい名前を変更するだけです。 Gitは、コミット中に明示的にではなく、事後に名前変更の検出を実行します。</p></div>
</div>
<div class="sect2">
<h3 id="_use_tag_fixup_branches">Use Tag Fixup Branches</h3>
<div class="paragraph"><p>他のいくつかのSCMシステムでは、ユーザーは同じ コミット/チェンジセット からではない複数のファイルからタグを作成できます。 または、リポジトリで使用可能なファイルのサブセットであるタグを作成します。</p></div>
<div class="paragraph"><p>これらのタグをそのままGitにインポートするには、タグのコンテンツと一致するようにファイルを「修正」するコミットを少なくとも1つ実行する必要があります。 fast-importの <code>reset</code> コマンドを使用して、通常のブランチスペースの外側にあるダミーブランチをタグのベースコミットにリセットし、1つ以上のファイル修正コミットをコミットして、最後にダミーブランチにタグを付けます。</p></div>
<div class="paragraph"><p>たとえば、すべての通常のブランチは <code>refs/heads/</code> の下に保存されるため、タグ修正ブランチには <code>TAG_FIXUP</code> という名前を付けます。 このように、インポーターによって使用される修正ブランチが、ソースからインポートされた実際のブランチと名前空間の競合を持つことは不可能です((名前 <code>TAG_FIXUP</code> は <code>refs/heads/TAG_FIXUP</code> ではありません)。</p></div>
<div class="paragraph"><p>フィックスアップ(fixup)をコミットするときは、 <code>merge</code> を使用してファイルリビジョンを提供しているコミットをフィックスアップブランチに接続することを検討してください。 そうすることで、 <code>git blame</code> などのツールが実際のコミット履歴を追跡し、ソースファイルに適切に注釈を付けることができます。</p></div>
<div class="paragraph"><p>fast-importが終了した後、フロントエンドはダミーブランチを削除するために <code>rm .git/TAG_FIXUP</code> を実行する必要があります。</p></div>
</div>
<div class="sect2">
<h3 id="_import_now_repack_later">Import Now, Repack Later</h3>
<div class="paragraph"><p>fast-importが完了するとすぐに、Gitリポジトリは完全に有効になり、使用できるようになります。 通常、これは非常に大規模なプロジェクト(100,000以上のコミット)の場合でも、非常に短い時間しかかかりません。</p></div>
<div class="paragraph"><p>ただし、データの局所性とアクセスパフォーマンスを向上させるには、リポジトリを再パックする必要があります。 また、非常に大規模なプロジェクトでは数時間かかる場合があります(特に、 <code>-f</code> および 大きな <code>--window</code> パラメーターが使用されている場合)。 再パックはリーダーやライターと一緒に実行しても安全なので、バックグラウンドで再パックを実行し、再パックが終了したらリーダーやライターを終了させます。 あなたが新しいGitプロジェクトに挑戦するのを待たされる事はありません！</p></div>
<div class="paragraph"><p>あなたが再パックを待つことを選択した場合は、再パックが完了するまでベンチマークやパフォーマンステストを実行しないでください。 その場合、 fast-importは、実際の使用状況では決して見られないような、最適でないパックファイルを出力します。</p></div>
</div>
<div class="sect2">
<h3 id="_repacking_historical_data">Repacking Historical Data</h3>
<div class="paragraph"><p>非常に古くにインポートされたデータ(たとえば、昨年より古い)を再パックする場合は、 <code>git repack</code> を実行するときに、 <code>--window=50</code> (またはそれ以上)を指定して余分なCPU時間を費やすことを検討してください。 これには時間がかかりますが、作成されるパックファイルも小さくなります。 あなたが労力を費やす必要があるのは1回だけで、あなたのプロジェクトを使用するすべての人が小さくなったリポジトリの恩恵を受けることができます。</p></div>
</div>
<div class="sect2">
<h3 id="_include_some_progress_messages">Include Some Progress Messages</h3>
<div class="paragraph"><p>時々、フロントエンドに <code>progress</code> メッセージを送信してfast-importします。 メッセージの内容は完全に自由形式であるため、現在のコミット日が翌月に移動するたびに、現在の月と年を出力することをお勧めします。あなたのユーザーは、処理されたデータストリームの量をよりよく知ることができます。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_packfile_optimization">PACKFILE OPTIMIZATION</h2>
<div class="sectionbody">
<div class="paragraph"><p>ブロブを高速にパックする場合、インポートは常に最後に書き込まれたブロブに対して削除を試みます。 フロントエンドによって特別に調整されていない限り、これはおそらく同じファイルの以前のバージョンではないため、生成されるデルタは可能な限り最小にはなりません。 結果のパックファイルは圧縮されますが、最適ではありません。</p></div>
<div class="paragraph"><p>単一のファイルのすべてのリビジョンに効率的にアクセスできるフロントエンド(たとえば、 RCS/CVS ,v file の読み取り)は、連続する <code>blob</code> コマンドのシーケンスとして、そのファイルのすべてのリビジョンを提供することを選択できます。 これにより、fast-importでさまざまなファイルリビジョンを相互に区別し、最終的なパックファイルのスペースを節約できます。 マークは、後で一連の <code>commit</code> コマンド中に個々のファイルリビジョンを識別するために使用できます。</p></div>
<div class="paragraph"><p>fast-importによって作成されたパックファイルは、適切なディスクアクセスパターンを促進しません。 これは、標準入力で受信した順序でデータをfast-importで書き込むことが原因ですが、Gitは通常、パックファイル内のデータを整理して、最新の(現在の先端)データを履歴データの前に表示します。 Gitはまた、コミットをクラスター化し、キャッシュの局所性を向上させることでリビジョンのトラバーサルを高速化します。</p></div>
<div class="paragraph"><p>このため、fast-importが完了した後、ユーザーがリポジトリを <code>git repack -a -d</code> で再パックし、Gitがパックファイルを再編成してデータアクセスを高速化できるようにすることを強くお勧めします。 ブロブデルタが最適ではない場合(上記参照)、すべてのデルタの再計算を強制するために <code>-f</code> オプションを追加すると、最終的なパックファイルサイズを大幅に減らすことができます(ほとんどの場合30〜50%小さくなります)。</p></div>
<div class="paragraph"><p><code>git repack</code> を実行する代わりに、 <code>git gc --aggressive</code> を実行することもできます。これにより、インポート後に他のものも最適化されます(たとえば、loose refs をパックします)。 <a href="git-gc.html">git-gc(1)</a> の「AGGRESSIVE」セクションに記載されているように、 <code>--aggressive`オプションは、 linkgit:git-repack[1] への `-f</code> オプションを使用して新しいデルタを検索します。 上記で詳しく説明した理由により、fast-importの後に <code>--aggressive</code> を使用することは、価値があることがわかっている数少ないケースの1つです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_memory_utilization">MEMORY UTILIZATION</h2>
<div class="sectionbody">
<div class="paragraph"><p>fast-importがインポートを実行するために必要なメモリの量に影響を与えるいくつかの要因があります。 コアGitのクリティカルセクションと同様に、fast-importは独自のメモリアロケータを使用して、mallocに関連するオーバーヘッドを減らします。 実際には、fast-importは、大きなブロック割り当てを使用するため、mallocオーバーヘッドを0に減らす傾向があります。</p></div>
<div class="sect2">
<h3 id="_per_object">per object</h3>
<div class="paragraph"><p>fast-importは、この実行で書き込まれるすべてのオブジェクトのメモリ内構造を維持します。 32ビットシステムでは、構造は32バイトですが、64ビットシステムでは、構造は40バイトです(ポインタサイズが大きいため)。 テーブル内のオブジェクトは、fast-importが終了するまで割り当てが解除されません。 32ビットシステムに200万個のオブジェクトをインポートするには、約64MiBのメモリが必要です。</p></div>
<div class="paragraph"><p>オブジェクトテーブルは、実際にはオブジェクト名(一意のSHA-1)をキーとするハッシュテーブルです。 このストレージ構成により、fast-importで既存または既に書き込まれたオブジェクトを再利用し、出力パックファイルへの重複の書き込みを回避できます。 インポートでは、ブロブの重複が驚くほど一般的です。これは通常、ソースでのブランチのマージが原因です。</p></div>
</div>
<div class="sect2">
<h3 id="_per_mark">per mark</h3>
<div class="paragraph"><p>マークは、マークごとに1つのポインター(ポインターのサイズに応じて4バイトまたは8バイト)を使用して、まばらな配列に格納されます。 配列はまばらですが、フロントエンドでは 1〜n のマークを使用することを強くお勧めします。ここで、n はこのインポートに必要なマークの総数です。</p></div>
</div>
<div class="sect2">
<h3 id="_per_branch">per branch</h3>
<div class="paragraph"><p>ブランチはアクティブと非アクティブにクラス分けされます。 2つのクラスのメモリ使用量は大幅に異なります。</p></div>
<div class="paragraph"><p>非アクティブなブランチは、ブランチごとに96バイトまたは120バイト(それぞれ32ビットまたは64ビットシステム)とブランチ名の長さ(通常は200バイト未満)を使用する構造に格納されます。 fast-importは、2MiB未満のメモリで10,000もの非アクティブなブランチを簡単に処理します。</p></div>
<div class="paragraph"><p>アクティブなブランチには非アクティブなブランチと同じオーバーヘッドがありますが、そのブランチで最近変更されたすべてのツリーのコピーも含まれています。 ブランチがアクティブになってからサブツリー <code>include</code> が変更されていない場合、その内容はメモリに読み込まれませんが、ブランチがアクティブになってからコミットによってサブツリー <code>src</code> が変更されている場合、その内容はメモリに読み込まれます。</p></div>
<div class="paragraph"><p>アクティブなブランチは、そのブランチに含まれるファイルに関するメタデータを格納するため、メモリ内のストレージサイズがかなり大きくなる可能性があります(以下参照)。</p></div>
<div class="paragraph"><p>fast-importは、単純な「最も最近使用されていない」アルゴリズム(least-recently-used algorithm)に基づいて、アクティブなブランチを自動的に非アクティブなステータスに移動します。 LRUチェーンは、<code>commit</code> コマンドごとに更新されます。 アクティブなブランチの最大数は、コマンドラインで <code>--active-branches=</code> を使用して増減できます。</p></div>
</div>
<div class="sect2">
<h3 id="_per_active_tree">per active tree</h3>
<div class="paragraph"><p>ツリー(別名ディレクトリ)は、エントリに必要なメモリに加えて、わずか12バイトのメモリを使用します(以下「per active file」参照)。 ツリーのオーバーヘッドは個々のファイルエントリで償却されるため、ツリーのコストは実質的に0です。</p></div>
</div>
<div class="sect2">
<h3 id="_per_active_file_entry">per active file entry</h3>
<div class="paragraph"><p>アクティブツリー内のファイル(およびサブツリーへのポインター)には、エントリごとに52バイトまたは64バイト(32/64 ビットプラットフォーム)が必要です。 スペースを節約するために、ファイル名とツリー名は共通の文字列テーブルにプールされ、ファイル名 <code>Makefile</code> が(文字列ヘッダーのオーバーヘッドを含めた後)、プロジェクト内で何度発生しても、わずか16バイトしか使用しないようにします。</p></div>
<div class="paragraph"><p>アクティブブランチLRUは、ファイル名文字列プールおよびサブツリーの遅延読み込みと組み合わせると、fast-importにより、非常に限られたメモリフットプリント(アクティブブランチあたり2.7 MiB未満)で2,000以上のブランチと45,114以上のファイルを持つプロジェクトを効率的にインポートできます。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_signals">SIGNALS</h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>SIGUSR1</strong> を <code>git fast-import</code> プロセスに送信すると、現在のパックファイルが早期に終了し、 <code>checkpoint</code> コマンドがシミュレートされます。 せっかちなオペレーターは、この機能を使用して、実行時間の追加と圧縮率の低下を犠牲にして、進行中のインポートからオブジェクトとrefを確認できます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration">CONFIGURATION</h2>
<div class="sectionbody">
<div class="paragraph"><p>このセクションの以下のすべては、 <a href="git-config.html">git-config(1)</a> ドキュメントの抜粋です。 内容は <a href="git-config.html">git-config(1)</a> ドキュメント にあるものと同一です:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
fastimport.unpackLimit
</dt>
<dd>
<p>
        <a href="git-fast-import.html">git-fast-import(1)</a> によってインポートされたオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、インポートされたオブジェクトの数がこの制限以上の場合、パックはパックとして保存されます。 fast-import(高速インポート)からパックを保存すると、特に低速のファイルシステムで、インポート操作をより速く完了することができます。 設定されていない場合は、代わりに <code>transfer.unpackLimit</code> の値が使用されます。
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">SEE ALSO</h2>
<div class="sectionbody">
<div class="paragraph"><p><a href="git-fast-export.html">git-fast-export(1)</a></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-07-18 11:56:01 JST
</div>
</div>
</body>
</html>
