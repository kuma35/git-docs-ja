<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>git-rebase(1)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
git-rebase(1) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>git-rebase -
   別のベースの先端のその先頭にコミットを再適用します
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]
        [--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]
<em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
        --root [&lt;branch&gt;]
<em>git rebase</em> (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>&lt;branch&gt;が指定されている場合、 <em>git rebase</em> は他の処理を行う前に自動で <code>git switch &lt;branch&gt;</code>
を実行します。それ以外の場合は、現在のブランチに残ります。</p></div>
<div class="paragraph"><p>&lt;upstream&gt; が指定されていない場合、 branch.&lt;name&gt;.remote と branch.&lt;name&gt;.merge
オプションで構成されたアップストリーム(詳細は <a href="git-config.html">git-config(1)</a> を参照)および <code>--fork-point</code>
オプションが想定されています。現在のブランチを使用していない場合、または現在のブランチにアップストリームが構成されていない場合、リベースは中止されます。</p></div>
<div class="paragraph"><p>現在のブランチでコミットによって行われたが、&lt;upstream&gt;にないすべての変更は、一時領域に保存されます。 これは <code>git log
&lt;upstream&gt;..HEAD</code> で表示されるのと同じコミットのセットで、または <code>--fork-point</code> がアクティブな場合 <code>git log
'fork_point'..HEAD</code> で表示されるのと同じコミットのセットで、または <code>--root</code> オプションが指定されている場合 <code>git
log HEAD</code> で表示されるのと同じコミットのセットです。</p></div>
<div class="paragraph"><p>現在のブランチは&lt;upstream&gt;にリセットされ、または <code>--onto</code>
オプションが指定されている場合は&lt;newbase&gt;にリセットされます。これは、 <code>git reset --hard &lt;upstream&gt;</code>
(または&lt;newbase&gt;)とまったく同じ効果があります。 ORIG_HEADは、リセット前にブランチの先端を指すように設定されています。</p></div>
<div class="paragraph"><p>以前に一時領域に保存されたコミットは、現在のブランチに1つずつ順番に再適用されます。注意: <code>HEAD..&lt;upstream&gt;</code>
でのコミットと同一のテキスト変更を導入するHEADでのコミットは省略されることに注意してください(つまり、異なるコミットメッセージまたはタイムスタンプで、アップストリームで既に受け入れ済のパッチはスキップされます)。</p></div>
<div class="paragraph"><p>マージに失敗すると、このプロセスが完全には自動で行われなくなる事があります。あなたは、このようなマージの失敗を解決し、そして <code>git rebase
--continue</code> を実行する必要があります。 別のオプションとしては、 <code>git rebase --skip</code>
でマージの失敗を引き起こしたコミットをバイパスすることです。そして、元の&lt;branch&gt;をチェックアウトし、<code>.git/rebase-apply</code>
作業ファイルを削除するには、代わりにコマンド <code>git rebase --abort</code> を使用します。</p></div>
<div class="paragraph"><p>以下の履歴が存在し、現在のブランチが「topic」であると想定します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>          A---B---C topic
         /
    D---E---F---G master</code></pre>
</div></div>
<div class="paragraph"><p>この時点で、以下のコマンドのどちらかを実行します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase master
git rebase master topic</code></pre>
</div></div>
<div class="paragraph"><p>そうすると以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                  A'--B'--C' topic
                 /
    D---E---F---G master</code></pre>
</div></div>
<div class="paragraph"><p><strong>注意:</strong> 後者の形式は、<code>git checkout topic</code> の後に <code>git rebase master</code> が続く省略形です。
リベースが終了すると、
<code>topic</code> はチェックアウトされたブランチのままになります。</p></div>
<div class="paragraph"><p>(たとえば、アップストリームに適用されたパッチをメールで送信したため)アップストリームブランチにすでに行った変更が含まれている場合、そのコミットはスキップされ、警告が発行されます(<code>merge</code>
バックエンドが使用されている場合)。たとえば、以下の履歴で <code>git rebase master</code> を実行します(<code>A'</code> と <code>A</code>
は同じ変更セットを導入しますが、コミッター情報は異なります):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>          A---B---C topic
         /
    D---E---A'---F master</code></pre>
</div></div>
<div class="paragraph"><p>その結果は</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                   B'---C' topic
                  /
    D---E---A'---F master</code></pre>
</div></div>
<div class="paragraph"><p>これは、あるブランチに基づいてトピックブランチを別のブランチに移植し、 <code>rebase --onto</code>
を使用して、トピックブランチを後者のブランチからフォークしたふりをする方法です。</p></div>
<div class="paragraph"><p>まず、「topic」がブランチ「next」に基づいているとしましょう。
たとえば「topic」で開発された機能は、「next」にあるいくつかの機能に依存しています。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</code></pre>
</div></div>
<div class="paragraph"><p>我々は <em>topic</em> をブランチ <em>master</em>
からフォークさせたいのです。たとえば「topic」が依存する機能が、より安定した「master」ブランチにマージされたためです。
ツリーを以下のようにしたいわけです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</code></pre>
</div></div>
<div class="paragraph"><p>これは、以下のコマンドを使用して取得できます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto master next topic</code></pre>
</div></div>
<div class="paragraph"><p><code>--onto</code> オプションの別の例は、ブランチの一部をリベースすることです。 以下のような状況の場合:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</code></pre>
</div></div>
<div class="paragraph"><p>そして、以下のコマンドを実行します</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto master topicA topicB</code></pre>
</div></div>
<div class="paragraph"><p>そうすると結果は以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</code></pre>
</div></div>
<div class="paragraph"><p>これは、topicBがtopicAに依存していない場合に役立ちます。</p></div>
<div class="paragraph"><p>コミットの範囲は、リベースで削除することもできます。以下の状況の場合:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    E---F---G---H---I---J  topicA</code></pre>
</div></div>
<div class="paragraph"><p>そして、以下のコマンドを実行します</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --onto topicA~5 topicA~3 topicA</code></pre>
</div></div>
<div class="paragraph"><p>そうすると、以下のようにコミットFとGが削除されます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    E---H'---I'---J'  topicA</code></pre>
</div></div>
<div class="paragraph"><p>これは、FとGに何らかの欠陥がある場合、または、topicAの一部であってはならない場合に役立ちます。注意: <code>--onto</code>
と&lt;upstream&gt;パラメーターの引数は、任意の有効なコミットっぽい何か(commit-ish)にすることができることに注意してください。</p></div>
<div class="paragraph"><p>競合が発生した場合、「git rebase」は最初の問題のあるコミットで停止し、ツリーに競合マーカーを残します。 <em>git diff</em>
を使用して、マーカー(&lt;&lt;&lt;&lt;&lt;&lt;)を見つけ、編集して競合を解決できます。編集するファイルごとに、競合が解決されたことをGitに通知する必要があります。通常、これは以下の方法で行います。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git add &lt;filename&gt;</code></pre>
</div></div>
<div class="paragraph"><p>競合を手動で解決し、あなたが欲する解決策でインデックスを更新した後、以下のコマンドでリベースプロセスを続行できます。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --continue</code></pre>
</div></div>
<div class="paragraph"><p>あるいは、「git rebase」を元に戻す(undo)こともできます</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase --abort</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_options">OPTIONS</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
<code>--onto &lt;newbase&gt;</code>
</dt>
<dd>
<p>
        新しいコミットを作成する開始点。 <code>--onto</code>
        オプションが指定されていない場合、開始点は&lt;upstream&gt;です。これは、既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。
</p>
<div class="paragraph"><p>特別な場合として、マージベースが1つしかない場合は、AとBのマージベースのショートカットとして "A...B"
を使用できます。最大でAとBのいずれかを省略できます。その場合、デフォルトでHEADになります。</p></div>
</dd>
<dt class="hdlist1">
<code>--keep-base</code>
</dt>
<dd>
<p>
        &lt;upstream&gt; &lt;branch&gt; のマージベースへの新しいコミットを作成する開始点を設定します。 <code>git rebase --keep-base
        &lt;upstream&gt; &lt;branch&gt;</code> を実行することは <code>git rebase --onto &lt;upstream&gt;... &lt;upstream&gt;</code>
        を実行することと同じです。
</p>
<div class="paragraph"><p>このオプションは、アップストリームブランチの先頭で機能を開発している場合に役立ちます。この機能が働いている間に、アップストリームのブランチが進むことがあり、アップストリームの先頭にリベースを続けるのは得策ではなく、ベースのコミットをそのままにしておくことがあります。</p></div>
<div class="paragraph"><p>このオプションと <code>--fork-point</code>
はどちらも&lt;upstream&gt;と&lt;branch&gt;の間のマージベースを検索します。しかし、このオプションは新しいコミットが作成される「開始点」としてマージベースを使用します。一方
<code>--fork-point</code> はマージベースを使用して、リベースされる「コミットのセット」を決定します。</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
&lt;upstream&gt;
</dt>
<dd>
<p>
        比較するアップストリームブランチ。既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。デフォルトは、現在のブランチ用に構成されたアップストリームです。
</p>
</dd>
<dt class="hdlist1">
&lt;branch&gt;
</dt>
<dd>
<p>
        作業するブランチ。デフォルトはHEADです。
</p>
</dd>
<dt class="hdlist1">
<code>--continue</code>
</dt>
<dd>
<p>
        マージの競合を解決した後、リベースプロセスを再開します。
</p>
</dd>
<dt class="hdlist1">
<code>--abort</code>
</dt>
<dd>
<p>
        リベース操作を中止(abort)し、HEADを元のブランチにリセットします。リベース操作の開始時に&lt;branch&gt;が指定された場合、HEADは&lt;branch&gt;にリセットされます。それ以外の場合、HEADはリベース操作が開始されたときの位置にリセットされます。
</p>
</dd>
<dt class="hdlist1">
<code>--quit</code>
</dt>
<dd>
<p>
        リベース操作を中止(abort)しますが、HEADは元のブランチにリセットされません。その結果、インデックスと作業ツリーも変更されません。
        <code>--autostash</code> を使用して一時的なstashエントリが作成された場合、それはstashリストに保存されます。
</p>
</dd>
<dt class="hdlist1">
<code>--apply</code>
</dt>
<dd>
<p>
        適用戦略(applying strategies)を使用してリベースします(内部で <code>git-am</code>
        を呼び出します)。このオプションは、マージバックエンドがapplyのすべてを処理すると、将来的には動作しなくなる可能性があります。
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--empty={drop,keep,ask}</code>
</dt>
<dd>
<p>
        任意のアップストリームコミットの、開始時は空ではなく、かつ、クリーンでは無いチェリーピックであるが、(すでにアップストリームの変更のサブセットが含まれているため、)リベース後に空になるコミットを処理する方法。dropを使用すると、空になるコミットはドロップされます(これがデフォルトです)。keepを使用すると、そのようなコミットは保持されます。
        ask
        を使用すると、空のコミットが適用されるとリベースが停止し、ドロップするか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます(<code>--interactive</code>
        の指定を含んでいます)。<code>--exec</code> などの他のオプションでは、-i /
        -interactiveが明示的に指定されていない限り、デフォルトのドロップが使用されます。
</p>
<div class="paragraph"><p>注意: (<code>--no-keep-empty</code>
が指定されていない場合、)空で開始するコミットは保持され、(<code>--reapply-cherry-picks</code> が渡されない限り)準備ステップとして、(
<code>git log --cherry-mark ...</code> によって決定される)クリーンなチェリーピックであるコミットが検出・ドロップされます。</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--no-keep-empty</code>
</dt>
<dt class="hdlist1">
<code>--keep-empty</code>
</dt>
<dd>
<p>
        Do not keep commits that start empty before the rebase (i.e. that do not
        change anything from its parent) in the result.  The default is to keep
        commits which start empty, since creating such commits requires passing the
        --allow-empty override flag to <code>git commit</code>, signifying that a user is very
        intentionally creating such a commit and thus wants to keep it.
</p>
<div class="paragraph"><p>Usage of this flag will probably be rare, since you can get rid of commits
that start empty by just firing up an interactive rebase and removing the
lines corresponding to the commits you don&#8217;t want.  This flag exists as a
convenient shortcut, such as for cases where external tools generate many
empty commits and you want them all removed.</p></div>
<div class="paragraph"><p>空では開始されないが、リベース後に空になるコミットについては、 <code>--empty</code> フラグを参照してください。</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--reapply-cherry-picks</code>
</dt>
<dt class="hdlist1">
<code>--no-reapply-cherry-picks</code>
</dt>
<dd>
<p>
        Reapply all clean cherry-picks of any upstream commit instead of
        preemptively dropping them. (If these commits then become empty after
        rebasing, because they contain a subset of already upstream changes, the
        behavior towards them is controlled by the <code>--empty</code> flag.)
</p>
<div class="paragraph"><p>By default (or if <code>--no-reapply-cherry-picks</code> is given), these commits will
be automatically dropped.  Because this necessitates reading all upstream
commits, this can be expensive in repos with a large number of upstream
commits that need to be read.  When using the <code>merge</code> backend, warnings will
be issued for each dropped commit (unless <code>--quiet</code> is given). Advice will
also be issued unless <code>advice.skippedCherryPicks</code> is set to false (see
<a href="git-config.html">git-config(1)</a>).</p></div>
<div class="paragraph"><p><code>--reapply-cherry-picks</code>
を使用すると、リベースはすべてのアップストリームコミットの読み取りを放棄できるため、パフォーマンスが向上する可能性があります。</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--allow-empty-message</code>
</dt>
<dd>
<p>
        No-op.  Rebasing commits with an empty message used to fail and this option
        would override that behavior, allowing commits with empty messages to be
        rebased.  Now commits with an empty message do not cause rebasing to halt.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--skip</code>
</dt>
<dd>
<p>
        現在のパッチをスキップして、リベースプロセスを再開します。
</p>
</dd>
<dt class="hdlist1">
<code>--edit-todo</code>
</dt>
<dd>
<p>
        対話的リベース中にToDoリストを編集します。
</p>
</dd>
<dt class="hdlist1">
<code>--show-current-patch</code>
</dt>
<dd>
<p>
        対話的なリベース、または、競合のためにリベースが停止されたときに、現在のパッチを表示します。 これは <code>git show REBASE_HEAD</code>
        と同等です。
</p>
</dd>
<dt class="hdlist1">
<code>-m</code>
</dt>
<dt class="hdlist1">
<code>--merge</code>
</dt>
<dd>
<p>
        マージ戦略(merging strategies)を使用してリベースします(デフォルト)。
</p>
<div class="paragraph"><p>Note that a rebase merge works by replaying each commit from the working
branch on top of the &lt;upstream&gt; branch.  Because of this, when a merge
conflict happens, the side reported as <em>ours</em> is the so-far rebased series,
starting with &lt;upstream&gt;, and <em>theirs</em> is the working branch.  In other
words, the sides are swapped.</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>-s &lt;strategy&gt;</code>
</dt>
<dt class="hdlist1">
<code>--strategy=&lt;strategy&gt;</code>
</dt>
<dd>
<p>
        デフォルトの <code>ort</code> の代わりに、指定のマージ戦略を使用します。 このオプションは <code>--merge</code> の指定を含んでいます。
</p>
<div class="paragraph"><p>Because <em>git rebase</em> replays each commit from the working branch on top of
the &lt;upstream&gt; branch using the given strategy, using the <em>ours</em> strategy
simply empties all patches from the &lt;branch&gt;, which makes little sense.</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>-X &lt;strategy-option&gt;</code>
</dt>
<dt class="hdlist1">
<code>--strategy-option=&lt;strategy-option&gt;</code>
</dt>
<dd>
<p>
        Pass the &lt;strategy-option&gt; through to the merge strategy.  This implies
        <code>--merge</code> and, if no strategy has been specified, <code>-s ort</code>.  Note the
        reversal of <em>ours</em> and <em>theirs</em> as noted above for the <code>-m</code> option.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--rerere-autoupdate</code>
</dt>
<dt class="hdlist1">
<code>--no-rerere-autoupdate</code>
</dt>
<dd>
<p>
        可能であれば、rerereメカニズムが自動競合解決の結果でインデックスを更新できるようにします。
</p>
</dd>
<dt class="hdlist1">
<code>-S[&lt;keyid&gt;]</code>
</dt>
<dt class="hdlist1">
<code>--gpg-sign[=&lt;keyid&gt;]</code>
</dt>
<dt class="hdlist1">
<code>--no-gpg-sign</code>
</dt>
<dd>
<p>
        GPG-sign commits. The <code>keyid</code> argument is optional and defaults to the
        committer identity; if specified, it must be stuck to the option without a
        space. <code>--no-gpg-sign</code> is useful to countermand both <code>commit.gpgSign</code>
        configuration variable, and earlier <code>--gpg-sign</code>.
</p>
</dd>
<dt class="hdlist1">
<code>-q</code>
</dt>
<dt class="hdlist1">
<code>--quiet</code>
</dt>
<dd>
<p>
        静かにします。このオプションは <code>--no-stat</code> を含んでいます。
</p>
</dd>
<dt class="hdlist1">
<code>-v</code>
</dt>
<dt class="hdlist1">
<code>--verbose</code>
</dt>
<dd>
<p>
        おしゃべりになります。 <code>--stat</code> を含んでいます。
</p>
</dd>
<dt class="hdlist1">
<code>--stat</code>
</dt>
<dd>
<p>
        最後のリベース以降にアップストリームで変更されたもののdiffstatを表示します。 diffstatは、構成オプション rebase.stat
        によっても制御されます。
</p>
</dd>
<dt class="hdlist1">
<code>-n</code>
</dt>
<dt class="hdlist1">
<code>--no-stat</code>
</dt>
<dd>
<p>
        リベースプロセスの一部としてdiffstatを表示しないでください。
</p>
</dd>
<dt class="hdlist1">
<code>--no-verify</code>
</dt>
<dd>
<p>
        このオプションは、リベース前のフックをバイパスします。 <a href="githooks.html">githooks(5)</a> も参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>--verify</code>
</dt>
<dd>
<p>
        プリリベースフック(pre-rebase hook)の実行を許可します。これがデフォルトです。このオプションは、 <code>--no-verify</code>
        をオーバーライドするために使用できます。 <a href="githooks.html">githooks(5)</a> も参照してください。
</p>
</dd>
<dt class="hdlist1">
<code>-C&lt;n&gt;</code>
</dt>
<dd>
<p>
        Ensure at least &lt;n&gt; lines of surrounding context match before and after each
        change.  When fewer lines of surrounding context exist they all must match.
        By default no context is ever ignored.  Implies --apply.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--no-ff</code>
</dt>
<dt class="hdlist1">
<code>--force-rebase</code>
</dt>
<dt class="hdlist1">
<code>-f</code>
</dt>
<dd>
<p>
        Individually replay all rebased commits instead of fast-forwarding over the
        unchanged ones.  This ensures that the entire history of the rebased branch
        is composed of new commits.
</p>
<div class="paragraph"><p>You may find this helpful after reverting a topic branch merge, as this
option recreates the topic branch with fresh commits so it can be remerged
successfully without needing to "revert the reversion" (see the
<a href="howto/revert-a-faulty-merge.html">revert-a-faulty-merge How-To</a> for
details).</p></div>
</dd>
<dt class="hdlist1">
<code>--fork-point</code>
</dt>
<dt class="hdlist1">
<code>--no-fork-point</code>
</dt>
<dd>
<p>
        &lt;branch&gt;によって導入されたコミットを計算するときに、reflogを使用して、&lt;upstream&gt;と&lt;branch&gt;の間の、より一般的な祖先を見つけます。
</p>
<div class="paragraph"><p>When --fork-point is active, <em>fork_point</em> will be used instead of &lt;upstream&gt;
to calculate the set of commits to rebase, where <em>fork_point</em> is the result
of <code>git merge-base --fork-point &lt;upstream&gt; &lt;branch&gt;</code> command (see
<a href="git-merge-base.html">git-merge-base(1)</a>).  If <em>fork_point</em> ends up being empty, the
&lt;upstream&gt; will be used as a fallback.</p></div>
<div class="paragraph"><p>コマンドラインで&lt;upstream&gt;が指定されている場合、デフォルトは <code>--no-fork-point</code> です。それ以外の場合、デフォルトは
<code>--fork-point</code> です。</p></div>
<div class="paragraph"><p>If your branch was based on &lt;upstream&gt; but &lt;upstream&gt; was rewound and your
branch contains commits which were dropped, this option can be used with
<code>--keep-base</code> in order to drop those commits from your branch.</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--ignore-whitespace</code>
</dt>
<dd>
<p>
差分を調整しようとするときは、空白の違いを無視してください。現在、各バックエンドはこの振る舞いの近似を実装しています:
</p>
<div class="paragraph"><p>apply backend: When applying a patch, ignore changes in whitespace in
context lines. Unfortunately, this means that if the "old" lines being
replaced by the patch differ only in whitespace from the existing file, you
will get a merge conflict instead of a successful patch application.</p></div>
<div class="paragraph"><p>merge backend: Treat lines with only whitespace changes as unchanged when
merging. Unfortunately, this means that any patch hunks that were intended
to modify whitespace and nothing else will be dropped, even if the other
side had no changes that conflicted.</p></div>
</dd>
<dt class="hdlist1">
<code>--whitespace=&lt;option&gt;</code>
</dt>
<dd>
<p>
        このフラグは、パッチを適用する「git apply」プログラム(<a href="git-apply.html">git-apply(1)</a> を参照)に渡されます。 <code>--apply</code>
        の意味を含んでいます。
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--committer-date-is-author-date</code>
</dt>
<dd>
<p>
        Instead of using the current time as the committer date, use the author date
        of the commit being rebased as the committer date. This option implies
        <code>--force-rebase</code>.
</p>
</dd>
<dt class="hdlist1">
<code>--ignore-date</code>
</dt>
<dt class="hdlist1">
<code>--reset-author-date</code>
</dt>
<dd>
<p>
        Instead of using the author date of the original commit, use the current
        time as the     author date of the rebased commit.  This option implies
        <code>--force-rebase</code>.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--signoff</code>
</dt>
<dd>
<p>
        Add a <code>Signed-off-by</code> trailer to all the rebased commits. Note that if
        <code>--interactive</code> is given then only commits marked to be picked, edited or
        reworded will have the trailer added.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>-i</code>
</dt>
<dt class="hdlist1">
<code>--interactive</code>
</dt>
<dd>
<p>
        Make a list of the commits which are about to be rebased.  Let the user edit
        that list before rebasing.  This mode can also be used to split commits (see
        SPLITTING COMMITS below).
</p>
<div class="paragraph"><p>The commit list format can be changed by setting the configuration option
rebase.instructionFormat.  A customized instruction format will
automatically have the long commit hash prepended to the format.</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>-r</code>
</dt>
<dt class="hdlist1">
<code>--rebase-merges[=(rebase-cousins|no-rebase-cousins)]</code>
</dt>
<dd>
<p>
        By default, a rebase will simply drop merge commits from the todo list, and
        put the rebased commits into a single, linear branch.  With
        <code>--rebase-merges</code>, the rebase will instead try to preserve the branching
        structure within the commits that are to be rebased, by recreating the merge
        commits. Any resolved merge conflicts or manual amendments in these merge
        commits will have to be resolved/re-applied manually.
</p>
<div class="paragraph"><p>By default, or when <code>no-rebase-cousins</code> was specified, commits which do not
have <code>&lt;upstream&gt;</code> as direct ancestor will keep their original branch point,
i.e. commits that would be excluded by <a href="git-log.html">git-log(1)</a>'s
<code>--ancestry-path</code> option will keep their original ancestry by default. If
the <code>rebase-cousins</code> mode is turned on, such commits are instead rebased
onto <code>&lt;upstream&gt;</code> (or <code>&lt;onto&gt;</code>, if specified).</p></div>
<div class="paragraph"><p>The <code>--rebase-merges</code> mode is similar in spirit to the deprecated
<code>--preserve-merges</code> but works with interactive rebases, where commits can be
reordered, inserted and dropped at will.</p></div>
<div class="paragraph"><p>It is currently only possible to recreate the merge commits using the <code>ort</code>
merge strategy; different merge strategies can be used only via explicit
<code>exec git merge -s &lt;strategy&gt; [...]</code> commands.</p></div>
<div class="paragraph"><p>以下の「REBASING MERGES」(マージのリベース)および「INCOMPATIBLE
OPTIONS」(互換性のないオプション)も参照してください。</p></div>
</dd>
<dt class="hdlist1">
<code>-p</code>
</dt>
<dt class="hdlist1">
<code>--preserve-merges</code>
</dt>
<dd>
<p>
        [DEPRECATED: use <code>--rebase-merges</code> instead] Recreate merge commits instead
        of flattening the history by replaying commits a merge commit
        introduces. Merge conflict resolutions or manual amendments to merge commits
        are not preserved.
</p>
<div class="paragraph"><p>This uses the <code>--interactive</code> machinery internally, but combining it with
the <code>--interactive</code> option explicitly is generally not a good idea unless
you know what you are doing (see BUGS below).</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>-x &lt;cmd&gt;</code>
</dt>
<dt class="hdlist1">
<code>--exec &lt;cmd&gt;</code>
</dt>
<dd>
<p>
        Append "exec &lt;cmd&gt;" after each line creating a commit in the final
        history. &lt;cmd&gt; will be interpreted as one or more shell commands. Any
        command that fails will interrupt the rebase, with exit code 1.
</p>
<div class="paragraph"><p><code>--exec</code> の1つのインスタンスを複数のコマンドで使用することにより、複数のコマンドを実行できます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."</code></pre>
</div></div>
<div class="paragraph"><p>または、複数の <code>--exec</code> を指定します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i --exec "cmd1" --exec "cmd2" --exec ...</code></pre>
</div></div>
<div class="paragraph"><p><code>--autosquash</code> が使用されている場合、「exec」行は中間コミットに追加されず、各スカッシュ/修正シリーズの最後にのみ現れます。</p></div>
<div class="paragraph"><p>これは内部で <code>--interactive</code> 機構を使用しますが、明示的な <code>--interactive</code> の指定なしで実行できます。</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--root</code>
</dt>
<dd>
<p>
        Rebase all commits reachable from &lt;branch&gt;, instead of limiting them with an
        &lt;upstream&gt;.  This allows you to rebase the root commit(s) on a branch.  When
        used with --onto, it will skip changes already contained in &lt;newbase&gt;
        (instead of &lt;upstream&gt;) whereas without --onto it will operate on every
        change.  When used together with both --onto and --preserve-merges, <em>all</em>
        root commits will be rewritten to have &lt;newbase&gt; as parent instead.
</p>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--autosquash</code>
</dt>
<dt class="hdlist1">
<code>--no-autosquash</code>
</dt>
<dd>
<p>
        When the commit log message begins with "squash! &#8230;" or "fixup! &#8230;" or
        "amend! &#8230;", and there is already a commit in the todo list that matches
        the same <code>...</code>, automatically modify the todo list of <code>rebase -i</code>, so that
        the commit marked for squashing comes right after the commit to be modified,
        and change the action of the moved commit from <code>pick</code> to <code>squash</code> or <code>fixup</code>
        or <code>fixup -C</code> respectively. A commit matches the <code>...</code> if the commit subject
        matches, or if the <code>...</code> refers to the commit&#8217;s hash. As a fall-back,
        partial matches of the commit subject work, too. The recommended way to
        create fixup/amend/squash commits is by using the <code>--fixup</code>,
        <code>--fixup=amend:</code> or <code>--fixup=reword:</code> and <code>--squash</code> options respectively of
        <a href="git-commit.html">git-commit(1)</a>.
</p>
<div class="paragraph"><p>If the <code>--autosquash</code> option is enabled by default using the configuration
variable <code>rebase.autoSquash</code>, this option can be used to override and
disable this setting.</p></div>
<div class="paragraph"><p>以下の「INCOMPATIBLE OPTIONS」セクションもご覧下さい。</p></div>
</dd>
<dt class="hdlist1">
<code>--autostash</code>
</dt>
<dt class="hdlist1">
<code>--no-autostash</code>
</dt>
<dd>
<p>
        Automatically create a temporary stash entry before the operation begins,
        and apply it after the operation ends.  This means that you can run rebase
        on a dirty worktree.  However, use with care: the final stash application
        after a successful rebase might result in non-trivial conflicts.
</p>
</dd>
<dt class="hdlist1">
<code>--reschedule-failed-exec</code>
</dt>
<dt class="hdlist1">
<code>--no-reschedule-failed-exec</code>
</dt>
<dd>
<p>
        失敗した <code>exec</code> コマンドを自動的に再スケジュールします。 これは、対話モード(または <code>--exec</code>
        オプションが提供された場合)でのみ意味があります。
</p>
<div class="paragraph"><p>Even though this option applies once a rebase is started, it&#8217;s set for the
whole rebase at the start based on either the <code>rebase.rescheduleFailedExec</code>
configuration (see <a href="git-config.html">git-config(1)</a> or "CONFIGURATION" below) or
whether this option is provided. Otherwise an explicit
<code>--no-reschedule-failed-exec</code> at the start would be overridden by the
presence of <code>rebase.rescheduleFailedExec=true</code> configuration.</p></div>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_incompatible_options">INCOMPATIBLE OPTIONS</h2>
<div class="sectionbody">
<div class="paragraph"><p>これら、</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--apply</code>
</p>
</li>
<li>
<p>
<code>--whitespace</code>
</p>
</li>
<li>
<p>
<code>-C</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>は、以下のオプションと互換性がありません:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--merge</code>
</p>
</li>
<li>
<p>
<code>--strategy</code>
</p>
</li>
<li>
<p>
<code>--strategy-option</code>
</p>
</li>
<li>
<p>
<code>--allow-empty-message</code>
</p>
</li>
<li>
<p>
<code>--[no-]autosquash</code>
</p>
</li>
<li>
<p>
<code>--rebase-merges</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code>
</p>
</li>
<li>
<p>
<code>--interactive</code>
</p>
</li>
<li>
<p>
<code>--exec</code>
</p>
</li>
<li>
<p>
<code>--no-keep-empty</code>
</p>
</li>
<li>
<p>
<code>--empty=</code>
</p>
</li>
<li>
<p>
<code>--reapply-cherry-picks</code>
</p>
</li>
<li>
<p>
<code>--edit-todo</code>
</p>
</li>
<li>
<p>
<code>--onto</code> と組み合わせて使用する場合の <code>--root</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>加えて、以下のオプションの組み合わせには互換性がありません:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--interactive</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--signoff</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--rebase-merges</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--empty=</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--ignore-whitespace</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--committer-date-is-author-date</code>
</p>
</li>
<li>
<p>
<code>--preserve-merges</code> かつ <code>--ignore-date</code>
</p>
</li>
<li>
<p>
<code>--keep-base</code> かつ <code>--onto</code>
</p>
</li>
<li>
<p>
<code>--keep-base</code> かつ <code>--root</code>
</p>
</li>
<li>
<p>
<code>--fork-point</code> かつ <code>--root</code>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_振る舞いの違い">振る舞いの違い</h2>
<div class="sectionbody">
<div class="paragraph"><p>git rebase has two primary backends: apply and merge.  (The apply backend
used to be known as the <em>am</em> backend, but the name led to confusion as it
looks like a verb instead of a noun.  Also, the merge backend used to be
known as the interactive backend, but it is now used for non-interactive
cases as well.  Both were renamed based on lower-level functionality that
underpinned each.) There are some subtle differences in how these two
backends behave:</p></div>
<div class="sect2">
<h3 id="_空のコミット">空のコミット</h3>
<div class="paragraph"><p>The apply backend unfortunately drops intentionally empty commits, i.e.
commits that started empty, though these are rare in practice.  It also
drops commits that become empty and has no option for controlling this
behavior.</p></div>
<div class="paragraph"><p>The merge backend keeps intentionally empty commits by default (though with
-i they are marked as empty in the todo list editor, or they can be dropped
automatically with --no-keep-empty).</p></div>
<div class="paragraph"><p>Similar to the apply backend, by default the merge backend drops commits
that become empty unless -i/--interactive is specified (in which case it
stops and asks the user what to do).  The merge backend also has an
--empty={drop,keep,ask} option for changing the behavior of handling commits
that become empty.</p></div>
</div>
<div class="sect2">
<h3 id="_ディレクトリ名変更の検知">ディレクトリ名変更の検知</h3>
<div class="paragraph"><p>Due to the lack of accurate tree information (arising from constructing fake
ancestors with the limited information available in patches), directory
rename detection is disabled in the apply backend.  Disabled directory
rename detection means that if one side of history renames a directory and
the other adds new files to the old directory, then the new files will be
left behind in the old directory without any warning at the time of rebasing
that you may want to move these files into the new directory.</p></div>
<div class="paragraph"><p>ディレクトリ名変更の検出は、マージバックエンドと連携して、このような場合に警告を提供します。</p></div>
</div>
<div class="sect2">
<h3 id="_context">Context</h3>
<div class="paragraph"><p>The apply backend works by creating a sequence of patches (by calling
<code>format-patch</code> internally), and then applying the patches in sequence
(calling <code>am</code> internally).  Patches are composed of multiple hunks, each
with line numbers, a context region, and the actual changes.  The line
numbers have to be taken with some fuzz, since the other side will likely
have inserted or deleted lines earlier in the file.  The context region is
meant to help find how to adjust the line numbers in order to apply the
changes to the right lines.  However, if multiple areas of the code have the
same surrounding lines of context, the wrong one can be picked.  There are
real-world cases where this has caused commits to be reapplied incorrectly
with no conflicts reported.  Setting diff.context to a larger value may
prevent such types of problems, but increases the chance of spurious
conflicts (since it will require more lines of matching context to apply).</p></div>
<div class="paragraph"><p>マージバックエンドは、関連する各ファイルの完全なコピーを使って動作し、これらの種類の問題からファイルを保護します。</p></div>
</div>
<div class="sect2">
<h3 id="_labelling_of_conflicts_markers">Labelling of conflicts markers</h3>
<div class="paragraph"><p>When there are content conflicts, the merge machinery tries to annotate each
side&#8217;s conflict markers with the commits where the content came from.  Since
the apply backend drops the original information about the rebased commits
and their parents (and instead generates new fake commits based off limited
information in the generated patches), those commits cannot be identified;
instead it has to fall back to a commit summary.  Also, when
merge.conflictStyle is set to diff3, the apply backend will use "constructed
merge base" to label the content from the merge base, and thus provide no
information about the merge base commit whatsoever.</p></div>
<div class="paragraph"><p>マージバックエンドは、履歴の両側で完全なコミットで動作するため、そのような制限はありません。</p></div>
</div>
<div class="sect2">
<h3 id="_フック">フック</h3>
<div class="paragraph"><p>The apply backend has not traditionally called the post-commit hook, while
the merge backend has.  Both have called the post-checkout hook, though the
merge backend has squelched its output.  Further, both backends only call
the post-checkout hook with the starting point commit of the rebase, not the
intermediate commits nor the final commit.  In each case, the calling of
these hooks was by accident of implementation rather than by design (both
backends were originally implemented as shell scripts and happened to invoke
other commands like <em>git checkout</em> or <em>git commit</em> that would call the
hooks).  Both backends should have the same behavior, though it is not
entirely clear which, if any, is correct.  We will likely make rebase stop
calling either of these hooks in the future.</p></div>
</div>
<div class="sect2">
<h3 id="_interruptability">Interruptability</h3>
<div class="paragraph"><p>The apply backend has safety problems with an ill-timed interrupt; if the
user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase
can enter a state where it cannot be aborted with a subsequent <code>git rebase
--abort</code>.  The merge backend does not appear to suffer from the same
shortcoming.  (See
<a href="https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/">https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/</a> for details.)</p></div>
</div>
<div class="sect2">
<h3 id="_commit_rewording">Commit Rewording</h3>
<div class="paragraph"><p>When a conflict occurs while rebasing, rebase stops and asks the user to
resolve.  Since the user may need to make notable changes while resolving
conflicts, after conflicts are resolved and the user has run <code>git rebase
--continue</code>, the rebase should open an editor and ask the user to update the
commit message.  The merge backend does this, while the apply backend
blindly applies the original commit message.</p></div>
</div>
<div class="sect2">
<h3 id="_miscellaneous_differences">Miscellaneous differences</h3>
<div class="paragraph"><p>ほとんどの人がおそらく取るに足らないと考えるであろうが、完全性のためにいくつかの振る舞いの違いについて言及します:</p></div>
<div class="ulist"><ul>
<li>
<p>
Reflog: 2つのバックエンドは、reflogで行われた変更を説明するときに異なる表現を使用しますが、どちらも「リベース」という単語を使用します。
</p>
</li>
<li>
<p>
Progress, informational, and error messages: The two backends provide
  slightly different progress and informational messages.  Also, the apply
  backend writes error messages (such as "Your files would be overwritten&#8230;")
  to stdout, while the merge backend writes them to stderr.
</p>
</li>
<li>
<p>
状態ディレクトリ: 2つのバックエンドは、.git/ の下の異なるディレクトリに状態を保持します
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_merge_strategies">MERGE STRATEGIES</h2>
<div class="sectionbody">
<div class="paragraph"><p>The merge mechanism (<code>git merge</code> and <code>git pull</code> commands) allows the backend
<em>merge strategies</em> to be chosen with <code>-s</code> option.  Some strategies can also
take their own options, which can be passed by giving <code>-X&lt;option&gt;</code> arguments
to <code>git merge</code> and/or <code>git pull</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ort
</dt>
<dd>
<p>
        This is the default merge strategy when pulling or merging one branch.  This
        strategy can only resolve two heads using a 3-way merge algorithm.  When
        there is more than one common ancestor that can be used for 3-way merge, it
        creates a merged tree of the common ancestors and uses that as the reference
        tree for the 3-way merge.  This has been reported to result in fewer merge
        conflicts without causing mismerges by tests done on actual merge commits
        taken from Linux 2.6 kernel development history.  Additionally this strategy
        can detect and handle merges involving renames.  It does not make use of
        detected copies.  The name for this algorithm is an acronym ("Ostensibly
        Recursive&#8217;s Twin") and came from the fact that it was written as a
        replacement for the previous default algorithm, <code>recursive</code>.
</p>
<div class="paragraph"><p>The <em>ort</em> strategy can take the following options:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ours
</dt>
<dd>
<p>
        This option forces conflicting hunks to be auto-resolved cleanly by favoring
        <em>our</em> version.  Changes from the other tree that do not conflict with our
        side are reflected in the merge result.  For a binary file, the entire
        contents are taken from our side.
</p>
<div class="paragraph"><p>This should not be confused with the <em>ours</em> merge strategy, which does not
even look at what the other tree contains at all.  It discards everything
the other tree did, declaring <em>our</em> history contains all that happened in
it.</p></div>
</dd>
<dt class="hdlist1">
theirs
</dt>
<dd>
<p>
        This is the opposite of <em>ours</em>; note that, unlike <em>ours</em>, there is no
        <em>theirs</em> merge strategy to confuse this merge option with.
</p>
</dd>
<dt class="hdlist1">
ignore-space-change
</dt>
<dt class="hdlist1">
ignore-all-space
</dt>
<dt class="hdlist1">
ignore-space-at-eol
</dt>
<dt class="hdlist1">
ignore-cr-at-eol
</dt>
<dd>
<p>
        Treats lines with the indicated type of whitespace change as unchanged for
        the sake of a three-way merge.  Whitespace changes mixed with other changes
        to a line are not ignored.  See also <a href="git-diff.html">git-diff(1)</a> <code>-b</code>, <code>-w</code>,
        <code>--ignore-space-at-eol</code>, and <code>--ignore-cr-at-eol</code>.
</p>
<div class="ulist"><ul>
<li>
<p>
If <em>their</em> version only introduces whitespace changes to a line, <em>our</em>
  version is used;
</p>
</li>
<li>
<p>
If <em>our</em> version introduces whitespace changes but <em>their</em> version includes
  a substantial change, <em>their</em> version is used;
</p>
</li>
<li>
<p>
Otherwise, the merge proceeds in the usual way.
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
renormalize
</dt>
<dd>
<p>
        This runs a virtual check-out and check-in of all three stages of a file
        when resolving a three-way merge.  This option is meant to be used when
        merging branches with different clean filters or end-of-line normalization
        rules.  See "Merging branches with differing checkin/checkout attributes" in
        <a href="gitattributes.html">gitattributes(5)</a> for details.
</p>
</dd>
<dt class="hdlist1">
no-renormalize
</dt>
<dd>
<p>
        Disables the <code>renormalize</code> option.  This overrides the <code>merge.renormalize</code>
        configuration variable.
</p>
</dd>
<dt class="hdlist1">
find-renames[=&lt;n&gt;]
</dt>
<dd>
<p>
        Turn on rename detection, optionally setting the similarity threshold.  This
        is the default. This overrides the <em>merge.renames</em> configuration variable.
        See also <a href="git-diff.html">git-diff(1)</a> <code>--find-renames</code>.
</p>
</dd>
<dt class="hdlist1">
rename-threshold=&lt;n&gt;
</dt>
<dd>
<p>
        Deprecated synonym for <code>find-renames=&lt;n&gt;</code>.
</p>
</dd>
<dt class="hdlist1">
subtree[=&lt;path&gt;]
</dt>
<dd>
<p>
        This option is a more advanced form of <em>subtree</em> strategy, where the
        strategy makes a guess on how two trees must be shifted to match with each
        other when merging.  Instead, the specified path is prefixed (or stripped
        from the beginning) to make the shape of two trees to match.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
recursive
</dt>
<dd>
<p>
        This can only resolve two heads using a 3-way merge algorithm.  When there
        is more than one common ancestor that can be used for 3-way merge, it
        creates a merged tree of the common ancestors and uses that as the reference
        tree for the 3-way merge.  This has been reported to result in fewer merge
        conflicts without causing mismerges by tests done on actual merge commits
        taken from Linux 2.6 kernel development history.  Additionally this can
        detect and handle merges involving renames.  It does not make use of
        detected copies.  This was the default strategy for resolving two heads from
        Git v0.99.9k until v2.33.0.
</p>
<div class="paragraph"><p>The <em>recursive</em> strategy takes the same options as <em>ort</em>.  However, there
are three additional options that <em>ort</em> ignores (not documented above) that
are potentially useful with the <em>recursive</em> strategy:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
patience
</dt>
<dd>
<p>
        Deprecated synonym for <code>diff-algorithm=patience</code>.
</p>
</dd>
<dt class="hdlist1">
diff-algorithm=[patience|minimal|histogram|myers]
</dt>
<dd>
<p>
        Use a different diff algorithm while merging, which can help avoid mismerges
        that occur due to unimportant matching lines (such as braces from distinct
        functions).  See also <a href="git-diff.html">git-diff(1)</a> <code>--diff-algorithm</code>.  Note that
        <code>ort</code> specifically uses <code>diff-algorithm=histogram</code>, while <code>recursive</code>
        defaults to the <code>diff.algorithm</code> config setting.
</p>
</dd>
<dt class="hdlist1">
no-renames
</dt>
<dd>
<p>
        Turn off rename detection. This overrides the <code>merge.renames</code> configuration
        variable.  See also <a href="git-diff.html">git-diff(1)</a> <code>--no-renames</code>.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
resolve
</dt>
<dd>
<p>
        This can only resolve two heads (i.e. the current branch and another branch
        you pulled from) using a 3-way merge algorithm.  It tries to carefully
        detect criss-cross merge ambiguities.  It does not handle renames.
</p>
</dd>
<dt class="hdlist1">
octopus
</dt>
<dd>
<p>
        This resolves cases with more than two heads, but refuses to do a complex
        merge that needs manual resolution.  It is primarily meant to be used for
        bundling topic branch heads together.  This is the default merge strategy
        when pulling or merging more than one branch.
</p>
</dd>
<dt class="hdlist1">
ours
</dt>
<dd>
<p>
        This resolves any number of heads, but the resulting tree of the merge is
        always that of the current branch head, effectively ignoring all changes
        from all other branches.  It is meant to be used to supersede old
        development history of side branches.  Note that this is different from the
        -Xours option to the <em>recursive</em> merge strategy.
</p>
</dd>
<dt class="hdlist1">
subtree
</dt>
<dd>
<p>
        This is a modified <code>ort</code> strategy. When merging trees A and B, if B
        corresponds to a subtree of A, B is first adjusted to match the tree
        structure of A, instead of reading the trees at the same level. This
        adjustment is also done to the common ancestor tree.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>With the strategies that use 3-way merge (including the default, <em>ort</em>), if
a change is made on both branches, but later reverted on one of the
branches, that change will be present in the merged result; some people find
this behavior confusing.  It occurs because only the heads and the merge
base are considered when performing a merge, not the individual commits.
The merge algorithm therefore considers the reverted change as no change at
all, and substitutes the changed version instead.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_notes">NOTES</h2>
<div class="sectionbody">
<div class="paragraph"><p>共有リポジトリで「git rebase」を使用することの意味を理解する必要があります。 下記の「RECOVERING FROM UPSTREAM
REBASE」も参照してください。</p></div>
<div class="paragraph"><p>When the git-rebase command is run, it will first execute a "pre-rebase"
hook if one exists.  You can use this hook to do sanity checks and reject
the rebase if it isn&#8217;t appropriate.  Please see the template pre-rebase hook
script for an example.</p></div>
<div class="paragraph"><p>完了すると、&lt;branch&gt;が現在のブランチになります。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_interactive_mode">INTERACTIVE MODE</h2>
<div class="sectionbody">
<div class="paragraph"><p>対話的にリベースするということは、リベースされるコミットを編集する機会があることを意味します。コミットを並べ替えたり、削除したりできます(不良パッチやその他の不要なパッチを削除します)。</p></div>
<div class="paragraph"><p>対話的モードは、以下の種類の作業の流れを対象としています:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
素晴らしいアイデアを思いついた
</p>
</li>
<li>
<p>
コードをハックハック
</p>
</li>
<li>
<p>
提出用のシリーズを準備する
</p>
</li>
<li>
<p>
送信
</p>
</li>
</ol></div>
<div class="paragraph"><p>ここで、(2)は、以下のいくつかの内容で構成されています</p></div>
<div class="paragraph"><p>a) 通常</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
コミットに値する何かを終える
</p>
</li>
<li>
<p>
コミット
</p>
</li>
</ol></div>
<div class="paragraph"><p>b) 独立した修正</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
何かが機能しないことに気付く
</p>
</li>
<li>
<p>
そいつを修正する
</p>
</li>
<li>
<p>
それをコミット
</p>
</li>
</ol></div>
<div class="paragraph"><p>Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect
commit it fixes, because that commit is buried deeply in a patch series.
That is exactly what interactive rebase is for: use it after plenty of "a"s
and "b"s, by rearranging and editing commits, and squashing multiple commits
into one.</p></div>
<div class="paragraph"><p>あなたがそのまま保持したい最後のコミットから開始します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>git rebase -i &lt;after-this-commit&gt;</code></pre>
</div></div>
<div class="paragraph"><p>An editor will be fired up with all the commits in your current branch
(ignoring merge commits), which come after the given commit.  You can
reorder the commits in this list to your heart&#8217;s content, and you can remove
them.  The list looks more or less like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...</code></pre>
</div></div>
<div class="paragraph"><p>The oneline descriptions are purely for your pleasure; <em>git rebase</em> will not
look at them but at the commit names ("deadbee" and "fa1afe1" in this
example), so do not delete or edit the names.</p></div>
<div class="paragraph"><p>By replacing the command "pick" with the command "edit", you can tell <em>git
rebase</em> to stop after applying that commit, so that you can edit the files
and/or the commit message, amend the commit, and continue rebasing.</p></div>
<div class="paragraph"><p>リベースを中断するには(「edit」コマンドと同じように、ただし最初にコミットを選択せずに)、「break」コマンドを使用します。</p></div>
<div class="paragraph"><p>コミットのコミットメッセージを編集するだけの場合は、コマンド「pick」をコマンド「reword」に置き換えます。</p></div>
<div class="paragraph"><p>コミットを削除するには、コマンド「pick」を「drop」に置き換えるか、マッチする行を削除します。</p></div>
<div class="paragraph"><p>If you want to fold two or more commits into one, replace the command "pick"
for the second and subsequent commits with "squash" or "fixup".  If the
commits had different authors, the folded commit will be attributed to the
author of the first commit.  The suggested commit message for the folded
commit is the concatenation of the first commit&#8217;s message with those
identified by "squash" commands, omitting the messages of commits identified
by "fixup" commands, unless "fixup -c" is used.  In that case the suggested
commit message is only the message of the "fixup -c" commit, and an editor
is opened allowing you to edit the message.  The contents (patch) of the
"fixup -c" commit are still incorporated into the folded commit. If there is
more than one "fixup -c" commit, the message from the final one is used.
You can also use "fixup -C" to get the same behavior as "fixup -c" except
without opening an editor.</p></div>
<div class="paragraph"><p><em>git rebase</em> will stop when "pick" has been replaced with "edit" or when a
command fails due to merge errors. When you are done editing and/or
resolving conflicts you can continue with <code>git rebase --continue</code>.</p></div>
<div class="paragraph"><p>For example, if you want to reorder the last 5 commits, such that what was
HEAD~4 becomes the new HEAD. To achieve that, you would call <em>git rebase</em>
like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i HEAD~5</code></pre>
</div></div>
<div class="paragraph"><p>そして、最初のパッチをリストの最後に移動します。</p></div>
<div class="paragraph"><p>たとえば、あなたが以下のような歴史を持っているなら、マージコミットを再作成することをお勧めします:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>           X
            \
         A---M---B
        /
---o---O---P---Q</code></pre>
</div></div>
<div class="paragraph"><p>あなたは「A」から「Q」までのサイドブランチをリベースしたいとします。 現在のHEADが「B」であることを確認して</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i -r --onto Q O</code></pre>
</div></div>
<div class="paragraph"><p>Reordering and editing commits usually creates untested intermediate steps.
You may want to check that your history editing did not break anything by
running a test, or at least recompiling at intermediate points in history by
using the "exec" command (shortcut "x").  You may do so by creating a todo
list like this one:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...</code></pre>
</div></div>
<div class="paragraph"><p>The interactive rebase will stop when a command fails (i.e. exits with non-0
status) to give you an opportunity to fix the problem. You can continue with
<code>git rebase --continue</code>.</p></div>
<div class="paragraph"><p>The "exec" command launches the command in a shell (the one specified in
<code>$SHELL</code>, or the default shell if <code>$SHELL</code> is not set), so you can use shell
features (like "cd", "&gt;", ";" &#8230;). The command is run from the root of the
working tree.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i --exec "make test"</code></pre>
</div></div>
<div class="paragraph"><p>このコマンドを使用すると、中間コミットがコンパイル可能であることを確認できます。ToDoリストは以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_コミットの分割">コミットの分割</h2>
<div class="sectionbody">
<div class="paragraph"><p>In interactive mode, you can mark commits with the action "edit".  However,
this does not necessarily mean that <em>git rebase</em> expects the result of this
edit to be exactly one commit.  Indeed, you can undo the commit, or you can
add other commits.  This can be used to split a commit into two:</p></div>
<div class="ulist"><ul>
<li>
<p>
Start an interactive rebase with <code>git rebase -i &lt;commit&gt;^</code>, where &lt;commit&gt;
  is the commit you want to split.  In fact, any commit range will do, as long
  as it contains that commit.
</p>
</li>
<li>
<p>
分割するコミットを、アクション「edit」でマークします。
</p>
</li>
<li>
<p>
When it comes to editing that commit, execute <code>git reset HEAD^</code>.  The effect
  is that the HEAD is rewound by one, and the index follows suit.  However,
  the working tree stays the same.
</p>
</li>
<li>
<p>
Now add the changes to the index that you want to have in the first commit.
  You can use <code>git add</code> (possibly interactively) or <em>git gui</em> (or both) to do
  that.
</p>
</li>
<li>
<p>
最新の適切なコミットメッセージを使用して、最新の「現在のインデックス」をコミットします。
</p>
</li>
<li>
<p>
作業ツリーがクリーンになるまで、最後の2つの手順を繰り返します。
</p>
</li>
<li>
<p>
<code>git rebase --continue</code> でリベースを続行します。
</p>
</li>
</ul></div>
<div class="paragraph"><p>If you are not absolutely sure that the intermediate revisions are
consistent (they compile, pass the testsuite, etc.) you should use <em>git
stash</em> to stash away the not-yet-committed changes after each commit, test,
and amend the commit if fixes are necessary.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_recovering_from_upstream_rebase">RECOVERING FROM UPSTREAM REBASE</h2>
<div class="sectionbody">
<div class="paragraph"><p>Rebasing (or any other form of rewriting) a branch that others have based
work on is a bad idea: anyone downstream of it is forced to manually fix
their history.  This section explains how to do the fix from the
downstream&#8217;s point of view.  The real fix, however, would be to avoid
rebasing the upstream in the first place.</p></div>
<div class="paragraph"><p>To illustrate, suppose you are in a situation where someone develops a
<em>subsystem</em> branch, and you are working on a <em>topic</em> that is dependent on
this <em>subsystem</em>.  You might end up with a history like the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \
          o---o---o---o---o  subsystem
                           \
                            *---*---*  topic</code></pre>
</div></div>
<div class="paragraph"><p><em>subsystem</em> が <em>master</em> に対してリベースされる場合、以下が発生します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                           \
                            *---*---*  topic</code></pre>
</div></div>
<div class="paragraph"><p>これで通常どおり開発を続行し、最終的に「topic」を「subsystem」にマージすると、「subsystem」からのコミットは永久に複製されたままになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                           \                         /
                            *---*---*-..........-*--*  topic</code></pre>
</div></div>
<div class="paragraph"><p>Such duplicates are generally frowned upon because they clutter up history,
making it harder to follow.  To clean things up, you need to transplant the
commits on <em>topic</em> to the new <em>subsystem</em> tip, i.e., rebase <em>topic</em>.  This
becomes a ripple effect: anyone downstream from <em>topic</em> is forced to rebase
too, and so on!</p></div>
<div class="paragraph"><p>以下のサブセクションで議論する2種類の修正があります:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
簡単な場合: 変更は文字通り同じ(same)
</dt>
<dd>
<p>
        これは、 <em>subsystem</em> のリベースが単純なリベースであり、競合がなかった場合に発生します。
</p>
</dd>
<dt class="hdlist1">
難しい場合: 変更は同じではありません
</dt>
<dd>
<p>
        This happens if the <em>subsystem</em> rebase had conflicts, or used
        <code>--interactive</code> to omit, edit, squash, or fixup commits; or if the upstream
        used one of <code>commit --amend</code>, <code>reset</code>, or a full history rewriting command
        like <a href="https://github.com/newren/git-filter-repo"><code>filter-repo</code></a>.
</p>
</dd>
</dl></div>
<div class="sect2">
<h3 id="_簡単な場合">簡単な場合</h3>
<div class="paragraph"><p>Only works if the changes (patch IDs based on the diff contents) on
<em>subsystem</em> are literally the same before and after the rebase <em>subsystem</em>
did.</p></div>
<div class="paragraph"><p>In that case, the fix is easy because <em>git rebase</em> knows to skip changes
that are already present in the new upstream (unless
<code>--reapply-cherry-picks</code> is given). So if you say (assuming you&#8217;re on
<em>topic</em>)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    $ git rebase subsystem</code></pre>
</div></div>
<div class="paragraph"><p>あなたは修正された履歴で終わります。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    o---o---o---o---o---o---o---o  master
                                 \
                                  o'--o'--o'--o'--o'  subsystem
                                                   \
                                                    *---*---*  topic</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_難しい場合">難しい場合</h3>
<div class="paragraph"><p><em>subsystem</em> の変更がリベース前の変更に正確に対応していない場合、事態はさらに複雑になります。</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">While an "easy case recovery" sometimes appears to be successful
      even in the hard case, it may have unintended consequences.  For
      example, a commit that was removed via <code>git rebase
      --interactive</code> will be <strong>resurrected</strong>!</td>
</tr></table>
</div>
<div class="paragraph"><p>The idea is to manually tell <em>git rebase</em> "where the old <em>subsystem</em> ended
and your <em>topic</em> began", that is, what the old merge base between them was.
You will have to find a way to name the last commit of the old <em>subsystem</em>,
for example:</p></div>
<div class="ulist"><ul>
<li>
<p>
With the <em>subsystem</em> reflog: after <em>git fetch</em>, the old tip of <em>subsystem</em>
  is at <code>subsystem@{1}</code>.  Subsequent fetches will increase the number.  (See
  <a href="git-reflog.html">git-reflog(1)</a>.)
</p>
</li>
<li>
<p>
<em>topic&#8217;の先端に関連して: 'topic</em> に3つのコミットがあることを知っているので、 <em>subsystem</em> の古い先端は <code>topic~3</code>
  でなければなりません。
</p>
</li>
</ul></div>
<div class="paragraph"><p>次に、あなたは以下のように言って、古い <code>subsystem..topic</code> を新しい先端に移植できます(reflogの場合、すでに <em>topic</em>
にいると仮定します):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    $ git rebase --onto subsystem subsystem@{1}</code></pre>
</div></div>
<div class="paragraph"><p>The ripple effect of a "hard case" recovery is especially bad: <em>everyone</em>
downstream from <em>topic</em> will now have to perform a "hard case" recovery too!</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rebasing_merges">REBASING MERGES</h2>
<div class="sectionbody">
<div class="paragraph"><p>The interactive rebase command was originally designed to handle individual
patch series. As such, it makes sense to exclude merge commits from the todo
list, as the developer may have merged the then-current <code>master</code> while
working on the branch, only to rebase all the commits onto <code>master</code>
eventually (skipping the merge commits).</p></div>
<div class="paragraph"><p>However, there are legitimate reasons why a developer may want to recreate
merge commits: to keep the branch structure (or "commit topology") when
working on multiple, inter-related branches.</p></div>
<div class="paragraph"><p>In the following example, the developer works on a topic branch that
refactors the way buttons are defined, and on another topic branch that uses
that refactoring to implement a "Report a bug" button. The output of <code>git
log --graph --format=%s -5</code> may look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>*   Merge branch 'report-a-bug'
|\
| * Add the feedback button
* | Merge branch 'refactor-button'
|\ \
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one</code></pre>
</div></div>
<div class="paragraph"><p>The developer might want to rebase those commits to a newer <code>master</code> while
keeping the branch topology, for example when the first topic branch is
expected to be integrated into <code>master</code> much earlier than the second one,
say, to resolve merge conflicts with changes to the DownloadButton class
that made it into <code>master</code>.</p></div>
<div class="paragraph"><p>This rebase can be performed using the <code>--rebase-merges</code> option.  It will
generate a todo list looking like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>label onto

# Branch: refactor-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor-button

# Branch: report-a-bug
reset refactor-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report-a-bug

reset onto
merge -C a1b2c3 refactor-button # Merge 'refactor-button'
merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'</code></pre>
</div></div>
<div class="paragraph"><p>In contrast to a regular interactive rebase, there are <code>label</code>, <code>reset</code> and
<code>merge</code> commands in addition to <code>pick</code> ones.</p></div>
<div class="paragraph"><p>The <code>label</code> command associates a label with the current HEAD when that
command is executed. These labels are created as worktree-local refs
(<code>refs/rewritten/&lt;label&gt;</code>) that will be deleted when the rebase
finishes. That way, rebase operations in multiple worktrees linked to the
same repository do not interfere with one another. If the <code>label</code> command
fails, it is rescheduled immediately, with a helpful message how to proceed.</p></div>
<div class="paragraph"><p>The <code>reset</code> command resets the HEAD, index and worktree to the specified
revision. It is similar to an <code>exec git reset --hard &lt;label&gt;</code>, but refuses
to overwrite untracked files. If the <code>reset</code> command fails, it is
rescheduled immediately, with a helpful message how to edit the todo list
(this typically happens when a <code>reset</code> command was inserted into the todo
list manually and contains a typo).</p></div>
<div class="paragraph"><p>The <code>merge</code> command will merge the specified revision(s) into whatever is
HEAD at that time. With <code>-C &lt;original-commit&gt;</code>, the commit message of the
specified merge commit will be used. When the <code>-C</code> is changed to a
lower-case <code>-c</code>, the message will be opened in an editor after a successful
merge so that the user can edit the message.</p></div>
<div class="paragraph"><p>If a <code>merge</code> command fails for any reason other than merge conflicts (i.e.
when the merge operation did not even start), it is rescheduled immediately.</p></div>
<div class="paragraph"><p>By default, the <code>merge</code> command will use the <code>ort</code> merge strategy for
regular merges, and <code>octopus</code> for octopus merges.  One can specify a default
strategy for all merges using the <code>--strategy</code> argument when invoking
rebase, or can override specific merges in the interactive list of commands
by using an <code>exec</code> command to call <code>git merge</code> explicitly with a
<code>--strategy</code> argument.  Note that when calling <code>git merge</code> explicitly like
this, you can make use of the fact that the labels are worktree-local refs
(the ref <code>refs/rewritten/onto</code> would correspond to the label <code>onto</code>, for
example) in order to refer to the branches you want to merge.</p></div>
<div class="paragraph"><p>Note: the first command (<code>label onto</code>) labels the revision onto which the
commits are rebased; The name <code>onto</code> is just a convention, as a nod to the
<code>--onto</code> option.</p></div>
<div class="paragraph"><p>It is also possible to introduce completely new merge commits from scratch
by adding a command of the form <code>merge &lt;merge-head&gt;</code>. This form will
generate a tentative commit message and always open an editor to let the
user edit it. This can be useful e.g. when a topic branch turns out to
address more than a single concern and wants to be split into two or even
more topic branches. Consider this todo list:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1.3
pick fdbaec Fix detection of cURL in CMake on Windows</code></pre>
</div></div>
<div class="paragraph"><p>The one commit in this list that is not related to CMake may very well have
been motivated by working on fixing all those bugs introduced by switching
to CMake, but it addresses a different concern. To split this branch into
two topic branches, the todo list could be edited like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>label onto

pick afbecd http: add support for TLS v1.3
label tlsv1.3

reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake

reset onto
merge tlsv1.3
merge cmake</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration">CONFIGURATION</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
rebase.backend
</dt>
<dd>
<p>
        Default backend to use for rebasing.  Possible choices are <em>apply</em> or
        <em>merge</em>.  In the future, if the merge backend gains all remaining
        capabilities of the apply backend, this setting may become unused.
</p>
</dd>
<dt class="hdlist1">
rebase.stat
</dt>
<dd>
<p>
        Whether to show a diffstat of what changed upstream since the last
        rebase. False by default.
</p>
</dd>
<dt class="hdlist1">
rebase.autoSquash
</dt>
<dd>
<p>
        If set to true enable <code>--autosquash</code> option by default.
</p>
</dd>
<dt class="hdlist1">
rebase.autoStash
</dt>
<dd>
<p>
        When set to true, automatically create a temporary stash entry before the
        operation begins, and apply it after the operation ends.  This means that
        you can run rebase on a dirty worktree.  However, use with care: the final
        stash application after a successful rebase might result in non-trivial
        conflicts.  This option can be overridden by the <code>--no-autostash</code> and
        <code>--autostash</code> options of <a href="git-rebase.html">git-rebase(1)</a>.  Defaults to false.
</p>
</dd>
<dt class="hdlist1">
rebase.missingCommitsCheck
</dt>
<dd>
<p>
        If set to "warn", git rebase -i will print a warning if some commits are
        removed (e.g. a line was deleted), however the rebase will still proceed. If
        set to "error", it will print the previous warning and stop the rebase, <em>git
        rebase --edit-todo</em> can then be used to correct the error. If set to
        "ignore", no checking is done.  To drop a commit without warning or error,
        use the <code>drop</code> command in the todo list.  Defaults to "ignore".
</p>
</dd>
<dt class="hdlist1">
rebase.instructionFormat
</dt>
<dd>
<p>
        A format string, as specified in <a href="git-log.html">git-log(1)</a>, to be used for the todo
        list during an interactive rebase.  The format will automatically have the
        long commit hash prepended to the format.
</p>
</dd>
<dt class="hdlist1">
rebase.abbreviateCommands
</dt>
<dd>
<p>
        If set to true, <code>git rebase</code> will use abbreviated command names in the todo
        list resulting in something like this:
</p>
<div class="listingblock">
<div class="content">
<pre><code>        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        ...</code></pre>
</div></div>
<div class="paragraph"><p>instead of:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        ...</code></pre>
</div></div>
<div class="paragraph"><p>Defaults to false.</p></div>
</dd>
<dt class="hdlist1">
rebase.rescheduleFailedExec
</dt>
<dd>
<p>
        Automatically reschedule <code>exec</code> commands that failed. This only makes sense
        in interactive mode (or when an <code>--exec</code> option was provided).  This is the
        same as specifying the <code>--reschedule-failed-exec</code> option.
</p>
</dd>
<dt class="hdlist1">
rebase.forkPoint
</dt>
<dd>
<p>
        If set to false set <code>--no-fork-point</code> option by default.
</p>
</dd>
<dt class="hdlist1">
sequence.editor
</dt>
<dd>
<p>
        リベース命令ファイル(rebase instruction file)を編集するために <code>git rebase -i</code>
        によって使用されるテキストエディタ。この値は、使用時にシェルによって解釈されることを意図しています。 これは、
        <code>GIT_SEQUENCE_EDITOR</code>
        環境変数によってオーバーライドできます。構成されていない場合は、代わりにデフォルトのコミットメッセージエディタが使用されます。
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs">BUGS</h2>
<div class="sectionbody">
<div class="paragraph"><p>The todo list presented by the deprecated <code>--preserve-merges --interactive</code>
does not represent the topology of the revision graph (use <code>--rebase-merges</code>
instead).  Editing commits and rewording their commit messages should work
fine, but attempts to reorder commits tend to produce counterintuitive
results.  Use <code>--rebase-merges</code> in such scenarios instead.</p></div>
<div class="paragraph"><p>For example, an attempt to rearrange</p></div>
<div class="listingblock">
<div class="content">
<pre><code>1 --- 2 --- 3 --- 4 --- 5</code></pre>
</div></div>
<div class="paragraph"><p>to</p></div>
<div class="listingblock">
<div class="content">
<pre><code>1 --- 2 --- 4 --- 3 --- 5</code></pre>
</div></div>
<div class="paragraph"><p>by moving the "pick 4" line will result in the following history:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>        3
       /
1 --- 2 --- 4 --- 5</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2022-03-01 11:31:48 JST
</div>
</div>
</body>
</html>
