\input texinfo
@setfilename gitman.info
@documentencoding UTF-8
@dircategory Development
@direntry
* Git Man Pages: (gitman).  Manual pages for Git revision control system
@end direntry
@node Top,,, (dir)
@top Git Manual Pages
@documentlanguage en
@menu
* git-add::
* git-am::
* git-annotate::
* git-apply::
* git-archimport::
* git-archive::
* git-bisect::
* git-blame::
* git-branch::
* git-bugreport::
* git-bundle::
* git-cat-file::
* git-check-attr::
* git-check-ignore::
* git-check-mailmap::
* git-check-ref-format::
* git-checkout-index::
* git-checkout::
* git-cherry-pick::
* git-cherry::
* git-citool::
* git-clean::
* git-clone::
* git-column::
* git-commit-graph::
* git-commit-tree::
* git-commit::
* git-config::
* git-count-objects::
* git-credential-cache--daemon::
* git-credential-cache::
* git-credential-store::
* git-credential::
* git-cvsexportcommit::
* git-cvsimport::
* git-cvsserver::
* git-daemon::
* git-describe::
* git-diagnose::
* git-diff-files::
* git-diff-index::
* git-diff-tree::
* git-diff::
* git-difftool::
* git-fast-export::
* git-fast-import::
* git-fetch-pack::
* git-fetch::
* git-filter-branch::
* git-fmt-merge-msg::
* git-for-each-ref::
* git-for-each-repo::
* git-format-patch::
* git-fsck-objects::
* git-fsck::
* git-fsmonitor--daemon::
* git-gc::
* git-get-tar-commit-id::
* git-grep::
* git-gui::
* git-hash-object::
* git-help::
* git-hook::
* git-http-backend::
* git-http-fetch::
* git-http-push::
* git-imap-send::
* git-index-pack::
* git-init-db::
* git-init::
* git-instaweb::
* git-interpret-trailers::
* git-log::
* git-ls-files::
* git-ls-remote::
* git-ls-tree::
* git-mailinfo::
* git-mailsplit::
* git-maintenance::
* git-merge-base::
* git-merge-file::
* git-merge-index::
* git-merge-one-file::
* git-merge-tree::
* git-merge::
* git-mergetool--lib::
* git-mergetool::
* git-mktag::
* git-mktree::
* git-multi-pack-index::
* git-mv::
* git-name-rev::
* git-notes::
* git-p4::
* git-pack-objects::
* git-pack-redundant::
* git-pack-refs::
* git-patch-id::
* git-prune-packed::
* git-prune::
* git-pull::
* git-push::
* git-quiltimport::
* git-range-diff::
* git-read-tree::
* git-rebase::
* git-receive-pack::
* git-reflog::
* git-remote-ext::
* git-remote-fd::
* git-remote::
* git-repack::
* git-replace::
* git-request-pull::
* git-rerere::
* git-reset::
* git-restore::
* git-rev-list::
* git-rev-parse::
* git-revert::
* git-rm::
* git-send-email::
* git-send-pack::
* git-sh-i18n--envsubst::
* git-sh-i18n::
* git-sh-setup::
* git-shell::
* git-shortlog::
* git-show-branch::
* git-show-index::
* git-show-ref::
* git-show::
* git-sparse-checkout::
* git-stage::
* git-stash::
* git-status::
* git-stripspace::
* git-submodule::
* git-svn::
* git-switch::
* git-symbolic-ref::
* git-tag::
* git-unpack-file::
* git-unpack-objects::
* git-update-index::
* git-update-ref::
* git-update-server-info::
* git-upload-archive::
* git-upload-pack::
* git-var::
* git-verify-commit::
* git-verify-pack::
* git-verify-tag::
* git-version::
* git-web--browse::
* git-whatchanged::
* git-worktree::
* git-write-tree::
* git::
* gitattributes::
* gitcli::
* gitcore-tutorial::
* gitcredentials::
* gitcvs-migration::
* gitdiffcore::
* giteveryday::
* gitfaq::
* gitformat-bundle::
* gitformat-chunk::
* gitformat-commit-graph::
* gitformat-index::
* gitformat-pack::
* gitformat-signature::
* gitglossary::
* githooks::
* gitignore::
* gitk::
* gitmailmap::
* gitmodules::
* gitnamespaces::
* gitprotocol-capabilities::
* gitprotocol-common::
* gitprotocol-http::
* gitprotocol-pack::
* gitprotocol-v2::
* gitremote-helpers::
* gitrepository-layout::
* gitrevisions::
* gitsubmodules::
* gittutorial-2::
* gittutorial::
* gitweb.conf::
* gitweb::
* gitworkflows::
* scalar::
@end menu
@node git-add,,,Top
@chapheading Name

git-add — ファイルの内容をインデックスに追加します

@noindent

@chapheading Synopsis

@display
git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
          [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse]
          [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
          [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、作業ツリーで見つかった現在のコンテンツを使用してインデックスを更新し、次のコミットのためにステージングされたコンテンツを準備します。 通常、既存のパスの現在のコンテンツを全体として追加しますが、一部のオプションを使用して、作業ツリーファイルに加えられた変更の一部のみを適用したコンテンツを追加したり、作業ツリーにもう存在しないパスを削除したりすることもできます。

「インデックス」は作業ツリーのコンテンツのスナップショットを保持し、次のコミットのコンテンツとして取得されるのはこのスナップショットです。 したがって、作業ツリーに変更を加えた後、commitコマンドを実行する前に、 @samp{add} コマンドを使用して新しいファイルまたは変更されたファイルをインデックスに追加する必要があります。

このコマンドは、コミット前に複数回実行できます。 addコマンドの実行時に指定されたファイルのコンテンツのみが追加されます。 その次のコミットに後続の変更を含める場合は、 @samp{git add} を再度実行して、新しいコンテンツをインデックスに追加する必要があります。

@samp{git status} コマンドを使用して、次のコミットのためにステージングされる変更が含まれているファイルの概要を取得できます。

@samp{git add} コマンドは、デフォルトでは無視されたファイル(ignored files)を追加しません。 無視されたファイル(ignored files)をコマンドラインで明示的に指定した場合、 @samp{git add} は無視されたファイルのリストにより失敗します。 Gitによって実行されたディレクトリ再帰またはファイル名グロブ(シェル展開される前にあなたのグロブをクォートしておく)によって到達した無視されたファイルは、黙って無視されます。 @samp{-f} (force)オプションとともに @samp{git add} コマンドを使用すると無視されたファイルを追加できます。

コミットにコンテンツを追加する別の方法については、 git-commit(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  <pathspec>… 
コンテンツを追加するファイル。 ファイルグロブ(例: @samp{*.c})を指定して、マッチするすべてのファイルを追加できます。 また、先頭のディレクトリ名(たとえば @samp{dir} で @samp{dir/file1} と @samp{dir/file2} を追加)を指定して、ディレクトリ全体の現在の状態に一致するようにインデックスを更新することもできます(たとえば、 @samp{dir} を指定すると、作業ツリーで変更されたファイル @samp{dir/file1} の変更記録や、作業ツリーに追加されたファイル @samp{dir/file2} の追加記録だけでなく、作業ツリーから削除されたファイル @samp{dir/file3} の削除記録も行われます)。 古いバージョンのGitでは、削除されたファイルを無視していたことに注意してください。 変更されたファイルまたは新しいファイルを追加し、削除されたファイルを無視する場合は、 @samp{--no-all} オプションを使用します。

<pathspec>構文の詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際にファイルを追加するのではなく、ファイルが存在するかどうか、および/または 無視されるかどうかを表示します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
おしゃべりにします。

@item  @samp{-f} 
@itemx  @samp{--force} 
これ以外の場合は無視されるファイルの追加を許可します。

@item  @samp{--sparse} 
スパース・チェックアウト・コーン(sparse-checkout cone)の外側のインデックス・エントリを更新できるようにします。 通常、 @samp{git add} はパスがスパース・チェックアウト・コーン内に収まらないインデックス・エントリの更新を拒否します。これらのファイルは警告なしに作業ツリーから削除される可能性があるためです。 詳細については、 git-sparse-checkout(1) を参照してください。

@item  @samp{-i} 
@itemx  @samp{--interactive} 
作業ツリーの変更されたコンテンツを対話的にインデックスに追加します。 オプションのパス引数を指定して、操作を作業ツリーのサブセットに制限することができます。 詳細については、「Interactive mode」を参照してください。

@item  @samp{-p} 
@itemx  @samp{--patch} 
インデックスと作業ツリーの間でパッチの塊(hunk)を対話的に選択し、それらをインデックスに追加します。 これにより、ユーザーは、変更されたコンテンツをインデックスに追加する前に、違いを確認することができます。

これは効果的に @samp{add --interactive} を実行しますが、初期コマンドメニューをバイパスし、 @samp{patch} サブコマンドに直接ジャンプします。 詳細については、「Interactive mode」を参照してください。

@item  @samp{-e} 
@itemx  @samp{--edit} 
差分とインデックスをエディタで開き、ユーザに編集させる。 エディタを閉じた後、ハンクヘッダ(hunk headers)を調整し、インデックスにパッチを適用する。

このオプションの目的は、適用するパッチの行を選択すること、またはステージングする行の内容を変更することです。 これは、対話的なハンク選択器(interactive hunk selector)を使用するよりも迅速かつ柔軟になります。 しかしながら、混乱してインデックスに適用されないパッチを作成するのも簡単にできてしまいます。以下の「EDITING PATCHES」を参照してください。

@item  @samp{-u} 
@itemx  @samp{--update} 
<pathspec>にマッチするエントリがすでにある場所でインデックスを更新します。 これにより、作業ツリーにマッチするようにインデックスエントリが削除および変更されますが、新しいファイルは追加されません。

@samp{-u} オプションが使用されているときに<pathspec>が指定されていない場合、作業ツリー全体で追跡されているファイル(tracked files)すべてが更新されます(Gitの古いバージョンでは、更新を現在のディレクトリとそのサブディレクトリに制限するために使用されていました)。

@item  @samp{-A} 
@itemx  @samp{--all} 
@itemx  @samp{--no-ignore-removal} 
作業ツリーに<pathspec>にマッチするファイルがある場合だけでなく、インデックスにすでにエントリがある場合にも、インデックスを更新します。 これにより、作業ツリーにマッチするようにインデックスエントリが 追加や変更や削除 されます。

@samp{-A} オプションが使用されているときに<pathspec>が指定されていない場合、作業ツリー全体のすべてのファイルが更新されます(Gitの古いバージョンでは、現在のディレクトリとそのサブディレクトリに更新を制限するために使用されていました)。

@item  @samp{--no-all} 
@itemx  @samp{--ignore-removal} 
インデックスに未知の新しいファイルや、作業ツリーで変更されたファイルを追加してインデックスを更新するが、作業ツリーから削除されたファイルは無視する。 <pathspec> が使用されていない場合、このオプションは何もしません。

このオプションは主に、 @samp{git add <pathspec>...} が @samp{git add --no-all <pathspec>...} つまり、削除されたファイルの無視、の同義語であった、古いバージョンのGitに慣れているユーザーを支援するためのものです。

@item  @samp{-N} 
@itemx  @samp{--intent-to-add} 
パスが後で追加されるという事実のみを記録します。 パスのエントリは、コンテンツなしでインデックスに配置されます。 これは、特に、そのようなファイルのステージングされていないコンテンツを @samp{git diff} で表示し、それらを @samp{git commit -a} でコミットする場合に役立ちます。

@item  @samp{--refresh} 
ファイルを追加しません。 ただし、インデックス内の stat() 情報のみ更新します。

@item  @samp{--ignore-errors} 
一部のファイルのインデックス作成エラーが原因で追加できなかった場合は、操作を中止せずに、他のファイルの追加を続行します。 コマンドは、ゼロ以外のステータスで終了します。 構成変数 @samp{add.ignoreErrors} をtrueに設定して、これをデフォルトの動作にすることができます。

@item  @samp{--ignore-missing} 
このオプションは、 @samp{--dry-run} と一緒にのみ使用できます。 このオプションを使用することにより、ユーザーは、指定されたファイルがすでに作業ツリーに存在するかどうかに関係なく、それらのファイルのどれが無視されるかどうかを確認できます。

@item  @samp{--no-warn-embedded-repo} 
デフォルトでは、 @samp{git submodule add} を使用して @samp{.gitmodules} にエントリを作成せずに、埋め込みリポジトリ(embedded repository)をインデックスに追加すると、 @samp{git add} が警告を表示します。 このオプションは、警告を抑制します(たとえば、サブモジュールで手動で操作を実行している場合)。

@item  @samp{--renormalize} 
全ての追跡されたファイル(tracked files)に「クリーン」(clean)プロセスを新たに適用して、それらをインデックスに強制的に再度追加します。 これは、誤った CRLF/LF 行末で追加されたファイルを修正するために、 @samp{core.autocrlf} 構成または @samp{text} 属性を変更した後に役立ちます。 このオプションは @samp{-u} の指定を含んでいます。 単独の CR 文字は変更されないため、CRLF は LF にクリーンアップされますが、 CRCRLF シーケンスは部分的にのみ CRLF にクリーンアップされます。

@item  @samp{--chmod=(+|-)x} 
追加されたファイルの実行可能ビットを上書きします。 実行可能ビットはインデックス内でのみ変更され、ディスク上のファイルは変更されません。

@item  @samp{--pathspec-from-file=<file>} 
パススペックは、コマンドライン引数の代わりに @samp{<file>} で渡されます。 @samp{<file>} が正確に @samp{-} の場合、標準入力が使用されます。 パススペック要素は、LFまたは CR/LF で区切られます。 パススペック要素は、構成変数 @samp{core.quotePath} で説明されているようにクォートできます(git-config(1) 参照)。 @samp{--pathspec-file-nul} および グローバル @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
@samp{--pathspec-from-file} でのみ意味があります。 pathspec要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  @samp{--} 
このオプションは、コマンドラインオプションをファイルのリストから分離するために使用できます(ファイル名がコマンドラインオプションと間違えられる可能性がある場合に便利です)。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
@samp{Documentation} ディレクトリとそのサブディレクトリの下にあるすべての @samp{*.txt} ファイルからコンテンツを追加します:

@example
$ git add Documentation/\*.txt
@end example


注意: この例では、アスタリスク @samp{*} がシェルからクォートされていることに注意してください。 これにより、コマンドに @samp{Documentation/} ディレクトリのサブディレクトリからのファイルを含めることができます。

@item
すべての git-*.sh スクリプトからコンテンツを追加することを検討します:

@example
$ git add git-*.sh
@end example


この例では、シェルがアスタリスクを展開できてしまうため(つまり、ファイルを明示的にリストしているため)、 @samp{subdir/git-foo.sh} は考慮されません。
@end itemize

@noindent

@chapheading INTERACTIVE MODE

コマンドが対話モード(interactive mode)に入ると、「status」サブコマンドの出力が表示され、対話コマンドループに入ります。

コマンドループは、使用可能なサブコマンドのリストを表示し、 @samp{What now> ` というプロンプトを表示します。 一般に、プロンプトが単一の `>} で終了する場合、以下のように、指定された選択肢の1つだけを選択し、returnキーをタイプできます:

@example
    *** Commands ***
      1: status       2: update       3: revert       4: add untracked
      5: patch        6: diff         7: quit         8: help
    What now> 1
@end example


選択が一意である限り、上記のは「s」または「sta」または「status」と言うことができます。

メインコマンドループには6つのサブコマンドがあります(加えてhelpとquitがあります)。

@table @asis

@item  status 
これは、HEADとインデックスの間の変更(つまり、 @samp{git commit} とした場合にコミットされるもの)、および、各パスのインデックスと作業ツリーファイルの間の変更(つまり、 @samp{git add} を使用して、 @samp{git commit} する前にさらにステージングできるもの)を示しています。 出力例は以下のようになります:

@example
              staged     unstaged path
     1:       binary      nothing foo.png
     2:     +403/-35        +1/-1 add-interactive.c
@end example


It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, @emph{binary} would have been shown in place of @emph{nothing}). The other file, add-interactive.c, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).

@item  update 
これにより、ステータス情報が表示され、 @samp{Update>>} プロンプトが表示されます。 プロンプトが二重の @samp{>>} で終わる場合は、空白またはコンマで連結して複数の選択を行うことができます。 また、範囲指定もできます。 例えば、 @samp{2-5 7,9} でリストから 2,3,4,5,7,9 を選択します。 範囲内の2番目の数字を省略すると、残りのすべてのパッチが適用されます。 例えば、 @samp{7-} はリストから 7,8,9 を選択します。 @samp{*} で全選択できます。

あなたが選択したものは、以下のように @samp{*} で強調表示されます:

@example
           staged     unstaged path
  1:       binary      nothing foo.png
* 2:     +403/-35        +1/-1 add-interactive.c
@end example


選択を削除するには、以下のように入力の前に @samp{-} を付けます:

@example
Update>> -2
@end example


選択後、空行で答えて、インデックス内の選択されたパスの作業ツリーファイルの内容をステージングします。

@item  revert 
これは「update」と非常によく似たUIを持ち、選択されたパスのステージングされた情報はHEADバージョンの情報に戻されます(revert)。 新しいパスを元に戻すと、追跡されなくなります。

@item  add untracked 
これは、「update」および「revert」と非常によく似たUIを備えており、追跡されていないパスをインデックスに追加できます。

@item  patch 
これにより、選択に似た @samp{status} から1つのパスを選択できます。 パスを選択すると、インデックスと作業ツリーファイルの差分が表示され、各ハンクの変更をステージングするかどうかを尋ねられます。 以下のオプションのいずれかを選択してからreturnキーをタイプできます。

@example
y - stage this hunk
n - do not stage this hunk
q - quit; do not stage this hunk or any of the remaining ones
a - stage this hunk and all later hunks in the file
d - do not stage this hunk or any of the later hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
@end example

すべてのハンクの運命を決定した後、選択されたハンク達がある場合、インデックスは選択されたハンク達によって更新されます。

構成変数 @samp{interactive.singleKey} を @samp{true} に設定することにより、あなたはここでreturnキーをタイプする必要をなくすことができます。

@item  diff 
これにより、コミットされる内容(つまり、HEAD〜インデックス間)を確認できます。
@end table

@noindent

@chapheading EDITING PATCHES

@samp{git add -e} を呼び出すか、対話的ハンク選択器(interactive hunk selector)で @samp{e} を選択すると、エディタでパッチを開きます。 エディタが終了すると、結果がインデックスに適用されます。 パッチに任意の変更を加えることは自由ですが、一部の変更は混乱を招く結果をもたらす可能性があること、または適用できないパッチをもたらす可能性があることに注意してください。 操作を完全に中止する場合(つまり、インデックスに新しいものをステージングしない場合)は、パッチのすべての行を削除するだけです。 以下のリストは、パッチに見られる一般的なものと、それらに対して意味のある編集操作を示しています。

@table @asis

@item  added content 
追加されたコンテンツは、 + で始まる行で表されます。 追加行を削除することで、追加行のステージングを防ぐことができます。

@item  removed content 
削除されたコンテンツは、 @samp{-} で始まる行で表されます。 @samp{-} を ` ` (スペース)に変換することで、ステージングによる削除を防ぐことができます。

@item  modified content 
変更されたコンテンツは、 @samp{-} 行(古いコンテンツを削除)とそれに続く + 行(置換コンテンツを追加)で表されます。 @samp{-} 行を ` ` に変換し、 + 行を削除することで、変更のステージングを防ぐことができます。 ペアの半分だけを変更すると、インデックスに紛らわしい変更が加えられる可能性があることに注意してください。
@end table

実行できるより複雑な操作もあります。 ただし、パッチはインデックスにのみ適用され、作業ツリーには適用されないため、作業ツリーはインデックスの変更を「元に戻す」(undo)ように見えることに注意してください。 たとえば、HEADにも作業ツリーにも存在しないインデックスに新しい行を導入すると、コミットのために新しい行がステージングされますが、その行は作業ツリーで元に戻されている(revert)ように見えます。

これらの構成を使用しないようにするか、または、細心の注意を払って使用してください。

@table @asis

@item  removing untouched content 
インデックスと作業ツリーの間で異なって無いコンテンツが、 ` ` (スペース)で始まるコンテキスト行に表示される場合があります。 スペースを @samp{-} に変換することで、削除するコンテキスト行としてステージングできます。 その結果、再度追加してくださいと、その作業ツリーファイルが表示されます。

@item  modifying existing content 
(` ` を @samp{-} に変換することにより、)削除のためにステージングして、新しいコンテンツに + 行を追加することにより、コンテキスト行を変更することもできます。 同様に、既存の追加または変更のために + 行を変更できます。 いずれの場合も、新しい変更は作業ツリーに戻されて表示されます。

@item  new content 
パッチに存在しない新しいコンテンツを追加することもできます。 それぞれが + で始まる新しい行を追加するだけです。 追加は、作業ツリーに戻されて表示されます。
@end table

パッチが適用できなくなるため、完全に回避する必要のある操作もいくつかあります:

@itemize 

@item
コンテキスト行達(" ")または削除行達("-")の追加

@item
コンテキスト行達または削除行達の削除

@item
コンテキスト行達または削除行達の内容を変更する
@end itemize

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  add.ignoreErrors 
@itemx  add.ignore-errors (非推奨) 
インデックスエラーのために一部のファイルを追加できない場合にファイルの追加を続行するように @samp{git add} に指示します。 git-add(1) の @samp{--ignore-errors} オプションと同等です。 @samp{add.ignore-errors} は、構成変数の通常の命名規則に従わないため、非推奨になりました。

@item  add.interactive.useBuiltin 
Unused configuration variable. Used in Git versions v2.25.0 to v2.36.0 to enable the built-in version of git-add(1)'s interactive mode, which then became the default in Git versions v2.37.0 to v2.39.0.
@end table

@noindent

@chapheading SEE ALSO

git-status(1) git-rm(1) git-reset(1) git-mv(1) git-commit(1) git-update-index(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-am,,,Top
@chapheading Name

git-am — メールボックスから一連のパッチを適用します

@noindent

@chapheading Synopsis

@display
git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify]
         [--[no-]3way] [--interactive] [--committer-date-is-author-date]
         [--ignore-date] [--ignore-space-change | --ignore-whitespace]
         [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
         [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
         [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
         [--quoted-cr=<action>]
         [--empty=(stop|drop|keep)]
         [(<mbox> | <Maildir>)…]
git am (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)
@end display


@noindent

@chapheading DESCRIPTION

Splits mail messages in a mailbox into commit log message, authorship information and patches, and applies them to the current branch. You could think of it as a reverse operation of git-format-patch(1) run on a branch with a straight history without merges.

@noindent

@chapheading OPTIONS

@table @asis

@item  (<mbox>|<Maildir>)… 
パッチを読み取るメールボックスファイルのリスト。 この引数を指定しない場合、コマンドは標準入力から読み取ります。 ディレクトリを指定すると、それらはMaildirとして扱われます。

@item  @samp{-s} 
@itemx  @samp{--signoff} 
自分のコミッターIDを使用して、コミットメッセージに @samp{Signed-off-by} トレーラーを追加します。 詳細については、 git-commit(1) のsignoffオプションを参照してください。

@item  @samp{-k} 
@itemx  @samp{--keep} 
@samp{-k} フラグを @samp{git mailinfo} に渡します(git-mailinfo(1) 参照)。

@item  @samp{--keep-non-patch} 
@samp{-b} フラグを @samp{git mailinfo} に渡します(git-mailinfo(1) 参照)。

@item  @samp{--[no-]keep-cr} 
@samp{--keep-cr} を使用して、同じオプションで @samp{git mailsplit} (git-mailsplit(1) 参照)を呼び出し、行末のCRが削除されないようにします。 @samp{am.keepcr} 構成変数を使用して、デフォルトの動作を指定できます。 @samp{--no-keep-cr} は、 @samp{am.keepcr} をオーバーライドするのに役立ちます。

@item  @samp{-c} 
@itemx  @samp{--scissors} 
切り取り線行の前にある本体のすべてを削除します(git-mailinfo(1) 参照)。 @samp{mailinfo.scissors} 構成変数を使用してデフォルトでアクティブ化できます。

@item  @samp{--no-scissors} 
切り取り線を無視します(git-mailinfo(1) 参照)。

@item  @samp{--quoted-cr=<action>} 
このフラグは @samp{git mailinfo} に渡されます(git-mailinfo(1) 参照)。

@item  @samp{--empty=(stop|drop|keep)} 
デフォルト、またはオプションが @samp{stop} に設定されている場合、パッチの欠落した入力の電子メール・メッセージでコマンドがエラーになり、現在の am セッションの途中で停止(stop)します。 このオプションが @samp{drop} に設定されている場合、代わりにそのような電子メール・メッセージをスキップします。 このオプションが @samp{keep} に設定されている場合、空のコミットを作成し、電子メール・メッセージの内容をログとして記録します。

@item  @samp{-m} 
@itemx  @samp{--message-id} 
@samp{-m} フラグを @samp{git mailinfo} (git-mailinfo(1) 参照)に渡して、Message-IDヘッダーがコミットメッセージに追加されるようにします。 @samp{am.messageid} 構成変数を使用して、デフォルトの動作を指定できます。

@item  @samp{--no-message-id} 
コミットメッセージにMessage-IDヘッダーを追加しないでください。 @samp{no-message-id} は、 @samp{am.messageid} を上書きするのに役立ちます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。エラーメッセージのみ出力します。

@item  @samp{-u} 
@itemx  @samp{--utf8} 
@samp{-u} フラグを @samp{git mailinfo} に渡します（linkgit：git-mailinfo [1]を参照）。 電子メールから取得された、提案されたコミットログメッセージは、UTF-8エンコーディングに再コーディングされます(UTF-8でない場合は、構成変数 @samp{i18n.commitEncoding} を使用して、プロジェクトの優先エンコーディングを指定できます)。

これは以前のバージョンのgitではオプションでしたが、現在はデフォルトです。
@samp{--no-utf8} を使用してこれをオーバーライドできます。

@item  @samp{--no-utf8} 
@samp{-n} フラグを @samp{git mailinfo} に渡します(git-mailinfo(1) 参照)。

@item  @samp{-3} 
@itemx  @samp{--3way} 
@itemx  @samp{--no-3way} 
パッチが適切に適用されない場合、パッチが適用されるはずのブロブのIDを記録し、それらのブロブがローカルで使用できる場合は、3方向マージにフォールバックします。 @samp{--no-3way} を使用して、 am.threeWay構成変数をオーバーライドできます。 詳細については、 git-config(1) のam.threeWayを参照してください。

@item  @samp{--rerere-autoupdate} 
@itemx  @samp{--no-rerere-autoupdate} 
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 @samp{--no-rerere-autoupdate} は、別の @samp{git add} で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。

@item  @samp{--ignore-space-change} 
@itemx  @samp{--ignore-whitespace} 
@itemx  @samp{--whitespace=<option>} 
@itemx  @samp{-C<n>} 
@itemx  @samp{-p<n>} 
@itemx  @samp{--directory=<dir>} 
@itemx  @samp{--exclude=<path>} 
@itemx  @samp{--include=<path>} 
@itemx  @samp{--reject} 
これらのフラグは、パッチを適用する @samp{git apply} (git-apply(1) 参照)プログラムに渡されます。

@item  @samp{--patch-format} 
デフォルトでは、コマンドはパッチ形式を自動的に検出しようとします。 このオプションを使用すると、ユーザーは自動検出をバイパスして、パッチを解釈するパッチ形式を指定できます。 有効な形式は、mbox、mboxrd、stgit、stgit-series、hg です。

@item  @samp{-i} 
@itemx  @samp{--interactive} 
対話的に実行します。

@item  @samp{-n} 
@itemx  @samp{--no-verify} 
By default, the pre-applypatch and applypatch-msg hooks are run. When any of @samp{--no-verify} or @samp{-n} is given, these are bypassed. See also githooks(5).

@item  @samp{--committer-date-is-author-date} 
デフォルトでは、コマンドは電子メールメッセージの日付をコミット作者の日付として記録し、コミットの作成時刻をコミッターの日付として使用します。 これにより、ユーザーは作者の日付と同じ値を使用して、コミッターの日付について嘘をつくことができます。

@item  @samp{--ignore-date} 
デフォルトでは、コマンドは電子メールメッセージの日付をコミット作者の日付として記録し、コミットの作成時刻をコミッターの日付として使用します。 これにより、ユーザーはコミッターの日付と同じ値を使用して、作者の日付について嘘をつくことができます。

@item  @samp{--skip} 
現在のパッチをスキップします。 これは、中止(abort)されたパッチを再スタートする場合にのみ意味があります。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミット。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに固定する必要があります。 @samp{--no-gpg-sign} は、 @samp{commit.gpgSign} 構成変数と以前の @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{--continue} 
@itemx  @samp{-r} 
@itemx  @samp{--resolved} 
パッチが失敗した後(たとえば、競合するパッチを適用しようとした場合)、ユーザーはそれを手動で適用し、インデックスファイルに適用の結果が保存されます。 電子メールメッセージと現在のインデックスファイルから抽出された作者とコミットログを使用してコミットし、続行します。

@item  @samp{--resolvemsg=<msg>} 
パッチ障害が発生すると、終了する前に<msg>が画面に出力されます。 これは、失敗を処理するために @samp{--continue} または @samp{--skip} を使用するように通知する標準メッセージをオーバーライドします。 これは、 @samp{git rebase} と @samp{git am} の間の内部使用のみを目的としています。

@item  @samp{--abort} 
元のブランチを復元(restore)し、パッチ操作を中止(abort)します。 am操作に関係するファイルの内容をam前の状態(pre-am state)に戻します(revert)。

@item  @samp{--quit} 
パッチ適用操作を中止しますが、HEADとインデックスはそのままにしておきます。

@item  @samp{--show-current-patch[=(diff|raw)]} 
競合が原因で @samp{git am} が停止(stop)したメッセージを表示します。 @samp{raw} が指定されている場合、電子メールメッセージの生の内容を表示します。 @samp{diff} の場合、diff部分のみを表示します。 デフォルトは @samp{raw} です。

@item  @samp{--allow-empty} 
パッチが欠落している入力の電子メール・メッセージでパッチが失敗した後、ログ・メッセージとして電子メール・メッセージの内容を含む空のコミットを作成します。
@end table

@noindent

@chapheading DISCUSSION

コミット作者名はメッセージの "From: " から取得され、コミット作者日付はメッセージの "Date: " 行から取得されます。 "Subject: " 行は、共通のプレフィックス @samp{[PATCH <anything>]} を削除した後、コミットのタイトルとして使用されます。 "Subject: " 行は、コミットが何であるかを1行のテキストで簡潔に説明することになっています。

"From: " や "Date: " や "Subject: " の行で始まる本文は、ヘッダーから取得されたそれぞれのコミット作者名とタイトルの値をオーバーライドします。

コミットメッセージは、 "Subject: " から取得したタイトルと空行とパッチが開始されるところまでのメッセージの本文によって形成されます。 各行の終わりにある余分な空白(whitespace)は自動的に削除されます。

パッチは、メッセージの直後にインラインであることが期待されます。 以下の形式の行:

@itemize 

@item
3つのダッシュ(@samp{---})と行終端(end-of-line)、または

@item
"diff -" で始まる行、または

@item
"Index: " で始まる行
@end itemize

これらはパッチの開始と見なされ、そのような行が最初に出現する前でコミットログメッセージが終了します。

最初に @samp{git am} を呼び出すときに、処理するメールボックスの名前を指定します。 適用されない最初のパッチを確認すると、途中で中止(abort)されます。 これからは、以下の2つの方法のいずれかで回復(recover)できます:

@enumerate 

@item
@samp{--skip} オプションを指定してコマンドを再実行し、現在のパッチをスキップします。

@item
作業ディレクトリの競合を手動で解決し、インデックスファイルを更新して、パッチが生成するはずの状態にします。その次に、 @samp{--continue} オプションを指定してコマンドを実行します。
@end enumerate

このコマンドは、現在の操作が終了するまで新しいメールボックスの処理を拒否するため、最初からやり直す場合は、メールボックス名を指定してコマンドを実行する前に、 @samp{git am --abort} を実行してください。

パッチが適用される前に、ORIG_HEADは現在のブランチの先端に設定されます。 これは、間違ったブランチで @samp{git am} を実行したり、メールボックスを変更することでより簡単に修正できるコミットのエラー("From:" 行のエラーなど)など、複数のコミットに問題がある場合に役立ちます。

@noindent

@chapheading HOOKS

このコマンドは、 applypatch-msgフックとpre-applypatchフックとpost-applypatchフックを実行できます。 詳細については githooks(5) を参照してください。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  am.keepcr 
trueの場合、 @samp{git-am} は、パラメーター @samp{--keep-cr} を使用してmbox形式のパッチに対して` git-mailsplit` を呼び出します。 この場合、 @samp{git-mailsplit} は @samp{\r\n} で終わる行から @samp{\r} を削除しません。 コマンドラインから @samp{--no-keep-cr} を指定することでオーバーライドできます。 git-am(1) と git-mailsplit(1) を参照してください。

@item  am.threeWay 
デフォルトでは、パッチが正しく適用されない場合、 @samp{git am} は失敗します。 trueに設定すると、この設定は、パッチが適用される予定のブロブのIDを記録し、それらのブロブをローカルで使用できる場合に、3方向マージにフォールバックするように @samp{git am} に指示します(コマンドラインから @samp{--3way} オプションを指定するのと同じです)。 デフォルトは @samp{false} です。 git-am(1)を参照してください。
@end table

@noindent

@chapheading SEE ALSO

git-apply(1), git-format-patch(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-annotate,,,Top
@chapheading Name

git-annotate — 指定ファイルの各行のコミット情報を表示

@noindent

@chapheading Synopsis

@display
git annotate [<options>] [<rev-opts>] [<rev>] [--] <file>
@end display


@noindent

@chapheading DESCRIPTION

指定されたファイルの各行に、その行を導入したコミットからの情報で注釈を付けます。オプションで、特定のリビジョンから注釈を付けます。

このコマンドと git-blame(1) の唯一の違いは、わずかに異なる出力形式を使用することです。このコマンドは、既存のスクリプトをサポートするための下位互換性のためにのみ存在し、他のSCMシステムから来た人々により馴染みのあるコマンド名を提供します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-b} 
境界コミットでは空白のSHA-1を表示します。これは、 @samp{blame.blankBoundary} 構成オプションを介して制御することもできます。

@item  @samp{--root} 
ルートコミットを境界として扱わないでください。 これは、 @samp{blame.showRoot} 構成オプションを介して制御することもできます。

@item  @samp{--show-stats} 
blameの出力の最後に追加の統計を含めます。

@item  @samp{-L <start>,<end>} 
@itemx  @samp{-L :<funcname>} 
@samp{<start>,<end>} で指定の行範囲のみ、または正規表現関数名 @samp{<funcname>} で指定の行範囲のみに注釈を付けます。複数回指定できます。範囲が重複するのは許されます。

@samp{<start>} と @samp{<end>} はオプションです。 @samp{-L <start>} または @samp{-L <start>,} は @samp{<start>} からファイルの終わりまでの範囲です。 @samp{-L ,<end>} は、ファイルの先頭から @samp{<end>} までの範囲です。

<start> と <end> は、以下のいずれかの形式です:

@itemize 

@item
数値

<start> または <end> が数値の場合、絶対行番号を指定します(行は1から数えます)。

@item
@samp{/regex/}

この形式は、指定されたPOSIX正規表現に一致する最初の行を使用します。 <start> が正規表現の場合、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 <start> が @samp{^/regex/} の場合、ファイルの先頭から検索します。 <end> が正規表現の場合、 <start> で指定された行から検索開始します。

@item
+offset or -offset

これは <end> に対してのみ有効であり、 <start> で指定された行の前後の行数を指定します。
@end itemize

<start> と <end> の代わりに @samp{:<funcname>} が指定されている場合、これは <funcname> に一致する最初の関数名行から次の関数名行までの範囲を示す正規表現です。 @samp{:<funcname>} は、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 @samp{^:<funcname>} はファイルの先頭から検索します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{-l} 
長いレビジョンを表示します(デフォルト: off)。

@item  @samp{-t} 
生のタイムスタンプを表示します(デフフォルト: off)。

@item  @samp{-S <revs-file>} 
git-rev-list(1) を呼び出す代わりに、revs-fileのリビジョンを使用します。

@item  @samp{--reverse <rev>..<rev>} 
履歴を後方へではなく前方へウォークします。行があらわれたされたリビジョンを表示する代わりに、行が存在した最後のリビジョンを表示します。これには、START..END のように、STARTにblameのパスが存在するレビジョン範囲が必要です。 便宜上、 @samp{git blame --reverse START} は @samp{git blame --reverse START..HEAD} と見なされます。

@item  @samp{--first-parent} 
マージコミットを確認したら、最初の親コミットのみを追跡します。 このオプションは、履歴全体にいつ導入されたかではなく、特定の統合ブランチにいつ導入されたかを判別するために使用できます。

@item  @samp{-p} 
@itemx  @samp{--porcelain} 
ソフトウェア等で使用するのに適した形式で表示します。

@item  @samp{--line-porcelain} 
磁器形式で表示しますが、コミットが最初に参照されたときだけでなく、各行のコミット情報を出力します。 --porcelain の機能を含んでいます。

@item  @samp{--incremental} 
ソフトウェア等で使用するのに適した形式で結果を段階的(incrementally)に表示します。

@item  @samp{--encoding=<encoding>} 
作者名(author names)の出力と要約のコミットに使用されるエンコーディングを指定します。 これを @samp{none} に設定すると、blame出力は変換されていないデータになります。詳細については、 git-log(1) のマニュアルページにある discussion の encoding に関する説明を参照してください。

@item  @samp{--contents <file>} 
Annotate using the contents from the named file, starting from <rev> if it is specified, and HEAD otherwise. You may specify @emph{-} to make the command read from the standard input for the file contents.

@item  @samp{--date <format>} 
日付の出力に使用される形式を指定します。 --date が指定されていない場合、blame.date 構成変数の値が使用されます。 blame.date 構成変数も設定されていない場合は、 iso形式が使用されます。サポートされている値については、 git-log(1) の --date オプションの説明を参照してください。

@item  @samp{--[no-]progress} 
進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、端末に接続されていない場合でも進行状況のレポートを有効にします。 @samp{--progress} を @samp{--porcelain} または @samp{--incremental} と一緒に使用することはできません。

@item  @samp{-M[<num>]} 
ファイル内の移動またはコピーされた行を検出します。コミットが行のブロックを移動またはコピーすると(たとえば、元のファイルにA、次にBがあり、コミットによってB、次にAに変更される)、従来の「blame」アルゴリズムは移動の半分だけに気づき、通常は行をblameします それは親に上に移動され(つまりB)、子のコミットに下に移動された(つまりA)行にblameを割り当てます。このオプションを使用すると、追加の検査パスを実行することにより、両方のグループの行が親のせいになります。

<num> はオプションですが、Gitがそれらの行を親コミットに関連付けるためにファイル内で移動/コピーとして検出する必要がある英数字の数(number of alphanumeric characters)の下限です。デフォルト値は20です。

@item  @samp{-C[<num>]} 
@samp{-M} に加えて、同じコミットで変更された他のファイルから移動またはコピーされた行を検出します。これは、プログラムを再編成し、ファイル間でコードを移動するときに役立ちます。このオプションを2回指定すると、コマンドは、ファイルを作成するコミットで他のファイルからのコピーを追加で検索します。このオプションを3回指定すると、コマンドはコミットで他のファイルからのコピーを追加で検索します。

<num> はオプションですが、Gitがそれらの行を親コミットに関連付けるためにファイル間の移動/コピーとして検出する必要がある英数字の数(number of alphanumeric characters)の下限です。また、デフォルト値は40です。複数の @samp{-C} オプションが指定されている場合、最後の @samp{-C} の <num> 引数が有効になります。

@item  @samp{--ignore-rev <rev>} 
変更が発生しなかったかのように、blameを割り当てるときにリビジョンによって行われた変更を無視します。無視されたコミットによって変更または追加された行は、その行または近くの行を変更した前のコミットのせいになります。このオプションは、複数のリビジョンを無視するために複数回指定できます。 @samp{blame.markIgnoredLines} 構成オプションが設定されている場合、無視されたコミットによって変更され、別のコミットに起因する行は、blame出力で @samp{?} でマークされます。 @samp{blame.markUnblamableLines} 構成オプションが設定されている場合、別のリビジョンに帰することができなかった無視されたコミットによって触れられた行は、 @samp{*} でマークされます。

@item  @samp{--ignore-revs-file <file>} 
@samp{file} にリストされているリビジョンを無視します。これは @samp{fsck.skipList} と同じ形式である必要があります。このオプションは繰り返すことができ、これらのファイルは、 @samp{blame.ignoreRevsFile} 構成オプションで指定されたファイルの後に処理されます。空のファイル名 @samp{""} は、以前に処理されたファイルからrevsのリストをクリアします。

@item  @samp{--color-lines} 
前行と同一のコミットからの場合、デフォルト形式の行注釈に異なる色を付けます。 これにより、異なるコミットによって導入されたコード・ブロックを区別しやすくなります。 色のデフォルトはシアン(cyan)で、 @samp{color.blame.repeatedLines} 設定オプションを使用して調整できます。

@item  @samp{--color-by-age} 
デフォルトの形式では、行の経過時間に応じて行の注釈に色を付けます。 @samp{color.blame.highlightRecent} 構成オプションは、年齢の各範囲で使用される色を制御します。

@item  @samp{-h} 
ヘルプメッセージを表示する。
@end table

@noindent

@chapheading SEE ALSO

git-blame(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-apply,,,Top
@chapheading Name

git-apply — パッチをファイルやインデックスに適用します

@noindent

@chapheading Synopsis

@display
git apply [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]
          [--apply] [--no-add] [--build-fake-ancestor=<file>] [-R | --reverse]
          [--allow-binary-replacement | --binary] [--reject] [-z]
          [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]
          [--ignore-space-change | --ignore-whitespace]
          [--whitespace=(nowarn|warn|fix|error|error-all)]
          [--exclude=<path>] [--include=<path>] [--directory=<root>]
          [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<patch>…]
@end display


@noindent

@chapheading DESCRIPTION

提供されたdiff出力(つまり「パッチ」)を読み取り、ファイルに適用します。 リポジトリ内のサブディレクトリから実行する場合、ディレクトリ外のパスへのパッチは無視されます。 @samp{--index} オプションを使用すると、パッチはインデックスにも適用され、 @samp{--cached} オプションを使用すると、パッチはインデックスにのみ適用されます。 これらのオプションがない場合、コマンドはパッチをファイルにのみ適用し、Gitリポジトリにいる必要はありません。

このコマンドはパッチを適用しますが、コミットは作成しません。 git-format-patch(1) によって生成されたパッチや、電子メールで受信されたパッチから、 git-am(1) を使用してコミットを作成します。

@noindent

@chapheading OPTIONS

@table @asis

@item  <patch>… 
パッチを読み取るファイル。 @samp{-} は、標準入力から読み取るために使用できます。

@item  @samp{--stat} 
パッチを適用する代わりに、入力に対してdiffstatを出力します。 ※applyはオフです(適用操作しません)。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、機械読み取り用に、追加および削除された行数を10進表記で表示し、パス名を省略形で表示します。 バイナリファイルの場合、 @samp{0 0} と言う代わりに2つの @samp{-} を出力します。 ※applyはオフです(適用操作しません)。

@item  @samp{--summary} 
パッチを適用する代わりに、ファイル作成、名前変更、モード変更など、git diff 拡張ヘッダーから取得した情報の要約を出力します。 ※applyはオフです(適用操作しません)。

@item  @samp{--check} 
パッチを適用する代わりに、パッチが現在の作業ツリーやインデックスファイルに適用可能かどうかを確認し、エラーを検出します。 ※applyはオフです(適用操作しません)。

@item  @samp{--index} 
パッチをインデックスと作業ツリーの両方に適用します(または、 @samp{--check} が有効になっている場合は、両方に正しく適用されることをチェックします)。 注意: @samp{--index} はインデックスエントリと関連するパスの作業木のコピーが同じであることを期待し(それらの内容とファイルモードなどのメタデータは一致する必要があります)、そうでない場合には、たとえパッチがインデックスと作業ツリーのそれぞれに単独できれいに適用されるとしても、エラーを発生させることに注意してください。

@item  @samp{--cached} 
作業ツリーに触れることなく、インデックスのみにパッチを適用します。 @samp{--check} が有効になっている場合は、インデックスエントリに正しく適用されることをチェックするだけです。

@item  @samp{--intent-to-add} 
パッチを作業ツリーだけに適用する場合は、新規ファイルをマークして後でインデックスに追加します(git-add(1) の @samp{--intent-to-add} オプションを参照してください)。このオプションは、Git リポジトリ内で実行していて @samp{--index} が指定されていない場合、無視されます。 なお、 @samp{--index} は @samp{--cached} や @samp{--3way} などの他のオプションによって暗示される可能性があります。

@item  @samp{-3} 
@itemx  @samp{--3way} 
パッチが適用する予定のブロブのIDを記録していて、それらのブロブがローカルで利用可能である場合、3方向マージを試みます。作業ツリーのファイルに競合マーカーを残して、ユーザーが解決できるようにするかもしれません。 このオプションは、 @samp{--cached} オプションが使用されていない限り、 @samp{--index} オプションを意味し、 @samp{--reject} オプションと互換性がありません。 また、 @samp{--reject} オプションと互換性がありません。 @samp{--cached} オプションと一緒に使用すると、競合があってもキャッシュの上位に残されます。

@item  @samp{--build-fake-ancestor=<file>} 
新しい @samp{git diff} 出力には、パッチが適用される元のバージョンを識別するのに役立つ各ブロブの「インデックス情報」が埋め込まれています。 このオプションが指定され、元のバージョンのブロブがローカルで使用可能な場合は、それらのブロブを含む一時的なインデックスを作成します。

純粋なモード変更(インデックス情報を持たない)に遭遇した場合、代わりに現在のインデックスから情報が読み取られます。

@item  @samp{-R} 
@itemx  @samp{--reverse} 
パッチを逆に適用します。

@item  @samp{--reject} 
アトミックな場合、 @samp{git apply} はデフォルトでパッチ全体に失敗し、一部のハンクが適用されない場合は作業ツリーにアクセスしません。 このオプションを使用すると、パッチの該当する部分が適用され、拒否されたハンクが対応する @samp{*.rej} ファイルに残されます。

@item  @samp{-z} 
@samp{--numstat} が指定されている場合、パス名を変更せずに、NULで終了する機械可読形式を使用します。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、「異常な」文字を含むパス名がクォートされます(git-config(1) 参照)。

@item  @samp{-p<n>} 
<n>個の先頭のパスコンポーネント(スラッシュで区切られている)を従来のdiffパスから削除します。 たとえば、 @samp{-p2} を使用すると、 @samp{a/dir/file} に対するパッチが @samp{file} に直接適用されます。 デフォルトは1です。

@item  @samp{-C<n>} 
各変更の前後で、周囲のコンテキストの少なくとも<n>行が一致することを確認してください。 周囲のコンテキストの行が少ない場合、それらはすべて一致する必要があります。 デフォルトでは、コンテキストが無視されることはありません。

@item  @samp{--unidiff-zero} 
デフォルトでは、 @samp{git apply} は、適用されるパッチが少なくとも1行のコンテキストを持つ統一された差分(unified diff)であることを想定しています。 これは優れた安全索を提供しますが、 @samp{--unified=0} で生成されたdiffを適用すると機能しなくなります。 これらのチェックをバイパスするには、 @samp{--unidiff-zero} を使用します。

注意: 上記の理由により、文脈自由パッチ(context-free patches)の使用は推奨されないことに注意してください。

@item  @samp{--apply} 
上記の「※applyはオフです(適用操作しません)」と記されたされたオプションのいずれかを使用すると、 @samp{git apply} は、実際にパッチを適用せずに、要求された情報を読み取って出力します。 これらのフラグの後にこのフラグを付けると、パッチも適用します。

@item  @samp{--no-add} 
パッチを適用するときは、パッチによる追加を無視してください。 これを使用して、最初に @samp{diff} を実行し、このオプションを使用して結果を適用することにより、2つのファイル間の共通部分を抽出できます。これにより、削除部分は適用されますが、追加部分は適用されません。

@item  @samp{--allow-binary-replacement} 
@itemx  @samp{--binary} 
Gitの歴史上、ユーザーからの明示的な許可なしにバイナリパッチを適用することは許可されていませんでした。このフラグは、そのための方法でした。 現在、バイナリパッチの適用は常に許可されているため、これは何の操作も行いません(no-op)。

@item  @samp{--exclude=<path-pattern>} 
与えられたパスパターンに一致するファイルに変更を適用しないでください。 これは、特定のファイルまたはディレクトリを除外するパッチセットをインポートするときに役立ちます。

@item  @samp{--include=<path-pattern>} 
与えられたパスパターンに一致するファイルに変更を適用します。 これは、特定のファイルまたはディレクトリを含めるパッチセットをインポートするときに役立ちます。

@samp{--exclude} および @samp{--include} パターンが使用される場合、それらはコマンドラインに表示される順序で検査され、最初の一致によって各パスへのパッチが使用されるかどうかが決定されます。 どの include/exclude パターンにも一致しないパスへのパッチは、コマンドラインに include パターンがない場合は既定で使用され、includeパターンがある場合は無視されます。

@item  @samp{--ignore-space-change} 
@itemx  @samp{--ignore-whitespace} 
パッチを適用するときは、必要に応じてコンテキスト行の空白(whitespace)の変更を無視してください。 コンテキスト行は空白を保持し、@samp{--whitespace} オプションの値に関係なく空白が修正されることはありません。 ただし、追加行はこのオプションに関わらず引き続き修正されます。

@item  @samp{--whitespace=<action>} 
パッチを適用するときは、空白エラー(whitespace errors)のある新しい行または変更された行を検出してください。 何を空白エラーと見なすのかは、 @samp{core.whitespace} 構成で制御します。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。

デフォルトでは、コマンドは警告メッセージを出力しますが、パッチを適用します。 @samp{git-apply} が統計に使用され、パッチを適用しない場合、デフォルトで @samp{nowarn} になります。

さまざまな @samp{<action>} 値を使用して、この振る舞いを制御できます:

@itemize 

@item
@samp{nowarn} は、末尾の空白の警告をオフにします。

@item
@samp{warn} は、そのようないくつかのエラーに対する警告を出力しますが、パッチはそのまま適用します(デフォルト)。

@item
@samp{fix} outputs warnings for a few such errors, and applies the patch after fixing them (@samp{strip} is a synonym — the tool used to consider only trailing whitespace characters as errors, and the fix involved @emph{stripping} them, but modern Gits do more).

@item
@samp{error} は、そのようないくつかのエラーに対する警告を出力し、パッチの適用を拒否します。

@item
@samp{error-all} は @samp{error} に似ていますが、すべてのエラーを表示します。
@end itemize

@item  @samp{--inaccurate-eof} 
特定の状況下では、 @samp{diff} の一部のバージョンは、ファイルの最後で欠落している改行を正しく検出しません。 その結果、そのような @samp{diff} プログラムによって作成されたパッチは、不完全な行を正しく記録しません。 このオプションは、このバグを回避することにより、そのようなパッチを適用するためのサポートを追加します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
進捗状況をstderrに報告します。 デフォルトでは、現在適用されているパッチに関するメッセージのみが出力されます。 このオプションを使用すると、追加情報が報告されます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
stderr 出力を抑制します。 パッチのステータスや進行状況に関するメッセージは出力されません。

@item  @samp{--recount} 
ハンクヘッダーの行数を信頼せず、パッチを調べて推測してください。 (たとえば、ハンクヘッダーを適切に調整せずにパッチを編集した後。)

@item  @samp{--directory=<root>} 
すべてのファイル名の前に <root> を付けます。 @samp{-p} 引数も渡された場合、 新しい <root> を前に付ける前に適用されます。

たとえば、 @samp{a/git-gui.sh} を @samp{b/git-gui.sh} に更新することについて説明しているパッチを作業ツリー @samp{modules/git-gui/git-gui.sh のファイルに適用できます。 `git apply --directory=modules/git-gui} を実行します。

@item  @samp{--unsafe-paths} 
デフォルトでは、作業領域(Git制御の作業ツリー、または @samp{git apply} がGNUパッチの代わりに使用される場合の現在の作業ディレクトリ)の外側に影響を与えるパッチは、間違い(またはいたずら)として拒否されます。

@samp{git apply} が「より良いGNUパッチ」として使用される場合、ユーザーは @samp{--unsafe-paths} オプションを渡してこの安全性チェックをオーバーライドできます。 @samp{--index} または @samp{--cached} が使用されている場合、このオプションは効果がありません。

@item  @samp{--allow-empty} 
diff を含まないパッチに対してエラーを返さないでください。 空のパッチやコミット・テキストのみのパッチもこの対象になります。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  apply.ignoreWhitespace 
@samp{change} に設定すると、 @samp{--ignore-space-change} オプションと同じように、空白の変更を無視するように @samp{git apply} に指示します。 @samp{no}, @samp{none}, @samp{never}, @samp{false} のいずれかに設定すると、すべての空白の違いを尊重するように @samp{git apply} に指示されます。 git-apply(1) を参照してください。

@item  apply.whitespace 
@samp{--whitespace} オプションと同じ方法で、 @samp{git apply} に空白の処理方法を指示します。 git-apply(1) を参照してください。
@end table

@noindent

@chapheading SUBMODULES

パッチにサブモジュールへの変更が含まれている場合、 @samp{git apply} はこれらの変更を以下のように扱います。

@samp{--index} が(明示的または暗黙的に)指定されている場合、パッチを適用するには、サブモジュールのコミットがインデックスと正確に一致する必要があります。 サブモジュールのいずれかがチェックアウトされている場合、これらのチェックアウトは完全に無視されます。つまり、サブモジュールは最新またはクリーンである必要はなく、更新されません。

@samp{--index} が指定されていない場合、パッチ内のサブモジュールのコミットは無視され、対応するサブディレクトリの有無のみがチェックされ、(可能であれば)更新されます。

@noindent

@chapheading SEE ALSO

git-am(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-archimport,,,Top
@chapheading Name

git-archimport — GNU Arch リポジトリをGitにインポートします

@noindent

@chapheading Synopsis

@display
git archimport [-h] [-v] [-o] [-a] [-f] [-T] [-D <depth>] [-t <tempdir>]
               <archive>/<branch>[:<git-branch>]…
@end display


@noindent

@chapheading DESCRIPTION

1つ以上の GNU Arch リポジトリからプロジェクトをインポートします。これは、提供された <archive>/<branch> パラメーターによって定義された名前空間内のブランチとリポジトリに従います。リモートブランチが見つからない場合は、マージ元から通常のコミットとしてインポートされます。見つかった場合は、可能な限りマージとしてマークします(以下の説明を参照)。

スクリプトは、 @samp{initial import} または @samp{tag} 型のArchコミットからインポートを開始できるキールート(key root)を提供することを想定しています。提供されたルート(root)内の新しいブランチを追跡してインポートします。

1つのプロジェクトのみを扱うことを想定しています。ルート(root)が異なるブランチを検出した場合、実行を拒否します。その場合は、 <archive>/<branch> パラメータを編集して、インポートの範囲を明確に定義します。

@samp{git archimport} は、バックグラウンドで @samp{tla} を広範囲に使用して、Archリポジトリにアクセスします。パス上に利用可能な @samp{tla} の最新バージョンがあることを確認してください。 @samp{tla} は、 @samp{git archimport} に渡すリポジトリについて知っている必要があります。

最初のインポートでは、 @samp{git archimport} は空のディレクトリに自分自身を見つけることをf期待しています。 Archを使用するプロジェクトの開発を追跡するには、最初のインポートと同じパラメーターを使用して「git archimport」を再実行し、増分インポートを実行します。

@samp{git archimport} は、インポートするアーカイブに適切なブランチ名を作成しようとしますが、Gitブランチ名を手動で指定することもできます。これを行うには、各 <archive>/<branch> パラメーターの後にコロン(@samp{:})で区切ってGitブランチ名を記述します。このようにして、Archブランチ名を短縮し、Arch専門用語をGit専門用語に変換できます。たとえば、「PROJECT--devo--VERSION」ブランチを「master」にマッピングします。

複数のArchブランチを1つのGitブランチに関連付けることができます。 結果は、2番目のブランチが作成された後、最初のブランチに対してコミットが行われない場合にのみ最も意味があります。それでも、これは定期的にローテーションされたArchリポジトリを変換するのに役立ちます。

@noindent

@chapheading MERGES

Archからのパッチマージデータは、Gitでのマージをマークするためにも使用されます。 Gitはパッチの追跡についてはあまり気にせず、分岐した時点以降、ブランチにすべてのコミットが組み込まれている場合にのみマージを考慮します。最終的な結果として、Gitはブランチがどこまで分岐したかを把握できます。したがって、インポートプロセスでは、パッチ取引のメタデータが失われます。

幸い、Archからインポートされたブランチをマージしようとすると、Gitは適切なマージベースを見つけ、ブランチ間で順番どおりにトレードされていないパッチを特定できる可能性が高くなります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-h} 
使い方表示。

@item  @samp{-v} 
詳細な出力。

@item  @samp{-T} 
多くのタグ。Archリポジトリのコミット名を反映して、すべてのコミットにタグを作成します。

@item  @samp{-f} 
高速パッチセットインポート戦略(fast patchset import strategy)を使用します。これは、大きなツリーでは大幅に高速化できますが、ディレクトリの名前変更やアクセス許可の変更を処理できません。デフォルトの戦略は遅いけど安全(slow and safe)です。

@item  @samp{-o} 
これは、以前のバージョンの「git archimport」で使用されていた古いスタイルのブランチ名との互換性のために使用します。古いスタイルのブランチ名は category--branch でしたが、新しいスタイルのブランチ名は category--branch--version です。 どちらの場合も、コマンドラインで指定された名前が自動生成された名前を上書きします。

@item  @samp{-D <depth>} 
マージの祖先に従い、マージされたツリーのインポートを試みます。パッチログが剪定されている場合は、1より大きい深さを指定します。

@item  @samp{-a} 
@samp{http://mirrors.sourcecontrol.net} でアーカイブを自動登録してみてください。これは、 @samp{-D} オプションを使用すると特に便利です。

@item  @samp{-t <tmpdir>} 
デフォルトのtempdirをオーバーライドします。

@item  <archive>/<branch> 
@samp{tla log} が理解できる形式の <archive>/<branch> ID。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-archive,,,Top
@chapheading Name

git-archive — 名前付きツリーからファイルのアーカイブを作成します

@noindent

@chapheading Synopsis

@display
git archive [--format=<fmt>] [--list] [--prefix=<prefix>/] [<extra>]
              [-o <file> | --output=<file>] [--worktree-attributes]
              [--remote=<repo> [--exec=<git-upload-archive>]] <tree-ish>
              [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

名前付きツリーのツリー構造を含む指定された形式のアーカイブを作成し、それを標準出力に書き込みます。 <prefix> が指定されている場合、アーカイブ内のファイル名の前に追加されます。

「git archive」は、ツリーIDを指定した場合と、コミットIDまたはタグIDを指定した場合の動作が異なります。ツリーIDを指定した場合は、現在の時刻がアーカイブ内の各ファイルの変更時刻として使用されます。コミットIDまたはタグIDを指定した場合、参照されたコミットオブジェクトに記録されたコミット時間が代わりに使用されます。さらに、tar形式が使用されている場合、コミットIDはグローバル拡張paxヘッダー(global extended pax header)に格納されます。 @samp{git get-tar-commit-id} を使用して抽出できます。ZIPファイルでは、ファイルコメントとして保存されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--format=<fmt>} 
結果のアーカイブの形式を指定します。 可能な値は、 @samp{tar} と @samp{zip} と @samp{tar.gz} と @samp{tgz} と、構成オプション @samp{tar.<format>.command} を使用して定義された任意の形式です。 @samp{--format} が指定されておらず、出力ファイルが指定されている場合、フォーマットは、可能であればファイル名から推測されます(たとえば、 @samp{foo.zip} に書き込むと、出力は @samp{zip} 形式になります)。 それ以外の場合、出力形式は @samp{tar} です。

@item  @samp{-l} 
@itemx  @samp{--list} 
有効なすべての形式を表示します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
進捗状況をstderrに報告します。

@item  @samp{--prefix=<prefix>/} 
@samp{<prefix>/} をアーカイブ内のパスに追加します。 繰り返すことができ、その右端(rightmost)の値が、すべての追跡ファイル(tracked files)で使用されます。 @samp{--add-file} と @samp{--add-virtual-file} で使用される値については下記参照。

@item  @samp{-o <file>} 
@itemx  @samp{--output=<file>} 
アーカイブをstdoutではなく<file>に書き込みます。

@item  @samp{--add-file=<file>} 
追跡されていないファイルをアーカイブに追加します。 繰り返すことで複数のファイルを追加する事ができます。 そのファイルのアーカイブ内のパスは、 この @samp{--add-file} の前の最後の @samp{--prefix} オプション (存在する場合) の値と <file> のベース名を連結することによって構築されます。

@item  @samp{--add-virtual-file=<path>:<content>} 
指定されたコンテンツをアーカイブに追加します。 複数のファイルを追加するために繰り返すことができます。 ファイルのアーカイブ内のパスは、 この @samp{--add-virtual-file} の前の最後の @samp{--prefix} オプション (存在する場合) の値と @samp{<path>} を連結することによって構築されます。

@samp{<path>} 引数は二重引用符文字(@samp{"})で囲む事ができます。その場合含まれるファイル名は C スタイルの文字列として解釈されます。つまり、バックスラッシュはエスケープ文字として解釈されます。 パスにコロン(@samp{:})が含まれている場合、またはパスが二重引用符文字(@samp{"})で開始または終了する場合、コロンがパスとコンテンツの間の区切り記号として誤って解釈されないように、パスをクォートする必要があります。

ファイル・モードは通常のファイル(regular file)に制限されており、オプションはプラットフォームに依存するコマンド・ラインの制限を受ける場合があります。 重要なケースでは、未追跡ファイル(untracked file)を作成し、代わりに @samp{--add-file} を使用します。

@item  @samp{--worktree-attributes} 
作業ツリーの .gitattributes ファイルでも属性を探します( @ref{ATTRIBUTES} 参照)。

@item  @samp{--mtime=<time>} 
Set modification time of archive entries. Without this option the committer time is used if @samp{<tree-ish>} is a commit or tag, and the current time if it is a tree.

@item  <extra> 
これは、アーカイババックエンドが理解できる任意のオプションです。次のセクションを参照してください。

@item  @samp{--remote=<repo>} 
ローカルリポジトリからtarアーカイブを作成する代わりに、リモートリポジトリからtarアーカイブを取得します。リモートリポジトリは、 @samp{<tree-ish>} で許可されるsha1式に制限を課す場合があることに注意してください。詳細については、 git-upload-archive(1) を参照してください。

@item  @samp{--exec=<git-upload-archive>} 
@samp{--remote} とともに使用して、リモート側の「git-upload-archive」へのパスを指定します。

@item  <tree-ish> 
アーカイブを作成するためのツリーまたはコミット。

@item  <path> 
オプションのパスパラメータがない場合、現在の作業ディレクトリのすべてのファイルとサブディレクトリがアーカイブに含まれます。1つ以上のパスが指定されている場合、それらのみが含まれます。
@end table

@noindent

@chapheading BACKEND EXTRA OPTIONS

@noindent

@heading zip

@table @asis

@item  @samp{-<digit>} 
圧縮レベルを指定します。 値が大きいほど、コマンドはより小さいサイズに圧縮するためにより多くの時間を費やすことができます。 サポートされている値は @samp{-0} (格納のみ) から @samp{-9} (最良の比率) までです。 指定しない場合のデフォルトは @samp{-6} です。
@end table

@noindent

@heading tar

@table @asis

@item  @samp{-<number>} 
圧縮レベルを指定します。 この値は、 @samp{tar.<format>.command} で設定された圧縮コマンドに渡されます。 サポートされているレベルのリストと、このオプションが指定されていない場合のデフォルトのレベルについては、構成コマンド(configured command)のマニュアル・ページを参照してください。
@end table

@noindent

@chapheading CONFIGURATION

@table @asis

@item  tar.umask 
この変数は、tarアーカイブエントリの許可ビットを制限するために使用できます。 デフォルトは 0002 で、ワールド書き込みビットをオフにします。特別な値「user」は、代わりにアーカイブユーザーのumaskが使用されることを示します。詳細については、 umask(2) を参照してください。 @samp{--remote} が使用されている場合、リモートリポジトリの設定のみが有効になります。

@item  tar.<format>.command 
この変数は、 @samp{git archive} によって生成されたtar出力をパイプするシェルコマンドを指定します。コマンドは、標準入力から生成されたtarファイル取り込み、シェルを使用して実行され、標準出力に最終出力を生成する必要があります。圧縮レベルのオプションはすべてコマンドに渡されます(例: @samp{-9} )。

@samp{tar.gz} および @samp{tgz} 形式は自動的に定義され、デフォルトで魔法の(magic)コマンド @samp{git archive gzip} を使用します。これにより、 gzip の内部実装が呼び出されます。

@item  tar.<format>.remote 
trueの場合、 git-upload-archive(1) を介してリモートクライアントで使用できるように @samp{<format>} を有効にします。 ユーザー定義形式の場合、デフォルトは false ですが、 @samp{tar.gz} および @samp{tgz} 形式の場合は true です。
@end table

@noindent

@chapheading ATTRIBUTES

@table @asis

@item  export-ignore 
属性export-ignoreを持つファイルとディレクトリは、アーカイブファイルに追加されません。 詳細については、 gitattributes(5) を参照してください。

@item  export-subst 
属性export-substがファイルに設定されている場合、Gitはこのファイルをアーカイブに追加するときにいくつかのプレースホルダーを展開します。詳細については、 gitattributes(5) を参照してください。
@end table

注意: デフォルトでは、属性はアーカイブされているツリーの @samp{.gitattributes} ファイルから取得されることに注意してください。事後に出力が生成される方法を微調整したい場合(たとえば、 @samp{.gitattributes} に適切な export-ignore を追加せずにコミットした場合)、必要に応じてチェックアウトされた @samp{.gitattributes} ファイルを調整して @samp{--worktree-attributes} オプションを使用します。 または、 @samp{$GIT_DIR/info/attributes} ファイルに、ツリーをアーカイブするときに適用する必要のある属性を保持することもできます。

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)} 
現在のブランチの最新のコミットの内容を含むtarアーカイブを作成し、それを @samp{/var/tmp/junk} ディレクトリに抽出します。

@item  @samp{git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz} 
これは、 v1.4.0リリース用の圧縮tarballを作成します。

@item  @samp{git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz} 
これは、上記と同じですが、組み込みのtar.gz処理を使用します。

@item  @samp{git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0} 
これは上記と同じですが、形式は出力ファイル名から推測されます。

@item  @samp{git archive --format=tar --prefix=git-1.4.0/ v1.4.0^@{tree@} | gzip >git-1.4.0.tar.gz} 
v1.4.0リリース用の圧縮tarballを作成しますが、グローバル拡張paxヘッダー(global extended pax header)はありません。

@item  @samp{git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip} 
現在のヘッド のDocumentation/ ディレクトリにあるすべてのものを「git-1.4.0-docs.zip」にプレフィックス「git-docs/」を付けて配置します。

@item  @samp{git archive -o latest.zip HEAD} 
現在のブランチの最新のコミットの内容を含むZipアーカイブを作成します。出力形式は、出力ファイルの拡張子によって推測されることに注意してください。

@item  @samp{git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD} 
プレフィックス無しの現在のブランチの最新のコミットのコンテンツと、プレフィックス @samp{build/} 付きの未追跡ファイル @samp{configure} を含む tar アーカイブを作成します。

@item  @samp{git config tar.tar.xz.command "xz -c"} 
LZMA圧縮tarファイルを作成するための「tar.xz」形式を構成します。 @samp{--format=tar.xz} を指定するか、 @samp{-o foo.tar.xz} のような出力ファイルを作成することで使用できます。
@end table

@noindent

@chapheading SEE ALSO

gitattributes(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-bisect,,,Top
@chapheading Name

git-bisect — 二分木検索を使用して、バグを引き起こしたコミットを見つけます

@noindent

@chapheading Synopsis

@display
git bisect <subcommand> <options>
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、さまざまなサブコマンドと、サブコマンドに応じて異なるオプションを取ります:

@example
git bisect start [--term-@{new,bad@}=<term> --term-@{old,good@}=<term>]
                 [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...]
git bisect (bad|new|<term-new>) [<rev>]
git bisect (good|old|<term-old>) [<rev>...]
git bisect terms [--term-good | --term-bad]
git bisect skip [(<rev>|<range>)...]
git bisect reset [<commit>]
git bisect (visualize|view)
git bisect replay <logfile>
git bisect log
git bisect run <cmd>...
git bisect help
@end example

このコマンドは、二分木検索アルゴリズムを使用して、プロジェクトの履歴のどのコミットでバグが発生したかを検出します。 最初に、バグが含まれていることがわかっている「bad」コミットと、バグが発生する前にあることがわかっている「good」コミットを伝えることで使用します。 次に、 @samp{git bisect} は、これら2つのエンドポイントの中間のコミットを選択し、選択したコミットが「good」か「bad」かを尋ねます。 変更を導入した正確なコミットが見つかるまで、範囲を絞り込み続けます。

実際、 @samp{git bisect} を使用して、プロジェクトの @strong{任意の} プロパティを変更したコミットを見つけることができます。 例：バグを修正したコミット、またはベンチマークのパフォーマンスを向上させたコミット。 このより一般的な使用法をサポートするために、「good」と「bad」の代わりに「old」と「new」という用語(terms)を使用することも、独自の用語(terms)を選択することもできます。 詳細については、以下の「Alternate terms」(代替用語)のセクションを参照してください。

@noindent

@heading Basic bisect commands: start, bad, good

例として、プロジェクトのバージョン @samp{v2.6.13-rc2} では動作することがわかっている機能を壊したコミットを見つけようとしているとします。以下のようにbisectセッションを開始します:

@example
$ git bisect start
$ git bisect bad                 # Current version is bad
$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good
@end example


少なくとも1つのbadコミットと1つのgoodコミットを指定すると、 @samp{git bisect} はその範囲の履歴の真ん中でコミットを選択し、それをチェックアウトして、以下のようなものを出力します(訳注:テスト対象残り675リビジョン(ざっくり10ステップ)):

@example
Bisecting: 675 revisions left to test after this (roughly 10 steps)
@end example


あなたはチェックアウトしたバージョンをコンパイルしてテストする必要があります。 もし、そのバージョンが正しく機能する場合は、次のように入力します

@example
$ git bisect good
@end example


もし、そのバージョンが壊れている場合は、以下のように入力します

@example
$ git bisect bad
@end example


そうすると、 @samp{git bisect} は以下のように応答します

@example
Bisecting: 337 revisions left to test after this (roughly 9 steps)
@end example


このプロセスを繰り返します: ツリーをコンパイルしてテストし、それがgoodかbadかに応じて、 @samp{git bisect good} または @samp{git bisect bad} を実行して、テストが必要な次のコミットを要求します。

最終的には、検査するリビジョンがなくなり、コマンドは最初の不正なコミットの説明を出力します。 参照 @samp{refs/bisect/bad} は、そのコミットを指したままになります。

@noindent

@heading Bisect reset

bisectセッションの後、bisect状態をクリーンアップして元のHEADに戻すには、以下のコマンドを発行します:

@example
$ git bisect reset
@end example


デフォルトでは、これにより、あなたのツリーは @samp{git bisect start} の前にチェックアウトされたコミットに戻ります。 (新しく行う @samp{git bisect start} も、古いbisect状態をクリーンアップするため、これを実行します。)

オプションの引数を使用すると、代わりに異なるコミットに戻ることができます:

@example
$ git bisect reset <commit>
@end example


たとえば、 @samp{git bisect reset bisect/bad} は最初のbadリビジョンをチェックアウトしますが、 @samp{git bisect reset HEAD} は現在のbisectコミットのままにし、コミットの切り替えを完全に回避します。

@noindent

@heading Alternate terms(代替用語)

破損を引き起こしたコミットではなく、他の「old」状態と「new」状態の間で変化を引き起こしたコミットを探している場合があります。 たとえば、特定の修正を導入したコミットを探している場合があります。 または、ソースコードのファイル名がすべて最終的に会社の命名基準に変換された最初のコミットを探しているかもしれません。その他何でもありです。

このような場合、「変更前の状態」と「変更後の状態」を指すのに「good」と「bad」という用語(terms)を使用することは非常に混乱する可能性があります。 したがって、「good」と「bad」の代わりに、それぞれ「old」と「new」という用語を使用できます。 (ただし、単一のセッション内で「good」と「bad」を「old」と「new」と混在させることはできないことに注意してください。)

このより一般的な使用法では、 @samp{git bisect} に、いくつかのプロパティを持つ「new」コミットと、そのプロパティを持たない「old」コミットを提供します。 @samp{git bisect} がコミットをチェックアウトするたびに、そのコミットにそのプロパティがあるかどうかをテストします。 含まれている場合は、コミットを「new」としてマークします。 それ以外の場合は、「old」とマークします。 bisectが行われると、 @samp{git bisect} はどのコミットがそのプロパティを導入したかを報告します。

「good」と「bad」の代わりに「old」と「new」を使用するには、引数としてcommitを指定せずに @samp{git bisect start} を実行してから、以下のコマンドを実行してコミットを追加する必要があります:

@example
git bisect old [<rev>]
@end example


これは、コミットが求められた変更の前であったことを知らせるためで、あるいは、

@example
git bisect new [<rev>...]
@end example


これはコミットが求められた変更より新しい事を知らせます。

現在使用している用語(terms)を思い出したいときは、以下を入力します。

@example
git bisect terms
@end example


old(または new)の用語(term)は、 @samp{git bisect terms --term-old} または @samp{git bisect terms --term-good} で取得できます。

bad/good または new/old の代わりに独自の用語(terms)を使用する場合は、以下を使用してbisectを開始することにより、(@samp{reset} 、@samp{start} などの既存のbisectサブコマンドを除く)任意の名前を選択できます

@example
git bisect start --term-old <term-old> --term-new <term-new>
@end example


たとえば、あなたがパフォーマンスの低下をもたらすコミットを探している場合は、以下のように使用できます

@example
git bisect start --term-old fast --term-new slow
@end example


または、あなたがバグを修正したコミットを探している場合は、以下のようにします

@example
git bisect start --term-new fixed --term-old broken
@end example


次に、コミットをマークするために、 @samp{git bisect good} や @samp{git bisect bad} の代わりに、 @samp{git bisect <term-old>} や @samp{git bisect <term-new>} を使用します。

@noindent

@heading Bisect visualize/view

@samp{gitk} に現在残っている容疑者(suspects)を確認するには、bisectプロセス中に以下のコマンドを発行します(サブコマンド @samp{view} は @samp{visualize} の代わりに使用できます):

@example
$ git bisect visualize
@end example


@samp{DISPLAY} 環境変数が設定されていない場合、代わりに @samp{git log} が使用されます。 @samp{-p} や @samp{--stat} などのコマンドラインオプションを指定することもできます。

@example
$ git bisect visualize --stat
@end example


@noindent

@heading Bisect log and bisect replay

リビジョンをgoodまたはbadとマークした後、以下のコマンドを発行して、これまでに行われたことを表示します:

@example
$ git bisect log
@end example


リビジョンのステータスの指定を間違えたのを見つけた場合は、このコマンドの出力をファイルに保存し、それを編集して誤ったエントリを削除してから、以下のコマンドを発行して修正された状態に戻すことができます:

@example
$ git bisect reset
$ git bisect replay that-file
@end example


@noindent

@heading Avoiding testing a commit

bisectセッションの途中で、提案されたリビジョンがテストに適していないことがわかっている場合(たとえば、ビルドに失敗し、その失敗が追跡しているバグとは何の関係もないことがわかっている場合)、その近くのコミットを手動で選択し、代わりにそれをテストできます。

例えば:

@example
$ git bisect good/bad                   # previous round was good or bad.
Bisecting: 337 revisions left to test after this (roughly 9 steps)
$ git bisect visualize                  # oops, that is uninteresting.
$ git reset --hard HEAD~3               # try 3 revisions before what
                                        # was suggested
@end example


次に、選択したリビジョンをコンパイルしてテストし、その後、通常の方法でリビジョンにgoodまたはbadのマークを付けます。

@noindent

@heading Bisect skip

自分で近くのコミットを選択する代わりに、コマンドを発行してGitにそれを実行するように依頼できます:

@example
$ git bisect skip                 # Current version cannot be tested
@end example


しかしながら、探しているコミットに隣接するコミットをスキップすると、Gitはそれらのコミットのどれが最初のbadコミットであったかを正確に知ることができなくなります。

範囲表記を使用して、1つのコミットだけでなく、範囲のコミットをスキップすることもできます。 例えば以下のようにします:

@example
$ git bisect skip v2.5..v2.6
@end example


これは、@samp{v2.5} 以降の @samp{v2.6} までのコミットをテストしてはならないことをbisectプロセスに伝えます。

注意: 範囲の最初のコミットもスキップする場合は、以下のコマンドを発行することに注意してください:

@example
$ git bisect skip v2.5 v2.5..v2.6
@end example


これは、@samp{v2.5} と @samp{v2.6} (の両端を含む) の間のコミットをスキップする必要があることをbisectプロセスに通知します。

@noindent

@heading bisect startでより多くのパラメータを与えて探索量削減

あなたが追跡している問題にツリーのどの部分が関係しているかがわかっている場合は、 @samp{bisect start} コマンドを発行するときにパスパラメータを指定することで、試行回数をさらに減らすことができます:

@example
$ git bisect start -- arch/i386 include/asm-i386
@end example


複数の適切なコミットが事前にわかっている場合は、 @samp{bisect start} コマンドを発行するときに、badコミットの直後にすべてのgoodコミットを指定することで、bisect量を絞り込むことができます:

@example
$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --
                   # v2.6.20-rc6 is bad
                   # v2.6.20-rc4 and v2.6.20-rc1 are good
@end example


@noindent

@heading Bisect run

現在のソースコードがgoodかbadかを判断できるスクリプトがある場合は、以下のコマンドを発行してbisectすることができます:

@example
$ git bisect run my_script arguments
@end example


注意: スクリプト(上記例では @samp{my_script})は、現在のソースコードが good/old ならばコード0で終了し、現在のソースコードが bad/new の場合はコードは125を除く1〜127で終了します。

その他の終了コードは、bisectプロセスを中止します。 @samp{exit(-1)} を介して終了するプログラムは $?= 255 を残すことに注意してください。 (exit(3)のマニュアルページ参照)。 値は @samp{& 0377} でマスクされます。

現在のソースコードをテストできない場合は、特別な終了コード125を使用する必要があります。 スクリプトがこのコードで終了する場合、現在のリビジョンはスキップされます(上記「git bisect skip」参照)。 126と127はPOSIXシェルによって特定のエラーステータスを通知するために使用されるため、125がこの目的で使用する最も適切な値として選択されました(127は、コマンドが見つかりません で、 126は コマンドが見つかりましたが実行可能ではありません です。 — これらの詳細は、 @samp{bisect run} に関する限り、スクリプトの通常のエラーであるため、重要ではありません)。

bisectセッション中に、テスト対象のリビジョンに一時的な変更を加えたい場合がよくあります(例: ヘッダーファイルで @samp{s/#define DEBUG 0/#define DEBUG 1/} 、または「このコミットがないリビジョンでは、このbisectが関心を持たない別の問題を解決するために、このパッチを適用する必要があります」)。

このような状況に対処するために、「git bisect」内部でテストする次のリビジョンを見つけた後、スクリプトはコンパイル前にパッチを適用し、実際のテストを実行し、その後、リビジョン(おそらく必要なパッチを含む)が合格したかどうかを判断できます。 テストしてから、ツリーを元の状態に巻き戻します。 最後に、スクリプトは実際のテストのステータスで終了し、 @samp{git bisect run} コマンドループがbisectセッションの最終的な結果を決定できるようにする必要があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--no-checkout} 
bisectプロセスの各反復で新しい作業ツリーをチェックアウトしないでください。 代わりに、 @samp{BISECT_HEAD} という名前の特別な参照を更新して、テストする必要のあるコミットを指すようにします。

このオプションは、各ステップで実行するテストで、チェックアウトされたツリーが必要ない場合に役立つことがあります。

ベアリポジトリの場合、 @samp{--no-checkout} が想定されます。

@item  @samp{--first-parent} 
マージコミットを確認したら、最初の親コミットのみを実行します。

ブランチのマージによって導入されたデグレを検出する際に、マージコミットはバグの導入として識別され、その祖先は無視されます。

このオプションは、マージされたブランチに壊れたコミットまたはビルドできないコミットが含まれているが、マージ自体はOKな場合に誤検知を回避するのに特に役立ちます。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
v1.2とHEADの間で壊れたビルドを自動的にbisectします:

@example
$ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good
$ git bisect run make                # "make" builds the app
$ git bisect reset                   # quit the bisect session
@end example


@item
originとHEADの間のテスト失敗を自動的にbisectします:

@example
$ git bisect start HEAD origin --    # HEAD is bad, origin is good
$ git bisect run make test           # "make test" builds and tests
$ git bisect reset                   # quit the bisect session
@end example


@item
壊れたテストケースを自動的にbisectします:

@example
$ cat ~/test.sh
#!/bin/sh
make || exit 125                     # this skips broken builds
~/check_test_case.sh                 # does the test case pass?
$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
$ git bisect run ~/test.sh
$ git bisect reset                   # quit the bisect session
@end example


ここでは、 @samp{test.sh} カスタムスクリプトを使用します。 このスクリプトでは、 @samp{make} が失敗した場合、現在のコミットをスキップします。 @samp{check_test_case.sh} は、テストケースが合格した場合は @samp{exit 0} であり、そうでない場合は @samp{exit 1} である必要があります。

@samp{test.sh} と @samp{check_test_case.sh} の両方がリポジトリの外にある場合は、bisectプロセスとmakeプロセスとtestプロセスとスクリプトの間の相互作用を防ぐ方が安全です。

@item
一時的な変更(ホットフィックス)で自動的にbisectします:

@example
$ cat ~/test.sh
#!/bin/sh

# tweak the working tree by merging the hot-fix branch
# and then attempt a build
if      git merge --no-commit --no-ff hot-fix &&
        make
then
        # run project specific test and report its status
        ~/check_test_case.sh
        status=$?
else
        # tell the caller this is untestable
        status=125
fi

# undo the tweak to allow clean flipping to the next commit
git reset --hard

# return control
exit $status
@end example


これにより、各テスト実行の前にホットフィックスブランチからの変更が適用されます。 例えば、ビルドやテスト環境が変わり、古いリビジョンではすでに修正されているものが、新しいリビジョンでは修正が必要になる可能性があるからです。（ホットフィックスブランチが、bisectしているすべてのリビジョンに含まれているコミットに基づいていることを確認して、マージがあまり引き込まれないようにするか、 @samp{git merge} の代わりに @samp{git cherry-pick} を使用します。)

@item
壊れたテストケースを自動的にbisectします:

@example
$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
$ git bisect run sh -c "make || exit 125; ~/check_test_case.sh"
$ git bisect reset                   # quit the bisect session
@end example


これは、テストを1行で記述した場合、実行スクリプトなしで実行できることを示しています。

@item
破損したリポジトリでオブジェクトグラフの適切な領域を見つけます

@example
$ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout
$ git bisect run sh -c '
        GOOD=$(git for-each-ref "--format=%(objectname)" refs/bisect/good-*) &&
        git rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&
        git pack-objects --stdout >/dev/null <tmp.$$
        rc=$?
        rm -f tmp.$$
        test $rc = 0'

$ git bisect reset                   # quit the bisect session
@end example


この場合、「git bisect run」が終了すると、 bisect/bad は、到達可能なグラフが「git pack objects」で必要な意味で完全にトラバース可能な親が少なくとも1つあるコミットを参照します。

@item
コードでデグレの代わりに修正を探します

@example
$ git bisect start
$ git bisect new HEAD    # current commit is marked as new
$ git bisect old HEAD~10 # the tenth commit from now is marked as old
@end example


または:
@end itemize

@example
$ git bisect start --term-old broken --term-new fixed
$ git bisect fixed
$ git bisect broken HEAD~10
@end example


@noindent

@heading Getting help

@samp{git bisect} を使用して短い使用法の説明を取得し、 @samp{gitbisect help} または @samp{git bisect -h} を使用して長い使用法の説明を取得します。

@noindent

@chapheading SEE ALSO

@uref{git-bisect-lk2009.html,Fighting regressions with git bisect}, git-blame(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-blame,,,Top
@chapheading Name

git-blame — ファイルの各行を最後に変更したリビジョンと作者を表示する

@noindent

@chapheading Synopsis

@display
git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]
            [-L <range>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<date>]
            [--ignore-rev <rev>] [--ignore-revs-file <file>]
            [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]
            [ --contents <file> ] [<rev> | --reverse <rev>..<rev>] [--] <file>
@end display


@noindent

@chapheading DESCRIPTION

指定のファイルの各行で、その行を最後に変更したリビジョンからの情報を注釈します。 オプションで、指定のリビジョンから注釈を開始します。

@samp{-L} は注釈を指定行に制限します。複数回指定できます。

行の原初は、ファイル自体の名前変更にまたがって自動的に追跡されます(現在のところ、名前変更追跡をオフにするオプションはありません)。 あるファイルから別のファイルに移動した行を追跡したり、別のファイルからコピーして貼り付けた行を追跡したりするには、 @samp{-C} および @samp{-M} オプションを参照してください。

レポートには、削除または置換された行については何も表示されません。 以下の段落で簡単に説明する @samp{git diff} や @samp{pickaxe} インターフェースなどのツールを使用する必要があります。

Gitは、ファイル注釈のサポートとは別に、変更時にコード断片(code snippet)が発生したときの開発履歴の検索もサポートしています。 これにより、コード断片がファイルに追加され、ファイル間で移動またはコピーされ、最終的に削除または置換された時期を追跡できます。 これは、diffでテキスト文字列を検索することで機能します。 @samp{blame_usage} を検索するpickaxeインターフェースの小さな例:

@example
$ git log --pretty=oneline -S'blame_usage'
5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <ancestry-file>
ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output
@end example


@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-b} 
境界コミットでは空白のSHA-1を表示します。これは、 @samp{blame.blankBoundary} 構成オプションを介して制御することもできます。

@item  @samp{--root} 
ルートコミットを境界として扱わないでください。 これは、 @samp{blame.showRoot} 構成オプションを介して制御することもできます。

@item  @samp{--show-stats} 
blameの出力の最後に追加の統計を含めます。

@item  @samp{-L <start>,<end>} 
@itemx  @samp{-L :<funcname>} 
@samp{<start>,<end>} で指定の行範囲のみ、または正規表現関数名 @samp{<funcname>} で指定の行範囲のみに注釈を付けます。複数回指定できます。範囲が重複するのは許されます。

@samp{<start>} と @samp{<end>} はオプションです。 @samp{-L <start>} または @samp{-L <start>,} は @samp{<start>} からファイルの終わりまでの範囲です。 @samp{-L ,<end>} は、ファイルの先頭から @samp{<end>} までの範囲です。

<start> と <end> は、以下のいずれかの形式です:

@itemize 

@item
数値

<start> または <end> が数値の場合、絶対行番号を指定します(行は1から数えます)。

@item
@samp{/regex/}

この形式は、指定されたPOSIX正規表現に一致する最初の行を使用します。 <start> が正規表現の場合、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 <start> が @samp{^/regex/} の場合、ファイルの先頭から検索します。 <end> が正規表現の場合、 <start> で指定された行から検索開始します。

@item
+offset or -offset

これは <end> に対してのみ有効であり、 <start> で指定された行の前後の行数を指定します。
@end itemize

<start> と <end> の代わりに @samp{:<funcname>} が指定されている場合、これは <funcname> に一致する最初の関数名行から次の関数名行までの範囲を示す正規表現です。 @samp{:<funcname>} は、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 @samp{^:<funcname>} はファイルの先頭から検索します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{-l} 
長いレビジョンを表示します(デフォルト: off)。

@item  @samp{-t} 
生のタイムスタンプを表示します(デフフォルト: off)。

@item  @samp{-S <revs-file>} 
git-rev-list(1) を呼び出す代わりに、revs-fileのリビジョンを使用します。

@item  @samp{--reverse <rev>..<rev>} 
履歴を後方へではなく前方へウォークします。行があらわれたされたリビジョンを表示する代わりに、行が存在した最後のリビジョンを表示します。これには、START..END のように、STARTにblameのパスが存在するレビジョン範囲が必要です。 便宜上、 @samp{git blame --reverse START} は @samp{git blame --reverse START..HEAD} と見なされます。

@item  @samp{--first-parent} 
マージコミットを確認したら、最初の親コミットのみを追跡します。 このオプションは、履歴全体にいつ導入されたかではなく、特定の統合ブランチにいつ導入されたかを判別するために使用できます。

@item  @samp{-p} 
@itemx  @samp{--porcelain} 
ソフトウェア等で使用するのに適した形式で表示します。

@item  @samp{--line-porcelain} 
磁器形式で表示しますが、コミットが最初に参照されたときだけでなく、各行のコミット情報を出力します。 --porcelain の機能を含んでいます。

@item  @samp{--incremental} 
ソフトウェア等で使用するのに適した形式で結果を段階的(incrementally)に表示します。

@item  @samp{--encoding=<encoding>} 
作者名(author names)の出力と要約のコミットに使用されるエンコーディングを指定します。 これを @samp{none} に設定すると、blame出力は変換されていないデータになります。詳細については、 git-log(1) のマニュアルページにある discussion の encoding に関する説明を参照してください。

@item  @samp{--contents <file>} 
Annotate using the contents from the named file, starting from <rev> if it is specified, and HEAD otherwise. You may specify @emph{-} to make the command read from the standard input for the file contents.

@item  @samp{--date <format>} 
日付の出力に使用される形式を指定します。 --date が指定されていない場合、blame.date 構成変数の値が使用されます。 blame.date 構成変数も設定されていない場合は、 iso形式が使用されます。サポートされている値については、 git-log(1) の --date オプションの説明を参照してください。

@item  @samp{--[no-]progress} 
進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、端末に接続されていない場合でも進行状況のレポートを有効にします。 @samp{--progress} を @samp{--porcelain} または @samp{--incremental} と一緒に使用することはできません。

@item  @samp{-M[<num>]} 
ファイル内の移動またはコピーされた行を検出します。コミットが行のブロックを移動またはコピーすると(たとえば、元のファイルにA、次にBがあり、コミットによってB、次にAに変更される)、従来の「blame」アルゴリズムは移動の半分だけに気づき、通常は行をblameします それは親に上に移動され(つまりB)、子のコミットに下に移動された(つまりA)行にblameを割り当てます。このオプションを使用すると、追加の検査パスを実行することにより、両方のグループの行が親のせいになります。

<num> はオプションですが、Gitがそれらの行を親コミットに関連付けるためにファイル内で移動/コピーとして検出する必要がある英数字の数(number of alphanumeric characters)の下限です。デフォルト値は20です。

@item  @samp{-C[<num>]} 
@samp{-M} に加えて、同じコミットで変更された他のファイルから移動またはコピーされた行を検出します。これは、プログラムを再編成し、ファイル間でコードを移動するときに役立ちます。このオプションを2回指定すると、コマンドは、ファイルを作成するコミットで他のファイルからのコピーを追加で検索します。このオプションを3回指定すると、コマンドはコミットで他のファイルからのコピーを追加で検索します。

<num> はオプションですが、Gitがそれらの行を親コミットに関連付けるためにファイル間の移動/コピーとして検出する必要がある英数字の数(number of alphanumeric characters)の下限です。また、デフォルト値は40です。複数の @samp{-C} オプションが指定されている場合、最後の @samp{-C} の <num> 引数が有効になります。

@item  @samp{--ignore-rev <rev>} 
変更が発生しなかったかのように、blameを割り当てるときにリビジョンによって行われた変更を無視します。無視されたコミットによって変更または追加された行は、その行または近くの行を変更した前のコミットのせいになります。このオプションは、複数のリビジョンを無視するために複数回指定できます。 @samp{blame.markIgnoredLines} 構成オプションが設定されている場合、無視されたコミットによって変更され、別のコミットに起因する行は、blame出力で @samp{?} でマークされます。 @samp{blame.markUnblamableLines} 構成オプションが設定されている場合、別のリビジョンに帰することができなかった無視されたコミットによって触れられた行は、 @samp{*} でマークされます。

@item  @samp{--ignore-revs-file <file>} 
@samp{file} にリストされているリビジョンを無視します。これは @samp{fsck.skipList} と同じ形式である必要があります。このオプションは繰り返すことができ、これらのファイルは、 @samp{blame.ignoreRevsFile} 構成オプションで指定されたファイルの後に処理されます。空のファイル名 @samp{""} は、以前に処理されたファイルからrevsのリストをクリアします。

@item  @samp{--color-lines} 
前行と同一のコミットからの場合、デフォルト形式の行注釈に異なる色を付けます。 これにより、異なるコミットによって導入されたコード・ブロックを区別しやすくなります。 色のデフォルトはシアン(cyan)で、 @samp{color.blame.repeatedLines} 設定オプションを使用して調整できます。

@item  @samp{--color-by-age} 
デフォルトの形式では、行の経過時間に応じて行の注釈に色を付けます。 @samp{color.blame.highlightRecent} 構成オプションは、年齢の各範囲で使用される色を制御します。

@item  @samp{-h} 
ヘルプメッセージを表示する。

@item  @samp{-c} 
git-annotate(1) と同じ出力モードを使用します(デフォルト: オフ)。

@item  @samp{--score-debug} 
ファイル間の行の移動(@samp{-C} 参照)およびファイル内で移動された行(@samp{-M} 参照)に関連するデバッグ情報を含めます。 リストされている最初の数字はスコアです。 これは、ファイル間またはファイル内で移動を検出した英数字の数です。これらのコード行が移動されたと見なすには、 これが @samp{git blame} の特定のしきい値を超えている必要があります。

@item  @samp{-f} 
@itemx  @samp{--show-name} 
元のコミットのファイル名を表示します。 デフォルトでは、名前変更の検出により、別の名前のファイルからの行がある場合はファイル名が表示されます。

@item  @samp{-n} 
@itemx  @samp{--show-number} 
元のコミットの行番号を表示します(デフォルト: オフ)。

@item  @samp{-s} 
作者名とタイムスタンプの出力を抑制します。

@item  @samp{-e} 
@itemx  @samp{--show-email} 
作者名の代わりに作者の電子メールアドレス(author email)を表示します(デフォルト: オフ)。 これは、 @samp{blame.showEmail} 構成オプションを介して制御することもできます。

@item  @samp{-w} 
親のバージョンと子のバージョンを比較して、その行がどこから来たのかを見つけるときは、空白(whitespace)を無視します。

@item  @samp{--abbrev=<n>} 
デフォルトの7+1桁の16進数でオブジェクト名を省略する代わりに、<m>+1桁を使用します。ここで<m>は少なくとも<n>ですが、コミットオブジェクト名が一意になるような長さにします。 1列分はコミットの境界を示すカレット(@samp{^})に使用されることに注意してください。
@end table

@noindent

@chapheading THE DEFAULT FORMAT

@samp{--porcelain} オプションも @samp{--incremental} オプションも指定されていない場合、@samp{git Blame} は各行の注釈を以下のとおり出力します:

@itemize 

@item
行の元となったコミットのオブジェクトの省略名

@item
作者ID (@samp{-s} または @samp{-e} が指定されていない限り、デフォルトでは作者名と日付)

@item
行番号
@end itemize

上記を行の内容の前に表示します。

@noindent

@chapheading THE PORCELAIN FORMAT(磁器形式)

この形式では、各行はヘッダーの後に出力されます。 少なくともヘッダーには、以下のような最初の行があります:

@itemize 

@item
その行が属するコミットの40バイトのSHA-1;

@item
元のファイルの行の行番号;

@item
最終ファイルの行の行番号;

@item
前のコミットとは異なるコミットからの行のグループを開始する行においては、そのグループの行数。以降の行では、このフィールドはありません。
@end itemize

このヘッダー行の後には、コミットごとに少なくとも1回は以下の情報が続きます:

@itemize 

@item
author name ("author") と email ("author-mail") と time ("author-time") と time zone ("author-tz"); コミッターも同様。

@item
その行が属するコミット内のファイル名。

@item
コミットログメッセージの最初の行("summary")。
@end itemize

実際の行の内容は、上記のヘッダーの後にTABが前に付いて出力されます。 これは、後でヘッダー要素を追加できるようにするためです。

磁器形式(porcelain format)は、一般的に、既視のコミット情報を抑制します。 たとえば、同じコミットのせいにされた2行が両方とも表示されますが、そのコミットの詳細は1回だけ表示されます。これはより効率的ですが、リーダーがより多くの状態を保持する必要がある場合があります。 @samp{--line-porcelain} オプションを使用すると、各行の完全なコミット情報を出力できるため、以下のように単純な(ただし効率の低い)使用法が可能になります:

@example
# count the number of lines attributed to each author
git blame --line-porcelain file |
sed -n 's/^author //p' |
sort | uniq -c | sort -rn
@end example

@noindent

@chapheading SPECIFYING RANGES

古いバージョンのgitの @samp{git blame} や @samp{git annotate} と異なり、注釈の範囲は行範囲とリビジョン範囲の両方で制限できます。注釈を行の範囲に制限する @samp{-L} オプションは、複数回指定できます。

あなたがファイル @samp{foo} の40〜60行目の行の原初を見つけることに関心がある場合は、以下のように @samp{-L} オプションを使用できます(2行とも同じ意味です。どちらも40行目から21行を要求します):

@example
git blame -L 40,60 foo
git blame -L 40,+21 foo
@end example

また、正規表現を使用して行範囲を指定することもできます:

@example
git blame -L '/^sub hello @{/,/^@}$/' foo
@end example

これは、注釈を @samp{hello} サブルーチンの本体に制限します。

あなたがバージョンv2.6.18より古い変更、または3週間より古い変更に関心がない場合は、 @samp{git rev-list} のようにリビジョン範囲指定子を使用できます:

@example
git blame v2.6.18.. -- foo
git blame --since=3.weeks -- foo
@end example

リビジョン範囲指定子を使用して注釈を制限すると、範囲境界以降に変更されていない行(上記の例で、コミットv2.6.18 または 3週間以上経過した最新のコミットのいずれか)は、その範囲境界のコミットのblameになります。

特に便利な方法は、追加されたファイルに、既存のファイルからコピペして作成された行があるかどうかを確認することです。 これは、開発者がだらしなく、コードを適切にリファクタリングしなかったことを示している場合があります。 最初に、ファイルを導入したコミットを以下のように見つけることができます:

@example
git log --diff-filter=A --pretty=short -- foo
@end example

次に、 @samp{commit^!} 表記を使用して、コミットとその親の間の変更に注釈を付けます:

@example
git blame -C -C -f $commit^! -- foo
@end example

@noindent

@chapheading INCREMENTAL OUTPUT

@samp{--incremental} オプションを付けて呼び出すと、ビルドした結果を出力します。 出力は一般に、より新しいコミットによって触れられた行から順に語られます(つまり、行の注釈は順不同になります)。これは、対話的なビューアで使用するためのものです。

出力形式は磁器形式(Porcelain format)に似ていますが、注釈が付けられているファイルの実際の行は含まれていません。

@enumerate 

@item
各blame項目は必ず行で始まる:

@example
<40-byte hex sha1> <sourceline> <resultline> <num_lines>
@end example

行番号は1から数えます。

@item
コミットがストリームに初めて現れるとき、追加のコミット情報(作成者、電子メール、コミッター、日付、要約など)を説明する1語のタグが各行の先頭に出力されて、コミットに関するその他のさまざまな情報が出力されます。

@item
磁器形式(Porcelain format)とは異なり、ファイル名情報が常に与えられ、エントリを終了します:

@example
"filename" <whitespace-quoted-filename-goes-here>
@end example

したがって、一部の行指向および単語指向のパーサーの解析は非常に簡単です(ほとんどのスクリプト言語では非常に自然なはずです)。

@quotation

@strong{Note}

構文解析を行う人の場合: より堅牢にするために、拡張情報行(extended information lines)の先頭にあるタグワード(またはその特定のものを気にする)を認識できない最初の行と最後の行の間の行(@samp{<sha1>} 行や @samp{filename} 行)はすべて無視してください。 そうすれば、(コミットエンコーディング(commit encoding)や拡張コミット解説(extended commit commentary)のような)情報が追加されたとしても、blameビュワーは気にしません。
@end quotation
@end enumerate

@noindent

@chapheading MAPPING AUTHORS

gitmailmap(5) を参照してください。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  blame.blankBoundary 
git-blame(1)で境界コミット(boundary commits)の空白コミットオブジェクト名を表示します。このオプションのデフォルトはfalseです。

@item  blame.coloring 
これにより、blame出力に適用される配色が決まります。 これは、 @samp{repeatedLines} または @samp{highlightRecent} またはデフォルトの @samp{none} にすることができます。

@item  blame.date 
git-blame(1) で日付を出力するために使用される形式を指定します。 設定を解除すると、iso形式が使用されます。 サポートされている値については、 git-log(1) の @samp{--date} オプションの説明を参照してください。

@item  blame.showEmail 
git-blame(1) で、作者名(author)の代わりに作者の電子メールアドレス(author email)を表示します。 このオプションのデフォルトはfalseです。

@item  blame.showRoot 
git-blame(1) ではルートコミットを境界として扱わないでください。 このオプションのデフォルトはfalseです。

@item  blame.ignoreRevsFile 
git-blame(1) で、ファイルにリストされているリビジョン(1行に1つの省略されていないオブジェクト名)を無視します。 @samp{#} で始まる空白とコメントは無視されます。 このオプションは複数回繰り返すことができます。 空のファイル名は、無視されたリビジョンのリストをリセットします。 このオプションは、コマンドラインオプション @samp{--ignore-revs-file} の前に処理されます。

@item  blame.markUnblamableLines 
git-blame(1)の出力で @samp{*} を使用して、別のコミットに帰することができなかった、無視されたリビジョンによって変更された行をマークします。

@item  blame.markIgnoredLines 
git-blame(1)の出力で、別のコミットに起因する無視されたリビジョンによって変更された行を @samp{?} でマークします。
@end table

@noindent

@chapheading SEE ALSO

git-annotate(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-branch,,,Top
@chapheading Name

git-branch — ブランチを、一覧表示または作成または削除します

@noindent

@chapheading Synopsis

@display
git branch [--color[=<when>] | --no-color] [--show-current]
        [-v [--abbrev=<n> | --no-abbrev]]
        [--column[=<options>] | --no-column] [--sort=<key>]
        [--merged [<commit>]] [--no-merged [<commit>]]
        [--contains [<commit>]] [--no-contains [<commit>]]
        [--points-at <object>] [--format=<format>]
        [(-r | --remotes) | (-a | --all)]
        [--list] [<pattern>…]
git branch [--track[=(direct|inherit)] | --no-track] [-f]
        [--recurse-submodules] <branchname> [<start-point>]
git branch (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]
git branch --unset-upstream [<branchname>]
git branch (-m | -M) [<oldbranch>] <newbranch>
git branch (-c | -C) [<oldbranch>] <newbranch>
git branch (-d | -D) [-r] <branchname>…
git branch --edit-description [<branchname>]
@end display


@noindent

@chapheading DESCRIPTION

@samp{--list} が指定されている場合、またはオプション以外の引数がない場合は、既存のブランチが一覧表示されます。 現在のブランチは緑色(green)で強調表示され、アスタリスク(@samp{*})でマークされます。 リンクされたワークツリーでチェックアウトされたブランチは、シアン(cyan)で強調表示され、プラス記号(@samp{+})でマークされます。 オプション @samp{-r} を指定すると、リモート追跡ブランチが一覧表示され、オプション @samp{-a} はローカルブランチとリモートブランチの両方を表示します。

@samp{<pattern>} が指定されている場合、出力を、マッチするブランチに制限するためのシェルワイルドカードとして使用されます。 複数のパターンが指定されている場合、いずれかのパターンに一致するとブランチが表示されます。

@samp{<pattern>} を提供するときは、 @samp{--list} を使用する必要があることに注意してください。 そうしないと、コマンドがブランチの作成として解釈される可能性があります。

@samp{--contains} を使用すると、名前付きコミットを含むブランチ(つまり、先端コミットが名前付きコミットの子孫であるブランチ)のみが表示され、 @samp{--no-contains} はそれを反転します。 @samp{--merged} を使用すると、指定されたコミットにマージされたブランチ(つまり、指定されたコミットから先端コミットに到達できるブランチ)のみが一覧表示されます。 @samp{--no-merged} を使用すると、指定されたコミットにマージされていないブランチのみが一覧表示されます。 <commit> 引数が欠落している場合、デフォルトで @samp{HEAD} (つまり、現在のブランチの先端)になります。

コマンドの2番目の形式は、現在の @samp{HEAD} 、または、指定されている場合は <start-point> を指す <branchname> という名前の新しいブランチヘッドを作成します。 特殊なケースとして、 <start-point> について、マージベースが1つしかない場合は、@samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 最大で @samp{A} と @samp{B} のいずれかを省略できます。その場合、デフォルトで @samp{HEAD} になります。

注意: これにより新しいブランチが作成されますが、作業ツリーはそれに切り替わりません。 @samp{git switch <newbranch>} を使用して、新しいブランチに切り替えます。

ローカルブランチがリモート追跡ブランチから開始されると、Gitはブランチ(具体的には @samp{branch.<name>.remote} と @samp{branch.<name>.merge} の構成エントリ)をセットアップし、 @samp{git pull} でリモート追跡ブランチから適切にマージするようにします。 この動作は、グローバルな @samp{branch.autoSetupMerge} 構成フラグを介して変更できます。 この設定は、 @samp{--track} および @samp{--no-track} オプションを使用してオーバーライドでき、後で @samp{git branch --set-upstream-to} を使用して変更できます。

@samp{-m} または @samp{-M} オプションを使用すると、 <oldbranch> の名前を <newbranch> に名前変更します。 <oldbranch> に対応するreflogがある場合は、 <newbranch> に一致するように名前変更され、ブランチの名前変更を記憶するためにreflogエントリが作成されます。 <newbranch> が存在する場合は、 @samp{-M} を使用して名前の変更を強制する必要があります。

@samp{-c} および @samp{-C} オプションは、 @samp{-m} および @samp{-M} とまったく同一の意図(semantics)ですが、ブランチの名前が変更される代わりに、configおよびreflogとともに新しい名前にコピーされます。

@samp{-d} または @samp{-D} オプションを使用すると、 @samp{<branchname>} が削除されます。 削除するブランチを複数指定できます。 現在、ブランチがreflogを持っている場合、reflogも削除されます。

@samp{-r} を @samp{-d} と一緒に使用して、リモート追跡ブランチを削除します。 リモート追跡ブランチを削除するのは、リモートリポジトリに存在しなくなった場合、または @samp{git fetch} が再度フェッチしないように構成されている場合にのみ意味があることに注意してください。 廃止されたすべてのリモート追跡ブランチをクリーンアップする方法については、 git-remote(1) の「prune」サブコマンドも参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-d} 
@itemx  @samp{--delete} 
ブランチを削除します。 ブランチは、アップストリームブランチで完全にマージする必要があります。アップストリームが @samp{--track} または @samp{--set-upstream-to} で設定されていない場合は、@samp{HEAD} でマージする必要があります。

@item  @samp{-D} 
@samp{--delete --force} のショートカットです。

@item  @samp{--create-reflog} 
ブランチのreflogを作成します。 これにより、ブランチrefに加えられたすべての変更の記録がアクティブになり、 @samp{<branchname>@@\@{yesterday@}} などの日付ベースのsha1式を使用できるようになります。 非ベアリポジトリでは、通常、reflogはデフォルトで @samp{core.logAllRefUpdates} 設定オプションによって有効になっていることに注意してください。 否定形式 @samp{--no-create-reflog} は、それ以前の @samp{--create-reflog} をオーバーライドするだけですが、現在のところ @samp{core.logAllRefUpdates} の設定を否定しません。

@item  @samp{-f} 
@itemx  @samp{--force} 
Reset <branchname> to <start-point>, even if <branchname> exists already. Without @samp{-f}, @emph{git branch} refuses to change an existing branch. In combination with @samp{-d} (or @samp{--delete}), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with @samp{-m} (or @samp{--move}), allow renaming the branch even if the new branch name already exists, the same applies for @samp{-c} (or @samp{--copy}).

Note that @emph{git branch -f <branchname> [<start-point>]}, even with @emph{-f}, refuses to change an existing branch @samp{<branchname>} that is checked out in another worktree linked to the same repository.

@item  @samp{-m} 
@itemx  @samp{--move} 
ブランチを、その構成や reflog とともに 移動/名前変更 します。

@item  @samp{-M} 
@samp{--move --force} のショートカットです。

@item  @samp{-c} 
@itemx  @samp{--copy} 
ブランチを、その構成や reflog とともにコピーします。

@item  @samp{-C} 
@samp{--copy --force} のショートカットです。

@item  @samp{--color[=<when>]} 
現在のブランチと、ローカルブランチと、リモート追跡ブランチを強調表示するためにブランチに色を付けます。値は always (デフォルト) または never または auto でなければなりません。

@item  @samp{--no-color} 
構成ファイルでデフォルトのカラー出力が指定されている場合でも、ブランチの色付けをオフにします。 @samp{--color=never} と同じです。

@item  @samp{-i} 
@itemx  @samp{--ignore-case} 
ブランチの並べ替えとフィルタリングでは英大文字小文字を区別しません(case insensitive)。

@item  @samp{--omit-empty} 
Do not print a newline after formatted refs where the format expands to the empty string.

@item  @samp{--column[=<options>]} 
@itemx  @samp{--no-column} 
ブランチの一覧表示を複数列に表示します。 オプションの構文については、構成変数 @samp{column.branch} を参照してください。 オプションのない @samp{--column} と @samp{--no-column} は、それぞれ @samp{always} と @samp{never} と同等です。

このオプションは、非おしゃべりモード(non-verbose mode)でのみ適用できます。

@item  @samp{-r} 
@itemx  @samp{--remotes} 
リモートトラッキングブランチを一覧表示または削除(@samp{-d} とともに使用する場合)します。 オプションのパターンに一致するように @samp{--list} と組み合わせます。

@item  @samp{-a} 
@itemx  @samp{--all} 
リモートトラッキングブランチとローカルブランチの両方を一覧表示します。 @samp{--list} と組み合わせて、オプションのパターンにマッチさせます。

@item  @samp{-l} 
@itemx  @samp{--list} 
ブランチを一覧表示します。 オプションの`<pattern>…@samp{を使用します。 例: `git branch --list 'maint-*'} パターンにマッチするブランチのみをリストします。

@item  @samp{--show-current} 
現在のブランチの名前を出力します。 HEADを切り離した(detached HEAD)状態では、何も出力されません。

@item  @samp{-v} 
@itemx  @samp{-vv} 
@itemx  @samp{--verbose} 
リストモード(list mode)の場合は、sha1を表示し、各ヘッドの件名と、(存在する場合、)アップストリームブランチとの関係をコミットします。 2回指定した場合は、リンクされたワークツリーのパス(存在する場合)とアップストリームブランチの名前も出力します(@samp{git remote show <remote>} も参照)。 現在のワークツリーのHEADにはパスが出力されないことに注意してください(常に現在のディレクトリになります)。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
エラー以外のメッセージを抑制して、ブランチを作成または削除するときはもっと静かにしてください。

@item  @samp{--abbrev=<n>} 
コミットオブジェクト名を示す詳細リストで、オブジェクトを一意に参照する、少なくとも16進数 @emph{<n>} 桁の長さの最短のプレフィックスを表示します。 デフォルト値は 7 で、 @samp{core.abbrev} 構成オプションでオーバーライドできます。

@item  @samp{--no-abbrev} 
省略せずに、出力リストに完全なsha1を表示します。

@item  @samp{-t} 
@itemx  @samp{--track[=(direct|inherit)]} 
新しいブランチを作成するときは、 @samp{branch.<name>.remote} および @samp{branch.<name>.merge} 構成エントリをセットアップして、新しいブランチの「上流」追跡構成(upstream tracking configuration)を設定します。 この構成は、 @samp{git status} と @samp{git branch -v} で、2つのブランチの間の関係を表示するようにgitに指示します。 さらに、引数なしで @samp{git pull} に、新しいブランチがチェックアウトされたときに上流(upstream)からプルするように指示します。

オプションの引数に応じて、正確な上流(upstream)ブランチが選択されます。 @samp{-t} または @samp{--track} または @samp{--track=direct} は、起点(start-point)ブランチ自体を上流として使用することを意味します。 `--track=inherit｀ は、起点ブランチの上流構成(upstream configuration)をコピーすることを意味します。

branch.autoSetupMerge 構成変数は、@samp{--track} も @samp{--no-track} も指定されていない場合に、 @samp{git switch} や @samp{git checkout} や @samp{git branch} がどのように振る舞うかを指定します:

デフォルトのオプション @samp{true} は、起点(start-point)がリモート追跡ブランチである場合はいつでも @samp{--track=direct} が指定されたかのように振る舞います。 @samp{false} は、@samp{--no-track} が指定されたかのように振る舞います。 @samp{always} は、@samp{--track=direct} が指定されたかのように振る舞います。 @samp{inherit} は @samp{--track=inherit} が与えられたかのように振る舞います。 @samp{simple} は、起点がリモート追跡ブランチであり、新しいブランチがリモート・ブランチと同じ名前を持つ場合にのみ、 @samp{--track=direct} が指定されたかのように振る舞います。

@samp{branch.<name>.remote} および @samp{branch.<name>.merge} オプションの使用方法に関する追加の説明については、 git-pull(1) および git-config(1) を参照してください。

@item  @samp{--no-track} 
branch.autoSetupMerge構成変数がセットされている場合でも、「upstream」構成をセットアップしないでください。

@item  @samp{--recurse-submodules} 
このオプションは実験的機能です! @samp{submodule.propagateBranches} が有効になっている場合、現在のコマンドをサブモジュール内でも再帰させます。 git-config(1) の @samp{submodule.propagateBranches} を参照してください。 現在、ブランチの作成のみがサポートされています。

ブランチの作成で使用すると、新しいブランチ <branchname> がスーパープロジェクトに作成され、すべてのサブモジュールがスーパープロジェクトの <start-point> に作成されます。 サブモジュールでは、ブランチはスーパープロジェクトの <start-point> でサブモジュールのコミットを指しますが、ブランチの追跡情報はサブモジュールのブランチとremoteに基づいて設定されます。 例えば @samp{git branch --recurse-submodules topic origin/main} は、スーパープロジェクトの @samp{origin/main} 内のサブモジュール・コミットを指すサブモジュール・ブランチ @samp{topic} を作成しますが、サブモジュールの @samp{origin/main} を追跡します。

@item  @samp{--set-upstream} 
このオプションは構文がわかりにくいため、サポートされなくなりました。 代わりに @samp{--track} または @samp{--set-upstream-to} を使用してください。

@item  @samp{-u <upstream>} 
@itemx  @samp{--set-upstream-to=<upstream>} 
<branchname> の追跡情報を設定して、<upstream> が <branchname> のアップストリームブランチと見なされるようにします。 <branchname> が指定されていない場合、デフォルトで現在のブランチになります。

@item  @samp{--unset-upstream} 
<branchname> のアップストリーム情報を削除します。 ブランチが指定されていない場合、デフォルトで現在のブランチになります。

@item  @samp{--edit-description} 
エディタを開き、テキストを編集して、ブランチの目的を説明し、他のさまざまなコマンド(@samp{format-patch} 、` request-pull` 、 @samp{merge} (有効な場合) など)で使用できるようにします。 複数行の説明を使用できます。

@item  @samp{--contains [<commit>]} 
指定されたコミットを含むブランチのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{--no-contains [<commit>]} 
指定されたコミットを含まないブランチのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{--merged [<commit>]} 
指定されたコミットから先端に到達できるブランチのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{--no-merged [<commit>]} 
指定されたコミットから先端に到達できないブランチのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  <branchname> 
作成または削除するブランチの名前。 新しいブランチ名は、 git-check-ref-format(1) で定義されているすべてのチェックに合格する必要があります。 これらのチェックの一部は、ブランチ名で許可される文字を制限する場合があります。

@item  <start-point> 
新しいブランチヘッドはこのコミットを指します。 ブランチ名 または commit-id または タグ として指定できます。 このオプションを省略すると、代わりに現在のHEADが使用されます。

@item  <oldbranch> 
名前を変更する既存のブランチの名前。

@item  <newbranch> 
既存のブランチの新しい名前。 <branchname> と同じ制限が適用されます。

@item  @samp{--sort=<key>} 
指定されたキーに基づいて並べ替えます。 プレフィックス @samp{-} を使用して、値の降順で並べ替えます。 @samp{--sort=<key>} オプションを複数回使用できます。その場合、最後のキーが主キーになります。 サポートされているキーは、 @samp{gitfor-each-ref} のキーと同じです。 ソート順は、デフォルトで、 @samp{branch.sort} 変数が存在する場合はその値に設定されているか、完全なrefname (@samp{refs/...} プレフィックスを含む)に基づいてソートされます。 これにより、切り離されたHEAD(detached HEAD)(存在する場合)が最初にリストされ、次にローカルブランチ、最後にリモート追跡ブランチがリストされます。 git-config(1) を参照してください。

@item  @samp{--points-at <object>} 
指定されたオブジェクトのブランチのみを一覧表示します。

@item  @samp{--format <format>} 
表示されているブランチrefとそれが指すオブジェクトを @samp{%(fieldname)} によって差し込みする書式文字列。 形式はgit-for-each-ref(1) の形式と同じです。
@end table

@noindent

@chapheading CONFIGURATION

@samp{pager.branch} は、ブランチを一覧表示する場合、 つまり @samp{--list} が使用または暗示されている場合にのみ尊重されます。 デフォルトでは、ページャーを使用します。 git-config(1) を参照してください。

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  branch.autoSetupMerge 
git-pull(1) が開始点ブランチから適切にマージされるように、 @samp{git branch} や @samp{git switch} や @samp{git checkout} に新しいブランチを設定するように指示します。 このオプションが設定されていない場合でも、この動作は、 @samp{--track} や @samp{--no-track} オプションを使用してブランチごとに選択できることに注意してください。 有効な設定は次のとおりです: @samp{false} — 自動セットアップは行われません。 @samp{true} — 開始点がリモート追跡ブランチの場合、自動セットアップが実行されます。 @samp{always} — 自動セットアップは、開始点がローカルブランチまたはリモート追跡ブランチのいずれかである場合に実行されます。 このオプションのデフォルトはtrueです。 @samp{inherit} — 開始点に追跡構成(tracking configuration)がある場合、それは新しいブランチにコピーされます。 @samp{simple} — 自動セットアップは、開始点がリモート追跡ブランチであり、新しいブランチがリモート・ブランチと同じ名前を持つ場合にのみ実行されます。 このオプションのデフォルトは true です。

@item  branch.autoSetupRebase 
別のブランチを追跡する @samp{git branch} または @samp{git switch} または @samp{git checkout} を使用して新しいブランチが作成されると、この変数はGitにマージではなくリベースするプルを設定するように指示します(@samp{branch.<name>.rebase} 参照)。 @samp{never} の場合、リベースが自動的にtrueに設定されることはありません。 @samp{local} の場合、他のローカルブランチの追跡されたブランチに対してリベースがtrueに設定されます。 @samp{remote} の場合、リモート追跡ブランチの追跡されたブランチに対してリベースがtrueに設定されます。 @samp{always} の場合、リベースはすべての追跡ブランチに対してtrueに設定されます。 別のブランチを追跡するためにブランチを設定する方法の詳細については、 @samp{branch.autoSetupMerge} を参照してください。 このオプションのデフォルトは @samp{never} です。

@item  branch.sort 
この変数は、 git-branch(1) によって表示されるときのブランチの並べ替え順序を制御します。 @samp{--sort=<value>} オプションが指定されていない場合、この変数の値がデフォルトとして使用されます。 有効な値については、 git-for-each-ref(1) のfield namesを参照してください。

@item  branch.<name>.remote 
ブランチ<name>にいる場合、フェッチ元/プッシュ先 のremoteを @samp{git fetch} と @samp{git push} に通知します。 プッシュ先のremoteは、 (全ブランチ用の) @samp{remote.pushDefault} でオーバーライドできます。 現在のブランチの場合、プッシュ先のremoteは、 @samp{branch.<name>.pushRemote} によってさらにオーバーライドされる可能性があります。 remoteが構成されていない場合、または、どのブランチにも属しておらずリポジトリに複数のremoteが定義されている場合、フェッチの場合は @samp{origin} に、プッシュの場合は @samp{remote.pushDefault} にデフォルト設定されます。 さらに、 @samp{.} (ピリオド)は現在のローカルリポジトリ(ドットリポジトリ)です。下記 @samp{branch.<name>.merge} の最後の注意を参照してください。

@item  branch.<name>.pushRemote 
ブランチ<name>にいる場合、プッシュするための @samp{branch.<name>.remote} をオーバーライドします。 また、ブランチ<name>からプッシュするための @samp{remote.pushDefault} をオーバーライドします。 ある場所(あなたのアップストリームなど)から別の場所(独自の公開リポジトリなど)にプッシュする場合は、 @samp{remote.pushDefault} を設定して、すべてのブランチにプッシュするリモートを指定し、そして、このオプションを使用して 特定のブランチに対してオーバーライドします。

@item  branch.<name>.merge 
branch.<name>.remote とともに、指定されたブランチのアップストリームブランチを定義します。 マージするブランチを @samp{git fetch}/@samp{git pull}/@samp{git rebase} に通知し、 @samp{git push} にも影響を与える可能性があります(push.default参照)。 ブランチ<name>にいる場合、FETCH_HEADでマージするためにマークされるデフォルトのrefspecを @samp{git fetch} に指示します。 値はrefspecのリモート部分のように処理され、 @samp{branch.<name>.remote ` で指定されたリモートからフェッチされたrefと一致する必要があります。 マージ情報は、マージのためにデフォルトのブランチを検索するために `git pull} (最初に @samp{git fetch} を呼び出します)によって使用されます。 このオプションがない場合、 @samp{git pull} はデフォルトで、フェッチされた最初のrefspecをマージします。 octopusマージを取得するには、複数値を指定します。 あなたがローカルリポジトリ内の別のブランチから<name>にマージされるように @samp{git pull} を設定したい場合は、branch.<name>.mergeが目的をブランチを指すようにして、そして、 branch.<name>.remote に相対パス設定 @samp{.} (ピリオド)を使用できます。

@item  branch.<name>.mergeOptions 
ブランチ<name>にマージするためのデフォルトオプションを設定します。 構文とサポートされているオプションは git-merge(1) のものと同じですが、空白文字を含むオプション値は現在サポートされていません。

@item  branch.<name>.rebase 
trueの場合、 @samp{git pull} の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチ<name>をリベースします。 ブランチ固有ではない方法でこれを行うには、 @samp{pull.rebase} を参照してください。

@samp{merges} (または単に @samp{m}) の場合、 @samp{--rebase-merges} オプションを @samp{git rebase} に渡して、ローカル・マージ・コミットがリベースに含まれるようにします (詳細については git-rebase(1) を参照してください)。

値が @samp{interactive} (または単に @samp{i})の場合、リベースは対話モードで実行されます。

@strong{注意}: これはおそらく危険な操作です。
あなたが影響を理解していない限り、使用しないでください
(詳細については、 git-rebase(1) を参照してください)。

@item  branch.<name>.description 
ブランチの説明は、 @samp{git branch --edit-description} で編集できます。 ブランチの説明は、format-patchのカバーレターまたはrequest-pullの概要に自動的に追加されます。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  Start development from a known tag 
@example
$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
$ cd my2.6
$ git branch my2.6.14 v2.6.14   (1)
$ git switch my2.6.14
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
このステップと次のステップは、 @samp{checkout -b my2.6.14 v2.6.14} を使用して1つのステップに組み合わせることができます。
@end table

@item  Delete an unneeded branch 
@example
$ git clone git://git.kernel.org/.../git.git my.git
$ cd my.git
$ git branch -d -r origin/todo origin/html origin/man   (1)
$ git branch -D test                                    (2)
@end example


@table @asis

@item @pxref{CO2-1,,(1)}
リモート追跡ブランチ「todo」と「html」と「man」を削除します。 この後の @samp{fetch} または @samp{pull} は、あなたが構成しないように構成しない限り、それらを再度作成します。 git-fetch(1) を参照してください。

@item @pxref{CO2-2,,(2)}
「master」ブランチ(または現在チェックアウトされているブランチ)にtestブランチからのすべてのコミットがない場合でも、「test」ブランチを削除します。
@end table

@item  Listing branches from a specific remote 
@example
$ git branch -r -l '<remote>/<pattern>'                 (1)
$ git for-each-ref 'refs/remotes/<remote>/<pattern>'    (2)
@end example


@table @asis

@item @pxref{CO3-1,,(1)}
@samp{-a} を使用すると、<remote>が、同じ<remote>パターンのプレフィックスが付いているローカルブランチと混同されます。

@item @pxref{CO3-2,,(2)}
@samp{for-each-ref} は幅広いオプションをとることができます。 git-for-each-ref(1) を参照してください
@end table
@end table

通常、パターンにはクォートが必要です。

@noindent

@chapheading NOTES

すぐに切り替えたいブランチを作成する場合は、 @samp{git switch} コマンドとその @samp{-c} オプションを使用して、1つのコマンドで同じことを行う方が簡単です。

オプション @samp{--contains} と ` --no-contains` と @samp{--merged} と @samp{--no-merged} は、4つの関連しているが異なる目的を果たします:

@itemize 

@item
@samp{--contains <commit>} は、<commit>がリベースまたは修正された場合に特別な注意が必要なすべてのブランチを検索するために使用されます。これらのブランチには、指定された<commit>が含まれているためです。

@item
@samp{--no-contains <commit>} はその逆です。つまり、指定された<commit>を含まないブランチです。

@item
@samp{--merged} は、安全に削除できるすべてのブランチを検索するために使用されます。これらのブランチはHEADに完全に含まれているためです。

@item
@samp{--no-merged} は、HEADにマージする候補となるブランチを見つけるために使用されます。これらのブランチは、HEADに完全には含まれていないためです。
@end itemize

複数の @samp{--contains} フィルターと @samp{--no-contains} フィルターを組み合わせる場合、少なくとも1つの @samp{--contains} コミットを含み、 @samp{--no-contains} コミットを含まない参照のみが表示されます。

複数の @samp{--merged} フィルターと @samp{--no-merged} フィルターを組み合わせると、少なくとも1つの @samp{--merged} コミットから到達可能で、 @samp{--no-merged} コミットのいずれからも到達できない参照のみが表示されます。

@noindent

@chapheading SEE ALSO

git-check-ref-format(1), git-fetch(1), git-remote(1), @uref{user-manual.html#what-is-a-branch,“Understanding history: What is a branch?”} in the Git User’s Manual.

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-bugreport,,,Top
@chapheading Name

git-bugreport — ユーザーがバグ報告を提出するための情報を収集する

@noindent

@chapheading Synopsis

@display
git bugreport [(-o | --output-directory) <path>] [(-s | --suffix) <format>]
                [--diagnose[=<mode>]]
@end display


@noindent

@chapheading DESCRIPTION

ユーザーのマシン、Gitクライアント、リポジトリの状態に関する情報、およびユーザーが観察した動作に関する情報の入力書式を(例えば、Gitメーリングリストに観察されたバグを報告するために)、ユーザーが共有できる単一のテキストファイルとして獲得します。

以下の情報がユーザーに要求されます:

@itemize 

@item
再現手順

@item
期待する動作

@item
実際の動作
@end itemize

以下の情報が自動的に収集されます:

@itemize 

@item
@emph{git version --build-options}

@item
uname sysname と release と version と machine strings

@item
コンパイラ指定情報文字列

@item
有効なフックのリスト

@item
$SHELL
@end itemize

追加情報は、 @samp{--diagnose} オプションを使用して別の zip アーカイブに収集することができ、読者に追加のコンテキストを提供するためにバグレポート・ドキュメントと一緒に添付できます。

このツールは、通常のGitセットアッププロセスを介して呼び出されます。つまり、関連する構成ファイルが読み取れない場合など、起動できない場合があります。 この種のシナリオでは、手動で助けを求めるときに、上記の種類の情報を手動で収集すると役立つ場合があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-o <path>} 
@itemx  @samp{--output-directory <path>} 
結果のバグレポートファイルを現在のディレクトリではなく @samp{<path>} に配置します。

@item  @samp{-s <format>} 
@itemx  @samp{--suffix <format>} 
バグレポート名の代替サフィックスを指定して、 @samp{git-bugreport-<formatted suffix>} という名前のファイルを作成します。 これは、 strftime(3) 形式の文字列の形式をとる必要があります。現在の現地時間が使用されます。

@item  @samp{--no-diagnose} 
@itemx  @samp{--diagnose[=<mode>]} 
ユーザーの、マシンとGitクライアントとリポジトリの状態に関する補足情報の zip アーカイブを作成します。 アーカイブはバグ・レポートと同じ出力ディレクトリに書き込まれ、 @samp{git-diagnostics-<formatted suffix>} という名前が付けられます。

@samp{mode} が指定されていない場合、診断アーカイブには @samp{git diagnostic} によって報告されるデフォルトの統計セットが含まれます。 オプションの @samp{mode} 値を指定して、アーカイブに含める情報を変更できます。 @samp{mode} の有効な値のリストとその使用方法の詳細については、git-diagnose(1) を参照してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-bundle,,,Top
@chapheading Name

git-bundle — アーカイブごとにオブジェクトとrefを移動します

@noindent

@chapheading Synopsis

@display
git bundle create [-q | --quiet | --progress]
                    [--version=<version>] <file> <git-rev-list-args>
git bundle verify [-q | --quiet] <file>
git bundle list-heads <file> [<refname>…]
git bundle unbundle [--progress] <file> [<refname>…]
@end display


@noindent

@chapheading DESCRIPTION

「bundle」ファイルを作成や解凍や操作します。 バンドルは、ネットワーク接続の反対側にアクティブな「サーバー」がない時に、Gitオブジェクトの「オフライン」転送に使用されます。

これらを使用して、リポジトリの増分(incremental)バックアップと完全(full)バックアップの両方を作成し、あるリポジトリ内の参照の状態を別のリポジトリに取り次ぐことができます。

@samp{ssh://} や @samp{https://} などのプロトコルを介してフェッチまたは「読み取り」するGitコマンドも、バンドルファイルを操作できます。 バンドルから新しいリポジトリを作成するために git-clone(1) を使うことができ、そして、バンドルからリポジトリを取得するために git-fetch(1) を使うことができ、そして、バンドルの中に含まれる参照を git-ls-remote(1) でリストすることが可能です。 対応する「書き込み」サポートはありません。 つまり、バンドルへの @samp{git push} はサポートされていません。

バンドルの使用方法例については、以下の「EXAMPLES」セクションを参照してください。

@noindent

@chapheading BUNDLE FORMAT

バンドルは @samp{.pack} ファイル(linkgit：git-pack-objects[1] 参照)であり、バンドル内に含まれる参照を示すヘッダーが付いています。

パックされたアーカイブ形式自体と同様に、バンドルは自己完結型にすることも、除外を使用して作成することもできます。 以下の「OBJECT PREREQUISITES」(オブジェクトの前提条件)セクションを参照してください。

リビジョンの除外を使用して作成されたバンドルは、 git-pack-objects(1) の @samp{--thin} オプションを使用して作成された「薄いパック」(thin packs)であり、 git-index-pack(1) の @samp{--fix-thin} オプションを使用してバンドル解除します。

リビジョンの除外を使用する場合、厚いパック(thick pack)を作成するオプションはありません。ユーザーは違いについて心配する必要はありません。 薄いパック(thin packs)を使用することにより、除外を使用して作成されたバンドルのサイズが小さくなります。 それらが内部で「薄い」(thin)ことは、ここでは単に好奇心として、そして他のドキュメントへの参照として示されています。

詳しくは gitformat-bundle(5) を、「thin pack」については gitformat-pack(5) をご覧ください。

@noindent

@chapheading OPTIONS

@table @asis

@item  create [options] <file> <git-rev-list-args> 
Used to create a bundle named @emph{file}. This requires the @emph{<git-rev-list-args>} arguments to define the bundle contents. @emph{options} contains the options specific to the @emph{git bundle create} subcommand. If @emph{file} is @samp{-}, the bundle is written to stdout.

@item  verify <file> 
Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, @emph{git bundle} prints a list of missing commits, if any. Finally, information about additional capabilities, such as "object filter", is printed. See "Capabilities" in gitformat-bundle(5) for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If @emph{file} is @samp{-}, the bundle is read from stdin.

@item  list-heads <file> 
Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out. If @emph{file} is @samp{-}, the bundle is read from stdin.

@item  unbundle <file> 
Passes the objects in the bundle to @emph{git index-pack} for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by @emph{git fetch}. If @emph{file} is @samp{-}, the bundle is read from stdin.

@item  <git-rev-list-args> 
@samp{git rev-parse} および @samp{git rev-list} に受け入れられる引数のリスト(および名前付きrefを含む。下記「SPECIFYING REFERENCES」参照)。これは、転送する特定のオブジェクトと参照を指定します。 たとえば、 @samp{master~10..master} を指定すると、現在のmaster参照が、10番目の祖先のコミット以降に追加されたすべてのオブジェクトとともにパッケージ化されます。 パッケージ化できる参照とオブジェクトの数に明示的な制限はありません。

@item  [<refname>…] 
利用可能として報告された参照を制限するために使用される参照のリスト。 これは主に @samp{git fetch} に役立ちます。これは、要求された参照のみを受け取り、必ずしもパック内のすべてを受け取るとは限りません(この場合、 @samp{git bundle} は @samp{git fetch-pack} のように機能します)。

@item  @samp{--progress} 
@samp{-q} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送られていない場合でも、進行状況を強制します。

@item  @samp{--version=<version>} 
バンドルのバージョンを指定します。 バージョン2 は古い形式であり、SHA-1リポジトリでのみ使用できます。 新しい バージョン3 には、拡張を許可する機能が含まれています。 デフォルトは、使用中のハッシュアルゴリズムに基づいて、サポートされている最も古い形式です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
このフラグにより、コマンドは標準エラーストリームで進行状況を報告しなくなります。
@end table

@noindent

@chapheading SPECIFYING REFERENCES

リビジョンは、バンドルにパッケージ化される参照名を伴う必要があります。

複数の参照をパッケージ化でき、複数の前提条件オブジェクトのセットを指定できます。 パッケージ化されたオブジェクトは、前提条件の結合に含まれていないオブジェクトです。

@samp{git bundle create} コマンドは、 @samp{git rev-parse --abbrev-ref=loose} と同じルールを使用して参照名を解決します。 各前提条件は、明示的に指定することも(例: @samp{^master~10})、暗黙的に指定することもできます(例: @samp{master~10..master}, @samp{--since=10.days.ago master})。

これらの単純なケースはすべてOKです(「master」ブランチと「next」ブランチがあると仮定します):

@example
$ git bundle create master.bundle master
$ echo master | git bundle create master.bundle --stdin
$ git bundle create master-and-next.bundle master next
$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin
@end example


そして、以下も同様です(上記と同一ですが @samp{--stdin} が省略された例です):

@example
$ git bundle create recent-master.bundle master~10..master
$ git bundle create recent-updates.bundle master~10..master next~5..next
@end example


リビジョン名や、右辺が参照に解決できない範囲は、受け付けられません:

@example
$ git bundle create HEAD.bundle $(git rev-parse HEAD)
fatal: Refusing to create empty bundle.
$ git bundle create master-yesterday.bundle master~10..master~5
fatal: Refusing to create empty bundle.
@end example


@noindent

@chapheading OBJECT PREREQUISITES

PREREQUISITES(前提条件);バンドルを作成する場合、共通の履歴のないリポジトリでバンドル解凍できる自己完結型のバンドルを作成できます。また、履歴の初期の部分で必要なオブジェクトを除外するための負のリビジョン(negative revisions)を提供することもできます。

@samp{new} などのリビジョンを @samp{git bundle create} にフィードすると、リビジョン @samp{new} から到達可能なすべてのオブジェクトを含むバンドルファイルが作成されます。 そのバンドルを任意のリポジトリでバンドル解凍して、リビジョン @samp{new} につながる完全な履歴を取得できます。

@example
$ git bundle create full.bundle new
@end example


@samp{old..new} のようなリビジョン範囲は、バンドルファイルを生成しますが、バンドルが「バンドル解除」可能(unbundle-able)であるためには、リビジョン @samp{old} (とそこから到達できるすべてのオブジェクト) が存在する必要があります:

@example
$ git bundle create full.bundle old..new
@end example


前提条件のない自己完結型のバンドルは、空のリポジトリにさえもどこにでも抽出できます。または、そのバンドルからcloneすることもできます(つまり、 @samp{new} ですが、 @samp{old..new} ではありません)。

注意: バンドルファイルには、宛先に既に存在するオブジェクトが含まれていても、宛先で解凍する際には無視されますので、注意してください。

@samp{refs/remotes/*} などの参照を含む @samp{git clone --mirror} と一致させる場合は、 @samp{--all} を使用します。 ソースリポジトリから直接クローンが取得するのと同じ参照セットを提供する場合は、 @samp{<git-rev-list-args>} に @samp{--branches --tags} を使用します。

@samp{git bundle verify} コマンドを使用して、受信者リポジトリにバンドルに必要な前提条件のコミットがあるかどうかを確認できます。

@noindent

@chapheading EXAMPLES

あなたが、マシンAのリポジトリR1から、マシンBの別のリポジトリR2に、履歴を転送するとします。 何らかの理由で、AとBの間の直接接続は許可されていませんが、何らかのメカニズム(CD、電子メールなど)を介してAからBにデータを移動することはできます。 私達は、R1のmasterブランチで行われた開発で、R2を更新したいと思います。

開発プロセスをブートストラップするために、あなたは、最初に前提条件のないバンドルを作成します。あなたはタグを使用して、最後に処理したコミットまでを記憶し、後で他のリポジトリを増分バンドル(incremental bundle)で簡単に更新できるようにすることができます:

@example
machineA$ cd R1
machineA$ git bundle create file.bundle master
machineA$ git tag -f lastR2bundle master
@end example


次に、file.bundleをターゲットマシンBに転送します。このバンドルでは既存のオブジェクトを抽出する必要がないため、あなたはマシンBからクローンを作成して、新しいリポジトリを作成できます:

@example
machineB$ git clone -b master /home/me/tmp/file.bundle R2
@end example


これにより、結果のリポジトリに「origin」と呼ばれるリモートが定義され、バンドルからフェッチおよびプルできるようになります。 R2 の $GIT_DIR/config ファイルには、以下のようなエントリがあります:

@example
[remote "origin"]
    url = /home/me/tmp/file.bundle
    fetch = refs/heads/*:refs/remotes/origin/*
@end example


結果のmine.gitリポジトリを更新するには、 /home/me/tmp/file.bundle に保存されているバンドルを増分更新(incremental updates)に置き換えた後、フェッチまたはプルできます。

元のリポジトリでさらに作業した後、増分バンドル(incremental bundle)を作成して、他のリポジトリを更新できます:

@example
machineA$ cd R1
machineA$ git bundle create file.bundle lastR2bundle..master
machineA$ git tag -f lastR2bundle master
@end example


次に、あなたはバンドルを他のマシンに転送して /home/me/tmp/file.bundle を置き換え、そこからプルします。

@example
machineB$ cd R2
machineB$ git pull
@end example


目的の受信者リポジトリが必要なオブジェクトをどのコミットまで持つべきかがわかっている場合は、その知識を使用して前提条件を指定し、結果のバンドルに含まれるリビジョンとオブジェクトを制限するカットオフポイントを指定できます。 前の例では、この目的でlastR2bundleタグを使用しましたが、 git-log(1) コマンドに指定する他のオプションを使用できます。 その他の例は以下のとおりです:

あなたは両方に存在するタグを使用できます:

@example
$ git bundle create mybundle v1.0.0..master
@end example


あなたは日時に基づく前提条件を使用できます:

@example
$ git bundle create mybundle --since=10.days master
@end example


あなたはコミット数を利用できます:

@example
$ git bundle create mybundle -10 master
@end example


@samp{git-bundle verify} を実行して、前提条件に従って作成されたバンドルから抽出可能かどうかを確認できます:

@example
$ git bundle verify mybundle
@end example


これにより、バンドルから抽出するために必要なコミットが一覧表示され、コミットがない場合はエラーになります。

受信者リポジトリの観点からのバンドルは、フェッチまたはプルする通常のリポジトリと同じです。 たとえば、フェッチするときに参照をマップできます:

@example
$ git fetch mybundle master:localRef
@end example


あなたはまた、それが提供する参照を確認することもできます:

@example
$ git ls-remote mybundle
@end example


@noindent

@chapheading FILE FORMAT

See gitformat-bundle(5).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cat-file,,,Top
@chapheading Name

git-cat-file — リポジトリオブジェクトのコンテンツまたはタイプとサイズの情報を提供します

@noindent

@chapheading Synopsis

@display
git cat-file <type> <object>
git cat-file (-e | -p) <object>
git cat-file (-t | -s) [--allow-unknown-type] <object>
git cat-file (--batch | --batch-check | --batch-command) [--batch-all-objects]
             [--buffer] [--follow-symlinks] [--unordered]
             [--textconv | --filters] [-Z]
git cat-file (--textconv | --filters)
             [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]
@end display


@noindent

@chapheading DESCRIPTION

SYNOPSISの最初の形式では、コマンドはリポジトリ内のオブジェクトのコンテンツまたはタイプを提供します。 オブジェクトのタイプを調べるために @samp{-t} や @samp{-p} が使われているか、オブジェクトのサイズを調べるために @samp{-s} が使われているか、あるいは @samp{--textconv} や @samp{--filters} が使われている(これらはタイプ @samp{blob} を意味する)場合を除いて、タイプは必須となります。

SYNOPSISの2番目の形式では、オブジェクトのリスト(改行で区切られている)がstdinに提供され、各オブジェクトのSHA-1のタイプとサイズがstdoutに出力されます。 オプションの @samp{<format>} 引数を使用して、出力形式をオーバーライドできます。 @samp{--textconv} または @samp{--filters} のいずれかが指定された場合、入力は、適切なドライバーを決定できるように、オブジェクト名とそれに続くパス名を単一の空白で区切ってリストすることが期待されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  <object> 
表示するオブジェクトの名前。 オブジェクト名を綴る方法のより完全なリストについては、 gitrevisions(7) の「SPECIFYING REVISIONS」セクションを参照してください。

@item  @samp{-t} 
コンテンツの代わりに、 @samp{<object>} で識別されるオブジェクトタイプを表示します。

@item  @samp{-s} 
Instead of the content, show the object size identified by @samp{<object>}. If used with @samp{--use-mailmap} option, will show the size of updated object after replacing idents using the mailmap mechanism.

@item  @samp{-e} 
@samp{<object>} が存在し、有効なオブジェクトである場合、ステータスはゼロで終了(exit)します。 @samp{<object>} が無効な形式の場合、ゼロ以外で終了(exit)し、stderrでエラーを発行します。

@item  @samp{-p} 
そのタイプに基づいて @samp{<object>} の内容をきれいに印刷(pretty-print)します。

@item  <type> 
通常、これは実際のタイプの @samp{<object>} と一致しますが、指定された @samp{<object>} から簡単に逆参照できるタイプを要求することもできます。 例として、@samp{<object>`がそれを含むコミットオブジェクトである `tree`を要求するか、または `<object>} がそれを指すタグオブジェクトである @samp{blob} を要求します。

@item  @samp{--[no-]mailmap} 
@itemx  @samp{--[no-]use-mailmap} 
mailmap ファイルを使用して、作者(author)やコミッター(commiter)やタグ付けした人(taggr)の名前と電子メール・アドレスを正規の実名と電子メール・アドレスにマップします。 git-shortlog(1) を参照してください。

@item  @samp{--textconv} 
textconvフィルターによって変換されたコンテンツを表示します。 この場合、 @samp{<object>} は、 @samp{<tree-ish>:<path>} または @samp{:<path>} の形式である必要があり、 @samp{<path>} のインデックスに記録されたコンテンツにフィルターを適用します。

@item  @samp{--filters} 
与えられた @samp{<path>} に対して、現在の作業ツリーで構成されているフィルターによって変換された内容を表示します(つまり、スマッジ(smudge)フィルター、行末変換など)。 この場合、@samp{<object>} は @samp{<tree-ish>:<path>} または @samp{:<path>} の形式である必要があります。

@item  @samp{--path=<path>} 
@samp{--textconv} または @samp{--filters} とともに使用して、例えば、ブロブの元となったリビジョンを把握するのが難しいときに、オブジェクト名とパスを別々に指定できるようにします。

@item  @samp{--batch} 
@itemx  @samp{--batch=<format>} 
Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except @samp{--textconv}, @samp{--filters}, or @samp{--use-mailmap}.

@itemize 

@item
When used with @samp{--textconv} or @samp{--filters}, the input lines must specify the path, separated by whitespace. See the section @samp{BATCH OUTPUT} below for details.

@item
When used with @samp{--use-mailmap}, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities.
@end itemize

@item  @samp{--batch-check} 
@itemx  @samp{--batch-check=<format>} 
Print object information for each object provided on stdin. May not be combined with any other options or arguments except @samp{--textconv}, @samp{--filters} or @samp{--use-mailmap}.

@itemize 

@item
When used with @samp{--textconv} or @samp{--filters}, the input lines must
specify the path, separated by whitespace. See the section
@samp{BATCH OUTPUT} below for details.

@item
When used with @samp{--use-mailmap}, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism.
@end itemize

@item  @samp{--batch-command} 
@itemx  @samp{--batch-command=<format>} 
Enter a command mode that reads commands and arguments from stdin. May only be combined with @samp{--buffer}, @samp{--textconv}, @samp{--use-mailmap} or @samp{--filters}.

@itemize 

@item
When used with @samp{--textconv} or @samp{--filters}, the input lines must specify the path, separated by whitespace. See the section @samp{BATCH OUTPUT} below for details.

@item
When used with @samp{--use-mailmap}, for commit and tag objects, the @samp{contents} command shows the identities replaced using the mailmap mechanism, while the @samp{info} command shows the size of the object as if it actually recorded the replacement identities.
@end itemize

@samp{--batch-command} は以下のコマンドを認識します:

@table @asis

@item  contents <object> 
オブジェクト参照 @samp{<object>} のオブジェクトの内容を出力します。 これは @samp{--batch} の出力に対応します。

@item  info <object> 
オブジェクト参照 @samp{<object>} のオブジェクト情報を出力します。 これは @samp{--batch-check} の出力に対応します。

@item  flush 
@samp{--buffer} とともに使用して、最初から、または最後のフラッシュが発行されてから発行された先行するすべてのコマンドを実行します。 @samp{--buffer} を使用すると、 @samp{flush} が発行されるまで何も出力されません。 @samp{--buffer} を使用しない場合は、 @samp{flush} を発行しなくてもコマンドを毎回フラッシュします。
@end table

@item  @samp{--batch-all-objects} 
stdinでオブジェクトのリストを読み取る代わりに、 (到達可能なオブジェクトだけでなく、)リポジトリ内のすべてのオブジェクトと代替オブジェクトストア(alternate object stores)に対して要求されたバッチ操作を実行します。 @samp{--batch} または @samp{--batch-check} を指定する必要があります。 デフォルトでは、オブジェクトはハッシュでソートされた順序でアクセスされます。 下記 @samp{--unordered} も参照してください。 オブジェクトは、git-replace(1) の置換メカニズムを考慮せずに、そのまま表示されます。

@item  @samp{--buffer} 
通常、バッチ出力は各オブジェクトが出力された後にフラッシュされるため、プロセスは @samp{cat-file} からインタラクティブに読み取りおよび書き込みを行うことができます。 このオプションを使用すると、出力は通常のstdioバッファリングを使用します。 これは、多数のオブジェクトで @samp{--batch-check} または @samp{--batch-command} を呼び出す場合には、はるかに効率的です。

@item  @samp{--unordered} 
@samp{--batch-all-objects} が使用されている場合に、このオプションを使用すると、ハッシュの順序よりもオブジェクトのコンテンツにアクセスするのに効率的な順序でオブジェクトにアクセスします。 順序の正確な詳細は指定されていませんが、特定の順序が必要ない場合は、特に @samp{--batch} を使用すると、通常、出力が速くなります。 注意: @samp{cat-file} は、リポジトリに同一オブジェクトが複数回保存されている場合でも、オブジェクトを1回だけ表示することに注意してください。

@item  @samp{--allow-unknown-type} 
@samp{-s} または @samp{-t} が不明なタイプの 壊れた/破損した オブジェクトを照会できるようにします。

@item  @samp{--follow-symlinks} 
@samp{--batch} または @samp{--batch-check} を使用して、 tree-ish:path-in-tree 形式の拡張SHA-1式を使用してオブジェクトを要求する場合は、リポジトリ内のシンボリックリンクをたどります。 リンク自体に関する出力を提供する代わりに、リンク先オブジェクトに関する出力を提供します。 シンボリックリンクがツリーっぽいものの外側を指している場合(たとえば、 @samp{/foo} へのリンクまたは @samp{../foo} へのルートレベルのリンク)、ツリーの外側にあるリンクの部分が出力されます。

このオプションは、ツリー内のオブジェクトではなく、インデックス内のオブジェクトが指定されている場合(たとえば、 @samp{HEAD:link} ではなく @samp{:link}）、 (現在のところ)正しく機能しません。

@samp{--batch} または @samp{--batch-check} が使用されていない限り、このオプションは(現在のところ)使用できません。

たとえば、以下のものを含むgitリポジトリについて考えてみましょう:

@example
f はファイルで、内容は "hello\n" です。
link は f への symlink です。
dir/link は ../f への symlink です。
plink は ../f への symlink です。
alink は /etc/passwd への symlink です。
@end example

通常のファイル @samp{f} の場合、 @samp{echo HEAD:f | git cat-file --batch} とすると、以下を出力します

@example
ce013625030ba8dba906f756967f9e9ca394464a blob 6
@end example

そして @samp{echo HEAD:link | git cat-file --batch --follow-symlinks} は、 @samp{HEAD:dir/link} と同様に、 両方とも @samp{HEAD:f} を指しているため、同一の出力を行います。

@samp{--follow-symlinks} がないと、これらはシンボリックリンク自体に関するデータを出力します。 @samp{HEAD:link} の場合、以下のように表示されます。

@example
4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1
@end example

@samp{plink} と @samp{alink} はどちらもツリーの外側を指しているため、それぞれ以下のように出力されます:

@example
symlink 4
../f
@end example

@example
symlink 11
/etc/passwd
@end example

@item  @samp{-Z} 
Only meaningful with @samp{--batch}, @samp{--batch-check}, or @samp{--batch-command}; input and output is NUL-delimited instead of newline-delimited.

@item  @samp{-z} 
Only meaningful with @samp{--batch}, @samp{--batch-check}, or @samp{--batch-command}; input is NUL-delimited instead of newline-delimited. This option is deprecated in favor of @samp{-Z} as the output can otherwise be ambiguous.
@end table

@noindent

@chapheading OUTPUT

@samp{-t} が指定されている場合、 @samp{<type>} の1つを出力。

@samp{-s} が指定されている場合、 @samp{<object>} のサイズ(バイト単位)を出力。

@samp{-e} が指定されている場合、 @samp{<object>} の形式が正しくない限り、出力は行われません。

@samp{-p} を指定すると、@samp{<object>} の内容がきれいに印刷(pretty-printed)されます。

@samp{<type>} が指定されている場合、 @samp{<object>} の生の(圧縮されていない)コンテンツが返されます。

@noindent

@chapheading BATCH OUTPUT

@samp{--batch} または @samp{--batch-check} が指定されている場合、 @samp{cat-file} はstdinからオブジェクトを1行に1つずつ読み取り、それらに関する情報を出力します。 デフォルトでは、 git-rev-parse(1) にフィードされたかのように、行全体がオブジェクトと見なされます。

@samp{--batch-command} が指定されると、 @samp{cat-file} は標準入力からコマンドを 1 行に 1 つずつ読み取り、指定されたコマンドに基づいて情報を出力します。 @samp{--batch-command} を使用すると、 @samp{info} コマンドの後にオブジェクトが続くと @samp{--batch-check} と同一の方法でオブジェクトに関する情報が出力され、 @samp{contents} コマンドの後にオブジェクトが続くと @samp{--batch} と同一の方法で内容が出力されます。

カスタム @samp{<format>} を使用して、オブジェクトごとに表示される情報を指定できます。 @samp{<format>} は、各オブジェクトのstdoutに文字通りコピーされ、 @samp{%(atom)} `形式のプレースホルダーが展開され、その後に改行が続きます。 使用可能なatomは以下のとおりです:

@table @asis

@item  @samp{objectname} 
オブジェクト名の完全な16進表現。

@item  @samp{objecttype} 
オブジェクトのタイプ(@samp{cat-file -t} で表示されるものと同じ)。

@item  @samp{objectsize} 
オブジェクトのサイズ(バイト単位) (@samp{cat-file -s} で表示されるものと同じ)。

@item  @samp{objectsize:disk} 
オブジェクトがディスク上で占めるサイズ(バイト単位)。 下記「CAVEATS」セクションの「note about on-disk sizes」（ディスク上のサイズに関する注記)を参照してください。

@item  @samp{deltabase} 
オブジェクトがディスク上にデルタとして保存されている場合、これはデルタベースオブジェクト名の完全な16進表現に展開されます。 それ以外の場合は、null OID ( 全てゼロ)に展開されます。 下記「CAVEATS」を参照してください。

@item  @samp{rest} 
このatomが出力文字列で使用されている場合、入力行は最初の空白の境界で分割されます。 その空白の前のすべての文字がオブジェクト名と見なされます。 その最初の空白後の文字(つまり、行の「残り」)は、 @samp{%(rest)} アトムに置き換えられて出力されます。
@end table

形式が指定されていない場合、デフォルトの形式は @samp{%(objectname) %(objecttype) %(objectsize)} です。

@samp{--batch} が指定されている場合、 または @samp{--batch-command} が @samp{contents} コマンドで使用されている場合、 オブジェクト情報の後にオブジェクトの内容(@samp{%(objectsize)} バイトのサイズ)が続き、その後に改行(newline)が続きます。

たとえば、カスタム形式のない @samp{--batch} は、以下のように生成されます:

@example
<oid> SP <type> SP <size> LF
<contents> LF
@end example


一方、 @samp{--batch-check='%(objectname) %(objecttype)'} は、以下のように生成します:

@example
<oid> SP <type> LF
@end example


リポジトリ内のオブジェクトに解決できない名前がstdinに指定されている場合、 @samp{cat-file} はカスタム形式を無視して以下のように出力します:

@example
<object> SP missing LF
@end example


(あいまいな短い sha など、)複数のオブジェクトを参照する可能性のある名前が指定されている場合、 @samp{cat-file} はカスタム形式を無視して以下のように出力します:

@example
<object> SP ambiguous LF
@end example


@samp{--follow-symlinks} が使用され、リポジトリ内のシンボリックリンクがリポジトリの外部を指している場合、 @samp{cat-file} はカスタム形式を無視して以下のように出力します:

@example
symlink SP <size> LF
<symlink> LF
@end example


シンボリックリンク(symlink)はツリーのルートに対して絶対(absolute)(@samp{/} で始まる)か、あるいは相対(relative)です。 たとえば、 dir/link が @samp{../../foo} を指している場合、@samp{<symlink>} は @samp{../foo} になります。 @samp{<size>} は、バイト単位のシンボリックリンクのサイズです。

@samp{--follow-symlinks} を使用すると、以下のエラーメッセージが表示されます:

@example
<object> SP missing LF
@end example


これは、要求した最初のシンボリックリンク(initial symlink)が存在しない場合に出力されます。

@example
dangling SP <size> LF
<object> LF
@end example


これは、最初のシンボリックリンク(initial symlink)が存在する場合に出力されますが、それが指すモノは出力されません。

@example
loop SP <size> LF
<object> LF
@end example


これは、シンボリックリンクループ(または解決するために40を超えるリンク段数を必要とするシンボリックリンク)に対して出力されます。

@example
notdir SP <size> LF
<object> LF
@end example


これは、シンボリックリンクの解決中に、ファイルがディレクトリ名として使用された場合に出力されます。

Alternatively, when @samp{-Z} is passed, the line feeds in any of the above examples are replaced with NUL terminators. This ensures that output will be parsable if the output itself would contain a linefeed and is thus recommended for scripting purposes.

@noindent

@chapheading CAVEATS(警告)

注意: ディスク上のオブジェクトのサイズは正確に報告されますが、どのrefまたはオブジェクトがディスクの使用に関与しているかについて結論を出す際には注意が必要です。 パックされた非デルタオブジェクトのサイズは、それに対してデルタするオブジェクトのサイズよりもはるかに大きい場合がありますが、ベースとデルタのオブジェクトの選択は任意であり、再パック中に変更される可能性があります。

注意: オブジェクトの複数のコピーがオブジェクトデータベースに存在する可能性があることにも注意してください。 この場合、どのコピーのサイズまたはデルタベースが報告されるかは未定義です。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-check-attr,,,Top
@chapheading Name

git-check-attr — gitattributes情報を表示

@noindent

@chapheading Synopsis

@display
git check-attr [--source <tree-ish>] [-a | --all | <attr>…] [--] <pathname>…
git check-attr --stdin [-z] [--source <tree-ish>] [-a | --all | <attr>…]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、すべてのパス名について、gitattributesとしての各属性を @samp{unspecified}(未指定)または @samp{set} または @samp{unset} であるかどうか一覧表示します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a, --all} 
指定されたパスに関連付けられているすべての属性を一覧表示します。 このオプションを使用すると、 @emph{unspecified} (指定されていない)属性は出力に含まれません。

@item  @samp{--cached} 
作業ツリーを無視して、インデックス内のみに対して @samp{.gitattributes} を考慮してください。

@item  @samp{--stdin} 
コマンドラインからではなく、標準入力から1行に1つずつパス名を読み取ります。

@item  @samp{-z} 
出力形式は、マシンで解析できるように変更されます。 @samp{--stdin} も指定されている場合、入力パスは改行文字ではなくNUL文字で区切ります。

@item  @samp{--source=<tree-ish>} 
Check attributes against the specified tree-ish. It is common to specify the source tree by naming a commit, branch or tag associated with it.

@item  @samp{--} 
先行するすべての引数を属性として解釈し、後続のすべての引数をパス名として解釈します。
@end table

@samp{--stdin} と @samp{--all} と @samp{--} のいずれも使用されていない場合、最初の引数は属性として扱われ、残りの引数はパス名として扱われます。

@noindent

@chapheading OUTPUT

出力形式: <path> COLON SP <attribute> COLON SP <info> LF

@samp{-z} が有効の場合はNULが区切り文字として使用されます: <path> NUL <attribute> NUL <info> NUL

<path>はクエリ対象のファイルのパス、 <attribute> はクエリ対象の属性、 <info> は行かのいずれかになります:

@table @asis

@item  @samp{unspecified} 
(未指定)パスにその属性が定義されていない場合。

@item  @samp{unset} 
属性がfalseとして定義されている場合。

@item  @samp{set} 
属性がtrueとして定義されている場合。

@item  <value> 
属性に値が割り当てられたとき。
@end table

バッファリングは、 git(1) の @samp{GIT_FLUSH} オプションに記載されているように行われます。呼び出し元は、入力バッファーのオーバーフィル(overfilling)または空の出力バッファーからの読み取りによって引き起こされるデッドロックを回避する責任があります。

@noindent

@chapheading EXAMPLES

これらの例では、以下の @samp{.gitattributes} ファイルが使用されています:

@example
*.java diff=java -crlf myAttr
NoMyAttr.java !myAttr
README caveat=unspecified
@end example


@itemize 

@item
単一の属性のリスト:
@end itemize

@example
$ git check-attr diff org/example/MyClass.java
org/example/MyClass.java: diff: java
@end example


@itemize 

@item
ファイルの複数の属性の一覧表示:
@end itemize

@example
$ git check-attr crlf diff myAttr -- org/example/MyClass.java
org/example/MyClass.java: crlf: unset
org/example/MyClass.java: diff: java
org/example/MyClass.java: myAttr: set
@end example


@itemize 

@item
ファイルのすべての属性を一覧表示:
@end itemize

@example
$ git check-attr --all -- org/example/MyClass.java
org/example/MyClass.java: diff: java
org/example/MyClass.java: myAttr: set
@end example


@itemize 

@item
複数のファイルの属性を一覧表示:
@end itemize

@example
$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java
org/example/MyClass.java: myAttr: set
org/example/NoMyAttr.java: myAttr: unspecified
@end example


@itemize 

@item
すべての値が等しく明確であるわけではありません:
@end itemize

@example
$ git check-attr caveat README
README: caveat: unspecified
@end example


@noindent

@chapheading SEE ALSO

gitattributes(5).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-check-ignore,,,Top
@chapheading Name

git-check-ignore — gitignoreや除外ファイルのデバッグ

@noindent

@chapheading Synopsis

@display
git check-ignore [<options>] <pathname>…
git check-ignore [<options>] --stdin
@end display


@noindent

@chapheading DESCRIPTION

コマンドラインまたは @samp{--stdin} を介してファイルから指定されたパス名ごとに、ファイルが @samp{.gitignore} (またはexcludeメカニズムへの他の入力ファイル)によって除外されているかどうかを確認し、除外されている場合はそのパスを出力します。

デフォルトでは、追跡中のファイル(tracked files)は除外ルールの対象ではないため、まったく表示されません。但し、 ‘--no-index’ もご覧下さい。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q, --quiet} 
何も出力せず、終了ステータスを設定するだけです。 これは、単一のパス名でのみ有効です。

@item  @samp{-v, --verbose} 
除外されたパスを出力する代わりに、除外パターンに一致するパスごとに、パスと一緒に除外パターンを出力します。 (通常、除外パターンに一致することはパスが除外されることを意味しますが、パターンが "@samp{!}" で始まる場合、それは否定パターンであり、一致することはパスが除外されないことを意味します。)

除外ソース内および除外ソース間の優先ルールについては、 gitignore(5) を参照してください。

@item  @samp{--stdin} 
コマンドラインからではなく、標準入力から1行に1つずつパス名を読み取ります。

@item  @samp{-z} 
出力フォーマットは、マシン解析可能になるように変更されます(以下を参照)。 @samp{--stdin} も指定されている場合、入力パスは改行文字ではなくNUL文字で区切られます。

@item  @samp{-n, --non-matching} 
どのパターンにも一致しないパスを表示します。これは、 @samp{--verbose} が有効になっている場合にのみ意味があります。有効になっていないと、パターンに一致するパスと一致しないパスを区別できません。

@item  @samp{--no-index} 
チェックを行うときにインデックスを調べません。これは、例えば @samp{git add .} で追跡されたパスが、ユーザーの期待通りにルールで無視されなかった場合のデバッグに使用できます。また、以前に @samp{git add -f} で追加したパスにマッチするように、否定を含むパターンを開発するときにも使用できます。
@end table

@noindent

@chapheading OUTPUT

デフォルトでは、指定されたパス名のうち無視パターンに一致するパスが1行に1つずつ出力されます。特定のパスに一致する無視パターンがない場合、そのパスについては何も出力されません。これは、そのパスが無視されないことを意味します。

@samp{--verbose} が指定されている場合、出力の各行は以下の形式になります:

<source> <COLON> <linenum> <COLON> <pattern> <HT> <pathname>

<pathname> はクエリ対象のファイルのパス、 <pattern> は一致するパターン、 <source> はパターンのソースファイル、 <linenum> はそのソース内のパターンの行番号です。 パターンに "@samp{!}" 接頭辞または "@samp{/}" 接尾辞が含まれている場合、 それは出力でも保持されます。 <source> は、 @samp{core.excludesFile} で構成されたファイルを参照する場合は絶対パス、 @samp{.git/info/exclude} またはディレクトリごとの除外ファイルを参照する場合はリポジトリルートを基準とします。

@samp{-z} が指定されている場合、出力のパス名はヌル文字で区切られます。 @samp{--verbose} も指定されている場合、コロンとハードタブの代わりにヌル文字も使用されます:

<source> <NULL> <linenum> <NULL> <pattern> <NULL> <pathname> <NULL>

@samp{-n} または @samp{--non-matching} が指定されている場合、一致しないパス名も出力されます。その場合、 <pathname> を除く各出力レコードのすべてのフィールドが空になります。これは、非対話的に実行する場合に役立ちます。これにより、ファイル達を長時間実行されるチェック無視プロセスのSTDINに段階的にストリーミングでき、これらのファイルごとに、STDOUTはそのファイルがパターンに一致するかどうかを示します。 (このオプションがないと、特定のファイルの出力がないということは、どのパターンとも一致しなかったのか、出力がまだ生成されていないのかを判断することはできません。)

バッファリングは、 git(1) の @samp{GIT_FLUSH} オプションに記載されているように行われます。呼び出し元は、入力バッファーのオーバーフィルまたは空の出力バッファーからの読み取りによって引き起こされるデッドロックを回避する責任があります。

@noindent

@chapheading EXIT STATUS

@table @asis

@item  0 
提供されたパスの1つ以上が無視されます。

@item  1 
提供されたパスはどれも無視されません。

@item  128 
致命的なエラーが発生しました。
@end table

@noindent

@chapheading SEE ALSO

gitignore(5) git-config(1) git-ls-files(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-check-mailmap,,,Top
@chapheading Name

git-check-mailmap — 連絡先(contacts)の、正式な名前と電子メールアドレスを表示

@noindent

@chapheading Synopsis

@display
git check-mailmap [<options>] <contact>…
@end display


@noindent

@chapheading DESCRIPTION

コマンドライン指定または、(@samp{--stdin} を使用する場合)標準入力からの各 “Name <user@@host>” または “<user@@host>” について、その人の正規名と電子メールアドレス(以下 "Mapping Authors" 参照)を検索します。見つかった場合は、それらを印刷します。それ以外の場合は、入力をそのまま出力します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--stdin} 
コマンドラインで指定された連絡先(contacts)を消費後、標準入力から連絡先(contacts)を1行に1つずつ読み取ります。
@end table

@noindent

@chapheading OUTPUT

各連絡先(contact)ごとに、改行で終了する1行が出力されます。 名前が @emph{mailmap} に提供または認識されている場合、 “Name <user@@host>” が出力されます。それ以外の場合は、 “<user@@host>” のみが出力されます。

@noindent

@chapheading CONFIGURATION

カスタムの @samp{.mailmap} ターゲットファイルまたはオブジェクトを指定する方法については、 git-config(1) の @samp{mailmap.file} と @samp{mailmap.blob} を参照してください。

@noindent

@chapheading MAPPING AUTHORS

gitmailmap(5) 参照。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-check-ref-format,,,Top
@chapheading Name

git-check-ref-format — 参照名が整形式であることを確認します

@noindent

@chapheading Synopsis

@display
git check-ref-format [--normalize]
       [--[no-]allow-onelevel] [--refspec-pattern]
       <refname>
git check-ref-format --branch <branchname-shorthand>
@end display


@noindent

@chapheading DESCRIPTION

指定の refname が受け入れ可能かどうかを確認し、受け入れられない場合はゼロ以外のステータスで終了します。

参照はGitでブランチとタグを指定するために使用されます。ブランチヘッドは @samp{refs/heads} 階層に格納され、タグはref名前空間の @samp{refs/tags} 階層に格納されます(通常は @samp{$GIT_DIR/refs/heads} ディレクトリと @samp{$GIT_DIR/refs/tags} ディレクトリに、または refが @samp{git gc} によってパックされている場合はファイル @samp{$GIT_DIR/packed-refs} のエントリとしてあります)。

Gitは、参照の命名方法に以下のルールを課しています:

@enumerate 

@item
階層(ディレクトリ)グループ化のためにスラッシュ(@samp{/})を含めることができますが、スラッシュで区切られたコンポーネントは、ドット(@samp{.})で開始したり、シーケンス @samp{.lock} で終了したりすることはできません。

@item
少なくとも1つのスラッシュ(@samp{/})が含まれている必要があります。これにより、 @samp{heads/} 、 @samp{tags/} などのカテゴリの存在が強制されますが、実際の名前は制限されません。 @samp{--allow-onelevel} オプションが使用されている場合、このルールは放棄されます。

@item
どこにも2つの連続したドット(@samp{..})を含めることはできません。

@item
ASCII制御文字(つまり、値が \040 未満のバイト または \177(@samp{DEL}))、スペース、チルダ(@samp{~})、キャレット(@samp{^})、コロン(@samp{:})はどこにでも含めることはできません。

@item
疑問符(@samp{？})、アスタリスク(@samp{*})、角かっこ(@samp{[})がどこにあってもいけません。この規則の例外については、以下の @samp{--refspec-pattern} オプションを参照してください。

@item
スラッシュ(@samp{/})で開始または終了したり、複数の連続したスラッシュを含めることはできません(この規則の例外については、以下の @samp{--normalize} オプションを参照してください)。

@item
ドット(@samp{.})で終わらせることはできません。

@item
シーケンス @samp{@@@{} を含めることはできません。

@item
単一の文字 @samp{@@} にすることはできません。

@item
@samp{\} を含めることはできません。
@end enumerate

これらのルールにより、シェルスクリプトをベースにしたツールで参照名を簡単にパースできるようになり、参照名が(誤って)引用符なしで使われたときにシェルでパス名を展開したり、特定の参照名表現におけるあいまいさを回避することができます(gitrevisions(7) を参照)。

@enumerate 

@item
二重ドット(@samp{..})は、 @samp{ref1..ref2} などとよく使用されます。一部のコンテキストでは、この表記は @samp{^ref1 ref2} を意味します(つまり、@samp{ref1} に無く かつ @samp{ref2} にある)。

@item
チルダ(@samp{~})とキャレット(@samp{^})は、接尾辞 @emph{nth parent} (n番目の親)と @emph{peel onion} (玉ねぎ剥き)操作を導入するために使用されます。

@item
コロン(@samp{：})は、 @samp{srcref:dstref} のように、フェッチおよびプッシュ操作で「srcrefの値を使用してdstrefに格納する」ことを意味するために使用されます。 @samp{git cat-file blob v1.3.3:refs.c} のようにして @samp{git cat-file} などで特定のオブジェクトを選択するためにも使用できます。

@item
at-open-brace(@samp{@@@{})は、reflogエントリにアクセスするための表記法として使用されます。
@end enumerate

@samp{--branch} オプションを使用すると、コマンドは名前を取得し、それが有効なブランチ名として使用できるかどうかを確認します(たとえば、新しいブランチを作成するとき)。ただし、切り離された(detached)HEAD状態を参照する可能性のある、遡及チェックアウト構文(previous checkout syntax)を使用する場合は注意が必要です。 @samp{git check-ref-format --branch $name} が実装するルールは、 @samp{git check-ref-format refs/heads/$name} が言うことよりも厳しい場合があります(たとえば、参照コンポーネントの先頭にダッシュが表示される場合がありますが、ブランチ名の先頭では明示的に禁止されています)。リポジトリで @samp{--branch} オプションを指定して実行すると、入力は最初に「遡及チェックアウト構文」 @samp{@@@{-n@}} 用に展開されます。たとえば、 @samp{@@@{-1@}} は、 @samp{git switch} または @samp{git checkout} 操作を使用して最後にチェックアウトされたものを参照する方法です。磁器コマンドでは、ブランチ名が必要な場所でこの構文を受け入れるために、このオプションを使用する必要があります。これにより、あなたがブランチ名を入力したかのように機能できます。注意: 「遡及チェックアウト操作」では、例外として、チェックアウトされたN番目の最後のものがブランチではなかった場合にコミットオブジェクト名が生成される可能性があることに注意してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--[no-]allow-onelevel} 
1レベルのrefnameを受け入れるかどうかを制御します(つまり、複数の @samp{/} で区切られたコンポーネントを含まないrefname)。 デフォルトは @samp{--no-allow-onelevel} です。

@item  @samp{--refspec-pattern} 
<refname>を(リモートリポジトリで使用される)refspecの参照名パターンとして解釈します。このオプションを有効にすると、<refname>はrefspecに単一の @samp{*} を含めることができます(例: @samp{foo/bar*/baz} または @samp{foo/bar*baz/} はOKですが、 @samp{foo/bar*/baz*} はダメです)。

@item  @samp{--normalize} 
先行スラッシュ(@samp{/})文字を削除し、名前コンポーネント間の隣接するスラッシュを1つのスラッシュに折りたたむことにより、 @emph{refname} を正規化します。正規化されたrefnameが有効な場合は、それを標準出力に出力し、ステータス0で終了します。それ以外の場合は、ゼロ以外のステータスで終了します。 ( @samp{--print} は @samp{--normalize} を綴る非推奨の方法です。)
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
チェックアウトしたのモノの一つ前のものの名前を印刷します:

@example
$ git check-ref-format --branch @@@{-1@}
@end example


@item
新しいブランチに使用する参照名を決定します:

@example
$ ref=$(git check-ref-format --normalize "refs/heads/$newbranch")||
@{ echo "we do not like '$newbranch' as a branch name." >&2 ; exit 1 ; @}
@end example

@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-checkout-index,,,Top
@chapheading Name

git-checkout-index — インデックスから作業ツリーにファイルをコピー

@noindent

@chapheading Synopsis

@display
git checkout-index [-u] [-q] [-a] [-f] [-n] [--prefix=<string>]
                   [--stage=<number>|all]
                   [--temp]
                   [--ignore-skip-worktree-bits]
                   [-z] [--stdin]
                   [--] [<file>…]
@end display


@noindent

@chapheading DESCRIPTION

リストされているすべてのファイルをインデックスから作業ディレクトリにコピーします(既存ファイルは上書きしません)。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-u} 
@itemx  @samp{--index} 
インデックスファイルのチェックアウトされたエントリの統計情報を更新します。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
ファイルが存在する場合、またはインデックスにない場合は、静かにする

@item  @samp{-f} 
@itemx  @samp{--force} 
既存ファイルを強制的に上書きします

@item  @samp{-a} 
@itemx  @samp{--all} 
skip-worktree ビットが設定されているファイルを除いて、インデックス内のすべてのファイルをチェックアウトします(@samp{--ignore-skip-worktree-bits} 参照)。 明示的なファイル名(explicit filenames)と一緒に使用することはできません。

@item  @samp{-n} 
@itemx  @samp{--no-create} 
新しいファイルをチェックアウトせず、すでにチェックアウトされているファイルのみを更新します。

@item  @samp{--prefix=<string>} 
ファイルを作成するときは、<string> (通常は末尾に/を含むディレクトリ名) をファイル名の先頭に追加します

@item  @samp{--stage=<number>|all} 
マージされていないエントリをチェックアウトする代わりに、名前付きステージからファイルをコピーします。 <number>は1〜3の間でなければなりません。 注: @samp{--stage=all} は自動的に @samp{--temp} の指定を含みます。

@item  @samp{--temp} 
ファイルを作業ディレクトリにコピーする代わりに、コンテンツを一時ファイルに書き込みます。一時的な名前の関連付けはstdoutに書き込まれます。

@item  @samp{--ignore-skip-worktree-bits} 
skip-worktree ビットが設定されたファイルを含め、すべてのファイルをチェックアウトします。

@item  @samp{--stdin} 
コマンドラインからパスのリストを取得する代わりに、標準入力からパスのリストを読み取ります。デフォルトでは、パスはLFで区切られます(つまり、1行に1つのパス)。

@item  @samp{-z} 
@samp{--stdin} でのみ意味があります。 パスは、LFではなくNUL文字で区切られます。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。
@end table

フラグの順序は以前は重要でしたが、現在は重要ではありません。

@samp{git checkout-index} を実行するだけでは何も起こりません。 あなたはおそらく @samp{git checkout-index -a} を意図しました。 そして、それを強制したい場合は、 @samp{git checkout-index -f -a} が必要です。

ここでは直感性は目標ではありません。再現性が目標です。 「引数がないということは作業がないことを意味する」という振る舞いの理由は、スクリプトから以下のことができるはずだからです:

@example
$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --
@end example


これにより、既存のすべての @samp{*.h} ファイルがキャッシュされたコピーに置き換えられます。 空のコマンドラインが「すべて」を意味するならば、これはインデックス内のすべてを強制的に更新してしまいますが、そうではありません。 ただし、 @samp{git checkout-index} は @samp{--stdin} を受け入れるため、以下のようにする方が高速です:

@example
$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin
@end example


残りがファイル名になることがわかっている場合は、 @samp{--} を使用することをお勧めします。 たとえば、@samp{-a} のファイル名での問題を防ぎます。 スクリプトでは @samp{--} を使用することをお勧めします。

@noindent

@chapheading Using --temp or --stage=all

@samp{--temp} が使用されている場合(または @samp{--stage=all} によって暗黙に指定されている場合)、 @samp{git checkout-index} は、チェックアウトされているインデックスエントリごとに一時ファイルを作成します。 インデックスの統計情報は更新されません。 これらのオプションは、マージされていないファイルを外部のマージツールで処理できるように、呼び出し元がマージされていないすべてのエントリのすべてのステージを必要とする場合に役立ちます。

一時ファイル名と追跡されたパス名の関連付けを提供するリストがstdoutに書き込まれます。リスト形式には2つのバリエーションがあります:

@example
. tempname TAB path RS
@end example


最初の形式は、 @samp{--stage} が省略されているか、 @samp{--stage=all} でない場合に使用される形式です。 フィールドtempnameはファイルの内容を保持する一時ファイル名であり、pathはインデックスで追跡されるパス名です。 要求されたエントリのみが出力されます。

@example
. stage1temp SP stage2temp SP stage3tmp TAB path RS
@end example


2番目の形式は、 @samp{--stage=all} の場合に使用される形式です。 3つのステージ一時フィールド(stage1temp、stage2temp、stage3temp)は、インデックスにステージエントリがある場合は一時ファイルの名前をリストし、ステージエントリがない場合は @samp{.} をリストします。ステージ0のエントリしかないpathは、常に出力から省略されます。

どちらの形式でも、RS(レコード区切り文字)はデフォルトでは改行ですが、コマンドラインで @samp{-z} が渡された場合はヌルバイトになります。一時ファイル名は常に安全な文字列(safe strings)で、ディレクトリ区切り文字や空白文字が含まれることはありません。pathフィールドは常に現在のディレクトリを基準にしており、一時ファイル名は常に最上位ディレクトリを基準にしています。

一時ファイルにコピーされるオブジェクトがシンボリックリンクである場合、リンクの内容は通常のファイルに書き込まれます。 この情報を利用するのはエンドユーザーまたは磁器コマンドの責任です。

@noindent

@chapheading EXAMPLES

@table @asis

@item  すでにチェックアウトされているファイルのみをupdateおよびrefreshするには 
@example
$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh
@end example


@item  @samp{git checkout-index} を使用して「ツリー全体をエクスポート」 
プレフィックス機能により、基本的に @samp{git checkout-index} を「ツリーとしてエクスポートする」機能として使用するのは簡単になります。目的のツリーをインデックスに読み込んで、以下の手順を実行します:

@example
$ git checkout-index --prefix=git-export-dir/ -a
@end example


@samp{git checkout-index} は、指定されたディレクトリにインデックスを「エクスポート」します。

最後の @samp{/} は重要です。 エクスポートされた名前には、文字通り、指定された文字列が接頭辞として付けられます。 これを以下の例と比較してください。

@item  プレフィックス付きのファイルをエクスポート 
@example
$ git checkout-index --prefix=.merged- Makefile
@end example


これにより、現在キャッシュされている @samp{Makefile} のコピーが、ファイル @samp{.merged-Makefile} にチェックアウトされます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-checkout,,,Top
@chapheading Name

git-checkout — ブランチの切り替え、または作業ツリーファイルの復元を行います。

@noindent

@chapheading Synopsis

@display
git checkout [-q] [-f] [-m] [<branch>]
git checkout [-q] [-f] [-m] --detach [<branch>]
git checkout [-q] [-f] [-m] [--detach] <commit>
git checkout [-q] [-f] [-m] [[-b|-B|--orphan] <new-branch>] [<start-point>]
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>…
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]
git checkout (-p|--patch) [<tree-ish>] [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

作業ツリー内のファイルを、インデックスまたは指定されたツリー内のバージョンと一致するように更新します。 pathspecが指定されていない場合、 @samp{git checkout} は @samp{HEAD} も更新して、指定されたブランチを現在のブランチとして設定します。

@table @asis

@item  @samp{git checkout [<branch>]} 
@samp{<branch>} での作業の準備をするために、インデックスと作業ツリーのファイルを更新し、 @samp{HEAD} をブランチに向けることで、@samp{<branch>} に切り替わります。作業ツリーのファイルに対するローカルな変更は保持され、 @samp{<branch>} にコミットできるようになります。

@samp{<branch>} が見つからないが、一致する名前を持つ1つのリモート(@samp{<remote>} と呼びます)に追跡ブランチが存在し、` --no-guess` が指定されていない場合は、以下と同等として扱います

@example
$ git checkout -b <branch> --track <remote>/<branch>
@end example


あなたは @samp{<branch>} を省略できます。この場合、コマンドは「現在のブランチをチェックアウトする」ことになり、(もし存在すれば)現在のブランチの追跡情報だけを表示するという、かなり高価な副作用のある、見栄えの良いノー・オペレーション(no-op)となります。

@item  @emph{git checkout} -b|-B <new-branch> [<start-point>] 
@samp{-b} を指定すると、git-branch(1) が呼び出されてチェックアウトされたかのように新しいブランチが作成されます。 この場合、 @samp{git branch} に渡される @samp{--track} または @samp{--no-track} オプションを使用できます。便利にするために @samp{-b} のない @samp{--track} はブランチの作成を意味します。後述の @samp{--track} の説明を参照してください。

@samp{-B} を指定すると、存在しない場合は @samp{<new-branch>} が作成されます。 それ以外の場合はリセットされます。これは、以下の取引(transaction)と同等です

@example
$ git branch -f <branch> [<start-point>]
$ git checkout <branch>
@end example


つまり、 @samp{git checkout} が成功しない限り、ブランチは リセット/作成 されません。

@item  @samp{git checkout --detach [<branch>]} 
@itemx  @samp{git checkout [--detach] <commit>} 
@samp{<commit>} の上で作業する準備をします。その上で、 @samp{HEAD} を切り離し(「DETACHED HEAD」セクションを参照)、作業ツリーのインデックスとファイルを更新します。 作業ツリー内のファイルへのローカルの変更は保持されるため、結果の作業ツリーは、コミットに記録された状態と、ローカルの変更になります。

@samp{<commit>} 引数がブランチ名の場合、 @samp{--detach} オプションを使用して、ブランチの先端にある @samp{HEAD} をデタッチできます(@samp{git checkout <branch>} は、 @samp{HEAD} をデタッチせずにそのブランチをチェックアウトします)。

@samp{<branch>} を省略すると、現在のブランチの先端にある @samp{HEAD} が切り離されます。

@item  @samp{git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...} 
@itemx  @samp{git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]} 
pathspecにマッチするファイルの内容を上書きします。 @samp{<tree-ish>} (ほとんどの場合コミット)が指定されていない場合は、作業ツリーをインデックスの内容で上書きします。 @samp{<tree-ish>} が指定された場合、インデックスと作業ツリーの両方を @samp{<tree-ish>} の内容で上書きします。

以前にマージに失敗したため、インデックスがマージされていないエントリを含んでいる可能性があります。デフォルトでは、インデックスからそのようなエントリをチェックアウトしようとすると、チェックアウト操作は失敗し、何もチェックアウトされません。 @samp{-f} を使用すると、これらのマージされていないエントリは無視されます。マージの特定の側からのコンテンツは、 @samp{--ours} または @samp{--theirs} を使用してインデックスからチェックアウトできます。 @samp{-m} を使用すると、作業ツリーファイルに加えられた変更を破棄して、元の競合するマージ結果を再作成できます。

@item  @samp{git checkout (-p|--patch) [<tree-ish>] [--] [<pathspec>...]} 
これは以前のモードと似ていますが、対話的インターフェイスを使用して「diff」出力を表示し、その結果において使用するハンクを選択できます。 @samp{--patch} オプションの説明については、以下を参照してください。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。フィードバックメッセージを抑制します。

@item  @samp{--progress} 
@itemx  @samp{--no-progress} 
@samp{--quiet} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、 @samp{--quiet} に関係なく、端末に接続されていない場合でも進行状況のレポートを有効にします。

@item  @samp{-f} 
@itemx  @samp{--force} 
ブランチを切り替えるとき、インデックスや作業ツリーが @samp{HEAD} と異なっていても、また、邪魔な未追跡のファイルがあっても進行します。 これは、ローカルの変更や、邪魔な未追跡のファイルやディレクトリを捨てるために使用します。

インデックスからパスをチェックアウトするときは、マージされていないエントリでエラーにしないでください。代わりに、マージされていないエントリは無視されます。

@item  @samp{--ours} 
@itemx  @samp{--theirs} 
インデックスからパスをチェックアウトするときは、ステージ#2(@samp{ours})または#3(@samp{theirs})でマージされていないパスをチェックアウトしてください。

注意: @samp{git rebase} と @samp{git pull --rebase} での作業中、「ours」と「theirs」が入れ替わっているように見える場合があることに注意してください。 @samp{--ours} は、変更がリベースされるブランチからのバージョンを提供し、 @samp{--theirs} は、リベースされる作業を保持するブランチからのバージョンを提供します。

これは、リモートでの履歴を共有の正規の履歴として扱うワークフローで @samp{rebase} が使用されているためです。リベースするブランチで行われた作業を、統合されるサードパーティの作業として扱います。そして、あなたは一時的にリベース中に正規の歴史の管理者の役割を引き受けています。正規の履歴の管理者として、リモートからの履歴を「私たち」(ours; つまり、「私達の共有された正規の履歴」)として表示する必要があり、サイドブランチで行ったことは「彼ら」(theirs;つまり「その上での貢献者の作品」)として表示する必要があります。

@item  @samp{-b <new-branch>} 
Create a new branch named @samp{<new-branch>}, start it at @samp{<start-point>}, and check the resulting branch out; see git-branch(1) for details.

@item  @samp{-B <new-branch>} 
Creates the branch @samp{<new-branch>}, start it at @samp{<start-point>}; if it already exists, then reset it to @samp{<start-point>}. And then check the resulting branch out. This is equivalent to running "git branch" with "-f" followed by "git checkout" of that branch; see git-branch(1) for details.

@item  @samp{-t} 
@itemx  @samp{--track[=(direct|inherit)]} 
新しいブランチを作成するときは、「アップストリーム構成」(upstream configuration)をセットアップします。 詳細については、 git-branch(1)の @samp{--track} を参照してください。

@samp{-b`オプションが指定されていない場合、新しいブランチの名前は、対応するリモート用に構成されたrefspecのローカル部分を調べ、最初の部分を `*} まで削除することにより、リモート追跡ブランチから派生させます。これにより、 @samp{origin/hack} (または @samp{remotes/origin/hack}、 あるいは @samp{refs/remotes/origin/hack}) から分岐するときに、ローカルブランチとして @samp{hack} を使用するように指示されます。指定された名前にスラッシュ(@samp{/})がない場合、または上記の推測の結果が空の名前になる場合、推測は中止されます。このような場合は、 @samp{-b} を使用して明示的に名前を付けることができます。

@item  @samp{--no-track} 
@samp{branch.autoSetupMerge} 構成変数がtrueであっても、「アップストリーム構成」を設定しないでください。

@item  @samp{--guess} 
@itemx  @samp{--no-guess} 
`<branch>`が見つからないが、名前が一致する1つのリモート( `<remote>`と呼びます)に追跡ブランチが存在する場合は、以下と同等としてあつかいます

@example
$ git checkout -b <branch> --track <remote>/<branch>
@end example


ブランチが複数のリモートに存在し、そのうちの1つが @samp{checkout.defaultRemote} 構成変数で名付けられている場合、 @samp{<branch>} がすべてのリモートで一意でなくても、曖昧さ回避の目的でそのブランチを使用します。例えば @samp{checkout.defaultRemote=origin} と設定すると、 @samp{<branch>} があいまいだが @samp{origin} リモート上に存在する場合、常にそこからリモートブランチをチェックアウトします。 git-config(1) の @samp{checkout.defaultRemote} も参照してください。

@samp{--guess} がデフォルトの振る舞いです。無効にするには、 @samp{--no-guess} を使用します。

デフォルトの振る舞いは、@samp{checkout.guess} 構成変数を介して設定できます。

@item  @samp{-l} 
新しいブランチのreflogを作成します。詳細については、 git-branch(1) を参照してください。

@item  @samp{-d} 
@itemx  @samp{--detach} 
ブランチをチェックアウトして作業するのではなく、検査と破棄可能な実験のためのコミットをチェックアウトします。 これは、 @samp{<commit>} がブランチ名でない場合の、 @samp{git checkout <commit>} のデフォルトの動作です。 詳細については、以下の「DETACHED HEAD」セクションを参照してください。

@item  @samp{--orphan <new-branch>} 
@samp{<start-point>} から開始された @samp{<new-branch>} という名前の新しい「孤立した」(orphan) ブランチを作成し、それに切り替えます。 この新しいブランチで行われた最初のコミットには親がなく、他のすべてのブランチとコミットから完全に切断された新しい履歴のルートになります。

インデックスと作業ツリーは、以前に @samp{git checkout <start-point>} を実行した場合と同じように調整されます。これにより、 ルート(root)をコミットするために容易に @samp{git commit -a} 実行をでき、 @samp{<start-point>} と同様のパスのセットを記録する新しい履歴を開始できます。

これは、ツリーの完全な履歴を公開せずにコミットからツリーを公開する場合に便利です。これは、現在のツリーが「クリーン」であるが、完全な履歴にはプロプライエタリなコードやその他の邪魔なコードが含まれているプロジェクトの、オープンソースブランチを公開するためにこれを行うことができます。

@samp{<start-point>} のパスとはまったく異なるパスのセットを記録する切断された履歴を開始する場合は、 作業ツリーの最上位から @samp{git rm -rf .} を実行して、 孤立したブランチ(orphan branch)を作成した直後にインデックスと作業ツリーをクリアする必要があります。 その後に、 新しいファイルを準備したり、 作業ツリーを再作成したり、 他の場所からファイルをコピーしたり、 tarballを抽出したりする準備が整います。

@item  @samp{--ignore-skip-worktree-bits} 
スパースチェックアウトモード(sparse checkout mode)では、 @samp{git checkout -- <paths>} は、 @samp{<paths>} と一致するエントリと、 @samp{$GIT_DIR/info/sparse-checkout} のスパースパターン(sparse patterns)のみを更新します。このオプションは、スパースパターンを無視し、 @samp{<paths>} 内のファイルを追加し直します。

@item  @samp{-m} 
@itemx  @samp{--merge} 
ブランチを切り替えるときに、現在のブランチと切り替え先のブランチの間で異なる1つ以上のファイルにローカルの変更がある場合、コマンドは、コンテキストでの変更を保持するためにブランチの切り替えを拒否します。ただし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、および新しいブランチの間の3方向のマージを実行してから新しいブランチに移動します。

マージの競合が発生すると、競合するパスのインデックスエントリはマージされないままになります。競合を解決し、解決されたパスを @samp{git add}（またはマージによってパスが削除される場合は @samp{git rm})でマークする必要があります。

インデックスからパスをチェックアウトする場合、このオプションを使用すると、指定したパスで競合するマージを再作成できます。

@samp{--merge} でブランチを切り替えると、ステージされた変更が失われる可能性があります。

@item  @samp{--conflict=<style>} 
上記の @samp{--merge} オプションと同一ですが、競合するハンクの表示方法を変更し、 @samp{merge.conflictStyle} 構成変数をオーバーライドします。 可能な値は @samp{merge}(デフォルト)と @samp{diff3} と @samp{zdiff3} です。

@item  @samp{-p} 
@itemx  @samp{--patch} 
@samp{<tree-ish>} (または指定されていない場合はインデックス)と作業ツリーの間の差分でハンクを対話的に選択します。選択されたハンクは、作業ツリー(@samp{<tree-ish>} が指定されている場合はインデックス)に逆に適用されます。

これは、 @samp{git checkout -p} を使用して、現在の作業ツリーから編集を選択的に破棄できることを意味します。 @samp{--patch} モードの操作方法については、 git-add(1) の「Interactive Mode」セクションを参照してください。

注意: このオプションはデフォルトでオーバーレイなしモードを使用します(@samp{--overlay} も参照)。現在はオーバーレイモードをサポートしていないことに注意してください。

@item  @samp{--ignore-other-worktrees} 
@samp{git checkout} は、必要なrefが別のワークツリーによってすでにチェックアウトされている場合に拒否します。このオプションを使用すると、とにかくrefをチェックアウトできます。つまり、refを複数のワークツリーで保持できます。

@item  @samp{--overwrite-ignore} 
@itemx  @samp{--no-overwrite-ignore} 
ブランチを切り替えるときに、無視したファイルを黙って上書きします。これがデフォルトの動作です。新しいブランチに無視したファイルが含まれている場合に操作を中止するには、 @samp{--no-overwrite-ignore} を使用します。

@item  @samp{--recurse-submodules} 
@itemx  @samp{--no-recurse-submodules} 
@samp{--recurse-submodules} を使用すると、スーパープロジェクトに記録されたコミットに従って、すべてのアクティブなサブモジュールのコンテンツが更新されます。サブモジュールのローカル変更が上書きされる場合、 @samp{-f} が使用されない限り、チェックアウトは失敗します。何も使用されていない場合(または @samp{--no-recurse-submodules})、サブモジュールの作業ツリーは更新されません。 git-submodule(1) と同様に、これはサブモジュールの @samp{HEAD} を切り離します(detach)。

@item  @samp{--overlay} 
@itemx  @samp{--no-overlay} 
デフォルトのオーバーレイモードでは、 @samp{git checkout} がインデックスまたは作業ツリーからファイルを削除することはありません。 @samp{--no-overlay} を指定すると、インデックスと作業ツリーには表示されるが、 @samp{<tree-ish>} には表示されないファイルが削除され、 @samp{<tree-ish>} と完全に一致するようになります。

@item  @samp{--pathspec-from-file=<file>} 
pathspecは、コマンドライン引数の代わりに @samp{<file>} で渡されます。 @samp{<file>} が正確に @samp{-} の場合、標準入力が使用されます。pathspec要素は、LFまたはCR/LFで区切られます。pathspec要素は、構成変数 @samp{core.quotePath} で説明されているように、クォートできます(git-config(1) 参照)。 @samp{--pathspec-file-nul} および グローバル @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
`--pathspec-from-file`でのみ意味があります。Pathspec要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  <branch> 
チェックアウトするブランチ。もしそれがブランチ(つまり、 @samp{refs/heads/} を前につけたとき、有効なrefである名前)を参照しているなら、そのブランチはチェックアウトされます。そうでない場合、もしそれが有効なコミットを参照していれば、あなたの @samp{HEAD} は "detached" となり、あなたはもはやどのブランチにもいません(詳しくは以下を参照してください)。

@samp{@@@{-N@}} 構文を使用して、 @samp{git checkout `操作を使用してチェックアウトされた最後からN番目ブランチ/コミットを参照できます。 `@@@{-1@}} と同義の @samp{-} を指定することもできます。

特殊なケースとして、マージベースが1つしかない場合は、 @samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 最大で @samp{A} と @samp{B} のどちらかを省略できます。その場合、デフォルトで @samp{HEAD} になります。

@item  <new-branch> 
新しいブランチの名前。

@item  <start-point> 
新しいブランチを開始するコミットの名前。詳細については、 git-branch(1) を参照してください。デフォルトは @samp{HEAD} です。

特殊なケースとして、マージベースが1つしかない場合は、 @samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 最大で @samp{A} と @samp{B} のどちらかを省略できます。その場合、デフォルトで @samp{HEAD} になります。

@item  <tree-ish> 
チェックアウト元のツリー(パスが指定されている場合)。指定しない場合はインデックスが使用されます。

特殊なケースとして、マージベースが1つしかない場合は、 @samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 最大で @samp{A} と @samp{B} のどちらかを省略できます。その場合、デフォルトで @samp{HEAD} になります。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <pathspec>… 
操作の影響を受けるパスを制限します。

詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading DETACHED HEAD

@samp{HEAD} は通常、名前付きブランチ(@samp{master} など)を指します。一方、各ブランチは特定のコミットを参照します。3つのコミットがあり、そのうちの1つがタグ付けされており、ブランチ`master` がチェックアウトされているリポジトリを見てみましょう:

@example
           HEAD (refers to branch 'master')
            |
            v
a---b---c  branch 'master' (refers to commit 'c')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


この状態でコミットが作成されると、新しいコミットを参照するようにブランチが更新されます。 具体的には、 @samp{git commit} は、親がコミット @samp{c} である新しいコミット @samp{d} を作成し、ブランチ @samp{master} を更新して新しい コミット @samp{d} を参照します。 @samp{HEAD} はまだブランチ @samp{master} を参照しているので、間接的に コミット @samp{d} を参照するようになりました:

@example
$ edit; git add; git commit

               HEAD (refers to branch 'master')
                |
                v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


名前付きブランチの先端にないコミットをチェックアウトしたり、名前付きブランチによって参照されていない新しいコミットを作成したりできると便利な場合があります。 コミット @samp{b} をチェックアウトするとどうなるか見てみましょう(ここでは、これを行う2つの方法を示します):

@example
$ git checkout v2.0  # or
$ git checkout master^^

   HEAD (refers to commit 'b')
    |
    v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


使用するcheckoutコマンドに関係なく、 @samp{HEAD} はコミット @samp{b} を直接参照するようになりました。 これは、切り離された @samp{HEAD} (detached HEAD)状態にあることとして知られています。これは、名前付きブランチを参照するのではなく、単に @samp{HEAD} が特定のコミットを参照することを意味します。この状態でコミットを作成するとどうなるか見てみましょう:

@example
$ edit; git add; git commit

     HEAD (refers to commit 'e')
      |
      v
      e
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


新しいコミット @samp{e} がありますが、これは @samp{HEAD} によってのみ参照されます。 もちろん、この状態でさらに別のコミットを追加できます:

@example
$ edit; git add; git commit

         HEAD (refers to commit 'f')
          |
          v
      e---f
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


実際、私達は通常のGit操作はすべて実行できます。 しかし、ここで私達が @samp{master} をチェックアウトするとどうなるか見てみましょう:

@example
$ git checkout master

               HEAD (refers to branch 'master')
      e---f     |
     /          v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
@end example


この時点で、コミット @samp{f} を指しているものは何もないことを理解することが重要です。最終的に、コミット @samp{f} (および拡張によりコミット @samp{e} )は、あなたがルーチンのGitガベージコレクションプロセス前に参照を作成しない限り、ルーチンのGitガベージコレクションプロセスによって削除されます。あなたが、まだコミット`f`から離れていない場合、以下のいずれかがそれへの参照を作成します:

@example
$ git checkout -b foo  # or "git switch -c foo"  (1)
$ git branch foo                                 (2)
$ git tag foo                                    (3)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
コミット @samp{f} を参照する新しいブランチ @samp{foo} を作成し、次にブランチ @samp{foo} を参照するように`HEAD`を更新します。つまり、このコマンドを実行すると、もはや切り離された`HEAD` (detached HEAD)状態では無くなります。

@item @pxref{CO1-2,,(2)}
同様に、コミット @samp{f} を参照する新しいブランチ @samp{foo} を作成しますが、 @samp{HEAD} は切り離されたままにします。

@item @pxref{CO1-3,,(3)}
新しいタグ @samp{foo} を作成します。これは、@samp{HEAD} を切り離したままコミット @samp{f} を参照します。
@end table

私達がうっかり @samp{f} から離れてしまった場合は、最初にそのオブジェクト名を回復する必要があり(通常は @samp{git reflog} を使用)、次にそれへの参照を作成できます。 たとえば、 @samp{HEAD} が参照した最後の2つのコミットを確認するには、以下のいずれかのコマンドを使用できます:

@example
$ git reflog -2 HEAD # or
$ git log -g -2 HEAD
@end example


@noindent

@chapheading ARGUMENT DISAMBIGUATION(引数の曖昧性解消)

与えられた引数が1つだけで、それが @samp{--} ではない場合(例: @samp{git checkout abc})や、引数が有効な @samp{<tree-ish>} (例:ブランチ @samp{abc} が存在する)や、有効な @samp{<pathspec>} (たとえば、 "abc" という名前のファイルまたはディレクトリが存在する)な場合、Gitは通常、明確にするように求めます。ただし、ブランチのチェックアウトは非常に一般的な操作であるため、このような状況では、 @samp{git checkout abc} は "abc" を @samp{<tree-ish>} と見なします。これらのパスをインデックスからチェックアウトする場合は、 @samp{git checkout -- <pathspec>} を使用します。

@noindent

@chapheading EXAMPLES

@noindent

@heading 1. Paths

以下のシーケンスは、 @samp{master} ブランチをチェックアウトし、 @samp{Makefile} のリビジョンを2つ戻し、誤って @samp{hello.c} を削除したので、 @samp{hello.c} をインデックスから取得します。

@example
$ git checkout master             (1)
$ git checkout master~2 Makefile  (2)
$ rm -f hello.c
$ git checkout hello.c            (3)
@end example


@table @asis

@item @pxref{CO2-1,,(1)}
ブランチを切り替えます

@item @pxref{CO2-2,,(2)}
別のコミットからファイルを取り出します

@item @pxref{CO2-3,,(3)}
インデックスから @samp{hello.c} を復元します
@end table

あなたがインデックスから「すべての」Cソースファイルをチェックアウトしたい場合は、以下のように言うことができます

@example
$ git checkout -- '*.c'
@end example


@samp{*.c} を囲む引用符に注意してください。 ファイル @samp{hello.c} も、作業ツリーに存在していなくてもチェックアウトされます。これは、(引用符で囲む事で作業ツリーに対してシェル展開するのではなくて)ファイルグロブがインデックスのエントリを照合するために使用されるためです。

@samp{hello.c} という名前の不幸なブランチがある場合、このステップはそのブランチに切り替えるための指示として混乱を産みます。あなたは代わりに以下のように書く必要があります。

@example
$ git checkout -- hello.c
@end example


@noindent

@heading 2. Merge

間違ったブランチで作業した後、正しいブランチへの切り替えは以下を使用して行います:

@example
$ git checkout mytopic
@end example


ただし、あなたの「間違った」ブランチと正しい @samp{mytopic} ブランチは、ローカルで変更したファイルで異なる場合があります。その場合、上記のチェックアウトは以下のように失敗します:

@example
$ git checkout mytopic
error: You have local changes to 'frotz'; not switching branches.
@end example


コマンドに @samp{-m} フラグを指定すると、3方向のマージを試みます:

@example
$ git checkout -m mytopic
Auto-merging frotz
@end example


この3方向マージの後、ローカルの変更はインデックスファイルに登録されないため、 @samp{git diff} は、新しいブランチの先端以降に行った変更を表示します。

@noindent

@heading 3. Merge conflict

@samp{-m} オプションを使用してブランチを切り替えるときにマージの競合が発生すると、以下のように表示されます:

@example
$ git checkout -m mytopic
Auto-merging frotz
ERROR: Merge conflict in frotz
fatal: merge program failed
@end example


この時点で、 @samp{git diff} は、前の例のようにきれいにマージされた変更と、競合するファイルの変更を示しています。 競合を編集して解決し、通常どおり @samp{git add} で解決済みのマークを付けます。

@example
$ edit frotz
$ git add frotz
@end example


@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  checkout.defaultRemote 
@samp{git checkout <something>} または @samp{git switch <something>} を実行し、リモートが1つしかない場合、 @samp{origin/<something>} のチェックアウトと追跡に暗黙的にフォールバックする可能性があります。 @samp{<something>} 参照を持つリモートが複数あるとすぐに動作しなくなります。 この設定により、曖昧性解消に関して常に勝利させる優先リモートの名前を設定できます。 典型的なユースケースは、これを @samp{origin} に設定することです。

現在、これは git-switch(1) と git-checkout(1) によって、@samp{git checkout <something>} や @samp{git switch <something>} が別のリモート上の @samp{<something>} ブランチをチェックアウトするときに使われています。また git-worktree(1) は @samp{git worktree add} がリモートブランチを参照しているときに使われています。 この設定は、将来、他のチェックアウトのようなコマンドまたは機能に使用される可能性があります。

@item  checkout.guess 
@samp{git checkout} と @samp{git switch} の、 @samp{--guess} または @samp{--no-guess} オプションのデフォルト値を提供します。 git-switch(1) および git-checkout(1) を参照してください。

@item  checkout.workers 
作業ツリーを更新するときに使用する並列ワーカーの数。デフォルトは1、つまり順次実行です。 1未満の値に設定すると、Gitは使用可能な論理コアの数と同じ数のワーカーを使用します。 この設定と @samp{checkout.thresholdForParallelism} は、チェックアウトを実行するすべてのコマンドに影響します。 例えば、 checkout, clone, reset, sparse-checkout, などです。

注意: 並列チェックアウトは通常、SSDまたはNFS上にあるリポジトリのパフォーマンスを向上させます。 回転するディスクやコアの数が少ないマシン上のリポジトリの場合、デフォルトのシーケンシャルチェックアウトの方がパフォーマンスが向上することがよくあります。 リポジトリのサイズと圧縮レベルも、並列バージョンのパフォーマンスに影響を与える可能性があります。

@item  checkout.thresholdForParallelism 
少数のファイルで並列チェックアウトを実行する場合、サブプロセスの生成とプロセス間通信のコストが並列化のメリットを上回る可能性があります。 この設定により、並列チェックアウトを試行する必要のあるファイルの最小数を定義できます。 デフォルトは100です。
@end table

@noindent

@chapheading SEE ALSO

git-switch(1), git-restore(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cherry-pick,,,Top
@chapheading Name

git-cherry-pick — いくつかの既存のコミットによって導入された変更を適用します

@noindent

@chapheading Synopsis

@display
git cherry-pick [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]
                  [-S[<keyid>]] <commit>…
git cherry-pick (--continue | --skip | --abort | --quit)
@end display


@noindent

@chapheading DESCRIPTION

1つ以上の既存のコミットが与えられた場合、それぞれが導入する変更を適用し、それぞれに新しいコミットを記録します。 これには、作業ツリーがクリーン(HEADコミットが編集中でない)である必要があります。

変更を適用する方法が明確でない場合、以下のようになります:

@enumerate 

@item
現在のブランチと @samp{HEAD} ポインタは、正常に行われた最後のコミットに留まります。

@item
@samp{CHERRY_PICK_HEAD} refは、適用が難しい変更を導入したコミットを指すように設定されています。

@item
変更がクリーンに適用されたパスは、インデックスファイルとあなたの作業ツリーの両方で更新されます。

@item
競合するパスの場合、git-merge(1) の「TRUE MERGE」セクションで説明されているように、インデックスファイルには最大3つのバージョンが記録されます。 作業ツリーファイルには、通常の競合マーカー @samp{<<<<<<<} および @samp{>>>>>>>} で囲まれた競合の説明が含まれます。

@item
その他の変更は行われません。
@end enumerate

このような競合を解決するための幾つかのヒントについては、 git-merge(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  <commit>… 
チェリーピックにコミットします。 コミットを綴る方法のより完全なリストについては、 gitrevisions(7) を参照してください。 コミットのセットを渡すことはできますが、デフォルトでは、 @samp{--no-walk} オプションが指定されているかのように振る舞い、トラバーサルは実行されません。 git-rev-list(1) を参照してください。 範囲を指定すると、すべての @samp{<commit>...} 引数が単一のリビジョンウォークに送られることに注意してください(@samp{maint master..next} を使用するk後述する例を参照してください)。

@item  @samp{-e} 
@itemx  @samp{--edit} 
このオプションを使用すると、 @samp{git cherry-pick} を使用してコミットする前にコミットメッセージを編集できます。

@item  @samp{--cleanup=<mode>} 
このオプションは、コミットメッセージがコミット機構に渡される前にどのようにクリーンアップされるかを決定します。 詳細については、 git-commit(1) を参照してください。 特に、 @samp{<mode>} に @samp{scissors} の値が指定されている場合、競合が発生した場合に渡される前に、切り取り線 が @samp{MERGE_MSG} に追加されます。

@item  @samp{-x} 
コミットを記録するときは、"(cherry picked from commit …)" という行を元のコミットメッセージに追加して、この変更がどのコミットからチェリーピックされたかを示します。 これは、競合のないチェリーピックに対してのみ行われます。 情報が受信者にとって役に立たないため、プライベートブランチからチェリーピッキングをしている場合は、このオプションを使用しないでください。 一方、公開されている2つのブランチ間を選択している場合(たとえば、開発ブランチからの古いリリースのメンテナンスブランチへの修正をバックポートする場合)、この情報を追加すると便利です。

@item  @samp{-r} 
以前は、コマンドはデフォルトで上記の @samp{-x} を実行し、 @samp{-r} はそれを無効にすることでした。 現在、デフォルトでは @samp{-x} を実行しないため、このオプションは何もしません。

@item  @samp{-m <parent-number>} 
@itemx  @samp{--mainline <parent-number>} 
マージのどちら側をメインラインと見なすべきかわからないため、通常、マージを選択することはできません。 このオプションは、メインラインの親番号(1から始まる)を指定し、cherry-pickが指定された親に関連する変更を再実行(replay)できるようにします。

@item  @samp{-n} 
@itemx  @samp{--no-commit} 
通常、コマンドはコミットのシーケンスを自動的に作成します。 このフラグは、コミットを行わずに、名前付きの各コミットを作業ツリーとインデックスにチェリーピックするために必要な変更を適用します。 さらに、このオプションを使用する場合、インデックスはHEADコミットと一致する必要はありません。 チェリーピックは、インデックスの開始状態に対して行われます。

これは、インデックスへの複数のコミットの効果を連続して選択する場合に便利です。

@item  @samp{-s} 
@itemx  @samp{--signoff} 
コミットメッセージの最後に @samp{Signed-off-by} トレーラーを追加します。 詳細については、git-commit(1) のsignoffオプションを参照してください。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミット。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに固定する必要があります。 @samp{--no-gpg-sign} は、 @samp{commit.gpgSign} 構成変数と以前の @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{--ff} 
現在のHEADが、チェリーピックされたコミットの親と同じである場合、このコミットへの早送り(fast forward)が実行されます。

@item  @samp{--allow-empty} 
デフォルトでは、空のコミットのチェリーピックは失敗し、 @samp{git commit --allow-empty} の明示的な呼び出しが必要であることを示します。 このオプションはその動作をオーバーライドし、空のコミットをチェリーピックに自動的に保存できるようにします。 @samp{--ff} が有効な場合、「早送り」要件を満たす空のコミットは、このオプションがなくても保持されることに注意してください。 注意: また、このオプションを使用すると、最初は空だったコミット(つまり、親と同じツリーを記録していたコミット)だけが保持されることに注意してください。以前のコミットのために空にされたコミットはドロップされます。 これらのコミットを強制的に含めるには、 @samp{--keep-redundant-commits} を使用します。

@item  @samp{--allow-empty-message} 
デフォルトでは、空のメッセージでコミットをチェリーピックすると失敗します。 このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをチェリーピックできるようにします。

@item  @samp{--keep-redundant-commits} 
チェリーピックされているコミットが現在の履歴にすでにあるコミットと重複している場合、そのコミットは空になります。 デフォルトでは、これらの冗長なコミットにより @samp{cherry-pick} が停止するため、ユーザーはコミットを調べることができます。 このオプションはその動作をオーバーライドし、空のコミットオブジェクトを作成します。 @samp{--allow-empty} の指定含んでいます。

@item  @samp{--strategy=<strategy>} 
指定のマージ戦略を使用します。複数回指定できません。 詳細については、 git-merge(1) の「MERGE STRATEGIES」セクションを参照してください。

@item  @samp{-X<option>} 
@itemx  @samp{--strategy-option=<option>} 
マージ戦略固有のオプションをマージ戦略に渡します。 詳細については、 git-merge(1) を参照してください。

@item  @samp{--rerere-autoupdate} 
@itemx  @samp{--no-rerere-autoupdate} 
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 @samp{--no-rerere-autoupdate} は、別の @samp{git add} で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。
@end table

@noindent

@chapheading SEQUENCER SUBCOMMANDS

@table @asis

@item  @samp{--continue} 
@samp{.git/sequencer} の情報を使用して、進行中の操作の続行を行います。失敗したcherry-pickまたはrevertの競合を解決した後、続行するために使用できます。

@item  @samp{--skip} 
現在のコミットをスキップして、残りのシーケンスを続行します。

@item  @samp{--quit} 
進行中の今回の操作を忘れてください。チェリーピックまたはrevertに失敗した後、シーケンサーの状態をクリアするために使用できます。

@item  @samp{--abort} 
操作をキャンセルして、シーケンス操作前の状態に戻ります。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git cherry-pick master} 
masterブランチの先端でコミットによって導入された変更を適用し、その変更で新しいコミットを作成します。

@item  @samp{git cherry-pick ..master} 
@itemx  @samp{git cherry-pick ^HEAD master} 
masterの祖先であるがHEADの祖先ではないすべてのコミットによって導入された変更を適用して、新しいコミットを生成します。

@item  @samp{git cherry-pick maint next ^master} 
@itemx  @samp{git cherry-pick maint master..next} 
maintまたはnextの祖先であるが、masterまたはその祖先のいずれでもないすべてのコミットによって導入された変更を適用します。 後者は @samp{maint} と @samp{master} と @samp{next} の間のすべてを意味するものではないことに注意してください。 具体的には、 @samp{master} に含まれている場合は @samp{maint} は使用されません。

@item  @samp{git cherry-pick master~4 master~2} 
masterが指す最後から5番目と3番目のコミットによって導入された変更を適用し、これらの変更を使用して2つの新しいコミットを作成します。

@item  @samp{git cherry-pick -n master~1 next} 
作業ツリーとインデックスに、masterが指す最後から2番目のコミットとnextが指す最後のコミットによって導入された変更を適用しますが、これらの変更でコミットを作成しないでください。

@item  @samp{git cherry-pick --ff ..next} 
履歴が線形で、HEADがnextの祖先である場合は、作業ツリーを更新し、HEADポインターをnextに一致するように進めます。 それ以外の場合は、次のコミットで導入された変更を現在のブランチに適用し、新しい変更ごとに新しいコミットを作成します。

@item  @samp{git rev-list --reverse master -- README | git cherry-pick -n --stdin} 
READMEにアクセスしたmasterブランチのすべてのコミットによって導入された変更を作業ツリーとインデックスに適用します。これにより、結果を検査して、必要に応じて1つの新しいコミットにすることができます。
@end table

以下のシーケンスは、パッチのバックポートを試み、パッチが適用されるコードが大幅に変更されたためにベイルアウト(脱出; git reste)してから、再試行します。今度は、コンテキスト行の一致にさらに注意を払います。

@example
$ git cherry-pick topic^             (1)
$ git diff                           (2)
$ git cherry-pick --abort            (3)
$ git cherry-pick -Xpatience topic^  (4)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
@samp{git show topic^} で表示される変更を適用します。 この例では、パッチが適切に適用されないため、競合に関する情報がインデックスと作業ツリーに書き込まれ、新しいコミット結果はありません。

@item @pxref{CO1-2,,(2)}
調停する変更を要約します

@item @pxref{CO1-3,,(3)}
チェリーピックをキャンセルします。 つまり、作業ツリーで行ったローカルの変更を保持したまま、チェリーピック前の状態に戻ります。

@item @pxref{CO1-4,,(4)}
より多くの時間のを費やして、 @samp{topic^} によって導入された変更を再度適用し、コンテキスト行の誤った一致に基づく間違いを避けようと試みます。
@end table

@noindent

@chapheading SEE ALSO

git-revert(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cherry,,,Top
@chapheading Name

git-cherry — アップストリームにまだ適用されていないコミットを検索する

@noindent

@chapheading Synopsis

@display
git cherry [-v] [<upstream> [<head> [<limit>]]]
@end display


@noindent

@chapheading DESCRIPTION

@samp{<head>..<upstream>} に @samp{<limit>..<head>} の範囲と同等のコミットがあるかどうかを検査(determine)します。

等価性テストは、空白と行番号を削除した後のdiffに基づいています。したがって、git-cherry は、 git-cherry-pick(1) または git-am(1) または git-rebase(1) を使用してコミットが「コピー」された時に検出します。

@samp{<limit>..<head>} の範囲のすべてのコミットのSHA1を出力し、 <upstream> に同等のものがあるコミットの場合は @samp{-} を接頭辞として付け、そうでないコミットの場合は @samp{+} を接頭辞として付けます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
SHA1の横にコミット件名(commit subject)を表示します。

@item  <upstream> 
同等のコミットを検索するためのアップストリームブランチ。デフォルトはHEADのアップストリームブランチです。

@item  <head> 
作業ブランチ。デフォルトはHEADです。

@item  <limit> 
コミットをlimitまで(limitを含む)報告しないでください。
@end table

@noindent

@chapheading EXAMPLES

@noindent

@heading Patch workflows

git-cherryは、パッチベースのワークフロー(gitworkflows(7) 参照)で頻繁に使用され、一連のパッチがアップストリームメンテナによって適用されているかどうかを判断します。このようなワークフローでは、以下のようなトピックブランチを作成して送信できます:

@example
$ git checkout -b topic origin/master
# work and create some commits
$ git format-patch origin/master
$ git send-email ... 00*
@end example


後で、あなたは(まだ @samp{topic} に居る時に、)次のように言うことで、変更が適用されたかどうかを確認できます:

@example
$ git fetch  # update your notion of origin/master
$ git cherry -v
@end example


@noindent

@heading Concrete example

トピックが3つのコミットで構成され、メンテナがそのうちの2つを適用した状況では、状況は以下のようになります:

@example
$ git log --graph --oneline --decorate --boundary origin/master...topic
* 7654321 (origin/master) upstream tip commit
[... snip some other commits ...]
* cccc111 cherry-pick of C
* aaaa111 cherry-pick of A
[... snip a lot more that has happened ...]
| * cccc000 (topic) commit C
| * bbbb000 commit B
| * aaaa000 commit A
|/
o 1234567 branch point
@end example


このような場合、git-cherryはまだ適用されていないモノの簡潔な要約を示します:

@example
$ git cherry origin/master topic
- cccc000... commit C
+ bbbb000... commit B
- aaaa000... commit A
@end example


ここで、(@samp{-} でマークされている)コミットAとCは、 @samp{origin/master} のトップでリベースすると、トピックブランチから削除できますが、（@samp{+} でマークされている)コミットBは @samp{origin/master} にapplyするために送信されるために、まだ保持しつづける必要があります。

@noindent

@heading Using a limit

オプションの <limit> は、あなたのトピックがアップストリームにない他の作業に基づいている場合に役立ちます。前の例を拡張すると、これは以下のようになります:

@example
$ git log --graph --oneline --decorate --boundary origin/master...topic
* 7654321 (origin/master) upstream tip commit
[... snip some other commits ...]
* cccc111 cherry-pick of C
* aaaa111 cherry-pick of A
[... snip a lot more that has happened ...]
| * cccc000 (topic) commit C
| * bbbb000 commit B
| * aaaa000 commit A
| * 0000fff (base) unpublished stuff F
[... snip ...]
| * 0000aaa unpublished stuff A
|/
o 1234567 merge-base between upstream and topic
@end example


制限として @samp{base} を指定することで、 @samp{base} と @samp{topic} の間のコミットをリストすることを回避できます:

@example
$ git cherry origin/master topic base
- cccc000... commit C
+ bbbb000... commit B
- aaaa000... commit A
@end example


@noindent

@chapheading SEE ALSO

git-patch-id(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-citool,,,Top
@chapheading Name

git-citool — git-commitのグラフィカルな代替手段

@noindent

@chapheading Synopsis

@display
git citool
@end display


@noindent

@chapheading DESCRIPTION

Tcl/Tkベースのグラフィカルインターフェイス。変更されたファイルを確認し、それらをインデックスにステージングし、コミットメッセージを入力して、新しいコミットを現在のブランチに記録します。このインターフェースは、インタラクティブ性の低い’git commit’プログラムの代替手段です。

'git citool’は実際には`git gui citool`の標準エイリアスです。詳細については、git-gui(1)を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-clean,,,Top
@chapheading Name

git-clean — 作業ツリーから追跡されていないファイルを削除する

@noindent

@chapheading Synopsis

@display
git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

現在のディレクトリから開始して、バージョン管理下にないファイルを再帰的に削除することにより、作業ツリーをクリーンにします。

通常、Gitが追跡していないファイルのみが削除されますが、 @samp{-x} オプションが指定されている場合、無視されたファイル(ignored files)も削除されます。これは、たとえば、ビルドでの生成物全てを削除するのに役立ちます。

If any optional @samp{<pathspec>...} arguments are given, only those paths that match the pathspec are affected.

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-d} 
Normally, when no <pathspec> is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If a <pathspec> is specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under @samp{--force}) will be removed.

@item  @samp{-f} 
@itemx  @samp{--force} 
Git構成変数 clean.requireForce が false に設定されてい無い場合、「git clean」は、 @samp{-f} または @samp{-i} が指定されていない限り、ファイルまたはディレクトリの削除を拒否します。 2つ目の @samp{-f} が指定されていない限り、Gitは追跡されていないネストされたgitリポジトリ(.gitサブディレクトリを持つディレクトリ)の変更を拒否します。

@item  @samp{-i} 
@itemx  @samp{--interactive} 
何が行われるを示し、ファイルを対話的にクリーンアップします。 詳細は「Interactive mode」を参照してください。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際には何も削除せず、何が行われるかを表示します。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにして、エラーのみを報告し、正常に削除されたファイルは報告しないでください。

@item  @samp{-e <pattern>} 
@itemx  @samp{--exclude=<pattern>} 
標準の無視ルールに加えて、指定の除外パターンを使用します(gitignore(5) 参照)。

@item  @samp{-x} 
標準の無視ルール(gitignore(5) 参照)を使用しないでください。ただし、コマンドラインから @samp{-e} オプションを指定して指定された無視ルールは使用してください。これにより、ビルド生成物を含む、追跡されていないすべてのファイルを削除できます。これを使用して（おそらく「git restore」または「git reset」と組み合わせて）、ビルドをテストするためのクリーンな、元の作業ディレクトリを作成できます。

@item  @samp{-X} 
Gitによって無視されたファイルのみを削除します。これは、すべてを最初から再構築するのに役立つ場合がありますが、手動で作成したファイルは保持します。
@end table

@noindent

@chapheading Interactive mode

コマンドがinteractive modeに入ると、クリーンアップするファイルとディレクトリが表示され、インタラクティブコマンドループに入ります。

コマンドループは、使用可能なサブコマンドのリストを表示し、「Whatnow> 」というプロンプトを表示します。一般に、プロンプトが単一の「>」で終わる場合、以下のように、選択肢の1つだけを選択し、ENTERキーを押します:

@example
    *** Commands ***
        1: clean                2: filter by pattern    3: select by numbers
        4: ask each             5: quit                 6: help
    What now> 1
@end example


選択が一意である限り、上記は「c」または「clean」と打ち込む事もできます。

メインコマンドループには6つのサブコマンドがあります。

@table @asis

@item  clean 
ファイルとディレクトリのクリーニングを開始して、終了(quit)します。

@item  filter by pattern 
これにより、削除するファイルとディレクトリが表示され、「Input ignore patterns>>」(入力無視パターン)プロンプトが表示されます。スペースで区切られたパターンを入力して、ファイルとディレクトリを削除から除外できます。 例えば。 「* .c * .h」は、「.c」と「.h」で終わるファイルを削除から除外します。そして、結果に満足したら、ENTER を押してメインメニューに戻ります。

@item  select by numbers 
これにより、削除するファイルとディレクトリが表示され、「Select items to delete>>」(削除するアイテムを選択)というプロンプトが表示されます。プロンプトがこのように二重の「>>」で終わる場合、空白またはコンマで連結して複数の選択を行うことができます。また、あなたは範囲を伝えることができます。 例えば「2-57,9」でリストから2,3,4,5,7,9を選択します。範囲の2番目の数値を省略すると、残りのすべての項目が選択されます。 例えば「7-」はリストから7,8,9を選択します。「*」dで全てを選択できます。そして、結果に満足したら、ENTER を押してメインメニューに戻ります。

@item  ask each 
これはクリーニングが始まると、アイテムを削除するために一つずつ確認する必要があります。この操作は、上記の2つのアクションほど効率的ではないことに注意してください。

@item  quit 
これにより、クリーニングを行わずに終了(quit)できます。

@item  help 
git-cleanの対話的な簡単な使用法を示します。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  clean.requireForce 
@samp{-f} または @samp{-i} または @samp{-n} が指定されない限り、git-clean が何もしないようにするためのブール値です。
デフォルトは true です。
@end table

@noindent

@chapheading SEE ALSO

gitignore(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-clone,,,Top
@chapheading Name

git-clone — リポジトリを新しいディレクトリにクローン(複製)します

@noindent

@chapheading Synopsis

@display
git clone [--template=<template-directory>]
          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]
          [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]
          [--dissociate] [--separate-git-dir <git-dir>]
          [--depth <depth>] [--[no-]single-branch] [--no-tags]
          [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]
          [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]
          [--filter=<filter> [--also-filter-submodules]] [--] <repository>
          [<directory>]
@end display


@noindent

@chapheading DESCRIPTION

リポジトリを新しく作成されたディレクトリにクローン(clone;複製)し、複製されたリポジトリ内の各ブランチのリモート追跡ブランチを作成し(@samp{git branch --remotes} を使用して表示できます)、複製されたリポジトリの現在アクティブなブランチからフォークされた初期ブランチを作成してチェックアウトします。

クローン後、引数のない @samp{git fetch} は、すべてのリモート追跡ブランチを更新し、加えて、引数のない @samp{git pull} は、存在する場合、リモートのmasterブランチを現在のmasterブランチにマージします（これは、 @samp{--single-branch} が指定されている場合は当てはまりません。以下参照)。

このデフォルト設定は、 @samp{refs/remotes/origin} の下にリモートブランチヘッドへの参照を作成し、@samp{remote.origin.url} と @samp{remote.origin.fetch} 設定変数を初期化することによって実現されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-l} 
@itemx  @samp{--local} 
複製元のリポジトリがローカルマシン上にある場合、このフラグは通常の 「Git対応」転送メカニズムをバイパスし、オブジェクトおよびrefsディレクトリの下にあるHEADおよびすべてのコピーを作成することでリポジトリを複製します。 @samp{.git/objects/} ディレクトリの下のファイルは、可能な場合はスペースを節約するためにハードリンクされています。

リポジトリがローカルパス(例: @samp{/path/to/repo})として指定されている場合、これがデフォルトであり、 @samp{--local} は基本的に何も操作しません(no-op)です。 リポジトリがURLとして指定されている場合、このフラグは無視されます(ローカル最適化は使用されません)。 @samp{--no-local} を指定すると、 @samp{/path/to/repo} が指定されたときデフォルトが上書きされ、代わりに通常のGit転送が使用されます。

If the repository’s @samp{$GIT_DIR/objects} has symbolic links or is a symbolic link, the clone will fail. This is a security measure to prevent the unintentional copying of files by dereferencing the symbolic links.

@strong{NOTE}: this operation can race with concurrent modification to the
source repository, similar to running @samp{cp -r src dst} while modifying
@samp{src}.

@item  @samp{--no-hardlinks} 
ハードリンクを使用する代わりに、ローカルファイルシステム上のリポジトリからのクローン作成プロセスで、ファイルを @samp{.git/objects} ディレクトリの下にコピーするように強制します。 これは、リポジトリのバックアップを作成しようとしている場合に望ましい場合があります。

@item  @samp{-s} 
@itemx  @samp{--shared} 
クローンを作成するリポジトリがローカルマシン上にある場合、ハードリンクを使用する代わりに、オブジェクトをソースリポジトリと共有するように @samp{.git/objects/info/alternates} を自動的に設定します。 結果のリポジトリは、独自のオブジェクトなしで開始されます。

@quotation

@strong{Note}

これは危険な操作になり得ます。あなたが、それが何をするのか理解していない限り、使用してはいけません。 このオプションを使用してリポジトリのクローンを作成してから、ソースリポジトリ内のブランチを削除する(または既存のコミットを参照しないようにする他のGitコマンドを使用する)と、一部のオブジェクトが参照されなくなる(unreferenced)(または宙ぶらりん(dangling)になる)可能性があります。 そうしたオブジェクトは、 @samp{git maintenance run --auto} を自動的に呼び出す通常のGit操作(@samp{git commit} など)によって削除される場合があります(git-maintenance(1) 参照)。 これらのオブジェクトが削除され、クローンされたリポジトリーによって参照された場合、クローンされたリポジトリーは破損します。
@end quotation

注意: @samp{--shared} でクローンされたリポジトリで @samp{--local} オプションなしで @samp{git repack} を実行すると、オブジェクトがソースリポジトリからクローンされたリポジトリのパックにコピーされ、 @samp{clone --shared} によるディスクスペースの節約はなくなります。 ただし、デフォルトで @samp{--local} オプションを使用する @samp{git gc} を実行するのは安全です。

@samp{--shared} でクローンされたリポジトリのソースリポジトリへの依存関係を解消したい場合、 @samp{git repack -a} を実行するだけで、すべてのオブジェクトをソースリポジトリから、クローンされたリポジトリのパックにコピーできます。

@item  @samp{--reference[-if-able] <repository>} 
参照リポジトリがローカルマシン上にある場合は、参照リポジトリからオブジェクトを取得するように @samp{.git/objects/info/alternates} を自動的に設定します。 既存のリポジトリをalternateとして使用すると、クローンされるリポジトリからコピーする必要のあるオブジェクトが少なくなり、ネットワークとローカルのストレージコストが削減されます。 @samp{--reference-if-able} を使用すると、存在しないディレクトリはクローンを中断する代わりに警告を出してスキップします。

@quotation

@strong{Note}

@samp{--shared} オプションと @samp{--dissociate} オプションについては「NOTE」を参照してください。
@end quotation

@item  @samp{--dissociate} 
ネットワーク転送を減らすために @samp{--reference} オプションで指定された参照リポジトリからオブジェクトを借用しクローン作成後に、借用したオブジェクトの必要なローカルコピーを作成し、借用を停止(stop)します。 このオプションは、すでに他のリポジトリからオブジェクトを借りているリポジトリからローカルにクローンを作成するときにも使用できます—新しいリポジトリは同一のリポジトリからオブジェクトを借りますが、このオプションを使用して借用を停止できます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。進行状況は標準エラーストリームに報告されません。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
賑やかにします。標準エラーストリームへの進行状況のレポートには影響しません。

@item  @samp{--progress} 
@samp{--quiet} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{--server-option=<option>} 
プロトコルバージョン2を使用して通信する場合、指定の文字列をサーバーに送信します。指定の文字列には、NULまたはLF文字を含めることはできません。 不明なオプションを含むサーバーオプションのサーバー処理は、サーバー固有です。 複数の @samp{--server-option=<option>} が指定されている場合、それらはすべてコマンドラインにリストされている順序で相手側に送信されます。

@item  @samp{-n} 
@itemx  @samp{--no-checkout} 
クローンの完了後、HEADのチェックアウトは実行されません。

@item  @samp{--[no-]reject-shallow} 
ソースリポジトリが浅い(shallow)リポジトリの場合は失敗します。 @samp{clone.rejectShallow} 構成変数を使用して、デフォルトを指定できます。

@item  @samp{--bare} 
「ベア」(bare=裸の)Gitリポジトリを作成します。 つまり、 @samp{<directory>} を作成して管理ファイルを @samp{<directory>/.git} に配置する代わりに、 @samp{<directory>} 自体を @samp{$GIT_DIR} にします。 作業ツリーをチェックアウトする場所がないため、これは明らかに @samp{--no-checkout} を意味します。 また、リモートのブランチヘッドは、 @samp{refs/remotes/origin/} にマッピングせずに、対応するローカルブランチヘッドに直接コピーされます。 このオプションを使用すると、リモート追跡ブランチも関連する構成変数も作成されません。

@item  @samp{--sparse} 
最上位ディレクトリ内のファイルのみが最初に存在するスパース・チェックアウトを採用します。 git-sparse-checkout(1) コマンドを使用して、必要に応じて作業ディレクトリを拡張できます。

@item  @samp{--filter=<filter-spec>} 
部分クローン(partial clone)機能を使用して、サーバーが特定のオブジェクトフィルターに従って到達可能なオブジェクトのサブセットを送信するように要求します。 @samp{--filter} を使用する場合、提供された @samp{<filter-spec>} が部分クローンフィルターに使用されます。 たとえば、 @samp{--filter=blob:none} は、Gitで必要になるまで、すべてのブロブ(ファイルの内容)を除外します。 また、 @samp{--filter=blob:limit=<size>} は、少なくとも @samp{<size>} のサイズのすべてのブロブを除外します。 フィルタ仕様の詳細については、 git-rev-list(1) の @samp{--filter} オプションを参照してください。

@item  @samp{--also-filter-submodules} 
また、リポジトリ内のすべてのサブモジュールに部分クローン・フィルタ(partial clone filter)を適用します。 @samp{--filter} と @samp{--recurse-submodules} が必要です。 これは、 @samp{clone.filterSubmodules} 設定オプションを設定することで、デフォルトでオンにすることができます。

@item  @samp{--mirror} 
ソースリポジトリのミラーを設定します。 これは @samp{--bare} を意味します。 @samp{--bare} と比較して、 @samp{--mirror} は、ソースのローカルブランチをターゲットのローカルブランチにマップするだけでなく、すべての参照(リモート追跡ブランチ、noteなどを含む)をマップし、以下のようなrefspec構成をセットアップします。 これらのすべての参照は、ターゲットリポジトリ内の @samp{git remote update} によって上書きされます。

@item  @samp{-o <name>} 
@itemx  @samp{--origin <name>} 
リモート名 @samp{origin} を使用してアップストリームリポジトリを追跡する代わりに、@samp{<name>} を使用します。 構成(config)の @samp{clone.defaultRemoteName} をオーバーライドします。

@item  @samp{-b <name>} 
@itemx  @samp{--branch <name>} 
新しく作成されたHEADを、複製されたリポジトリのHEADが指すブランチにポイントする代わりに、代わりに @samp{<name>} ブランチをポイントします。 非ベアリポジトリでは、これはチェックアウトされるブランチです。 @samp{--branch} はタグを取得し、結果のリポジトリでそのコミット時にHEADを切り離す(detach)こともできます。

@item  @samp{-u <upload-pack>} 
@itemx  @samp{--upload-pack <upload-pack>} 
これが指定され、クローンを作成するリポジトリにssh経由でアクセスする場合、これは、通信相手側(the other end)で実行されるコマンドのデフォルト以外のパスを指定します。

@item  @samp{--template=<template-directory>} 
テンプレートを使用するディレクトリを指定します。 (git-init(1) の「TEMPLATE DIRECTORY」セクションを参照してください。)

@item  @samp{-c <key>=<value>} 
@itemx  @samp{--config <key>=<value>} 
新しく作成されたリポジトリに構成変数を設定します。 これは、リポジトリが初期化された直後または、リモート履歴がフェッチされる前または、ファイルがチェックアウトされる前に有効になります。 キーは、 git-config(1) で期待されるものと同じ形式です(例: @samp{core.eol=true})。 同じキーに複数値が指定されている場合、各値は構成ファイルに書き込まれます。 これにより、たとえば、originのリモートにフェッチrefspecを追加しても安全になります。

現在の実装の制限により、一部の構成変数は、最初のフェッチとチェックアウトが完了するまで有効になりません。 有効にならないことがわかっている構成変数は、 @samp{remote.<name>.mirror} と @samp{remote.<name>.tagOpt} です。 代わりに、対応する @samp{--mirror} および @samp{--no-tags} オプションを使用してください。

@item  @samp{--depth <depth>} 
指定されたコミット数に切り捨てられた履歴を持つ「浅い」クローン(shallow clone)を作成します。 すべてのブランチの先端近くの履歴をフェッチするために @samp{--no-single-branch} が指定されていない限り、 @samp{--single-branch} を意味します。 サブモジュールを浅くクローンする場合は、 @samp{--shallow-submodules} も渡します。

@item  @samp{--shallow-since=<date>} 
指定した日時以降の履歴を持つ浅いクローン(shallow clone)を作成します。

@item  @samp{--shallow-exclude=<revision>} 
指定のリモートブランチまたはタグから到達可能なコミットを除外して、履歴を持つ浅いクローン(shallow clone)を作成します。 このオプションは複数回指定できます。

@item  @samp{--[no-]single-branch} 
@samp{--branch} オプションで指定された、またはリモートのプライマリブランチの @samp{HEAD} が指す単一のブランチの先端につながる履歴のみをクローンします。 結果のリポジトリにさらにフェッチすると、このオプションが最初のクローン作成に使用されたブランチのリモート追跡ブランチのみが更新されます。 @samp{--single-branch} クローンが作成されたときに、リモートのHEADがどのブランチも指さなかった場合、リモート追跡ブランチは作成されません。

@item  @samp{--no-tags} 
タグのクローンを作成せず、構成に @samp{remote.<remote>.tagOpt=--no-tags} を設定して、今後の @samp{git pull} および @samp{git fetch} 操作がタグに従わないようにします。 指定後も明示的なタグフェッチは引き続き機能します(git-fetch(1) 参照)。

@samp{--single-branch} と組み合わせて使用すると、単一のクローンされたブランチ以外の参照なしでブランチをクローンおよび維持できます。 検索インデックス作成のために、一部のリポジトリのデフォルトブランチの最小限のクローンを維持するので便利です。

@item  @samp{--recurse-submodules[=<pathspec>]} 
クローンが作成されたら、提供されたパススペックに基づいてサブモジュールを初期化し、クローンを作成します。 パススペックが指定されていない場合、すべてのサブモジュールが初期化され、クローン化されます。 このオプションは、複数のエントリで構成されるパススペックに対して複数回指定できます。 結果として得られるクローンには @samp{submodule.active} が指定され、パス指定がない場合は @samp{.} (すべてのサブモジュールを意味します) が設定されます。

サブモジュールは、デフォルト設定を使用して初期化およびクローン化されます。 これは、クローンが終了した直後に @samp{git submodule update --init --recursive <pathspec>} を実行するのと同じです。 クローンされたリポジトリに ワークツリー/チェックアウト がない場合(つまり、 @samp{--no-checkout}/@samp{-n} または @samp{--bare} または @samp{--mirror} のいずれかが指定されている場合)、このオプションは無視されます。

@item  @samp{--[no-]shallow-submodules} 
クローンされるすべてのサブモジュールは、深さが1の浅さののになります。

@item  @samp{--[no-]remote-submodules} 
クローン化されるすべてのサブモジュールは、スーパープロジェクトの記録されたSHA-1ではなく、サブモジュールのリモート追跡ブランチのステータスを使用してサブモジュールを更新します。 @samp{--remote} を @samp{git submodule update} に渡すのと同じです。

@item  @samp{--separate-git-dir=<git-dir>} 
クローンされたリポジトリを本来あるべき場所に配置する代わりに、クローンされたリポジトリを指定されたディレクトリに配置し、そこへのファイルシステムに依存しないGitシンボリックリンクを作成します。 その結果、Gitリポジトリを作業ツリーから分離できます。

@item  @samp{-j <n>} 
@itemx  @samp{--jobs <n>} 
同時にフェッチするサブモジュールの数。 デフォルトは @samp{submodule.fetchJobs} オプションです。

@item  <repository> 
クローンを作成する(場合によってはリモートの)リポジトリ。 リポジトリの指定の詳細については、下記 GIT URLS  セクションを参照してください。

@item  <directory> 
クローンを作成する新しいディレクトリの名前。 ディレクトリが明示的に指定されていない場合は、ソースリポジトリの「人間味のある」(humanish)部分が使用されます(@samp{/path/to/repo.git} の場合は @samp{repo} 、 @samp{host.xz:foo/.git} の場合は @samp{foo} )。 既存のディレクトリへのクローン作成は、ディレクトリが空の場合にのみ許可されます。

@item  @samp{--bundle-uri=<uri>} 
リモートからフェッチする前に、指定された @samp{<uri>} からバンドルをフェッチし、データをローカル・リポジトリで非バンドル化(unbundle)します。 バンドル内のrefは、 非表示の @samp{refs/bundle/*} 名前空間に保存されます。 このオプションは、 @samp{--depth} や`--shallow-since` や @samp{--shallow-exclude} と互換性がありません。
@end table

@noindent

@chapheading GIT URLS

一般に、URLには、トランスポートプロトコル、リモートサーバーのアドレス、およびリポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、一部の情報が欠落している場合があります。

Gitはsshとgitとhttpとhttpsプロトコルをサポートします(さらにftpとftpsをフェッチに使用できますが、これは非効率的で非推奨です。使用しないでください)。

ネイティブトランスポート(つまり、 git:// URL)は認証を行わないため、セキュリティで保護されていないネットワークでは注意して使用する必要があります。

以下の構文を使用できます:

@itemize 

@item
ssh://[user@@]host.xz[:port]/path/to/repo.git/

@item
git://host.xz[:port]/path/to/repo.git/

@item
http[s]://host.xz[:port]/path/to/repo.git/

@item
ftp[s]://host.xz[:port]/path/to/repo.git/
@end itemize

代替のscpのような構文をsshプロトコルで使用することもできます:

@itemize 

@item
[user@@]host.xz:path/to/repo.git/
@end itemize

この構文は、最初のコロン(:)の前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス @samp{foo:bar} を、絶対パスまたは @samp{./foo:bar} として指定して、 ssh url として誤って解釈されないようにすることができます。

sshおよびgitプロトコルは、さらに ~username 拡張をサポートします:

@itemize 

@item
ssh://[user@@]host.xz[:port]/~[user]/path/to/repo.git/

@item
git://host.xz[:port]/~[user]/path/to/repo.git/

@item
[user@@]host.xz:/~[user]/path/to/repo.git/
@end itemize

Gitでもネイティブにサポートされているローカルリポジトリの場合、以下の構文を使用できます:

@itemize 

@item
/path/to/repo.git/

@item
file:///path/to/repo.git/
@end itemize

これらの2つの構文は、前者が @samp{--local} オプションを含むことを除いて、ほとんど同等です。

「git clone」と「git fetch」と「git pull」は、「git push」と違って適切なバンドルファイルを受け入れます。 git-bundle(1) を参照してください。

Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、Gitは @emph{remote-<transport>} リモートヘルパー(存在する場合)を使用しようとします。リモートヘルパーを明示的に要求するには、以下の構文を使用できます:

@itemize 

@item
<transport>::<address>
@end itemize

ここで、 <address> は、パス、サーバーとパス、または呼び出されている特定のリモートヘルパーによって認識される任意のURLのような文字列です。詳細については、 gitremote-helpers(7) を参照してください。

同じ名前のリモートリポジトリが多数あり、それらに異なる形式を使用する場合(あなたの使用するURLが機能するURLに書き換えられるように)、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                insteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:
@end example


"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、任意のコンテキストで、"git://git.host.xz/repo.git" に書き換えられます。

プッシュ専用のURLを書き換えたい場合は、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                pushInsteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/
@end example


"git://example.org/path/to/repo.git" のようなURLは、プッシュの場合は "ssh://example.org/path/to/repo.git" に書き換えられますが、プルは引き続き元のURLのままです。

@noindent

@chapheading EXAMPLES

@itemize 

@item
アップストリームからのクローン:

@example
$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux
$ make
@end example


@item
チェックアウトせずに、現在のディレクトリから借用するローカルクローンを作成します:

@example
$ git clone -l -s -n . ../copy
$ cd ../copy
$ git show-branch
@end example


@item
既存のローカルディレクトリから借用しつつ、アップストリームからクローンを作成します:

@example
$ git clone --reference /git/linux.git \
        git://git.kernel.org/pub/scm/.../linux.git \
        my-linux
$ cd my-linux
@end example


@item
変更を公開するためのベア(bare)リポジトリを作成します:

@example
$ git clone --bare -l /home/proj/.git /pub/scm/proj.git
@end example

@end itemize

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  init.templateDir 
テンプレートのコピー元のディレクトリを指定します。 (git-init(1) の「TEMPLATE DIRECTORY」セクションを参照してください。)

@item  init.defaultBranch 
デフォルトのブランチ名を上書きできます。例えば、新しいリポジトリを初期化するとき。

@item  clone.defaultRemoteName 
リポジトリのクローンを作成するときに作成するリモートの名前。 デフォルトは @samp{origin} で、 @samp{--origin} コマンドラインオプションを git-clone(1) に渡すことでオーバーライドできます。

@item  clone.rejectShallow 
リポジトリが浅い(shallow)場合は、リポジトリの複製(clone)を拒否します。コマンドラインでオプション @samp{--reject-shallow} を渡すことでオーバーライドできます。 git-clone(1) を参照してください

@item  clone.filterSubmodules 
部分(partial)クローン・フィルタが提供され(git-rev-list(1) の @samp{--filter} を参照)、かつ、 @samp{--recurse-submodules} が使用されている場合は、フィルタをサブモジュールにも適用します。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-column,,,Top
@chapheading Name

git-column — データを複数列表示する

@noindent

@chapheading Synopsis

@display
git column [--command=<name>] [--[raw-]mode=<mode>] [--width=<width>]
             [--indent=<string>] [--nl=<string>] [--padding=<n>]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、標準入力の行を複数の列を持つテーブル(表)にフォーマットします。各入力行は、テーブルの1つのセルを占有します。これは、出力を複数列にフォーマットするために他のgitコマンドによって内部的に使用されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--command=<name>} 
構成変数 column.<name> とcolumn.ui を使用してレイアウトモードを探します。

@item  @samp{--mode=<mode>} 
レイアウトモードを指定します。 git-config(1) のオプション構文については、構成変数 column.ui を参照してください。

@item  @samp{--raw-mode=<n>} 
@samp{--mode} と同じですが、数値としてエンコードされたモードを使用します。これは主に、レイアウトモードをすでにパースしている他のコマンドによって使用されます。

@item  @samp{--width=<width>} 
端末幅を指定します。デフォルトでは、「git column」は端末の幅を検出するか、検出できない場合は80にフォールバックします。

@item  @samp{--indent=<string>} 
各行の先頭に印刷される文字列。

@item  @samp{--nl=<string>} 
改行文字を含む、各行の終わりに印刷される文字列。

@item  @samp{--padding=<N>} 
列間のスペースの数。 デフォルトでは1つの空白。
@end table

@noindent

@chapheading EXAMPLES

データを複数列(columns)でフォーマット:

@example
$ seq 1 24 | git column --mode=column --padding=5
1      4      7      10     13     16     19     22
2      5      8      11     14     17     20     23
3      6      9      12     15     18     21     24
@end example


データを複数行(rows)でフォーマット:

@example
$ seq 1 21 | git column --mode=row --padding=5
1      2      3      4      5      6      7
8      9      10     11     12     13     14
15     16     17     18     19     20     21
@end example


列幅が等しくないテーブルにいくつかのタグをリストします:

@example
$ git tag --list 'v2.4.*' --column=row,dense
v2.4.0  v2.4.0-rc0  v2.4.0-rc1  v2.4.0-rc2  v2.4.0-rc3
v2.4.1  v2.4.10     v2.4.11     v2.4.12     v2.4.2
v2.4.3  v2.4.4      v2.4.5      v2.4.6      v2.4.7
v2.4.8  v2.4.9
@end example


@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  column.ui 
サポートされているコマンドを列(column)で出力するかどうかを指定します。 この変数は、スペースまたはコンマで区切られたトークンのリストで構成されます:

以下のオプションは、機能を有効にするタイミングを制御します(デフォルトは @samp{never}):

@table @asis

@item  @samp{always} 
常に列表示

@item  @samp{never} 
決して列表示しない

@item  @samp{auto} 
端末へ出力の場合は列表示
@end table

以下のオプションはレイアウトを制御します(デフォルトは @samp{column})。 @samp{always} や @samp{never} や @samp{auto} のいずれも指定されていない場合に、以下のいずれかを設定すると、 @samp{always} の指定を含みます。

@table @asis

@item  @samp{column} 
行の前に列を埋める

@item  @samp{row} 
列の前に行を埋める

@item  @samp{plain} 
1つの列に表示
@end table

最後に、以下のオプションはレイアウトオプションと組み合わせることができます(デフォルトは @samp{nodense}):

@table @asis

@item  @samp{dense} 
より多くのスペースを利用するために不等サイズの列を作成する

@item  @samp{nodense} 
同じサイズの列を作成する
@end table

@item  column.branch 
@samp{git branch} でブランチリストを列出力するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。

@item  column.clean 
@samp{git clean -i} でアイテムを一覧表示するときのレイアウトを指定します。これにより、常にファイルとディレクトリが列表示されます。 詳細については、 @samp{column.ui} を参照してください。

@item  column.status 
@samp{git status} で追跡されていないファイルを列表示するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。

@item  column.tag 
@samp{git tag} でタグリストを列出力するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-commit-graph,,,Top
@chapheading Name

git-commit-graph — Gitコミットグラフファイル(commit-graph file)の書き出しと検証(verify)

@noindent

@chapheading Synopsis

@display
git commit-graph verify [--object-dir <dir>] [--shallow] [--[no-]progress]
git commit-graph write [--object-dir <dir>] [--append]
                        [--split[=<strategy>]] [--reachable | --stdin-packs | --stdin-commits]
                        [--changed-paths] [--[no-]max-new-filters <n>] [--[no-]progress]
                        <split options>
@end display


@noindent

@chapheading DESCRIPTION

シリアル化されたコミットグラフファイルを管理します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--object-dir} 
パックファイルとコミットグラフファイルの場所として、指定のディレクトリを使用します。このパラメータは、完全な @samp{.git} ディレクトリではなく、objectsディレクトリのみを持つ代替の場所を指定するために存在します。コミットグラフファイルは @samp{<dir>/info} ディレクトリにあり、パックファイルは @samp{<dir>/pack} にあるものと期待されます。ディレクトリを絶対パスにすることができなかった場合、または既知のオブジェクトディレクトリと一致しない場合、 @samp{git commit-graph ...} はゼロ以外のステータスで終了します。

@item  @samp{--[no-]progress} 
進行状況を明示的にオン/オフにします。どちらも指定されていない場合、標準エラーが端末に接続されていれば進行状況が表示されます。
@end table

@noindent

@chapheading COMMANDS

@table @asis

@item  @samp{write} 
パックファイルで見つかったコミットに基づいてコミットグラフファイルを書き出します。構成オプション @samp{core.commitGraph} が無効になっている場合、このコマンドは警告を出力し、コミットグラフファイルを書き込まずに成功を返します。

@samp{--stdin-packs} オプションと共に使用して、指定のパックインデックス内のオブジェクトのみをウォークすることにより、新しいコミットグラフを生成します。 (@samp{--stdin-commits} または @samp{--reachable} と組み合わせることはできません。)

@samp{--stdin-commits} オプションと共に使用して、16進数のOIDのリストとしてstdinで指定されたコミットから始まるコミットを1行に1つずつウォークして、新しいコミットグラフを生成します。(直接に、またはタグの皮むきによって、)非コミットに解決されるOIDは黙って無視されます。不正な形式のOID、または存在しないOIDは、エラーを生成します。 (@samp{--stdin-packs} または @samp{--reachable} と組み合わせることはできません。)

@samp{--reachable} オプションと共に使用して、すべての参照で開始するコミットをウォークして、新しいコミットグラフを生成します。 (@samp{--stdin-commits} または @samp{--stdin-packs} と組み合わせることはできません。)

@samp{--append} オプションと共に使用して、既存のコミットグラフファイルに存在するすべてのコミットを含めます。

@samp{--changed-paths} オプションと共に使用すると、コミットとその最初の親(first parent)の間で変更されたパスに関する情報を計算して書き込みます。この操作は、大規模なリポジトリでは時間がかかる場合があります。 @samp{git log -- <path>} を使用すると、ディレクトリまたはファイルの履歴を取得するためのパフォーマンスが大幅に向上します。このオプションが指定されている場合、その後のコミットグラフ書き込みでは、このオプションが指定されたものであると自動的に想定されます。このデータの保存を停止するには、 @samp{--no-changed-paths} を使用します。

@samp{--max-new-filters=<n>} オプションと共に使用して、(@samp{--changed-paths} が指定されている場合、)最大で @samp{n} の新しいブルームフィルター(Bloom filters)を生成します。 @samp{n} が @samp{-1} の場合、制限は適用されません。この制限に対しては、新しいレイヤーに存在するコミットのみがカウントされます。以前のレイヤーでブルームフィルターをさかのぼって計算するには、 @samp{--split=replace} を使用することをお勧めします。 @samp{commitGraph.maxNewFilters} 構成をオーバーライドします。

@samp{--split[=<strategy>]} オプションと共に使用して、 @samp{<dir>/info/commit-graphs} に格納されている複数のコミットグラフファイルのチェーンとしてコミットグラフを記述します。コミットグラフレイヤーは、戦略およびその他の分割オプションに基づいてマージされます。コミットグラフにまだ含まれていない新しいコミットは、新しい先端ファイル(tip file)に追加されます。以下のマージ条件が満たされた場合、このファイルは既存のファイルとマージされます:

@itemize 

@item
@samp{--split=no-merge} が指定されている場合、マージは実行されず、残りのオプションは無視されます。 @samp{--split=replace} は、既存のチェーンを新しいチェーンで上書きします。裸の @samp{--split} は後続のオプションに従います。 (注意: コミットグラフのチェーンをマージすると、既存のチェーンが長さ1のチェーンに置き換えられ、最初で唯一の増分がグラフ全体を保持することに注意してください)。

@item
@samp{--size-multiple=<X>} が指定されていない場合は、 Xを2に等しくします。新しい先端ファイル(tip file)にN個のコミットがあり、以前の先端にM個のコミットがあり、「X 掛ける N」が M より大きい場合は、代わりに2つのファイルを1つのファイルにマージします。

@item
@samp{--max-commits=<M>} オプションの M が正の整数で指定され、新しい先端ファイル(tip file) に M 以上のコミットがある場合は、代わりに新しい先端を以前の先端とマージします。

最後に、 @samp{--expire-time=<datetime>} が指定されていない場合は、 datetimeを現在の時刻とします。分割コミットグラフ(split commit-graph)を書き込んだ後、変更時刻がdatetimeより古い未使用のコミットグラフをすべて削除します。
@end itemize

@item  @samp{verify} 
コミットグラフファイルを読み取り、その内容をオブジェクトデータベースと照合して確認(verify)します。破損したデータをチェックするために使用されます。

@samp{--shallow} オプションと共に使用すると、分割コミットグラフ(split commit-graphs)のチェーン内の先端コミットグラフファイルのみをチェックします。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
パックされたコミットのコミットグラフファイルをローカルの @samp{.git} ディレクトリに書き込みます。

@example
$ git commit-graph write
@end example


@item
@samp{<pack-index>} のコミットを使用して、現在のコミットグラフファイルを拡張するコミットグラフファイルを書き出します。

@example
$ echo <pack-index> | git commit-graph write --stdin-packs
@end example


@item
到達可能なすべてのコミットを含むコミットグラフファイルを作成します。

@example
$ git show-ref -s | git commit-graph write --stdin-commits
@end example


@item
現在のコミットグラフファイル内のすべてのコミットと @samp{HEAD} から到達可能なコミットを含むコミットグラフファイルを書き出します。

@example
$ git rev-parse HEAD | git commit-graph write --stdin-commits --append
@end example

@end itemize

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  commitGraph.generationVersion 
commit-graph ファイルの書き込みまたは読み取り時に使用する世代番号バージョン(generation number version)のタイプを指定します。 バージョン 1 が指定されている場合、修正されたコミット日付は書き込まれたり読み取られたりしません。 デフォルトは 2 です。

@item  commitGraph.maxNewFilters 
@samp{git commit-graph write} の @samp{--max-new-filters} オプションのデフォルト値を指定します(git-commit-graph(1) 参照)。

@item  commitGraph.readChangedPaths 
trueの場合、gitはcommit-graphファイルで変更パスブルームフィルター(the changed-path Bloom filters)を使用します(存在し、有効な場合)。 デフォルトはtrueです。 詳細については、 git-commit-graph(1) を参照してください。
@end table

@noindent

@chapheading FILE FORMAT

see gitformat-commit-graph(5).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-commit-tree,,,Top
@chapheading Name

git-commit-tree — 新しいコミットオブジェクトを作成します

@noindent

@chapheading Synopsis

@display
git commit-tree <tree> [(-p <parent>)…]
git commit-tree [(-p <parent>)…] [-S[<keyid>]] [(-m <message>)…]
                  [(-F <file>)…] <tree>
@end display


@noindent

@chapheading DESCRIPTION

これは通常、エンドユーザーが直接実行するものではありません。代わりに git-commit(1) を参照してください。

提供されたツリーオブジェクトに基づいて新しいコミットオブジェクトを作成し、標準出力に新しいコミットオブジェクトIDを発行します。 @samp{-m} または @samp{-F} オプションが指定されていない限り、ログメッセージは標準入力から読み取られます。

@samp{-m} および @samp{-F} オプションは、任意の回数、任意の順序で指定できます。コミットログメッセージは、オプションが指定された順序で作成されます。

コミットオブジェクトには、任意の数の親を含めることができます。親が1つだけの場合、これは通常のコミットです。 複数の親を持つことで、コミットは複数の履歴行の間でマージされます。なお、最初のコミット(ルートコミット)には親はありません。

ツリーは作業ディレクトリの特定のディレクトリ状態を表しますが、コミットはある「時点」における状態を表し、そこに到達する方法を説明します。

あなたがその状態に関するメモをは何処に保存してもGitは気にしませんが、通常、コミットは新しい「HEAD」状態を識別します。実際のところGitは、@samp{.git/HEAD} が指すファイルに結果を書き込む傾向にあり、最後にコミットされた状態が何であったかを常に確認できるようにしています。

@noindent

@chapheading OPTIONS

@table @asis

@item  <tree> 
既存のツリーオブジェクト。

@item  @samp{-p <parent>} 
各 @samp{-p} は、親コミットオブジェクトのIDを示します。

@item  @samp{-m <message>} 
コミットログメッセージの段落。これは複数回指定でき、各 <message> は独立した段落になります。

@item  @samp{-F <file>} 
指定されたファイルからコミットログメッセージを読み取ります。 標準入力から読み取るには、 @samp{-} を使用します。 これは複数回指定でき、各ファイルの内容は独自した段落になります。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミット。 @samp{keyid} 引数はオプションで、デフォルトはコミッターIDです。指定する場合は、スペースなしでオプションに指定する必要があります。 @samp{--no-gpg-sign} は、コマンドラインで前に指定した @samp{--gpg-sign} オプションを無効にするのに役立ちます。
@end table

@noindent

@chapheading Commit Information

コミットをカプセル化します:

@itemize 

@item
全ての親のオブジェクトID

@item
作者名と電子メールアドレスと日付

@item
コミッター名とコミッター電子メールアドレスとコミット日付
@end itemize

コミットコメントは標準入力から読み取られます。変更ログエントリが "<" リダイレクトを介して提供されない場合、「git commit-tree」は、変更ログエントリがターミナルから入力されて ^D で終了するのを待つだけです。

@noindent

@chapheading DATE FORMATS

@samp{GIT_AUTHOR_DATE} と @samp{GIT_COMMITTER_DATE} 環境変数は、以下の日付形式をサポートします:

@table @asis

@item  Git internal format 
これは @samp{<unix-timestamp> <time-zone-offset>} ここで、 @samp{<unix-timestamp>} UNIXエポックからの秒数です。 @samp{<time-zone-offset>} はUTCからの正または負のオフセットです。 たとえば、CET(UTCより1時間進んでいます)は @samp{+0100} です。

@item  RFC 2822 
RFC 2822で説明されている標準の電子メール形式。たとえば、 @samp{Thu, 07 Apr 2005 22:13:13 +0200} 。

@item  ISO 8601 
ISO 8601規格で指定されている日時(例: @samp{2005-04-07T22:13:13})。パーサは、 @samp{T} 文字の代わりにスペースも受け入れます。秒の小数部分は無視されます。たとえば、 @samp{2005-04-07T22:13:13.019} は @samp{2005-04-07T22:13:13} として扱われます。

@quotation

@strong{Note}

日付部分は、上記に加えて、 @samp{YYYY.MM.DD} または @samp{MM/DD/YYYY} または @samp{DD.MM.YYYY} 形式が受け入れられます。
@end quotation
@end table

@noindent

@chapheading Discussion

Gitは、ある程度までは文字エンコードに依存しません。

@itemize 

@item
ブロブオブジェクトの内容は、解釈されていないバイトのシーケンスです。コアレベルでのエンコーディング変換はありません。

@item
パス名はUTF-8正規化形式C(UTF-8 normalization form C)でエンコードされます。これは、ツリーオブジェクト、インデックスファイル、ref名、およびコマンドライン引数、環境変数、構成ファイル( @samp{.git/config} (git-config(1) 参照) と gitignore(5) と gitattributes(5) と gitmodules(5)) のパス名に適用されます。

コアレベルのGitは、パス名を単に非NULバイトのシーケンスとして扱い、パス名をエンコードする変換はありません(MacとWindowsを除く)。したがって、非ASCIIパス名の使用は、レガシー拡張ASCIIエンコーディングを使用するプラットフォームやファイルシステムでもほとんど機能します。ただし、そのようなシステムで作成されたリポジトリは、UTF-8ベースのシステム(Linux、Mac、Windowsなど)では正しく機能しません。その逆も同様です。さらに、多くのGitベースのツールは、パス名がUTF-8であると単純に想定しており、他のエンコーディングを正しく表示できません。

@item
コミットログメッセージは通常UTF-8でエンコードされますが、他の拡張ASCIIエンコードもサポートされています。これには、ISO-8859-x、CP125xなどが含まれますが、UTF-16/32、EBCDIC、およびCJKマルチバイトエンコーディング(GBK、Shift-JIS、Big5、EUC-x、CP9xxなど)は含まれません。
@end itemize

我々はコミットログメッセージをUTF-8でエンコードすることをお勧めしますが、コアとGit Porcelainはどちらも、プロジェクトでUTF-8を強制しないように設計されています。特定のプロジェクトのすべての参加者がレガシーエンコーディングを使用する方が便利だと感じた場合、Gitはそれを禁止しません。 ただし、覚えておくべきことがいくつかあります。

@enumerate 

@item
@samp{git commit} と @samp{git commit-tree} は、プロジェクトがレガシーエンコーディングを使用していることを明示的に指定しない限り、与えられたコミットログメッセージが有効なUTF-8文字列のように見えない場合に警告を発します。明示的に指定する方法は、以下のように、 @samp{.git/config} ファイルに @samp{i18n.commitEncoding} を含めることです。

@example
[i18n]
        commitEncoding = ISO-8859-1
@end example


上記の設定で作成されたコミットオブジェクトは、 @samp{encoding} ヘッダーに @samp{i18n.commitEncoding} の値を記録します。 これは、後でそれらを見る他の人々を助けるためです。このヘッダーがないということは、コミットログメッセージがUTF-8でエンコードされていることを意味します。

@item
@samp{git log} や @samp{git show} や @samp{git blame} とその仲間たちは、コミットオブジェクトの @samp{encoding} ヘッダーを見て、特に指定がない限り、ログメッセージをUTF-8に再コーディングしようとします。あなたは以下のように、 @samp{.git/config} ファイルの @samp{i18n.logOutputEncoding} を使用して目的の出力エンコーディングを指定できます。

@example
[i18n]
        logOutputEncoding = ISO-8859-1
@end example


この構成変数がない場合は、代わりに @samp{i18n.commitEncoding} の値が使用されます。
@end enumerate

UTF-8への再コーディングは必ずしも可逆的な操作ではないため、我々はコミットが行われたときにコミットログメッセージを再コーディングしないことを意図的に選択したことに注意してください。

@noindent

@chapheading FILES

/etc/mailname

@noindent

@chapheading SEE ALSO

git-write-tree(1) git-commit(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-commit,,,Top
@chapheading Name

git-commit — 変更をリポジトリへ記録します

@noindent

@chapheading Synopsis

@display
git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
           [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|reword):]<commit>)]
           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
           [--date=<date>] [--cleanup=<mode>] [--[no-]status]
           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
           [(--trailer <token>[(=|:)<value>])…] [-S[<keyid>]]
           [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

インデックスの現在の内容と変更を説明する指定されたログメッセージを含む新しいコミットを作成します。 新しいコミットはHEADの直接の子であり、通常は現在のブランチの先端であり、ブランチはそれを指すように更新されます(作業ツリーにブランチが関連付けられていない場合は、git-checkout(1) で説明されているようにHEADが「切り離され」(detached)されます)。

コミットするコンテンツは、いくつかの方法で指定できます:

@enumerate 

@item
git-add(1) を使用して、「commit」コマンドを使用する前にインデックスに変更を段階的に「追加」(add)します(注: 「変更」されたファイルも「add」コマンドで「追加」するが必要があります)。

@item
再び「commit」コマンドを使用する前に、 git-rm(1) を使用して、作業ツリーとインデックスからファイルを削除します。

@item
「commit」コマンドの引数としてファイルをリストします(@samp{--interactive} や @samp{--patch} スイッチがない場合)。 この場合、そのコミットはインデックスにステージングされた変更を無視し、代わりにリストされたファイル(これらはすでに Git に知られている必要があります)の現在のコンテンツを記録します

@item
「commit」コマンドで @samp{-a} スイッチを使用して、すべての既知のファイル(つまり、すでにインデックスにリストされているすべてのファイル)からの変更を自動的に「add」(追加)し、作業ツリーから削除されたインデックス内のファイルを自動的に「rm」(削除)してから、実際のコミットを実行します

@item
「commit」コマンドで @samp{--interactive} または @samp{--patch} スイッチを使用して、操作を完了する前に、インデックスの内容に加えて、どのファイルまたはハンクをコミットの一部にするかを1つずつ決定します。 これらのモードの操作方法については、 git-add(1)の「Interactive Mode」セクションを参照してください。
@end enumerate

@samp{--dry-run} オプションは、同じパラメーターのセット(オプションとパス)を指定することにより、次のコミットにて上記のいずれかに含まれるものの要約を取得するために使用できます。

コミットを行い、その直後に間違いを見つけた場合は、「git reset」を使用してそれから回復できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
@itemx  @samp{--all} 
変更および削除されたファイルを自動的にステージングするようにコマンドに指示しますが、Gitに通知していない新しいファイルは影響を受けません。

@item  @samp{-p} 
@itemx  @samp{--patch} 
対話的なパッチ選択インターフェイスを使用して、コミットする変更を選択します。 詳細については、git-add(1) を参照してください。

@item  @samp{-C <commit>} 
@itemx  @samp{--reuse-message=<commit>} 
既存のコミットオブジェクトを取得し、コミットを作成するときにログメッセージと作者情報(タイムスタンプを含む)を再利用します。

@item  @samp{-c <commit>} 
@itemx  @samp{--reedit-message=<commit>} 
@emph{-C} と同様ですが、 @samp{-c} を使用するとエディターが呼び出されるため、ユーザーはコミットメッセージをさらに編集できます。

@item  @samp{--fixup=[(amend|reword):]<commit>} 
@samp{git rebase --autosquash} を適用すると @samp{<commit>} を「fixes up」(修正)する新しいコミットを作成します。 プレーンな @samp{--fixup=<commit>} は「fixup!」コミットを作成します。 これは @samp{<commit>} の内容を変更しますが、ログメッセージは変更されません。 @samp{--fixup=amend:<commit>} も同様ですが、「amend!」コミットを作成します。 これにより @samp{<commit>} のログメッセージも「amend!」コミットのログメッセージに置き換えられます。 @samp{--fixup=reword:<commit>} は「amend!」コミットを作成します。これは @samp{<commit>} のログメッセージを独自のログメッセージに置き換える「amend!」コミットを作成しますが、 @samp{<commit>} の内容は変更しません。

プレーンな @samp{--fixup=<commit>} によって作成されたコミットは、 @samp{fixup!} に <commit> の件名行が続く件名を作り、これは @samp{git rebase --autosquash} によって特別に認識されます。 @samp{-m} オプションは、作成されたコミットのログメッセージを補足するために使用できますが、「fixup!」コミットが @samp{git rebase --autosquash} によって @samp{<commit>} に押しつぶされる(squash)と、追加のコメントは破棄されます。

@samp{--fixup=amend:<commit>} によって作成されたコミットは似ていますが、その件名には代わりに @samp{amend!} というプレフィックスが付いています。 <commit> のログメッセージが「amend!」コミットのログメッセージにコピーされ、エディターで開いた時に調整できます。 @samp{git rebase --autosquash} が「fixup!」を押しつぶす(squash)とき @samp{<commit>} にコミットすると、 @samp{<commit>} のログメッセージは「amend!」コミットからの修正されたログメッセージに置き換えられます。 「amend!」コミットのログメッセージが空であることは、 @samp{--allow-empty-message} が指定されていない限りエラーとなります。

@samp{--fixup=reword:<commit>} は @samp{--fixup=amend:<commit> --only} の省略形です。 これはログメッセージのみで「amend!」コミットを作成します(インデックスにステージングされた変更は無視します)。 @samp{git rebase --autosquash} によって押しつぶされる(squash)と、他の変更を加えることなく、 @samp{<commit>} のログメッセージを置き換えます。

「fixup!」や「amend!」といったコミットは、 @samp{git rebase --autosquash} で適用したときに @samp{<commit>} の作者は変更しません。 詳しくは git-rebase(1) を参照してください。

@item  @samp{--squash=<commit>} 
@samp{rebase --autosquash} で使用するコミットメッセージを作成します。 コミットメッセージの件名行は、プレフィックスが "squash! " と指定されたコミットから取得されます。 追加のコミットメッセージオプション(@samp{-m}/@samp{-c}/@samp{-C}/@samp{-F})とともに使用できます。 詳細については、 git-rebase(1) を参照してください。

@item  @samp{--reset-author} 
@samp{-C}/@samp{-c}/@samp{--amend} オプションとともに使用する場合、または競合するチェリーピックの後にコミットする場合は、結果のコミットの作者がコミッターに属することを宣言します。これにより、作者のタイムスタンプも更新されます。

@item  @samp{--short} 
ドライランを行うときに、出力を短い形式で提供します。 詳細については、 git-status(1) を参照してください。 @samp{--dry-run} の指定を含んでいます。

@item  @samp{--branch} 
短い形式でもブランチと追跡情報を表示します。

@item  @samp{--porcelain} 
ドライランを行うときに、磁器コマンド対応の形式で出力を提供します。 詳細については、 git-status(1) を参照してください。 @samp{--dry-run} の指定を含んでいます。

@item  @samp{--long} 
ドライランを行うときに、出力を長い形式で提供します。 @samp{--dry-run} の指定を含んでいます。

@item  @samp{-z} 
@itemx  @samp{--null} 
@samp{short} または @samp{porcelain} ステータス出力を表示する場合は、ファイル名をそのまま(verbatim)出力し、LFではなくNULでエントリを終了します。 フォーマットが指定されていない場合は、 @samp{--porcelain} 出力フォーマットを意味します。 @samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、「異常な」文字を含むファイル名がクォートされます(git-config(1) 参照)。

@item  @samp{-F <file>} 
@itemx  @samp{--file=<file>} 
指定されたファイルからコミットメッセージを取得します。<file>に @samp{-} を使用すると、標準入力からメッセージを読み取ります。

@item  @samp{--author=<author>} 
コミット作者をオーバーライドします。 標準の @samp{A U Thor <author@@example.com>} 形式を使用して明示的な作者を指定します。 それ以外の場合、 <author> はパターンであると見なされ、その作者による既存のコミットを検索するために使用され(つまり、 @samp{rev-list --all -i --author=<author>})、そして、コミットの作者は、最初に見つかったそのようなコミットからコピーされます。

@item  @samp{--date=<date>} 
コミットで使用された作者の日付を上書きします。

@item  @samp{-m <msg>} 
@itemx  @samp{--message=<msg>} 
指定された<msg>をコミットメッセージとして使用します。 複数の @samp{-m} オプションが指定されている場合、それらの値は個別の段落として連結されます。

@samp{-m} オプションは、 @samp{-c} 、 @samp{-C} 、 @samp{-F} と相互に排他的(mutually exclusive)です。

@item  @samp{-t <file>} 
@itemx  @samp{--template=<file>} 
コミットメッセージを編集するときは、指定されたファイルの内容でエディターを起動します。 @samp{commit.template} 構成変数は、このオプションをコマンドに暗黙的に与えるためによく使用されます。 このメカニズムは、メッセージに何をどの順序で書き込むかについてのヒントを参加者に案内したいプロジェクトで使用できます。 ユーザーがメッセージを編集せずにエディターを終了すると、コミットは中止(abort)されます。 これは、メッセージが他の手段、例えば @samp{-m} または @samp{-F} オプションを使用して提供された場合には効果がありません。

@item  @samp{-s} 
@itemx  @samp{--signoff} 
@itemx  @samp{--no-signoff} 
コミットログメッセージの最後に、コミッターによる「Signed-off-by」トレーラーを追加します。signoffの意味は、コミットしているプロジェクトによって異なります。たとえば、コミッターがプロジェクトのライセンスに基づいて作品を提出する権利を持っていることを証明したり、開発者の原産地証明書などの寄稿者の代表に同意したりする場合があります。(LinuxカーネルおよびGitプロジェクトで使用されるものについては、http：//developercertificate.orgを参照してください)。プロジェクトでsignoffがどのように使用されるかを理解するには、貢献しているプロジェクトのドキュメントまたはリーダーシップ(leadership)を参照してください。

@samp{--no-signoff} オプションを使用すると、コマンドラインで以前の @samp{--signoff} オプションを無効にすることができます。

@item  @samp{--trailer <token>[(=|:)<value>]} 
トレーラーとして適用する必要がある<token>と<value>のペアを指定します。 (例: @samp{git commit --trailer "Signed-off-by:C O Mitter \ <committer@@example.com>" --trailer "Helped-by:C O Mitter \ <committer@@example.com>"} は「コミットメッセージへ「Signed-off-by」トレーラーと「Helped-by」トレーラーを追加します。)） @samp{trailer.*} 構成変数(git-interpret-trailers(1))を使用して、重複したトレーラーを省略するかどうか、各トレーラーがトレーラー群の何処に表示されるかや、その他の詳細を定義できます。

@item  @samp{-n} 
@itemx  @samp{--[no-]verify} 
デフォルトでは、 pre-commit および commit-msg フックが実行されます。 @samp{--no-verify} または @samp{-n} のいずれかが指定された場合、これらのフックはバイパスされます。 githooks(5) も参照してください。

@item  @samp{--allow-empty} 
通常、唯一の親コミットとまったく同じツリーを持つコミットを記録することは間違いであり、コマンドはそのようなコミットを行うことを防ぎます。 このオプションはその安全装置をバイパスします。主に外部SCMインターフェイススクリプトで使用するためのものです。

@item  @samp{--allow-empty-message} 
@samp{--allow-empty} と同様に、このコマンドは主に外部SCMインターフェイススクリプトで使用されます。 あなたは git-commit-tree(1) のような配管コマンドを使用せずに、空のコミットメッセージでコミットを作成できます。

@item  @samp{--cleanup=<mode>} 
このオプションは、提供されたコミットメッセージをコミットする前にクリーンアップする方法を決定します。 <mode> は、 @samp{strip} または @samp{whitespace} または @samp{verbatim} または ` scissors` または @samp{default} にすることができます。

@table @asis

@item  strip 
先頭と末尾の空行の削除と、行末の空白を削除と、コメントの削除を行い、連続する空行を折りたたみます。

@item  whitespace 
#コメント が削除されないことを除いて、@samp{strip} と同一です。

@item  verbatim 
メッセージは一切変更しません。

@item  scissors 
メッセージを編集する場合は、以下の行からの(そしてその行を含む)すべてが切り捨てられることを除いて、 @samp{whitespace} と同じです。 @samp{#} はcore.commentCharでカスタマイズできます。

@example
# ------------------------ >8 ------------------------
@end example

@item  default 
メッセージを編集する場合は @samp{strip} と同一です。 それ以外の場合は @samp{whitespace} と同一です。
@end table

デフォルトは、 @samp{commit.cleanup} 構成変数によって変更できます(git-config(1) 参照)。

@item  @samp{-e} 
@itemx  @samp{--edit} 
@samp{-F} を使用してファイルから取得したメッセージや、 @samp{-m} を使用してコマンドラインから取得したメッセージや、 @samp{-C} を使用してコミットオブジェクトから取得したメッセージは、通常、編集不可のコミットログメッセージとして使用されます。 このオプションを使用すると、これらのソースから取得したメッセージをさらに編集できます。

@item  @samp{--no-edit} 
エディターを起動せずに、選択したコミットメッセージを使用します。 たとえば、 @samp{git commit --amend --no-edit} は、コミットメッセージを変更せずにコミットを修正します。

@item  @samp{--amend} 
新しいコミットを作成して、現在のブランチの先端を置き換えます。 記録されたツリーは通常どおりに準備され(@samp{-i} および @samp{-o} オプションと明示的なパススペックの効果を含む)、空のメッセージではなく、元のコミットからのメッセージが開始点として使用されます。 他のメッセージは、コマンドラインから @samp{-m}, @samp{-F}, @samp{-c} などのオプションを介して指定します。 新しいコミットには、現在のものと同じ親と作者があります(@samp{--reset-author} オプションはこれを打ち消すことができます)。

これは、以下とおおむね同じです:

@example
        $ git reset --soft HEAD^
        $ ... do something else to come up with the right tree ...
        $ git commit -c ORIG_HEAD
@end example


ただし、マージコミットを修正(amend)するために使用できます。

すでに公開されているコミットを修正する場合、あなたは履歴の書き換えの影響を理解する必要があります。 (git-rebase(1) の「RECOVERING FROM UPSTREAM REBASE」セクションを参照してください。)

@item  @samp{--no-post-rewrite} 
post-rewriteフックをバイパスします。

@item  @samp{-i} 
@itemx  @samp{--include} 
これまでにステージングされたコンテンツからコミットを行う前に、コマンドラインで指定されたパスのコンテンツもステージングします。 あなたが競合するマージを終了させるのでない限り、これは通常、あなたが希望することはないでしょう。

@item  @samp{-o} 
@itemx  @samp{--only} 
他のパス用にステージングされたコンテンツを無視して、コマンドラインで指定されたパスの更新された作業ツリーのコンテンツを取得してコミットします。 これは、コマンドラインでパスが指定されている場合の「git commit」のデフォルトの動作モードです。この場合、このオプションは省略できます。 このオプションを`--amend` と一緒に指定する場合、パスを指定する必要はありません。これを使用すると、すでにステージングされている変更をコミットせずに最後のコミットを修正できます。 @samp{--allow-empty} パス と一緒に使用する場合もパスは必要ではなく、空のコミットが作成されます。

@item  @samp{--pathspec-from-file=<file>} 
パススペックは、コマンドライン引数の代わりに`<file>@samp{で渡されます。 `<file>} が正確に @samp{-} の場合、標準入力が使用されます。 パススペック要素は、LFまたはCR/LFで区切られます。 パススペック要素は、構成変数 @samp{core.quotePath} で説明されているようにクォートできます(git-config(1) 参照)。 @samp{--pathspec-file-nul} および グローバル @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
@samp{--pathspec-from-file} 指定時のみ意味があります。 パススペック要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  @samp{-u[<mode>]} 
@itemx  @samp{--untracked-files[=<mode>]} 
追跡されていないファイル(untracked files)を表示します。

modeパラメーターはオプション(デフォルトは「all」)であり、追跡されていないファイルの処理を指定するために使用されます。 @samp{-u} を使用しない場合、デフォルトは「normal」です。つまり、追跡されていないファイルとディレクトリを表示します。

可能なオプションは以下のとおりです:

@itemize 

@item
no - 追跡されていないファイルを表示します

@item
normal - 追跡されていないファイルとディレクトリを表示します

@item
all - 追跡されてないディレクトリ内の個々のファイルも表示します。
@end itemize

デフォルトは、 git-config(1) に記載されている status.showUntrackedFiles 構成変数を使用して変更できます。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
HEADコミットとコミットメッセージテンプレートの下部にコミットされる内容とのunified diffを表示して、ユーザーがコミットの変更内容を思い出させることでコミットを説明できるようにします。 注意: このdiff出力には、接頭辞 @samp{#} が付いた行がないことに注意してください。 このdiffは、コミットメッセージの一部にはなりません。 git-config(1) の @samp{commit.verbose} 構成変数を参照してください。

2回指定した場合は、コミットされるものとワークツリーファイルの間のunified diff、 つまり、追跡されたファイルへのステージングされていない変更を追加で表示します。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
コミット要約メッセージを抑制します。

@item  @samp{--dry-run} 
コミットを作成しません。ただし、コミットされるパス、コミットされないままになるローカル変更のあるパス、および追跡されないパスのリストを表示します。

@item  @samp{--status} 
エディターを使用してコミットメッセージを準備する場合は、 git-status(1) の出力をコミットメッセージテンプレートに含めます。 デフォルトはオンではありますが、 構成変数 commit.status での指定をオーバーライドするために使用できます。

@item  @samp{--no-status} 
エディターを使用してデフォルトのコミットメッセージを準備する場合は、 git-status(1) の出力をコミットメッセージテンプレートに含めません。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミット。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに固定する必要があります。 @samp{--no-gpg-sign} は、@samp{commit.gpgSign} 構成変数と、これより前で指定された @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <pathspec>… 
コマンドラインでパススペックが指定されている場合、インデックスにすでに追加されている変更を記録せずに、パススペックにマッチするファイルの内容をコミットします。 これらのファイルの内容は、これより前にステージングされたものに加えて、次のコミットのためにもステージングされます。

詳細については、 gitglossary(7)の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading EXAMPLES

自分の作業を記録する場合、作業ツリー内の変更されたファイルの内容は、「git add」を使用して「インデックス」と呼ばれるステージング領域に一時的に保存されます。 ファイルは、インデックス内でのみ、作業ツリー内ではなく、 @samp{git restore --staged <file>} を使用して最後のコミットのファイルに戻すことができます。これにより、 @samp{git add} が効果的に元に戻され、このファイルへの変更を次のコミットに関わらわせないようにします。 これらのコマンドを使用して増加的にコミットする状態を構築した後、 @samp{git commit} (パス名パラメーターなし)を使用して、これまでにステージングされたものを記録します。 これは、このコマンドの最も基本的な形式です。 例:

@example
$ edit hello.c
$ git rm goodbye.c
$ git add hello.c
$ git commit
@end example


個々の変更の後にファイルをステージングする代わりに、作業ツリーで内容が追跡されているファイルへの変更を通知し、対応する @samp{git add} と @samp{git rm} を実行するように`gitcommit`に指示できます。 つまり、以下の例は、作業ツリーに他の変更がない場合、上記の例と同じように機能します:

@example
$ edit hello.c
$ rm goodbye.c
$ git commit -a
@end example


コマンド @samp{git commit -a} は、最初にあなたの作業ツリーを調べ、 あなたが @samp{hello.c} を変更して @samp{goodbye.c} を削除したことを認識し、 必要な @samp{git add} と @samp{git rm} を実行します。

多くのファイルに変更をステージングした後、 @samp{git commit} にパス名を指定することで、変更が記録される順序を変更できます。 パス名が指定されると、コマンドは、指定されたパスに加えられた変更のみを記録するコミットを行います:

@example
$ edit hello.c hello.h
$ git add hello.c hello.h
$ edit Makefile
$ git commit Makefile
@end example


これにより、@samp{Makefile`への変更を記録するコミットが行われます。 `hello.c} と @samp{hello.h} に対してステージングされた変更は、結果のコミットには含まれません。 ただし、それらの変更は失われません。それらはいまだステージングに留まっているだけです。上記シーケンスの後、あなたが以下のようにした場合:

@example
$ git commit
@end example


この2番目のコミットは、期待どおりに @samp{hello.c} と @samp{hello.h} への変更を記録します。

競合が原因でマージ(「git merge」または「git pull」によって開始）が停止(stop)した後では、クリーンにマージされたパスはすでにステージングされてコミットされ、競合したパスはマージされていない状態のままになります。 最初に、「git status」で、どのパスが競合しているかを確認する必要があります。あなたの作業ツリーで手動で修正した後、通常どおり「git add」を使用して結果をステージングします:

@example
$ git status | grep unmerged
unmerged: hello.c
$ edit hello.c
$ git add hello.c
@end example


競合を解決して結果をステージングした後、 @samp{git ls-files -u} は競合するパスへの言及を停止します。 完了したら、 @samp{git commit} を実行して、最終的にマージを記録します:

@example
$ git commit
@end example


独自の変更を記録する場合と同様に、 @samp{-a} オプションを使用して入力を保存できます。 一つ違うのは、マージの解決中にパス名を伴って @samp{git commit} を使用して、変更がコミットされる順序を変更できないことです。これは、マージが単一のコミットとして記録される必要があるためです。 実際、パス名が指定されている場合、コマンドは実行を拒否します(ただし、 @samp{-i} オプションも参照してください)。

@noindent

@chapheading COMMIT INFORMATION

作者とコミッターの情報は、以下の環境変数から取得されます(設定されてる場合):

@example
GIT_AUTHOR_NAME
GIT_AUTHOR_EMAIL
GIT_AUTHOR_DATE
GIT_COMMITTER_NAME
GIT_COMMITTER_EMAIL
GIT_COMMITTER_DATE
@end example

(注: "<" と ">" と "\n" は取り除きます)

作者とコミッター名は、慣例により、個人名(つまり、他の人間があなたを参照する名前)の形式ですが、Gitは特定の形式を強制または要求しません。 上記の制約に従って、任意のUnicodeを使用できます。 この名前は認証には影響しません。認証には影響させるためには、 git-config(1)の @samp{credential.username} 変数を参照してください。

これらの環境変数(の一部)が設定されていない場合、情報は構成アイテム @samp{user.name} および @samp{user.email} から取得され、それが存在しない場合は、環境変数EMAILから取得され、それが設定されてない場合は、 システムユーザー名や送信メールに使用されるホスト名(@samp{/etc/mailname} から取得され、そのファイルが存在しない場合は完全修飾ホスト名にフォールバックします)から取得されます。

@samp{author.name} と @samp{committer.name} と、それらに対応する電子メールオプションは、 設定されている場合はそれぞれ @samp{user.name} と @samp{user.email} をオーバーライドし、環境変数によってオーバーライドされます。

一般的な使用法は、 @samp{user.name} 変数と @samp{user.email} 変数のみを設定することです。 他のオプションは、より複雑なユースケースのために提供されています。

@noindent

@chapheading DATE FORMATS

@samp{GIT_AUTHOR_DATE} と @samp{GIT_COMMITTER_DATE} 環境変数は、以下の日付形式をサポートします:

@table @asis

@item  Git internal format 
これは @samp{<unix-timestamp> <time-zone-offset>} ここで、 @samp{<unix-timestamp>} UNIXエポックからの秒数です。 @samp{<time-zone-offset>} はUTCからの正または負のオフセットです。 たとえば、CET(UTCより1時間進んでいます)は @samp{+0100} です。

@item  RFC 2822 
RFC 2822で説明されている標準の電子メール形式。たとえば、 @samp{Thu, 07 Apr 2005 22:13:13 +0200} 。

@item  ISO 8601 
ISO 8601規格で指定されている日時(例: @samp{2005-04-07T22:13:13})。パーサは、 @samp{T} 文字の代わりにスペースも受け入れます。秒の小数部分は無視されます。たとえば、 @samp{2005-04-07T22:13:13.019} は @samp{2005-04-07T22:13:13} として扱われます。

@quotation

@strong{Note}

日付部分は、上記に加えて、 @samp{YYYY.MM.DD} または @samp{MM/DD/YYYY} または @samp{DD.MM.YYYY} 形式が受け入れられます。
@end quotation
@end table

上記のすべての日付形式を認識することに加えて、 @samp{--date} オプションは、 "yesterday" や "last Friday at noon" など、より人間よりの日付形式も理解しようとします。

@noindent

@chapheading DISCUSSION

必須ではありませんが、変更を要約した1行の短い(50文字未満の)行でコミットメッセージを開始し、その後に空行を続け、さらに詳細な説明を続けることをお勧めします。 コミットメッセージの最初の空行までのテキストはコミットタイトルとして扱われ、そのタイトルはGit全体で使用されます。 たとえば、 git-format-patch(1) はコミットを電子メールに変換し、コミットタイトルをメール件名に使い、残りのコミットメッセージをメール本文に使います。

Gitは、ある程度までは文字エンコードに依存しません。

@itemize 

@item
ブロブオブジェクトの内容は、解釈されていないバイトのシーケンスです。コアレベルでのエンコーディング変換はありません。

@item
パス名はUTF-8正規化形式C(UTF-8 normalization form C)でエンコードされます。これは、ツリーオブジェクト、インデックスファイル、ref名、およびコマンドライン引数、環境変数、構成ファイル( @samp{.git/config} (git-config(1) 参照) と gitignore(5) と gitattributes(5) と gitmodules(5)) のパス名に適用されます。

コアレベルのGitは、パス名を単に非NULバイトのシーケンスとして扱い、パス名をエンコードする変換はありません(MacとWindowsを除く)。したがって、非ASCIIパス名の使用は、レガシー拡張ASCIIエンコーディングを使用するプラットフォームやファイルシステムでもほとんど機能します。ただし、そのようなシステムで作成されたリポジトリは、UTF-8ベースのシステム(Linux、Mac、Windowsなど)では正しく機能しません。その逆も同様です。さらに、多くのGitベースのツールは、パス名がUTF-8であると単純に想定しており、他のエンコーディングを正しく表示できません。

@item
コミットログメッセージは通常UTF-8でエンコードされますが、他の拡張ASCIIエンコードもサポートされています。これには、ISO-8859-x、CP125xなどが含まれますが、UTF-16/32、EBCDIC、およびCJKマルチバイトエンコーディング(GBK、Shift-JIS、Big5、EUC-x、CP9xxなど)は含まれません。
@end itemize

我々はコミットログメッセージをUTF-8でエンコードすることをお勧めしますが、コアとGit Porcelainはどちらも、プロジェクトでUTF-8を強制しないように設計されています。特定のプロジェクトのすべての参加者がレガシーエンコーディングを使用する方が便利だと感じた場合、Gitはそれを禁止しません。 ただし、覚えておくべきことがいくつかあります。

@enumerate 

@item
@samp{git commit} と @samp{git commit-tree} は、プロジェクトがレガシーエンコーディングを使用していることを明示的に指定しない限り、与えられたコミットログメッセージが有効なUTF-8文字列のように見えない場合に警告を発します。明示的に指定する方法は、以下のように、 @samp{.git/config} ファイルに @samp{i18n.commitEncoding} を含めることです。

@example
[i18n]
        commitEncoding = ISO-8859-1
@end example


上記の設定で作成されたコミットオブジェクトは、 @samp{encoding} ヘッダーに @samp{i18n.commitEncoding} の値を記録します。 これは、後でそれらを見る他の人々を助けるためです。このヘッダーがないということは、コミットログメッセージがUTF-8でエンコードされていることを意味します。

@item
@samp{git log} や @samp{git show} や @samp{git blame} とその仲間たちは、コミットオブジェクトの @samp{encoding} ヘッダーを見て、特に指定がない限り、ログメッセージをUTF-8に再コーディングしようとします。あなたは以下のように、 @samp{.git/config} ファイルの @samp{i18n.logOutputEncoding} を使用して目的の出力エンコーディングを指定できます。

@example
[i18n]
        logOutputEncoding = ISO-8859-1
@end example


この構成変数がない場合は、代わりに @samp{i18n.commitEncoding} の値が使用されます。
@end enumerate

UTF-8への再コーディングは必ずしも可逆的な操作ではないため、我々はコミットが行われたときにコミットログメッセージを再コーディングしないことを意図的に選択したことに注意してください。

@noindent

@chapheading ENVIRONMENT AND CONFIGURATION VARIABLES

コミットログメッセージの編集に使用されるエディターは、 @samp{GIT_EDITOR} 環境変数 または core.editor 構成変数 または @samp{VISUAL} 環境変数 または @samp{EDITOR} 環境変数から(この順序で)選択されます。 詳細については、 git-var(1) を参照してください。

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  commit.cleanup 
この設定は、 @samp{git commit} の @samp{--cleanup} オプションのデフォルトを上書きします。 詳細については、 git-commit(1) を参照してください。 デフォルトを変更すると、コメント文字 @samp{#} で始まる行をログメッセージに常に残しておきたい場合に役立ちます。その場合は、 @samp{git config commit.cleanup whitespace} を実行します(注意:これを行う場合は、コミットログテンプレートの @samp{#} で始まるヘルプ行を自分で削除する必要があることに注意してください)。

@item  commit.gpgSign 
すべてのコミットをGPG署名する必要があるかどうかを指定するブール値。 リベースなどの操作を行うときにこのオプションを使用すると、多数のコミットが署名される可能性があります。 エージェントを使用して、GPGパスフレーズの入力を省略するようにすると便利な場合があります。

@item  commit.status 
エディタを使用してコミットメッセージを準備するときに、コミットメッセージテンプレートにステータス情報を含めることを有効/無効にするブール値。 デフォルトはtrueです。

@item  commit.template 
新しいコミットメッセージのテンプレートとして使用するファイルのパス名を指定します。

@item  commit.verbose 
@samp{git commit} でverboseレベルを指定するブール値またはint。 git-commit(1) を参照してください。
@end table

@noindent

@chapheading HOOKS

このコマンドは、 @samp{commit-msg} フックと、 @samp{prepare-commit-msg} フックと、 @samp{pre-commit} フックと、 @samp{post-commit} フックと、 @samp{post-rewrite} フック を実行できます。 詳細については、 githooks(5) を参照してください。

@noindent

@chapheading FILES

@table @asis

@item  @samp{$GIT_DIR/COMMIT_EDITMSG} 
このファイルには、進行中のコミットのコミットメッセージが含まれています。 コミットを作成する前にエラーが原因で @samp{gitc ommit} が終了した場合、ユーザーによって提供されたコミットメッセージ(エディターセッションなど)は全てこのファイルに残りますが、次の @samp{git commit} の呼び出しによって上書きされます。
@end table

@noindent

@chapheading SEE ALSO

git-add(1), git-rm(1), git-mv(1), git-merge(1), git-commit-tree(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-config,,,Top
@chapheading Name

git-config — リポジトリオプションまたはグローバルオプションを、取得および設定する

@noindent

@chapheading Synopsis

@display
git config [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]
git config [<file-option>] [--type=<type>] --add <name> <value>
git config [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]
git config [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>
git config [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]
git config [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]
git config [<file-option>] --rename-section <old-name> <new-name>
git config [<file-option>] --remove-section <name>
git config [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list
git config [<file-option>] --get-color <name> [<default>]
git config [<file-option>] --get-colorbool <name> [<stdout-is-tty>]
git config [<file-option>] -e | --edit
@end display


@noindent

@chapheading DESCRIPTION

このコマンドを使用して、オプションを照会(query)/設定(set)/置換(replace)/設定解除(unset;削除)できます。名前は実際にはドットで区切られたセクションとキーであり、値はエスケープされます。

@samp{--add} オプションを使用すると、オプションに複数の行を追加できます。複数行で発生する可能性のあるオプションを更新または設定解除する場合は、@samp{value-pattern} ( @samp{--fixed-value} オプションが指定されていない限り、拡張正規表現)を指定する必要があります。パターンに一致する既存の値のみが更新または設定解除されます。パターンと「一致しない」行を処理する場合は、前に1つの感嘆符(@samp{!})を追加するだけです(@ref{EXAMPLES} も参照下さい)が、ただし、これは @samp{--fixed-value} オプションが使用されていない場合のみ機能することに注意してください。

@samp{--type=<type>} オプションは「git config」に指示して、指定の<type>の下で入力値(incoming value)と出力値(outgoing value)が正規化可能であることを確認します。 @samp{-type=<type>} が指定されていない場合、正規化は実行されません。 呼び出し元は、既に指定済の @samp{--type} 指定子を @samp{--no-type} で設定解除できます。

読み取り時、値はデフォルトでシステム、グローバル、リポジトリのローカル構成ファイルから読み取られ、オプション @samp{--system} 、@samp{--global} 、 @samp{--local} 、 @samp{--worktree} 、 `--file <filename> ` を使用して、その場所から「のみ」読み取るようにコマンドに指示できます(@ref{FILES} 参照)。

書き込み時、新しい値はデフォルトでリポジトリのローカル構成ファイルに書き込まれます。オプション @samp{--system} 、@samp{--global} 、 @samp{--worktree} 、@samp{--file <filename> ` を使用すれば、コマンドにその場所に書き込むよう指示できます(あなたは `--local} と言うこともでき、そしてこれはデフォルトです)。

このコマンドは、エラー時にゼロ以外のステータスで失敗します。 いくつかの終了コードは以下のとおりです:

@itemize 

@item
セクションキーが不正(ret=1)

@item
セクションまたは名前が与えられてない(ret=2)

@item
configファイルが不正(ret=3)

@item
configファイルに書き込みできない(ret=4)

@item
存在しないオプションの設定を削除(unseet)しようとしました(ret=5)

@item
あなたは、複数の行が一致するオプションを設定(set)/削除(unset)しようとしています(ret=5)

@item
不正な正規表現を使おうとしています(ret=6)
@end itemize

成功の場合、コマンドは終了コード 0 を返します。

使用可能なすべての構成変数のリストは、 @samp{git help --config} コマンドを使用して取得できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--replace-all} 
デフォルトの振る舞いでは最大1行を置き換えますが、このオプションより、キー(およびオプションで @samp{value-pattern})に一致するすべての行が置換されます。

@item  @samp{--add} 
既存の値を変更せずに、オプションに新しい「行を追加」します。 これは @samp{--replace-all} の @samp{value-pattern} として @samp{^$} を指定しても同じ事が可能です。

@item  @samp{--get} 
指定されたキーの値を取得します(オプションで、値に一致する正規表現でフィルタリングされます)。キーが見つからなかった場合はエラーコード1を返し、複数のキー値が見つかった場合は「最後の値」を返します。

@item  @samp{--get-all} 
@samp{--get} と同様ですが、複数値キー(複数行;multivar)のすべての値を返します。

@item  @samp{--get-regexp} 
@samp{--get-all} と同様ですが、名前を正規表現として解釈し、キー名を書き出します。正規表現の照合では現在、大文字と小文字が区別され、セクション名と変数名が小文字になっている正規化されたバージョンのキーに対して実行されますが、サブセクション名は大文字と小文字が区別されません。

@item  @samp{--get-urlmatch <name> <URL>} 
2つの部分からなる名前 section.key を指定すると、 <URL> 部分が指定したURLに最もよく一致する section.<URL>.key の値が返されます(そのようなキーが存在しない場合は、 section.keyの値にフォールバックします)。セクションだけを名前として指定した合は、当該セクション内のすべてのキー・値をリストします。値が見つからない場合はエラーコード1を返します。

@item  @samp{--global} 

オプション読み取りの場合: 使用可能なすべてのファイルからではなく、グローバル @samp{~/.gitconfig} と @samp{$XDG_CONFIG_HOME/git/config} からのみ読み取ります。

@ref{FILES} も参照して下さい。

@item  @samp{--system} 
オプション書き込みの場合: リポジトリの @samp{.git/config} ではなくシステム全体の @samp{$(prefix)/etc/gitconfig} に書き込みます。

オプション読み取りの場合: 使用可能なすべてのファイルからではなく、システム全体の @samp{$(prefix)/etc/gitconfig} からのみ読み取ります。

@ref{FILES} も参照して下さい。

@item  @samp{--local} 
オプションを書き込む場合: リポジトリの @samp{.git/config} ファイルに書き込みます。これがデフォルトの動作です。

読み取りオプションの場合: 使用可能なすべてのファイルからではなく、リポジトリ @samp{.git/config} からのみ読み取ります。

@ref{FILES} も参照して下さい。

@item  @samp{--worktree} 
@samp{extensions.worktreeConfig} が有効な場合に @samp{$GIT_DIR/config.worktree} が読み書きされることを除いて、 @samp{--local} と同様です。 そうでない場合は @samp{--local} と同じです。 @samp{$GIT_DIR} は、メインの作業ツリーでは @samp{$GIT_COMMON_DIR} と同じですが、他の作業ツリーでは @samp{$GIT_DIR/worktrees/<id>/} の形式であることに注意してください。 @samp{extensions.worktreeConfig} を有効にする方法については、 git-worktree(1) を参照してください。

@item  @samp{-f <config-file>} 
@itemx  @samp{--file <config-file>} 
オプション書き込みの場合: リポジトリの @samp{.git/config} ではなく、指定のファイルに書き込みます。

オプション読み取りの場合: 使用可能なすべてのファイルからではなく、指定のファイルからのみ読み取ります。

@ref{FILES} も参照して下さい。

@item  @samp{--blob <blob>} 
@samp{--file} に似ていますが、ファイルの代わりに指定のブロブを使用します。例えば、 @samp{master:.gitmodules} を使用して、masterブランチのファイル @samp{.gitmodules} から値を読み取ることができます。ブロブ名の綴りのより完全なリストについては、 gitrevisions(7) の「SPECIFYING REVISIONS」セクションを参照してください。

@item  @samp{--remove-section} 
指定のセクションを構成ファイルから削除します。

@item  @samp{--rename-section} 
指定のセクションの名前を新しい名前に変更します。

@item  @samp{--unset} 
キーに一致する行を構成ファイルから削除します。

@item  @samp{--unset-all} 
キーに一致するすべての行を構成ファイルから削除します。

@item  @samp{-l} 
@itemx  @samp{--list} 
構成ファイルに「設定されている」すべての変数とその値を一覧表示します(訳注:使用可能なすべての構成変数のリストは、 @samp{git help --config})。

@item  @samp{--fixed-value} 
@samp{value-pattern} 引数と一緒に使用する場合、 @samp{value-pattern} を正規表現ではなく単なる文字列として扱います。これにより、値が @samp{value-pattern} と完全に等しいものにのみ一致する、名前/値のペアだけに制限されます。

@item  @samp{--type <type>} 
「git config」は、入力または出力が指定された型(type)の制約の下で有効であることを保証し、その型の正規形式で出力値を正規化します。

有効な型には以下のものがあります:

@itemize 

@item
@samp{bool}: 値を @samp{true} または `false`として正規化します。

@item
@samp{int}: 値を単純な10進数として正規化します。オプションのサフィックス @samp{k} また @samp{m`または `g} を使用すると、入力時に値にそれぞれ1,024または1,048,576(1024^2)または1,073,741,824(10243)が掛け算されます。

@item
@samp{bool-or-int}: 上記のように、 @samp{bool} または @samp{int} のいずれかに従って正規化します。

@item
@samp{path}: @samp{$HOME} の値を意味する @samp{~} を先頭に追加し、指定のユーザのホームディレクトリを @samp{~user} として正規化します。この @samp{~} は値を書き込むときには効果がありません(ただし、あなたはコマンドラインから @samp{git config section.variable ~/} と実行してシェルに展開をさせることができます)。

@item
@samp{expiry-date}: 固定または相対の日付文字列からタイムスタンプに変換することで正規化します。この指定は値を書き込むときには効果がありません。

@item
@samp{color}: 値を取得するときに、ANSIカラーエスケープシーケンスに変換して正規化します。値を設定するとき、指定された値がANSIカラーとして正規化可能であることを確認するために健全性チェックが実行されますが、正規化自体は行われず、そのまま書き込まれます。
@end itemize

@item  @samp{--bool} 
@itemx  @samp{--int} 
@itemx  @samp{--bool-or-int} 
@itemx  @samp{--path} 
@itemx  @samp{--expiry-date} 
タイプ指定子を選択するための歴史的オプション。 代わりに @samp{--type} を優先します(上記参照)。

@item  @samp{--no-type} 
(これ以前に設定されていた場合、)これ以前に設定された型指定子の設定を解除します。このオプションは、「git config」が取得した変数を正規化しないように要求します。 @samp{--no-type} は、@samp{--type=<type>} または @samp{--<type>} が無い場合は何の効果もありません。

@item  @samp{-z} 
@itemx  @samp{--null} 
値やキーを出力するすべてのオプションで、値を(改行ではなく)常にヌルバイト(\0)で終了します。代わりに、キーと値の間の区切り文字として改行を使用します。これにより、例えば、改行を含む値を混乱することなく、出力を安全にパースできます。

@item  @samp{--name-only} 
@samp{--list} または @samp{--get-regexp} の構成変数で名前のみを出力します。

@item  @samp{--show-origin} 
照会されたすべての構成オプションの出力に、その構成オプションの出処の種類(ファイル、標準入力、blob、コマンドライン)と実際の出処(設定ファイルのパス、参照、または該当する場合はblobのID)を追加します。

@item  @samp{--show-scope} 
@samp{--show-origin} と同様に、クエリされたすべての設定オプションの出力をその値のスコープ(worktree, local, global, system, command)で拡張します。

@item  @samp{--get-colorbool <name> [<stdout-is-tty>]} 
@samp{name} の色設定(たとえば @samp{color.diff})を見つけて、 @samp{true} または @samp{false} を出力します。 @samp{<stdout-is-tty>} は @samp{true} または @samp{false} のいずれかである必要があり、構成で @samp{auto`と表示されている場合に考慮されます。 `<stdout-is-tty>} がない場合は、コマンド自体の標準出力をチェックし、色を使用する場合はステータス0で終了し、それ以外の場合はステータス1で終了します。 @samp{name} の色設定が未定義の場合、コマンドはフォールバックとして @samp{color.ui} を使用します。

@item  @samp{--get-color <name> [<default>]} 
@samp{name} (例: @samp{color.diff.new}) に設定されている色を見つけて、ANSIカラーエスケープシーケンスとして標準出力に出力します。 @samp{name} に色が設定されていない場合は、オプションの @samp{default} パラメータが代わりに使用されます。

@samp{--type=color [--default=<default>]} は @samp{--get-color} よりも優先されます(ただし、 @samp{--get-color} は、 @samp{--type=color} によって出力される末尾の改行を省略します)。

@item  @samp{-e} 
@itemx  @samp{--edit} 
指定の構成ファイルを変更するためのエディタを開きます。指定できるのは、 @samp{--system} または @samp{--global} または「リポジトリ」(指定なし;デフォルト)、のいずれかです。

@item  @samp{--[no-]includes} 
値を検索するときは、設定ファイルの @samp{include.*} ディレクティブを尊重します。特定のファイルが指定されている場合(たとえば、 @samp{--file} 、@samp{--global} などを使用した場合)はデフォルトで @samp{off} になり、すべての構成ファイルを検索する場合は @samp{on} になります。

@item  @samp{--default <value>} 
@samp{--get} を使用していて、要求した変数が見つからない場合、 <value> がその変数に割り当てられた値であるかのように動作します。
@end table

@noindent

@chapheading CONFIGURATION

@samp{pager.config} は、構成を一覧表示する場合、つまり、 ` --list` 、または複数の結果を返す可能性のある @samp{--get-*} のいずれか、を使用する場合にのみ尊重されます。デフォルトでは pager を使用します。

@noindent

@chapheading FILES

デフォルトでは、 「git config」は複数のファイルから構成オプションを読み取ります:

@table @asis

@item  $(prefix)/etc/gitconfig 
システム全体(PC毎)の構成ファイル

@item  $XDG_CONFIG_HOME/git/config 
@itemx  ~/.gitconfig 
ユーザー固有の構成ファイル。 XDG_CONFIG_HOME 環境変数が設定されていないか空の場合、 $XDG_CONFIG_HOME として $HOME/.config/ が使用されます。

これらは「グローバル」(global)構成ファイルとも呼ばれます。 両方のファイルが存在する場合、両方のファイルが上記の順序で読み取られます。

@item  $GIT_DIR/config 
リポジトリ毎の構成ファイル。

@item  $GIT_DIR/config.worktree 
これはオプションであり、 @samp{extensions.worktreeConfig} が $GIT_DIR/config に存在する場合にのみ検索されます。
@end table

任意の git コマンドを実行するとき、 @samp{-c} オプションを使用して、 追加の構成パラメーターを指定することもできます。 詳細については、 git(1) を参照してください。

オプションは、利用可能なこれらすべてのファイルから読み取られます。 グローバルまたはシステム全体の構成ファイルが見つからないか読み取れない場合、それらは無視されます。 リポジトリ構成ファイルが見つからないか読み取れない場合、 「git config」はゼロ以外のエラー・コードで終了します。 ファイルが読み取れない場合はエラー・メッセージが生成されますが、見つからない場合は生成されません。

ファイルは上記の順序で読み取られ、「最後」に見つかった値が前に読み取った値よりも優先されます。なお、複数値(multiple values)を取得すると、すべてのファイルのキーのすべての値が使用されます。

デフォルトでは、オプションはリポジトリ固有の構成ファイルにのみ書き込まれます。 これは、 @samp{--replace-all} や @samp{--unset} などのオプションにも影響することに注意してください。 「@samp{git config} は、一度に 1 つのファイルのみを変更します。」

ファイルのパスを @samp{--file} オプションで指定したり、構成スコープ(configuration scope)を @samp{--system} または @samp{--global} または @samp{--local} または @samp{--worktree} で指定することにより、どの構成ソース(configuration sources)を読み書きするかを制限することが可能です。 詳しくは、上記の @ref{OPTIONS} を参照してください。

@noindent

@chapheading SCOPES

各構成ソース(configuration source)は、構成スコープ(configuration scope)内にあります。それらスコープは以下のとおりです:

@table @asis

@item  system 
$(prefix)/etc/gitconfig

@item  global 
$XDG_CONFIG_HOME/git/config

~/.gitconfig

@item  local 
$GIT_DIR/config

@item  worktree 
$GIT_DIR/config.worktree

@item  command 
GIT_CONFIG_@{COUNT,KEY,VALUE@} 環境変数 (下記 @ref{ENVIRONMENT} 参照)

@samp{-c} オプション
@end table

@samp{command} を除いて、各スコープは各コマンド・ライン・オプションに対応します: @samp{--system}, @samp{--global}, @samp{--local}, @samp{--worktree}

オプションを読み取るとき、スコープを指定すると、そのスコープ内のファイル達からオプション達のみが読み取られます。 オプションを記述するときに、スコープを指定すると、(リポジトリ固有の構成ファイルではなく) そのスコープ内のファイルに書き込まれます。 完全な説明については、上記 @ref{OPTIONS} を参照してください。

ほとんどの構成オプションは、定義されているスコープに関係なく適用されますが、一部のオプションは特定のスコープでのみ適用されます。 詳細については、それぞれのオプションのドキュメントを参照してください。

@noindent

@heading Protected configuration

保護された構成(protected configuration)は、 @samp{system} と @samp{global} と @samp{command} スコープを参照します。 セキュリティ上の理由から、特定のオプションは、保護された構成で指定されている場合にのみ尊重され、それ以外の場合は無視されます。

Gitはこれらのスコープを、あたかもユーザーまたは信頼できる管理者によって制御されているかのように扱います。これは、これらのスコープを制御する攻撃者は、Gitを使用せずに実質的な害を与えることができるのだから、当然、ユーザーの環境は攻撃者からこれらのスコープを保護しているに違いないはずだと想定するのです。(訳注:ユーザ側で攻撃されないようにちゃんと保護しといてください、Git側では責任もてません の意)

@noindent

@chapheading ENVIRONMENT

@table @asis

@item  GIT_CONFIG_GLOBAL 
@itemx  GIT_CONFIG_SYSTEM 
グローバルまたはシステムレベルの構成からではなく、指定されたファイルから構成を取得します。詳細については git(1) を参照してください。

@item  GIT_CONFIG_NOSYSTEM 
システム全体(PC毎)の $(prefix)/etc/gitconfig ファイルからの設定の読み取りをスキップするかどうか。詳細については git(1) を参照してください。
@end table

@ref{FILES} も参照して下さい。

@table @asis

@item  GIT_CONFIG_COUNT 
@itemx  GIT_CONFIG_KEY_<n> 
@itemx  GIT_CONFIG_VALUE_<n> 
GIT_CONFIG_COUNTが正の数に設定されている場合、その数までのすべての環境ペア GIT_CONFIG_KEY_<n> と GIT_CONFIG_VALUE_<n> がプロセスのランタイム構成に追加されます。構成ペアはゼロインデックスです。キーまたは値が欠落している場合は、エラーとして扱われます。空のGIT_CONFIG_COUNTは、GIT_CONFIG_COUNT=0と同じように扱われます。つまり、ペアは処理されません。これらの環境変数は構成ファイルの値をオーバーライドしますが、 @samp{git -c} を介して渡された明示的なオプションによってオーバーライドされます。

これは、共通の構成で複数のgitコマンドを生成したいが、スクリプトを作成する場合など、構成ファイルに依存できない場合に役立ちます。

@item  GIT_CONFIG 
@samp{git config} に @samp{--file} オプションが指定されていない場合は、 @samp{--file} を介して提供されているかのように @samp{GIT_CONFIG} によって指定されたファイルを使用します。この変数は他のGitコマンドには影響せず、主に歴史的な互換性のためのものです。 通常、 @samp{--file} オプションの代わりに使用する理由はありません。
@end table

@noindent

@chapheading EXAMPLES

以下の .git/config が与えられているものとします:

@example
#
# This is the config file, and
# a '#' or ';' character indicates
# a comment
#

; core variables
[core]
        ; Don't trust file modes
        filemode = false

; Our diff algorithm
[diff]
        external = /usr/local/bin/diff-wrapper
        renames = true

; Proxy settings
[core]
        gitproxy=proxy-command for kernel.org
        gitproxy=default-proxy ; for all the rest

; HTTP
[http]
        sslVerify
[http "https://weak.example.com"]
        sslVerify = false
        cookieFile = /tmp/cookie.txt
@end example


あなたは以下のようにしてfilemodeをtrueに設定できます

@example
% git config core.filemode true
@end example


この架空のプロキシ・コマンド・エントリには、実際には適用先の URL を識別するための接尾辞があります。 kernel.org のエントリを @samp{ssh} に変更する方法は以下のとおりです:

@example
% git config core.gitproxy '"ssh" for kernel.org' 'for kernel.org$'
@end example


これにより、kernel.orgのキーと値のペアのみが置き換えられます。

renamesのエントリを削除するには

@example
% git config --unset diff.renames
@end example


マルチ変数(multivar)(上記のcore.gitproxyなど)のエントリを削除する場合は、正確に1行の値に一致する正規表現を指定する必要があります。

特定のキーの値を照会するには、次のようにします。

@example
% git config --get core.filemode
@end example


または

@example
% git config core.filemode
@end example


また、マルチ変数(multivar)の照会は:

@example
% git config --get core.gitproxy "for kernel.org$"
@end example


マルチ変数のすべての値を知りたい場合は、次のようにします:

@example
% git config --get-all core.gitproxy
@end example


あなたが危険極まりない人生を送りたい場合は、以下のようにして core.gitproxy の「全て」を新しいものに置き換えることができます。

@example
% git config --replace-all core.gitproxy ssh
@end example


しかし、あなたが本当にデフォルトプロキシの行、つまり「for …」の接尾辞のない行だけを置き換えたい場合は、次のようにします:

@example
% git config core.gitproxy ssh '! for '
@end example


感嘆符(@samp{!})と実際に一致させるには、以下のことを行う必要があります。

@example
% git config section.key value '[!]'
@end example


既存のプロキシを変更せずに新しいプロキシを追加するには、以下を使用します。

@example
% git config --add core.gitproxy '"proxy-command" for example.com'
@end example


あなたのスクリプトで構成からカスタマイズされた色を使う例:

@example
#!/bin/sh
WS=$(git config --get-color color.diff.whitespace "blue reverse")
RESET=$(git config --get-color "" "reset")
echo "$@{WS@}your whitespace color or blue reverse$@{RESET@}"
@end example


URL が @samp{https://weak.example.com} の場合、 @samp{http.sslVerify} はfalseに設定され、他のすべてのURLでは @samp{true} に設定されます:

@example
% git config --type=bool --get-urlmatch http.sslverify https://good.example.com
true
% git config --type=bool --get-urlmatch http.sslverify https://weak.example.com
false
% git config --get-urlmatch http https://weak.example.com
http.cookieFile /tmp/cookie.txt
http.sslverify false
@end example


@noindent

@chapheading CONFIGURATION FILE

Git構成ファイルには、Gitコマンドの動作に影響を与えるいくつかの変数が含まれています。各リポジトリ内のファイル @samp{.git/config} と、オプションで @samp{config.worktree} (git-worktree(1) の「CONFIGURATION FILE」セクションを参照)は、そのリポジトリの設定を保存するために使用され、 @samp{$HOME/.gitconfig} は、ユーザーごとの構成を @samp{.git/config} ファイルのフォールバック値として保存するために使用されます。 ファイル @samp{/etc/gitconfig} を使用して、システム全体のデフォルト設定を保存できます。

構成変数は、Git配管コマンドとGit磁器コマンドの両方で使用されます。変数はセクションに分割されます。変数自体の完全修飾変数名は最後のドット区切りセグメントであり、セクション名は最後のドットより前のすべてです。変数名では大文字と小文字が区別されず、英数字(alphanumeric)と @samp{-}(\x2d) のみが許可され、英字(alphabetic)で始まる必要があります。一部の変数は複数回現れる場合があり、その変数はmultivalueであると言います(訳注:multiple lines(複数行)という表現とmultivalueと言う表現が混在する。configでは同じ意味)。

@noindent

@heading Syntax

構文はかなり柔軟で寛容です。空白(whitespace)はほとんど無視されます。 @emph{#} と @emph{;} 文字はそこからその行の行末までコメントにします。空白行は無視されます。

このファイルは、セクションと変数で構成されています。セクションは角括弧内(@samp{[' … `]')のセクションの名前で始まり、次のセクションが始まるまで続きます。セクション名では大文字と小文字は区別されません。セクション名には、英数字(alphanumeric) と `-} (\x2d) と @samp{.} (\x2e) のみを使用できます。各変数はあるセクションに属している必要があります。つまり、変数の最初の設定の前にセクションヘッダーが必要です。

セクションはさらにサブセクションに分割できます。サブセクションを開始するには、以下の例のように、セクションヘッダーで、セクション名からスペースで区切って、その名前を二重引用符で囲みます:

@example
        [section "subsection"]
@end example


サブセクション名では大文字と小文字が区別され、改行とヌルバイト(\x00)以外の任意の文字を含めることができます。 二重引用符 @samp{"} (\x22)と バックスラッシュ(\x5c;日本の環境では円記号で表示される事がある)は、それぞれ @samp{\"} と @samp{\\} としてエスケープすることで含めることができます。 他の文字の前にあるバックスラッシュは、読み取るときに削除されます。 たとえば、 @samp{\t} は @samp{t} として読み取られ、 @samp{\0} は @samp{0} として読み取られます。セクションヘッダーは複数行にまたがることはできません。変数は、セクションまたは特定のサブセクションに直接属する場合があります。 @samp{[section" subsection "]} がある場合は @samp{[section]} も使用できますが、必須ではありません。

非推奨の @samp{[section.subsection]} 構文があります。この構文では、サブセクション名は小文字に変換され、大文字と小文字が区別されて比較されます。これらのサブセクション名は、セクション名と同じ制限に従います。

他のすべての行(およびセクションヘッダーの後の行の残りの部分)は、「name = value」(または単に「name」)の形式で設定変数として認識されます(「name」形式は「name = true」の省略形で、変数をブール値「true」に設定します)。変数名では大文字と小文字が区別されず、英数字(alphanumeric)と @samp{-} (\x2d) のみが許可され、英字(alphabetic)で始まる必要があります。

値を定義する行は、 @samp{\} (\x5c) で終了することにより、次の行に続けることができます。続けた時、バックスラッシュと行末は削除されて認識されます。 @emph{name =} の後の先頭の空白と、その行で最初に現れるコメント文字 @emph{#} または @emph{;} 以降行末まで、または、行末尾の空白は、二重引用符で囲まれていない限り破棄されます。値内の内部空白はそのまま保持されます。

ダブルクォートで囲まれた中では、ダブルクォート @samp{"} とバックスラッシュ @samp{\} 文字はエスケープしなければなりません。 @samp{"} を表わすには @samp{\"} を使い、 @samp{\} を表わすには @samp{\\} を使ってください。

( @samp{\"} と @samp{\\} に加えて)認識されるエスケープシーケンスは、改行文字(NL;newline)が @samp{\n} 、水平タブ(HT;TAB)が @samp{\t} 、バックスペース(BS)が @samp{\b} です。他のエスケープシーケンス(8進エスケープシーケンスを含む)は無効です。

@noindent

@heading Includes

@samp{include} セクションと @samp{includeIf} セクションを使用すると、別のソースからの設定ディレクティブを含めることができます。これら２つのセクションは、条件がtrueと評価されない場合 @samp{includeIf} セクションが無視されることを除いて、同様に動作します。 以下の「Conditional includes」を参照してください。

特別な @samp{include.path} (または @samp{includeIf.*.path} )変数をインクルードするファイルの名前に設定することにより、別の構成ファイルをインクルードできます。 変数はその値としてパス名を取り、チルダ展開の対象となります。これらの変数は複数回指定できます。

インクルードファイルの内容は、includeディレクティブの場所で見つかったかのように、すぐに挿入されます。変数の値が相対パスである場合、そのパスは、includeディレクティブが見つかった構成ファイルからの相対パスであると見なされます。例については、以下を参照してください。

@noindent

@heading Conditional includes

@samp{includeIf.<condition>.path} 変数をインクルードするファイルの名前に設定することにより、条件付きで別の構成ファイルをインクルードできます。

条件は、キーワードで始まり、その後にコロンと、形式と意味がキーワードによって異なるいくつかのデータが続きます。サポートされているキーワードは以下のとおりです:

@table @asis

@item  @samp{gitdir} 
キーワード @samp{gitdir:} 続くデータは、グロブパターンとして使用されます。 .git ディレクトリの場所がパターンと一致する場合、インクルード条件が満たされます。

@samp{.git} の場所は自動検出されるか、 @samp{$GIT_DIR} 環境変数から取得されます。 リポジトリが .git ファイルを介して(つまり、サブモジュールやリンクされたワークツリーなどから)自動検出される場合、最終的に検出される .git の場所とは、 .git ファイルの場所ではなく .git ファイルからたどった
.gitディレクトリの場所です。

パターンには、標準のグロブワイルドカードと、複数のパス部分に一致する可能性のある2つの追加のワイルドカード @samp{**/} と @samp{/**} を含めることができます。詳細については、 gitignore(5) を参照してください。便宜上、以下の記法が使えます:

@itemize 

@item
パターンが @samp{~/} で始まる場合、 @samp{~} は環境変数 @samp{HOME} の内容に置き換えられます。

@item
パターンが @samp{./} で始まる場合、現在の設定ファイルを含むディレクトリに置き換えられます。

@item
パターンが @samp{~/} ・ @samp{./} ・ @samp{/} のいずれでも始まらない場合、 @samp{**/} 自動的に先頭に追加されます。たとえば、パターン @samp{foo/bar} は @samp{**/foo/bar} になり、 @samp{/any/path/to/foo/bar} と一致します。

@item
パターンが @samp{/} で終わる場合、 @samp{**} が自動的に追加されます。 たとえば、パターン @samp{foo/} は @samp{foo/**} になります。言い換えると、「foo」ディレクトリとその中のすべてに再帰的に一致します。
@end itemize

@item  @samp{gitdir/i} 
これは、照合が大文字と小文字を区別せずに行われることを除いて、 @samp{gitdir} と同じです(大文字と小文字を区別しないファイルシステムなど)。

@item  @samp{onbranch} 
キーワード @samp{onbranch:} に続くデータは、標準のグロブワイルドカードと、複数のパス部分に一致する可能性のある2つの追加のワイルドカード @samp{**/} と @samp{/**} を含むパターンと見なされます。現在チェックアウトされているブランチの名前がパターンと一致するワークツリーにいる場合、インクルード条件が満たされます。

パターンが @samp{/} で終わる場合、 @samp{**} が自動的に追加されます。 たとえば、パターン @samp{foo/} は @samp{foo/**} になります。つまり、 @samp{foo/} で始まるすべてのブランチに一致します。これは、ブランチが階層的に編成されていて、その階層内のすべてのブランチに構成を適用する場合に役立ちます。

@item  @samp{hasconfig:remote.*.url:} 
このキーワードに続くデータは、標準のグロブ・ワイルドカード(globbing wildcards)と、複数コンポーネントに一致する 2 つの追加ワイルドカード @samp{**/} と @samp{/**} を使用したパターンと見なされます。 このキーワードが最初に表れた時、構成ファイルの残りでremote URL がスキャンされます(値は適用されません)。 このパターンに一致するremote URL が少なくとも 1 つ存在する場合、インクルード条件が満たされます。

このオプションによって (直接的または間接的に) インクルードされるファイルには、remote URL を含めることはできません。

注意:他の includeIf 条件とは異なり、この条件の解決は、条件を読み取る時点ではまだわかっていない情報に依存することに注意してください。 典型的なユース・ケースは、このオプションがシステム・レベルまたはグローバル・レベルの構成として存在し、 remote URL がローカル・レベルの構成にあるというものです。 したがって、この状態を解決するときは前方をスキャンする必要があります。 インクルードされる可能性のあるファイルが、そのようなファイルがインクルードされる可能性があるかどうかに影響を与える、鶏が先か卵が先かという問題を回避するために、Git は、これらのファイルがこれらの条件の解決に影響を与えることを禁止する (したがって remote URL を宣言することを禁止する) ことで、この循環を断ち切ります。

As for the naming of this keyword, it is for forwards compatibility with a naming scheme that supports more variable-based include conditions, but currently Git only supports the exact keyword described above.
@end table

@samp{gitdir} と @samp{gitdir/i} を介したマッチングに関するいくつかの注意事項:

@itemize 

@item
@samp{$GIT_DIR} の中のシンボリックリンクは、マッチ前に解決されません。

@item
シンボリックリンクバージョンとrealpathバージョンの両方のパスが、 @samp{$GIT_DIR} の値と照合されます。例えば @samp{~/git} が @samp{/mnt/storage/git} へのシンボリックリンクである場合、 @samp{gitdir:~/git} と @samp{gitdir:/mnt/storage/git} の両方が一致します。

これは、Git v2.13.0 でのこの機能の最初のリリースには当てはまりませんでした。これは、realpathバージョンにのみ一致していました。この機能の初期リリースとの互換性を希望する構成では、realpathバージョンのみ、あるいは両方のバージョンを指定する必要があります。

@item
注意: 「../」は特別なものではなく、文字通り一致することに注意してください。これは、あなたが望むものではない可能性があります。
@end itemize

@noindent

@heading Example

@example
# Core variables
[core]
        ; Don't trust file modes
        filemode = false

# Our diff algorithm
[diff]
        external = /usr/local/bin/diff-wrapper
        renames = true

[branch "devel"]
        remote = origin
        merge = refs/heads/devel

# Proxy settings
[core]
        gitProxy="ssh" for "kernel.org"
        gitProxy=default-proxy ; for the rest

[include]
        path = /path/to/foo.inc ; include by absolute path
        path = foo.inc ; find "foo.inc" relative to the current file
        path = ~/foo.inc ; find "foo.inc" in your `$HOME` directory

; include if $GIT_DIR is /path/to/foo/.git
[includeIf "gitdir:/path/to/foo/.git"]
        path = /path/to/foo.inc

; include for all repositories inside /path/to/group
[includeIf "gitdir:/path/to/group/"]
        path = /path/to/foo.inc

; include for all repositories inside $HOME/to/group
[includeIf "gitdir:~/to/group/"]
        path = /path/to/foo.inc

; relative paths are always relative to the including
; file (if the condition is true); their location is not
; affected by the condition
[includeIf "gitdir:/path/to/group/"]
        path = foo.inc

; include only if we are in a worktree where foo-branch is
; currently checked out
[includeIf "onbranch:foo-branch"]
        path = foo.inc

; include only if a remote with the given URL exists (note
; that such a URL may be provided later in a file or in a
; file read after this file is read, as seen in this example)
[includeIf "hasconfig:remote.*.url:https://example.com/**"]
        path = foo.inc
[remote "origin"]
        url = https://example.com/git
@end example


@noindent

@heading Values

多くの変数の値は単純な文字列として扱われますが、特定のタイプの値をとる変数があり、それらの綴り方に関する規則があります。

@table @asis

@item  boolean 
変数がブール値をとると言われるとき、「true」と「false」の多くの同義語が受け入れられます。なお、これらはすべて大文字と小文字を区別しません。

@table @asis

@item  true 
Boolean true literals are @samp{yes}, @samp{on}, @samp{true}, and @samp{1}. Also, a variable defined without @samp{= <value>} is taken as true.

@item  false 
Boolean false literals are @samp{no}, @samp{off}, @samp{false}, @samp{0} and the empty string.

@samp{--type = bool} 型指定子を使用して値を正規形に変換する場合、 @emph{git config} は、値の出力を「true」または「false」（小文字で表記）にします。
@end table

@item  integer 
さまざまなサイズを指定する多くの変数の値には、「k」、「M」などの接尾辞を付けることができます。これは、「数値に1024掛けた値に」、「数値に1024x1024を掛けた値に」などを意味します。

@item  color 
色をとる変数の値は、スペースで区切られた色(最大で2つ、1つは前景用(foreground)、もう1つは背景用(background))と、(必要な数の)属性(attribute)の「リスト」です。

使用できる基本色は、 @samp{normal} と @samp{black} と @samp{red} と @samp{green} と @samp{yellow} と @samp{blue} と @samp{magenta} と @samp{cyan} と @samp{white} と @samp{default} です。与えられた最初の色は前景用です。2番目は背景用です。 @samp{normal} と @samp{default} を除くすべての基本色には、 @samp{brightred} のように色の前に @samp{bright} と付けることで指定できる明るいバリエーションがあります。

色 @samp{normal} は色を変更しません。 空の文字列と同じですが、背景色のみを指定する場合の前景色として使用できます (たとえば、 @samp{normal red})。

色 @samp{default} は、色を端末のデフォルトに明示的にリセットします。たとえば、クリアされた背景を指定します。 端末によって異なりますが、これは通常 @samp{white black} に設定するのと同じではありません。

色は0から255までの数字で指定することもできます。これらはANSI256色モードを使用します(ただし、すべての端末がこれをサポートしているわけではないことに注意してください)。端末が24ビットRGB値をサポートしている場合は @samp{#ff0ab3} のように16進数として指定することもできます。

受け入れられる属性(attribute)は、 @samp{bold} と @samp{dim} と @samp{ul} と @samp{blink} と @samp{reverse} と @samp{italic} と @samp{strike} (取り消し線(cross-out)または「取り消し線」の文字(strikethrough letters)の場合) です。色に関する属性の位置(前、後、または中間)は重要ではありません。特定の属性は、それらの前に「no」または「no-」を付けることによってオフにすることができます(たとえば、「noreverse」、「no-ul」など)。

疑似属性 @samp{reset} は、指定された色を適用する前に、すべての色と属性をリセットします。 たとえば、@samp{reset green} は、アクティブな属性のない緑の前景とデフォルトの背景になります。

空のカラー文字列は、色の効果をまったく生成しません。 これは、色を完全に無効にすることなく、特定の要素の色付けを回避するために使用できます。

gitで事前定義されたカラースロットの場合、属性は、カラー出力の各アイテムの先頭でリセットされることを意図しています。したがって、 @samp{color.decorate.branch`を} black`に設定すると、同じ出力行の前のものが @samp{bold} または他の属性でペイントされるように設定されている場合(たとえば @samp{log --decorate} 出力のブランチ名のリストの前で括弧を開く)でも、そのブランチ名がプレーンな @samp{black} でペイントされます。ただし、カスタムログ形式では、より複雑で階層化された色付けが行われる場合があり、否定された形式が役立つ場合があります。

@item  pathname 
パス名の値をとる変数には、 @samp{~/} または @samp{~user/} で始まる文字列を指定できます。このような文字列には、通常のチルダ展開が行われます。 @samp{~/} は @samp{$HOME} の値に展開され、 @samp{~user/} は指定のユーザーのホームディレクトリに展開されます。

パスが @samp{%(prefix)/} で始まる場合、残りはGitの「ランタイムプレフィックス」に関連するパス、つまりGit自体がインストールされた場所に関連するパスとして解釈されます。 たとえば、 @samp{%(prefix)/bin/} は、Git実行可能ファイル自体が存在するディレクトリを指します。Gitがランタイムプレフィックスのサポートなしでコンパイルされた場合、代わりにコンパイルされたプレフィックスが置き換えられます。万が一、展開してはならないリテラルパスを指定する必要がある場合は、 @samp{./%(prefix)/bin} のように接頭辞 @samp{./} を付ける必要があります。
@end table

@noindent

@heading Variables

注意: このリストは包括的ではなく、必ずしも完全ではないことに注意してください。コマンド固有の変数については、適切なマニュアルページに詳細な説明があります。

他のgit関連ツールは、独自の変数を使用する場合があります。独自のツールで使用する新しい変数を考案するときは、それらの名前がGit自体や他の一般的なツールで使用されているものと競合しないことを確認し、ドキュメントに記述してください。

@table @asis

@item  advice.* 
これらの変数は、新しいユーザーを支援するために設計されたさまざまなオプションのヘルプメッセージを制御します。すべての「advice.*」変数はデフォルトで「true」に設定されており、これらを「false」に設定することで、ヘルプが不要であることをGitに伝えることができます。

@table @asis

@item  ambiguousFetchRefspec 
複数のremoteトの fetch refspec が同一のリモート追跡ブランチ名前空間に
マップされ、ブランチ追跡のセットアップが失敗する場合に
表示されるアドバイス。

@item  fetchShowForcedUpdates 
git-fetch(1)がrefの更新後に強制更新を計算したり、
チェックが無効になっていることを警告したりするのに
長い時間がかかる場合に表示されるアドバイス。

@item  pushUpdateRejected 
@samp{pushNonFFCurrent} と @samp{pushNonFFMatching} と @samp{pushAlreadyExists} と
@samp{pushFetchFirst} と @samp{pushNeedsForce} と @samp{pushRefNeedsUpdate} を
同時に無効にする場合は、この変数を
@samp{false} に設定します。

@item  pushNonFFCurrent 
現在のブランチへの non-fast-forward 更新が原因で
git-push(1) が失敗した場合に表示されるアドバイス。

@item  pushNonFFMatching 
git-push(1) を実行し、
「matching refs」を明示的にプッシュ(つまり あなたは「:」を使用したか、
あなたの現在のブランチではないrefspecを指定した)して、
「non-fast-forward」エラーが発生したときに表示されるアドバイスです。

@item  pushAlreadyExists 
git-push(1) が、
fast-forwarding の対象とならない更新(タグなど)を拒否した場合に表示されます。

@item  pushFetchFirst 
git-push(1) が、私たちが持っていないオブジェクトを指す
リモート参照を上書きしようとする更新を
拒否した場合に表示されます。

@item  pushNeedsForce 
git-push(1) が、
コミットっぽくないオブジェクトを指すリモートrefを上書きしようとする更新、
またはコミットっぽくないブジェクトを指すリモートrefを作成しようとする更新を
拒否した場合に表示されます。

@item  pushUnqualifiedRefname 
git-push(1) が、
ソースと宛先のrefsに基づいて、
ソースが属するリモートref名前空間を推測しようとするのをあきらめたときに表示されます。
ただし、
ソースオブジェクトのタイプに基づいて、
refs/heads/* または refs/tags/* のいずれかにプッシュすることを提案できる場合もあります。

@item  pushRefNeedsUpdate 
git-push(1) が、
リモート追跡refにローカルにない更新がある場合に、
ブランチの強制更新を拒否した場合に表示されます。

@item  skippedCherryPicks 
git-rebase(1) が、
アップストリームブランチにすでにチェリーピックされているコミットをスキップした場合に表示されます。

@item  statusAheadBehind 
git-status(1) が、
リモート追跡refと比較したローカルrefの先行(ahead)/遅延(behind)カウントを計算し、
その計算に予想よりも時間がかかる場合に表示されます。
@samp{status.aheadBehind} がfalseの場合、
またはオプション @samp{--no-ahead-behind} が指定されている場合は表示されません。

@item  statusHints 
git-status(1) の出力や、
git-commit(1) の
コミットメッセージ記入時のテンプレート表示や、
git-switch(1) または git-checkout(1) の
ブランチ切り替え時のヘルプメッセージに、
現在の状態からどのように進めていくかの指示を表示します。

@item  statusUoption 
コマンドが、
追跡されていないファイルを列挙するのに2秒以上かかる場合は、
git-status(1) で @samp{-u} オプション使用の検討をアドバイスします。

@item  commitBeforeMerge 
git-merge(1) がローカルの変更を上書きしないようにマージを拒否した場合に、
アドバイスが表示されます。

@item  resetNoRefresh 
コマンドがリセット後にインデックスをリフレッシュするのに2秒以上かかる場合、
git-reset(1) に @samp{--no-refresh} オプションを使用することを
検討するようにアドバイスします。

@item  resolveConflict 
競合が原因で操作が実行できない場合に、
さまざまなコマンドによって表示されるアドバイス。

@item  sequencerInUse 
シーケンサーコマンドがすでに進行中の場合に表示されるアドバイス。

@item  implicitIdentity 
システムのユーザー名とドメイン名から
情報が推測される場合のID構成の設定方法に
関するアドバイス。

@item  detachedHead 
git-switch(1) または git-checkout(1) を使用して
HEADのデタッチ状態に移行し、
事後にローカルブランチを作成する方法を
指示したときに表示されるアドバイス。

@item  suggestDetachingHead 
git-switch(1) が明示的な @samp{--detach} オプション無しで
HEAD の切り離し(detach)を拒否した場合に表示されるアドバイス。

@item  checkoutAmbiguousRemoteBranchName 
git-checkout(1) と git-switch(1) の引数が、
明確な引数によらず
リモート追跡ブランチがチェックアウトされる状況で、
複数のリモート上のリモート追跡ブランチに対して
あいまいに解決される場合に表示されるアドバイス。
このアドバイスが出力される状況で、
特定のリモートをデフォルトで
使用するように設定する方法については、
@samp{checkout.defaultRemote}
構成変数を参照してください。

@item  amWorkDir 
git-am(1) がパッチファイルの適用に失敗した場合に
パッチファイルの場所を示すアドバイス。

@item  rmHints 
git-rm(1) の出力に失敗した場合、
現在の状態からどのように進めるかについての指示を表示します。

@item  addEmbeddedRepo 
誤って、あるgitリポジトリを別のリポジトリ内に追加した
場合の対処方法に関するアドバイス。

@item  ignoredHook 
フックが実行可能ファイルとして設定されていないために
フックが無視された場合に表示されるアドバイス。

@item  waitingForEditor 
Gitがユーザーからのエディタ入力を待機しているときは、
いつでも端末にメッセージを出力します。

@item  nestedTag 
ユーザーがタグオブジェクトに再帰的にタグを付けようとした
場合に表示されるアドバイス。

@item  submoduleAlternateErrorStrategyDie 
「die」に設定された submodule.alternateErrorStrategy オプションが
致命的なエラーを引き起こす場合に表示されるアドバイス。

@item  submodulesNotUpdated 
@samp{git submodule update --init} が実行されなかったために失敗した
サブモジュール・コマンドをユーザーが実行したときに表示されるアドバイス。

@item  addIgnoredFile 
ユーザーが、無視されたファイルをインデックスに追加しようとした
場合に表示されるアドバイス。

@item  addEmptyPathspec 
ユーザーがpathspecパラメーターを指定せずに
addコマンドを実行した場合に表示されるアドバイス。

@item  updateSparsePath 
git-add(1) または git-rm(1) のいずれかが、
現在のスパースチェックアウト外のインデックスエントリを
更新するように求められたときに表示されるアドバイス。

@item  diverging 
Advice shown when a fast-forward is not possible.

@item  worktreeAddOrphan 
Advice shown when a user tries to create a worktree from an
invalid reference, to instruct how to create a new orphan
branch instead.
@end table

@item  core.fileMode 
作業ツリー内のファイルの実行可能ビットを尊重するかどうかをGitに通知します。

一部のファイルシステムでは、実行可能としてマークされたファイルがチェックアウトされるか、実行可能ビットがオンになっている実行不可能なファイルをチェックアウトすると、実行可能ビットを失います。 git-clone(1) または git-init(1) は、ファイルシステムを調査して、実行可能ビットを正しく処理し、この変数が必要に応じて自動的に設定されるかどうかを確認します。

リポジトリはファイルモードを正しく処理するファイルシステム上にある可能性があり、この変数は作成時に「true」に設定されますが、後でファイルモードを失う別の環境からアクセスできるようになる可能性があります(たとえば、CIFSマウントを介したext4のエクスポート。CygwinがGit for WindowsまたはEclipseでリポジトリを作成た時など)。このような場合、この変数を「false」に設定する必要がある場合があります。 git-update-index(1) を参照してください。

(設定ファイルでcore.filemodeが指定されていない場合、)デフォルトはtrueです。

@item  core.hideDotFiles 
(Windowsのみ)trueの場合、名前がドットで始まる、新しく作成されたディレクトリと新しく作成されたファイルを非表示としてマークします。 @samp{dotGitOnly} の場合、 @samp{.git/} ディレクトリのみが非表示になり、ドットで始まる他のファイルは非表示になりません。デフォルトのモードは @samp{dotGitOnly} です。

@item  core.ignoreCase 
APFS、HFS+、FAT、NTFSなどの大文字と小文字を区別しないファイルシステムでGitをより適切に機能させるためのさまざまな回避策を可能にする内部変数。たとえば、Gitが「Makefile」を予期しているときにディレクトリリストで「makefile」が見つかった場合、Git それは実際には同じファイルであると想定し、「Makefile」として記憶し続けます。

デフォルトはfalseですが、 git-clone(1) または git-init(1) は、リポジトリの作成時に必要に応じてcore.ignoreCaseを調査してtrueに設定します。

あなたのオペレーティングシステムとファイルシステムに関して、Gitは、この変数の適切な構成に依存しています。この値を変更すると、予期しない動作が発生する可能性があります。

@item  core.precomposeUnicode 
このオプションは、GitのMacOS実装でのみ使用されます。 core.precomposeUnicode=true の場合、GitはMacOSによって行われたファイル名のUnicode分解(unicode decomposition)を元に戻します。これは、MacOSとLinuxまたはWindowsの間でリポジトリを共有する場合に便利です。 (Git for Windows 1.7.10以降、または Git under cygwin 1.7 が必要です)。 falseの場合、ファイル名はGitによって完全に透過的に処理されます。これは、古いバージョンのGitとの下位互換性があります。

@item  core.protectHFS 
trueに設定されている場合、 HFS+ ファイルシステムで @samp{.git} と同等と見なされるパスのチェックアウトを許可しないでください。デフォルトはMacOSでは @samp{true} 、それ以外の場合は @samp{false} です。

@item  core.protectNTFS 
trueに設定されている場合、NTFSファイルシステムで問題を引き起こす可能性のあるパスのチェックアウトを許可しないでください。 例えば、 8.3 の「短い」名前と競合します。デフォルトは、Windowsでは「true」、それ以外の場合は「false」です。

@item  core.fsmonitor 
true に設定すると、この作業ディレクトリのための組み込みファイル・システム・モニター・デーモンが有効になります(git-fsmonitor--daemon(1))。

フック・ベースのファイル・システム・モニター(hook-based file system monitors)と同様に、組み込みのファイル・システム・モニターは、多数のファイルを含む作業ディレクトリで Git インデックスを更新する必要がある Git コマンド (例: @samp{git status}) を高速化できます。 組み込みのモニターにより、外部のサードパーティ ツールをインストールして維持する必要がなくなります。

組み込みのファイル・システム・モニターは、現在のところ、サポートされているプラットフォームの限られたセットでのみ使用できます。 現在、これには Windows と MacOS が含まれます。

@example
それ以外の場合、この変数には fsmonitorフック・コマンドの
パス名が含まれます。
@end example

このフック・コマンドは、要求された日時以降に変更された可能性のあるすべてのファイルを識別するために使用されます。 この情報は、変更されていないファイルの不要なスキャンを回避することで git を高速化するために使用されます。

githooks(5) の「fsmonitor-watchman」セクションを参照してください。

注意: コマンド・ラインでとあるバージョンを使用し、 IDEツールで別のバージョンを使用するなど、Gitの複数のバージョンを同時に使用する場合、 @samp{core.fsmonitor} の定義が拡張され、フック・パス名に加えてブール値が許可されることに注意してください。 Git バージョン 2.35.1 以前はブール値を認識せず、 @samp{true} または @samp{false} の値を呼び出されるフック・パス名と見なします。 Git バージョン 2.26 〜 2.35.1 までは、デフォルトでプロトコルV2 をフックし、 fsmonitor 無し (フル スキャン) にフォールバックします。 2.26 より前のバージョンの Git は、デフォルトでプロトコルV1 をフックし、報告する変更がない(スキャンなし)と暗黙のうちに想定するため、ステータス・コマンドは不完全な結果を報告する場合があります。 このため、組み込みのファイル・システム・モニターを使用する前に、すべての Git バージョンをアップグレードすることをお勧めします。

@item  core.fsmonitorHookVersion 
「fsmonitor」フックを呼び出すときに使用するプロトコル・バージョンを設定します。

現在、バージョン1と2があります。これが設定されていない場合、バージョン2が最初に試行され、失敗した場合はバージョン1が試行されます。 バージョン1は、入力としてtimpstampを使用して、それ以降に変更があったファイルを判別しますが、watchmanなどの一部のモニターでは、timestampを使用すると競合状態になります。バージョン2はopaque stringを使用しているため、モニターは競合状態なしで変更されたファイルを判別するために使用できるものを返すことができます。

@item  core.trustctime 
falseの場合、インデックスと作業ツリー間のctimeの違いは無視されます。iノードの変更時刻がGitの外部の何か(ファイルシステムクローラーおよび一部のバックアップシステム)によって定期的に変更される場合に役立ちます。 git-update-index(1) を参照してください。デフォルトではtrueです。

@item  core.splitIndex 
trueの場合、インデックスの分割インデックス機能が使用されます。 git-update-index(1) を参照してください。 デフォルトではfalseです。

@item  core.untrackedCache 
インデックスの追跡されていないモノのキャッシュ機能をどうするかを決定します。この変数が設定されていない(unset)か、 @samp{keep} に設定されている場合、キャッシュが保持されます。 @samp{true} に設定すると、自動的に追加されます。 また、 @samp{false} に設定すると、自動的に削除されます。 @samp{true} に設定する前に、mtimeがシステムで正しく機能していることを確認する必要があります。 git-update-index(1) を参照してください。 この設定をデフォルトで @samp{true} に設定する @samp{feature.manyFiles} が有効になっていない限り、デフォルトは @samp{keep} です。

@item  core.checkStat 
core.checkStat が設定されていないか @samp{default} に設定されている場合、Gitがファイルを調べてからファイルが変更されたかどうかを検出するために、stat構造体の多くのフィールドがチェックされます。この構成変数が @samp{minimal} に設定されている場合、mtimeとctimeの1秒未満の部分、ファイルの所有者のuidとgid、iノード番号(およびGitがそれを使用するようにコンパイルされている場合はデバイス番号も)はチェック対象から除外され、mtimeの2分の1の部分(および @samp{core.trustCtime} が設定されている場合はctime)とファイルサイズチェックのみがチェック対象として残ります。

(JGitなど)一部のフィールドに使用可能な値を残さないGitの実装があります。これらのフィールドを比較から除外することにより、 @samp{minimal} モードは、同じリポジトリがこれらの他のシステムによって同時に使用される場合の相互運用性に役立つ可能性があります。

@item  core.quotePath 
パスを出力するコマンド(例: @samp{ls-files} 、 @samp{diff})は、パス名を二重引用符で囲み(@samp{"..."})、Cが制御文字をエスケープするのと同じ方法でそれらの文字をバックスラッシュ(@samp{\})でエスケープすることにより、パス名の「異常な」文字をクォートします(例: TABの場合は @samp{\t} 、LFの場合は @samp{\n} 、バックスラッシュの場合は @samp{\\} )、または0x80より大きい値のバイト(たとえば、UTF-8の "micro" の場合は8進数 @samp{\302\265})。この変数がfalseに設定されている場合、0x80を超えるバイトは「異常」とは見なされなくなります。この変数の設定に関係なく、二重引用符(@samp{"})、バックスラッシュ(@samp{\})、および制御文字は常にエスケープされます。単純なスペース文字は「異常」とは見なされません。多くのコマンドは、 @samp{-z} オプションを使用してパス名を完全にそのままで出力できます。デフォルト値はtrueです。

@item  core.eol 
作業ディレクトリ内で、( @samp{text} 属性を設定するか、@samp{text=auto} とGitがコンテンツをテキストとして自動検出することにより)テキストとしてマークされたファイルが使用する行末タイプを設定します。 代替手段は、 @samp{lf} と @samp{crlf} と プラットフォームの生来の行末を使用する @samp{native} があります。デフォルト値は @samp{native} です。行末変換の詳細については、 gitattributes(5) を参照してください。注意: @samp{core.autocrlf} が @samp{true} または @samp{input} に設定されている場合、この値は無視されることに注意してください。

@item  core.safecrlf 
trueの場合、行末変換がアクティブなときに @samp{CRLF} の変換が可逆的かどうかをGitにチェックさせます。 Gitは、コマンドが作業ツリー内のファイルを直接または間接的に変更するかどうかを確認します。たとえば、あるファイルをコミットしてから同じファイルをチェックアウトすると、作業ツリーに元のファイルが生成されます。この操作が @samp{core.autocrlf} の現在の設定に当てはまらない場合、Gitはそのファイルを拒否します。変数を @samp{warn} に設定でき、その場合、Gitは不可逆的な変換についてのみ警告はしますが、操作を続行します。

CRLF変換には、データが破損する可能性がわずかにあります。有効にすると、Gitはコミット時にCRLFをLFに変換し、チェックアウト時にLFをCRLFに変換します。コミット前にLFとCRLFが混在しているファイルは、Gitでは復元できません。リポジトリにLF行末のみが含まれるように行末を修正するのは、テキストファイルの場合は正しい操作です。しかし、誤ってテキストとして分類されたバイナリファイルの場合、変換によってデータが破損する可能性があります。

あなたがこのような破損を早期に認識した場合は、 .gitattributes で変換タイプを明示的に設定することで簡単に修正できます。コミットした直後は、作業ツリーに元のファイルが残っており、このファイルはまだ破損していません。 このファイルはバイナリファイルなのだからと、Gitがファイルを適切に処理することをGitに明示的に伝えることができます。

残念ながら、行末が混在するテキストファイルをクリーンアップするという望ましい効果と、バイナリファイルを破損するという望ましくない効果を区別することはできません。どちらの場合も、CRLFは元に戻せない方法で削除されます。テキストファイルの場合、CRLFは行末であるため、これは正しいことですが、バイナリファイルの場合、CRLFを変換するとデータが破損します。

注意: この安全性チェックは、チェックアウトによって、 @samp{core.eol} と @samp{core.autocrlf} の異なる設定に対して元のファイルと同じファイルが生成されることを意味するのではなく、現在のファイルに対してのみ生成されることに注意してください。 たとえば、 @samp{LF} を含むテキストファイルは @samp{core.eol=lf} で受け入れられ、後で ` core.eol=crlf` でチェックアウトできます。この場合、結果のファイルには @samp{CRLF} が含まれますが、 元のファイルには @samp{LF`が含まれていました。 ただし、両方の作業ツリーで、行末は一貫しています。つまり、すべて `LF} または、 すべて @samp{CRLF} のいずれかですが、混合されることはありません。行末が混在するファイルは、 @samp{core.safecrlf} メカニズムによって報告されます。

@item  core.autocrlf 
この変数を「true」に設定することは、すべてのファイルで「text」属性を「auto」に設定し、core.eolを「crlf」に設定することと同じです。 作業ディレクトリに @samp{CRLF} 行末があり、リポジトリにLF行末がある場合は、trueに設定します。 この変数は「input」に設定できます。この場合、出力変換は実行されません。

@item  core.checkRoundtripEncoding 
@samp{working-tree-encoding} 属性で使用された場合に Git が UTF-8 のラウンドトリップチェックを行うエンコーディングの、カンマや空白で区切られたリスト(gitattributes(5) を参照)。デフォルト値は @samp{SHIFT-JIS} です。

@item  core.symlinks 
falseの場合、シンボリックリンクは、リンクテキストを含む小さなプレーンファイルとしてチェックアウトされます。 git-update-index(1) と git-add(1) は、記録されたタイプを通常のファイルに変更しません。シンボリックリンクをサポートしないFATのようなファイルシステムで役立ちます。

デフォルトは true ですが、git-clone(1) や git-init(1) はリポジトリの作成時に core.symlinks を調査して必要に応じて core.symlinks を false に設定します。

@item  core.gitProxy 
フェッチにGitプロトコルを使用する場合、リモートサーバーへの直接接続を確立する代わりに(「コマンドホストポート」として)実行する「プロキシコマンド」。変数値が「COMMAND for DOMAIN」形式の場合、コマンドは、指定されたドメイン文字列で終わるホスト名にのみ適用されます。この変数は複数回設定でき、指定された順序で照合されます。最初にマッチしたものが採用されます。

@samp{GIT_PROXY_COMMAND} 環境変数(特別な「for」処理なしで常に普遍的に適用されます)によってオーバーライドできます。

特別な文字列 @samp{none} をプロキシコマンドとして使用して、特定のドメインパターンにプロキシを使用しないように指定できます。これは、ファイアウォール内のサーバをプロキシの使用から除外する一方で、外部ドメインには共通のプロキシをデフォルトで使用する場合に便利です。

@item  core.sshCommand 
この変数が設定されている場合、 @samp{git fetch} と @samp{git push} は、リモートシステムに接続する必要があるときに、 @samp{ssh} の代わりに指定したコマンドを使用します。このコマンドは @samp{GIT_SSH_COMMAND} 環境変数と同じ形式であり、環境変数が設定されると上書きされます。

@item  core.ignoreStat 
trueの場合、Gitはインデックスと作業ツリーの両方で同じように更新された追跡ファイルの「assume-unchanged」(無変更と仮定する)ビットを設定することにより、ファイルが変更されたかどうかを検出するための lstat() 呼び出しを回避します。

ファイルがGitの外部で変更される場合、ユーザーは変更されたファイルを明示的にステージングする必要があります(たとえば、 git-update-index(1) の「Examples」セクションを参照)。 Gitは通常、これらのファイルへの変更を検出しません。

これは、 CIFS/Microsoft Windows など、 lstat() 呼び出しが非常に遅いシステムで役立ちます。

false がデフォルトです。

@item  core.preferSymlinkRefs 
HEADおよびその他のシンボリック参照ファイルのデフォルトの「symref」形式の代わりに、シンボリックリンクを使用します。これは、HEADがシンボリックリンクであることを期待する古いスクリプトを操作するために必要になる場合があります。

@item  core.alternateRefsCommand 
alternateから利用可能な履歴のヒントをアドバタイズする場合は、 git-for-each-ref(1) の代わりに、シェルを使用して指定されたコマンドを実行します。最初の引数は、alternateの絶対パスです。出力には、1行に1つの16進オブジェクトIDが含まれている必要があります(つまり、 @samp{git for-each-ref --format='%(objectname)'} によって生成されたものと同じある必要があります)。

注意: 通常、 あなたは @samp{git for-each-ref} をconfig値に直接入れることはできません。これは、リポジトリパスを引数として受け取らないためです(ただし、あなたは上記のコマンドをシェルスクリプトでラップすることはできます)。

@item  core.alternateRefsPrefixes 
alternateからの参照を一覧表示する場合は、指定のプレフィックスで始まる参照のみを一覧表示します。プレフィックスは git-for-each-ref(1) への引数として指定されたかのようにマッチングします。複数のプレフィックスを一覧表示するには、それらを空白で区切ります。 @samp{core.alternateRefsCommand} が設定されている場合、 @samp{core.alternateRefsPrefixes} を設定しても効果ありません。

@item  core.bare 
trueの場合、このリポジトリは「ベア」(bare;ベアリポジトリ)であると見なされ、作業ディレクトリは関連付けられていません。この場合、 git-add(1) や git-merge(1) など、作業ディレクトリを必要とする多くのコマンドが無効になります。

この設定は、リポジトリの作成時に git-clone(1) または git-init(1) によって自動的に推測されます。 デフォルトでは、 @samp{/.git} で終わるリポジトリはベアではないと見なされ(bare = false)、他のすべてのリポジトリはベアであると見なされます(bare
= true)。

@item  core.worktree 
作業ツリーのルートへのパスを設定します。 @samp{GIT_COMMON_DIR} 環境変数が設定されている場合、 core.worktree は無視され、作業ツリーのルートを決定するために使用されません。core.worktree は @samp{GIT_WORK_TREE} 環境変数と @samp{--work-tree} コマンドラインオプションで上書きできます。値は、絶対パスまたは @samp{.git} ディレクトリへの相対パスにすることができます。これは、 @samp{--git-dir} または GIT_DIR 環境変数で指定されるか、@samp{--git-dir} や GIT_DIR 環境変数の指定が無い場合は自動的に検出されます。@samp{--work-tree} と GIT_WORK_TREE と core.worktree のいずれも指定されていない場合、現在の作業ディレクトリが作業ツリーの最上位と見なされます。

注意: この変数は、ディレクトリの @samp{.git｀ サブディレクトリ内の構成ファイルに設定されている場合でも適用され、その値は前者のディレクトリとは異なることに注意してください(たとえば、 `/path/to/} ディレクトリの @samp{.git} サブディレクトリ内の構成ファイル @samp{/path/to/.git/config} 内の core.worktree が @samp{/different/path} に設定されていたとする)、これはおそらく設定ミスです。あなたが @samp{/path/to} ディレクトリでGitコマンドを実行すると、引き続き @samp{/different/path} が作業ツリーのルートとして使用され、あなたが何をしているのか分かっている(たとえば、リポジトリの通常の作業ツリーとは異なる場所に同じインデックスの読み取り専用スナップショットを作成している)のでない限り混乱を招く可能性があります。

@item  core.logAllRefUpdates 
reflogを有効にします。新旧のSHA-1の追加や、日付/時刻・理由の更新による、refである <ref> の更新は、ファイル @samp{$GIT_DIR/logs/<ref>} が存在する場合のみ、そのファイルにロギングされます。この構成変数が @samp{true} に設定されている場合、欠落している @samp{$GIT_DIR/logs/<ref>} ファイルがブランチヘッド(つまり、 @samp{refs/heads/} 下)、リモートref(つまり、 refs/ 下)、note refs(つまり、 @samp{refs/notes/} 下)、およびシンボリックref @samp{HEAD} 。 @samp{always`に設定されている場合、欠落しているreflogは、 `refs/} 下のすべてのrefに対して自動的に作成されます。

この情報を使用して、「2日前」(2 days ago)にブランチの先端であったコミットを判別できます。

この値は、作業ディレクトリが関連付けられているリポジトリではデフォルトでtrueになり、ベアリポジトリではデフォルトでfalseになります。

@item  core.repositoryFormatVersion 
リポジトリの形式とレイアウトのバージョンを識別する内部変数。

@item  core.sharedRepository 
@samp{group} (または @samp{true} )の場合、リポジトリはグループ内の複数のユーザー間で共有可能になります(すべてのファイルとオブジェクトがグループ書き込み可能であることを確認してください)。 @samp{all} (または @samp{world} または @samp{everybody})の場合、リポジトリはグループ共有可能であることに加えて、すべてのユーザーが読み取り可能になります。 @samp{umask} (または @samp{false} )の場合、Gitは umask(2) によって報告された権限を使用します。 @samp{0xxx} (@samp{0xxx} は8進数)の場合、リポジトリ内のファイルはこのモード値になります。「0xxx」はユーザーのumask値をオーバーライドします(他のオプションはユーザーのumask値の要求された部分のみをオーバーライドします)。例: @samp{0660} は、所有者とグループがリポジトリを 読み取り/書き込み 可能にしますが、他のユーザーはアクセスできません(umaskが @samp{0022} などでない限り、 @samp{group} と同等です)。 @samp{0640} は、グループで読み取り可能ですが、グループで書き込み可能ではないリポジトリです。 git-init(1) を参照してください。 デフォルトでは False です。

@item  core.warnAmbiguousRefs 
trueの場合、渡したref名があいまいでリポジトリ内の複数のrefと一致する可能性がある場合、Gitは警告を表示します。 デフォルトではtrue。

@item  core.compression 
デフォルトの圧縮レベルを示す整数 -1〜9。 -1はzlibのデフォルトです。0は圧縮がないことを意味し、1〜9はさまざまな速度とサイズのトレードオフであり、9が最も低速です。設定されている場合、これは @samp{core.looseCompression} や @samp{pack.compression} などの他の圧縮変数のデフォルトを提供します。

@item  core.looseCompression 
整数 -1〜9は、パックファイルにないオブジェクトの圧縮レベルを示します。-1はzlibのデフォルトです。0は圧縮がないことを意味し、1〜9はさまざまな速度とサイズのトレードオフであり、9が最も低速です。設定されていない場合、デフォルトは core.compression です。 これが設定されていない場合、デフォルトは1(最高速度)になります。

@item  core.packedGitWindowSize 
1回のマッピング操作でメモリにマップするパックファイルのバイト数。ウィンドウサイズを大きくすると、システムが少数の大きなパックファイルをより迅速に処理できるようになる場合があります。ウィンドウサイズを小さくすると、オペレーティングシステムのメモリマネージャへの呼び出しが増えるため、パフォーマンスに悪影響を及ぼしますが、多数の大きなパックファイルにアクセスする場合のパフォーマンスが向上する可能性があります。

コンパイル時にNO_MMAPが設定されている場合、デフォルトは1Mバイトです。それ以外の場合、32ビットプラットフォームでは32Mバイト、64ビットプラットフォームでは1Gバイトです。これは、すべてのユーザー/オペレーティングシステムにとって妥当なはずです。おそらくあなたはこの値を調整する必要はありません。

@samp{k} または @samp{m} または @samp{g} の一般的な単位接尾辞がサポートされています。

@item  core.packedGitLimit 
パックファイルからメモリに同時にマップする最大バイト数。Gitが操作を完了するために一度にこれ以上のバイトにアクセスする必要がある場合、Gitは既存の領域のマップを解除して、プロセス内の仮想アドレス空間を再利用します。

デフォルトは、32ビットプラットフォームでは256Mバイト、64ビットプラットフォームでは32Tバイト(事実上無制限)です。これは、超巨大プロジェクトを除いて、すべてのユーザー/オペレーティングシステムにとって妥当なはずです。あなたは、おそらくこの値を調整する必要はありません。

@samp{k} または @samp{m} または @samp{g} の一般的な単位接尾辞がサポートされています。

@item  core.deltaBaseCacheLimit 
複数の削除されたオブジェクトによって参照される可能性のあるベースオブジェクトをキャッシュするために予約するスレッドあたりの最大バイト数。解凍(decompress)されたベースオブジェクト全体をキャッシュに保存することで、Gitは頻繁に使用されるベースオブジェクトを何度もアンパックおよび解凍することを回避できます。

デフォルトは、すべてのプラットフォームで96Mバイトです。これは、超巨大プロジェクトを除いて、すべてのユーザー/オペレーティングシステムにとって妥当なはずです。あなたは、おそらくこの値を調整する必要はありません。

@samp{k} または @samp{m} または @samp{g} の一般的な単位接尾辞がサポートされています。

@item  core.bigFileThreshold 
「大きい」(big)と見なされるファイルのサイズは、以下で説明するように、多数の git コマンドの動作と、そのようなファイルがリポジトリ内に格納される方法を変更します。 デフォルトは 512 MiB です。 @samp{k} または @samp{m} または @samp{g} の一般的な単位サフィックスがサポートされています。

構成された制限を超えるファイルは以下のようになります:

@itemize 

@item
デルタ圧縮を試行せずに、圧縮された状態でパックファイルに保存されます。

デフォルトの制限は、主にこのユースケースを念頭に置いて設定されています。 これにより、ほとんどのプロジェクトのソース・コードとその他のテキスト・ファイルはデルタ圧縮されますが、より大きなバイナリ・メディア・ファイルは圧縮されません。

デルタ圧縮なしで大きなファイルを保存すると、ディスク使用量が増えるというわずかな犠牲を払って、過度のメモリ使用量を回避できます。

@item
「binary」とラベル付けされているかのように扱われます(gitattributes(5) 参照)。 例えば git-log(1) と git-diff(1) は、この制限を超えるファイルのdiffを計算しません。

@item
通常、書き込み時にストリーミングされます。これにより、過度のメモリ使用が回避されますが、一定のオーバーヘッドが発生します。 これを利用するコマンドには、 git-archive(1) や git-fast-import(1) や git-index-pack(1) や git-unpack-objects(1) や git-fsck(1) などがあります。
@end itemize

@item  core.excludesFile 
@samp{.gitignore} (ディレクトリごと)と @samp{.git/info/exclude} に加えて、追跡されることを意図されていないパスを記述するパターンを含むファイルへのパス名を指定します。 デフォルトは @samp{$XDG_CONFIG_HOME/git/ignore} です。 @samp{$XDG_CONFIG_HOME} が設定されていないか空の場合、代わりに @samp{$HOME/.config/git/ignore} が使用されます。 gitignore(5) を参照してください。

@item  core.askPass 
パスワードを対話的に要求する一部のコマンド(svnやhttpインターフェイスなど)は、この変数の値を介して指定された外部プログラムを使用するように指示できます。 @samp{GIT_ASKPASS} 環境変数でオーバーライドできます。設定されていない場合は、 @samp{SSH_ASKPASS} 環境変数の値にフォールバックするか、それが失敗した場合は、単純なパスワードプロンプトにフォールバックします。外部プログラムには、コマンドライン引数として適切なプロンプトが与えられ、その標準出力にパスワードを書き出す事になっています。

@item  core.attributesFile 
@samp{.gitattributes} (ディレクトリごと) と @samp{.git/info/attributes} に加えて、Gitはこのファイルで属性を調べます(gitattributes(5) を参照)。パスの拡張は、 @samp{core.excludesFile} の場合と同じ方法で行われます。デフォルト値は @samp{$XDG_CONFIG_HOME/git/attributes} です。 @samp{$XDG_CONFIG_HOME} が設定されていないか空の場合、代わりに @samp{$HOME/.config/git/attributes} が使用されます。

@item  core.hooksPath 
デフォルトでは、Gitは @samp{$GIT_DIR/hooks} ディレクトリでフックを探します。これを別のパスに設定します。例えば @samp{/etc/git/hooks} です。そしてGitはそのディレクトリであなたのフックを見つけようとします。例えば @samp{$GIT_DIR/hooks/pre-receive} の代わりに @samp{/etc/git/hooks/pre-receive} です。

パスは絶対パスでも相対パスでもかまいません。相対パスは、フックが実行されているディレクトリを基準にしたものと見なされます(githooks(5) の「DESCRIPTION」セクションを参照)。

この設定変数は、あなたのGitフックをリポジトリごとに設定するのではなく一元的に設定したい場合や、デフォルトのフックを変更した @samp{init.templateDir} に代わるより柔軟で一元的な設定として有用です。

@item  core.editor 
エディタを起動してメッセージを編集できる @samp{commit} や @samp{tag} などのコマンドは、この変数が設定されているときにこの変数の値を使用し、環境変数 @samp{GIT_EDITOR} は設定されていません。 git-var(1) を参照してください。

@item  core.commentChar 
メッセージを編集できる @samp{commit} や @samp{tag} などのコマンドは、この文字で始まるコメント行を考慮し、エディタから戻った後にそれらを削除します(デフォルトは @samp{#})。

@samp{auto} に設定すると、 @samp{git-commit} は、既存のコミットメッセージのどの行の先頭文字でもない文字を選択します。

@item  core.filesRefLockTimeout 
個々の参照をロックしようとしたときに再試行する時間の長さ(ミリ秒単位)。値0は、まったく再試行しないことを意味します。 -1 は無期限に試すことを意味します。 デフォルトは100です(つまり、100ミリ秒再試行します)。

@item  core.packedRefsTimeout 
@samp{packed-refs} ファイルをロックしようとしたときに再試行する時間の長さ(ミリ秒単位)。値0は、まったく再試行しないことを意味します。-1は無期限に試すことを意味します。デフォルトは1000です(つまり、1秒間再試行します)。

@item  core.pager 
Gitコマンドで使用するテキストビューア( @samp{less} など)。値はシェルによって解釈されることを意図しています。 優先順位は、 @samp{$GIT_PAGER} 環境変数、 @samp{core.pager} 構成、 @samp{$PAGER} 、そしてコンパイル時に選択されたデフォルト(通常は @samp{less})です。

@samp{LESS} 環境変数が設定されていない(unset)場合、Gitはそれを @samp{FRX} に設定(set)します(@samp{LESS} 環境変数が設定されている場合は、Gitはそれをまったく変更しません)。Gitのデフォルト設定である @samp{LESS} を選択的にオーバーライドする場合は、 @samp{core.pager} を、例えば @samp{less -S} と設定できます。これはGitによってシェルに渡され、Gitは最後のコマンドを @samp{LESS=FRX less -S} に変換します。環境変数では @samp{S} オプションを設定しませんが、コマンドラインでは設定し、長い行を切り捨てるように指示します。同様に、 @samp{core.pager} を @samp{less -+F} に設定すると、環境変数によって指定された @samp{F`オプションがコマンドラインによって非アクティブになり、 `less} の「1画面の場合は終了」動作が非アクティブになります。特定のGitコマンドに対していくつかのフラグを特に指定してアクティブにすることができます。たとえば、 @samp{pager.blame} を @samp{less -S} に設定すると、 @samp{git blame} でのみページャーで行の切り捨てが有効になります。

同様に、 @samp{LV} 環境変数が設定されていない場合、Gitはそれを @samp{-c} に設定します。この設定を上書きするには、 @samp{LV} を別の値でエクスポートするか、 @samp{core.pager} を @samp{lv +c} に設定します。

@item  core.whitespace 
注意すべき一般的な空白(whitespace)の問題のコンマ(@samp{,})区切りのリスト。 @samp{gitdiff} は @samp{color.diff.whitespace} を使用してそれらを強調表示し、 @samp{git apply --whitespace = error} はそれらをエラーと見なします。 接頭辞 @samp{-} を付けて、それらのいずれかを無効にすることができます(例: @samp{-trailing-space}):

@itemize 

@item
@samp{blank-at-eol} は、行末の末尾の空白をエラーとして扱います(デフォルトで有効になっています)。

@item
@samp{space-before-tab} は、行の最初のインデント部分のタブ文字の直前に表示されるスペース文字をエラーとして扱います(デフォルトで有効になっています)。

@item
@samp{indent-with-non-tab} は、同等のタブではなくスペース文字でインデントされた行をエラーとして扱います(デフォルトでは有効になっていません)。

@item
@samp{tab-in-indent} は、行の最初のインデント部分にあるタブ文字をエラーとして扱います(デフォルトでは有効になっていません)。

@item
@samp{blank-at-eof} は、ファイルの最後に追加された空白行をエラーとして扱います(デフォルトで有効になっています)。

@item
@samp{trailing-space} は、` blank-at-eol` と @samp{blank-at-eof} の両方をカバーする省略形です。

@item
@samp{cr-at-eol} は、行末のキャリッジリターンをラインターミネータの一部として扱います。つまり、そのようなキャリッジリターンの前の文字が空白(a whitespace)でない場合、 @samp{trailing-space} はトリガーされません(デフォルトでは有効になっていません)。

@item
@samp{tabwidth=<n>} は、タブが占める文字数を示します。 これは、 @samp{indent-with-non-tab} と、 Gitが @samp{tab-in-indent} エラーを修正する場合に関連します。デフォルトのタブ幅は8です。許可される値は1〜63です。
@end itemize

@item  core.fsync 
作成または変更時に core.fsyncMethod を介して強化する必要があるリポジトリのコンポーネントのコンマ区切りリスト。 コンポーネントの前に @samp{-} を付けることで、コンポーネントの堅牢化を無効にすることができます。 堅牢化されていないアイテムは、不正なシステム・シャットダウンが発生した場合に失われる可能性があります。 特別な要件がない限り、このオプションを空のままにするか、 @samp{committed} または @samp{added} または @samp{all} のいずれかを選択することをお勧めします。

この構成が検出されると、一連のコンポーネントがプラットフォームのデフォルト値で開始され、無効なコンポーネントが削除され、追加のコンポーネントが追加されます。 @samp{none} は、プラットフォームのデフォルトが無視されるように状態をリセットします。

空の文字列は、 fsync 構成をプラットフォームのデフォルトにリセットします。 ほとんどのプラットフォームのデフォルトは @samp{core.fsync=committed,-loose-object} と同等で、パフォーマンスは良好ですが、システムが正常にシャットダウンされなかった場合に最近の作業が失われるリスクがあります。

@itemize 

@item
@samp{none} は、fsync されたコンポーネントのセットをクリアします。

@item
@samp{loose-object} は、リポジトリに追加されたオブジェクトを緩いオブジェクト形式に堅牢化します。

@item
@samp{pack} は、リポジトリに追加されたオブジェクトをパックファイル形式に堅牢化します。

@item
@samp{pack-metadata} は、パックファイルのビットマップとインデックスに堅牢化します。

@item
@samp{commit-graph} hardens the commit-graph file.

@item
@samp{index} は、変更時にインデックスに堅牢化します。

@item
@samp{objects} は、 @samp{loose-object,pack} と同等の集約オプションです。

@item
reference` は、リポジトリで変更された参照に堅牢化します。

@item
@samp{derived-metadata} は、 @samp{pack-metadata,commit-graph} と同等の集約オプションです。

@item
@samp{committed} は、現在のところ @samp{objects} と同等の集約オプションです。 このモードでは、 @samp{git commit} または同様のコマンドでリポジトリにコミットされた作業が確実に堅牢化されるようにして、パフォーマンスがいくらか犠牲になります。

@item
@samp{added} は、現在のところ @samp{committed,index} と同等の集約オプションです。 このモードでは、 @samp{git add} などのコマンドや同様の操作の結果が確実に堅牢化されるようにして、パフォーマンスが犠牲が追加されます。

@item
@samp{all} は、上記のすべての個々のコンポーネントをsyncする集約オプションです。
@end itemize

@item  core.fsyncMethod 
fsync および関連するプリミティブを使用してリポジトリ・データを堅牢化するために Git が使用する戦略を示す値。

@itemize 

@item
@samp{fsync} は、 fsync() システム・コール、または、当該プラットフォームで fsync() システム・コールと同等のものを使用します。

@item
@samp{writeout-only} はページ・キャッシュの書き戻し(writeback)要求を発行しますが、ファイル・システムとストレージ・ハードウェアによっては、システム・クラッシュが発生した場合にリポジトリに追加されたデータが保持されない場合があります。 これは macOS のデフォルト・モードです。

@item
@samp{batch} は、書き込み専用(writeout-only)フラッシュを使用してディスク・ライトバック・キャッシュに複数の更新をステージングするモードを有効にし、その後、操作の最後にディスク・キャッシュ・フラッシュをトリガーするためにダミー・ファイル 1 つによっての完全な fsync を実行します。

現在、 @samp{batch} モードは緩いオブジェクト・ファイルにのみ適用されます。 他のリポジトリ・データは、 @samp{fsync} が指定されたかのように永続化されます。 このモードは、 macOS では HFS+ または APFS ファイルシステムに格納されたリポジトリに対して、 Windows では NTFS または ReFS ファイルシステムに格納されたリポジトリに対しては @samp{fsync} と同じくらい安全であると予想されます。
@end itemize

@item  core.fsyncObjectFiles 
このブール値は、オブジェクトファイルを書き込むときに @samp{fsync()} を有効にします。 この設定は非推奨です。 代わりに core.fsync を使用してください。

この設定は、 緩いオブジェクト形式で Git リポジトリに追加されたデータに影響します。 true に設定すると、Git は fsync または同様のシステム・コールを発行してキャッシュをフラッシュし、不正なシステム・シャットダウンに直面しても緩いオブジェクトの一貫性が維持されるようにします。

@item  core.preloadIndex 
@samp{git diff} などの操作のために並列インデックスプリロードを有効にする

これにより、特にキャッシュセマンティクスが弱く、IOレイテンシが比較的高いNFSなどのファイルシステムで、「git diff」や「git status」などの操作を高速化できます。有効にすると、Gitはファイルシステムデータとのインデックス比較を並行して実行し、重複する入出力を許可します。デフォルトはtrueです。

@item  core.unsetenvvars 
Windowsのみ: 他のプロセスを生成する前に設定を解除する必要がある環境変数の名前のコンマ(@samp{,})区切りのリスト。Git for Windowsが独自のPerlインタープリターの使用を主張しているという事実を説明するために、デフォルトは @samp{PERL5LIB} です。

@item  core.restrictinheritedhandles 
Windowsのみ: 生成されたプロセスが標準のファイルハンドル( @samp{stdin} と @samp{stdout} と @samp{stderr})のみを継承するか、すべてのハンドルを継承するかをオーバーライドします。 @samp{auto} または @samp{true} または @samp{false} にすることができます。デフォルトは @samp{auto} で、これはWindows7以降では @samp{true} を意味し、古いバージョンのWindowsでは @samp{false} を意味します。

@item  core.createObject 
これを @samp{link} に設定できます。この場合、ハードリンク後のソース削除を、オブジェクトの作成が既存のオブジェクトが上書しないことをチェックするために使用します。

一部のファイルシステム/オペレーティングシステムの組み合わせでは、これは信頼できませんので、この構成設定を @samp{rename} に設定します。ただし、これにより、既存のオブジェクトファイルが上書きされないようにするチェックが削除されます。

@item  core.notesRef 
コミットメッセージを表示するときは、指定されたrefに保存されている note も表示します。refは完全に修飾されている必要があります。指定されたrefが存在しない場合、それはエラーではありませんが、noteを印刷してはならないことを意味します。

この設定のデフォルトは「refs/notes/commits」であり、 @samp{GIT_NOTES_REF} 環境変数でオーバーライドできます。 git-notes(1) を参照してください。

@item  core.commitGraph 
trueの場合、gitはcommit-graphファイル(存在する場合)を読み取り、コミットのグラフ構造をパースします。デフォルトはtrueです。詳細については、 git-commit-graph(1) を参照してください。

@item  core.useReplaceRefs 
@samp{false} に設定すると、コマンドラインで @samp{--no-replace-objects} オプションが指定されたかのように振る舞います。詳細については git(1) と git-replace(1) を参照してください。

@item  core.multiPackIndex 
multi-pack-index ファイルを使用して、単一のインデックスを使用して複数のパックファイルを追跡します。詳細については git-multi-pack-index(1) を参照してください。デフォルトはtrueです。

@item  core.sparseCheckout 
「スパースチェックアウト」(sparse checkout)機能を有効にします。 詳細については、 git-sparse-checkout(1) を参照してください。

@item  core.sparseCheckoutCone 
スパースチェックアウト機能の「コーンモード」(cone mode)を有効にします。スパースチェックアウトファイルに含まれるパターンのセットが限られている場合、このモードはパフォーマンスに大きな利点をもたらします。 この変数を @samp{false} に設定することで、より柔軟なパターンを指定できるように「非コーンモード」(non-cone mode)を要求できます。 詳細については git-sparse-checkout(1) を参照してください。

@item  core.abbrev 
オブジェクト名の省略形の長さを設定します。指定されていないか「auto」に設定されている場合、リポジトリ内のパックされたオブジェクトのおおよその数に基づいて適切な値が計算されます。それは、省略されたオブジェクト名がしばらくの間(some time)一意であるのに十分な長さです。「no」に設定すると、省略形は作成されず、オブジェクト名は完全な長さで表示されます。 最小の長さは4です。

@item  add.ignoreErrors 
@itemx  add.ignore-errors (非推奨) 
インデックスエラーのために一部のファイルを追加できない場合にファイルの追加を続行するように @samp{git add} に指示します。 git-add(1) の @samp{--ignore-errors} オプションと同等です。 @samp{add.ignore-errors} は、構成変数の通常の命名規則に従わないため、非推奨になりました。

@item  add.interactive.useBuiltin 
Unused configuration variable. Used in Git versions v2.25.0 to v2.36.0 to enable the built-in version of git-add(1)'s interactive mode, which then became the default in Git versions v2.37.0 to v2.39.0.

@item  alias.* 
git(1) コマンドラッパーのコマンドエイリアス。例えば、 @samp{alias.last = cat-file commit HEAD} 定義後、 @samp{git last} の呼び出しは @samp{git cat-file commit HEAD} と同等です。スクリプトの使用に関する混乱や問題を回避するために、既存のGitコマンドを非表示にするエイリアスは無視されます。 引数はスペースで分割され、通常のシェルのクォートとエスケープがサポートされています。 引用符のペアまたはバックスラッシュ(@samp{\})を使用して、それらをクォートすることができます。

エイリアスの最初の単語は必ずしもコマンドである必要はないことに注意してください。 これは、@samp{git} の呼び出しに渡されるコマンドラインオプションにすることができます。 特に、これは、 @samp{-c} を使用して1回限りの構成で渡す場合、または @samp{-p} を使用して強制的にページネーションを行う場合に役立ちます。 たとえば、 @samp{loud-rebase = -c commit.verbose=true rebase} は、@samp{git loud-rebase} の実行が @samp{git -c commit.verbose=true rebase} と同等になるように定義できます。 また、 @samp{ps = -p status} は便利なエイリアスで、 @samp{git ps} は @samp{git status} の出力をページ分割して出力します。

エイリアス展開の前に感嘆符(@samp{!})が付いている場合は、シェルコマンドとして扱われます。 たとえば、 @samp{alias.new = !gitk --all --not ORIG_HEAD} を定義すると、 @samp{git new} の呼び出しは、シェルコマンド @samp{gitk --all --not ORIG_HEAD} を実行するのと同じです。 シェルコマンドは、リポジトリの最上位ディレクトリから実行されることに注意してください。これは、必ずしも現在のディレクトリであるとは限りません。 @samp{GIT_PREFIX} は、元のカレントディレクトリから @samp{git rev-parse --show-prefix} を実行したときに返される値が設定されます。 git-rev-parse(1) を参照してください。

@item  am.keepcr 
trueの場合、 @samp{git-am} は、パラメーター @samp{--keep-cr} を使用してmbox形式のパッチに対して` git-mailsplit` を呼び出します。 この場合、 @samp{git-mailsplit} は @samp{\r\n} で終わる行から @samp{\r} を削除しません。 コマンドラインから @samp{--no-keep-cr} を指定することでオーバーライドできます。 git-am(1) と git-mailsplit(1) を参照してください。

@item  am.threeWay 
デフォルトでは、パッチが正しく適用されない場合、 @samp{git am} は失敗します。 trueに設定すると、この設定は、パッチが適用される予定のブロブのIDを記録し、それらのブロブをローカルで使用できる場合に、3方向マージにフォールバックするように @samp{git am} に指示します(コマンドラインから @samp{--3way} オプションを指定するのと同じです)。 デフォルトは @samp{false} です。 git-am(1)を参照してください。

@item  apply.ignoreWhitespace 
@samp{change} に設定すると、 @samp{--ignore-space-change} オプションと同じように、空白の変更を無視するように @samp{git apply} に指示します。 @samp{no}, @samp{none}, @samp{never}, @samp{false} のいずれかに設定すると、すべての空白の違いを尊重するように @samp{git apply} に指示されます。 git-apply(1) を参照してください。

@item  apply.whitespace 
@samp{--whitespace} オプションと同じ方法で、 @samp{git apply} に空白の処理方法を指示します。 git-apply(1) を参照してください。

@item  blame.blankBoundary 
git-blame(1)で境界コミット(boundary commits)の空白コミットオブジェクト名を表示します。このオプションのデフォルトはfalseです。

@item  blame.coloring 
これにより、blame出力に適用される配色が決まります。 これは、 @samp{repeatedLines} または @samp{highlightRecent} またはデフォルトの @samp{none} にすることができます。

@item  blame.date 
git-blame(1) で日付を出力するために使用される形式を指定します。 設定を解除すると、iso形式が使用されます。 サポートされている値については、 git-log(1) の @samp{--date} オプションの説明を参照してください。

@item  blame.showEmail 
git-blame(1) で、作者名(author)の代わりに作者の電子メールアドレス(author email)を表示します。 このオプションのデフォルトはfalseです。

@item  blame.showRoot 
git-blame(1) ではルートコミットを境界として扱わないでください。 このオプションのデフォルトはfalseです。

@item  blame.ignoreRevsFile 
git-blame(1) で、ファイルにリストされているリビジョン(1行に1つの省略されていないオブジェクト名)を無視します。 @samp{#} で始まる空白とコメントは無視されます。 このオプションは複数回繰り返すことができます。 空のファイル名は、無視されたリビジョンのリストをリセットします。 このオプションは、コマンドラインオプション @samp{--ignore-revs-file} の前に処理されます。

@item  blame.markUnblamableLines 
git-blame(1)の出力で @samp{*} を使用して、別のコミットに帰することができなかった、無視されたリビジョンによって変更された行をマークします。

@item  blame.markIgnoredLines 
git-blame(1)の出力で、別のコミットに起因する無視されたリビジョンによって変更された行を @samp{?} でマークします。

@item  branch.autoSetupMerge 
git-pull(1) が開始点ブランチから適切にマージされるように、 @samp{git branch} や @samp{git switch} や @samp{git checkout} に新しいブランチを設定するように指示します。 このオプションが設定されていない場合でも、この動作は、 @samp{--track} や @samp{--no-track} オプションを使用してブランチごとに選択できることに注意してください。 有効な設定は次のとおりです: @samp{false} — 自動セットアップは行われません。 @samp{true} — 開始点がリモート追跡ブランチの場合、自動セットアップが実行されます。 @samp{always} — 自動セットアップは、開始点がローカルブランチまたはリモート追跡ブランチのいずれかである場合に実行されます。 このオプションのデフォルトはtrueです。 @samp{inherit} — 開始点に追跡構成(tracking configuration)がある場合、それは新しいブランチにコピーされます。 @samp{simple} — 自動セットアップは、開始点がリモート追跡ブランチであり、新しいブランチがリモート・ブランチと同じ名前を持つ場合にのみ実行されます。 このオプションのデフォルトは true です。

@item  branch.autoSetupRebase 
別のブランチを追跡する @samp{git branch} または @samp{git switch} または @samp{git checkout} を使用して新しいブランチが作成されると、この変数はGitにマージではなくリベースするプルを設定するように指示します(@samp{branch.<name>.rebase} 参照)。 @samp{never} の場合、リベースが自動的にtrueに設定されることはありません。 @samp{local} の場合、他のローカルブランチの追跡されたブランチに対してリベースがtrueに設定されます。 @samp{remote} の場合、リモート追跡ブランチの追跡されたブランチに対してリベースがtrueに設定されます。 @samp{always} の場合、リベースはすべての追跡ブランチに対してtrueに設定されます。 別のブランチを追跡するためにブランチを設定する方法の詳細については、 @samp{branch.autoSetupMerge} を参照してください。 このオプションのデフォルトは @samp{never} です。

@item  branch.sort 
この変数は、 git-branch(1) によって表示されるときのブランチの並べ替え順序を制御します。 @samp{--sort=<value>} オプションが指定されていない場合、この変数の値がデフォルトとして使用されます。 有効な値については、 git-for-each-ref(1) のfield namesを参照してください。

@item  branch.<name>.remote 
ブランチ<name>にいる場合、フェッチ元/プッシュ先 のremoteを @samp{git fetch} と @samp{git push} に通知します。 プッシュ先のremoteは、 (全ブランチ用の) @samp{remote.pushDefault} でオーバーライドできます。 現在のブランチの場合、プッシュ先のremoteは、 @samp{branch.<name>.pushRemote} によってさらにオーバーライドされる可能性があります。 remoteが構成されていない場合、または、どのブランチにも属しておらずリポジトリに複数のremoteが定義されている場合、フェッチの場合は @samp{origin} に、プッシュの場合は @samp{remote.pushDefault} にデフォルト設定されます。 さらに、 @samp{.} (ピリオド)は現在のローカルリポジトリ(ドットリポジトリ)です。下記 @samp{branch.<name>.merge} の最後の注意を参照してください。

@item  branch.<name>.pushRemote 
ブランチ<name>にいる場合、プッシュするための @samp{branch.<name>.remote} をオーバーライドします。 また、ブランチ<name>からプッシュするための @samp{remote.pushDefault} をオーバーライドします。 ある場所(あなたのアップストリームなど)から別の場所(独自の公開リポジトリなど)にプッシュする場合は、 @samp{remote.pushDefault} を設定して、すべてのブランチにプッシュするリモートを指定し、そして、このオプションを使用して 特定のブランチに対してオーバーライドします。

@item  branch.<name>.merge 
branch.<name>.remote とともに、指定されたブランチのアップストリームブランチを定義します。 マージするブランチを @samp{git fetch}/@samp{git pull}/@samp{git rebase} に通知し、 @samp{git push} にも影響を与える可能性があります(push.default参照)。 ブランチ<name>にいる場合、FETCH_HEADでマージするためにマークされるデフォルトのrefspecを @samp{git fetch} に指示します。 値はrefspecのリモート部分のように処理され、 @samp{branch.<name>.remote ` で指定されたリモートからフェッチされたrefと一致する必要があります。 マージ情報は、マージのためにデフォルトのブランチを検索するために `git pull} (最初に @samp{git fetch} を呼び出します)によって使用されます。 このオプションがない場合、 @samp{git pull} はデフォルトで、フェッチされた最初のrefspecをマージします。 octopusマージを取得するには、複数値を指定します。 あなたがローカルリポジトリ内の別のブランチから<name>にマージされるように @samp{git pull} を設定したい場合は、branch.<name>.mergeが目的をブランチを指すようにして、そして、 branch.<name>.remote に相対パス設定 @samp{.} (ピリオド)を使用できます。

@item  branch.<name>.mergeOptions 
ブランチ<name>にマージするためのデフォルトオプションを設定します。 構文とサポートされているオプションは git-merge(1) のものと同じですが、空白文字を含むオプション値は現在サポートされていません。

@item  branch.<name>.rebase 
trueの場合、 @samp{git pull} の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチ<name>をリベースします。 ブランチ固有ではない方法でこれを行うには、 @samp{pull.rebase} を参照してください。

@samp{merges} (または単に @samp{m}) の場合、 @samp{--rebase-merges} オプションを @samp{git rebase} に渡して、ローカル・マージ・コミットがリベースに含まれるようにします (詳細については git-rebase(1) を参照してください)。

値が @samp{interactive} (または単に @samp{i})の場合、リベースは対話モードで実行されます。

@strong{注意}: これはおそらく危険な操作です。
あなたが影響を理解していない限り、使用しないでください
(詳細については、 git-rebase(1) を参照してください)。

@item  branch.<name>.description 
ブランチの説明は、 @samp{git branch --edit-description} で編集できます。 ブランチの説明は、format-patchのカバーレターまたはrequest-pullの概要に自動的に追加されます。

@item  browser.<tool>.cmd 
指定したブラウザ(<tool>)を起動するコマンドを指定してください。 指定されたコマンドは、引数として渡されたURLを使用してシェルで評価されます。 (git-web--browse(1) を参照してください。)

@item  browser.<tool>.path 
HTMLヘルプ(git-help(1) の @samp{-w} オプション参照) または gitwebの作業リポジトリ(git-instaweb(1) 参照) をブラウズするために使用される可能性のある指定のツール(<tool>)のパス(path)をオーバーライドします。

@item  bundle.* 
The @samp{bundle.*} keys may appear in a bundle list file found via the @samp{git clone --bundle-uri} option. These keys currently have no effect if placed in a repository config file, though this will change in the future. See @uref{technical/bundle-uri.html,the bundle URI design document} for more details.

@item  bundle.version 
This integer value advertises the version of the bundle list format used by the bundle list. Currently, the only accepted value is @samp{1}.

@item  bundle.mode 
This string value should be either @samp{all} or @samp{any}. This value describes whether all of the advertised bundles are required to unbundle a complete understanding of the bundled information (@samp{all}) or if any one of the listed bundle URIs is sufficient (@samp{any}).

@item  bundle.heuristic 
If this string-valued key exists, then the bundle list is designed to work well with incremental @samp{git fetch} commands. The heuristic signals that there are additional keys available for each bundle that help determine which subset of bundles the client should download. The only value currently understood is @samp{creationToken}.

@item  bundle.<id>.* 
The @samp{bundle.<id>.*} keys are used to describe a single item in the bundle list, grouped under @samp{<id>} for identification purposes.

@item  bundle.<id>.uri 
This string value defines the URI by which Git can reach the contents of this @samp{<id>}. This URI may be a bundle file or another bundle list.

@item  checkout.defaultRemote 
@samp{git checkout <something>} または @samp{git switch <something>} を実行し、リモートが1つしかない場合、 @samp{origin/<something>} のチェックアウトと追跡に暗黙的にフォールバックする可能性があります。 @samp{<something>} 参照を持つリモートが複数あるとすぐに動作しなくなります。 この設定により、曖昧性解消に関して常に勝利させる優先リモートの名前を設定できます。 典型的なユースケースは、これを @samp{origin} に設定することです。

現在、これは git-switch(1) と git-checkout(1) によって、@samp{git checkout <something>} や @samp{git switch <something>} が別のリモート上の @samp{<something>} ブランチをチェックアウトするときに使われています。また git-worktree(1) は @samp{git worktree add} がリモートブランチを参照しているときに使われています。 この設定は、将来、他のチェックアウトのようなコマンドまたは機能に使用される可能性があります。

@item  checkout.guess 
@samp{git checkout} と @samp{git switch} の、 @samp{--guess} または @samp{--no-guess} オプションのデフォルト値を提供します。 git-switch(1) および git-checkout(1) を参照してください。

@item  checkout.workers 
作業ツリーを更新するときに使用する並列ワーカーの数。デフォルトは1、つまり順次実行です。 1未満の値に設定すると、Gitは使用可能な論理コアの数と同じ数のワーカーを使用します。 この設定と @samp{checkout.thresholdForParallelism} は、チェックアウトを実行するすべてのコマンドに影響します。 例えば、 checkout, clone, reset, sparse-checkout, などです。

注意: 並列チェックアウトは通常、SSDまたはNFS上にあるリポジトリのパフォーマンスを向上させます。 回転するディスクやコアの数が少ないマシン上のリポジトリの場合、デフォルトのシーケンシャルチェックアウトの方がパフォーマンスが向上することがよくあります。 リポジトリのサイズと圧縮レベルも、並列バージョンのパフォーマンスに影響を与える可能性があります。

@item  checkout.thresholdForParallelism 
少数のファイルで並列チェックアウトを実行する場合、サブプロセスの生成とプロセス間通信のコストが並列化のメリットを上回る可能性があります。 この設定により、並列チェックアウトを試行する必要のあるファイルの最小数を定義できます。 デフォルトは100です。

@item  clean.requireForce 
@samp{-f} または @samp{-i} または @samp{-n} が指定されない限り、git-clean が何もしないようにするためのブール値です。
デフォルトは true です。

@item  clone.defaultRemoteName 
リポジトリのクローンを作成するときに作成するリモートの名前。 デフォルトは @samp{origin} で、 @samp{--origin} コマンドラインオプションを git-clone(1) に渡すことでオーバーライドできます。

@item  clone.rejectShallow 
リポジトリが浅い(shallow)場合は、リポジトリの複製(clone)を拒否します。コマンドラインでオプション @samp{--reject-shallow} を渡すことでオーバーライドできます。 git-clone(1) を参照してください

@item  clone.filterSubmodules 
部分(partial)クローン・フィルタが提供され(git-rev-list(1) の @samp{--filter} を参照)、かつ、 @samp{--recurse-submodules} が使用されている場合は、フィルタをサブモジュールにも適用します。

@item  color.advice 
ヒントの色を有効/無効にするブール値(たとえば、プッシュが失敗した場合のリストについては @samp{advice.*} を参照します)。 @samp{always} または @samp{false}(または @samp{never}) または @samp{auto}(または @samp{true}) に設定でき、その場合、色は、エラー出力が端末に送信される場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto} )。

@item  color.advice.hint 
ヒントにはカスタマイズされた色を使用します。

@item  color.blame.highlightRecent 
行の年齢に応じて、 @samp{git blame --color-by-age} の行注釈の色を指定します。

この設定は、色と日付設定のコンマ区切りリストに設定する必要があります。色で開始および終了し、日付は古いものから新しいものへと設定する必要があります。 行が指定されたタイムスタンプの前に導入された場合、メタデータは指定の色で色付けされ、古いタイムスタンプの色を上書きします。

絶対タイムスタンプの代わりに、相対タイムスタンプも機能します。例えば、@samp{2.weeks.ago} は、2週間より古いものに対処するために有効です。

デフォルトは @samp{blue,12 month ago,white,1 month ago,red} で、1年以上前のすべてを青に色付けし、1か月前から1年前までの変更は白のままにし、先月に導入された行赤に色付けします。

@item  color.blame.repeatedLines 
前の行と同じコミットからのものである場合、指定の色を使用して @samp{git Blame --color-lines} の行注釈を色付けします。 デフォルトはシアン(cyan)色です。

@item  color.branch 
git-branch(1) の出力で色を有効/無効にするブール値。 @samp{always} または @samp{false}(または @samp{never}) または @samp{auto}(または @samp{true})に設定でき、その場合、色は出力が端末への場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.branch.<slot> 
ブランチの色付けにスタマイズ色を使用します。 @samp{<slot>} は、 @samp{current}(現在のブランチ)、 @samp{local}(ローカルブランチ)、 @samp{remote}(@samp{refs/remotes/} 内のリモート追跡ブランチ)、 @samp{upstream}(アップストリーム追跡ブランチ）、 @samp{plain}(その他のref)、のいずれかです。

@item  color.diff 
ANSIエスケープシーケンスを使用してパッチに色を追加するかどうか。 これが @samp{always} に設定されている場合、 git-diff(1) と git-log(1) と git-show(1) はすべてのパッチに色を使用します。 @samp{true} または @samp{auto} に設定されている場合、これらのコマンドは、端末への出力時にのみ色を使用します。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

これは、 git-format-patch(1) または @samp{git-diff-@{asterisk@}} 配管コマンドには影響しません。 @samp{--color[=<when>]} オプションを使用してコマンドラインでオーバーライドできます。

@item  color.diff.<slot> 
diffカラー化にカスタマイズ色を使用します。 @samp{<slot>} は、パッチのどの部分で指定された色を使用するかを指定します。 次のいずれか一つです: @samp{context}(コンテキストテキスト。 @samp{plain} は歴史的な同義語です)、 @samp{meta}(メタ情報)、 @samp{frag}(ハンクヘッダー)、 @samp{func}(ハンクヘッダーの関数)、 @samp{old}(削除された行)、 @samp{new}(追加された行)、 @samp{commit}(コミットヘッダー)、 @samp{whitespace}(空白エラーを強調表示)、 @samp{oldMoved}(削除された複数行)、 @samp{newMoved}(追加された複数行)、 @samp{oldMovedDimmed} 、 @samp{oldMovedAlternative} 、 @samp{oldMovedAlternativeDimmed} 、 @samp{newMovedDimmed} 、 @samp{newMovedAlternative} 、 @samp{newMovedAlternativeDimmed}(詳細については、 git-diff(1) の @samp{--color-moved} の @samp{<mode>} 設定参照)、 @samp{contextDimmed} 、 @samp{oldDimmed} 、 @samp{newDimmed} 、@samp{contextBold} 、 @samp{oldBold} 、 @samp{newBold}(詳細については git-range-diff(1) 参照)。

@item  color.decorate.<slot> 
@samp{git log --decorate} 出力にカスタマイズ色を使用します。 @samp{<slot>} にはそれぞれ、ローカルブランチ、リモート追跡ブランチ、タグ、stash、HEADと、graftedコミットをあらわす、 @samp{branch} 、@samp{remoteBranch} 、@samp{tag} 、 @samp{stash} 、 @samp{HEAD} 、 @samp{grafted} のうちの一つを指定します。

@item  color.grep 
@samp{always} に設定すると、常に一致を強調表示します。 @samp{false}(または @samp{never})の場合、決して一致を強調表示しません。 @samp{true} または @samp{auto} に設定すると、出力が端末に書き込まれる場合にのみ色を使用します。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.grep.<slot> 
grepの色付けにカスタマイズ色を使用します。 @samp{<slot>} は、指定の色を使用する行の部分を指定します。

@table @asis

@item  @samp{context} 
コンテキスト行の非一致テキスト(@samp{-A} または @samp{-B} または @samp{-C} 使用時)

@item  @samp{filename} 
ファイル名接頭辞(@samp{-h} 使用時以外)

@item  @samp{function} 
関数名行(@samp{-p} 使用時)

@item  @samp{lineNumber} 
行番号接頭辞(@samp{-n} 使用時)

@item  @samp{column} 
桁番号接頭辞(@samp{--column} 使用時)

@item  @samp{match} 
一致テキスト(@samp{matchContext} と @samp{matchSelected} の設定と同じ)

@item  @samp{matchContext} 
内容行の一致テキスト

@item  @samp{matchSelected} 
選択した行でテキストのマッチングを行います。 また、次の git-log(1) サブコマンドをカスタマイズするために使用されます: @samp{--grep} と @samp{--author} と @samp{--committer}

@item  @samp{selected} 
選択した行でテキストとマッチングしません。 また、次の git-log(1) サブコマンドをカスタマイズするために使用されます: @samp{--grep} と @samp{--author} と @samp{--committer}

@item  @samp{separator} 
行内のフィールド間セパレータ(@samp{:} と @samp{-} と @samp{=})と、ハンク間セパレータ(@samp{--})
@end table

@item  color.interactive 
@samp{always} に設定すると、対話プロンプトと表示には常に色を使用します(@samp{git-add --interactive} や @samp{git-clean --interactive`で使用されるものなど)。 false(または `never})の場合、決して色を使用しません。 @samp{true} または @samp{auto} に設定すると、出力が端末に向けられている場合にのみ色を使用します。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.interactive.<slot> 
@samp{git add --interactive} および @samp{git clean --interactive} 出力にカスタマイズ色を使用します。 @samp{<slot>`は、対話コマンドからの通常の出力の4つの異なるタイプに対して、 `prompt} または @samp{header} または @samp{help} または @samp{error} の場合があります。

@item  color.pager 
@samp{auto} カラーモードがページャーに送られる出力を色付けするかどうかを指定するブール値。 デフォルトはtrueです。 ページャーがANSIカラーコードを理解しない場合は、これをfalseに設定します。

@item  color.push 
プッシュエラーで色を有効/無効にするブール値。 @samp{always} 、 @samp{false}(または @samp{never})または @samp{auto}(または @samp{true})に設定でき、その場合、色はエラー出力が端末に送られる場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.push.error 
プッシュエラーのカスタマイズされた色に使用。

@item  color.remote 
設定されている場合、行の先頭にあるキーワードが強調表示されます。 キーワードは @samp{error} と @samp{warning} と @samp{hint} と @samp{success} であり、大文字と小文字を区別せずに照合されます。 @samp{always} または @samp{false}(または @samp{never})または @samp{auto}(または @samp{true})に設定できます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.remote.<slot> 
リモートキーワードごとにカスタマイズ色を使用します。 @samp{<slot>} は、対応するキーワードに一致する @samp{hint} または @samp{warning} または @samp{success} または @samp{error} の場合があります。

@item  color.showBranch 
linkgit：git-show-branch[1]の出力で色を有効/無効にするブール値。 @samp{always} 、@samp{false}(または @samp{never})または @samp{auto} (または @samp{true}) に設定でき、その場合、色は出力が端末への場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.status 
git-status(1) の出力で色を有効/無効にするブール値。 @samp{always} 、 @samp{false}(または @samp{never})または @samp{auto}(または @samp{true})に設定でき、その場合、色は出力が端末への場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.status.<slot> 
ステータスの色付けにカスタマイズ色を使用します。 @samp{<slot>} は次から一つを選択します。 @samp{header}(ステータスメッセージのヘッダーテキスト)、 @samp{added} または @samp{updated}((追加されたがコミットされていないファイル)、 @samp{changed}(変更されたがインデックスに追加されていないファイル)、 @samp{untracked}(Git によって追跡されていないファイル)、 @samp{branch}(現在のブランチ)、 @samp{nobranch}(「no branch」警告を表示する色。デフォルトは赤)、 @samp{localBranch} または @samp{remoteBranch}(ブランチと追跡情報をステータス表示する際の、ローカルブランチとリモートブランチの名前) または @samp{unmerged} (変更がマージされていないファイル)

@item  color.transport 
プッシュが拒否されたときに色を有効/無効にするブール値。 @samp{always} 、 @samp{false}(または @samp{never})または @samp{auto}(または @samp{true})に設定でき、その場合、色はエラー出力が端末に送られる場合にのみ使用されます。 設定されていない場合は、 @samp{color.ui} の値が使用されます(デフォルトでは @samp{auto})。

@item  color.transport.rejected 
プッシュが拒否された時に使うカスタマイズ色。

@item  color.ui 
この変数は、コマンドファミリごとの色の使用を制御する @samp{color.diff} や @samp{color.grep} などの変数のデフォルト値を決定します。 より多くのコマンドが @samp{--color} オプションのデフォルトを設定するための構成を習得するにつれて、その範囲は拡大します。 他の構成または @samp{--color} オプションで明示的に有効にしない限り、Gitコマンドで色を使用しないようにする場合は、@samp{false} または @samp{never} に設定します。 機械での利用を目的としない、すべての出力でカラーを使用する場合は @samp{always} に設定し、端末への書き込み時にそのような出力でカラーを使用する場合は @samp{true} または @samp{auto} (これはGit 1.8.4以降のデフォルトです)に設定します。

@item  column.ui 
サポートされているコマンドを列(column)で出力するかどうかを指定します。 この変数は、スペースまたはコンマで区切られたトークンのリストで構成されます:

以下のオプションは、機能を有効にするタイミングを制御します(デフォルトは @samp{never}):

@table @asis

@item  @samp{always} 
常に列表示

@item  @samp{never} 
決して列表示しない

@item  @samp{auto} 
端末へ出力の場合は列表示
@end table

以下のオプションはレイアウトを制御します(デフォルトは @samp{column})。 @samp{always} や @samp{never} や @samp{auto} のいずれも指定されていない場合に、以下のいずれかを設定すると、 @samp{always} の指定を含みます。

@table @asis

@item  @samp{column} 
行の前に列を埋める

@item  @samp{row} 
列の前に行を埋める

@item  @samp{plain} 
1つの列に表示
@end table

最後に、以下のオプションはレイアウトオプションと組み合わせることができます(デフォルトは @samp{nodense}):

@table @asis

@item  @samp{dense} 
より多くのスペースを利用するために不等サイズの列を作成する

@item  @samp{nodense} 
同じサイズの列を作成する
@end table

@item  column.branch 
@samp{git branch} でブランチリストを列出力するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。

@item  column.clean 
@samp{git clean -i} でアイテムを一覧表示するときのレイアウトを指定します。これにより、常にファイルとディレクトリが列表示されます。 詳細については、 @samp{column.ui} を参照してください。

@item  column.status 
@samp{git status} で追跡されていないファイルを列表示するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。

@item  column.tag 
@samp{git tag} でタグリストを列出力するかどうかを指定します。 詳細については、 @samp{column.ui} を参照してください。

@item  commit.cleanup 
この設定は、 @samp{git commit} の @samp{--cleanup} オプションのデフォルトを上書きします。 詳細については、 git-commit(1) を参照してください。 デフォルトを変更すると、コメント文字 @samp{#} で始まる行をログメッセージに常に残しておきたい場合に役立ちます。その場合は、 @samp{git config commit.cleanup whitespace} を実行します(注意:これを行う場合は、コミットログテンプレートの @samp{#} で始まるヘルプ行を自分で削除する必要があることに注意してください)。

@item  commit.gpgSign 
すべてのコミットをGPG署名する必要があるかどうかを指定するブール値。 リベースなどの操作を行うときにこのオプションを使用すると、多数のコミットが署名される可能性があります。 エージェントを使用して、GPGパスフレーズの入力を省略するようにすると便利な場合があります。

@item  commit.status 
エディタを使用してコミットメッセージを準備するときに、コミットメッセージテンプレートにステータス情報を含めることを有効/無効にするブール値。 デフォルトはtrueです。

@item  commit.template 
新しいコミットメッセージのテンプレートとして使用するファイルのパス名を指定します。

@item  commit.verbose 
@samp{git commit} でverboseレベルを指定するブール値またはint。 git-commit(1) を参照してください。

@item  commitGraph.generationVersion 
commit-graph ファイルの書き込みまたは読み取り時に使用する世代番号バージョン(generation number version)のタイプを指定します。 バージョン 1 が指定されている場合、修正されたコミット日付は書き込まれたり読み取られたりしません。 デフォルトは 2 です。

@item  commitGraph.maxNewFilters 
@samp{git commit-graph write} の @samp{--max-new-filters} オプションのデフォルト値を指定します(git-commit-graph(1) 参照)。

@item  commitGraph.readChangedPaths 
trueの場合、gitはcommit-graphファイルで変更パスブルームフィルター(the changed-path Bloom filters)を使用します(存在し、有効な場合)。 デフォルトはtrueです。 詳細については、 git-commit-graph(1) を参照してください。

@item  credential.helper 
ユーザー名またはパスワードの資格情報が必要なときに呼び出される外部ヘルパーを指定します。ヘルパーは、ユーザーに資格情報の入力を求めないように、外部ストレージを参照する場合があります。これは通常、可能な引数を持つ資格情報ヘルパーの名前ですが、引数を持つ絶対パス、または @samp{!} が前に付いている場合はシェルコマンドの場合もあります。

注意: 複数のヘルパーが定義されている場合があることに注意してください。詳細と例については、 gitcredentials(7) を参照してください。

@item  credential.useHttpPath 
資格情報を取得するとき、http URL または https URL のパス部分を重要視します。デフォルトはfalseです。詳細については、 gitcredentials(7) を参照してください。

@item  credential.username 
ネットワーク認証にユーザー名が設定されていない場合は、デフォルトでこのユーザー名を使用します。 以下の credential.<context>.* と gitcredentials(7) を参照してください。

@item  credential.<url>.* 
上記の credential.* オプションは、一部の資格情報に選択的に適用できます。 たとえば、 "credential.https://example.com.username" は、example.com への https 接続に対してのみデフォルトのユーザー名を設定します。 URLの照合方法の詳細については、 gitcredentials(7) を参照してください。

@item  credentialCache.ignoreSIGHUP 
git-credential-cache—daemon に、終了する代わりにSIGHUPを無視するように指示します。

@item  credentialStore.lockTimeoutMS 
資格情報ファイルをロックしようとしたときに git-credential-store が再試行する時間の長さ(ミリ秒単位)。値0は、まったく再試行しないことを意味します。-1は無期限に試すことを意味します。デフォルトは1000です(つまり、1秒間再試行します)。

@item  completion.commands 
これは、補完コマンドのリストからコマンドを追加または削除するためにgit-completion.bashによってのみ使用されます。通常、磁器コマンドと、いくつかの選択されたコマンドのみが補完します。この変数には、スペースで区切ってコマンドを追加できます。 コマンドの前に @samp{-} を付けると、既存のリストから削除されます。

@item  diff.autoRefreshIndex 
@emph{git diff} を使用して作業ツリーファイルと比較する場合、統計のみの変更を変更されたものと見なさない。代わりに、サイレントに @samp{git update-index --refresh} を実行して、ワークツリーの内容がインデックスの内容と一致するパスの、キャッシュされた統計情報を更新します。このオプションのデフォルトはtrueです。注意: これは @samp{git diff} 磁器コマンドにのみ影響し、 @samp{git diff-files} などの下位レベルのdiffコマンドには影響しないことに注意してください。

@item  diff.dirstat 
git-diff(1) およびその仲間に対する @samp{--dirstat} オプションのデフォルトの動作を指定する @samp{--dirstat} パラメーターのコンマ区切りリスト。デフォルトは(@samp{--dirstat=<param1,param2,...>} を使用して)コマンドラインでオーバーライドできます。フォールバックのデフォルトは @samp{changes,noncumulative,3} です(@samp{diff.dirstat} によって変更されていない限り)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加 された行数を合計して、dirstat数を計算します。(バイナリファイルの場合、バイナリファイルには行の自然な概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりもコストのかかる @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。 結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最も安価な @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更もカウントします。 @samp{cumulative} を使用する場合、報告されるパーセンテージの合計が100％を超える場合があることに注意してください。 デフォルトの(非累積的な)動作は、 @samp{non-cumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。変更への貢献がこの割合より少ないディレクトリは出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウントする: @samp{files,10,cumulative}

@item  diff.statGraphWidth 
@samp{--stat} 出力でグラフ部分の幅を制限します。設定されている場合、format-patchを除く @samp{--stat} 出力を生成するすべてのコマンドに適用されます。

@item  diff.context 
デフォルトの3ではなく<n>行のコンテキストで差分を生成します。この値は @samp{-U} オプションによってオーバーライドされます。

@item  diff.interHunkContext 
指定された行数までのdiffハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。この値は、 @samp{--inter-hunk-context} コマンドラインオプションのデフォルトとして機能します。

@item  diff.external 
この構成変数が設定されている場合、diffの生成は、内部のdiff機構を使用して実行されるのではなく、指定されたコマンドを使用して実行されます。 ‘GIT_EXTERNAL_DIFF’ 環境変数でオーバーライドできます。このコマンドは、 git(1) の「git Diffs」で説明されているパラメーターを使用して呼び出されます。 注意: ファイルのサブセットでのみ外部diffプログラムを使用する場合は、代わりに gitattributes(5) を使用することをお勧めします。

@item  diff.ignoreSubmodules 
@samp{--ignore-submodules} のデフォルト値を設定します。これは @samp{git diff} 磁器コマンドにのみ影響し、 @samp{git diff-files} などの下位レベルのdiffコマンドには影響しないことに注意してください。 @samp{git checkout} や @samp{git switch} も、コミットされていない変更を報告するときにこの設定を尊重します。 @emph{all} に設定すると、 @samp{--ignore-submodules} コマンドラインオプションを使用してオーバーライドされない限り、 @samp{status.submoduleSummary} が設定されている場合、通常は @emph{git commit} および @emph{git status} で表示されるサブモジュールの概要が無効になります。 @emph{git submodule} コマンドは、この設定の影響を受けません。デフォルトでは、これは untracked に設定されているため、追跡されていないサブモジュールはすべて無視されます。

@item  diff.mnemonicPrefix 
設定されている場合、 @samp{git diff} は、比較対象に応じて標準の @emph{a/} や @emph{b/} とは異なるプレフィックスのペアを使用します。この構成が有効な場合、逆差分出力でもプレフィックスの順序が入れ替わります:

@table @asis

@item  @samp{git diff} 
(i)ndex と (w)ork tree を比較

@item  @samp{git diff HEAD} 
(c)ommit と (w)ork tree を比較

@item  @samp{git diff --cached} 
(c)ommit と (i)ndex を比較

@item  @samp{git diff HEAD:file1 file2} 
(o)bject と (w)ork tree エンティティを比較

@item  @samp{git diff --no-index a b} 
2つの非git項目 (1) と (2) を比較
@end table

@item  diff.noprefix 
設定されている場合、 @samp{git diff} は送信元または宛先のプレフィックスを表示しません。

@item  diff.relative 
@emph{true} に設定すると、 @emph{git diff} はディレクトリ外の変更を表示せず、現在のディレクトリへの相対的なパス名を表示します。

@item  diff.orderFile 
diff内でファイルを並べ替える方法を示すファイル。 詳細については、 git-diff(1) の @samp{-O} オプションを参照してください。 @samp{diff.orderFile} が相対パス名の場合、作業ツリーの最上位を基準として扱います。

@item  diff.renameLimit 
コピー/名前変更 の検出の徹底的な部分で考慮するファイルの数。 @emph{git diff} の @samp{-l} オプションと同等です。設定されていない場合、デフォルト値は現在1000です。この設定は、名前変更の検出がオフになっている場合は効果がありません。

@item  diff.renames 
Gitが名前の変更を検出するかどうかとその方法。 "false" に設定すると、名前変更の検出が無効になります。 "true" に設定すると、基本的な名前変更の検出が有効になります。 "copies" または "copy" に設定されている場合、Gitはコピーも検出します。デフォルトはtrueです。これは git-diff(1) や git-log(1) のような @emph{git diff} 磁器コマンドにのみ影響し、 git-diff-files(1) などの下位レベルのコマンドには影響しないことに注意してください。

@item  diff.suppressBlankEmpty 
空の出力行の前にスペースを印刷する標準的な動作を禁止するブール値。デフォルトはfalseです。

@item  diff.submodule 
サブモジュールの違いを表示する形式を指定します。 "short" 形式は、範囲の最初と最後にコミットの名前を表示するだけです。 "log" 形式は、 git-submodule(1) の @samp{summary} のように範囲内のコミットをリストします。 "diff" 形式は、サブモジュールの変更された内容のインラインdiffを示します。デフォルトは "short" です。

@item  diff.wordRegex 
単語ごとの差の計算を実行するときに「単語」(word)とは何かを判別するために使用されるPOSIX拡張正規表現。正規表現に一致する文字シーケンスは「単語」(words)であり、他のすべての文字は*無視できる*空白(whitespace)です。

@item  diff.<driver>.command 
カスタムdiffドライバーコマンド。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.xfuncname 
diffドライバーがハンクヘッダーを認識するために使用する必要がある正規表現。内蔵パターンを使用することもできます。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.binary 
このオプションをtrueに設定すると、diffドライバーがファイルをバイナリとして処理します。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.textconv 
ファイルのテキスト変換バージョンを生成するためにdiffドライバーが呼び出す必要のあるコマンド。変換の結果は、人間が読める形式のdiffを生成するために使用されます。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.wordRegex 
diffドライバーが単語(words)を1行に分割するために使用する必要がある正規表現。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.cachetextconv 
このオプションをtrueに設定すると、diffドライバーがテキスト変換出力をキャッシュするようになります。詳細については gitattributes(5) を参照してください。

@table @asis

@item  @samp{araxis} 
Use Araxis Merge (requires a graphical session)

@item  @samp{bc} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc3} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc4} 
Use Beyond Compare (requires a graphical session)

@item  @samp{codecompare} 
Use Code Compare (requires a graphical session)

@item  @samp{deltawalker} 
Use DeltaWalker (requires a graphical session)

@item  @samp{diffmerge} 
Use DiffMerge (requires a graphical session)

@item  @samp{diffuse} 
Use Diffuse (requires a graphical session)

@item  @samp{ecmerge} 
Use ECMerge (requires a graphical session)

@item  @samp{emerge} 
Use Emacs' Emerge

@item  @samp{examdiff} 
Use ExamDiff Pro (requires a graphical session)

@item  @samp{guiffy} 
Use Guiffy’s Diff Tool (requires a graphical session)

@item  @samp{gvimdiff} 
Use gVim (requires a graphical session)

@item  @samp{kdiff3} 
Use KDiff3 (requires a graphical session)

@item  @samp{kompare} 
Use Kompare (requires a graphical session)

@item  @samp{meld} 
Use Meld (requires a graphical session)

@item  @samp{nvimdiff} 
Use Neovim

@item  @samp{opendiff} 
Use FileMerge (requires a graphical session)

@item  @samp{p4merge} 
Use HelixCore P4Merge (requires a graphical session)

@item  @samp{smerge} 
Use Sublime Merge (requires a graphical session)

@item  @samp{tkdiff} 
Use TkDiff (requires a graphical session)

@item  @samp{vimdiff} 
Use Vim

@item  @samp{winmerge} 
Use WinMerge (requires a graphical session)

@item  @samp{xxdiff} 
Use xxdiff (requires a graphical session)
@end table

@item  diff.indentHeuristic 
このオプションを @samp{false} に設定すると、パッチを読みやすくするためにdiffハンク境界をシフトするデフォルトのヒューリスティックが無効になります。

@item  diff.algorithm 
diffアルゴリズムを選択します。 派生形は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして。可能な限り最小の差分が生成されるようにします。

@item  @samp{patience} 
パッチを生成するときは、patience diff(忍耐差分)アルゴリズムを使用してください。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズムを拡張して、「発生頻度の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

@item  diff.wsErrorHighlight 
差分の @samp{context} または @samp{old または `new} 行の空白エラー(whitespace errors)を強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は @samp{old,new,context} の省略形です。空白のエラー(whitespace errors)は @samp{color.diff.whitespace} で色分けされています。コマンドラインオプション @samp{--ws-error-highlight=<kind>} はこの設定を上書きします。

@item  diff.colorMoved 
有効な @samp{<mode>} またはtrueのいずれかに設定すると、diff内の移動された行が異なる色で表示されます。有効なモードの詳細については、 git-diff(1) の @samp{--color-moved} を参照してください。単にtrueに設定すると、デフォルトのカラーモードが使用されます。 falseに設定すると、移動した行は色付けされません。

@item  diff.colorMovedWS 
このオプションは、例えば @samp{diff.colorMoved} 設定を使用して移動した行に色を付ける場合、スペース(spaces)をどのように扱うかを @samp{<mode>} で制御します。有効なモードの詳細については git-diff(1) の @samp{--color-moved-ws} を参照してください。

@item  diff.tool 
git-difftool(1) で使用する diff ツールを制御します。 この変数は、 @samp{merge.tool} で構成された値をオーバーライドします。 以下のリストは、有効な組み込み値を示しています。 その他の値はカスタム diff ツール(tool)として扱われ、対応する difftool.<tool>.cmd 変数を定義する必要があります。

@item  diff.guitool 
@samp{-g}/@samp{--gui} フラグが指定されている場合に、 git-difftool(1) によって使用されるdiffツールを制御します。 この変数は、 @samp{merge.guitool} で構成された値をオーバーライドします。 以下のリストは、有効な組み込み値を示しています。 その他の値はカスタム diff ツール(tool)として扱われ、対応する difftool.<guitool>.cmd 変数を定義する必要があります。

@item  difftool.<tool>.cmd 
指定のdiffツール(<tool>)を呼び出すコマンドを指定します。指定されたコマンドは、次の変数を使用してシェルで評価されます: @samp{LOCAL} は、diff pre-imageの内容を含む一時ファイルの名前に設定され、 @samp{REMOTE} は、diff post-imageの内容を含む一時ファイルの名前に設定されます。

詳細については、 git-difftool(1) の @samp{--tool=<tool>} オプションを参照してください。

@item  difftool.<tool>.path 
指定のツール(<tool>)のパスを上書きします。これは、あなたのツールがPATHにない場合に役立ちます。

@item  difftool.trustExitCode 
呼び出された difftool がゼロ以外の終了ステータス(exit status)を返す場合は、difftool を終了(exit)します。

詳細については、 git-difftool(1) の @samp{--trust-exit-code} オプションを参照してください。

@item  difftool.prompt 
diffツールを呼び出す前にプロンプトを表示します。

@item  difftool.guiDefault 
Set @samp{true} to use the @samp{diff.guitool} by default (equivalent to specifying the @samp{--gui} argument), or @samp{auto} to select @samp{diff.guitool} or @samp{diff.tool} depending on the presence of a @samp{DISPLAY} environment variable value. The default is @samp{false}, where the @samp{--gui} argument must be provided explicitly for the @samp{diff.guitool} to be used.

@item  extensions.objectFormat 
使用するハッシュアルゴリズムを指定します。 許容値は @samp{sha1} と @samp{sha256} です。 指定しない場合、 @samp{sha1} が想定されます。 @samp{core.repositoryFormatVersion} が1でない限り、このキーを指定するとエラーになります。

注意: この設定は、git-init(1) または git-clone(1) によってのみ設定する必要があることに注意してください。 初期化後に変更しようとすると機能せず、診断が難しい問題が発生します。

@item  extensions.worktreeConfig 
有効にすると、ワークツリーは、 @samp{$GIT_COMMON_DIR/config} ファイルに加えて、 @samp{$GIT_DIR/config.worktree} ファイルから構成設定を読み込みます。 @samp{$GIT_COMMON_DIR} と @samp{$GIT_DIR} はメインの作業ツリーと同じですが、他の作業ツリーの @samp{$GIT_DIR} は @samp{$GIT_COMMON_DIR/worktrees/<id>/} に等しいことに注意してください。 @samp{config.worktree} ファイルの設定は、他の構成ファイルの設定を上書きします。

@samp{extensions.worktreeConfig} を有効にするときは、特定の値達を共通構成ファイル(common config file)からメインの作業ツリーの @samp{config.worktree} ファイル (存在する場合) に移動(move)するように注意する必要があります:

@itemize 

@item
@samp{core.worktree} を @samp{$GIT_COMMON_DIR/config} から @samp{$GIT_COMMON_DIR/config.worktree} に移動(move)しなければなりません。

@item
@samp{core.bare} が true の場合、 @samp{$GIT_COMMON_DIR/config} から @samp{$GIT_COMMON_DIR/config.worktree} に移動(move)しなければなりません。

各ワークツリーのカスタマイズ可能な sparse-checkout 設定に対する要望に応じて、 @samp{core.sparseCheckout} と @samp{core.sparseCheckoutCone} の場所(locations)を調整することも有益な場合があります。 デフォルトでは、@samp{git sparse-checkout} ビルトインは @samp{extensions.worktreeConfig} を有効にし、これらの構成値をワークツリーごとに割り当て、 @samp{$GIT_DIR/info/sparse-checkout} ファイルを使用して各ワークツリーごとに独立したスパース性を指定します。 詳細については、 git-sparse-checkout(1) を参照してください。

歴史的な理由から、 @samp{extensions.worktreeConfig} は @samp{core.repositoryFormatVersion} の設定に関係なく尊重されます。
@end itemize

@item  fastimport.unpackLimit 
git-fast-import(1) によってインポートされたオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、インポートされたオブジェクトの数がこの制限以上の場合、パックはパックとして保存されます。 fast-import(高速インポート)からパックを保存すると、特に低速のファイルシステムで、インポート操作をより速く完了することができます。 設定されていない場合は、代わりに @samp{transfer.unpackLimit} の値が使用されます。

@item  feature.* 
@samp{feature.} で始まる構成設定は、他の構成設定のグループのデフォルトを変更します。 これらのグループは、Git開発者コミュニティによって推奨されるデフォルトとして作成されており、変更される可能性があります。 特に、新しい構成オプションが異なるデフォルトで追加される場合があります。

@item  feature.experimental 
Gitの新機能であり、将来のデフォルトで検討されている構成オプションを有効にします。 ここに含まれる構成設定は、マイナーバージョンの更新を含め、リリースごとに追加または削除される場合があります。 これらの設定は非常に新しいため、意図しない相互作用が発生する可能性があります。 実験的な機能に関するフィードバックを提供したい場合は、この設定を有効にしてください。 新しいデフォルト値は以下のとおりです:

@itemize 

@item
@samp{fetch.negotiationAlgorithm=skipping} は、一度により多くのコミットをスキップし、ラウンドトリップの数を減らすことで、フェッチネゴシエーション時間を改善できます。

@item
@samp{pack.useBitmapBoundaryTraversal=true} may improve bitmap traversal times by walking fewer objects.
@end itemize

@item  feature.manyFiles 
作業ディレクトリに多数のファイルがあるリポジトリを最適化する構成オプションを有効にします。 多くのファイルがあると、 @samp{git status} や @samp{git checkout} などのコマンドが遅くなる可能性があり、これらの新しいデフォルトによりパフォーマンスが向上します:

@itemize 

@item
@samp{index.skipHash=true} speeds up index writes by not computing a trailing checksum. Note that this will cause Git versions earlier than 2.13.0 to refuse to parse the index and Git versions earlier than 2.40.0 will report a corrupted index during @samp{git fsck}.

@item
@samp{index.version=4} インデックスのpath-prefix圧縮を有効にします。

@item
@samp{core.untrackedCache=true} 追跡されていないキャッシュを有効にします。この設定は、mtimeがマシンで機能していることを前提としています。
@end itemize

@item  fetch.recurseSubmodules 
このオプションは、 @samp{git fetch}(および @samp{git pull} の基になるフェッチ)が入力されたサブモジュールに再帰的にフェッチするかどうかを制御します。 このオプションは、ブール値または @samp{on-demand} のいずれかに設定できます。 ブール値に設定すると、フェッチとプルの動作が変更され、trueに設定されている場合は無条件にサブモジュールに再帰し、falseに設定されている場合はまったく再帰しません。 @samp{on-demand} に設定すると、フェッチとプルは、スーパープロジェクトがサブモジュールの参照を更新するコミットを取得したときにのみ、入力されたサブモジュールに再帰します。 デフォルトは @samp{on-demand} 、または @samp{submodule.recurse} が設定されている場合はその値です。

@item  fetch.fsckObjects 
trueに設定されている場合、git-fetch-packはフェッチされたすべてのオブジェクトをチェックします。 チェックされる内容については、 @samp{transfer.fsckObjects} を参照してください。 デフォルトはfalseです。 設定されていない場合は、代わりに @samp{transfer.fsckObjects} の値が使用されます。

@item  fetch.fsck.<msg-id> 
@samp{fsck.<msg-id>} のように機能しますが、 git-fsck(1) の代わりに git-fetch-pack(1) によって使用されます。 詳細については、 @samp{fsck.<msg-id>} のドキュメントを参照してください。

@item  fetch.fsck.skipList 
@samp{fsck.skipList} のように機能しますが、 git-fsck(1) の代わりに git-fetch-pack(1) によって使用されます。 詳細については、 @samp{fsck.skipList} のドキュメントを参照してください。

@item  fetch.unpackLimit 
Gitネイティブ転送を介してフェッチされるオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、受信したオブジェクトの数がこの制限以上の場合、受信したパックは、欠落しているデルタベースを追加した後、パックとして保存されます。 プッシュからパックを保存すると、特に低速のファイルシステムで、プッシュ操作をより速く完了することができます。 これが設定されていない場合は、代わりに @samp{transfer.unpackLimit} の値が使用されます。

@item  fetch.prune 
trueの場合、fetchはコマンドラインで @samp{--prune} オプションが指定されたかのように自動的に動作します。 @samp{remote.<name>.prune} および git-fetch(1) の「PRUNING」セクションも参照してください。

@item  fetch.pruneTags 
trueの場合、フェッチは、まだ設定されていない場合、刈り込み(pruning)時に @samp{refs/tags/*:refs/tags/*} refspecが提供されたかのように自動的に振る舞います。 これにより、このオプションと @samp{fetch.prune} の両方を設定して、アップストリーム参照への 1=1 マッピングを維持できます。 @samp{remote.<name>.pruneTags} および git-fetch(1) の「PRUNING」セクションも参照してください。

@item  fetch.output 
ref updateステータスの出力方法を制御します。 有効な値は @samp{full} と @samp{compact} です。 デフォルト値は @samp{full} です。 詳細については、 git-fetch(1) の「OUTPUT」セクションを参照してください。

@item  fetch.negotiationAlgorithm 
サーバーによって送信されるパックファイルの内容をネゴシエートするときに、ローカルリポジトリ内のコミットに関する情報がどのように送信されるかを制御します。 @samp{consecutive} に設定すると、連続したコミットをそれぞれチェックするアルゴリズムを使用します。 @samp{skipping} に設定すると、収束を高速化するためにコミットをスキップするアルゴリズムが使用されますが、必要以上の大きさのパックファイルが生成される可能性があります。 または、 @samp{noop} に設定して情報をまったく送信しないようにします。これにより、ほぼ確実に必要以上に大きなパックファイルが生成されますが、ネゴシエーション・ステップはスキップされます。 @samp{default} に設定すると、それ以前に行われた設定をオーバーライドしてデフォルトの振る舞いをします。 デフォルトは通常 @samp{consecutive} ですが、 @samp{feature.experimental} が true の場合、デフォルトは @samp{skipping} です。 値が不明な場合、 @samp{git fetch} でエラーが発生します。

git-fetch(1) の @samp{--negotiate-only} および @samp{--negotiation-tip} オプションも参照してください。

@item  fetch.showForcedUpdates 
falseに設定すると、 git-fetch(1) および git-pull(1) コマンドで @samp{--no-show-forced-updates} が有効になります。 デフォルトはtrueです。

@item  fetch.parallel 
一度に並行して実行されるフェッチ操作の最大数を指定します(サブモジュール、または、git-fetch(1) の @samp{--multiple} オプションが有効な場合はリモート)。

値0は、適切なデフォルトを提供します。 設定されていない場合、デフォルトで1になります。

サブモジュールの場合、この設定は、 @samp{submodule.fetchJobs} 構成設定を使用してオーバーライドできます。

@item  fetch.writeCommitGraph 
リモートからパックファイルをダウンロードするすべての @samp{git fetch} コマンドの後でcommit-graphを書き込むには、trueに設定します。 @samp{--split} オプションを使用すると、ほとんどの実行で、既存のcommit-graphファイルの上に非常に小さなcommit-graphファイルが作成されます。 場合によっては、これらのファイルがマージされ、書き込みに時間がかかることがあります。 更新されたcommit-graphファイルがあると、 @samp{git merge-base} や @samp{git push -f} や @samp{git log --graph} などの多くのGitコマンドのパフォーマンス改善に役立ちます。 デフォルトはfalseです。

@item  fetch.bundleURI 
This value stores a URI for downloading Git object data from a bundle URI before performing an incremental fetch from the origin Git server. This is similar to how the @samp{--bundle-uri} option behaves in git-clone(1). @samp{git clone --bundle-uri} will set the @samp{fetch.bundleURI} value if the supplied bundle URI contains a bundle list that is organized for incremental fetches.

If you modify this value and your repository has a @samp{fetch.bundleCreationToken} value, then remove that @samp{fetch.bundleCreationToken} value before fetching from the new bundle URI.

@item  fetch.bundleCreationToken 
When using @samp{fetch.bundleURI} to fetch incrementally from a bundle list that uses the "creationToken" heuristic, this config value stores the maximum @samp{creationToken} value of the downloaded bundles. This value is used to prevent downloading bundles in the future if the advertised @samp{creationToken} is not strictly larger than this value.

The creation token values are chosen by the provider serving the specific bundle URI. If you modify the URI at @samp{fetch.bundleURI}, then be sure to remove the value for the @samp{fetch.bundleCreationToken} value before fetching.

@item  format.attach 
Enable multipart/mixed attachments as the default for @emph{format-patch}. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in git-format-patch(1). To countermand an earlier value, set it to an empty string.

@item  format.from 
@samp{--from} オプションのデフォルト値をformat-patchに提供します。ブール値、または名前と電子メールアドレスを受け入れます。 falseの場合、format-patchはデフォルトで @samp{--no-from} になり、パッチメールの @samp{From:} フィールドに直接コミット作成者を使用します。 trueの場合、format-patchはデフォルトで @samp{--from} になり、パッチメールの @samp{From:} フィールドにあなたのコミッターIDを使い、異なる場合にはパッチメールの本文に @samp{From:} フィールドを含めます。 ブール値でない値を設定した場合、format-patch はあなたのコミッターIDの代わりにその値を使用します。 デフォルトは false です。

@item  format.forceInBodyFrom 
@samp{--[no-]force-in-body-from} オプションのデフォルト値を format-patch に提供します。 デフォルトは false です。

@item  format.numbered 
パッチ件名のシーケンス番号を有効または無効にできるブール値。 デフォルトは「auto」で、複数のパッチがある場合にのみ有効になります。 「true」または「false」に設定することで、すべてのメッセージに対して有効または無効にできます。 git-format-patch(1)の @samp{--numbered} オプションを参照してください。

@item  format.headers 
メールで送信するパッチに含める追加の電子メールヘッダー。 git-format-patch(1) を参照してください。

@item  format.to 
@itemx  format.cc 
メールで送信するパッチに含める追加の受信者。 git-format-patch(1)の @samp{--to} および` --cc` オプションを参照してください。

@item  format.subjectPrefix 
format-patchのデフォルトは、 @samp{[PATCH]} という接頭辞の件名のファイルを出力することです。 この変数を使用して、その接頭辞を変更します。

@item  format.coverFromDescription 
ブランチの説明を使用してカバーレターのどの部分にデータを入力するかを決定するためのformat-patchのデフォルトモード。 git-format-patch(1)の @samp{--cover-from-description} オプションを参照してください。

@item  format.signature 
format-patchのデフォルトは、Gitバージョン番号を含む署名を出力することです。 この変数を使用して、そのデフォルトを変更します。 この変数を空の文字列("")に設定すると、署名の生成を抑制します。

@item  format.signatureFile 
この変数で指定されたファイルの内容が署名として使用されることを除いて、 format.signature と同じように機能します。

@item  format.suffix 
format-patchのデフォルトは、接尾辞が @samp{.patch} のファイルを出力することです。 この変数を使用して、その接尾辞を変更します(必要に応じて、必ずドット(@samp{.})を含めてください)。

@item  format.encodeEmailHeaders 
電子メール送信用に、非ASCII文字を含む電子メールヘッダーを「Q-encoding」(RFC 2047で説明)でエンコードします。 デフォルトはtrueです。

@item  format.pretty 
log/show/whatchanged コマンドのpretty形式のデフォルト。 git-log(1) 、 git-show(1) 、 git-whatchanged(1) を参照してください。

@item  format.thread 
@samp{git format-patch} のデフォルトのスレッドスタイル。 ブール値 または @samp{shallow} または @samp{deep} にすることができます。 @samp{shallow} スレッドは、すべてのメールをシリーズの先頭にに対して返信します。先頭は、カバーレター、 @samp{--in-reply-to} 、最初のパッチメールの順に選択されます。 @samp{deep} スレッドは、すべてのメールを前のメールに返信します。 true のブール値は @samp{shallow} と同じであり、 false値はスレッド化を無効にします。

@item  format.signOff 
デフォルトでformat-patchの @samp{-s/--signoff} オプションを有効にできるブール値。 @strong{注意} パッチに「Signed-off-by」トレーラーを追加することは意識的な行為である必要があり、同じオープンソースライセンスの下でこの作品を提出する権利があることを証明することを意味します。 詳細については、「SubmittingPatches」ドキュメントを参照してください。

@item  format.coverLetter 
format-patchが呼び出されたときにカバーレターを生成するかどうかを制御するブール値ですが、さらに「auto」に設定して、複数のパッチがある場合にのみカバーレターを生成することができます。 デフォルトはfalseです。

@item  format.outputDirectory 
現在の作業ディレクトリの代わりに、結果のファイルを保存するカスタムディレクトリを設定します。 すべてのディレクトリコンポーネントが作成されます。

@item  format.filenameMaxLength 
@samp{format-patch} コマンドによって生成される出力ファイル名の最大長。 デフォルトは64です。@samp{--filename-max-length=<n>} コマンドラインオプションで上書きできます。

@item  format.useAutoBase 
format-patch のオプションである @samp{--base=auto} をデフォルトで有効にするためのブール値です。 @samp{whenAble} に設定すると、適切なベースがある場合に @samp{--base=auto} を有効にし、それ以外の場合はフォーマット終了せずにベース情報の追加をスキップすることもできます。

@item  format.notes 
format-patchの @samp{--notes} オプションのデフォルト値を提供します。 ブール値、またはnotesを取得する場所を指定するrefを受け入れます。 falseの場合、format-patchのデフォルトは @samp{--no-notes} です。 trueの場合、format-patchのデフォルトは @samp{--notes} です。 非ブール値に設定されている場合、format-patchのデフォルトは @samp{--notes=<ref>} です。ここで、 @samp{ref} は指定した非ブール値です。 デフォルトはfalseです。

ref @samp{ref/notes/true} を使用したい場合は、代わりにそのリテラルを使用してください。

この構成は、複数のnotes refを含めるために複数回指定できます。その場合、渡された複数の @samp{--[no-]notes[=]} オプションと同様に動作します。つまり、値 @samp{true} はデフォルトのnotesを表示し、値 @samp{<ref>} はそのnotes ref からのnotesも表示し、値 @samp{false} はそれ以前の設定を無効にし、notesを表示しません。

例えば以下の場合、

@example
[format]
        notes = true
        notes = foo
        notes = false
        notes = bar
@end example


@samp{refs/notes/bar} からのnotesのみが表示されます。

@item  format.mboxrd 
A boolean value which enables the robust "mboxrd" format when @samp{--stdout} is in use to escape "^>+From " lines.

@item  format.noprefix 
If set, do not show any source or destination prefix in patches. This is equivalent to the @samp{diff.noprefix} option used by @samp{git diff} (but which is not respected by @samp{format-patch}). Note that by setting this, the receiver of any patches you generate will have to apply them using the @samp{-p0} option.

@item  filter.<driver>.clean 
チェックイン時にワークツリーファイルのコンテンツをブロブに変換するために使用されるコマンド。 詳細については、 gitattributes(5) を参照してください。

@item  filter.<driver>.smudge 
チェックアウト時にブロブオブジェクトのコンテンツをワークツリーファイルに変換するために使用されるコマンド。 詳細については、 gitattributes(5) を参照してください。

@item  fsck.<msg-id> 
fsck中に、gitは、現在のバージョンのgitでは生成されず、 @samp{transfer.fsckObjects} が設定されている場合はネットワーク経由で送信されない、レガシーデータの問題を検出する場合があります。この機能は、そのようなデータを含むレガシーリポジトリの操作をサポートすることを目的としています。

@samp{fsck.<msg-id>} 設定は、 git-fsck(1) によって取得されますが、代わりに、そのようなデータセット @samp{receive.fsck.<msg-id>} のプッシュを受け入れるか、または、クローンまたはフェッチのセットである @samp{fetch.fsck.<msg-id>} を使用します。

この文書の残りの部分では、簡潔にするために @samp{fsck.*} 変数について説明していますが、対応する @samp{receive.fsck.*} 変数と @samp{fetch.<msg-id>.*} 変数にも同じことが当てはまります。

@samp{color.ui} や @samp{core.editor} のような変数とは異なり、 @samp{receive.fsck.<msg-id>} と @samp{fetch.fsck.<msg-id>} 変数は、設定されていない場合、 @samp{fsck.<msg-id>} 構成にフォールバックしません。さまざまな状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。

@samp{fsck.<msg-id>} が設定されている場合、 @samp{fsck.<msg-id>} の値を @samp{error} 、 @samp{warn} 、@samp{ignore} のいずれか一つとすることにより、エラーを警告に切り替える事もでき、その逆も可能です。そして @samp{<msg-id>} の部分はメッセージIDです。便利なように、fsckはエラー/警告メッセージの前にメッセージIDを付けます。たとえば「missingEmail: invalid author/committer line - missing email」は、 @samp{fsck.missingEmail = ignore} を設定するとその問題が非表示になることを意味します。

一般に、これらの問題のあるオブジェクトが共有する破損の種類をリストして無視するのではなく、 @samp{fsck.skipList} に問題のある既存のオブジェクトを列挙することをお勧めします。前者を実行すると、同じ破損の新しいインスタンスが見過ごされる可能性があります。

不明な @samp{fsck.<msg-id>} 値を設定すると、fsckが停止(die)しますが、 @samp{receive.fsck.<msg-id>} や @samp{fetch.fsck.<msg-id>} に対して同じことを行うと、gitは単に警告するだけです。

See @samp{Fsck Messages} section of git-fsck(1) for supported values of @samp{<msg-id>}.

@item  fsck.skipList 
非致命的な理由により既に壊れている(broken)ことが分かっているため無視する必要があるオブジェクト名(1行につき1つの省略されてないSHA-1)のリストへのパス。Git 2.20 以降では、コメント(@samp{#})文字から行末までと、空行と、先頭と末尾の空白(whitespace)は無視されます。それより古いバージョンでは1行につき1つのSHA-1以外は全てエラーになります。

この機能は、無効なコミッターの電子メールアドレスなど、初期のコミットにもかかわらず、安全に無視できるエラーを含む、確立されたプロジェクトを受け入れる必要がある場合に役立ちます。 注意: この設定では、corruptオブジェクトをスキップすることはできません。

@samp{fsck.<msg-id>} と同様に、この変数に対応する @samp{receive.fsck.skipList} 派生と @samp{fetch.fsck.skipList} 派生があります。

@samp{color.ui} や @samp{core.editor} のような変数とは異なり、 @samp{receive.fsck.skipList} 変数と @samp{fetch.fsck.skipList} 変数は、設定されていない場合、 @samp{fsck.skipList} 構成にフォールバックしません。さまざまな状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。

古いバージョンのGit(2.20より前)では、オブジェクト名リストを並べ替える必要があることが文書化されています。これは必須ではなく、オブジェクト名は任意の順序で表示できますが、リストを読み取るときに、内部バイナリ検索実装の目的でリストが並べ替えられているかどうかを追跡しました。これにより、既に並べ替えられたリストでは作業を節約できます。膨大なリストがない限り、リストを事前に並べ替える必要はありませんでした。 Gitバージョン2.20以降では、代わりにハッシュ実装が使用されるため、リストを事前に並べ替える必要はありません。

@item  fsmonitor.allowRemote 
By default, the fsmonitor daemon refuses to work against network-mounted repositories. Setting @samp{fsmonitor.allowRemote} to @samp{true} overrides this behavior. Only respected when @samp{core.fsmonitor} is set to @samp{true}.

@item  fsmonitor.socketDir 
This Mac OS-specific option, if set, specifies the directory in which to create the Unix domain socket used for communication between the fsmonitor daemon and various Git commands. The directory must reside on a native Mac OS filesystem. Only respected when @samp{core.fsmonitor} is set to @samp{true}.

@item  gc.aggressiveDepth 
@samp{git gc --aggressive} で使用されるデルタ圧縮アルゴリズムで使用される深さパラメーター。これはデフォルトで50に設定されています。これは @samp{--aggressive} が使用されていない場合の @samp{--depth} オプションのデフォルトです。

詳細については git-repack(1) の @samp{--depth} オプションの文書を参照してください。

@item  gc.aggressiveWindow 
@samp{git gc --aggressive} で使用されるデルタ圧縮アルゴリズムで使用されるウィンドウサイズパラメータ。これはデフォルトで250に設定されています。これは、 @samp{--window} のデフォルト値の10よりもはるかに積極的なウィンドウサイズです。

詳細については、 git-repack(1) の @samp{--window} オプションの文書を参照してください。

@item  gc.auto 
リポジトリにおおよそ指定の値より多くのルーズオブジェクトがある場合、 @samp{git gc --auto} はそれらをパックします。一部の磁器コマンドは、このコマンドを使用して、軽量のガベージコレクションを時々実行します。デフォルト値は6700です。

これを0に設定すると、ルーズオブジェクトの数に基づく自動パッキングが無効にななります。また、他のヒューリスティックな @samp{git gc --auto} が、 @samp{gc.autoPackLimit} などの作業があるかどうかを判断するためにこの値を使用します。

@item  gc.autoPackLimit 
リポジトリに @samp{* .keep} ファイルでマークされていないパックがこの設定値より多くある場合、 @samp{git gc --auto} はそれらを1つの大きなパックに統合します。デフォルト値は50です。これを0に設定すると、無効になります。 @samp{gc.auto} を0に設定すると、この設定も無効になります。

以下の @samp{gc.bigPackThreshold} 構成変数を参照してください。この設定を使用中は、自動パックの制限がどのように機能するかに影響します。

@item  gc.autoDetach 
システムがサポートしている場合は @samp{git gc --auto} は即座戻り、実行はバックグラウンドで行われます。デフォルトはtrueです。

@item  gc.bigPackThreshold 
If non-zero, all non-cruft packs larger than this limit are kept when @samp{git gc} is run. This is very similar to @samp{--keep-largest-pack} except that all non-cruft packs that meet the threshold are kept, not just the largest pack. Defaults to zero. Common unit suffixes of @emph{k}, @emph{m}, or @emph{g} are supported.

注意: 保持されるパックの数が gc.autoPackLimit を超える場合、この構成変数は無視され、基本パックを除くすべてのパックが再パックされることに注意してください。再パック後、パックの数は gc.autoPackLimit を下回り、再び gc.bigPackThreshold が尊重されるでしょう。

@samp{git repack} がスムーズに実行されると推定されるメモリ量が利用できず、かつ、 @samp{gc.bigPackThreshold} が設定されていない場合、最大のパックも除外されます(これは、 @samp{--keep-largest-pack} を指定して @samp{git gc} を実行するのと同じです)。

@item  gc.writeCommitGraph 
trueの場合、 git-gc(1) が実行されると、 gcはcommit-graphファイルを書き換えます。 @samp{git gc --auto} を使用する場合、ハウスキーピングが必要な場合はコミットグラフが更新されます。デフォルトはtrueです。詳細については git-commit-graph(1) を参照してください。

@item  gc.logExpiry 
ファイルgc.logが存在する場合、 @samp{git gc --auto} はそのコンテンツを出力し、そのファイルが「gc.logExpiry」より古い場合を除いて、実行する代わりにステータス0で終了します。デフォルトは「1.day」です。その他の値の指定方法については @samp{gc.pruneExpire} を参照してください。

@item  gc.packRefs 
リポジトリで @samp{git pack-refs} を実行すると、HTTPなどの馬鹿プロトコル(dumb transport) を介して 1.5.1.2 より前のGitバージョンではクローンが作成できなくなります。この変数は、「git gc」が「git pack-refs」を実行するかどうかを決定します。これを @samp{notbare} に設定して、すべての非ベアリポジトリ内で有効にするか、ブール値に設定することができます。 デフォルトは @samp{true} です。

@item  gc.cruftPacks 
Store unreachable objects in a cruft pack (see git-repack(1)) instead of as loose objects. The default is @samp{true}.

@item  gc.pruneExpire 
@samp{git gc} を実行すると、 @samp{prune --expire 2.weeks.ago} が呼び出されます(そして @samp{gc.cruftPacks} または @samp{--cruft} を介してクラフトパック(cruft packs)を使用している場合は、 @samp{repack --cruft --cruft-expiration 2.weeks.ago} が呼び出されます)。 この構成変数で猶予期間をオーバーライドします。 値 @samp{now} を使用してこの猶予期間を無効にし、到達不能なオブジェクトを常にすぐに刈り込み(prune)するか、 @samp{never} を使用して刈り込みを抑制することができます。この機能は @samp{git gc} が、リポジトリに書き込む別のプロセスと並列実行される場合の破損を防ぐのに役立ちます。 git-gc(1) の「NOTES」セクションを参照してください。

@item  gc.worktreePruneExpire 
@samp{git gc} が実行されると、 @samp{git worktree prune --expire3.months.ago} が呼び出されます。この構成変数を使用して、別の猶予期間を設定できます。値「now」を使用して猶予期間を無効にし、 @samp{$GIT_DIR/worktrees} をすぐに剪定(prune)するか、「never」を使用して剪定を抑制することができます。

@item  gc.reflogExpire 
@itemx  gc.<pattern>.reflogExpire 
「git reflog expire」は、この時間より古いreflogエントリを削除します。デフォルトは90日です。値「now」はすべてのエントリをすぐに期限切れにし、「never」は期限切れを完全に抑制します。中央に「<pattern>」(例:「refs/stash」)がある場合、設定は <pattern> に一致するrefにのみ適用されます。

@item  gc.reflogExpireUnreachable 
@itemx  gc.<pattern>.reflogExpireUnreachable 
@samp{git reflog expire} は、この時間より古いreflogエントリを削除し、現在の先端(the current tip)から到達不能にします。デフォルトは30日です。値「now」はすべてのエントリをすぐに期限切れにし、「never」は期限切れを完全に抑制します。中央に「<pattern>」(例:「refs/stash」)がある場合、設定は <pattern> に一致するrefにのみ適用されます。

これらのタイプのエントリは通常、 @samp{git commit--amend} または @samp{git rebase} を使用した結果として作成され、修正またはリベースが発生する前のコミットです。これらの変更は現在のプロジェクトの一部ではないため、ほとんどのユーザーはそれらをより早く期限切れにしたいと思うでしょう。そのため、デフォルトは @samp{gc.reflogExpire} よりも積極的です。

@item  gc.recentObjectsHook 
When considering whether or not to remove an object (either when generating a cruft pack or storing unreachable objects as loose), use the shell to execute the specified command(s). Interpret their output as object IDs which Git will consider as "recent", regardless of their age. By treating their mtimes as "now", any objects (and their descendants) mentioned in the output will be kept regardless of their true age.

Output must contain exactly one hex object ID per line, and nothing else. Objects which cannot be found in the repository are ignored. Multiple hooks are supported, but all must exit successfully, else the operation (either generating a cruft pack or unpacking unreachable objects) will be halted.

@item  gc.rerereResolved 
以前に解決した競合するマージの記録は、「git rerere gc」が実行されるときに、この設定値で指定の日数保持されます。より人間が読める「1.month.ago」などを使用することもできます。デフォルトは60日です。 git-rerere(1) を参照してください。

@item  gc.rerereUnresolved 
@samp{git rerere gc} が実行されると、解決していない競合するマージの記録がこの設定値の日数保持されます。より人間が読める `1.month.ago`などを使用することもできます。デフォルトは15日です。 git-rerere(1) を参照してください。

@item  gitcvs.commitMsgAnnotation 
この文字列を各コミットメッセージに追加します。この機能を無効にするには、空の文字列に設定します。 デフォルトは "via git-CVS emulator" (git-CVSエミュレーター経由)です。

@item  gitcvs.enabled 
このリポジトリに対してCVSサーバー・インターフェースが有効になっているかどうか。 git-cvsserver(1) を参照してください。

@item  gitcvs.logFile 
CVS サーバインターフェイスが様々なことを記録するログファイルへのパスです。 git-cvsserver(1) を参照してください。

@item  gitcvs.usecrlfattr 
trueの場合、サーバーはファイルの行末変換属性を検索して、使用する @samp{-k} モードを決定します。 属性がGitにファイルをテキストとして処理させる場合、 @samp{-k} モードは空白(blank)のままになるため、CVSクライアントはファイルをテキストとして処理します。 それらがテキスト変換を抑制する場合、ファイルは @samp{-kb} モードで設定されます。これにより、クライアントが他の方法で行う可能性のある改行の変更が抑制されます。 属性でファイルタイプを決定できない場合は、@samp{gitcvs.allBinary} が使用されます。 gitattributes(5) を参照してください。

@item  gitcvs.allBinary 
これは、 @samp{gitcvs.usecrlfattr} が使用する「正しい @samp{-kb} モード」(correct @emph{-kb} mode)で解決しない場合に使用されます。 trueの場合、未解決のファイルはすべてモード @samp{-kb} でクライアントに送信されます。 これにより、クライアントはそれらをバイナリファイルとして扱い、改行が変更されないようにします。 または、 @samp{guess} に設定されている場合は、ファイルの内容が調べられ、 @samp{core.autocrlf} と同様に、バイナリであるかどうかが判断されます。

@item  gitcvs.dbName 
Gitリポジトリから派生したリビジョン情報をキャッシュするためにgit-cvsserverによって使用されるデータベース。 正確な意味は、使用するデータベースドライバーによって異なります。 SQLite(デフォルトのドライバー)の場合、これはファイル名です。 変数の置換をサポートします(詳細については、 git-cvsserver(1) を参照してください)。 セミコロン(@samp{;})を含めることはできません。 デフォルトは @samp{%Ggitcvs.%m.sqlite} です。

@item  gitcvs.dbDriver 
使用するPerlDBIドライバー。 ここで使用可能なドライバーを指定できますが、機能しない場合があります。 git-cvsserverは @samp{DBD::SQLite} でテストされています。 @samp{DBD::Pg で動作するという報告がありますが、 `DBD::mysql} で動作しないことが報告されています。 実験的機能です。 二重コロン(@samp{::})を含めることはできません。 デフォルトは @samp{SQLite} です。 git-cvsserver(1) を参照してください。

@item  gitcvs.dbUser, gitcvs.dbPass 
データベースのユーザーとパスワード。 SQLiteにはデータベースユーザーやパスワードの概念がないため、 @samp{gitcvs.dbDriver} を設定する場合にのみ役立ちます。 @samp{gitcvs.dbUser} は変数の置換をサポートしています(詳細については git-cvsserver(1) を参照してください)。

@item  gitcvs.dbTableNamePrefix 
データベーステーブル名のプレフィックス。 使用されるデータベーステーブルの名前の前に付けられ、単一のデータベースを複数のリポジトリに使用できるようにします。 変数の置換をサポートします(詳細については、 git-cvsserver(1) を参照してください)。 アルファベット以外の文字はすべてアンダースコアに置き換えられます。
@end table

@samp{gitcvs.usecrlfattr} と @samp{gitcvs.allBinary} を除くすべてのgitcvs変数は、 @samp{gitcvs.<access_method>.<varname>} (@samp{access_method} は "ext" と "pserver" のいずれか)として指定することもできます。それらは、指定のアクセス方法(@samp{<access_method>})にのみ適用されます。

@table @asis

@item  gitweb.category 
@itemx  gitweb.description 
@itemx  gitweb.owner 
@itemx  gitweb.url 
説明については gitweb(1) を参照してください。

@item  gitweb.avatar 
@itemx  gitweb.blame 
@itemx  gitweb.grep 
@itemx  gitweb.highlight 
@itemx  gitweb.patches 
@itemx  gitweb.pickaxe 
@itemx  gitweb.remote_heads 
@itemx  gitweb.showSizes 
@itemx  gitweb.snapshot 
説明については gitweb.conf(5) を参照してください。

@item  grep.lineNumber 
trueに設定すると、デフォルトで @samp{-n} オプションが有効になります。

@item  grep.column 
trueに設定されている場合、デフォルトで @samp{--column} オプションを有効にします。

@item  grep.patternType 
デフォルトのマッチング動作を設定します。 @samp{basic} または @samp{extended} または @samp{fixed} または @samp{perl} の値を使用すると、それぞれに応じて @samp{--basic-regexp} または ` --extended-regexp` または @samp{--fixed-strings} または @samp{--perl-regexp} オプションが有効になります。 値 @samp{default} は @samp{grep.extendedRegexp} オプションを使用して @samp{basic} と @samp{extended} のどちらかを選択します。

@item  grep.extendedRegexp 
trueに設定されている場合、デフォルトで @samp{--extended-regexp} オプションを有効にします。 @samp{grep.patternType} オプションが @samp{default} 以外の値に設定されている場合、このオプションは無視されます。

@item  grep.threads 
使用する grep ワーカー・スレッドの数。 設定しない場合(または 0 に設定した場合)、 Git は使用可能な論理コアの数と同じ数のスレッドを使用します。

@item  grep.fullName 
trueに設定すると、デフォルトで @samp{--full-name} オプションが有効になります。

@item  grep.fallbackToNoIndex 
trueに設定すると、 @samp{git grep} がgitリポジトリの外部で実行される場合は、 @samp{git grep --no-index} にフォールバックします。 デフォルトはfalseです。

@item  gpg.program 
PGP署名を作成または検証するときは、@samp{$PATH} にある @samp{gpg} の代わりにこのカスタムプログラムを使用します。 プログラムはGPGと同じコマンドラインインターフェイスをサポートする必要があります。つまり、切り離された署名(detached signature)を検証するには、 @samp{gpg --verify $signature - <$file} が実行され、 プログラムは、コード0で終了することにより、適切な署名を通知することが期待されます。PGP ASCII-armor の分離署名(ASCII-armored detached signature)を生成するために、 @samp{gpg -bsau $key} の標準入力には、署名する内容が入力され、プログラムはその結果を標準出力に送信することが期待されています。

@item  gpg.format 
@samp{--gpg-sign} で署名するときに使用するキー形式を指定します。 デフォルトは @samp{openpgp} です。 別の可能な値は @samp{x509} と @samp{ssh} です。

See gitformat-signature(5) for the signature format, which differs based on the selected @samp{gpg.format}.

@item  gpg.<format>.program 
これを使用して、選択した署名形式に使用されるプログラムをカスタマイズします。 ( @samp{gpg.program} と @samp{gpg.format} 参照) @samp{gpg.program} は、 @samp{gpg.openpgp.program} の歴史的同義語として引き続き使用できます。 @samp{gpg.x509.program} のデフォルト値は @samp{gpgsm} で、 @samp{gpg.ssh.program} のデフォルト値は @samp{ssh-keygen} です。

@item  gpg.minTrustLevel 
署名検証(signature verification)の最小信頼(trust)レベルを指定します。 このオプションが設定されていない場合、マージ操作の署名検証には、少なくとも @samp{marginal} 信頼(trust)のあるキーが必要です。 署名の検証を実行する他の操作には、少なくとも @samp{undefined} の信頼を持つキーが必要です。 このオプションを設定すると、すべての操作に必要な信頼レベルが上書きされます。 サポートされている値は以下のとおりです(重要度の昇順):

@itemize 

@item
@samp{undefined}

@item
@samp{never}

@item
@samp{marginal}

@item
@samp{fully}

@item
@samp{ultimate}
@end itemize

@item  gpg.ssh.defaultKeyCommand 
このコマンドは、 @samp{user.signingkey} が設定されておらず、かつ、 ssh 署名が要求されたときに実行されます。 正常に終了すると、出力の最初の行に @samp{key::} で始まる有効な ssh 公開鍵あるものと期待します。 これにより、 @samp{user.signingKey} を静的に構成することが実際的でない場合に、スクリプトが正しい公開鍵を動的に検索(lookup)できるようになります。 これはたとえば、キーまたは SSH 証明書が頻繁にローテーションされる場合や、適切なキーの選択が git にとって未知の外部要因に依存する場合などです。

@item  gpg.ssh.allowedSignersFile 
信頼できる ssh 公開鍵を含むファイル。 このファイルは、1行以上のプリンシパル(principals)とそれに続く ssh 公開鍵で構成されます。 例: @samp{user1@@example.com,user2@@example.com ssh-rsa AAAAX1...} 詳細については、 ssh-keygen(1) の「ALLOWED SIGNERS」を参照してください。 プリンシパル(principal)は、キーを識別するためにのみ使用され、署名を検証(verify)するときに使用できます。

SSH には、gpg のような信頼レベル(trust levels)の概念がありません。 有効な署名(valid signatures)と信頼できる署名(trusted signatures)を区別できるようにするために、 allowedSignersFile に公開鍵が存在する場合、署名検証の信頼レベルは @samp{fully} に設定されます。 それ以外の場合、信頼レベルは @samp{undefined} であり、git verify-commit/tag は失敗します。

このファイルはリポジトリ外の場所に設定でき、すべての開発者が独自の信頼ストア(trust store)を維持します。 中央リポジトリ・サーバーは、コードを検証するためのプッシュ・アクセスを使用して、ssh キーからこのファイルを自動的に生成できます。 おそらく、企業の設定では、このファイルは、開発者の ssh キーを既に処理している自動化によってグローバルな場所に生成されます。

署名付きコミットのみを許可するリポジトリは、作業ツリーの最上位からの相対パスを使用して、リポジトリ自体にファイルを保存できます。 このようにして、すでに有効なキーを持つコミッターのみが、キーリングのキーを追加または変更できます。

OpensSSH 8.8 以降、このファイルでは、valid-after および valid-before オプションを使用してキーの有効期間を指定できます。 署名の作成時に署名キーが有効であった場合、Git は署名を有効としてマークします。 これにより、ユーザーは以前に作成されたすべての署名を無効にすることなく、署名キーを変更できます。

cert-authority オプション (ssh-keygen(1) の「CERTIFICATES」を参照) を指定した SSH CA 鍵の使用も有効です。

@item  gpg.ssh.revocationFile 
SSH KRL または取り消された公開鍵のリスト(プリンシパル(principal)プレフィックスなし)。 詳細については、 ssh-keygen(1) を参照してください。 公開鍵がこのファイルで見つかった場合、その公開鍵は常に信頼レベル @samp{never} として扱われ、署名は無効として表示されます。

@item  gui.commitMsgWidth 
git-gui(1) のコミットメッセージウィンドウの幅を定義します。 「75」がデフォルトです。

@item  gui.diffContext 
git-gui(1) によるdiffの呼び出しで使用するコンテキスト行の数を指定します。 デフォルトは「5」です。

@item  gui.displayUntracked 
git-gui(1) がファイルリストに追跡されていないファイルを表示するかどうかを決定します。 デフォルトは「true」です。

@item  gui.encoding 
git-gui(1) および gitk(1) でファイルの内容を表示するために使用するデフォルトの文字エンコードを指定します。 関連するファイルの「encoding」属性を設定することでオーバーライドできます(gitattributes(5) 参照)。 このオプションが設定されていない場合、ツールはデフォルトでロケールエンコーディングになります。

@item  gui.matchTrackingBranch 
git-gui(1) で作成された新しいブランチが、デフォルトで名前が一致するリモートブランチを追跡するかどうかを決定します。 デフォルトは「false」です。

@item  gui.newBranchTemplate 
git-gui(1) を使用して新しいブランチを作成するときに、推奨される名前として使用されます。

@item  gui.pruneDuringFetch 
git-gui(1) がフェッチの実行時にリモート追跡ブランチを刈り込み(prune)する必要がある場合は「true」。 デフォルト値は「false」です。

@item  gui.trustmtime 
git-gui(1) がファイル変更のタイムスタンプを信頼するかどうかを決定します。 デフォルトでは、タイムスタンプは信頼されていません。

@item  gui.spellingDictionary 
git-gui(1) でコミットメッセージのスペルチェックに使用される辞書を指定します。「none」に設定すると、スペルチェックがオフになります。

@item  gui.fastCopyBlame 
trueの場合、 @samp{git gui blame} は、元の場所(original location)の検出に @samp{-C -C} ではなく @samp{-C} を使用します。 コピーの検出が完全ではなくなる代わりに、巨大なリポジトリでのblameが大幅に速くなります。

@item  gui.copyBlameThreshold 
英数字(alphanumeric)文字で測定された、 @samp{git gui blame} の元の位置(original location)検出で使用するしきい値を指定します。 コピー検出の詳細については、 git-blame(1) のマニュアルを参照してください。

@item  gui.blamehistoryctx 
「Show History Context」(履歴コンテキストの表示)メニュー項目が @samp{git gui blame} から呼び出されたときに、選択したコミットの gitk(1) に表示する履歴コンテキストの範囲を日数で指定します。 この変数がゼロに設定されている場合、履歴全体が表示されます。

@item  guitool.<name>.cmd 
git-gui(1) Toolsメニューの対応する項目が呼び出されたときに実行するシェルコマンドラインを指定します。 このオプションは、すべてのツールに必須です。 コマンドは作業ディレクトリのルートから実行され、環境ではツールの名前を @samp{GIT_GUITOOL} 、現在選択されているファイルの名前を @samp{FILENAME} 、現在のブランチの名前を @samp{CUR_BRANCH} として受け取ります(切り離されたヘッド(detached head)の場合、 @samp{CUR_BRANCH} は空です)。

@item  guitool.<name>.needsFile 
GUIでdiffが選択されている場合にのみ、ツールを実行します。 @samp{FILENAME} が空でないことを保証します。

@item  guitool.<name>.noConsole 
出力を表示するウィンドウを作成せずに、コマンドを黙って実行します。

@item  guitool.<name>.noRescan 
ツールの実行が終了した後、変更がないか作業ディレクトリを再スキャンしないでください。

@item  guitool.<name>.confirm 
ツールを実際に実行する前に、確認ダイアログを表示します。

@item  guitool.<name>.argPrompt 
ユーザーに文字列引数を要求し、それを @samp{ARGS} 環境変数を介してツールに渡します。 引数の要求は確認を意味するため、これが有効になっている場合、「confirm」オプションは効果がありません。 オプションが @samp{true} または @samp{yes} または 1 に設定されている場合、ダイアログは組み込みの汎用プロンプトを使用します。 それ以外の場合は、変数の正確な値が使用されます。

@item  guitool.<name>.revPrompt 
ユーザーに有効なリビジョンを1つ要求し、 @samp{REVISION} 環境変数を設定します。 それ以外は @samp{argPrompt} と同様です。 @samp{argPrompt} と一緒に使用できます。

@item  guitool.<name>.revUnmerged 
@samp{revPrompt} サブダイアログにマージされていないブランチのみを表示します。 これは、マージやリベースに似たツールには役立ちますが、チェックアウトやリセットなどには役立ちません。

@item  guitool.<name>.title 
プロンプトダイアログに使用するタイトルを指定します。 デフォルトはツール名です。

@item  guitool.<name>.prompt 
ダイアログの上部、 @samp{argPrompt} および @samp{revPrompt} のサブセクションの前に表示する一般的なプロンプト文字列を指定します。 デフォルト値には実際のコマンドが含まれます。

@item  help.browser 
ヘルプをweb形式で表示するために使用されるブラウザーを指定します。 git-help(1) を参照してください。

@item  help.format 
git-help(1) で使用されるデフォルトのヘルプ形式を上書きします。 値として @samp{man} と @samp{info} と @samp{web} と @samp{html} がサポートされています。 @samp{man} がデフォルトです。 @samp{web} と @samp{html} は同じ(same)です。

@item  help.autoCorrect 
gitがタイプミスを検出し、間違いにに類似した有効なコマンドを1つだけ識別できる場合、gitは正しいコマンドを提案しようとするか、提案を自動的に実行します。 可能な構成値は以下のとおりです:

@itemize 

@item
0 (デフォルト): 提案されたコマンドを表示します。

@item
正の数: 指定されたデシ秒単位(0.1秒単位)の秒数後に提案されたコマンドを実行します。

@item
"immediate": 提案されたコマンドを即座に実行します。

@item
"prompt": コマンドを実行するための提案と確認のプロンプトを表示します。

@item
"never": 提案されたコマンドを実行も表示もしないでください。
@end itemize

@item  help.htmlPath 
HTMLドキュメントが存在するパスを指定します。 ファイルシステムのパスとURLがサポートされています。 ヘルプが「web」形式で表示される場合、HTMLページの前にこのパスが付けられます。 これはデフォルトでGitインストールのドキュメントパスになります。

@item  http.proxy 
通常は @samp{http_proxy} や @samp{https_proxy} や @samp{all_proxy} 環境変数を使用して構成されたHTTPプロキシをオーバーライドします(curl(1) 参照)。 curlが理解できる構文に加えて、ユーザー名はパスワードなしでプロキシ文字列を指定でき、その場合、gitは他の資格情報の場合と同じ方法でプロキシ文字列を取得しようとします。 詳細については、 gitcredentials(7) を参照してください。 構文は @samp{[protocol://][user[:password]@@]proxyhost[:port]} です。 これは、リモートごとにオーバーライドできます。 remote.<name>.proxy を参照してください

@item  http.proxyAuthMethod 
HTTPプロキシに対して認証する方法を設定します。 これは、構成されたプロキシ文字列にユーザー名の部分が含まれている場合にのみ有効になります(つまり、 @samp{user@@host} または @samp{user@@host:port} 形式)。 これは、リモートごとにオーバーライドできます。 @samp{remote.<name>.proxyAuthMethod} を参照してください。 どちらも @samp{GIT_HTTP_PROXY_AUTHMETHOD} 環境変数でオーバーライドできます。 可能な値は以下のとおりです:

@itemize 

@item
@samp{anyauth} - 適切な認証方法を自動的に選択します。 プロキシは、407ステータスコードとサポートされている認証方法を使用した1つ以上のProxy-authenticateヘッダーを使用して、認証されていない要求に応答すると想定されます。 これがデフォルトです。

@item
@samp{basic} - HTTPベーシック認証

@item
@samp{digest} - HTTPダイジェスト認証。これにより、パスワードがクリアテキストでプロキシに送信されるのを防ぎます

@item
@samp{negotiate} - GSSネゴシエーション認証(@samp{curl(1)} の @samp{--negotiate} オプションと比較してください)

@item
@samp{ntlm} - NTLM認証(@samp{curl(1)} の @samp{--ntlm} オプションと比較してください)
@end itemize

@item  http.proxySSLCert 
HTTPSプロキシでの認証に使用するクライアント証明書を格納するファイルのパス名。 @samp{GIT_PROXY_SSL_CERT} 環境変数でオーバーライドできます。

@item  http.proxySSLKey 
HTTPSプロキシでの認証に使用する秘密鍵を格納するファイルのパス名。 @samp{GIT_PROXY_SSL_KEY} 環境変数でオーバーライドできます。

@item  http.proxySSLCertPasswordProtected 
プロキシSSL証明書に対するGitのパスワードプロンプトを有効にします。 それ以外の場合、証明書または秘密鍵が暗号化されていると、OpenSSLはユーザーにプロンプトを表示します。 @samp{GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED} 環境変数で上書きできます。

@item  http.proxySSLCAInfo 
HTTPSプロキシを使用するときにプロキシを検証するために使用する必要がある証明書バンドルを含むファイルへのパス名。 @samp{GIT_PROXY_SSL_CAINFO} 環境変数でオーバーライドできます。

@item  http.emptyAuth 
ユーザー名またはパスワードを求めずに認証を試みます。 libcurlは通常、認証にユーザー名を必要とするため、これを使用して、URLにユーザー名を指定せずにGSS-Negotiate認証を試みることができます。

@item  http.delegation 
GSSAPI資格情報の委任を制御します。 バージョン7.21.7以降、libcurlでは委任がデフォルトで無効になっています。 ユーザー資格情報に関して、何を委任できるかをサーバーに通知するパラメーターを設定します。 GSS/kerberosで使用されます。 可能な値は以下のとおりです:

@itemize 

@item
@samp{none} - 委任を許可しないでください。

@item
@samp{policy} - OK-AS-DELEGATE フラグが Kerberos サービスチケットに設定されている場合にのみ委任します。これはレルムポリシー(realm policy)の問題です。

@item
@samp{always} - サーバーが無条件に委任できるようにします。
@end itemize

@item  http.extraHeader 
サーバーと通信するときに追加のHTTPヘッダーを渡します。 そのようなエントリが複数存在する場合は、それらすべてが追加のヘッダーとして追加されます。 システム構成から継承された設定をオーバーライドできるようにするには、値を空にすると、余分なヘッダーが空のリストにリセットされます。

@item  http.cookieFile 
以前に保存されたクッキー行を含むファイルのパス名。サーバーと一致する場合はGit httpセッションで使用する必要があります。 クッキーを読み取るファイルのファイル形式は、プレーンHTTPヘッダーまたは、Netscape/Mozilla クッキーファイル形式である必要があります(curl(1) 参照)。 注意: @samp{http.saveCookies} が設定されていない限り、 @samp{http.cookieFile} で指定されたファイルは入力としてのみ使用されることに注意してください。

@item  http.saveCookies 
設定されている場合、リクエスト中に受信したクッキーを http.cookieFile で指定されたファイルに保存します。 http.cookieFile が設定されていない場合は効果がありません。

@item  http.version 
サーバーと通信するときは、指定されたHTTPプロトコルバージョンを使用してください。 デフォルトを強制する場合、使用可能なデフォルトバージョンはlibcurlによって異なります。 現在、このオプションの可能な値は以下のとおりです:

@itemize 

@item
HTTP/2

@item
HTTP/1.1
@end itemize

@item  http.curloptResolve 
HTTP リクエストの送信時に libcurl が最初に使用するホスト名解決情報。 この情報は、以下のいずれかの形式である必要があります:

@itemize 

@item
[+]HOST:PORT:ADDRESS[,ADDRESS]

@item
-HOST:PORT
@end itemize

最初の形式は、指定された @samp{HOST:PORT} へのすべてのリクエストを、指定された @samp{ADDRESS} にリダイレクトします。 2 番目の形式は、その @samp{HOST:PORT} の組み合わせの以前の設定値をすべてクリアします。 システム構成から継承されたすべての設定を簡単に上書きできるようにするために、空の値はすべての解決情報を空のリストにリセットします。

@item  http.sslVersion 
デフォルトを強制する場合に、SSL接続をネゴシエートするときに使用するSSLバージョン。 使用可能なデフォルトバージョンは、libcurlがNSSまたはOpenSSLのどちらに対して構築されたか、および使用中の暗号ライブラリの特定の構成によって異なります。 内部的には、これにより @samp{CURLOPT_SSL_VERSION} オプションが設定されます。 このオプションの形式とサポートされているSSLバージョンの詳細については、libcurlのドキュメントを参照してください。 現在、このオプションの可能な値は以下のとおりです:

@itemize 

@item
sslv2

@item
sslv3

@item
tlsv1

@item
tlsv1.0

@item
tlsv1.1

@item
tlsv1.2

@item
tlsv1.3
@end itemize

@samp{GIT_SSL_VERSION} 環境変数で上書きできます。 gitにlibcurlのデフォルトのsslバージョンを使用させ、明示的なhttp.sslversionオプションを無視するには、 @samp{GIT_SSL_VERSION} を空の文字列に設定します。

@item  http.sslCipherList 
SSL接続をネゴシエートするときに使用するSSL暗号のリスト。 使用可能な暗号は、libcurlがNSSまたはOpenSSLのどちらに対して構築されたか、および使用中の暗号ライブラリの特定の構成によって異なります。 内部的には、これにより @samp{CURLOPT_SSL_CIPHER_LIST} オプションが設定されます。 このリストの形式の詳細については、libcurlのドキュメントを参照してください。

@samp{GIT_SSL_CIPHER_LIST} 環境変数で上書きできます。 gitにlibcurlのデフォルトの暗号リストを使用させ、明示的なhttp.sslCipherListオプションを無視するには、 @samp{GIT_SSL_CIPHER_LIST} を空の文字列に設定します。

@item  http.sslVerify 
HTTPSをフェッチまたはプッシュするときにSSL証明書を検証するかどうか。 デフォルトはtrueです。 @samp{GIT_SSL_NO_VERIFY} 環境変数で上書きできます。

@item  http.sslCert 
HTTPSをフェッチまたはプッシュするときのSSL証明書を含むファイル。 @samp{GIT_SSL_CERT} 環境変数で上書きできます。

@item  http.sslKey 
HTTPSをフェッチまたはプッシュするときのSSL秘密鍵を含むファイル。 @samp{GIT_SSL_KEY} 環境変数で上書きできます。

@item  http.sslCertPasswordProtected 
SSL証明書に対するGitのパスワードプロンプトを有効にします。 それ以外の場合、証明書または秘密鍵が暗号化されていると、OpenSSLはユーザーにプロンプトを表示します。 @samp{GIT_SSL_CERT_PASSWORD_PROTECTED} 環境変数で上書きできます。

@item  http.sslCAInfo 
HTTPSをフェッチまたはプッシュするときにピア(peer)を検証(verify)するための証明書を含むファイル。 @samp{GIT_SSL_CAINFO} 環境変数でオーバーライドできます。

@item  http.sslCAPath 
HTTPSをフェッチまたはプッシュするときにピア(peer)を検証(verify)するためのCA証明書を含むファイルを含むパス。 @samp{GIT_SSL_CAPATH} 環境変数で上書きできます。

@item  http.sslBackend 
使用するSSLバックエンドの名前(例: @samp{openssl} または @samp{schannel})。 cURLが実行時にSSLバックエンドを選択するためのサポートを欠いている場合、このオプションは無視されます。

@item  http.schannelCheckRevoke 
@samp{http.sslBackend} が @samp{schannel} に設定されている場合にcURLで証明書失効チェックを実施または無効にするために使用されます。 設定されていない場合、デフォルトは @samp{true} です。 Gitが一貫してエラーを出し、メッセージが証明書の失効ステータスの確認に関するものである場合にのみ、これを無効にする必要があります。 cURLが実行時に関連するSSLオプションを設定するためのサポートを欠いている場合、このオプションは無視されます。

@item  http.schannelUseSSLCAInfo 
cURL v7.60.0以降、セキュリティで保護されたチャネルのバックエンドは @samp{http.sslCAInfo} を介して提供される証明書バンドルを使用できますが、これによりWindows証明書ストアが上書きされます。 これはデフォルトでは望ましくないため、 @samp{http.schannelUseSSLCAInfo} がこの動作をオーバーライドしない限り、 @samp{schannel} バックエンドが @samp{http.sslBackend} を介して構成されている場合、Gitはデフォルトでそのバンドルを使用しないようにcURLに指示します。

@item  http.pinnedPubkey 
httpsサービスの公開鍵。 これは、PEMまたはDERでエンコードされた公開鍵ファイルのファイル名か、 @samp{sha256//} で始まり、その後にbase64でエンコードされた公開鍵のsha256ハッシュが続く文字列のいずれかです。 libcurlの @samp{CURLOPT_PINNEDPUBLICKEY} も参照してください。 このオプションが設定されているがcURLでサポートされていない場合、gitはエラーで終了します。

@item  http.sslTry 
通常のFTPプロトコルを介して接続する場合は、AUTH SSL/TLS と暗号化されたデータ転送を使用してみてください。 これは、FTPサーバーがセキュリティ上の理由でそれを必要とする場合、またはリモートFTPサーバーがそれをサポートする場合はいつでも安全に接続したい場合に必要になることがあります。 誤って構成されたサーバーで証明書検証エラーが発生する可能性があるため、デフォルトはfalseです。

@item  http.maxRequests 
並行して起動するHTTPリクエストの数。 @samp{GIT_HTTP_MAX_REQUESTS} 環境変数でオーバーライドできます。 デフォルトは 5 です。

@item  http.minSessions 
リクエスト間で保持されるcurlセッションの数(スロット全体でカウント)。 http_cleanup() が呼び出されるまで、curl_easy_cleanup()で終了することはありません。 USE_CURL_MULTIが定義されていない場合、この値の上限は1になります。 デフォルトは1です。

@item  http.postBuffer 
リモートシステムにデータをPOSTするときにスマートHTTPトランスポートによって使用されるバッファーの最大サイズ(バイト単位)。 このバッファサイズより大きいリクエストの場合、 HTTP/1.1 と Transfer-Encoding: チャンクが使用され、ローカルで大規模なパックファイルが作成されるのを防ぎます。 デフォルトは1MiBで、ほとんどのリクエストでは十分です。

この制限を引き上げることは、チャンク転送エンコーディングを無効にする場合にのみ有効であるため、リモートサーバーまたはプロキシが HTTP/1.0 のみをサポートするか、HTTP標準に準拠していない場合にのみ使用する必要があることに注意してください。 この制限を引き上げることは、一般に、ほとんどのプッシュの問題に対して効果的な解決策ではありませんが、小さなプッシュに対してもバッファー全体が割り当てられるため、メモリー消費を大幅に増やす可能性があります。

@item  http.lowSpeedLimit, http.lowSpeedTime 
If the HTTP transfer speed, in bytes per second, is less than @emph{http.lowSpeedLimit} for longer than @emph{http.lowSpeedTime} seconds, the transfer is aborted. Can be overridden by the @samp{GIT_HTTP_LOW_SPEED_LIMIT} and @samp{GIT_HTTP_LOW_SPEED_TIME} environment variables.

@item  http.noEPSV 
curlによるEPSV ftpコマンドの使用を無効にするブール値。 これは、EPSVモードをサポートしていない一部の「貧弱な」ftpサーバーで役立ちます。 @samp{GIT_CURL_FTP_NO_EPSV} 環境変数でオーバーライドできます。 デフォルトはfalseです(curlはEPSVを使用します)。

@item  http.userAgent 
HTTPサーバーに提示されるHTTP USER_AGENT文字列。 デフォルト値は、git/1.7.1などのクライアントGitのバージョンを表します。 このオプションを使用すると、この値をMozilla/4.0などのより一般的な値にオーバーライドできます。 これは、たとえば、HTTP接続を一連の一般的なUSER_AGENT文字列(ただし、 git/1.7.1 などは含まない、)に制限するファイアウォールを介して接続する場合に必要になることがあります。 @samp{GIT_HTTP_USER_AGENT} 環境変数で上書きできます。

@item  http.followRedirects 
gitがHTTPリダイレクトに従うべきかどうか。 @samp{true} に設定されている場合、gitは、検出したサーバーによって発行されたリダイレクトを透過的に追跡します。 @samp{false} に設定すると、gitはすべてのリダイレクトをエラーとして扱います。 @samp{initial} に設定されている場合、gitはリモートへの最初のリクエストに対してのみリダイレクトに従いますが、後続のフォローアップHTTPリクエストに対しては追跡しません。 gitはリダイレクトされたURLをフォローアップリクエストのベースとして使用するため、通常はこれで十分です。 デフォルトは @samp{initial} です。

@item  http.<url>.* 
上記の @samp{http.*} オプションはいずれも、一部のURLに選択的に適用できます。 構成キーがURLと一致するように、構成キーの各要素がURLの要素と以下の順序で比較されます:

@enumerate 

@item
スキーム(例: @samp{https://example.com/} の @samp{https} の部分)。 このフィールドは、構成キーとURLの間で正確に一致する必要があります。

@item
ホスト/ドメイン名(例: @samp{https://example.com/} の @samp{example.com} の部分)。 このフィールドは、構成キーとURLの間で一致する必要があります。 このレベルのすべてのサブドメインに一致するように、ホスト名の一部として @samp{*} を指定することができます。 たとえば、 @samp{https://*.example.com/} は @samp{https://foo.example.com/} と一致しますが、 @samp{https://foo.bar.example.com/} とは一致しません。

@item
ポート番号(例: @samp{http://example.com:8080/} の @samp{8080} の部分)。 このフィールドは、構成キーとURLの間で正確に一致する必要があります。 省略されたポート番号は、照合する前に、スキームの正しいデフォルトに自動的に変換されます。

@item
パス(例: @samp{https://example.com/repo.git} の @samp{repo.git} の部分)。 構成キーのパスフィールドは、URLのパスフィールドと正確に一致するか、スラッシュ(@samp{/})で区切られたパス要素のプレフィックスとして一致する必要があります。 これは、パス @samp{foo/} の設定キーがURLパス @samp{foo/bar} と一致することを意味します。 プレフィックスは、スラッシュ(@samp{/})境界でのみ一致できます。 長い一致が優先されます(したがって、パス @samp{foo/bar} の構成キーは、パス @samp{foo/} の構成キーよりもURLパス @samp{foo/bar} によく一致します)。

@item
ユーザー名(例: @samp{https://user@@example.com/repo.git} の @samp{user} の部分)。 構成キーにユーザー名がある場合は、URLのユーザー名と正確に一致する必要があります。 構成キーにユーザー名がない場合、その構成キーは任意のユーザー名(ユーザー名無しを含む)のURLと一致しますが、ユーザー名の構成キーよりも優先順位は低くなります。
@end enumerate

上記のリストは、優先順位の高い順に並べられています。 構成キーのパスに一致するURLは、そのユーザー名に一致するURLよりも優先されます。 例えば、URLが @samp{https://user@@example.com/foo/bar} の場合、 @samp{https://user@@example.com} の設定キーの一致よりも @samp{https://example.com/foo} の設定キーの一致が優先されます。

すべてのURLは、照合を試みる前に正規化されます(パスワード部分がURLに埋め込まれている場合、照合目的では常に無視されます)。これにより、スペルが異なる同等のURLが正しく照合されます。 環境変数の設定は、常に一致を上書きします。 照合されるURLは、Gitコマンドに直接指定されたURLです。 これは、リダイレクトの結果としてアクセスされたURLがマッチングに参加しないことを意味します。

@item  i18n.commitEncoding 
コミットメッセージの文字エンコーディングは保存されます。 Gitそれ自体は気にしませんが、この情報は必要です。 例えば、電子メールまたはgitkグラフィカル履歴ブラウザーからコミットをインポートする場合(そしておそらく将来の他の場所や他の磁器コマンドでも)です。例として linkgit：git-mailinfo[1] を参照してください。 デフォルトは @samp{utf-8} です。

@item  i18n.logOutputEncoding 
コミットメッセージの文字エンコーディングは、 @samp{git log} やその仲間を実行するときに変換されます。

@item  imap.folder 
メールをドロップするフォルダー。通常はドラフトフォルダーです。 例：「INBOX.Drafts」とか「INBOX/Drafts」とか「[Gmail]/Drafts」です。必須です。

@item  imap.tunnel 
サーバーへの直接ネットワーク接続を使用する代わりに、コマンドがパイプされるIMAPサーバーへのトンネルをセットアップするために使用されるコマンド。 imap.host が設定されていない場合に必須です。

@item  imap.host 
サーバーを識別するURL。 非セキュア接続には @samp{imap://} プレフィックスを使用し、セキュア接続には @samp{imaps://} プレフィックスを使用します。 imap.tunnel が設定されている場合は無視されますが、それ以外の場合は必須です。

@item  imap.user 
サーバーにログインするときに使用するユーザー名。

@item  imap.pass 
サーバーにログインするときに使用するパスワード。

@item  imap.port 
サーバー上で接続する整数のポート番号。 デフォルトは、 imap:// ホストの場合は143、 imaps:// ホストの場合は993です。 imap.tunnel が設定されている場合は無視されます。

@item  imap.sslverify 
SSL/TLS接続で使用されるサーバー証明書の検証を有効/無効にするブール値。デフォルトは @samp{true} です。 imap.tunnel が設定されている場合は無視されます。

@item  imap.preformattedHTML 
パッチを送信するときにhtmlエンコーディングの使用を有効/無効にするブール値。 htmlでエンコードされたパッチは <pre> で囲まれ、コンテンツタイプは text/html になります。皮肉なことに、このオプションを有効にすると、Thunderbirdはパッチを plane/text の format=fixed メールとして送信します。デフォルトは @samp{false} です。

@item  imap.authMethod 
IMAPサーバーでの認証の認証方法を指定します。GitがNO_CURLオプションを使用してビルドされた場合、curlバージョンが7.34.0より古い場合、またはgit-imap-sendを @samp{--no-curl} オプションを指定して実行している場合、サポートされるメソッドは @emph{CRAM-MD5} のみです。これが設定されていない場合、「git imap-send」は基本的なIMAPプレーンテキストLOGINコマンドを使用します。

@item  include.path 
@itemx  includeIf.<condition>.path 
他の構成ファイルをインクルードするための特別な変数。 git-config(1) ドキュメントの「CONFIGURATION FILE」セクション、特に「Includes」および「Conditional includes」サブセクションを参照してください。

@item  index.recordEndOfIndexEntries 
インデックスファイルに「End Of Index Entry」セクションを含めるかどうかを指定します。 これにより、マルチプロセッサマシンでのインデックスの読み込み時間が短縮されますが、2.20より前のバージョンのGitを使用してインデックスを読み取ると、「ignoring EOIE extension」というメッセージが表示されます。 index.threads が明示的に有効になっている場合はデフォルトで @samp{true} 、それ以外の場合は @samp{false} になります。

@item  index.recordOffsetTable 
インデックスファイルに「Index Entry Offset Table」セクションを含めるかどうかを指定します。 これにより、マルチプロセッサマシンでのインデックスの読み込み時間が短縮されますが、2.20より前のバージョンのGitを使用してインデックスを読み取ると、「ignoring IEOT extension」というメッセージが表示されます。 index.threadsが明示的に有効になっている場合はデフォルトで @samp{true} 、それ以外の場合は @samp{false} になります。

@item  index.sparse 
有効にすると、sparse-directory エントリを使用してインデックスを書き込みます。 @samp{core.sparseCheckout} と @samp{core.sparseCheckoutCone} の両方が有効になっていない限り、これは効果がありません。 デフォルトは @samp{false} です。

@item  index.threads 
インデックスをロードするときに生成するスレッドの数を指定します。 これは、マルチプロセッサマシンでのインデックスのロード時間を短縮することを目的としています。 0または @samp{true} を指定すると、GitはCPUの数を自動検出し、それに応じてスレッドの数を設定します。 1または @emph{false} を指定すると、マルチスレッドが無効になります。 デフォルトは @samp{true} です。

@item  index.version 
新しいインデックスファイルを初期化するバージョンを指定します。 これは既存のリポジトリには影響しません。 @samp{feature.manyFiles} が有効になっている場合、デフォルトは4です。

@item  index.skipHash 
When enabled, do not compute the trailing hash for the index file. This accelerates Git commands that manipulate the index, such as @samp{git add}, @samp{git commit}, or @samp{git status}. Instead of storing the checksum, write a trailing set of bytes with value zero, indicating that the computation was skipped.

If you enable @samp{index.skipHash}, then Git clients older than 2.13.0 will refuse to parse the index and Git clients older than 2.40.0 will report an error during @samp{git fsck}.

@item  init.templateDir 
テンプレートのコピー元のディレクトリを指定します。 (git-init(1) の「TEMPLATE DIRECTORY」セクションを参照してください。)

@item  init.defaultBranch 
デフォルトのブランチ名を上書きできます。例えば、新しいリポジトリを初期化するとき。

@item  instaweb.browser 
gitwebであなたの作業リポジトリをブラウズするために使用されるプログラムを指定します。 git-instaweb(1) を参照してください。

@item  instaweb.httpd 
あなたの作業リポジトリでgitwebを起動するためのHTTPデーモンコマンドライン。 git-instaweb(1) を参照してください。

@item  instaweb.local 
trueの場合、 git-instaweb(1) によって起動されたWebサーバーはローカルIP(local IP)(127.0.0.1)にバインドされます。

@item  instaweb.modulePath 
@samp{/usr/lib/apache2/modules} の代わりに使用する git-instaweb(1) のデフォルトのモジュールパス。httpdがApacheの場合にのみ使用されます。

@item  instaweb.port 
gitweb httpdをバインドするポート番号。 git-instaweb(1) を参照してください。

@item  interactive.singleKey 
対話コマンドでは、ユーザーが1つのキーで1文字の入力を提供できるようにします(つまり、Enterキーを押さずに)。 現在、これは git-add(1) と git-checkout(1) と git-restore(1) と git-commit(1) と git-reset(1) と git-stash(1) の @samp{--patch} モードで使用されています。 ポータブルキーストローク入力(portable keystroke input)が利用できない場合、この設定は黙って無視されることに注意してください。 Perlモジュール Term::ReadKey が必要です。

@item  interactive.diffFilter 
対話コマンド(@samp{git add --patch} など)が色付きのdiffを表示すると、gitはこの構成変数で定義されたシェルコマンドを介してdiffをパイプします。 コマンドは、元のdiffの行と1対1の対応を保持している場合、人間に読みやすいようにdiffをさらにマークアップできます。 デフォルトは無効(フィルタリングなし)です。

@item  log.abbrevCommit 
trueの場合、 linkgit:git-log [1] と git-show(1) と git-whatchanged(1) に @samp{--abbrev-commit} を想定させます。 このオプションは @samp{--no-abbrev-commit} で上書きできます。

@item  log.date 
@samp{log} コマンドのデフォルトの日時モードを設定します。 log.dateの値の設定は、 @samp{git log} の @samp{--date} オプションと同様です。 詳細については、 git-log(1) を参照してください。

形式が @samp{auto:foo} に設定されていて、ページャーが使用されている場合、形式 @samp{foo} が日付形式に使用されます。 それ以外の場合は、 @samp{default} が使用されます。

@item  log.decorate 
logコマンドで表示されるコミットのref名を出力します。 @samp{short} が指定されている場合、ref名の接頭辞 @samp{refs/heads/} と @samp{refs/tags/} と @samp{refs/remotes/} は出力されません。 @samp{full} が指定されている場合、完全なref名(接頭辞を含む)が出力されます。 @samp{auto} が指定されている場合、出力が端末に送られる場合、ref名は @samp{short} が指定されているかのように表示されます。それ以外の場合、ref名は表示されません。 これは、 @samp{git log} の @samp{--decorate} オプションと同じです。

@item  log.initialDecorationSet 
デフォルトでは、 @samp{git log} は特定の既知の ref 名前空間の装飾(decorations)のみを表示します。 @samp{all} が指定されている場合は、すべてのrefを装飾として表示します。

@item  log.excludeDecoration 
ログ装飾(log decorations)から指定されたパターンを除外します。 これは @samp{--decorate-refs-exclude} コマンドラインオプションに似ていますが、構成オプションは @samp{--decorate-refs} オプションで上書きできます。

@item  log.diffMerges 
Set diff format to be used when @samp{--diff-merges=on} is specified, see @samp{--diff-merges} in git-log(1) for details. Defaults to @samp{separate}.

@item  log.follow 
@samp{true} の場合、 @samp{git log} は、単一の<path>が指定されたときに @samp{--follow} オプションが使用されたかのように機能します。 これには @samp{--follow} と同じ制限があります。つまり、複数のファイルを追跡するために使用することはできず、非線形履歴ではうまく機能しません。

@item  log.graphColors 
@samp{git log --graph} で履歴線(history lines)を描画するために使用できる、コンマで区切られた色のリスト。

@item  log.showRoot 
trueの場合、最初のコミットは大きな作成イベントとして表示されます。 これは、空のツリーに対するdiffに相当します。 git-log(1) や git-whatchanged(1) などのツールは、通常はルートコミットを隠していますが、今後は表示されるようになります。 デフォルトでは True です。

@item  log.showSignature 
trueの場合、 git-log(1) と git-show(1) と git-whatchanged(1) に @samp{--show-signature} を想定させます。

@item  log.mailmap 
trueの場合、 git-log(1) と git-show(1) と git-whatchanged(1) で @samp{--use-mailmap} を想定させ、それ以外の場合は @samp{--no-use-mailmap} を想定させます。 デフォルトではtrueです。

@item  lsrefs.unborn 
@samp{advertise} (デフォルト)または @samp{allow} または @samp{ignore} の場合があります。 @samp{advertise`の場合、サーバーは `unborn} (gitprotocol-v2(5) 説明があります)を送信するクライアントに応答し、プロトコルv2機能の広告(advertise)中にこの機能のサポートを広告します。 @samp{allow} は @samp{advertise`と同一ですが、サーバーがこの機能のサポートを広告しない点が異なります。 これは、管理者が `allow} を構成し、遅れて @samp{advertise} を構成できるため、(たとえば、)アトミックに更新できない負荷分散サーバーに役立ちます。

@item  mailinfo.scissors 
trueの場合、 git-mailinfo(1) (それゆえ git-am(1) も)は、コマンドラインで @samp{--scissors} オプションが指定されているかのようにデフォルトで動作します。この機能がアクティブな場合、メッセージ本文から切り取り線(つまり、主に ">8" や "8<" や "-" で構成される)行とそれより前のすべてを削除します。

@item  mailmap.file 
拡張メールマップファイルの場所。リポジトリのルートにあるデフォルトのメールマップが最初にロードされ、次にこの変数が指すメールマップファイルがロードされます。メールマップファイルの場所は、リポジトリサブディレクトリ内、またはリポジトリの外部のどこかにあります。 git-shortlog(1) と git-blame(1) を参照してください。

@item  mailmap.blob 
@samp{mailmap.file} と同様ですが、値をリポジトリ内のブロブへの参照と見なします。 @samp{mailmap.file} と @samp{mailmap.blob} の両方が指定されている場合、両方が解析され、 @samp{mailmap.file} からのエントリが優先されます。この変数は、ベアリポジトリではデフォルトで @samp{HEAD:.mailmap} になります。非ベアリポジトリでは、デフォルトで空になります。

@item  maintenance.auto 
このブール構成オプションは、一部のコマンドが通常の作業を行った後に @samp{git maintenance run --auto} を実行するかどうかを制御します。 デフォルトはtrueです。

@item  maintenance.strategy 
この文字列設定オプションは、バックグラウンドメンテナンスのいくつかの推奨スケジュールの1つを指定する方法を提供します。 これは、 @samp{--task=<task>} 引数が指定されていない場合、 @samp{git maintenance run --schedule=X} コマンド中に実行されるタスクにのみ影響します。 さらに、 @samp{maintenance.<task>.schedule} 構成値が設定されている場合、 @samp{maintenance.strategy} によって提供される値の代わりにその値が使用されます。 戦略として指定可能な文字列は以下のとおりです:

@itemize 

@item
@samp{none}: このデフォルト設定は、どのスケジュールでもタスクが実行されないことを意味します。

@item
@samp{incremental}: この設定は、データを削除しない小さなメンテナンスアクティビティの実行に最適化されています。 これは @samp{gc} タスクをスケジュールしませんが、 @samp{prefetch} および @samp{commit-graph} タスクを1時間ごとに実行し、 @samp{loose-objects} および @samp{incremental-repack} タスクを毎日実行し、 @samp{pack-refs} タスクを毎週実行します。
@end itemize

@item  maintenance.<task>.enabled 
このブール構成オプションは、 @samp{git maintenance run} に @samp{--task} オプションが指定されていない場合に、 @samp{<task>} という名前のメンテナンスタスクを実行するかどうかを制御します。 @samp{--task} オプションが存在する場合、これらの構成値は無視されます。 デフォルトでは、 @samp{maintenance.gc.enabled} のみがtrueです。

@item  maintenance.<task>.schedule 
この設定オプションは、指定された @samp{<task>} が @samp{git maintenance run --schedule=<frequency>} コマンド中に実行されるかどうかを制御します。 値は、 "hourly", "daily", "weekly" のいずれかである必要があります。

@item  maintenance.commit-graph.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{commit-graph} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{commit-graph} タスクは`--auto` オプションで実行されません。負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、commit-graphファイルにない到達可能なコミットの数が @samp{maintenance.commit-graph.auto} の値以上であるときにコマンドを実行する必要があることを意味します。デフォルト値は100です。

@item  maintenance.loose-objects.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{loose-objects} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{loose-objects} タスクは @samp{--auto} オプションでは実行されません。 負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、緩いオブジェクト(loose objects)の数が @samp{maintenance.loose-objects.auto} の値以上であるときにコマンドを実行する必要があることを意味します。 デフォルト値は100です。

@item  maintenance.incremental-repack.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{incremental-repack} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{incremental-repack} タスクは @samp{--auto} オプションでは実行されません。 負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、multi-pack-indexにないpack-fileの数が @samp{maintenance.incremental-repack.auto} の値以上であるときにコマンドを実行する必要があることを意味します。 デフォルト値は10です。

@item  man.viewer 
ヘルプを @samp{man} 形式で表示するために使用できるプログラムを指定します。 git-help(1) を参照してください。

@item  man.<tool>.cmd 
指定されたmanビューア(<tool>)を呼び出すコマンドを指定します。指定されたコマンドは、引数として渡されたマニュアルページを使用してシェルで評価されます。(git-help(1) を参照してください。)

@item  man.<tool>.path 
@samp{man} 形式でヘルプを表示するために使用される可能性のある特定のツール(<tool>)のパスをオーバーライドします。 git-help(1) を参照してください。

@item  merge.conflictStyle 
マージ時に競合するハンクが作業ツリーファイルに書き出されるスタイルを指定します。 デフォルトは @samp{merge`です。これは、 `<<<<<<<} 競合マーカー、一方の側で行われた変更、 @samp{=======} マーカー、もう一方の側で行われた変更、そして @samp{>>>>>>>} マーカーというスタイルです。 別のスタイル「diff3」は、 @samp{|||||||} マーカーと元のテキストを @samp{=======} マーカーの前に追加します。 @samp{merge} スタイルは、元のテキストの除外と、行のサブセットが、両側で一致する場合に競合領域から引き抜かれるため、 @samp{diff3} よりも小さな競合領域を生成する傾向があります。 もう 1 つの代替スタイル @samp{zdiff3} は @samp{diff3} に似ていますが、 両側で一致する行が競合領域の開始または最後近くに現れる場合、競合領域から削除します。

@item  merge.defaultToUpstream 
コミット引数なしでmergeが呼び出された場合は、リモート追跡ブランチに格納されている最後に観測された値を使用して、現在のブランチ用に構成されたアップストリームブランチをマージします。 @samp{branch.<currentbranch>.remote} によって指定されたリモートのブランチに名前を付ける @samp{branch.<currentbranch>.merge} の値が参照され、次に、それらは @samp{remote.<remote>.fetch} を介して対応するリモート追跡ブランチにマッピングされ、そして、これらの追跡ブランチの先端がマージされます。 デフォルトはtrueです。

@item  merge.ff 
デフォルトでは、Gitは、現在のコミットの子孫であるコミットをマージするときに、追加のマージコミットを作成しません。 代わりに、現在のブランチの先端が早送り(fast-forward)されます。 @samp{false} に設定すると、この変数はGitにそのような場合に追加のマージコミットを作成するように指示します(コマンドラインから @samp{--no-ff} オプションを指定するのと同じです)。 @samp{only} に設定すると、そのような早送りマージのみが許可されます(コマンドラインから @samp{--ff-only} オプションを指定するのと同じです)。

@item  merge.verifySignatures 
trueの場合、これは @samp{--verify-signatures} コマンドラインオプションと同等です。 詳細については、 git-merge(1) を参照してください。

@item  merge.branchdesc 
ブランチ名に加えて、それらに関連付けられたブランチの説明テキストをログメッセージに入力します。デフォルトはfalseです。

@item  merge.log 
ブランチ名に加えて、マージされる実際のコミットからの最大「指定の数」の親コミットの1行説明をログメッセージに入力します。デフォルトはfalseで、trueは20の同義語です。

@item  merge.suppressDest 
統合ブランチの名前に一致するグロブをこの複数値の構成変数(multi-valued configuration variable)に追加することにより、これらの統合ブランチへのマージに対して計算されるデフォルトのマージメッセージは、タイトルから「into <branch name>」を省略します。

空の値を持つ要素を使用して、以前の構成エントリから蓄積されたグロブのリストをクリアできます。 @samp{merge.suppressDest} 変数が定義されていない場合、下位互換性のためにデフォルト値の @samp{master} が使用されます。

@item  merge.renameLimit 
マージ処理中に名前変更検出の網羅的な部分で考慮するファイルの数。 指定されない場合、デフォルトは diff.renameLimit の値です。 merge.renameLimit と diff.renameLimit の両方が指定されていない場合、現在のデフォルトは 7000 です。 この設定は、名前変更検出がオフの場合は効果がありません。

@item  merge.renames 
Gitが名前の変更を検出するかどうか。 「false」に設定すると、名前変更の検出が無効になります。 「true」に設定すると、基本的な名前変更の検出が有効になります。 デフォルトは diff.renames の値です。

@item  merge.directoryRenames 
Gitがディレクトリの名前変更を検出するかどうか。これは、履歴の一方の側でディレクトリが名前変更されたときに、もう一方の側で追加された新しいファイルがマージ時にどうなるのかに影響します。 merge.directoryRenames を @samp{false} に設定すると、ディレクトリの名前変更の検出は無効になります。つまり、そのような新しいファイルは古いディレクトリに残されます。 @samp{true} に設定すると、ディレクトリの名前変更検出が有効になり、そのような新しいファイルは新しいディレクトリに移動されることを意味します。 @samp{conflict} に設定すると、そのようなパスに対して競合が報告されます。 merge.renames が false の場合、merge.directoryRenames は無視され、false として扱われます。 デフォルトは @samp{conflict} です。

@item  merge.renormalize 
リポジトリ内のファイルの標準の表現が時間の経過とともに変更されたことをGitに伝えます(たとえば、以前はCRLF行末のレコードテキストファイルをコミットしていましたが、最近のファイルはLF行末を使用している)。 このようなリポジトリでは、Gitは、不必要な競合を減らすために、マージを実行する前に、コミットに記録されたデータを標準形式に変換できます。 詳細については、gitattributes(5) の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)のセクションを参照してください。

@item  merge.stat 
マージの最後にORIG_HEADとマージ結果の間のdiffstatを出力するかどうか。 デフォルトではtrue。

@item  merge.autoStash 
trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。 これは、ダーティ作業ツリーでマージを実行できることを意味します。 ただし、注意して使用してください。マージが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。 このオプションは、 git-merge(1)の @samp{--no-autostash} および @samp{--autostash} オプションでオーバーライドできます。 デフォルトはfalseです。

@item  merge.tool 
git-mergetool(1) が使用するマージツールを制御します。 以下のリストは、有効な組み込み値を示しています。その他の値はカスタムマージツールとして扱われ、対応する mergetool.<tool>.cmd 変数が定義されている必要があります。

@item  merge.guitool 
@samp{-g}/@samp{--gui} フラグが指定されている場合に、 git-mergetool(1) が使用するマージツールを制御します。以下のリストは、有効な組み込み値を示しています。 その他の値はカスタムマージツールとして扱われ、対応する mergetool.<guitool>.cmd 変数が定義されている必要があります。

@table @asis

@item  @samp{araxis} 
Use Araxis Merge (requires a graphical session)

@item  @samp{bc} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc3} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc4} 
Use Beyond Compare (requires a graphical session)

@item  @samp{codecompare} 
Use Code Compare (requires a graphical session)

@item  @samp{deltawalker} 
Use DeltaWalker (requires a graphical session)

@item  @samp{diffmerge} 
Use DiffMerge (requires a graphical session)

@item  @samp{diffuse} 
Use Diffuse (requires a graphical session)

@item  @samp{ecmerge} 
Use ECMerge (requires a graphical session)

@item  @samp{emerge} 
Use Emacs' Emerge

@item  @samp{examdiff} 
Use ExamDiff Pro (requires a graphical session)

@item  @samp{guiffy} 
Use Guiffy’s Diff Tool (requires a graphical session)

@item  @samp{gvimdiff} 
Use gVim (requires a graphical session) with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{gvimdiff1} 
Use gVim (requires a graphical session) with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{gvimdiff2} 
Use gVim (requires a graphical session) with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{gvimdiff3} 
Use gVim (requires a graphical session) where only the MERGED file is shown

@item  @samp{kdiff3} 
Use KDiff3 (requires a graphical session)

@item  @samp{meld} 
Use Meld (requires a graphical session) with optional @samp{auto merge} (see @samp{git help mergetool}'s @samp{CONFIGURATION} section)

@item  @samp{nvimdiff} 
Use Neovim with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{nvimdiff1} 
Use Neovim with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{nvimdiff2} 
Use Neovim with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{nvimdiff3} 
Use Neovim where only the MERGED file is shown

@item  @samp{opendiff} 
Use FileMerge (requires a graphical session)

@item  @samp{p4merge} 
Use HelixCore P4Merge (requires a graphical session)

@item  @samp{smerge} 
Use Sublime Merge (requires a graphical session)

@item  @samp{tkdiff} 
Use TkDiff (requires a graphical session)

@item  @samp{tortoisemerge} 
Use TortoiseMerge (requires a graphical session)

@item  @samp{vimdiff} 
Use Vim with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{vimdiff1} 
Use Vim with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{vimdiff2} 
Use Vim with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{vimdiff3} 
Use Vim where only the MERGED file is shown

@item  @samp{winmerge} 
Use WinMerge (requires a graphical session)

@item  @samp{xxdiff} 
Use xxdiff (requires a graphical session)
@end table

@item  merge.verbosity 
再帰的マージ戦略によって示される出力の量を制御します。 レベル0は、競合が検出された場合の最終エラーメッセージ以外は何も出力しません。 レベル1は競合のみを出力し、レベル2は競合とファイル変更を出力します。 レベル5以上はデバッグ情報を出力します。 デフォルトはレベル2です。 @samp{GIT_MERGE_VERBOSITY} 環境変数でオーバーライドできます。

@item  merge.<driver>.name 
カスタムの低レベルマージドライバーの人間が読める名前を定義します。 詳細については、 gitattributes(5) を参照してください。

@item  merge.<driver>.driver 
カスタムの低レベルのマージドライバーを実装するコマンドを定義します。 詳細については、 gitattributes(5) を参照してください。

@item  merge.<driver>.recursive 
共通の祖先間で内部マージを実行するときに使用される低レベルのマージドライバーに名前を付けます。 詳細については、 gitattributes(5) を参照してください。

@item  mergetool.<tool>.path 
指定のツール(<tool>)のパスを上書きします。 これは、ツールがPATH上にない場合に役立ちます。

@item  mergetool.<tool>.cmd 
指定のマージツール(<tool>)を呼び出すコマンドを指定します。指定されたコマンドは、次の変数を使用してシェルで評価されます: @samp{BASE} は、マージされるファイルの共通ベースを含む一時ファイルの名前です(使用可能な場合)。 @samp{LOCAL} は、現在のブランチのファイルの内容を含む一時ファイルの名前です。 @samp{REMOTE} は、マージされるブランチのファイルの内容を含む一時ファイルの名前です。 @samp{MERGED} は、マージツールが正常なマージの結果を書き込むファイルの名前が含まれています。

@item  mergetool.<tool>.hideResolved 
ユーザーが特定のツール(<tool>)のグローバルな @samp{mergetool.hideResolved} 値をオーバーライドできるようにします。 詳細については、 @samp{mergetool.hideResolved} を参照してください。

@item  mergetool.<tool>.trustExitCode 
カスタムマージコマンドの場合、マージコマンドの終了コードを使用してマージが成功したかどうかを判断できるかどうかを指定します。 これがtrueで無い場合、マージターゲットファイルのタイムスタンプがチェックされ、ファイルが更新されている場合はマージが成功したと見なされます。そうでない場合、ユーザーはマージの成功を示すように求められます。

@item  mergetool.meld.hasOutput 
古いバージョンの @samp{meld} は @samp{--output} オプションをサポートしていません。 Gitは、 @samp{meld --help} の出力を調べることで、 @samp{meld} が @samp{--output} をサポートしているかどうかを検出しようとします。 @samp{mergetool.meld.hasOutput} を設定すると、Gitはこれらのチェックをスキップし、代わりに設定された値を使用します。 @samp{mergetool.meld.hasOutput} を @samp{true} に設定すると、Gitは無条件に @samp{--output} オプションを使用するようになり、 @samp{false} は @samp{--output} の使用を回避します。

@item  mergetool.meld.useAutoMerge 
meld は @samp{--auto-merge} が指定されると、競合しないすべての部分を自動的にマージし、競合する部分を強調表示して、ユーザーの決定を待ちます。 @samp{mergetool.meld.useAutoMerge} を`true`に設定すると、Gitは @samp{--auto-merge} オプションを @samp{meld} で無条件に使用するようになります。 この値を @samp{auto} に設定すると、gitは @samp{--auto-merge} がサポートされているかどうかを検出し、使用可能な場合にのみ @samp{--auto-merge} を使用します。 @samp{false} の値はデフォルト値で、` --auto-merge` の使用を完全に回避します。

@item  mergetool.vimdiff.layout 
vimdiff バックエンドはこの変数を使用して、分割されたウィンドウがどのように見えるかを制御します。 マージ・ツールとして Neovim(@samp{nvim}) または gVim(@samp{gvim}) を使用している場合でも適用されます。 詳細については、git-mergetool(1) の「BACKEND SPECIFIC HINTS」セクションを参照してください。

@item  mergetool.hideResolved 
During a merge Git will automatically resolve as many conflicts as possible and write the @emph{MERGED} file containing conflict markers around any conflicts that it cannot resolve; @emph{LOCAL} and @emph{REMOTE} normally represent the versions of the file from before Git’s conflict resolution. This flag causes @emph{LOCAL} and @emph{REMOTE} to be overwritten so that only the unresolved conflicts are presented to the merge tool. Can be configured per-tool via the @samp{mergetool.<tool>.hideResolved} configuration variable. Defaults to @samp{false}.

@item  mergetool.keepBackup 
マージを実行した後、競合マーカーを含む元のファイルを、拡張子 @samp{.orig} のファイルとして保存できます。 この変数が @samp{false} に設定されている場合、このファイルは保存されません。 デフォルトは @samp{true} です(つまり、バックアップファイルを保持します)。

@item  mergetool.keepTemporaries 
カスタムマージツールを呼び出すとき、Gitは一時ファイルの組をツールに渡します。 ツールがエラーを返し、この変数が @samp{true} に設定されている場合、これらの一時ファイルは保持されます。それ以外の場合、ツールの終了後に削除されます。 デフォルトは @samp{false} です。

@item  mergetool.writeToTemp 
Gitは、デフォルトで、競合するファイルの一時的な 「BASE」バージョンと「LOCAL」バージョンと「REMOTE」バージョンをワークツリーに書き込みます。 @samp{true} に設定すると、Gitはこれらのファイルに一時ディレクトリを使用しようとします。 デフォルトは @samp{false} です。

@item  mergetool.prompt 
マージ解決プログラムを呼び出す前にプロンプトを表示します。

@item  mergetool.guiDefault 
Set @samp{true} to use the @samp{merge.guitool} by default (equivalent to specifying the @samp{--gui} argument), or @samp{auto} to select @samp{merge.guitool} or @samp{merge.tool} depending on the presence of a @samp{DISPLAY} environment variable value. The default is @samp{false}, where the @samp{--gui} argument must be provided explicitly for the @samp{merge.guitool} to be used.

@item  notes.mergeStrategy 
ノートの競合を解決するときにデフォルトで選択するマージ戦略。 @samp{manual} 、` ours`、 @samp{theirs}、` union` 、@samp{cat_sort_uniq} のいずれかである必要があります。 デフォルトは @samp{manual} です。 各戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

この設定は、 @samp{--strategy} オプションを git-notes(1) に渡すことでオーバーライドできます。

@item  notes.<name>.mergeStrategy 
@samp{refs/notes/<name>} にノートをマージするときに、どのマージ戦略を選択するか。 これは、より一般的な @samp{notes.mergeStrategy} をオーバーライドします。 利用可能な戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

@item  notes.displayRef 
@samp{git log} 系のコマンドでコミット・メッセージを表示する際に、 @samp{core.notesRef} や @samp{GIT_NOTES_REF} で設定したデフォルトに加えて、どのref (グロブ、または複数回指定されている場合は複数ref)からノートを読み込むかを指定します。

この設定は、 @samp{GIT_NOTES_DISPLAY_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

存在しないrefsに対しては警告が発行されますが、どのrefsにもマッチしないグロブは黙って無視されます。

この設定は、コマンドの @samp{git log} 系の @samp{--no-notes} オプション、またはこれらのコマンドで受け入れられる @samp{--notes=<ref>} オプションによって無効にすることができます。

@samp{core.notesRef} の有効な値(GIT_NOTES_REFによってオーバーライドされる可能性があります)も、表示されるrefのリストに暗黙的に追加されます。

@item  notes.rewrite.<command> 
<command> (現在は @samp{amend} または @samp{rebase})でコミットを書き換え、 そして、 この変数が @samp{false} に設定されている場合、git はノートを元のコミットから書き換えられたコミットにコピーしません。 デフォルトは @samp{true} です。 下記 @samp{notes.rewriteRef} も参照してください。

この設定は、 @samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

@item  notes.rewriteMode 
書き換え時にノートをコピーする場合(@samp{notes.rewrite.<command>} オプション参照)、ターゲットコミットにすでにノートがある場合の対処方法を決定します。 @samp{overwrite} 、 @samp{concatenate} 、 @samp{cat_sort_uniq} 、 @samp{ignore} のいずれかである必要があります。 デフォルトは @samp{concatenate} です。

この設定は、 @samp{GIT_NOTES_REWRITE_MODE} 環境変数でオーバーライドできます。

@item  notes.rewriteRef 
書き換え中にノートをコピーする場合は、ノートをコピーする(完全修飾された)refを指定します。 グロブと見なしたら、マッチするすべてのrefのノートがコピーされます。 この構成を複数回指定することもできます。

デフォルト値はありません。 ノートの書き換えを有効にするには、この変数を構成する必要があります。 デフォルトのコミットノートの書き換えを有効にするには、これを @samp{refs/notes/commits} に設定します。

@samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドできます。 その形式の詳細については、上記 @samp{notes.rewrite.<command>} を参照してください。

@item  pack.window 
コマンドラインでウィンドウサイズが指定されていない場合に git-pack-objects(1) によって使用されるウィンドウのサイズ。デフォルトは10です。

@item  pack.depth 
コマンドラインで最大深度が指定されていない場合に git-pack-objects(1) によって使用される最大デルタ深度。デフォルトは50です。最大値は4095です。

@item  pack.windowMemory 
コマンドラインで制限が指定されていない場合に、パックウィンドウメモリの git-pack-objects(1) の各スレッドで消費されるメモリの最大サイズ。値には、「k」または「m」または「g」の接尾辞を付けることができます。未構成のまま(または明示的に0に設定する)にした場合、制限はありません。

@item  pack.compression 
パックファイル内のオブジェクトの圧縮レベルを示す整数 -1〜9。-1はzlibのデフォルトです。0は圧縮がないことを意味し、1〜9はさまざまな速度とサイズのトレードオフであり、9が最も低速です。設定されていない場合のデフォルトは core.compression です。 core.compression も設定されていない場合、デフォルトは -1 になります。これは、「速度と圧縮の間のデフォルトの妥協点(現在はレベル6と同等)」であるzlibのデフォルトです。

注意: 圧縮レベルを変更しても、既存のすべてのオブジェクトが自動的に再圧縮されるわけではないことに注意してください。 @samp{-F} オプションを git-repack(1) に渡すことで、強制的に再圧縮できます。

@item  pack.allowPackReuse 
trueの場合、かつ、到達可能性ビットマップ(reachability bitmaps)が有効になっている場合、pack-objectsはビットマップ化されたパックファイルの一部をそのままで送信しようとします。これにより、フェッチを提供するためのメモリとCPUの使用量を減らすことができますが、送信するパックが少し大きくなる可能性があります。デフォルトはtrueです。

@item  pack.island 
デルタアイランド(delta islands)のセットを構成する拡張正規表現。詳細については、 git-pack-objects(1) の「DELTA ISLANDS」を参照してください。

@item  pack.islandCore 
オブジェクトを最初にパックする島名(island name)を指定します。 これにより、1つのパックの前に一種の疑似パックが作成されるため、指定の島のオブジェクトを、これらのオブジェクトを要求するユーザーに提供する必要のあるパックにコピーする速度が速くなることが期待されます。実際には、これは、指定された島が、リポジトリで最も一般的に複製される島に対応している可能性が高いことを意味します。 git-pack-objects(1) の「DELTA ISLANDS」も参照してください。

@item  pack.deltaCacheSize 
デルタをパックに書き出す前に、 git-pack-objects(1) でデルタをキャッシュするために使用されるバイト単位の最大メモリ。すべてのオブジェクトに最適なものが見つけたあとで、このキャッシュがあれば、最終的なデルタ結果を再計算する必要がないため、オブジェクトの書き込みフェーズを高速化できます。そのために使用されます。ただし、メモリが不足しているマシンで大規模なリポジトリを再パックして、特にこのキャッシュがシステムをスワップに追いやる場合、これによって悪影響を受ける可能性があります。値0は、制限がないことを意味します。このキャッシュを事実上無効にするために、最小サイズの1バイトを使用できます。デフォルトは256MiBです。

@item  pack.deltaCacheLimit 
git-pack-objects(1) でキャッシュされるデルタの最大サイズ。すべてのオブジェクトに最適なものが見つかった後、このキャッシュがあれば、最終的なデルタ結果を再計算する必要がないため、オブジェクトの書き込みフェーズを高速化します。そのために使用されます。デフォルトは1000です。最大値は65535です。

@item  pack.threads 
最適なデルタマッチングを検索するときに生成するスレッドの数を指定します。このためには git-pack-objects(1)をpthreadでコンパイルする必要があります。そうしないと、このオプションは無視され、警告が表示されます。 これは、マルチプロセッサマシンでのパッキング時間を短縮することを目的としています。ただし、デルタ検索ウィンドウに必要なメモリ量は、スレッド数で乗算されます。0を指定すると、GitはCPUの数を自動検出し、それに応じてスレッドの数を設定します。

@item  pack.indexVersion 
デフォルトのパックインデックスバージョンを指定します。有効な値は、1.5.2より前のバージョンで使用されていたレガシーパックインデックスの場合は1、4GBを超えるパックの機能と破損したパックの再パックに対する適切な保護を備えた新しいパックインデックスの場合は2です。バージョン2がデフォルトです。注意: 対応するパックが2GBを超える場合は常にバージョン2が適用され、この構成オプションは無視されることに注意してください。

バージョン2の @samp{*.idx} ファイルを理解しない古いGitを使用している場合は、 @samp{*.pack} ファイルと対応する @samp{*.idx} ファイルの両方を反対側からコピーする非ネイティブプロトコル(例:http)を介してクローンを作成またはフェッチすると、古いバージョンのGitではアクセスできないリポジトリが提供される場合があります。けれども、 @samp{*.pack} ファイルが2GBより小さい場合は、 *.pack に git-index-pack(1) を使用して、 @samp{*.idx} ファイルを再生成できます。

@item  pack.packSizeLimit 
パックの最大サイズ。この設定は、再パック時にファイルへパッキングするときのみ影響します。つまり、 git:// プロトコルは影響を受けません。 git-repack(1) の @samp{--max-pack-size} オプションでオーバーライドできます。この制限に達すると、複数のパックファイルが作成されます。

注意: このオプションが役立つことはめったになく、(Gitはパックにまたがるデルタを保存しないため、)ディスク上の合計サイズが大きくなり、実行時のパフォーマンスが低下する可能性があることに注意してください(複数のパック内のオブジェクトルックアップは単一のパックで行うよりも遅く、到達可能性ビットマップなどの最適化は複数パックに対応できません)。

(たとえば、ファイルシステムが大きいファイルをサポートしていないため、)あなたが小さいパックファイルを使用してGitをバリバリと使う必要がある場合、このオプションが役立かもしれません。ただし、限られたサイズをサポートするメディア(たとえば、リポジトリ全体を保存できないリムーバブルメディア)を介してパックファイルを送信することが目標である場合は、単一の大きなパックファイルを作成し、一般的なマルチボリュームアーカイブツール(例えば Unix @samp{split} )を使用して分割する方がよいでしょう。

許可される最小サイズは1MiBに制限されています。デフォルトの大きさは無制限です。 @samp{k} または @samp{m} または @samp{g} の一般的な単位接尾辞がサポートされています。

@item  pack.useBitmaps 
trueの場合、(たとえば、フェッチ作業中のサーバー側で、)gitはstdoutにパックするときに(可能な場合は、)パックビットマップを使用します。デフォルトはtrueです。パックビットマップをデバッグしている場合を除いて、通常、これをオフにする必要はありません。

@item  pack.useBitmapBoundaryTraversal 
When true, Git will use an experimental algorithm for computing reachability queries with bitmaps. Instead of building up complete bitmaps for all of the negated tips and then OR-ing them together, consider negated tips with existing bitmaps as additive (i.e. OR-ing them into the result if they exist, ignoring them otherwise), and build up a bitmap at the boundary instead.

When using this algorithm, Git may include too many objects as a result of not opening up trees belonging to certain UNINTERESTING commits. This inexactness matches the non-bitmap traversal algorithm.

In many cases, this can provide a speed-up over the exact algorithm, particularly when there is poor bitmap coverage of the negated side of the query.

@item  pack.useSparse 
trueの場合、 gitは @samp{git pack-objects} で @samp{--revs} オプションが存在する場合、デフォルトで @samp{--sparse} オプションを使用します。このアルゴリズムは、新しいオブジェクトを導入するパスに現れるツリーのみをウォークします。これは、小さな変更を送信するパックを計算するときに、パフォーマンスに大きなメリットをもたらす可能性があります。ただし、含まれているコミットに特定の種類の直接名前変更(direct renames)が含まれている場合は、パックファイルに追加のオブジェクトが追加される可能性があります。 デフォルトは @samp{true} です。

@item  pack.preferBitmapTips 
ビットマップを受け取るコミットを選択するときは、「選択ウィンドウ」(selection window)の他のコミットよりも、この構成の任意の値の接尾辞である参照の先端にあるコミットを優先します。

注意: この設定を @samp{refs/foo} に設定しても、 @samp{refs/foo/bar} と @samp{refs/foo/baz} の先端のコミットが必ずしも選択されるわけではないことに注意してください。 これは、可変長の一連のウィンドウ内からビットマップに対してコミットが選択されるためです。

この構成の任意の値の接尾辞である参照の先端にあるコミットがウィンドウに表示された場合、そのウィンドウ内の他のコミットよりも即座に優先されます。

@item  pack.writeBitmaps (非推奨) 
これは、 @samp{repack.writeBitmaps} の非推奨の同義語です。

@item  pack.writeBitmapHashCache 
trueの場合、gitはビットマップインデックスに @samp{hash cache} セクションを含めます(記述されている場合)。 このキャッシュは、gitのデルタヒューリスティックを供給するために使用でき、ビットマップオブジェクトと非ビットマップオブジェクト間のデルタを改善する可能性があります(たとえば、古いビットマップパックと最後のgc以降にプッシュされたオブジェクト間のフェッチを提供する場合)。欠点は、ディスクスペースのオブジェクトごとに4バイトを消費することです。 デフォルトはtrueです。

マルチパックの到達可能性ビットマップを書き込む場合、新しい名前ハッシュは計算されません。 代わりに、既存のビットマップに保存されている名前ハッシュは、新しいビットマップを書き込むときに適切な場所に移動(permute)させられます。

@item  pack.writeBitmapLookupTable 
true の場合、Git はビットマップ・インデックスに @samp{lookup table} (検出表)セクションを含めます (記述されている場合)。 この表(table)は、個々のビットマップの読み込みをできるだけ遅らせるために使用されます。 これは、比較的大きなビットマップ・インデックスを持つリポジトリで役立ちます。 デフォルトは false です。

@item  pack.readReverseIndex 
When true, git will read any .rev file(s) that may be available (see: gitformat-pack(5)). When false, the reverse index will be generated from scratch and stored in memory. Defaults to true.

@item  pack.writeReverseIndex 
When true, git will write a corresponding .rev file (see: gitformat-pack(5)) for each new packfile that it writes in all places except for git-fast-import(1) and in the bulk checkin mechanism. Defaults to true.

@item  pager.<cmd> 
値がブール値の場合、ttyへの書き込み時に特定のGitサブコマンドの出力のページ付けをオンまたはオフにします。それ以外の場合は、 @samp{pager.<cmd>} の値で指定されたページャーを使用してサブコマンドのページ付けをオンにします。コマンドラインで @samp{--paginate} または @samp{--no-pager} が指定されている場合、このオプションよりも優先されます。すべてのコマンドのページ付けを無効にするには、 @samp{core.pager} または @samp{GIT_PAGER} を @samp{cat} に設定します。

@item  pretty.<name> 
git-log(1)で 指定されている、 @samp{--pretty=} 書式文字列のエイリアス。ここで定義されたエイリアスは、組み込みのpretty書式と同じように使用できます。 たとえば、 @samp{git config pretty.changelog "format:* %H %s"} を実行すると、 @samp{git log --pretty=changelog} の呼び出しは @samp{git log "--pretty=format:* %H %s"} を実行するのと同じになります。注意: 組み込みフォーマットと同じ名前のエイリアスは黙って無視されることに注意してください。

@item  protocol.allow 
If set, provide a user defined default policy for all protocols which don’t explicitly have a policy (@samp{protocol.<name>.allow}). By default, if unset, known-safe protocols (http, https, git, ssh) have a default policy of @samp{always}, known-dangerous protocols (ext) have a default policy of @samp{never}, and all other protocols (including file) have a default policy of @samp{user}. Supported policies:

@itemize 

@item
@samp{always} - プロトコルは常に使用できます。

@item
@samp{never} - プロトコルを使用することはできません。

@item
@samp{user} - プロトコルは、 @samp{GIT_PROTOCOL_FROM_USER} が設定されていないか、値が @samp{1} の場合にのみ使用できます。このポリシーは、プロトコルをユーザーが直接使用できるようにしたいが、ユーザー入力なしの clone/fetch/push を実行するコマンドでは使用したくない場合(たとえば再帰的なsubmoduleの初期化の場合)、設定しなければなりません。
@end itemize

@item  protocol.<name>.allow 
clone/fetch/push コマンドでプロトコル @samp{<name>} が使用するポリシーを設定します。 使用可能なポリシーについては、上記の「protocol.allow」を参照してください。

現在gitで使用されているプロトコル名はイカのとおりです:

@itemize 

@item
@samp{file}: 任意のローカルファイルベースのパス( @samp{file://} URL または ローカルパス を含む)

@item
@samp{git}: 直接TCP接続(または構成されている場合はプロキシ)を介した匿名のgitプロトコル

@item
@samp{ssh}: sshプロトコルの上で動くgitプロトコル( @samp{host:path} 書式や @samp{ssh://} 等を含む)

@item
@samp{http}: httpプロトコルの上で動くgitプロトコル。「スマートhttp」と「ダムhttp」の両方です。両方を構成する場合は、個別に構成する必要があります。注意:これには @samp{https} は含まれないことに注意してください。

@item
外部ヘルパーはそれらのプロトコルによる名前が付けられます(たとえば、 @samp{hg} というプロトコルを指定したら @samp{git-remote-hg} ヘルパーを許可します)
@end itemize

@item  protocol.version 
設定されている場合、クライアントは指定されたプロトコルバージョンを使用してサーバーとの通信を試みます。サーバーがサポートしていない場合、通信はバージョン0にフォールバックします。設定されていない場合、デフォルトは「2」です。 サポートされているバージョンは以下です:

@itemize 

@item
@samp{0} - オリジナル・ワイヤー・プロトコル

@item
@samp{1} - サーバーからの初期応答にバージョン文字列が追加されたオリジナル・ワイヤー・プロトコル。

@item
@samp{2} - ワイヤー・プロトコル・バージョン 2。gitprotocol-v2(5) 参照。
@end itemize

@item  pull.ff 
デフォルトでは、Gitは、現在のコミットの子孫であるコミットをマージするときに、追加のマージコミットを作成しません。 代わりに、現在のブランチの先端が早送り(fast-forward)されます。 @samp{false} に設定すると、この変数はGitにそのような場合に追加のマージコミットを作成するように指示します(コマンドラインから @samp{--no-ff} オプションを指定するのと同じです)。 @samp{only} に設定すると、そのような早送り(fast-forward)マージのみが許可されます(コマンドラインから @samp{--ff-only} オプションを指定するのと同じです)。 この設定は、プル時に @samp{merge.ff} をオーバーライドします。

@item  pull.rebase 
trueの場合、 @samp{git pull} の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチをリベースします。 ブランチごとにこれを設定するには、 @samp{branch.<name>.rebase} を参照してください。

@samp{merges} (または単に @samp{m} )の場合、 @samp{--rebase-merges} オプションを @samp{git rebase} に渡して、ローカルマージコミットがリベースに含まれるようにします(詳細については、 git-rebase(1) を参照してください)。

値が @samp{interactive} (または単に @samp{i})の場合、リベースは対話モードで実行されます。

@strong{注意}: これはおそらく危険な操作です。
あなたが影響を理解していない限り、使用しないでください
(詳細については、 git-rebase(1) を参照してください)。

@item  pull.octopus 
複数のブランチを一度にプルするときに使用するデフォルトのマージ戦略。

@item  pull.twohead 
単一のブランチをプルするときに使用するデフォルトのマージ戦略。

@item  push.autoSetupRemote 
@samp{true} に設定すると、現在のブランチの上流追跡(upstream tracking)が存在しない場合、デフォルトのpushで @samp{--set-upstream} を想定します。 このオプションは、 push.default オプションの @samp{simple} や @samp{upstream} や @samp{current} で有効になります。 (@samp{push.default=current} の振る舞いのように、)デフォルトで新しいブランチをデフォルトのremoteにプッシュしたい場合に便利で、これは、あなたが上流追跡(upstream tracking)も設定したい場合にも便利です。 このオプションの恩恵を受ける可能性が最も高いワークフローは、すべてのブランチがremoteで同じ名前を持つことが期待される「単純な」中央ワークフローです。

@item  push.default 
(コマンドライン、構成、またはその他の場所で、)refspecが指定されていない場合に @samp{git push} が実行するアクションを定義します。 特定の作業フローに適するさまざまな値があります。 たとえば、純粋に中央のワークフロー(つまり、フェッチ元がプッシュ先と等しい)では、 @samp{upstream} がおそらく必要なものです。 可能な値は以下のとおりです:

@itemize 

@item
@samp{nothing} - refspecが指定されていない限り、何もプッシュ(エラー出力)しないでください。 これは主に、常に明示的にすることで間違いを避けたい人を対象としています。

@item
@samp{current} - 現在のブランチをプッシュして、受信側で同一の名前のブランチを更新します。 中央作業フローと非中央作業フローの両方で機能します。

@item
@samp{upstream} - 現在のブランチを、通常その変更が現在のブランチに統合されるブランチにプッシュバックします(これを @samp{@@@{upstream@}} と呼びます)。 このモードは、通常プルするのと同じリポジトリ(つまり中央ワークフロー)にプッシュする場合にのみ意味があります。

@item
@samp{tracking} - これは @samp{upstream} の非推奨の同義語です。

@item
@samp{simple} - リモートで同一の名前の現在のブランチをプッシュします。

あなたが一元化された作業フロー(あなたのプル元の同一のリポジトリにプッシュする、通常は @samp{origin} )で作業している場合は、あなたは同一の名前でアップストリームブランチを構成する必要があります。

このモードはGit2.0以降のデフォルトであり、初心者に適した最も安全なオプションです。

@item
@samp{matching} - 送信側受信側両方で同一の名前のすべてのブランチをプッシュします。 これにより、プッシュするリポジトリは、プッシュされるブランチのセットを記憶するようになります(たとえば、常に「maint」と「master」をプッシュし、他のブランチがない場合、プッシュするリポジトリには、これら2つのブランチがあり、ローカルの「maint」と「master」がそこにプッシュされます)。

このモードを効果的に使用するには、 @samp{git push} を実行する前に、あなたがプッシュしたい「すべてのブランチ」がプッシュされる準備ができていることを確認する必要があります。このモードの要点は、すべてのブランチを一度にプッシュできるようにすることです。通常、1つのブランチのみで作業を終了して結果をプッシュする場合、他のブランチは未完了ですので、このモードは適していません。 また、このモードは、共有中央リポジトリにプッシュするのには適していません。他の人がそこに新しいブランチを追加したり、コントロール外の既存のブランチの先端を更新したりする可能性があるためです。

これは以前はデフォルトでしたが、Git 2.0以降ではそうではありません(@samp{simple} が新しいデフォルトです)。
@end itemize

@item  push.followTags 
trueに設定されている場合、デフォルトで @samp{--follow-tags} オプションを有効にします。 @samp{--no-follow-tags} を指定することにより、プッシュ時にこの構成をオーバーライドできます。

@item  push.gpgSign 
ブール値、または文字列 @samp{if-asked} に設定できます。 true値を指定すると、 @samp{--signed} linkgit:git-push [1]に渡されたかのように、すべてのプッシュがGPG署名されます。 文字列 @samp{if-asked} を指定し、サーバーがサポートしている場合は、 @samp{--signed=if-asked} が @samp{git push} に渡されたかのように、プッシュで署名されます。 誤った値は、優先度の低い構成ファイルの値を上書きする可能性があります。 明示的なコマンドラインオプションは、常にこの設定オプションを上書きします。

@item  push.pushOption 
コマンドラインから @samp{--push-option=<option>} 引数が指定されていない場合、 @samp{git push} はこの変数の各<value> が @samp{--push-option=<value>} として指定されているかのように動作します。

これは複数値の変数であり、優先度の高い構成ファイル(リポジトリ内の @samp{.git/config} など)で空の値を使用して、優先度の低い構成ファイル(@samp{$HOME/.gitconfig} など)から継承された値をクリアできます。

@example
Example:

/etc/gitconfig
  push.pushoption = a
  push.pushoption = b

~/.gitconfig
  push.pushoption = c

repo/.git/config
  push.pushoption =
  push.pushoption = b

This will result in only b (a and c are cleared).
@end example


@item  push.recurseSubmodules 
May be "check", "on-demand", "only", or "no", with the same behavior as that of "push --recurse-submodules". If not set, @emph{no} is used by default, unless @emph{submodule.recurse} is set (in which case a @emph{true} value means @emph{on-demand}).

@item  push.useForceIfIncludes 
「true」に設定すると、コマンドラインで git-push(1) のオプションとして @samp{--force-if-includes} を指定するのと同じです。 プッシュ時に @samp{--no-force-if-includes} を追加すると、この構成設定が上書きされます。

@item  push.negotiate 
「true」に設定されている場合は、クライアントとサーバーが共通のコミットを見つけようとするネゴシエーションの段階で送信されるパックファイルのサイズを縮小してみます。 「false」の場合、Gitはサーバーのref広告のみに依存して、共通のコミットを検索します。

@item  push.useBitmaps 
@samp{false} に設定すると、 @samp{pack.useBitmaps} が @samp{true} であっても @samp{git push} のビットマップの使用が無効になり、他の git 操作でのビットマップの使用が妨げられません。 デフォルトは @samp{true} です。

@item  rebase.backend 
リベースに使用するデフォルトのバックエンド。 可能な選択肢は、「apply」または「merge」です。 将来、mergeバックエンドがapplyバックエンドの残りのすべての機能を取得した場合、この設定は使用されなくなる可能性があります。

@item  rebase.stat 
最後のリベース以降にアップストリームで変更されたもののdiffstatを表示するかどうか。デフォルトではFalseです。

@item  rebase.autoSquash 
trueに設定されている場合、デフォルトで @samp{--autosquash} オプションを有効にします。

@item  rebase.autoStash 
trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。これは、ダーティワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、 git-rebase(1) の @samp{--no-autostash} および @samp{--autostash} オプションでオーバーライドできます。 デフォルトはfalseです。

@item  rebase.updateRefs 
trueに設定されている場合、デフォルトで @samp{--update-refs} オプションを有効にします。

@item  rebase.missingCommitsCheck 
「warn」に設定すると、 @samp{git rebase -i} は、一部のコミットが削除された場合(たとえば、行が削除された場合)に警告を出力しますが、リベースは続行されます。 「error」に設定すると、前記の警告が出力され、リベースが停止(stop)します。 @samp{git rebase --edit-todo} を使用して、エラーを修正できます。 「ignore」に設定すると、チェックは行われません。 警告やエラーなしにコミットをドロップするには、todoリストの @samp{drop} コマンドを使用します。 デフォルトは「ignore」です。

@item  rebase.instructionFormat 
git-log(1) で指定されている、対話的リベース中にToDoリストに使用される書式文字列。書式では、自動的に長いコミットハッシュが書式の前に付加されます。

@item  rebase.abbreviateCommands 
trueに設定すると、 @samp{git rebase} はtodoリストで省略コマンド名を使用し、以下のようになります:

@example
        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        ...
@end example


上記は以下の省略形です:

@example
        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        ...
@end example


デフォルトではfalseです。

@item  rebase.rescheduleFailedExec 
失敗した @samp{exec} コマンドを自動的に再スケジュールします。 これは、対話モード (または @samp{--exec} オプションが指定されている場合)でのみ意味があります。これは @samp{--reschedule-failed-exec} オプションを指定するのと同じです。

@item  rebase.forkPoint 
falseに設定されている場合、デフォルトで @samp{--no-fork-point} オプションを設定します。

@item  rebase.rebaseMerges 
Whether and how to set the @samp{--rebase-merges} option by default. Can be @samp{rebase-cousins}, @samp{no-rebase-cousins}, or a boolean. Setting to true or to @samp{no-rebase-cousins} is equivalent to @samp{--rebase-merges=no-rebase-cousins}, setting to @samp{rebase-cousins} is equivalent to @samp{--rebase-merges=rebase-cousins}, and setting to false is equivalent to @samp{--no-rebase-merges}. Passing @samp{--rebase-merges} on the command line, with or without an argument, overrides any @samp{rebase.rebaseMerges} configuration.

@item  receive.advertiseAtomic 
デフォルトでは、git-receive-packはアトミックプッシュ機能(atomic push capability)をクライアントに公表(advertise)します。この機能を公表したくない場合は、この変数をfalseに設定してください。

@item  receive.advertisePushOptions 
trueに設定すると、git-receive-packはプッシュオプション機能(push options capability)をクライアントに公表(advertise)します。デフォルトではFalse。

@item  receive.autogc 
デフォルトでは、git-pushからデータを受信し、参照を更新した後、git-receive-packは @samp{git-gc --auto} を実行します。 この変数をfalseに設定することで停止できます。

@item  receive.certNonceSeed 
この変数を文字列に設定すると、 @samp{git receive-pack} は @samp{git push --signed} を受け入れ、その文字列を秘密鍵として使用してHMACによって保護された「nonce」を使用して検証します。

@item  receive.certNonceSlop 
@samp{git push --signed} が、同じリポジトリにサービスを提供するreceive-packによって発行された「nonce」を含むプッシュ証明書をこの数秒以内に送信した場合、証明書で見つかった「nonce」をフックのために @samp{GIT_PUSH_CERT_NONCE} にエクスポートします(receive-packが送信側に含めるように要求したものの代わりに)。 これにより、 @samp{pre-receive} と @samp{post-receive} でのチェックの記述が少し簡単になります。証明書を受け入れるかどうかを決定するために、nonce が何秒後に古くなるかを記録する環境変数 @samp{GIT_PUSH_CERT_NONCE_SLOP} をチェックする代わりに、 @samp{GIT_PUSH_CERT_NONCE_STATUS} が @samp{OK} であることだけをチェックすることができます。

@item  receive.fsckObjects 
trueに設定されている場合、git-receive-packは受信したすべてのオブジェクトをチェックします。 チェックされる内容については、 @samp{transfer.fsckObjects} を参照してください。デフォルトはfalseです。設定されていない場合は、代わりに @samp{transfer.fsckObjects} の値が使用されます。

@item  receive.fsck.<msg-id> 
@samp{fsck.<msg-id>} のように機能しますが、 linkgit: git-fsck[1] の代わりに git-receive-pack(1) によって使用されます。詳細については、 @samp{fsck.<msg-id>} の文書を参照してください。

@item  receive.fsck.skipList 
@samp{fsck.skipList} のように機能しますが、 git-fsck(1) の代わりに git-receive-pack(1) によって使用されます。詳細については、 @samp{fsck.skipList} の文書を参照してください。

@item  receive.keepAlive 
クライアントからパックを受信した後、パックの処理中に @samp{receive-pack} が出力を生成せず(@samp{--quiet} が指定されている場合)、一部のネットワークがTCP接続を切断する可能性があります。このオプションを設定すると、 @samp{receive-pack} はこのフェーズで @samp{receive.keepAlive} 秒の間データを送信しない場合、short keepalive packetを送信します。デフォルトは5秒です。キープアライブを完全に無効にするには、0に設定します。

@item  receive.unpackLimit 
プッシュで受信されるオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。ただし、受信したオブジェクトの数がこの制限以上の場合、受信したパックは、欠落しているデルタベースを追加した後、パックとして保存されます。プッシュからパックを保存すると、特に低速のファイルシステムで、プッシュ操作をより速く完了することができます。 設定されていない場合は、代わりに @samp{transfer.unpackLimit} の値が使用されます。

@item  receive.maxInputSize 
着信パックストリームのサイズがこの制限よりも大きい場合、パックファイルを受け入れる代わりに git-receive-pack がエラーになります。0に設定または設定されていない場合、サイズは無制限です。

@item  receive.denyDeletes 
trueに設定すると、git-receive-packはrefを削除するrefの更新を拒否します。これを使用して、プッシュによるそのような参照の削除を防ぎます。

@item  receive.denyDeleteCurrent 
trueに設定すると、git-receive-packは、非ベアリポジトリの現在チェックアウトされているブランチを削除するrefの更新を拒否します。

@item  receive.denyCurrentBranch 
trueまたは "refuse"(拒否)に設定すると、 git-receive-pack は、非ベアリポジトリの現在チェックアウトされているブランチへのrefの更新を拒否します。このようなプッシュは、HEADがインデックスおよび作業ツリーと同期しなくなるため、潜在的に危険です。"warn"(警告)に設定されている場合は、stderrへのそのようなプッシュの警告を出力しますが、プッシュを続行できるようにします。 falseまたは"ignore"(無視)に設定されている場合は、メッセージなしでそのようなプッシュを許可します。 デフォルトは"refuse"です。

別のオプションは"updateInstead"で、現在のブランチにプッシュすると作業ツリーが更新されます。このオプションは、インタラクティブsshを介して一方の側に簡単にアクセスできない場合に作業ディレクトリを同期することを目的としています(たとえば、ライブWebサイト。つまり作業ディレクトリがクリーンである必要があります)。 このモードは、VM内で開発して、さまざまなオペレーティングシステムでコードをテストおよび修正する場合にも役立ちます。

デフォルトでは、作業ツリーまたはインデックスにHEADとの違いがある場合、"updateInstead"はプッシュを拒否しますが、 @samp{push-to-checkout} フックを使用してこれをカスタマイズできます。 githooks(5) を参照してください。

@item  receive.denyNonFastForwards 
trueに設定すると、git-receive-packは、fast-forwardではないrefの更新を拒否します。これを使用して、プッシュが強制されている場合でも、プッシュによるそのような更新を防ぎます。この構成変数は、共有リポジトリを初期化するときに設定されます。

@item  receive.hideRefs 
この変数は @samp{transfer.hideRefs} と同じですが、 @samp{receive-pack} にのみ適用されます(したがって、プッシュには影響しますが、フェッチには影響しません)。 @samp{git push} によって非表示の参照を更新または削除しようとする試みは拒否されます。

@item  receive.procReceiveRefs 
これは、 @samp{receive-pack} のコマンドに一致する参照プレフィックスを定義する複数値の変数(multi-valued variable)です。プレフィックスに一致するコマンドは、内部の @samp{execute_commands} 関数ではなく、外部フック「proc-receive」によって実行されます。この変数が定義されていない場合、「proc-receive」フックは使用されず、すべてのコマンドは内部の @samp{execute_commands} 関数によって実行されます。

たとえば、この変数が "refs/for" に設定されている場合、 "refs/for/master" などの参照にプッシュしても "refs/for/master" という名前の参照は作成・更新されませんが、 "proc-receive" フックを実行すれば直接プルリクエストを作成・更新できるはずです。

オプションの修飾子を値の先頭に指定して、特定のアクション(作成(a)、変更(m)、削除(d))のコマンドをフィルター処理できます。 @samp{!} を修飾子に含めて、参照プレフィックスエントリを無効にすることができます。 例えば以下のようにできます:

@example
git config --system --add receive.procReceiveRefs ad:refs/heads
git config --system --add receive.procReceiveRefs !:refs/heads
@end example

@item  receive.updateServerInfo 
trueに設定すると、git-pushからデータを受信し、参照を更新した後、git-receive-packはgit-update-server-infoを実行します。

@item  receive.shallowUpdate 
trueに設定すると、新しい参照に新しいshallow rootsが必要になったときに .git/shallow を更新できます。それ以外の場合、それらの参照は拒否されます。

@item  remote.pushDefault 
デフォルトでプッシュするリモート。 すべてのブランチの @samp{branch.<name>.remote} をオーバーライドし、特定のブランチの @samp{branch.<name>.pushRemote} によってオーバーライドされます。

@item  remote.<name>.url 
リモートリポジトリのURL。 git-fetch(1) または git-push(1) を参照してください。

@item  remote.<name>.pushurl 
リモートリポジトリのプッシュURL。 git-push(1) を参照してください。

@item  remote.<name>.proxy 
curl(httpとhttpsとftp)を必要とするリモートの場合、そのリモートに使用するプロキシへのURL。 そのリモートのプロキシを無効にするには、空の文字列に設定します。

@item  remote.<name>.proxyAuthMethod 
curl(httpとhttpsとftp)を必要とするリモートの場合、使用中のプロキシ(おそらく @samp{remote.<name>.proxy} で設定)に対して認証するために使用するメソッド。 @samp{http.proxyAuthMethod} を参照してください。

@item  remote.<name>.fetch 
git-fetch(1) のデフォルトの「refspec」セット。 git-fetch(1) を参照してください。

@item  remote.<name>.push 
git-push(1) のデフォルトの「refspec」セット。 git-push(1) を参照してください。

@item  remote.<name>.mirror 
trueの場合、このリモートにプッシュすると、コマンドラインで @samp{--mirror} オプションが指定されたかのように自動的に振る舞います。

@item  remote.<name>.skipDefaultUpdate 
trueの場合、 git-fetch(1) または git-remote(1) の @samp{update} サブコマンドを使用して更新すると、このリモートはデフォルトでスキップされます。

@item  remote.<name>.skipFetchAll 
trueの場合、 git-fetch(1) または git-remote(1) の @samp{update} サブコマンドを使用して更新すると、このリモートはデフォルトでスキップされます。

@item  remote.<name>.receivepack 
プッシュ時にリモート側で実行するデフォルトのプログラム。 git-push(1) のオプション @samp{--receive-pack} を参照してください。

@item  remote.<name>.uploadpack 
フェッチ時にリモート側で実行するデフォルトのプログラム。 git-fetch-pack(1) のオプション @samp{--upload-pack} を参照してください。

@item  remote.<name>.tagOpt 
この値を @samp{--no-tags} に設定すると、リモート<name>からフェッチするときの自動タグ追跡が無効になります。 @samp{--tags} に設定すると、リモートブランチヘッドから到達できない場合でも、リモート<name>からすべてのタグがフェッチされます。 これらのフラグを直接 git-fetch(1) に渡すと、この設定を上書きできます。 git-fetch(1) のオプション @samp{--tags} および @samp{--no-tags} を参照してください。

@item  remote.<name>.vcs 
これを値 <vcs> と設定すると、Gitは git-remote-<vcs> ヘルパーを使用してリモートと対話します。

@item  remote.<name>.prune 
trueに設定した時は、デフォルトでこのリモートからフェッチすると、(コマンドラインで @samp{--prune} オプションが指定されているかのように、)リモートに存在しなくなったリモート追跡参照も削除されます。 @samp{fetch.prune} 設定が存在する場合、それをオーバーライドします。

@item  remote.<name>.pruneTags 
trueに設定した時、デフォルトでこのリモートからフェッチすると、一般に刈り込み(pruning)が @samp{remote.<name>.prune} または @samp{fetch.prune} または @samp{--prune} を介して、アクティブ化されている場合、リモートに存在しなくなったローカルタグも削除されます。 @samp{fetch.pruneTags} 設定存在する場合それをオーバーライドします。

@samp{remote.<name>.prune} および git-fetch(1) の「PRUNING」セクションも参照してください。

@item  remote.<name>.promisor 
trueに設定すると、このリモートはプロミザー(promisor)オブジェクトをフェッチするために使用されます。

@item  remote.<name>.partialclonefilter 
このプロミサー・リモートからフェッチするときに適用されるフィルター。 この値を変更またはクリアした場合、その後のコミットのフェッチにのみ影響します。 ローカル・オブジェクト・データベースに既に存在するコミットの関連オブジェクトをフェッチするには、 git-fetch(1) の @samp{--refetch} オプションを使用します。

@item  remotes.<group> 
@samp{git remote update <group>} によってフェッチされるremoteのリスト。 git-remote(1) を参照してください。

@item  repack.useDeltaBaseOffset 
デフォルトでは、 git-repack(1) はデルタベースオフセットを使用するパックを作成します。 あなたのリポジトリを、バージョン1.4.4より古いGitと直接、またはhttpなどのバカ(dumb)プロトコルを介して共有する必要がある場合は、このオプションを @samp{false} に設定して再パックする必要があります。 ネイティブプロトコルを介した古いバージョンのGitからのアクセスは、このオプションの影響を受けません。

@item  repack.packKeptObjects 
trueに設定すると、 @samp{git repack} が @samp{--pack-kept-objects} が渡されたかのように動作します。 詳細については、 git-repack(1) を参照してください。 デフォルトは通常 @samp{false} ですが、ビットマップインデックスが(@samp{--write-bitmap-index} または @samp{repack.writeBitmaps} のいずれかを介して)書き込まれている場合は @samp{true} です。

@item  repack.useDeltaIslands 
trueに設定すると、 @samp{git repack} が @samp{--delta-islands} が渡されたかのように動作します。 デフォルトは @samp{false} です。

@item  repack.writeBitmaps 
trueの場合、gitはすべてのオブジェクトをディスクにパックするときにビットマップインデックスを書き込みます(たとえば、 @samp{git repack -a} が実行される場合)。 このインデックスは、クローンとフェッチ用に作成された後続のパックの「オブジェクトのカウント」フェーズを高速化できますが、ディスクスペースと最初の再パックに余分な時間がかかります。 複数のパックファイルが作成されている場合、これは効果がありません。 ベア(bare)リポジトリではデフォルトでtrueになり、それ以外の場合はfalseになります。

@item  repack.updateServerInfo 
false に設定すると、git-repack(1) は git-update-server-info(1) を実行しません。 デフォルトは true です。 git-repack(1) の @samp{-n} オプションで true の場合、オーバーライドできます。

@item  repack.cruftWindow 
@itemx  repack.cruftWindowMemory 
@itemx  repack.cruftDepth 
@itemx  repack.cruftThreads 
クラフト・パック(cruft pack)を生成するときに git-pack-objects(1) が使用するパラメータで、これらのパラメータはコマンドラインから与えることはできません。デフォルトと意味については、 @samp{pack.*} 設定変数の対応する名前のを参照してください。

@item  rerere.autoUpdate 
trueに設定すると、 @samp{git-rerere} は、以前に記録された解決策を使用して競合をクリーンに解決した後、結果のコンテンツでインデックスを更新します。 デフォルトはfalseです。

@item  rerere.enabled 
解決された競合の記録をアクティブにして、同じ競合ハンクが再度発生した場合に自動的に解決できるようにします。 デフォルトでは、 @samp{$GIT_DIR} の下に @samp{rr-cache} ディレクトリがある(例えば @samp{rerere} が以前にリポジトリで使用されていた)場合、 git-rerere(1) が有効になります。

@item  revert.reference 
この変数を true に設定すると、 @samp{git revert} は @samp{--reference} オプションが指定されているかのように振る舞います。

@item  safe.bareRepository 
Git が動作するベア(bare)・リポジトリを指定します。 現在サポートされている値は以下のとおりです:

@itemize 

@item
@samp{all}: Git はすべてのベア(bare)・リポジトリで動作します。 これがデフォルトです。

@item
@samp{explicit}: Git は、最上位の @samp{--git-dir} コマンドライン・オプション、 または @samp{GIT_DIR} 環境変数(git(1) を参照)で指定されたベア・リポジトリでのみ動作します。

あなたのワークフローでベア・リポジトリを使用しない場合は、グローバル構成で @samp{safe.bareRepository} を @samp{explicit} に設定すると効果的です。 これにより、ベア・リポジトリを含むリポジトリのクローンを作成し、そのディレクトリ内で Git コマンドを実行する攻撃から保護されます。

この構成設定は、保護された構成(protected configuration)でのみ尊重されます(@ref{SCOPES} 参照)。 これにより、信頼されていないリポジトリ(untrusted repository)がこの値を改ざんするのを防ぎます。
@end itemize

@item  safe.directory 
これらの構成(config)エントリは、現在のユーザー以外の誰かが所有していても安全と見なされる Git 追跡ディレクトリを指定します。 デフォルトでは、Git は他の誰かが所有するリポジトリの Git 構成(config)をパースすることさえ拒否し、 そのフックを実行に関しては言うまでもありません。 この構成設定により、 ユーザーは例外を指定できます。 例えば、意図的に共有するリポジトリ用です (git-init(1) の @samp{--shared} オプションを参照)。

これは複数の値(multi-valued)を持つ設定です。つまり、 @samp{git config --add} を使用して複数のディレクトリを追加できます。 (たとえば、システム構成で指定されたそのようなディレクトリを上書きするため、)安全なディレクトリのリストをリセットするには、空の値を持つ @samp{safe.directory} エントリを追加します。

この構成設定は、保護された構成(protected configuration)でのみ尊重されます(@ref{SCOPES} 参照)。 これにより、信頼されていないリポジトリ(untrusted repository)がこの値を改ざんするのを防ぎます。

この設定の値は補完(interpolated)されます。つまり、 @samp{~/<path>} はホーム・ディレクトリからの相対パスに展開され、@samp{%(prefix)/<path>} は Git コマンドの (実行時) プレフィックスからの相対パスに展開されます。

このセキュリティ・チェックを完全にオプトアウトするには、 @samp{safe.directory} を文字列 @samp{*} に設定します。 これにより、すべてのリポジトリを、それらのディレクトリが @samp{safe.directory} リストにリストされているかのように扱うことができます。 システム構成で @samp{safe.directory=*} が設定されていて、この保護を再度有効にしたい場合は、安全と見なすリポジトリをリストする前に、空の値でリストを初期化してください。

説明したように、Git はデフォルトで、自分自身 (Git を実行しているユーザー) が所有するリポジトリにのみアクセスできます。 ただし、sudo を提供する非 Windows プラットフォームで Git が「root」として実行されている場合、git は、sudo が作成する SUDO_UID 環境変数をチェックし、「root」からの ID に加えて、その値として記録された uid へのアクセスを許可します。 これは、インストール中に共通のシーケンス @samp{make && sudo make install} を実行しやすくするためです。 「sudo」の下で実行される git プロセスは「root」として実行されますが、「sudo」コマンドは環境変数をエクスポートして、元のユーザーの ID を記録します。 それが望ましくなく、代わりに root が所有するリポジトリのみを git に信頼させたい場合は、git を呼び出す前に root の環境から @samp{SUDO_UID} 変数を削除できます。

@item  sendemail.identity 
構成ID。 指定すると、 @samp{sendemail.<identity>} サブセクションの値が @samp{sendemail} セクションの値よりも優先されます。 デフォルトのIDは、 `sendemail.identity`の値です。

@item  sendemail.smtpEncryption 
説明については、 git-send-email(1) を参照してください。 注意: この設定は @samp{identity} メカニズムの対象ではないことに注意してください。

@item  sendemail.smtpsslcertpath 
ca-certificatesへのパス(ディレクトリまたは単一ファイルのどちらか)。 証明書の検証を無効にするには、空の文字列に設定します。

@item  sendemail.<identity>.* 
以下の @samp{sendemail.*} パラメータのID固有のバージョン。コマンドラインまたは @samp{sendemail.identity} のいずれかを使用して、このIDが選択された場合のパラメータよりも優先されます。

@item  sendemail.multiEdit 
true (デフォルト) の場合、編集する必要があるファイルを編集するために単一のエディター・インスタンスが生成されます(@samp{--annotate} が使用されている場合はパッチ、 @samp{--compose} が使用されている場合は要約)。 false の場合、ファイルは次々に編集され、そのたびに新しいエディター・インスタンスが生成されます。

@item  sendemail.confirm 
送信前に確認するかどうかのデフォルトを設定します。 @samp{always} または @samp{never} または @samp{cc} または @samp{compose} または @samp{auto} のいずれかでなければなりません。 これらの値の意味については、 git-send-email(1) ドキュメントの @samp{--confirm} を参照してください。

@item  sendemail.aliasesFile 
長い電子メール・アドレスのタイピングを回避するには、1 つまたは複数の電子メール・エイリアス・ファイルを指定します。 @samp{sendemail.aliasFileType} も指定する必要があります。

@item  sendemail.aliasFileType 
@samp{sendemail.aliasesFile} で指定されたファイルの形式。 @samp{mutt}, @samp{mailrc}, @samp{pine}, @samp{elm}, @samp{gnus}, @samp{sendmail} のいずれかでなければなりません。

各形式のエイリアス・ファイルがどのようなものかは、同名の電子メール・プログラムのドキュメントに記載されています。 標準フォーマットとの相違点と制限事項は以下のとおりです:

@table @asis

@item  sendmail 
@itemize 

@item
引用エイリアス(quoted aliases)と引用アドレス(quoted addresses)はサポートされていません。 @samp{"} 記号を含む行は無視されます。

@item
ファイル(@samp{/path/name})またはパイプ(@samp{|command})へのリダイレクトはサポートされていません。

@item
ファイル・インクルード(@samp{:include: /path/name})はサポートされていません。

@item
明示的にサポートされていない構造(constructs)、およびパーサーによって認識されないその他の行については、警告が標準エラー出力に出力されます。
@end itemize
@end table

@item  sendemail.annotate 
@itemx  sendemail.bcc 
@itemx  sendemail.cc 
@itemx  sendemail.ccCmd 
@itemx  sendemail.chainReplyTo 
@itemx  sendemail.envelopeSender 
@itemx  sendemail.from 
@itemx  sendemail.headerCmd 
@itemx  sendemail.signedoffbycc 
@itemx  sendemail.smtpPass 
@itemx  sendemail.suppresscc 
@itemx  sendemail.suppressFrom 
@itemx  sendemail.to 
@itemx  sendemail.tocmd 
@itemx  sendemail.smtpDomain 
@itemx  sendemail.smtpServer 
@itemx  sendemail.smtpServerPort 
@itemx  sendemail.smtpServerOption 
@itemx  sendemail.smtpUser 
@itemx  sendemail.thread 
@itemx  sendemail.transferEncoding 
@itemx  sendemail.validate 
@itemx  sendemail.xmailer 
これらの構成変数はすべて、git-send-email(1) コマンドライン・オプションのデフォルトを提供します。 詳細については、そのドキュメントを参照してください。

@item  sendemail.signedoffcc (非推奨) 
@samp{sendemail.signedoffbycc} の非推奨のエイリアス。

@item  sendemail.smtpBatchSize 
接続ごとに送信されるメッセージの数。その後、再ログインが発生します。 値が0または未定義の場合、すべてのメッセージを1つの接続で送信します。 git-send-email(1) の @samp{--batch-size} オプションも参照してください。

@item  sendemail.smtpReloginDelay 
SMTPサーバーに再接続する前に指定の秒数待機します。 git-send-email(1)の @samp{--relogin-delay} オプションも参照してください。

@item  sendemail.forbidSendmailVariables 
一般的な設定ミスを回避するために、 git-send-email(1) は、 @samp{sendmail} の設定オプションが存在する場合、警告とともに中止します。 チェックをバイパスするには、この変数を設定します。

@item  sequence.editor 
リベース命令ファイル(rebase instruction file)を編集するために @samp{git rebase -i} によって使用されるテキストエディタ。この値は、使用時にシェルによって解釈されることを意図しています。 これは、 @samp{GIT_SEQUENCE_EDITOR} 環境変数によってオーバーライドできます。構成されていない場合は、代わりにデフォルトのコミットメッセージエディタが使用されます。

@item  showBranch.default 
git-show-branch(1) のデフォルトのブランチセット。 git-show-branch(1) を参照してください。

@item  sparse.expectFilesOutsideOfPatterns 
通常、スパース・チェックアウトでは、どのスパース・パターンとも一致しないファイルは、インデックスの SKIP_WORKTREE ビットでマークされ、作業ツリーから欠落します。 したがって、Git は通常、期待に反して SKIP_WORKTREE ビットを持つファイルが実際に作業ツリーに存在するかどうかを確認します。 Git がいずれかを見つけた場合、関連する SKIP_WORKTREE ビットをクリアすることにより、それらのパスが存在するものとしてマークします。 このオプションを使用して、そのような存在にもかかわらずスキップされたファイルが予期できることを Git に伝え、それらのチェックを停止することができます。

デフォルトは @samp{false} です。これにより、Git はインデックス内のファイルのリストと同期が取れなくなった作業ツリーから自動的に回復(recover)できます。

何らかの外部要因で、作業ツリーファイルの存在とスパース・パターンの間の一貫性を維持するための責任をGitに負わせなくていい場合、これを @samp{true} にセットしてください。 例えば、アクセス・パターンに基づいて作業ツリーとスパース・パターンを最新に保つための堅牢なメカニズムを持つGit認識仮想ファイルシステムを持っている場合です。

この設定にかかわらず、Gitはスパース・チェックアウトが有効になっていない限り、存在するにも関わらずスキップ(present-despite-skip)されたファイルをチェックしません。したがって、このオプションは @samp{core.sparseCheckout} が @samp{true} でない限り何の効果も持ちません。

@item  splitIndex.maxPercentChange 
分割インデックス機能を使用する場合、これは、新しい共有インデックスが書き込まれる前の、分割インデックスと共有インデックスの両方のエントリの総数と比較した、分割インデックスに含めることができるエントリの割合を指定します。 値は0〜100の間である必要があります。 値が0の場合、新しい共有インデックスが常に書き込まれ、100の場合、新しい共有インデックスが書き込まれることはありません。 デフォルトの値は20であるため、分割インデックスのエントリ数がエントリの総数の20%を超える場合は、新しい共有インデックスが書き込まれます。 git-update-index(1) を参照してください。

@item  splitIndex.sharedIndexExpire 
分割インデックス機能を使用すると、この変数が指定する時間以降に変更されなかった共有インデックスファイルは、新しい共有インデックスファイルが作成されるときに削除されます。 値 @samp{now} はすべてのエントリをすぐに期限切れにし、 @samp{never} は期限切れを完全に抑制します。 デフォルト値は @samp{2.weeks.ago} です。 共有インデックスファイルは、それに基づいて新しい分割インデックスファイルが作成されるか、そこから読み取られるたびに、(有効期限について)変更されたと見なされることに注意してください。 git-update-index(1) を参照してください。

@item  ssh.variant 
デフォルトでは、Gitは設定されたSSHコマンドのベース名(環境変数 @samp{GIT_SSH} または環境変数 @samp{GIT_SSH_COMMAND} または構成設定 @samp{core.sshCommand} を使用して設定)に基づいて使用するコマンドライン引数を決定します。ベース名が認識されない場合、Gitは最初に @samp{-G} (print configuration)オプションを使用して構成済みのSSHコマンドを呼び出し、その後、(成功した場合、)OpenSSHオプションを使用するか、(失敗した場合、)hostおよびremoteコマンド以外のオプションを使用しないことで、OpenSSHオプションのサポートを検出しようとします。

構成変数 @samp{ssh.variant} は、この検出をオーバーライドするように設定できます。有効な値は、 @samp{ssh} (OpenSSHオプションを使用する場合)、 @samp{plink} 、 @samp{putty} 、 @samp{tortoiseplink} 、 @samp{simple} (hostおよびremoteコマンド以外のオプションを持っていません)、です。 デフォルトの自動検出は、値 @samp{auto} を使用して明示的に要求できます。また、これ以外の値は @samp{ssh} として扱われます。この設定は、環境変数 @samp{GIT_SSH_VARIANT} を介してオーバーライドすることもできます。

各派生で使用されている現在のコマンドラインパラメータは以下のとおりです:

@itemize 

@item
@samp{ssh} - [-p port] [-4] [-6] [-o option] [username@@]host command

@item
@samp{simple} - [username@@]host command

@item
@samp{plink} or @samp{putty} - [-P port] [-4] [-6] [username@@]host command

@item
@samp{tortoiseplink} - [-P port] [-4] [-6] -batch [username@@]host command
@end itemize

@samp{simple} 派生を除き、コマンドラインパラメータはgitが新しい機能を取得するにつれて変更される可能性があります。

@item  status.relativePaths 
デフォルトでは、 git-status(1) は現在のディレクトリからの相対パスを表示します。 この変数を @samp{false} に設定すると、リポジトリルートを基準にしたパスが表示されます(これはv1.5.4より前のGitのデフォルトでした)。

@item  status.short 
git-status(1) でデフォルトで @samp{--short} を有効にするには、trueに設定します。 オプション` --no-short` は、この変数よりも優先されます。

@item  status.branch 
git-status(1) でデフォルトで @samp{--branch} を有効にするには、trueに設定します。 オプション @samp{--no-branch} は、この変数よりも優先されます。

@item  status.aheadBehind 
非磁器コマンドステータス形式(non-porcelain status formats)の git-status(1) で、デフォルトで @samp{--ahead-behind} を有効にするにはtrueに設定し、 @samp{--no-ahead-behind} を有効にするにはfalseに設定します。 デフォルトはtrueです。

@item  status.displayCommentPrefix 
trueに設定すると、 git-status(1) は各出力行の前にコメントプレフィックスを挿入します(@samp{core.commentChar} で始まります。つまりデフォルトでは @samp{#} です)。 これは、Git 1.8.4以前の git-status(1) の動作でした。 デフォルトはfalseです。

@item  status.renameLimit 
git-status(1) および git-commit(1) で名前変更の検出を実行するときに考慮するファイルの数。 デフォルトは diff.renameLimit の値です。

@item  status.renames 
Gitが git-status(1) と git-commit(1) で名前の変更を検出するかどうかとその方法。 @samp{false} に設定すると、名前変更の検出が無効になります。 @samp{true} に設定すると、基本的な名前変更の検出が有効になります。 @samp{copies} または @samp{copy} に設定されている場合、Gitはコピーも検出します。 デフォルトは diff.renames の値です。

@item  status.showStash 
trueに設定すると、 git-status(1) は現在stashされているエントリの数を表示します。 デフォルトはfalseです。

@item  status.showUntrackedFiles 
デフォルトでは、 git-status(1) と git-commit(1) は、現在Gitによって追跡されていないファイルを表示します。 追跡されていないファイルのみを含むディレクトリは、ディレクトリ名のみで表示されます。 追跡されていないファイルを表示するということは、Gitがリポジトリ全体のすべてのファイルを lstat() する必要があることを意味します。これは、一部のシステムでは低速になる可能性があります。 したがって、この変数は、コマンドが追跡されていないファイルを表示する方法を制御します。 可能な値は以下のとおりです:

@itemize 

@item
@samp{no} - 追跡していないファイルを表示しない。

@item
@samp{normal} - 追跡していないファイルとディレクトリを表示

@item
@samp{all} - 追跡されていないディレクトリ内の個々のファイルも表示。
@end itemize

この変数が指定されていない場合、デフォルトで @samp{normal} になります。 この変数は、 git-status(1) および git-commit(1) の @samp{-u}|@samp{--untracked-files} オプションでオーバーライドできます。

@item  status.submoduleSummary 
デフォルトはfalseです。 これがゼロ以外の数値、またはtrue(-1または無制限と同じ)に設定されている場合、サブモジュールの要約が有効になり、変更されたサブモジュールのコミットの要約が表示されます(git-submodule(1) の @samp{--summary-limit} オプションを参照してください)。 @samp{diff.ignoreSubmodules} が @samp{all} に設定されている場合、または @samp{submodule.<name>.ignore=all} であるサブモジュールに対してのみ、要約出力コマンドが抑制されることに注意してください。 そのルールの唯一の例外は、statusとcommitが、ステージされたサブモジュールの変更を表示することです。 無視されたサブモジュールの概要も表示するには、 @samp{--ignore-submodules=dirty} コマンドラインオプションまたは @samp{git submodule summary} コマンドを使用できます。これは同様の出力を表示しますが、これらの設定を尊重しません。

@item  stash.showIncludeUntracked 
これがtrueに設定されている場合、 @samp{git stash show} コマンドはstashエントリの追跡されていないファイルを表示します。 デフォルトはfalseです。 git-stash(1) の showコマンドの説明を参照してください。

@item  stash.showPatch 
これがtrueに設定されている場合、オプションのない @samp{git stash show} コマンドは、パッチ形式でstashエントリを表示します。 デフォルトはfalseです。 git-stash(1)の showコマンドの説明を参照してください。

@item  stash.showStat 
これがtrueに設定されている場合、オプションのない @samp{git stash show} コマンドは、stashエントリのdiffstatを表示します。 デフォルトはtrueです。 git-stash(1) の showコマンドの説明を参照してください。

@item  submodule.<name>.url 
サブモジュールのURL。 この変数は、 @samp{git submodule init} を介して @samp{.gitmodules} ファイルから git config にコピーされます。 ユーザーは、 @samp{git submodule update} を介してサブモジュールを取得する前に、構成されたURLを変更できます。 @samp{submodule.<name>.active} も @samp{submodule.active} も設定されていない場合、この変数の存在は、サブモジュールがgitコマンドに関係するかどうかを示すためのフォールバックとして使用されます。 詳細については、 git-submodule(1)および gitmodules(5) を参照してください。

@item  submodule.<name>.update 
影響を受ける唯一のコマンドである @samp{git submodule update} によってサブモジュールが更新される方法。 @samp{git checkout --recurse-submodules} などの他のコマンドは影響を受けません。 @samp{git submodule} がサブモジュールと対話する唯一のコマンドであった場合、これは歴史的な理由で存在します。 @samp{submodule.active`や `pull.rebase} などの設定はより具体的です。 これは、gitmodules(5) ファイルから @samp{git submodule init} によって入力されます。 git-submodule(1) のupdateコマンドの説明を参照してください。

@item  submodule.<name>.branch 
@samp{git submodule update --remote} によって使用されるサブモジュールのリモートブランチ名。 このオプションを設定すると、 @samp{.gitmodules} ファイルにある値が上書きされます。 詳細については、 git-submodule(1) および gitmodules(5) を参照してください。

@item  submodule.<name>.fetchRecurseSubmodules 
このオプションは、このサブモジュールの再帰的フェッチを制御するために使用できます。 @samp{--[no-]recurse-submodules} コマンドラインオプションを使用して @samp{git fetch} と @samp{git pull} をオーバーライドすることでオーバーライドできます。 この設定は、 gitmodules(5) ファイルの設定を上書きします。

@item  submodule.<name>.ignore 
どのような状況で @samp{git status} とdiffファミリーがサブモジュールを変更済みとして表示するかを定義します。 @samp{all} に設定すると、変更されたとは見なされません(ただし、ステータスの出力に表示され、ステージングされるとコミットされます)。 @samp{dirty} は、サブモジュールの作業ツリーに対するすべての変更を無視し、差異のみを取ります。 サブモジュールのHEADと、スーパープロジェクトに記録されたコミットの間を考慮に入れます。 @samp{untracked} はさらに、作業ツリー内の変更された追跡ファイルを持つサブモジュールを表示させます。 @samp{none} (設定されていない場合のデフォルト)を使用すると、作業ツリーに追跡されていないファイルが変更されたサブモジュールも表示されます。 この設定は、このサブモジュールの @samp{.gitmodules`で行われた設定を上書きします。両方の設定は、 `--ignore-submodules} オプションを使用してコマンドラインで上書きできます。 @samp{git submodule} コマンドは、この設定の影響を受けません。

@item  submodule.<name>.active 
サブモジュールがgitコマンドに関係するかどうかを示すブール値。 この構成オプションは、 @samp{submodule.active} 構成オプションよりも優先されます。 詳細については、 gitsubmodules(7) を参照してください。

@item  submodule.active 
サブモジュールが git コマンドの対象かどうかを判断するためにサブモジュールのパスと照合するために使用される pathspec を含む繰り返しフィールド。詳細は gitsubmodules(7) を参照してください。

@item  submodule.recurse 
コマンドがデフォルトで @samp{--recurse-submodules} オプションを有効にするかどうかを示すブール値。 デフォルトは false です。

true に設定すると、 @samp{--no-recurse-submodules} オプションで非アクティブ化できます。 このオプションがない一部の Git コマンドは、 @samp{submodule.recurse} の影響を受ける上記のコマンドの一部を呼び出す可能性があることに注意してください。 たとえば、@samp{git remote update} は @samp{git fetch} を呼び出しますが、@samp{--no-recurse-submodules} オプションはありません。 これらのコマンドの回避策は、 @samp{git -c submodule.recurse=0} を使用して構成値を一時的に変更することです。

以下のリストは、 @samp{--recurse-submodules} を受け入れるコマンドと、それらがこの設定でサポートされているかどうかを示しています。

@itemize 

@item
checkout、fetch、grep、pull、push、read-tree、reset、restore、switch は常にサポートされています。

@item
@samp{clone} と @samp{ls-files} はサポートされていません。

@item
@samp{branch} は、 @samp{submodule.propagateBranches} が有効な場合にのみサポートされます
@end itemize

@item  submodule.propagateBranches 
[実験的] @samp{--recurse-submodules} または @samp{submodule.recurse=true} を使用するときに分岐サポート(branching support)を有効にするブール値。 これを有効にすると、特定のコマンドが @samp{--recurse-submodules} を受け入れるようになり、すでに @samp{--recurse-submodules} を受け入れている特定のコマンドが分岐(branches)を考慮するようになります。 デフォルトは false です。

@item  submodule.fetchJobs 
同時に フェッチ/クローン されるサブモジュールの数を指定します。 正の整数を使用すると、その数までのサブモジュールを並列にフェッチできます。 値0は、適切なデフォルトを提供します。 設定されていない場合、デフォルトで1になります。

@item  submodule.alternateLocation 
サブモジュールがcloneされるときに、サブモジュールがalternateを取得する方法を指定します。 可能な値は @samp{no} 、@samp{superproject} です。 デフォルトでは、参照を追加しない @samp{no} が想定されています。 値が @samp{superproject} に設定されている場合、cloneされるサブモジュールは、スーパープロジェクトのalternates locationを基準にしてalternates locationを計算します。

@item  submodule.alternateErrorStrategy 
@samp{submodule.alternateLocation} を介して計算されたサブモジュールのalternateでエラーを処理する方法を指定します。 可能な値は @samp{ignore} 、 @samp{info} 、 @samp{die} です。デフォルトは @samp{die} です。 @samp{ignore} または @samp{info} に設定されていて、計算されたalternateにエラーがある場合、alternateが指定されていないかのようにクローンが進行することに注意してください。

@item  tag.forceSignAnnotated 
作成された注釈付きタグをGPG署名するかどうかを指定するブール値。 コマンドラインで @samp{--annotate} が指定されている場合、このオプションよりも優先されます。

@item  tag.sort 
この変数は、 git-tag(1) によって表示されるときのタグの並べ替え順序を制御します。 @samp{--sort=<value>} オプションが指定されていない場合、この変数の値がデフォルトとして使用されます。

@item  tag.gpgSign 
すべてのタグをGPG署名するかどうかを指定するブール値。 自動スクリプトで実行しているときにこのオプションを使用すると、多数のタグが署名される可能性があります。 したがって、あなたは、エージェントを使用して、gpgパスフレーズを毎回入力しないようにするのが便利です。 このオプションは、 @samp{-u<keyid>} または @samp{--local-user=<keyid>} オプションによって有効にされるタグ署名の動作には影響しないことに注意してください。

@item  tar.umask 
この変数は、tarアーカイブエントリの許可ビットを制限するために使用できます。デフォルトは0002で、ワールド書き込みビット(world write bit)をオフにします。 特別な値 "user" は、アーカイブユーザーのumaskが代わりに使用されることを示します。 umask(2) および git-archive(1) を参照してください。
@end table

trace2構成設定は、システムおよびグローバル構成ファイルからのみ読み取られます。 リポジトリのローカルおよびワークツリー構成ファイルと @samp{-c} コマンドライン引数は尊重されません。

@table @asis

@item  trace2.normalTarget 
この変数は、通常のターゲット(normal target)宛先を制御します。 @samp{GIT_TRACE2} 環境変数によってオーバーライドされる可能性があります。

@item  trace2.perfTarget 
この変数は、パフォーマンスターゲットの宛先を制御します。 @samp{GIT_TRACE2_PERF} 環境変数によってオーバーライドされる可能性があります。

@item  trace2.eventTarget 
この変数は、イベントターゲットの宛先を制御します。 @samp{GIT_TRACE2_EVENT} 環境変数によってオーバーライドされる可能性があります。

@itemize 

@item
@samp{0} or @samp{false} - ターゲットを無効にします。

@item
@samp{1} or @samp{true} - @samp{STDERR} に書き出します。

@item
@samp{[2-9]} - すでに開いているファイル・デスクリプターに書き出します。

@item
@samp{<absolute-pathname>} - appendモードでファイルに書き込みます。ターゲットがすでに存在し、ディレクトリである場合、トレースは指定のディレクトリの下のファイル(プロセスごとに1つ)に書き込まれます。

@item
@samp{af_unix:[<socket_type>:]<absolute-pathname>} - Unixドメインソケットに書き出します(それらをサポートするプラットフォーム上であれば)。ソケットタイプは @samp{stream} または @samp{dgram} のいずれかです。省略した場合、Gitは両方を試します。
@end itemize

@item  trace2.normalBrief 
ブール値。 trueの場合、 @samp{time} と @samp{filename} と @samp{line} フィールドは通常の出力(normal output)から省略されます。 @samp{GIT_TRACE2_BRIEF} 環境変数によってオーバーライドされる可能性があります。 デフォルトはfalseです。

@item  trace2.perfBrief 
ブール値。 trueの場合、 @samp{time} と @samp{filename} と @samp{line} フィールドはPERF出力から省略されます。 @samp{GIT_TRACE2_PERF_BRIEF} 環境変数によってオーバーライドされる可能性があります。 デフォルトはfalseです。

@item  trace2.eventBrief 
ブール値。 trueの場合、 @samp{time} と @samp{filename} と @samp{line} フィールドはイベント出力から省略されます。 @samp{GIT_TRACE2_EVENT_BRIEF} 環境変数によってオーバーライドされる可能性があります。 デフォルトはfalseです。

@item  trace2.eventNesting 
整数。 イベント出力でネストされた領域(region)の必要な深さを指定します。この値より深い領域は省略されます。 @samp{GIT_TRACE2_EVENT_NESTING} 環境変数によってオーバーライドされる可能性があります。 デフォルトは2です。

@item  trace2.configParams 
trace2出力に記録する必要がある「重要な」構成設定のパターンのコンマ区切りリスト。 たとえば、 @samp{core.*,remote.*.url} を指定すると、trace2の出力には、構成された各リモートを一覧表示するイベントが含まれます。 @samp{GIT_TRACE2_CONFIG_PARAMS} 環境変数によってオーバーライドされる可能性があります。 デフォルトでは設定されていません。

@item  trace2.envVars 
trace2出力に記録する必要がある「重要な」環境変数のコンマ区切りリスト。 たとえば、 @samp{GIT_HTTP_USER_AGENT,GIT_CONFIG} を指定すると、trace2出力に、(いずれも設定されていると仮定して、)HTTPユーザーエージェントのオーバーライドとGit構成ファイルの場所をリストするイベントが含まれます。 @samp{GIT_TRACE2_ENV_VARS} 環境変数によってオーバーライドされる可能性があります。 デフォルトでは設定されていません。

@item  trace2.destinationDebug 
ブール値。 trueの場合、トレースターゲットの宛先を書き込み用に開くことができない場合、Gitはエラーメッセージを出力します。 デフォルトでは、これらのエラーは抑制され、トレースは黙って無効になっています。 @samp{GIT_TRACE2_DST_DEBUG} 環境変数によってオーバーライドされる可能性があります。

@item  trace2.maxFiles 
整数。 トレースファイルをターゲットディレクトリに書き込むとき、この数のファイルを超える場合は、追加のトレースを書き込まないでください。 代わりに、このディレクトリへのそれ以上のトレースをブロックする番兵ファイル(sentinel file)を作成します。 デフォルトは0で、このチェックを無効にします。

@item  transfer.credentialsInUrl 
構成された URL には、 @samp{<protocol>://<user>:<password>@@<domain>/<path>} の形式で平文(plaintext)の資格情報(credentials)を含めることができます。 (git-credential(1) の使用を優先して、)そのような構成の使用を警告または禁止することができます。 これは、 git-clone(1) や git-fetch(1) やgit-push(1) や その他の構成された URL の直接使用で使用されます。

注意: これは現在、@samp{remote.<name>.url} 構成での資格情報(credentials)の検出(detect)に限定されていることに注意してください。 @samp{remote.<name>.pushurl} 構成での資格情報の検出は行われません。

これを有効にして、不注意による資格情報(credentials)の公開を防ぐことができます。 それがなぜかを以下の例で説明します:

@itemize 

@item
git を実行している OS またはシステムでは、ユーザー名やパスワードが保存されている構成ファイルのアクセス許可を構成する方法が提供されていないか、許可されていない場合があります。

@item
たとえ許可があったとしても、そのようなデータを「保存」すると、他の方法で危険にさらされる可能性があります。たとえばバックアップ処理によって、データが別のシステムにコピーされる場合があります。

@item
git プログラムは、完全な URL をコマンドラインの引数として互いに渡します。つまり、他のユーザーが他のユーザーの完全なプロセス一覧を見ることができる OS やシステムでは、認証情報(credentials)が他のユーザーに公開されることになるのです。 linuxでは、 procfs(5) で文書化されている @samp{hidepid} 設定で、こういう振る舞いに設定することができます。

もし、このような配がないのであれば、 gitの設定ファイルに機密データを保存することによる認証情報の漏洩を心配する必要はないでしょう。さてそれではこの機能を使用する場合は、 @samp{transfer.credentialsInUrl} を以下のいずれかの値に設定します:

@item
@samp{allow} (デフォルト): Git は警告なしでアクティビティを続行します。

@item
@samp{warn}: Git は、平文(plaintext)の資格情報(credential)で URL をパースするときに @samp{stderr} に警告メッセージを書き込みます。

@item
@samp{die}: Git は、 平文(plaintext)の資格情報(credential)で URL をパースするときに、失敗メッセージを @samp{stderr} に書き込みます。
@end itemize

@item  transfer.fsckObjects 
@samp{fetch.fsckObjects} または @samp{receive.fsckObjects} が設定されていない場合、代わりにこの変数の値が使用されます。デフォルトはfalseです。

設定すると、不正な形式のオブジェクトまたは存在しないオブジェクトへのリンクの場合、フェッチまたは受信は中止されます。 さらに、レガシー問題(@samp{fsck.<msg-id>} を参照)を含む、 @samp{.GIT} ディレクトリや悪意のある @samp{.gitmodules} ファイルの存在などの潜在的なセキュリティの問題(詳細については、v2.2.1およびv2.17.1のリリースノートを参照してください)など、他のさまざまな問題がチェックされます。 その他の健全性とセキュリティのチェックが、将来のリリースで追加される可能性があります。

受信側では、fsckObjects に障害が発生すると、これらのオブジェクトに到達できなくなります。 git-receive-pack(1) の「QUARANTINE ENVIRONMENT」を参照してください。 一方、フェッチ側では、不正な形式のオブジェクトはリポジトリで参照されない(unreferenced)ままになります。

@samp{fetch.fsckObjects} 実装は隔離されていない(non-quarantine nature)ため、 @samp{receive.fsckObjects} のようにオブジェクトストアをクリーンな状態に保つことはできません。

オブジェクトが解凍されると、オブジェクトストアに書き込まれるため、「フェッチ」が失敗したにもかかわらず、悪意のあるオブジェクトが導入される場合があります。オブジェクトストアにすでに書き込まれているオブジェクトではなく、新しい着信オブジェクトのみがチェックされるため、後続の「フェッチ」が成功するだけです。 この振る舞いの違いは信頼されるべきではありません。将来的には、そのようなオブジェクトは「フェッチ」のために隔離される可能性があります。

今のところ、「プッシュ」と同じ保護が必要な場合、疑り深い人(paranoid)は検疫環境をエミュレートする方法を見つける必要があります。 例えば、内部ミラーの場合、2つのステップでミラーリングを実行します。信頼できないオブジェクトをフェッチするために1ステップ、そして次に、別の内部リポジトリに「プッシュ」(隔離を使用します)を実行する2ステップ目です。内部クライアントにこのプッシュ先リポジトリを消費させ、または、内部フェッチを禁止し、完全な @samp{fsck} が実行された場合にのみ許可します(その間に新しいフェッチは発生しません)。

@item  transfer.hideRefs 
文字列 @samp{receive-pack} と @samp{upload-pack} は、最初の広告から除外するrefを決定するために使用します。 複数のプレフィックス文字列を指定するには、複数の定義を使用します。 この変数の値にリストされている階層の下にあるrefは除外され、 @samp{git push} または @samp{git fetch} に応答するときに非表示になります。 この構成のプログラム固有のバージョンについては、 @samp{receive.hideRefs} および @samp{uploadpack.hideRefs} を参照してください。

あなたは ref名の前に @samp{!} を含めてエントリを無効にし、以前のエントリで非表示としてマークされていた場合でも、明示的に公開することもできます。 複数の非表示ref値がある場合、後のエントリが前のエントリを上書きします(そして、より具体的な構成ファイルのエントリは、より具体的でないものを上書きします)。

名前空間が使用されている場合、名前空間プレフィックスは、 @samp{transfer.hiderefs} パターンと照合される前に、各参照から削除されます。 削除する前に参照を一致させるには、参照名の前に @samp{^} を追加します。 @samp{!} と @samp{^} を組み合わせる場合は、最初に @samp{!} を指定する必要があります。

たとえば、 @samp{refs/heads/master} が @samp{transfer.hideRefs} で指定され、現在の名前空間が @samp{foo} の場合、 @samp{refs/namespaces/foo/refs/heads/master} は広告から省略されます。 @samp{uploadpack.allowRefInWant} が設定されている場合、 @samp{upload-pack} は、プロトコルバージョン2の @samp{fetch} コマンドの @samp{want-ref refs/heads/master} で、 @samp{refs/namespaces/foo/refs/heads/master} が存在しないかのように扱います。 一方、 @samp{receive-pack`は、その名前(いわゆる `.have} 行)を指定せずに、refが指しているオブジェクトIDを広告します。

refを非表示にしても、 gitnamespaces(7)のマニュアルページの「SECURITY」セクションで説明されている手法を使用して、クライアントがターゲットオブジェクトを盗むことができる場合があります。よって、プライベートデータは別のリポジトリに保持するのが最良です。

@item  transfer.unpackLimit 
@samp{fetch.unpackLimit} または @samp{receive.unpackLimit} が設定されていない場合、代わりにこの変数の値が使用されます。 デフォルト値は100です。

@item  transfer.advertiseSID 
ブール値。 trueの場合、クライアントプロセスとサーバープロセスは、一意のセッションIDをリモートの対応するプロセスに広告します。 デフォルトはfalseです。

@item  transfer.bundleURI 
When @samp{true}, local @samp{git clone} commands will request bundle information from the remote server (if advertised) and download bundles before continuing the clone through the Git protocol. Defaults to @samp{false}.

@item  uploadarchive.allowUnreachable 
trueの場合、クライアントが @samp{git archive --remote} を使用して、ref先端から到達可能かどうかに関係なく、任意のツリーを要求できるようにします。詳細については、 git-upload-archive(1)の「SECURITY」セクションの説明を参照してください。デフォルトは @samp{false} です。

@item  uploadpack.hideRefs 
この変数は @samp{transfer.hideRefs} と同じですが、 @samp{upload-pack} にのみ適用されます(したがって、プッシュではなくフェッチにのみ影響します)。 @samp{git fetch} で隠しref(hidden ref)をフェッチしようとすると失敗します。 @samp{uploadpack.allowTipSHA1InWant} も参照してください。

@item  uploadpack.allowTipSHA1InWant 
@samp{uploadpack.hideRefs} が有効な場合、 @samp{upload-pack} が非表示の参照の先端にあるオブジェクトを要求するフェッチ要求を受け入れることを許可します(デフォルトでは、そのような要求は拒否されます)。 @samp{uploadpack.hideRefs} も参照してください。 これが false であっても、クライアントは、 gitnamespaces(7) のマニュアルページの「SECURITY」セクションで説明されている手法を使用してオブジェクトを盗むことができる場合があります。プライベートデータを別のリポジトリに保持することをお勧めします。

@item  uploadpack.allowReachableSHA1InWant 
@samp{upload-pack} が、任意の参照先端から到達可能なオブジェクトを要求するフェッチ要求を受け入れることを許可します。 ただし、オブジェクトの到達可能性の計算には計算コストがかかることに注意してください。 デフォルトは @samp{false} です。 これが false であっても、クライアントは、 gitnamespaces(7) のマニュアルページの「SECURITY」セクションで説明されている手法を使用してオブジェクトを盗むことができる場合があります。 プライベートデータを別のリポジトリに保持することをお勧めします。

@item  uploadpack.allowAnySHA1InWant 
@samp{upload-pack} が、オブジェクトを要求するフェッチ要求を受け入れることを許可します。 デフォルトは @samp{false} です。

@item  uploadpack.keepAlive 
@samp{upload-pack} が @samp{pack-objects} を開始したとき、@samp{pack-objects} がパックを準備している間は黙っている期間があるかもしれません。 通常は進行状況情報を出力しますが、フェッチに @samp{--quiet} を使用した場合、 @samp{pack-objects} はパックデータが開始するまで何も出力しません。 一部のクライアントとネットワークは、サーバーがハングしてあきらめていると見なす場合があります。 このオプションを設定すると、 @samp{upload-pack} は @samp{uploadpack.keepAlive} 秒ごとに空のキープアライブパケットを送信するように指示されます。 このオプションを0に設定すると、キープアライブパケットが完全に無効になります。 デフォルトは5秒です。

@item  uploadpack.packObjectsHook 
このオプションが設定されている場合、 @samp{upload-pack} がクライアントのパックファイルを作成するために @samp{git pack-objects} を実行しようとすると、代わりにこのシェルコマンドが実行されます。 @samp{pack-objects} コマンドとそれが実行するであろう引数(最初の @samp{git pack-objects} を含む)がシェルコマンドに追加されます。 フックのstdinとstdoutは、 @samp{pack-objects} 自体が実行されたかのように扱われます。 つまり、 @samp{upload-pack} は、 @samp{pack-objects} を対象とした入力をフックに送り、stdoutで完成したpackfileを期待します。

注意: この構成変数は、保護された構成で指定されている場合にのみ尊重されることに注意してください(@ref{SCOPES} 参照)。 これは、信頼されていないリポジトリからのフェッチに対する安全対策です。

@item  uploadpack.allowFilter 
このオプションが設定されている場合、 @samp{upload-pack} は部分クローン(partial clone)および部分フェッチオブジェクト(partial fetch object)のフィルタリングをサポートします。

@item  uploadpackfilter.allow 
未指定のオブジェクトフィルターのデフォルト値を提供します(下記構成変数参照)。 @samp{true} に設定すると、将来追加されるすべてのフィルターも有効になります。 デフォルトは @samp{true} です。

@item  uploadpackfilter.<filter>.allow 
@samp{<filter>} に対応するオブジェクトフィルターを明示的に許可または禁止します。ここで、@samp{<filter>} は次のいずれかになります: @samp{blob:none}, @samp{blob:limit}, @samp{object:type}, @samp{tree}, @samp{sparse:oid}, @samp{combine} 。 組み合わフィルターを使用する場合は、@samp{combine} とすべてのネストされたフィルターの種類の両方を許可する必要があります。 デフォルトは @samp{uploadpackfilter.allow} です。

@item  uploadpackfilter.tree.maxDepth 
@samp{<n>} が @samp{uploadpackfilter.tree.maxDepth} の値以下の場合にのみ、 @samp{--filter=tree:<n>} を許可します。 設定されている場合、この構成変数がすでに設定されていない限り、これは @samp{uploadpackfilter.tree.allow=true} も意味します。 設定されていない場合は効果がありません。

@item  uploadpack.allowRefInWant 
このオプションが設定されている場合、 @samp{upload-pack} はプロトコルバージョン2の @samp{fetch} コマンドの @samp{ref-in-want} 機能をサポートします。 この機能は、レプリケーションの遅延のために、refが指すOIDについて同じビューを持たない可能性がある負荷分散サーバーの利益を目的としています。

@item  url.<base>.insteadOf 
この値で始まるURLは、代わりに<base>で始まるように書き換えられます。 あるサイトが多数のリポジトリを提供し、それらを複数のアクセス方法で提供しており、一部のユーザーが異なるアクセス方法を使用する必要がある場合、この機能は、ユーザーが任意の同等のURLを指定し、Gitが自動的に特定のユーザーにとって最適な代替URLに書き換えることを可能にします。 複数の insteadOf 文字列が特定のURLに一致する場合、最も長い一致が使用されます。

注意: プロトコルの制限は、書き換えられたURLに適用されることに注意してください。 リライトによってカスタムプロトコルまたはリモートヘルパーを使用するようにURLが変更された場合は、リクエストを許可するように @samp{protocol.*.allow} 構成を調整する必要があります。 特に、サブモジュールに使用する予定のプロトコルは、デフォルトの @samp{user} ではなく @samp{always} に設定する必要があります。 上記 @samp{protocol.allow} の説明を参照してください。

@item  url.<base>.pushInsteadOf 
この値で始まるURLはプッシュされません。代わりに、<base>で始まるように書き直され、結果のURLがにプッシュされます。 あるサイトが多数のリポジトリを提供し、それらを複数のアクセス方法で提供し、そのうちのいくつかはプッシュを許可しない場合、この機能は、サイト上で見たことのないリポジトリであっても、プル専用のURLを指定して、Gitが自動的に適切なURLを使ってプッシュすることを可能にします。 複数の pushInsteadOf 文字列が特定のURLに一致する場合、最も長い一致が使用されます。 リモートに明示的な pushurl がある場合、Gitはそのリモートのこの設定を無視します。

@item  user.name 
@itemx  user.email 
@itemx  author.name 
@itemx  author.email 
@itemx  committer.name 
@itemx  committer.email 
@samp{user.name} 変数と @samp{user.email} 変数は、コミットオブジェクトの @samp{author} フィールドと @samp{committer} フィールドに何が入るかを決定します。 @samp{author} または @samp{committer} を変更する必要がある場合は、 @samp{author.name} または @samp{author.email} または @samp{committer.name} または @samp{committer.email} 変数を設定できます。 また、これらはすべて、 @samp{GIT_AUTHOR_NAME} または @samp{GIT_AUTHOR_EMAIL} または @samp{GIT_COMMITTER_NAME} または @samp{GIT_COMMITTER_EMAIL} または @samp{EMAIL} 環境変数によってオーバーライドできます。

注意: これらの変数の @samp{name} 形式は、通常、何らかの形式の個人名を参照していることに注意してください。 これらの設定の詳細については、 git-commit(1) および git(1) の「environment variables」セクションを参照してください。代わりに認証資格情報(authentication credentials)を探している場合は、 @samp{credential.username} オプションを参照してください。

@item  user.useConfigOnly 
@samp{user.email} と @samp{user.name} のデフォルトを推測しようとせず、代わりに構成からのみ値を取得するようにGitに指示します。 たとえば、複数のメールアドレスがあり、リポジトリごとに異なるアドレスを使用する場合、 グローバル設定でこの設定オプションを @samp{true} に設定し、名前を指定すると、 Gitは、新しく複製されたリポジトリで新しくコミットを行う前に、電子メールを設定するように求めるプロンプトを表示します。 デフォルトは`false`です。

@item  user.signingKey 
git-tag(1) または git-commit(1) が、署名されたタグまたは署名されたコミットを作成するときに自動的に必要なキーを選択していない場合、この変数でデフォルトの選択を上書きできます。 このオプションは変更されずに gpg の @samp{--local-user} パラメータに渡されるため、gpg がサポートする任意の方法を使用してキーを指定できます。 gpg.formatが @samp{ssh} に設定されている場合、 ssh-agent を使用したときの秘密鍵または公開鍵へのパスを格納することができます。 あるいは、 @samp{key::} で始まる公開鍵を直接含めることもできます(例: @samp{key::ssh-rsa XXXXXX identifier})。 秘密鍵は、ssh-agent 経由で入手できる必要があります。 設定されていない場合、 git は gpg.ssh.defaultKeyCommand(例: @samp{ssh-add -L}) を呼び出し、利用可能な最初のキーを使用しようとします。 下位互換性のために、 @samp{key::ssh-rsa XXXXXX identifier} などの @samp{ssh-} で始まる生の鍵は @samp{key::ssh-rsa XXXXXX identifier} として扱われますが、この形式は非推奨です。 代わりに @samp{key::} 形式を使用してください。

@item  versionsort.prereleaseSuffix (非推奨) 
@samp{versionsort.suffix} の非推奨のエイリアス。 @samp{versionsort.suffix} が設定されている場合は無視されます。

@item  versionsort.suffix 
linkgit:git-tag [1]でバージョンの並べ替えが使用されている場合でも、基本バージョンが同じで接尾辞が異なるタグ名は辞書式順序で並べ替えられます。 例えば、メインリリースの後に表示されるプレリリースタグ(例: @samp{1.0} の後の @samp{1.0-rc1})。 この変数を指定して、異なる接尾辞を持つタグのソート順を決定できます。

この変数に単一の接尾辞(suffix)を指定すると、その接尾辞を含むタグ名は、対応するメインリリースの前に表示されます。 例えば、変数が @samp{-rc} に設定されている場合、すべての @samp{1.0-rcX} タグは @samp{1.0} の前に表示されます。 複数回指定した場合、1つのサフィックスにつき1回だけ、設定中のサフィックスの順番でタグ名の並べ替え順が決定されます。 例えば、構成で @samp{-pre`が `-rc} の前に表示されている場合、すべての @samp{1.0-preX} タグが @samp{1.0-rcX} タグの前にリストされます。 さまざまな接尾辞を持つタグに対するメインリリースタグの配置順序は、他の接尾辞群の中で空の接尾辞を指定することで決定できます。 例えば、接尾辞 「-rc」と「」と「-ck」と「-bfs」がこの順序で構成に表示される場合、すべての @samp{v4.8-rcX｀タグが最初にリストされ、次に `v4.8} がリストされ、その次が @samp{v4.8-ckX} で、最後に @samp{v4.8-bfsX} です。

複数の接尾辞(suffixes)が同じタグ名に一致する場合、そのタグ名は、タグ名の最初の位置から始まる接尾辞に従って並べ替えされます。 一致する複数の異なる接尾辞がその最も早い位置から始まる場合、そのタグ名はそれらの接尾辞の最長のものに従って並べ替えされます。 異なる接尾辞間の並べ替え順は、それらが複数の構成ファイルに渡る場合は未定義です。

@item  web.browser 
一部のコマンドで使用できるWebブラウザを指定します。 現在、 git-instaweb(1) と git-help(1) のみが使用できます。

@item  worktree.guessRemote 
ブランチが指定されておらず、 @samp{-b} や ` -B` や @samp{--detach} のいずれも使用されていない場合、 @samp{git worktree add} はデフォルトでHEADから新しいブランチを作成します。 @samp{worktree.guessRemote} がtrueに設定されている場合、 @samp{worktree add} は、名前が新しいブランチ名と一意に一致するリモート追跡ブランチを見つけようとします。 そのようなブランチが存在する場合、それはチェックアウトされ、新しいブランチの「アップストリーム」として設定されます。 そのような一致が見つからない場合は、フォールバックして現在のHEADから新しいブランチを作成します。
@end table

@noindent

@chapheading BUGS

非推奨の @samp{[section.subsection]} 構文を使用する場合、サブセクションに少なくとも1つの大文字が指定されていると、値を変更すると、変更ではなく複数行のキーが追加されます。たとえば、設定が以下のようになっている場合

@example
  [section.subsection]
    key = value1
@end example


@samp{git config section.Subsection.key value2} を実行すると、以下のようになります。

@example
  [section.subsection]
    key = value1
    key = value2
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node git-count-objects,,,Top
@chapheading Name

git-count-objects — パックされていない(unpack)オブジェクトの数とそのディスク消費量を計量します

@noindent

@chapheading Synopsis

@display
git count-objects [-v] [-H | --human-readable]
@end display


@noindent

@chapheading DESCRIPTION

これは、パックされていないオブジェクトファイルの数とそれらによって消費されたディスク領域を計量し、再パックするのに適した時期を判断するのに役立ちます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
@itemx  @samp{--verbose} 
より詳細な報告:

count: 緩いオブジェクト(loose objects;ファイルごとに１つのオブジェクトな形式)の数

size: 緩いオブジェクトによって消費される、KiB単位のディスク容量(-H が指定されていない場合)

in-pack: パック内にあるオブジェクトの数

size-pack: パック群によって消費される、KiB単位のディスク容量(-Hが指定されていない場合)

prune-packable: パック内にも同じものが存在する緩いオブジェクトの数。これらの緩いオブジェクトは、@samp{git prune-packed} を使用して剪定する(prune)事ができます。

garbage: オブジェクトデータベース内の、有効な緩いオブジェクトでも有効なパックでもないファイルの数

size-garbage: garbageファイルによって消費されるKiB単位のディスク容量(-Hが指定されていない場合)

alternate: 代替オブジェクトデータベース群の絶対パス。パスごとに1行ずつ、複数回表示される場合があります。パスに印刷不可能な文字が含まれている場合は、二重引用符で囲まれ、C言語スタイルのバックスラッシュエスケープシーケンスが含まれている可能性があることに注意してください。

@item  @samp{-H} 
@itemx  @samp{--human-readable} 
人間に分かりやすい形式でサイズを出力する
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-credential-cache--daemon,,,Top
@chapheading Name

git-credential-cache--daemon — ユーザーの資格情報を一時的にメモリに保存する

@noindent

@chapheading Synopsis

@display
git credential-cache--daemon [--debug] <socket-path>
@end display


@noindent

@chapheading DESCRIPTION

@quotation

@strong{Note}

あなたが、このコマンドを手動で起動したくないなら、 git-credential-cache(1) を使用すれば自動的に開始されます。
@end quotation

This command listens on the Unix domain socket specified by @samp{<socket-path>} for @samp{git-credential-cache} clients. Clients may store and retrieve credentials. Each credential is held for a timeout specified by the client; once no credentials are held, the daemon exits.

@samp{--debug} オプションが指定されている場合、デーモンはstderrストリームを閉じず、クライアントのリッスンを開始した後でも、追加の診断を出力する場合があります。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-credential-cache,,,Top
@chapheading Name

git-credential-cache — パスワードを一時的にメモリに保存するヘルパー

@noindent

@chapheading Synopsis

@example
git config credential.helper 'cache [<options>]'
@end example


@noindent

@chapheading DESCRIPTION

This command caches credentials for use by future Git programs. The stored credentials are kept in memory of the cache-daemon process (instead of written to a file) and are forgotten after a configurable timeout. Credentials are forgotten sooner if the cache-daemon dies, for example if the system restarts. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.

あなたはこのコマンドを直接呼び出すことは無いでしょう。これは、Gitの他の部分で認証情報ヘルパーとして使用されることを目的としています。gitcredentials(7) または 以下の EXAMPLES を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--timeout <seconds>} 
認証情報をキャッシュする秒数(デフォルト: 900)。

@item  @samp{--socket <path>} 
@samp{<path>} を使用して、実行中のキャッシュデーモンに接続します(または、新しいキャッシュデーモンが開始されていない場合は開始します)。デフォルトは @samp{$XDG_CACHE_HOME/git/credential/socket} です(@samp{~/.git-credential-cache/} が存在しない限り)。 @samp{~/.git-credential-cache/} が存在する場合は、代わりに @samp{~/.git-credential-cache/} が使用されます。あなたのホームディレクトリがネットワークにマウントされたファイルシステム上にある場合は、これをローカルファイルシステムに変更する必要がある場合があります。あなたは絶対パスを指定しなければなりません。
@end table

@noindent

@chapheading CONTROLLING THE DAEMON

あなたがデーモンを早期に終了させ、タイムアウトする前にキャッシュされたすべての認証情報を忘れ去りたい場合は、「exit」アクションを発行できます:

@example
git credential-cache exit
@end example


@noindent

@chapheading EXAMPLES

このヘルパーの肝は、ユーザー名またはパスワードを入力する必要がある回数を減らすことです。例えば:

@example
$ git config credential.helper cache
$ git push http://example.com/repo.git
Username: <type your username>
Password: <type your password>

[work for 5 more minutes]
$ git push http://example.com/repo.git
[your credentials are used automatically]
@end example


You can provide options via the credential.helper configuration variable (this example increases the cache time to 1 hour):

@example
$ git config credential.helper 'cache --timeout=3600'
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node git-credential-store,,,Top
@chapheading Name

git-credential-store — 資格情報をディスクに保存するヘルパー

@noindent

@chapheading Synopsis

@example
git config credential.helper 'store [<options>]'
@end example


@noindent

@chapheading DESCRIPTION

@quotation

@strong{Note}

このヘルパーを使用すると、パスワードは暗号化されずにディスクに保存され、ファイルシステムのアクセス許可によってのみ保護されます。これが許容できるセキュリティのトレードオフではない場合は git-credential-cache(1) を試すか、オペレーティングシステムが提供する安全なストレージと統合するヘルパーを探してください。
@end quotation

このコマンドは、将来に渡ってGitプログラムで使用できるように、資格情報をディスクに無期限に保存します。

このコマンドが直接呼び出されることはありません。これは、gitの他の部分で資格情報ヘルパーとして使用されることを目的としています。以下のEXAMPLESまたは gitcredentials(7) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--file=<path>} 
@samp{<path>} を使用して、資格情報を探してして保存します。ファイルには、システム上の他のユーザーがファイルを読み取れないようにファイルシステムのアクセス許可が設定されますが、暗号化またはその他の方法で保護されることはありません。@samp{<path>} 指定がない場合、資格情報は @samp{~/.git-credentials} と @samp{$XDG_CONFIG_HOME/git/credentials} から検索されます。そして、書き込みは、存在すれば @samp{~/.git-credentials} に書き込みますが、@samp{~/.git-credentials} に書き込まなかった場合、存在すれば @samp{$XDG_CONFIG_HOME/git/credentials} に書き込みます。 @ref{FILES} も参照してください。
@end table

@noindent

@chapheading FILES

@samp{--file} で明示的に設定されていない場合、git-credential-store が優先順位に従って資格情報を検索する2つのファイルがあります:

@table @asis

@item  ~/.git-credentials 
ユーザー毎の資格情報ファイル。

@item  $XDG_CONFIG_HOME/git/credentials 
2番目のユーザー毎の資格情報ファイル。 @emph{$XDG_CONFIG_HOME} が設定されていないか空の場合、 @samp{$HOME/.config/git/credentials} が使用されます。 @samp{~/.git-credentials} に一致する資格情報がある場合、このファイルに保存されている資格情報は使用されません。このファイルがサポートされていない、古いバージョンのGitを使用することがある場合は、このファイルを作成しないことをお勧めします。
@end table

資格情報探索の場合、ファイルは上記の順序で読み取られ、最初に一致した資格情報が、リストのさらに下のファイルで見つかった資格情報よりも優先されます。

資格情報ストレージは、デフォルトでこのリストの順で最初に見つかった既存のファイルに書き込みます。これらのファイルが存在しない場合は、 @samp{~/.git-credentials} を作成して書き込みます。

資格情報の消去を行うと、一致するすべての資格情報がすべてのファイルから消去されます。

@noindent

@chapheading EXAMPLES

このヘルパーの要点は、ユーザー名またはパスワードを入力する必要がある回数を減らすことです。 例えば:

@example
$ git config credential.helper store
$ git push http://example.com/repo.git
Username: <type your username>
Password: <type your password>

[several days later]
$ git push http://example.com/repo.git
[your credentials are used automatically]
@end example


@noindent

@chapheading STORAGE FORMAT

@samp{.git-credentials} ファイルはプレーンテキストで保存されます。各資格情報は、以下のようなURLとしてそれぞれ独自の行に保存されます:

@example
https://user:pass@@example.com
@end example


他の種類の行(空の行やコメント行など)は、一部が黙って無視される場合でも、ファイル内では許可されません。エディタでファイルを表示または編集しないでください。

Gitが特定のURLコンテキストの認証を必要とする場合、credential-store はそのコンテキストを、資格情報ファイルの各エントリと照合するパターンと見なします。 protocolとhostnameと(すでに持っている場合)usernameが一致する場合、パスワードはGitに返されます。詳細については、 gitcredentials(7) の 「the discussion of configuration」を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-credential,,,Top
@chapheading Name

git-credential — ユーザー資格情報の取得と保存

@noindent

@chapheading Synopsis

@example
'git credential' (fill|approve|reject)
@end example


@noindent

@chapheading DESCRIPTION

Gitには、システム固有のヘルパーから資格情報(credentials)を保存および取得したり、ユーザーにユーザー名とパスワードの入力を求めたりするための内部インターフェイスがあります。 git-credentialコマンドは、Gitと同じ方法で資格情報を取得、保存、または要求する可能性のあるスクリプトにこのインターフェイスを公開します。 このスクリプト可能なインターフェイスの設計は、内部CAPIをモデル化しています。 概念の背景については、credential.hを参照してください。

git-credentialは、コマンドラインで「action」オプション(@samp{fill} または @samp{approve} または @samp{reject} のいずれか)を取り、stdinで資格情報の説明(description)を読み取ります(INPUT/OUTPUT FORMAT (@pxref{INPUT/OUTPUT FORMAT}) を参照)

アクションが @samp{fill} の場合、git-credentialは、構成ファイルを読み取るか、構成された資格情報ヘルパーに連絡するか、ユーザーにプロンプトを表示することにより、説明(description)に「username」および「password」属性を追加しようとします。次に、資格情報の説明(description)のユーザー名とパスワードの属性が、すでに提供されている属性とともにstdoutに出力されます。

アクションが @samp{approve}(承認)の場合、git-credentialは、構成された資格情報ヘルパーに説明(description)を送信します。ヘルパーは、後で使用するために資格情報を保存する場合があります。

If the action is @samp{reject}, git-credential will send the description to any configured credential helpers, which may erase any stored credentials matching the description.

アクションが @samp{approve}(承認)または @samp{reject}(拒否)の場合、出力は生成されません。

@noindent

@chapheading TYPICAL USE OF GIT CREDENTIAL

git-credentialを使用するアプリケーションは、通常、以下の手順に従って @samp{git credential} を使用します:

@enumerate 

@item
コンテキストに基づいて資格情報の説明(description)を生成します。

たとえば、 @samp{https://example.com/foo.git} のパスワードが必要な場合は、以下の資格情報の説明(description)を生成できます(最後の空白行を忘れないでください。これは、アプリケーションがすべての情報の提供を終了したことを @samp{git credential} に通知します):

@example
protocol=https
host=example.com
path=foo.git
@end example

@item
この説明(description)のユーザー名とパスワードを提供するようにgit-credentialに依頼してください。 これは、 @samp{git credential fill} を実行し、ステップ(1)の説明(description)を標準入力に送ることで実行されます。完全な資格情報の説明(description)(資格情報自体、つまりログインとパスワードを含む)は、以下のように標準出力へ生成されます。

@example
protocol=https
host=example.com
username=bob
password=secr3t
@end example

ほとんどの場合、これは入力で指定された属性が出力で繰り返されることを意味しますが、Gitは資格情報の説明(description)を変更する場合もあります。たとえば、プロトコルがHTTP(s)であり、 @samp{credential.useHttpPath} がfalseの場合、 @samp{path} 属性を削除します。

@samp{git credential} が既にパスワードを知っていた場合、この手順では、ユーザーが @samp{password=secr3t} を返す前に実際にこのパスワードを入力していなかった可能性があります(ユーザーが代わりにキーチェーンのロックを解除するためにパスワードを入力したか、キーチェーンがすでにロック解除している場合はユーザーの操作が行われなかった可能性があります)。

@item
資格情報を使用し(たとえば、手順(2)のユーザー名とパスワードを使用してURLにアクセスします)、それが受け入れられるかどうかを確認します。

@item
パスワードの成功または失敗について報告します。資格情報によって操作が正常に完了することが許可された場合は、「approve」アクションでマークを付けて、「git credential」に次の呼び出しで再利用するように指示できます。操作中に資格情報が拒否された場合は、「reject」アクションを使用して、 @samp{git credential} が次の呼び出しで新しいパスワードを要求するようにします。 いずれの場合も、 @samp{git credential} には、ステップ(2)で取得した資格情報の説明(description)(ステップ(1)で提供されたものも含まれます)を指定する必要があります。
@end enumerate

@noindent

@chapheading INPUT/OUTPUT FORMAT

@samp{git credential} は、標準入力/標準出力で(使用するアクションに応じて)資格情報を読み取り および/また は書き込みます。この情報は、 @samp{git credential} がログイン情報(ホスト、プロトコル、パスなど)を取得するキー、または取得する実際の資格データ(ユーザー名/パスワード)のいずれかに対応できます。

資格情報は、1行に1つの属性を持つ、名前付き属性のセットに分割されます。 各属性は、キーと値のペアで指定され、 @samp{=} (等号)記号と、改行で続けます。

キーには、 @samp{=} または改行またはNUL以外の任意のバイトを含めることができます。値には、改行またはNUL以外の任意のバイトを含めることができます。

Attributes with keys that end with C-style array brackets @samp{[]} can have multiple values. Each instance of a multi-valued attribute forms an ordered list of values - the order of the repeated attributes defines the order of the values. An empty multi-valued attribute (@samp{key[]=\n}) acts to clear any previous entries and reset the list.

In all cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file.

Gitは以下の属性を理解します:

@table @asis

@item  @samp{protocol} 
資格情報が使用されるプロトコル(例: @samp{https})。

@item  @samp{host} 
ネットワーク資格情報のリモートホスト名。これには、ポート番号が指定されている場合はそれも含まれます(例: @samp{example.com:8088})。

@item  @samp{path} 
資格情報が使用されるパス。 たとえば、リモートhttpsリポジトリにアクセスする場合、これはサーバー上のリポジトリのパスになります。

@item  @samp{username} 
私達が既に持っている(たとえば、URL、構成、ユーザー、または以前に実行したヘルパーから)場合、資格情報のユーザー名。

@item  @samp{password} 
資格情報のパスワード(私達が保存を要求している場合)。

@item  @samp{password_expiry_utc} 
Generated passwords such as an OAuth access token may have an expiry date. When reading credentials from helpers, @samp{git credential fill} ignores expired passwords. Represented as Unix time UTC, seconds since 1970.

@item  @samp{oauth_refresh_token} 
An OAuth refresh token may accompany a password that is an OAuth access token. Helpers must treat this attribute as confidential like the password attribute. Git itself has no special behaviour for this attribute.

@item  @samp{url} 
この特別な属性が @samp{git credential} によって読み取られると、値はURLとして解析され、その構成要素が読み取られたかのように扱われます(たとえば、 @samp{url=https://example.com} は @samp{protocol=https} と @samp{host=example.com} が提供されたかのように振る舞います)。これは、発信者がURL自体を解析することを回避するのに役立ちます。

注意:プロトコルの指定は必須であり、そして、URLでホスト名が指定されていない場合(たとえば "cert:///path/to/file")、資格情報には、値が空の文字列であるホスト名属性が含まれることに注意してください。

URLから欠落しているコンポーネント(たとえば、上記の例にユーザー名がないとか)は未設定のままになります。

@item  @samp{wwwauth[]} 
When an HTTP response is received by Git that includes one or more @emph{WWW-Authenticate} authentication headers, these will be passed by Git to credential helpers.

Each @emph{WWW-Authenticate} header value is passed as a multi-valued attribute @emph{wwwauth[]}, where the order of the attributes is the same as they appear in the HTTP response. This attribute is @emph{one-way} from Git to pass additional information to credential helpers.
@end table

Unrecognised attributes are silently discarded.

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cvsexportcommit,,,Top
@chapheading Name

git-cvsexportcommit — 単一のコミットをCVSチェックアウトにエクスポートします

@noindent

@chapheading Synopsis

@display
git cvsexportcommit [-h] [-u] [-v] [-c] [-P] [-p] [-a] [-d <cvsroot>]
        [-w <cvs-workdir>] [-W] [-f] [-m <msgprefix>] [<parent-commit>] <commit-id>
@end display


@noindent

@chapheading DESCRIPTION

コミットをGitからCVSチェックアウトにエクスポートし、GitリポジトリからCVSリポジトリへのパッチのマージを容易にします。

@samp{-w} スイッチを使用してCVSチェックアウトの名前を指定するか、CVS作業コピーのルートから実行します。後者の場合、GIT_DIRを定義する必要があります。以下の例を参照してください。

安全寄りに最大限振って、CVSチェックアウトでファイルが変更されておらず、最新であることを確認したら、デフォルトでは自動コミットしません。

バイナリファイルに影響するファイルの追加、削除、およびコミットをサポートします。

コミットがマージコミットの場合は、あなたは @samp{git cvsexportcommit} にchangesetの対象となる親を指定する必要があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-c} 
パッチが正常に適用された場合、自動的にコミットします。ハンクが適用されない場合、またはその他の問題が発生した場合、コミットされません。

@item  @samp{-p} 
パッチを適用するときは、pedantic(衒学的)(paranoid;病的なほど疑り深い)にする。 @samp{--fuzz=0} でpatchを呼び出します。

@item  @samp{-a} 
著者情報を追加します。作者行と(作成者と異なる場合)コミッターをメッセージに追加します。

@item  @samp{-d} 
使用する代替CVSROOTを設定します。これは、 @samp{CVS -d} パラメーターに対応します。 非対称的な方法でCVSを使用する場合を除いて、通常、ユーザーはこれを設定することは無いと思います。

@item  @samp{-f} 
ファイルが最新でない場合でも、強制的にマージします。

@item  @samp{-P} 
直接の親でなくても、親を強制的にコミットします。

@item  @samp{-m} 
コミットメッセージの前に、指定のプレフィックスを付けます。パッチシリーズなどに便利です。

@item  @samp{-u} 
エクスポートを試みる前に、影響を受けるファイルをCVSリポジトリから更新してください。

@item  @samp{-k} 
パッチを適用する前に、CVSチェックアウトの動作でCVSキーワード拡張を逆にします。 (例: $Revision: 1.2.3.4$ は $Revision$ になります)

@item  @samp{-w} 
エクスポートに使用するCVSチェックアウトの場所を指定します。現在のディレクトリがGitリポジトリ内にある場合、このオプションでは、実行前にGIT_DIRを設定する必要はありません。 デフォルトは @samp{cvsexportcommit.cvsdir} の値です。

@item  @samp{-W} 
現在の作業ディレクトリがGitチェックアウトであるだけでなく、CVSチェックアウトでもあることをcvsexportcommitに伝えます。したがって、Gitは続行する前に作業ディレクトリを親コミットにリセットします。

@item  @samp{-v} 
おしゃべりにします。
@end table

@noindent

@chapheading CONFIGURATION

@table @asis

@item  cvsexportcommit.cvsdir 
エクスポートに使用するCVSチェックアウトのデフォルトの場所。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  1つのパッチをCVSにマージします 
@example
$ export GIT_DIR=~/project/.git
$ cd ~/project_cvs_checkout
$ git cvsexportcommit -v <commit-sha1>
$ cvs commit -F .msg <files>
@end example


@item  1つのパッチをCVSにマージします( @samp{-c} および @samp{-w} オプション)。作業ディレクトリはGitリポジトリ内にあります 
@example
        $ git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>
@end example


@item  保留中のパッチをCVSに自動的にマージします — 自分が何をしているかを本当に知っている場合だけにしましょう。 
@example
$ export GIT_DIR=~/project/.git
$ cd ~/project_cvs_checkout
$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v
@end example

@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cvsimport,,,Top
@chapheading Name

git-cvsimport — 別の嫌われ者のSCMからあなたのデータを救難救助する

@noindent

@chapheading Synopsis

@display
git cvsimport [-o <branch-for-HEAD>] [-h] [-v] [-d <CVSROOT>]
              [-A <author-conv-file>] [-p <options-for-cvsps>] [-P <file>]
              [-C <git-repository>] [-z <fuzz>] [-i] [-k] [-u] [-s <subst>]
              [-a] [-m] [-M <regex>] [-S <regex>] [-L <commit-limit>]
              [-r <remote>] [-R] [<CVS-module>]
@end display


@noindent

@chapheading DESCRIPTION

@quotation

@strong{Warning}

@samp{git cvsimport} はcvspsバージョン2を使用しますが、cvspsバージョン2は非推奨とされています。 @samp{git cvsimport} はcvspsバージョン3以降では動作しません。 CVSリポジトリのワンショットインポートを実行している場合は、 @uref{http://cvs2svn.tigris.org/cvs2git.html,cvs2git} または @uref{http://www.catb.org/esr/cvs-fast-export/,cvs-fast-export} の使用を検討してください。
@end quotation

CVSリポジトリをGitにインポートします。新しいリポジトリを作成するか、既存のリポジトリに追加インポートします。

CVSログをパッチセットに分割するには、「cvsps」を使用します。 少なくともバージョン2.1が必要です。

@quotation

@strong{Warning}

特定の状況では、インポートによって誤った結果が発生します。 詳細については、 ISSUES (@pxref{ISSUES}) セクションを参照してください。
@end quotation

@samp{git cvsimport} によって作成されたブランチに対して独自の作業を「絶対に」行ってはいけません。 デフォルトでは、初期インポートにより、自由に操作できるCVSリポジトリのメインブランチから「master」ブランチが作成され、データが入力されます。 その後、自分で増分インポート(incremental imports)またはCVSブランチを @samp{git merge} する必要があります。着信ブランチを分離して保護するために、 @samp{-r} を介して名前付きリモートを指定することをお勧めします。

すべての開発者が読み取り/書き込みできる共有パブリックリポジトリを設定する場合、または git-cvsserver(1) を使用する場合は、インポートされたリポジトリのベアクローンを作成し、 共有リポジトリとしてクローンを作成します。 gitcvs-migration(7) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
おしゃべりにします: cvsimportが何をしているかを報告します。

@item  @samp{-d <CVSROOT>} 
CVSアーカイブのルート。 ローカル(単純なパス)またはリモートの場合があります。 現在、 :local: と :ext: と :pserver: アクセスメソッドのみがサポートされています。 指定しない場合、 @samp{git cvsimport} は @samp{CVS/Root} から読み取ろうとします。 そのようなファイルが存在しない場合は、 @samp{CVSROOT} 環境変数をチェックします。

@item  <CVS-module> 
インポートするCVSモジュール。 <CVSROOT>を基準にしています。 指定しない場合、 @samp{git cvsimport} は @samp{CVS/Repository} からそれを読み取ろうとします。

@item  @samp{-C <target-dir>} 
インポート先のGitリポジトリ。 ディレクトリが存在しない場合は作成されます。 デフォルトは現在のディレクトリです。

@item  @samp{-r <remote>} 
このCVSリポジトリをインポートするGitリモート。 @samp{git clone} がデフォルトで @samp{origin} を使用する方法と同様に、すべてのCVSブランチを remotes/<remote>/<branch> に移動します。

@item  @samp{-o <branch-for-HEAD>} 
(@samp{-r`を介して)リモートが指定されていない場合、CVSからの `HEAD} ブランチはGitリポジトリ内の @samp{origin} ブランチにインポートされます。 これは、 @samp{HEAD} がすでにGitに対して特別な意味を持っているためです。 リモートが指定されると、 @samp{HEAD} ブランチの名前は @samp{remotes/<remote>/master} になり、 @samp{git clone} の振る舞いを真似します。 別のブランチにインポートする場合は、このオプションを使用します。

@samp{-o master} を使用すると、古いcvs2gitツールによって最初に実行されたインポートを続行します。

@item  @samp{-i} 
インポートのみ: インポート後にチェックアウトを実行しません。 このオプションにより、作業ディレクトリとインデックスは変更されずに残り、存在しない場合は作成されません。

@item  @samp{-k} 
排除キーワード(kill keywords): ノイズの多いチェンジセットを回避するために、CVSアーカイブからファイル名に @samp{-kk} が付くファイルを抽出します。 強くお勧めしますが、初期にインポートされたツリーとの互換性を維持するために、デフォルトではオフになっています。

@item  @samp{-u} 
タグ名とブランチ名のアンダースコアをドットに変換します。

@item  @samp{-s <subst>} 
ブランチ名の文字 @samp{/} を <subst> に置き換えます

@item  @samp{-p <options-for-cvsps>} 
cvspsの追加オプション。 オプション @samp{-u} および @samp{-A} は暗黙的であり、ここでは使用しないでください。

複数のオプションを渡す必要がある場合は、それらをコンマ(@samp{,})で区切ります。

@item  @samp{-z <fuzz>} 
タイムスタンプファズ係数(timestamp fuzz factor)を秒単位でcvspsに渡します。 設定されていない場合、cvspsのデフォルトは300秒です。

@item  @samp{-P <cvsps-output-file>} 
cvspsを呼び出す代わりに、提供されているcvsps出力ファイルを読み取ります。 デバッグ時や、cvspsがcvsimportの外部で処理されている場合に便利です。

@item  @samp{-m} 
コミットメッセージに基づいてマージを検出しようとします。 このオプションは、コミットメッセージからソースブランチ名をキャプチャしようとするデフォルトの正規表現を有効にします。

@item  @samp{-M <regex>} 
カスタム正規表現を使用したコミットメッセージに基づいてマージを検出しようとします。 @samp{-m} と一緒に使用して、デフォルトの正規表現を有効にすることもできます。スラッシュ(@samp{/})をエスケープする必要があります。

正規表現は、ソースブランチ名を$1でキャプチャする必要があります。

このオプションは、複数の検出正規表現を提供するために複数回使用できます。

@item  @samp{-S <regex>} 
正規表現にマッチするパスをスキップします。

@item  @samp{-a} 
最近のものを含むすべてのコミットをインポートします。 cvsimportはデフォルトで、タイムスタンプが10分未満のコミットをスキップします。

@item  @samp{-L <limit>} 
インポートされるコミットの数を制限します。 cvsimportがメモリをリークする場合の回避策です。

@item  @samp{-A <author-conv-file>} 
CVSは、デフォルトで、コミットログを書き込むときにUnixユーザー名を使用します。 このオプションとauthor-conv-fileを使用すると、CVSに記録されている名前が作者名(author)と電子メールアドレス(e-mail)と、オプションのタイムゾーン(time zone)にマップされます:

@example
        exon=Andreas Ericsson <ae@@op5.se>
        spawn=Simon Pawn <spawn@@frog-pond.org> America/Chicago
@end example


@samp{git cvsimport} は、これらの作者が GIT_AUTHOR_NAME と GIT_AUTHOR_EMAIL を最初から正しく設定していたかのように見せかけます。 タイムゾーンが指定されている場合は、GIT_AUTHOR_DATE に対応するオフセットが適用されます。

便宜上、このデータは @samp{-A} オプションが提供されるたびに @samp{$GIT_DIR/cvs-authors} に保存され、 @samp{git cvsimport} が実行されるたびに同じファイルから読み取られます。

後で @samp{git cvsexportcommit} を使用して変更をCVSに再度エクスポートする場合は、この機能を使用することはお勧めしません。

@item  @samp{-R} 
CVSリビジョン番号から新しく作成されたGitコミットIDへのマッピングを含む @samp{$GIT_DIR/cvs-revisions} ファイルを生成します。 生成されたファイルには、インポートされた（ファイル名、リビジョン）のペアごとに1行が含まれます。 各行は以下のようになります

@example
src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7
@end example


追加インポート(incremental imports)を行うときに使用するために、リビジョンデータがすでに存在する場合はファイルに追加されます。

このオプションは、コミットメッセージ、バグ追跡システム、電子メールアーカイブなどにCVSリビジョン番号が保存されている場合に役立つことがあります。

@item  @samp{-h} 
短い使用法メッセージを印刷して終了(exit)します。
@end table

@noindent

@chapheading OUTPUT

@samp{-v} が指定されている場合、スクリプトは実行内容を報告します。

それ以外の場合、成功はUnixの方法で示されます。つまり、終了ステータスがゼロで終了するだけです。

@noindent

@chapheading ISSUES

タイムスタンプ関連の問題:

@itemize 

@item
CVSリポジトリ内のコミットのタイムスタンプが、コミットの順序付けに使用できるほど安定していない場合、変更が間違った順序で表示される可能性があります。

@item
いずれかのファイルが複数回「cvsインポート」された場合(たとえば、複数のベンダーリリースのインポート)、HEADに間違ったコンテンツが含まれています。

@item
異なるファイルのタイムスタンプの順序がコミット一致時間ウィンドウ(commit matching time window)内でリビジョンの順序と交差する場合、コミットの順序が間違っている可能性があります。
@end itemize

ブランチ関連の問題:

@itemize 

@item
コミットが行われていないブランチはインポートされません。

@item
分岐点(branching point)からのすべてのファイルは、CVSに追加されていない場合でも、ブランチに追加されます。

@item
これは、子ブランチが作成された「後に」ソースブランチに追加されたファイルに適用されます。以前に子ブランチでコミットが行われなかった場合、それらはgitの子ブランチに誤って追加されます。
@end itemize

タグ関連の問題:

@itemize 

@item
同じリビジョンの複数のタグはインポートされません。
@end itemize

これらの問題のいずれかがインポートするリポジトリに当てはまると思われる場合は、cvs2gitの使用を検討してください:

@itemize 

@item
cvs2git (cvs2svnの一部です), @samp{http://subversion.apache.org/}
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-cvsserver,,,Top
@chapheading Name

git-cvsserver — Git用のCVSサーバーエミュレーター

@noindent

@chapheading Synopsis

SSH:

@display
export CVS_SERVER="git cvsserver"
cvs -d :ext:user@@server/path/repo.git co <HEAD_name>
@end display


pserver (/etc/inetd.conf):

@display
cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver
@end display


Usage:

@display
git-cvsserver [<options>] [pserver|server] [<directory> …]
@end display


@noindent

@chapheading DESCRIPTION

このアプリケーションは、GitのCVSエミュレーションレイヤーです。

非常に機能的です。 ただし、 すべてのメソッドが実装されているわけではなく、 実装されているメソッドについては、 すべてのスイッチが実装されているわけではありません。

テストは、 CLI CVSクライアントと、 Eclipse CVSプラグインの両方を使用して行われました。 ほとんどの機能は、これらのクライアントの両方で正常に機能します。

@noindent

@chapheading OPTIONS

これらのオプションはすべて、サーバー側で適用された場合にのみ意味があります。 これらは、 git-daemon(1) オプションにできるだけ似るように実装されています。

@table @asis

@item  @samp{--base-path <path>} 
要求された CVSROOT の前に「path」を追加します

@item  @samp{--strict-paths} 
サブディレクトリへの再帰を許可しない

@item  @samp{--export-all} 
構成で @samp{gitcvs.enabled} をチェックしないでください。 このオプションを使用する場合は、許可されるディレクトリのリスト(list of allowed directories)(下記参照)も指定する必要があります。

@item  @samp{-V} 
@itemx  @samp{--version} 
バージョン情報を出力して終了(exit)します

@item  @samp{-h} 
@itemx  @samp{-H} 
@itemx  @samp{--help} 
使用法を出力して終了(exit)します

@item  <directory> 
残りの引数は、ディレクトリのリストを提供します。 ディレクトリが指定されていない場合は、すべてが許可されます。 これらのディレクトリ内のリポジトリでは、 @samp{--export-all} が指定されていない限り、 引き続き @samp{gitcvs.enabled} 設定オプションが必要です。
@end table

@noindent

@chapheading LIMITATIONS

CVS クライアントは、タグ付け、ブランチ、Git マージを実行することはできません。

「git-cvsserver」は、GitブランチをCVSモジュールにマップします。 これは、ほとんどのCVSユーザーが期待するものとは大きく異なります。これは、CVSモジュールでは通常1つ以上のディレクトリを表すためです。

@noindent

@chapheading INSTALLATION

@enumerate 

@item
pserverを介してCVSアクセスを提供する場合は、 /etc/inetd.conf に以下のような行を追加します

@example
   cvspserver stream tcp nowait nobody git-cvsserver pserver
@end example


注意: 一部のinetdサーバーでは、 argv[0] の値(つまり、プログラムが実行されたと想定する名前)とは関係なく、実行可能ファイルの名前を指定できます。 この場合、 /etc/inetd.conf の正しい行は以下のようになります

@example
   cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver
@end example


デフォルトでは、匿名(anonymous)アクセスのみがpserverによって提供されます。 コミットするには、pserverアカウントを作成する必要があります。 cvsserverに書き込みを許可するリポジトリの構成ファイルに gitcvs.authdb 設定を追加するだけです。たとえば以下のようにします:

@example
   [gitcvs]
        authdb = /etc/cvsserver/passwd
@end example


これらのファイルの形式は、ユーザー名の後に暗号化されたパスワードが続きます。以下に例を示します:

@example
   myuser:sqkNi8zPf01HI
   myuser:$1$9K7FzU28$VfF6EoPYCJEYcVQwATgOP/
   myuser:$5$.NqmNH1vwfzGpV8B$znZIcumu1tNLATgV2l6e1/mY8RzhUDHMOaVOeL1cxV3
@end example


You can use the @emph{htpasswd} facility that comes with Apache to make these files, but only with the -d option (or -B if your system supports it).

できれば、プラットフォームでパスワード・ハッシュの作成を管理するシステム固有のユーティリティ(Linux の mkpasswd や、 OpenBSD の encrypt や、NetBSD の pwhash など)を使用して、適切な場所に貼り付け(paste)します。

次に、pserverメソッドを介してあなたのパスワードを入力します。以下に例を示します:

@example
   cvs -d:pserver:someuser:somepassword@@server:/path/repo.git co <HEAD_name>
@end example


PATHにGitツールを含める以外に、SSHアクセスに特別な設定は必要ありません。 CVS_SERVER環境変数を受け入れないクライアントがある場合は、 @samp{git-cvsserver} の名前を @samp{cvs} に変更できます。

注意: 新しいCVSバージョン(>= 1.12.11)では、CVSROOTで直接CVS_SERVERを指定することもサポートしています

@example
   cvs -d ":ext;CVS_SERVER=git cvsserver:user@@server/path/repo.git" co <HEAD_name>
@end example


これは、あなたの @samp{CVS/Root} ファイルに保存されるので、常に正しい環境変数を設定することを心配する必要がないという利点があります。 @samp{git-shell} に制限されている SSH ユーザは CVS_SERVER でデフォルトを上書きする必要はありません(すべきでもありません)。 なぜなら @samp{git-shell} は @samp{cvs} を @samp{git-cvsserver} と理解して、相手側が本当の @samp{cvs} より良いものを実行していると見せかけているからです。

@item
CVSからアクセスできるようにするリポジトリごとに、リポジトリの構成を編集して、以下のセクションを追加する必要があります。

@example
   [gitcvs]
        enabled=1
        # optional for debugging
        logFile=/path/to/logfile
@end example


注意: @samp{git-cvsserver} を呼び出す各ユーザーが、ログファイルとデータベースへの書き込みアクセス権を持っていることを確認する必要があります(Database Backend (@pxref{DATABASE BACKEND}) を参照してください)。SSH経由の書き込みアクセスを提供する場合は、 もちろん、ユーザーはGitリポジトリ自体への書き込みアクセス権も必要です。

また、 @samp{cvs commit} が機能するには、各リポジトリが「ベアリポジトリ」(Gitインデックスファイルなし)であることを確認する必要があります。 gitcvs-migration(7) を参照してください。

特定のアクセス方法では、すべての構成変数をオーバーライドすることもできます。 有効なメソッド名は @samp{ext} (SSHアクセス用) と @samp{pserver} です。 以下の設定例では、SSH経由のアクセスを許可しながら、pserverアクセスを無効にします。

@example
   [gitcvs]
        enabled=0

   [gitcvs "ext"]
        enabled=1
@end example


@item
あなたがチェックアウトコマンドで、CVSROOT/CVS_SERVER を直接指定しなくて、自動的に あなたの @samp{CVS/Root} ファイルに保存した場合は、環境で明示的に設定する必要があります。 CVSROOTは通常どおりに設定する必要がありますが、ディレクトリは適切なGitリポジトリを指している必要があります。 上記のように、 @samp{git-shell} に制限されて無いSSHクライアントの場合、 CVS_SERVERを @samp{git-cvsserver} に設定する必要があります。

@example
   export CVSROOT=:ext:user@@server:/var/git/project.git
   export CVS_SERVER="git cvsserver"
@end example


@item
コミットを行うSSHクライアントの場合、サーバー側の .ssh/environment ファイル(またはシェルによっては .bashrc など)が、 GIT_AUTHOR_NAMEとGIT_AUTHOR_EMAILとGIT_COMMITTER_NAMEとGIT_COMMITTER_EMAIL の為に適切な値をエクスポートすることを確認します。 ログインシェルがbashであるSSHクライアントの場合、.bashrc が妥当な代替手段となる可能性があります。

@item
これで、クライアントはプロジェクトをチェックアウトできるようになります。 CVSの「モジュール」名を使用して、チェックアウトするGitの「ヘッド」を示します。 これにより、 @samp{-d <dir_name>} で特に指定しない限り、新しくチェックアウトしたディレクトリの名前も設定されます。 たとえば、以下は「master」ブランチを「project-master」ディレクトリにチェックアウトします:

@example
   cvs co -d project-master master
@end example

@end enumerate

@noindent

@chapheading DATABASE BACKEND

@samp{git-cvsserver} は、Gitヘッド(つまり、CVSモジュール)ごとに1つのデータベースを使用して、リポジトリに関する情報を格納し、一貫したCVSリビジョン番号を維持します。 データベースは、コミットするたびに更新(つまり、書き込み)する必要があります。

(@samp{git-cvsserver} を使用するのではなく、)コミットが @samp{git} を使用して直接行われる場合、アクセス方法や要求された操作に関係なく、 @samp{git-cvsserver} による次のリポジトリアクセスで更新を行う必要があります。

つまり、(たとえば、pserverメソッドを使用して、)読み取りアクセスのみを提供している場合でも、 @samp{git-cvsserver} はデータベースへの書き込みアクセス権を持っている必要があります(それ以外の場合は、 @samp{git-cvsserver} が実行されるたびにデータベースが最新であることを確認する必要があります)。

デフォルトでは、Gitディレクトリにある @samp{gitcvs.<module_name>.sqlite} という名前のSQLiteデータベースを使用します。 SQLiteバックエンドは書き込み時にデータベースファイルと同じディレクトリに一時ファイルを作成するため、 @samp{git-cvsserver} を使用するユーザーにディレクトリへの書き込みアクセスを許可せずにデータベースファイルへの書き込みアクセスを許可するだけでは不十分な場合があることに注意してください 。

追跡しているブランチが変更された後、データベースを一貫した形式で確実に再生成することはできません。 例:マージされたブランチの場合、 @samp{git-cvsserver} は開発の1つのブランチのみを追跡し、 @samp{git merge} の後、増分更新されたデータベースは、最初から再生成されたデータベースとは異なるブランチを追跡し、一貫性のないCVSリビジョン番号を引き起こす可能性があります。 @samp{git-cvsserver} には、マージ前に段階的に実行された場合にどのブランチを選択したかを知る方法がありません。 したがって、データベースを完全にまたは部分的に(古いバックアップから)再生成する必要がある場合は、既存のCVSサンドボックスを疑う必要があります。

以下の構成変数を使用してデータベースバックエンドを構成できます:

@noindent

@heading Configuring database backend

@samp{git-cvsserver} は Perl DBI モジュールを使用します。 これらの変数を変更する場合、特に @samp{DBI->connect()} については、そのドキュメントもお読みください。

@table @asis

@item  gitcvs.dbName 
データベース名。 正確な意味は、選択したデータベースドライバーによって異なります。SQLiteの場合、これはファイル名です。 変数置換をサポートします(下記参照)。 セミコロン(@samp{;})を含めることはできません。 デフォルト: ：@samp{%Ggitcvs.%m.sqlite}

@item  gitcvs.dbDriver 
使用DBIドライバー。 ここで使用可能なドライバーを指定できますが、機能しない場合があります。 cvsserverは「DBD::SQLite」でテストされ、「DBD::Pg」で動作報告があり、「DBD::mysql」で動作しないことが報告されています。 これは実験的な機能と見なしてください。 コロン(@samp{:})を含めることはできません。 デフォルト: @samp{SQLite}

@item  gitcvs.dbuser 
データベースユーザー。 SQLiteにはデータベースユーザーの概念がないため、 @samp{dbDriver} を設定する場合にのみ役立ちます。 変数置換(variable substitution)をサポートします(下記参照)。

@item  gitcvs.dbPass 
データベースのパスワード。 SQLiteにはデータベースパスワードの概念がないため、 @samp{dbDriver} を設定する場合にのみ役立ちます。

@item  gitcvs.dbTableNamePrefix 
データベーステーブル名の接頭辞。 変数置換をサポートします(下記参照)。 アルファベット以外の文字(non-alphabetic characters)はすべてアンダースコアに置き換えられます。
@end table

すべての変数は、アクセス方法ごとに設定することもできます。 上記 (@pxref{configaccessmethod}) を参照してください。

@noindent

@subheading Variable substitution

@samp{dbDriver} と @samp{dbUser} では、以下の変数を使用できます:

@table @asis

@item  %G 
Gitディレクトリ名

@item  %g 
Gitディレクトリ名。英数字 と @samp{.} と @samp{-} を除くすべての文字が @samp{_} に置き換えられます(これにより、ディレクトリ名をファイル名として使用することが容易になります)。

@item  %m 
CVSモジュール/Gitヘッド名

@item  %a 
アクセス方法("ext" または "pserver" のいずれか)

@item  %u 
@samp{git-cvsserver} を実行しているユーザーの名前。 名前を判別できない場合は、数値uidが使用されます。
@end table

@noindent

@chapheading ENVIRONMENT

これらの変数により、状況によってはコマンドラインオプションが不要になり、git-shellを使用して使用を制限しやすくなります。

@table @asis

@item  GIT_CVSSERVER_BASE_PATH 
この変数は @samp{--base-path} の引数を置き換えます。

@item  GIT_CVSSERVER_ROOT 
この変数は、単一のディレクトリを指定し、@samp{<directory>...} 引数リストを置き換えます。 @samp{--export-all} が指定されていない限り、リポジトリには引き続き @samp{gitcvs.enabled} 設定オプションが必要です。
@end table

これらの環境変数が設定されている場合、対応するコマンドライン引数は使用されない場合があります。

@noindent

@chapheading ECLIPSE CVS CLIENT NOTES

Eclipse CVSクライアントでチェックアウトを取得するには:

@enumerate 

@item
メニューの "Create a new project → From CVS checkout"

@item
新しい場所(location)を作成します。 適切なプロトコルを選択する方法の詳細については、以下のnotesを参照してください。

@item
利用可能な「モジュール」を参照します。 リポジトリ内のヘッドのリストが表示されます。 そこからツリーを閲覧することはできません。 表示されるのはヘッドだけです。

@item
チェックアウトする ブランチ/タグ を尋ねられたら、 @samp{HEAD} を選択します。 .project ファイルのコミットを回避するには、「launch commit wizard」のチェックを外します。
@end enumerate

プロトコルに関する注意: pserver経由で匿名アクセスを使用している場合は、それを選択するだけです。 SSHアクセスを使用している場合は、「ext」プロトコルを選択し、 Preferences→Team→CVS→ExtConnectionペインで「ext」アクセスを構成する必要があります。 CVS_SERVERを @samp{gitcvsserver} に設定します。 なお、 @samp{ext} を使用する場合、パスワードのサポートは良くないので、SSHキーの設定を必ずしてください。

または、Eclipseが提供する非標準のextsshプロトコルを使用することもできます。 その場合、CVS_SERVERは無視され、サーバー上のcvsユーティリティを @samp{git-cvsserver} に置き換えるか、 @samp{.bashrc} を操作して、「cvs」を呼び出すと「git-cvsserver」が効果的に呼び出されるようにする必要があります。

@noindent

@chapheading 動作が確認されているクライアント

@itemize 

@item
CVS 1.12.9 on Debian

@item
CVS 1.11.17 on MacOSX (from Fink package)

@item
Eclipse 3.0, 3.1.2 on MacOSX (「Eclipse CVS Client Notes」参照)

@item
TortoiseCVS
@end itemize

@noindent

@chapheading OPERATIONS SUPPORTED

checkout, diff, status, update, log, add, remove, commit を含む、通常の使用に必要なすべての操作がサポートされています。

CVSタグまたはリビジョン番号(通常は @samp{-r})を読み取るほとんどのCVSコマンド引数は機能し、任意のgit refspec(タグ、ブランチ、コミットIDなど)もサポートします。 ただし、デフォルト以外のブランチのCVSリビジョン番号は十分にエミュレートされておらず、cvsログにはタグまたはブランチがまったく表示されません。 (非メインブランチのCVSリビジョン番号は、表面的にはCVSリビジョン番号に似ていますが、実際には、ブランチポイント以降のリビジョン数を表すのではなく、git commit IDを直接エンコードします。)

注意: 特定のブランチをチェックアウトする方法は2つあることに注意してください。 この文書の他の場所で説明されているように、cvs checkoutの「module」パラメーターはブランチ名として解釈され、メインブランチになります。 cvs update -rを使用して別のブランチを一時的にスティッキーにした場合でも、特定のサンドボックスのメインブランチのままです。 あるいは、モジュールがまだ「メイン」ブランチである場合でも、-r引数は実際にチェックアウトする他のブランチを示すことができます。 （現在実装分の)トレードオフ: 新しい「モジュール」ごとに、指定されたモジュールの履歴を持つ新しいデータベースがディスク上に作成され、データベースが作成された後、そのメインブランチに対する操作は高速になります。 または、-rは余分なディスク領域を必要としませんが、cvs updateなどの多くの操作では大幅に遅くなる可能性があります。

CVSで許可されていない文字を含む git refspec を参照する場合は、2つのオプションがあります。 まず、適切なCVS @samp{-r} 引数に直接 git refspec を提供するだけで機能する場合があります。 一部のCVSクライアントは、引数の健全性チェックをあまり行っていないようです。 次に、それが失敗した場合は、CVSタグで有効な文字のみを使用する特殊文字エスケープメカニズムを使用できます。 書式の4文字または5文字のシーケンス(アンダースコア(@samp{_})と、ダッシュ(@samp{-})と、1〜2字と、ダッシュ(@samp{-}))は、1〜2字に基づいてさまざまな文字をエンコードできます: スラッシュ(@samp{/})の場合は @samp{s} 、または ピリオド(@samp{.})の場合は @samp{p} 、または アンダースコア(@samp{_})の場合は @samp{u} 、または 2桁の16進数で表される任意のバイト値(通常はASCIIコード。またはUTF-8でエンコードされた文字の一部)。

従来の監視操作(edit、watch 関連)はサポートされていません。 エクスポートとタグ付け(タグとブランチ)は、この段階ではサポートされていません。

@noindent

@heading CRLF Line Ending Conversions

デフォルトでは、サーバーはすべてのファイルに対して @samp{-k} モードを空白のままにします。これにより、CVSクライアントはそれらをテキストファイルとして扱い、一部のプラットフォームでは行末変換の対象になります。

@samp{gitcvs.usecrlfattr} 構成変数を設定することにより、サーバーで行末変換属性を使用してファイルの @samp{-k} モードを設定することができます。 行末変換の詳細については、 gitattributes(5) を参照してください。

あるいは、 @samp{gitcvs.usecrlfattr} 構成が有効になっていない場合、または属性でファイル名の自動検出が許可されていない場合、サーバーはデフォルト設定に @samp{gitcvs.allBinary} 構成を使用します。 @samp{gitcvs.allBinary} が設定されている場合、特に指定されていないファイルはデフォルトで @samp{-kb} モードになります。 それ以外の場合、 @samp{-k} モードは空白のままになります。 ただし、 @samp{gitcvs.allBinary} が @samp{guess} に設定されている場合、ファイルの内容に基づいて正しい @samp{-k} モードが推測されます。

cvsとの一貫性を最大限に保つには、 @samp{gitcvs.usecrlfattr} をtrueに設定し、 @samp{gitcvs.allBinary} を @samp{guess} に設定して、デフォルトをオーバーライドするのがおそらく最善です。

@noindent

@chapheading DEPENDENCIES

@samp{git-cvsserver} は DBD::SQLite に依存します。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-daemon,,,Top
@chapheading Name

git-daemon — Gitリポジトリ用のほんまにシンプルなサーバー

@noindent

@chapheading Synopsis

@display
git daemon [--verbose] [--syslog] [--export-all]
             [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]
             [--strict-paths] [--base-path=<path>] [--base-path-relaxed]
             [--user-path | --user-path=<path>]
             [--interpolated-path=<pathtemplate>]
             [--reuseaddr] [--detach] [--pid-file=<file>]
             [--enable=<service>] [--disable=<service>]
             [--allow-override=<service>] [--forbid-override=<service>]
             [--access-hook=<path>] [--[no-]informative-errors]
             [--inetd |
              [--listen=<host_or_ipaddr>] [--port=<n>]
              [--user=<user> [--group=<group>]]]
             [--log-destination=(stderr|syslog|none)]
             [<directory>…]
@end display


@noindent

@chapheading DESCRIPTION

通常はポート「DEFAULT_GIT_PORT」(9418)でリッスンする非常に単純なTCP Gitデーモン。サービスを要求する接続を待機し、有効になっている場合はそのサービスを提供します。

ディレクトリにマジックファイル @samp{git-daemon-export-ok} があることを確認し、この方法でエクスポートのマークが明示されていないGitディレクトリのエクスポートを拒否します(@samp{--export-all} パラメーターが指定されていない場合)。 いくつかのディレクトリ・パスを「git daemon」の引数として渡すと、提供するのはそれらのディレクトリ内のリポジトリに限定されます。

デフォルトでは、 @samp{upload-pack} サービスのみが有効になっており、 @samp{git fetch} や @samp{git pull} や @samp{git clone} から呼び出される @samp{git fetch-pack} と @samp{git ls-remote} クライアントにサービスを提供します。

これは、読み取り専用の更新、つまりGitリポジトリからのプルに最適です。

@samp{git archive} を提供するための @samp{upload-archive} もあります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--strict-paths} 
パスを正確に一致させ(つまり、 実際のパスが "/foo/repo.git" または "/foo/repo/.git" の場合は "/foo/repo" を許可しないでください)、 そしてユーザー相対パスを許可しないでください。 このオプションが有効で、かつ、ディレクトリ引数が指定されていない場合、「git daemon」は起動を拒否します。

@item  @samp{--base-path=<path>} 
指定されたパスを基準にして、すべてのパス要求を再マップします。これは一種の "Git root" です。example.comで @samp{--base-path=/srv/git} を伴って @samp{git daemon} を実行し、後で @samp{git://example.com/hello.git} をプルしようと試みると、 @samp{git daemon} はパスを @samp{/srv/git/hello.git} として解釈します。

@item  @samp{--base-path-relaxed} 
@samp{--base-path} が有効になっていて、リポジトリを探すのに失敗した場合、このオプションを使用すると、 @samp{git daemon} はベースパスを前に付けずに探索を試みます。 これは、古いパスを許可したまま、 @samp{--base-path} 使用に切り替える場合に便利です。

@item  @samp{--interpolated-path=<pathtemplate>} 
仮想ホスティングをサポートするために、補完されたパステンプレートを使用して、代替パスを動的に構築できます。テンプレートは、クライアントから提供されたターゲットホスト名の %H をサポートしますが、すべて小文字に変換されます。正規ホスト名の場合は %CH、サーバーのIPアドレスの場合は %IP、ポート番号の場合は %P、名前付きリポジトリの絶対パスの場合は %D です。補完後、パスはディレクトリのリストに対して検証されます。

@item  @samp{--export-all} 
@samp{git-daemon-export-ok} ファイルがない場合でも、 (@samp{objects} と @samp{refs} サブディレクトリがある、)Gitリポジトリのように見えるすべてのディレクトリからのプルを許可します。

@item  @samp{--inetd} 
サーバーをinetdサービスとして実行します。@samp{--syslog} の指定を含んでいます(@samp{--log-destination=} でオーバーライドされる場合があります)。 @samp{--detach} 、 @samp{--port} 、 @samp{--listen} 、 @samp{--user} 、 @samp{--group} オプションとは互換性がありません。

@item  @samp{--listen=<host_or_ipaddr>} 
特定のIPアドレスまたはホスト名でリッスンします。IPアドレスは、IPv4アドレス、またはサポートされている場合はIPv6アドレスのいずれかになります。IPv6がサポートされていない場合、 @samp{--listen=hostname} もサポートされていないため、 @samp{--listen} にはIPv4アドレスを指定する必要があります。このオプションは複数回与えることができます。 @samp{--inetd} オプションと互換性がありません。

@item  @samp{--port=<n>} 
代わりのポートでリッスンします。 @samp{--inetd} オプションと互換性がありません。

@item  @samp{--init-timeout=<n>} 
接続が確立されてからクライアント要求が受信されるまでのタイムアウト(秒単位)(基本的には即時である必要があるため、通常はかなり低い値)。

@item  @samp{--timeout=<n>} 
特定のクライアントサブリクエスト(client sub-requests)のタイムアウト(秒単位)。これには、サーバーがサブリクエストを処理するのにかかる時間と、次のクライアントのリクエストを待つために費やされる時間が含まれます。

@item  @samp{--max-connections=<n>} 
同時クライアントの最大数。デフォルトは32です。制限しない場合はゼロに設定します。

@item  @samp{--syslog} 
@samp{--log-destination=syslog} の短縮形。

@item  @samp{--log-destination=<destination>} 
指定した宛先にログメッセージを送信します。 このオプションは @samp{--verbose} を意味しないため、デフォルトではエラー状態のみがログに記録されることに注意してください。 <destination> は以下のいずれかである必要があります:

@table @asis

@item  stderr 
標準エラーに書き込みます。 @samp{--detach} が指定されている場合、プロセスは実際の標準エラーから切断され、この宛先は実質的に @samp{none} と同等になることに注意してください。

@item  syslog 
@samp{git-daemon} 識別子を使用してsyslogに書き込みます。

@item  none 
すべてのログを無効にします。
@end table

デフォルトの宛先は、 @samp{--inetd} または @samp{--detach} が指定されている場合、は @samp{syslog} であり、それ以外の場合は @samp{stderr} です。

@item  @samp{--user-path} 
@itemx  @samp{--user-path=<path>} 
~user 表記をリクエストで使用できるようにします。パラメータなしで指定した場合、 git://host/~alice/foo git：// host / ~ alice / fooへのリクエストは、ユーザー @samp{alice} のホームディレクトリにある @samp{foo} リポジトリへのアクセスリクエストと見なされます。 @samp{--user-path=path} が指定されている場合、同じリクエストが、ユーザー @samp{alice} のホームディレクトリにある @samp{path/foo} リポジトリにアクセスするリクエストと見なされます。

@item  @samp{--verbose} 
着信接続と要求されたファイルに関する詳細をログに記録します。

@item  @samp{--reuseaddr} 
リスニングソケットをバインドするときは SO_REUSEADDR を使用します。 これにより、古い接続がタイムアウトするのを待たずにサーバーを再起動できます。

@item  @samp{--detach} 
シェルからデタッチします。 @samp{--syslog} オプションの指定を含んでいます。

@item  @samp{--pid-file=<file>} 
プロセスIDを <file> に保存します。デーモンが @samp{--inetd} で実行されている場合は無視されます。

@item  @samp{--user=<user>} 
@itemx  @samp{--group=<group>} 
サービスループに入る前に、デーモンのuidとgidを変更します。 @samp{--group} なしで @samp{--user} のみが指定された場合、ユーザーのプライマリグループIDが使用されます。オプションの値は @samp{getpwnam(3)} と @samp{getgrnam(3)} に与えられ、数値IDはサポートされていません。

これらのオプションを指定すると、 @samp{--inetd} と一緒に使用するとエラーになります。 同じことを実現するには、必要に応じて、 @samp{git daemon} を生成する前に、inetデーモンの機能を使用します。

ユーザーIDを切り替える多くのプログラムと同様に、デーモンは、(例えば、@samp{upload-pack} や`receive-pack` の) gitプログラムを実行するときに @samp{$HOME} などの環境変数をリセットしません。このオプションを使用する場合は、デーモンを起動する前に、 @samp{HOME} を @samp{<user>} のホームディレクトリを指すように設定、およびエクスポートし、そのディレクトリ内のGit構成ファイルが @samp{<user>} によって読み取り可能であることを確認してください。

@item  @samp{--enable=<service>} 
@itemx  @samp{--disable=<service>} 
デフォルトでサイト全体のサービスを 有効/無効 にします。サイト全体で無効にされたサービスは、オーバーライド可能とマークされていて、リポジトリが構成アイテムでサービスを有効にしている場合でも、リポジトリごとに有効にできることに注意してください。

@item  @samp{--allow-override=<service>} 
@itemx  @samp{--forbid-override=<service>} 
リポジトリごとの構成でサイト全体のデフォルトをオーバーライドすることを 許可/禁止 します。デフォルトでは、すべてのサービスがオーバーライドされる場合があります。

@item  @samp{--[no-]informative-errors} 
informative-errorsがオンになっている場合、git-daemonはより詳細なエラーをクライアントに報告し、「no such repository」(そのようなリポジトリがない)と「repository not exported」(リポジトリがエクスポートされていない)などの条件を区別します。これはクライアントにとってより便利ですが、エクスポートされていないリポジトリの存在に関する情報が漏洩する可能性があります。informative-errorsが有効になっていない場合、すべてのエラーは「access denied」とクライアントに報告します。 デフォルトは @samp{--no-informative-errors} です。

@item  @samp{--access-hook=<path>} 
クライアントが接続するたびに、最初に、<path> で指定された外部コマンドを実行します。コマンドライン引数として、サービス名("upload-pack"など)や、リポジトリへのパスや、ホスト名(%H)や、正規のホスト名(%CH)や、IPアドレス(%IP)や、TCPポート(%P)を、指定します。外部コマンドは、ゼロ以外のステータスで終了することによってサービスを拒否する(またはゼロ・ステータスで終了することによってサービスを許可する)ことを決定できます。また $REMOTE_ADDR や @samp{$REMOTE_PORT} 環境変数を調べて、この決定を行うときにリクエスト側(requestor)ついて調べることもできます。

外部コマンドはオプションで、サービスを拒否したときにエラーメッセージとしてリクエスト側(requestor)に送信される1行を標準出力に書き込むことができます。

@item  <directory> 
残りの引数は、ディレクトリのリストを提供します。 ディレクトリが指定されている場合、 @samp{git-daemon} プロセスは、 要求されたディレクトリがこれらのディレクトリのいずれかに含まれている場合にのみ、 リクエストされたディレクトリをサーブします。 @samp{--strict-paths} が指定されている場合、リクエストされたディレクトリはこれらのディレクトリのいずれかと正確に一致する必要があります。
@end table

@noindent

@chapheading SERVICES

これらのサービスは、このコマンドのコマンドラインオプションを使用してグローバルに 有効/無効 にできます。よりきめ細かい制御が必要な場合(たとえば、デーモンがサービスを提供するいくつかの選択されたリポジトリでのみ @samp{git archive} を実行できるようしたい時)、リポジトリごとの構成ファイルを使用して、それらを有効または無効にできます。

@table @asis

@item  upload-pack 
これは、 @samp{git fetch-pack} と @samp{git ls-remote} クライアントにサービスを提供します。デフォルトで有効になっていますが、リポジトリでは @samp{daemon.uploadpack `構成アイテムを `false} に設定することで無効にできます。

@item  upload-archive 
これは @samp{git archive --remote} を提供します。 デフォルトでは無効になっていますが、リポジトリでは、 @samp{daemon.uploadarch} 構成アイテムを @samp{true} に設定することで有効にできます。

@item  receive-pack 
これは @samp{git send-pack} クライアントにサービスを提供し、匿名プッシュを可能にします。プロトコルに認証が「ない」ため、デフォルトでは無効になっています(つまり、参照の削除を含め、誰でもリポジトリに何でもプッシュできます)。これは、誰もが友好的であるクローズドLAN設定のみを対象としています。このサービスは、 @samp{daemon.receivepack} 構成アイテムを @samp{true} に設定することで有効にできます。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  ここでは /etc/services の下に構築するものと仮定します 
@example
$ grep 9418 /etc/services
git             9418/tcp                # Git Version Control System
@end example


@item  @samp{git daemon} as inetd server 
@samp{/pub/foo} または @samp{/pub/bar} 内の任意のリポジトリを処理する inetd サービスとして「git daemon」を設定するには、 以下のようなエントリを @samp{/etc/inetd} に、すべて 1 行で配置します:

@example
        git stream tcp nowait nobody  /usr/bin/git
                git daemon --inetd --verbose --export-all
                /pub/foo /pub/bar
@end example


@item  @samp{git daemon} as inetd server for virtual hosts 
異なる仮想ホスト @samp{www.example.com} と @samp{www.example.org} のリポジトリを処理するinetdサービスとして「git daemon」を設定するには、以下のようなエントリをすべて１行で @samp{/etc/inetd} に配置します:

@example
        git stream tcp nowait nobody /usr/bin/git
                git daemon --inetd --verbose --export-all
                --interpolated-path=/pub/%H%D
                /pub/www.example.org/software
                /pub/www.example.com/software
                /software
@end example


この例では、ルートレベルのディレクトリ @samp{/pub} には、サポートされている各仮想ホスト名のサブディレクトリが含まれています。さらに、両方のホストは、リポジトリを単に @samp{git://www.example.com/software/repo.git} として公開します。 1.4.0より前のクライアントの場合、 @samp{/software} から適切なデフォルトリポジトリへのシンボリックリンクも作成できます。

@item  @samp{git daemon} as regular daemon for virtual hosts 
IPアドレスに基づいて複数の仮想ホストのリポジトリを処理する通常の非inetdサービスとして「git daemon」を設定するには、以下のようにデーモンを起動します:

@example
        git daemon --verbose --export-all
                --interpolated-path=/pub/%IP/%D
                /pub/192.168.1.200/software
                /pub/10.10.220.23/software
@end example


IPアドレスに基づいて複数の仮想ホストのリポジトリを処理する通常の非inetdサービスとして「git daemon」を設定するには、以下のようにデーモンを起動します。

@item  selectively enable/disable services per repository 
リポジトリに対して @samp{git archive --remote} を有効にし、 @samp{git fetch} を無効にするには、リポジトリの構成ファイルに以下のものを含めます（つまり、「HEAD」、「refs」、および「objects」の横にあるファイル「config」)。

@example
        [daemon]
                uploadpack = false
                uploadarch = true
@end example

@end table

@noindent

@chapheading ENVIRONMENT

「git daemon」は、IPアドレスが使用可能な場合、REMOTE_ADDRをそれに接続したクライアントのIPアドレスに設定します。 REMOTE_ADDRは、サービスの実行時に呼び出されるフックの環境で使用できます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-describe,,,Top
@chapheading Name

git-describe — 有効なrefに基づいて、オブジェクトに人間が読める形式の名前を付けます

@noindent

@chapheading Synopsis

@display
git describe [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>…]
git describe [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]
git describe <blob>
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、コミットから到達可能な最新のタグを検索します。 タグがコミットを指している場合は、タグのみが表示されます。 それ以外の場合は、タグ名に、タグ付けされたオブジェクトの上に追加されたコミットの数と、最新のコミットの省略されたオブジェクト名の接尾辞が付きます。 結果は「人間が読める」オブジェクト名であり、他のgitコマンドへのコミットを識別するためにも使用できます。

デフォルト(@samp{--all} または @samp{--tags} なし)では、 @samp{git describe} は注釈付きタグのみを表示します。 注釈付きタグの作成の詳細については、 git-tag(1) の @samp{-a} および @samp{-s} オプションを参照してください。

与えられたオブジェクトがブロブを参照している場合、それは @samp{<commit-ish>:<path>} として表されます。これは、そブロブが @samp{<commit-ish>} の @samp{<path>} にあり、それ自体が、このブロブがHEADからの逆リビジョンウォークで発生する最初のコミットを表しているためです。

@noindent

@chapheading OPTIONS

@table @asis

@item  <commit-ish>… 
説明するコミットっぽいオブジェクト名。 省略した場合、デフォルトでHEADになります。

@item  @samp{--dirty[=<mark>]} 
@itemx  @samp{--broken[=<mark>]} 
作業ツリーの状態を説明します。 作業ツリーがHEADと一致する場合、出力は @samp{git describe HEAD} と同じになります。 作業ツリーにローカル変更がある場合、接尾辞 @samp{-dirty} が追加されます。 リポジトリが破損していて、Gitがローカルでの変更があるかどうかを判断できない場合(代わりに接尾辞 @samp{-broken} を追加する @samp{--broken} が指定されていない限り)、Gitはエラーになります。

@item  @samp{--all} 
注釈付きタグのみを使用する代わりに、 @samp{refs/} 名前空間にあるrefを使用してください。 このオプションを使用すると、既知のブランチ または リモート追跡ブランチ または 軽量タグ を照合できます。

@item  @samp{--tags} 
注釈付きタグのみを使用する代わりに、 @samp{refs/tags} 名前空間にあるタグを使用してください。 このオプションを使用すると、軽量(注釈なし)タグのマッチングが可能になります。

@item  @samp{--contains} 
そのコミットより前のタグを見つける代わりに、そのコミットの後に来るタグを見つけて、それを含めます。 自動的に @samp{--tags} の指定を含んでいます。

@item  @samp{--abbrev=<n>} 
省略されたオブジェクト名のデフォルトの16進数(これは、リポジトリ内のオブジェクトの数によって異なりますが、デフォルトは7桁です)を使用する代わりに、<n>桁、または一意のオブジェクト名を形成するために必要な数の桁を使用します。<n>が0の場合、長い形式は抑制され、最も近いタグのみが表示されます。

@item  @samp{--candidates=<n>} 
入力のコミットっぽいのを説明するための候補として最新の10個のタグのみを考慮するのではなく、最大<n>個の候補を考慮してください。 <n>を10より大きくすると、少し時間がかかりますが、より正確な結果が得られる場合があります。 <n>が0の場合、完全一致のみが出力されます。

@item  @samp{--exact-match} 
完全一致のみを出力します(タグは指定されたコミットを直接参照します)。 これは @samp{--candidates=0} の同義語です。

@item  @samp{--debug} 
標準エラーに、検索戦略に関する情報を詳細に表示します。タグ名は引き続き標準出力で印刷されます。

@item  @samp{--long} 
タグと一致する場合でも、常に長い形式(タグとコミット数と省略されたコミット名)を出力します。 これは、問題のコミットがタグ付きバージョンである場合でも、 @samp{describe} 出力にコミットオブジェクト名の一部を表示する場合に役立ちます。 タグ名を発行するだけでなく、v1.2-0-gdeadbeeなどのコミットを記述します(オブジェクトdeadbeeを指すタグv1.2以降の0番目のコミット…)。

@item  @samp{--match <pattern>} 
@samp{refs/tags/} プレフィックスを除いて、指定された glob(7) パターンに一致するタグのみを考慮してください。 @samp{--all} と一緒に使用すると、パターンに一致するローカルブランチとリモート追跡参照も考慮されます。ただし、それぞれ @samp{refs/heads/} と @samp{refs/remotes/} プレフィックスは除外されます。 他のタイプの参照は考慮されません。 複数回指定すると、パターンのリストが蓄積され、いずれかのパターンに一致するタグが考慮されます。 パターンのリストをクリアしてリセットするには、 @samp{--no-match} を使用します。

@item  @samp{--exclude <pattern>} 
@samp{refs/tags/} プレフィックスを除いて、指定された glob(7) パターンに一致するタグを考慮しないでください。 @samp{--all} と一緒に使用すると、それぞれ @samp{refs/heads/} と @samp{refs/remotes/} プレフィックスを除いて、パターンに一致するローカルブランチとリモート追跡参照も考慮されません。 他のタイプの参照は考慮されません。 複数回指定すると、パターンのリストが蓄積され、いずれかのパターンに一致するタグが除外されます。 @samp{--match} と組み合わせると、タグが少なくとも1つの @samp{--match} パターンに一致し、 @samp{-exclude} パターンのいずれにも一致しない場合にタグが考慮されます。 パターンのリストをクリアしてリセットするには、 @samp{--no-exclude} を使用します。

@item  @samp{--always} 
ユニークさを保ちつつ省略されたコミットオブジェクトをフォールバックとして表示します。

@item  @samp{--first-parent} 
マージコミットを確認したら、最初の親コミットのみを追跡します。 これは、ターゲットコミットの履歴でマージされたブランチのタグを一致させたくない場合に役立ちます。
@end table

@noindent

@chapheading EXAMPLES

git.gitのツリーのようなナニカなら、以下のようなものを得るでしょう:

@example
[torvalds@@g5 git]$ git describe parent
v1.0.4-14-g2414721
@end example

つまり、私の「親」ブランチの現在のヘッドはv1.0.4に基づいていますが、その上にいくつかのコミットがあるため、describeは、追加のコミットの数(@samp{14})と、コミット自体の省略されたオブジェクト名(@samp{2414721})を最後に追加しました。

The number of additional commits is the number of commits which would be displayed by "git log v1.0.4..parent". The hash suffix is "-g" + an unambiguous abbreviation for the tip commit of parent (which was @samp{2414721b194453f058079d897d13c4e377f92dc6}). The length of the abbreviation scales as the repository grows, using the approximate number of objects in the repository and a bit of math around the birthday paradox, and defaults to a minimum of 7. The "g" prefix stands for "git" and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.

タグ名に対して @samp{git describe} を実行すると、タグ名が表示されるだけです:

@example
[torvalds@@g5 git]$ git describe v1.0.4
v1.0.4
@end example

@samp{--all} を使用すると、コマンドはブランチヘッドを参照として使用できるため、出力には参照パスも表示されます:

@example
[torvalds@@g5 git]$ git describe --all --abbrev=4 v1.0.5^2
tags/v1.0.0-21-g975b
@end example

@example
[torvalds@@g5 git]$ git describe --all --abbrev=4 HEAD^
heads/lt/describe-7-g975b
@end example

`--abbrev`を0に設定すると、このコマンドを使用して、接尾辞(suffix)なしで最も近いタグ名を見つけることができます:

@example
[torvalds@@g5 git]$ git describe --abbrev=0 v1.0.5^2
tags/v1.0.0
@end example

注意: 今、これらのコマンドを入力した場合に取得するサフィックスは、かつてLinusがこれらのコマンドを実行したときに上記で見たものよりも長くなる可能性があることに注意してください。Gitリポジトリには、オブジェクト名が975bで始まり、当時は存在しなかった新しいコミットが含まれている可能性があります。 @samp{-g975b} サフィックスだけでは、これらのコミットを明確にするのに十分でない場合があります。

@noindent

@chapheading SEARCH STRATEGY

提供されたコミットっぽいのごとに、 @samp{git describe} は最初にそのコミットを正確にタグ付けするタグを探します。 注釈付きタグは常に軽量タグよりも優先され、新しい日付のタグは常に古い日付のタグよりも優先されます。 完全に一致するものが見つかると、その名前が出力され、検索が停止します。

完全に一致するものが見つからなかった場合、 @samp{git describe} はコミット履歴をさかのぼって、タグ付けされた祖先コミットを見つけます。 祖先のタグは、入力したコミットっぽい何かのSHA-1の省略形とともに出力されます。 @samp{--first-parent} が指定された場合、ウォークは各コミットの最初の親のみを考慮します。

ウォーク中に複数のタグが見つかった場合は、入力コミットっぽい何かとは異なるコミットが最も少ないタグが選択されて出力されます。 ここで異なるコミットの数は、 @samp{git log tag..input} で示されるコミットの数として定義され、可能な限り最小のコミット数になります。

@noindent

@chapheading BUGS

Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as <commit-ish>:<path> despite the lightweight tag being favorable.

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-diagnose,,,Top
@chapheading Name

git-diagnose — 診断情報の zip アーカイブを生成する

@noindent

@chapheading Synopsis

@display
git diagnose [(-o | --output-directory) <path>] [(-s | --suffix) <format>]
               [--mode=<mode>]
@end display


@noindent

@chapheading DESCRIPTION

ユーザーのマシンや、 Git クライアントや、 リポジトリの状態に関する詳細情報を収集し、 その情報を zip アーカイブにパッケージ化します。 生成されたアーカイブは、 たとえば、Git メーリング・リストと共有して、 問題のデバッグを支援したり、 独立したデバッグの参照として使用したりできます。

デフォルトでは以下の情報がアーカイブに収められます:

@itemize 

@item
@samp{git version --build-options}

@item
リポジトリ・ルートへのパス(path)

@item
ファイルシステムで利用可能なディスク容量

@item
代替オブジェクト・ストア(alternate object stores)内のものを含む、 各パック・ファイルの名前とサイズ

@item
緩い(loose)オブジェクトの総数と、 @samp{.git/objects} のサブディレクトリごとに分類されたカウント
@end itemize

@samp{--mode} オプションを使用して別の診断モードを選択すると、 追加情報を収集できます。

このツールは、 git-bugreport(1) とは異なり、 リポジトリ・コンテンツのサイズとデータ形状のレポートに重点を置いて、 より詳細な情報を収集します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-o <path>} 
@itemx  @samp{--output-directory <path>} 
結果の診断アーカイブを、 現在のディレクトリではなく @samp{<path>} に配置します。

@item  @samp{-s <format>} 
@itemx  @samp{--suffix <format>} 
診断アーカイブ名の代替サフィックスを指定して、 @samp{git-diagnostics-<formatted suffix>} という名前のファイルを作成します。 これは、 strftime(3) 書式文字列の形式を取る必要があり、 現地の現在時間(current local time)が使用されます。

@item  @samp{--mode=(stats|all)} 
収集する必要がある診断のタイプを指定します。 @samp{git diagnostic} のデフォルトの動作は @samp{--mode=stats} と同等です。

@samp{--mode=all} オプションは、 @samp{--mode=stats} に含まれるすべてのものと、 @samp{.git} と @samp{.git/hooks} と @samp{.git/info} と @samp{.git/logs} と @samp{.git/objects/info} ディレクトリのコピーを収集します。 この追加情報は、 診断されたリポジトリの完全なコンテンツを再構築するために使用できるため、 機密情報である可能性があります。 @samp{--mode=all} で生成されたアーカイブを共有する場合、ユーザーは注意を払う必要があります。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-diff-files,,,Top
@chapheading Name

git-diff-files — 作業ツリーとインデックス内のファイルを比較します

@noindent

@chapheading Synopsis

@display
git diff-files [-q] [-0 | -1 | -2 | -3 | -c | --cc] [<common-diff-options>] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

作業ツリーとインデックス内のファイルを比較します。パスが指定されている場合、それらの名前付きパスのみを比較します。それ以外の場合は、インデックス内のすべてのエントリが比較されます。出力形式は、 @samp{git diff-index} や @samp{git diff-tree} の場合と同じです。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p").

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
生形式(raw format)でdiffを生成します。
これがデフォルトです。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
@samp{--raw} または @samp{--numstat} または @samp{--name-only} または @samp{--name-status} が指定されている場合は
パス名を変更せず、出力フィールドターミネータとしてNULLを使用してください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。

@item  @samp{--no-color} 
カラーdiffをオフにします。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
名前の変更(renames)を検知する。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--exit-code} 
diff(1）と同様のコードでプログラムを終了させます。つまり、違いがあった場合は 1 で終了し、 0 は違いがないことを意味します。

@item  @samp{--quiet} 
プログラムのすべての出力を無効にします。 @samp{--exit-code} を意味します。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@table @asis

@item  @samp{-1 --base} 
@itemx  @samp{-2 --ours} 
@itemx  @samp{-3 --theirs} 
@itemx  @samp{-0} 
"base" バージョン または "our branch" または "their branch" とそれぞれ異なります。これらのオプションを使用すると、マージされたエントリのdiffは表示されません。

デフォルトでは、 our branch (-2) とクリーンに解決されたパスに対してdiffを取ります。オプション -0 を指定すると、マージされていないエントリのdiff出力を省略し、 "Unmerged" と表示することができます。

@item  @samp{-c} 
@itemx  @samp{--cc} 
これは、ステージ2（ブランチ）、ステージ3（ブランチ）、および作業ツリーファイルを比較し、 @samp{diff-tree} がこれらのフラグを使用してマージコミットを示すのと同様に、結合された差分を出力します。

@item  @samp{-q} 
存在しないファイルでも黙っています
@end table

@noindent

@chapheading Raw output format

@samp{git-diff-index} と @samp{git-diff-tree} と @samp{git-diff-files} と @samp{git diff --raw} からの生の出力形式は非常に似ています。

これらのコマンドはすべて、2つのセットを比較します。なお、比較されるものは異なります:

@table @asis

@item  git-diff-index <tree-ish> 
<tree-ish> とファイルシステム上のファイルを比較します。

@item  git-diff-index --cached <tree-ish> 
<tree-ish> とインデックスを比較します。

@item  git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>…] 
2つの引数で指定されたツリーを比較します。

@item  git-diff-files [<pattern>…] 
インデックスとファイルシステム上のファイルを比較します。
@end table

"git-diff-tree" コマンドは、比較対象のハッシュ値を出力することで出力を開始します。その後、すべてのコマンドは、変更されたファイルごとに1つの出力行を出力します。

出力行は以下のようにフォーマットされます:

@example
in-place edit  :100644 100644 bcd1234 0123456 M file0
copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2
rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3
create         :000000 100644 0000000 1234567 A file4
delete         :100644 000000 1234567 0000000 D file5
unmerged       :000000 000000 0000000 0000000 U file6
@end example


つまり、左から右へ:

@enumerate 

@item
コロン(:)

@item
"src" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"dst" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"src" のsha1。作成(creation)またはマージされていない(unmerged)場合は 0@{40@}

@item
空白

@item
"dst" のsha1; 削除、またはマージされていない(unmerged)、または「ワーク・ツリーがインデックスと同期していない」場合は 0@{40@}

@item
空白

@item
ステータスの後に、オプションの「スコア数」("score" number)が続きます

@item
@samp{-z} オプションが使用されている場合はタブまたはNUL

@item
"src" のパス

@item
@samp{-z} オプションが使用されている場合タブまたはNUL。ステータスCまたはRにのみ存在します

@item
"dst" のパス。ステータスCまたはRにのみ存在します

@item
LFでレコードを終了します。 @samp{-z} オプションが使用されている場合はNULでレコードを終了します。
@end enumerate

ステータス文字の種類は以下のとおり:

@itemize 

@item
A: ファイルの追加

@item
C: ファイルを新しいファイルにコピー

@item
D: ファイルの削除

@item
M: ファイルの内容やモードの変更

@item
R: ファイル名の名前変更

@item
T: ファイルのタイプを変更(通常ファイル または シンボリックリンク または サブモジュール)

@item
U: ファイルはマージされていません(コミットする前にマージを完了する必要があります)

@item
X: 「不明な」変更タイプ(おそらくバグです。報告してください)
@end itemize

ステータス文字CとRの後には常にスコアが続きます(移動またはコピーのソースとターゲットの間の類似性のパーセンテージを示します)。ステータス文字Mの後には、ファイルの書き換えのスコア(非類似度のパーセンテージを示す)が続く場合があります。

ファイルシステム上のファイルがインデックスと同期していない場合、 ”dst” の sha1 はすべて 0 として表示されます。

例:

@example
:100644 100644 5be4a4a 0000000 M file.c
@end example


@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

@noindent

@chapheading diff format for merges

"git-diff-tree" と "git-diff-files" と "git-diff --raw" は、 @samp{-c} または @samp{--cc} オプションを使用して、マージコミットに対してもdiff出力を生成できます。出力は、以下の点で上記の形式とは異なります:

@enumerate 

@item
親ごとにコロン(:)があります

@item
より多くの "src" モードと "src" sha1があります

@item
statusは、各親のステータス文字を連結したものです

@item
オプションの「スコア数」はありません

@item
ファイルのタブ区切りのパス名
@end enumerate

@samp{-c} および ` -cc` の場合、履歴のいずれかの側でファイルの名前が変更された場合でも、宛先(dst)または最終パスのみが表示されます。 @samp{--combined-all-paths} を使用すると、各親のパスの名前が表示され、それに続いてマージコミットのパスの名前が表示されます。

例: @samp{--combined-all-paths} を使用しない @samp{-c} および @samp{--cc} の場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       phooey.c
@end example


例: @samp{-c} または @samp{--cc} のいずれかに @samp{--combined-all-paths} が追加された場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c  desc.c  desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       foo.sh  bar.sh  bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       fooey.c fuey.c  phooey.c
@end example


注意: @samp{combined diff} は、すべての親から変更されたファイルのみをリストすることに注意してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading other diff formats

@samp{--summary} オプションは、新しく追加、削除、名前変更、およびコピーされたファイルを説明します。@samp{--stat} オプションは、 diffstat(1) グラフ を出力に追加します。これらのオプションは、 @samp{-p} などの他のオプションと組み合わせることができ、人間が読むことを目的としています。

名前の変更またはコピーを伴う変更を表示する場合、 @samp{--stat} 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。 たとえば、4行を変更(modify)しながら @samp{arch/i386/Makefile} を @samp{arch/x86/Makefile} に移動(move)する変更(change)は、次のように表示されます:

@example
arch/@{i386 => x86@}/Makefile    |   4 +--
@end example


@samp{--numstat} オプションは diffstat(1) 情報を提供しますが、人間ではなくソフトウェアで読むのを容易にするように設計されています。 @samp{--numstat} 出力のエントリは以下のようになります:

@example
1       2       README
3       1       arch/@{i386 => x86@}/Makefile
@end example


この形式は、左から右へ:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
パス名(おそらく rename/copy 情報を含む)

@item
改行
@end enumerate

@samp{-z} 出力オプションが有効な場合、出力は以下のようにフォーマットされます:

@example
1       2       README NUL
3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
@end example


これは:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
NUL(rename/copy された場合のみ存在します)

@item
プリイメージのパス名

@item
NUL(rename/copy された場合のみ存在します)

@item
ポストイメージのパス名(rename/copy された場合のみ存在します)

@item
NUL
@end enumerate

名前が変更された場合のプリイメージパスの前の追加の @samp{NUL} は、出力を読み取るスクリプトが、先読みせずに、読み取られている現在のレコードがシングルパスレコードであるか、名前変更/コピーレコードであるか、を判断できるようにするためです。追加および削除された行を読み取った後、 @samp{NUL} まで読み取るとパス名が生成されますが、それが @samp{NUL} の場合、レコードには2つのパスが表示されます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-diff-index,,,Top
@chapheading Name

git-diff-index — ツリーを作業ツリーまたはインデックスと比較します

@noindent

@chapheading Synopsis

@display
git diff-index [-m] [--cached] [--merge-base] [<common-diff-options>] <tree-ish> [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

ツリーオブジェクトで見つかったブロブの内容とモードを、作業ツリー内の対応する追跡中のファイルまたはインデックス内の対応するパスと比較します。<path>引数が存在する場合、それらのパターンに一致するパスのみを比較します。それ以外の場合は、追跡中のすべてのファイルが比較されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p").

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
生形式(raw format)でdiffを生成します。
これがデフォルトです。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
@samp{--raw} または @samp{--numstat} または @samp{--name-only} または @samp{--name-status} が指定されている場合は
パス名を変更せず、出力フィールドターミネータとしてNULLを使用してください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。

@item  @samp{--no-color} 
カラーdiffをオフにします。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
名前の変更(renames)を検知する。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--exit-code} 
diff(1）と同様のコードでプログラムを終了させます。つまり、違いがあった場合は 1 で終了し、 0 は違いがないことを意味します。

@item  @samp{--quiet} 
プログラムのすべての出力を無効にします。 @samp{--exit-code} を意味します。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@table @asis

@item  <tree-ish> 
diffするツリーオブジェクトのID。

@item  @samp{--cached} 
ディスク上のファイルはまったく考慮しないでください。

@item  @samp{--merge-base} 
<tree-ish>を直接比較する代わりに、<tree-ish>とHEADの間のマージベースを使用してください。 <tree-ish>はコミットでなければなりません。

@item  @samp{-m} 
デフォルトでは、インデックスに記録されているがチェックアウトされていないファイルは削除済みとして報告されます。このフラグにより、 @samp{git diff-index} はチェックアウトされていないファイルは全て最新とします。
@end table

@noindent

@chapheading Raw output format

@samp{git-diff-index} と @samp{git-diff-tree} と @samp{git-diff-files} と @samp{git diff --raw} からの生の出力形式は非常に似ています。

これらのコマンドはすべて、2つのセットを比較します。なお、比較されるものは異なります:

@table @asis

@item  git-diff-index <tree-ish> 
<tree-ish> とファイルシステム上のファイルを比較します。

@item  git-diff-index --cached <tree-ish> 
<tree-ish> とインデックスを比較します。

@item  git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>…] 
2つの引数で指定されたツリーを比較します。

@item  git-diff-files [<pattern>…] 
インデックスとファイルシステム上のファイルを比較します。
@end table

"git-diff-tree" コマンドは、比較対象のハッシュ値を出力することで出力を開始します。その後、すべてのコマンドは、変更されたファイルごとに1つの出力行を出力します。

出力行は以下のようにフォーマットされます:

@example
in-place edit  :100644 100644 bcd1234 0123456 M file0
copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2
rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3
create         :000000 100644 0000000 1234567 A file4
delete         :100644 000000 1234567 0000000 D file5
unmerged       :000000 000000 0000000 0000000 U file6
@end example


つまり、左から右へ:

@enumerate 

@item
コロン(:)

@item
"src" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"dst" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"src" のsha1。作成(creation)またはマージされていない(unmerged)場合は 0@{40@}

@item
空白

@item
"dst" のsha1; 削除、またはマージされていない(unmerged)、または「ワーク・ツリーがインデックスと同期していない」場合は 0@{40@}

@item
空白

@item
ステータスの後に、オプションの「スコア数」("score" number)が続きます

@item
@samp{-z} オプションが使用されている場合はタブまたはNUL

@item
"src" のパス

@item
@samp{-z} オプションが使用されている場合タブまたはNUL。ステータスCまたはRにのみ存在します

@item
"dst" のパス。ステータスCまたはRにのみ存在します

@item
LFでレコードを終了します。 @samp{-z} オプションが使用されている場合はNULでレコードを終了します。
@end enumerate

ステータス文字の種類は以下のとおり:

@itemize 

@item
A: ファイルの追加

@item
C: ファイルを新しいファイルにコピー

@item
D: ファイルの削除

@item
M: ファイルの内容やモードの変更

@item
R: ファイル名の名前変更

@item
T: ファイルのタイプを変更(通常ファイル または シンボリックリンク または サブモジュール)

@item
U: ファイルはマージされていません(コミットする前にマージを完了する必要があります)

@item
X: 「不明な」変更タイプ(おそらくバグです。報告してください)
@end itemize

ステータス文字CとRの後には常にスコアが続きます(移動またはコピーのソースとターゲットの間の類似性のパーセンテージを示します)。ステータス文字Mの後には、ファイルの書き換えのスコア(非類似度のパーセンテージを示す)が続く場合があります。

ファイルシステム上のファイルがインデックスと同期していない場合、 ”dst” の sha1 はすべて 0 として表示されます。

例:

@example
:100644 100644 5be4a4a 0000000 M file.c
@end example


@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

@noindent

@chapheading diff format for merges

"git-diff-tree" と "git-diff-files" と "git-diff --raw" は、 @samp{-c} または @samp{--cc} オプションを使用して、マージコミットに対してもdiff出力を生成できます。出力は、以下の点で上記の形式とは異なります:

@enumerate 

@item
親ごとにコロン(:)があります

@item
より多くの "src" モードと "src" sha1があります

@item
statusは、各親のステータス文字を連結したものです

@item
オプションの「スコア数」はありません

@item
ファイルのタブ区切りのパス名
@end enumerate

@samp{-c} および ` -cc` の場合、履歴のいずれかの側でファイルの名前が変更された場合でも、宛先(dst)または最終パスのみが表示されます。 @samp{--combined-all-paths} を使用すると、各親のパスの名前が表示され、それに続いてマージコミットのパスの名前が表示されます。

例: @samp{--combined-all-paths} を使用しない @samp{-c} および @samp{--cc} の場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       phooey.c
@end example


例: @samp{-c} または @samp{--cc} のいずれかに @samp{--combined-all-paths} が追加された場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c  desc.c  desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       foo.sh  bar.sh  bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       fooey.c fuey.c  phooey.c
@end example


注意: @samp{combined diff} は、すべての親から変更されたファイルのみをリストすることに注意してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading other diff formats

@samp{--summary} オプションは、新しく追加、削除、名前変更、およびコピーされたファイルを説明します。@samp{--stat} オプションは、 diffstat(1) グラフ を出力に追加します。これらのオプションは、 @samp{-p} などの他のオプションと組み合わせることができ、人間が読むことを目的としています。

名前の変更またはコピーを伴う変更を表示する場合、 @samp{--stat} 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。 たとえば、4行を変更(modify)しながら @samp{arch/i386/Makefile} を @samp{arch/x86/Makefile} に移動(move)する変更(change)は、次のように表示されます:

@example
arch/@{i386 => x86@}/Makefile    |   4 +--
@end example


@samp{--numstat} オプションは diffstat(1) 情報を提供しますが、人間ではなくソフトウェアで読むのを容易にするように設計されています。 @samp{--numstat} 出力のエントリは以下のようになります:

@example
1       2       README
3       1       arch/@{i386 => x86@}/Makefile
@end example


この形式は、左から右へ:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
パス名(おそらく rename/copy 情報を含む)

@item
改行
@end enumerate

@samp{-z} 出力オプションが有効な場合、出力は以下のようにフォーマットされます:

@example
1       2       README NUL
3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
@end example


これは:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
NUL(rename/copy された場合のみ存在します)

@item
プリイメージのパス名

@item
NUL(rename/copy された場合のみ存在します)

@item
ポストイメージのパス名(rename/copy された場合のみ存在します)

@item
NUL
@end enumerate

名前が変更された場合のプリイメージパスの前の追加の @samp{NUL} は、出力を読み取るスクリプトが、先読みせずに、読み取られている現在のレコードがシングルパスレコードであるか、名前変更/コピーレコードであるか、を判断できるようにするためです。追加および削除された行を読み取った後、 @samp{NUL} まで読み取るとパス名が生成されますが、それが @samp{NUL} の場合、レコードには2つのパスが表示されます。

@noindent

@chapheading OPERATING MODES

あなたはインデックスファイルを完全に信頼するか(@samp{--cached} フラグを使用)、diffロジックにてstat状態と一致しないファイルを「仮変更」(tentatively changed)として表示するようにするかを選択できます。これらの操作はどちらも非常に便利です。

@noindent

@chapheading CACHED MODE

@samp{--cached} が指定されている場合、あなたは以下のように問うことができます:

@example
HEADと、現在のインデックスの内容(`git write-tree` を
使用して書き込むもの)との違いを見せてください
@end example

たとえば、あなたがあなたの作業ディレクトリで作業して、インデックス内のいくつかのファイルを更新し、コミットする準備ができました。あなたは何をコミットしようとしているかを正確に確認したいのですが、比較のために新しいツリーオブジェクトを作成する必要はありません。そのためには、あなたは以下のようにします。

@example
git diff-index --cached HEAD
@end example

例: @samp{commit.c} の名前を @samp{git-commit.c} に変更し、それをインデックスファイルで有効にするために @samp{update-index} を実行したとします。 インデックスファイルが私の作業ディレクトリと一致するため、 @samp{git diff-files} は何も表示しません。 しかし、 @samp{git diff-index} を実行すると以下のようになります:

@example
torvalds@@ppc970:~/git> git diff-index --cached HEAD
:100644 000000 4161aecc6700a2eb579e842af0b7f22b98443f74 0000000000000000000000000000000000000000 D    commit.c
:000000 100644 0000000000000000000000000000000000000000 4161aecc6700a2eb579e842af0b7f22b98443f74 A    git-commit.c
@end example

あなたは上記が名前変更(rename)であることが簡単にわかります。

実際、 @samp{git diff-index --cached} は、実際に @samp{git write-tree} を実行して比較することと常に完全に同等です。実際に実行するのではなくて、自分がどういう状態にあるかを確認したいだけの場合には、こちらの方がはるかに優れています。

したがって、 @samp{git diff-index --cached} を実行することは、「コミット済みとしてすでにマークしたものと、前のツリーとの違い」を自問するときに実に役に立つのです。

@noindent

@chapheading NON-CACHED MODE

非キャッシュモードは別のアプローチを取り、 @samp{git write-tree} + ` git diff-tree` でエミュレートできないという点で、2つのモードの中でより便利になる可能性があります。したがって、これがデフォルトのモードです。非キャッシュバージョンは以下のように問いかけます:

@example
HEADと現在チェックアウトされているツリーの違いを
表示 - インデックスの内容や最新でないファイル
@end example

これは明らかに非常に役立つ質問です。何をコミットできるかがわかるからです。 この場合も、出力は @emph{git diff-tree -r} の出力と完全に一致しますが、更にひとひねりあります。

そのひとひねりとは、一部のファイルがインデックスと一致しない場合、そのファイルには裏付けがないことです。これを示すために、魔法の「オールゼロ」sha1を使用します。 @samp{kernel/sched.c} を編集したが、実際にはまだ @emph{git update-index} を実行していないとしましょう。そうすると、新しい状態に関連付けられた「オブジェクト」はなく、以下のようになります:

@example
torvalds@@ppc970:~/v2.6/linux> git diff-index --abbrev HEAD
:100644 100644 7476bb5ba 000000000 M  kernel/sched.c
@end example

つまり、ツリーが変更され、 @samp{kernel/sched.c} が最新ではなく、新しいものが含まれている可能性があることを示しています。オールゼロのsha1は、実際の差分を取得するには、オブジェクト間のdiffを行うのではなく、作業ディレクトリ内のオブジェクトを直接確認する必要があることを意味します。

@quotation

@strong{Note}

このタイプの他のコマンドと同様に、 @samp{git diff-index} は実際にはファイルの内容をまったく調べません。 つまり、 @samp{kernel/sched.c} は実際には変更されておらず、触れた(touch)だけです。いずれの場合も、インデックスを同期させるには、 @samp{gitu pdate-index} する必要があることに注意してください。
@end quotation

@quotation

@strong{Note}

「has been updated」(更新されました)と「is still dirty in the working directory」(作業ディレクトリでまだダーティです)というファイルが混在している場合があります。「更新された」ファイルには有効なsha1が表示され、「インデックスと同期していない」ファイルには常に特別なすべてゼロのsha1が表示されるため、どのファイルがどの状態にあるかをいつでも確認できます。
@end quotation

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-diff-tree,,,Top
@chapheading Name

git-diff-tree — 2つのツリーオブジェクト間で、ブロブの内容とモードを比較します

@noindent

@chapheading Synopsis

@display
git diff-tree [--stdin] [-m] [-s] [-v] [--no-commit-id] [--pretty]
              [-t] [-r] [-c | --cc] [--combined-all-paths] [--root] [--merge-base]
              [<common-diff-options>] <tree-ish> [<tree-ish>] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

2つのツリーオブジェクト間で、ブロブの内容とモードを比較します

<tree-ish> が1つだけ指定されている場合、コミットはその親と比較されます(以下の @samp{--stdin} 参照)。

注意: @samp{git diff-tree} は、コミットオブジェクトにカプセル化されたツリーを使用できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p").

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
生形式(raw format)でdiffを生成します。
これがデフォルトです。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
@samp{--raw} または @samp{--numstat} または @samp{--name-only} または @samp{--name-status} が指定されている場合は
パス名を変更せず、出力フィールドターミネータとしてNULLを使用してください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。

@item  @samp{--no-color} 
カラーdiffをオフにします。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
名前の変更(renames)を検知する。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--exit-code} 
diff(1）と同様のコードでプログラムを終了させます。つまり、違いがあった場合は 1 で終了し、 0 は違いがないことを意味します。

@item  @samp{--quiet} 
プログラムのすべての出力を無効にします。 @samp{--exit-code} を意味します。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@table @asis

@item  <tree-ish> 
ツリーオブジェクトのID。

@item  <path>… 
<path>… が提供された場合、結果は提供されたパススペックの1つに一致するファイルのサブセットに制限されます。

@item  @samp{-r} 
サブツリーを再帰的に辿ります。

@item  @samp{-t} 
ツリーエントリ自体とサブツリーを表示します。 @samp{-r} の機能を含みます。

@item  @samp{--root} 
@samp{--root} が指定されている場合、最初のコミット(initial commit)は大きな作成イベント(big creation event)として表示されます。これは、NULLツリーに対する差分と同等です。

@item  @samp{--merge-base} 
<tree-ish>を直接比較する代わりに、2つの<tree-ish>間のマージベースをbefore側として使用します。2つの<tree-ish>が指定されている必要があり、両方ともコミットである必要があります。

@item  @samp{--stdin} 
`--stdin`が指定されている場合、コマンドはコマンドラインから<tree-ish>引数を取りません。代わりに、2つの<tree> または 1つの<commit> または <commit>のリストのいずれかを含む行を標準入力から読み取ります。（区切り文字として空白1文字を使用します。）

2つのツリーが与えられると、最初のツリーと2番目のツリーが比較されます。単一のコミットが与えられると、そのコミットをその親と比較します。 残りのコミットは、指定されると、最初のコミットの親であるかのように使用されます。

2つのツリーを比較する場合、違いの前に両方のツリーのID(スペースで区切られ、改行で終了)が出力されます。コミットを比較する場合、最初の(または唯一の)コミットのIDと、それに続く改行が出力されます。

以下のフラグは、(ツリーではなく、)コミットを比較するときの動作に影響します。

@item  @samp{-m} 
デフォルトでは、 @samp{git diff-tree --stdin} はマージコミットの違いを表示しません。 このフラグを使用すると、すべての親からのコミットとの違いが示されます。 @samp{-c} も参照してください。

@item  @samp{-s} 
デフォルトでは、 @samp{git diff-tree --stdin} は、機械可読形式( @samp{-p} なし) または パッチ形式( ` -p` あり)のいずれかで違いを示します。この出力を抑制できます。 @samp{-v} フラグでのみ役立ちます。

@item  @samp{-v} 
このフラグにより、 @samp{git diff-tree --stdin} は、違いの前にコミットメッセージも表示します。

@item  @samp{--pretty[=<format>]} 
@itemx  @samp{--format=<format>} 
コミットログの内容を指定された形式できれいに印刷(pretty-print)します。 <format> は oneline、short、medium、full、fuller、reference、email、raw、format:<string>、tformat:<string> のいずれかになります。 <format> が上記のいずれでもなく、「%プレースホルダー」が含まれている場合、 @samp{--pretty=tformat:<format>} が指定されたかのように動作します。

各フォーマットの詳細については、「PRETTY FORMATS」セクションを参照してください。 @samp{=<format>} の部分を省略すると、デフォルトで medium になります。

注意: リポジトリー構成でデフォルトのpretty formatを指定できます(git-config(1) 参照)。

@item  @samp{--abbrev-commit} 
40バイトの16進コミットオブジェクト名全体を表示する代わりに、オブジェクトに一意の名前を付けるプレフィックスを表示します。 "--abbrev=<n>" (表示されている場合はdiff出力も変更します)オプションを使用して、プレフィックスの最小長を指定できます。

これにより、80桁幅の端末を使用している人にとって "--pretty=oneline" がずっと読みやすくなるはずです。

@item  @samp{--no-abbrev-commit} 
完全な40バイトの16進コミットオブジェクト名を表示します。 これにより、明示的または "--oneline" などの他のオプションによって暗黙的に示される @samp{--abbrev-commit} が無効になります。また、 @samp{log.abbrevCommit} 変数をオーバーライドします。

@item  @samp{--oneline} 
これは、 "--pretty=oneline --abbrev-commit" を一緒に使用するための省略形です。

@item  @samp{--encoding=<encoding>} 
コミットオブジェクトは、ログメッセージに使用される文字エンコードをエンコードヘッダーに記録します。このオプションを使用して、ユーザーが好むエンコーディングでコミットログメッセージを再コーディングするようにコマンドに指示できます。配管以外のコマンドの場合、これはデフォルトでUTF-8になります。オブジェクトが @samp{X} でエンコードされていると主張し、 @samp{X} で出力している場合、オブジェクトをそのまま出力することに注意してください。これは、元のコミットの無効なシーケンスが出力にコピーされる可能性があることを意味します。 同様に、 iconv(3) がコミットの変換に失敗した場合、 元のオブジェクトをそのまま黙って出力します。

@item  @samp{--expand-tabs=<n>} 
@itemx  @samp{--expand-tabs} 
@itemx  @samp{--no-expand-tabs} 
出力に表示する前に、ログメッセージでタブ展開を実行します(タブ幅を <n> とみなして <n> 境界に揃うように空白で調整する)。 @samp{--expand-tabs} は @samp{--expand-tabs=8} の省略形であり、 @samp{--no-expand-tabs} は @samp{--expand-tabs=0} の省略形です。タブの展開を無効にします。

デフォルトでは、タブはログメッセージを4つのスペースでインデントするきれいな形式(pretty formats)で展開されます(つまり、medium (これがデフォルト) と full と fuller)。

@item  @samp{--notes[=<ref>]} 
コミットログメッセージを表示するときに、コミットに注釈を付けるnotes(git-notes(1) 参照)を表示します。これは、コマンドラインに @samp{--pretty} 、@samp{--format} または @samp{--oneline} オプションが指定されていない場合の、 @samp{git log} と @samp{git show} と ` git whatchanged` コマンドのデフォルトです。

デフォルトでは、表示されるnotesは、 @samp{core.notesRef} および @samp{notes.displayRef} 変数(または対応する環境変数オーバーライド)にリストされているnote refからのものです。詳細については git-config(1) を参照してください。

オプションの <ref> 引数を使用して、refを使用して表示するnotesを検索します。 refは、 @samp{refs/notes/} で始まる完全なrefnameを指定できます。 @samp{notes/} で始まるか、 @samp{refs/} で始まるか、それ以外で始まる場合、 @samp{refs/notes/} が接頭辞として付けられ、refのフルネームを形成します。

複数の --notes オプションを組み合わせて、表示するノートを制御できます。 例: "--notes=foo" は "refs/notes/foo" からのnotesのみを表示します。 "--notes=foo --notes" は、 "refs/notes/foo" とデフォルトのnotes ref(s) の両方のnotesを表示します。

@item  @samp{--no-notes} 
notesを表示しないでください。 これは、notesが表示されるnotes refのリストをリセットすることにより、上記の @samp{--notes} オプションを無効にします。 オプションは、コマンドラインで指定された順序で解析されます。 "--notes --notes=foo --no-notes --notes=bar" は、 "refs/notes/bar" からのnotesのみを表示します。

@item  @samp{--show-notes[=<ref>]} 
@itemx  @samp{--[no-]standard-notes} 
これらのオプションは非推奨です。 代わりに、上記の --notes/--no-notes オプションを使用してください。

@item  @samp{--show-signature} 
署名を @samp{gpg --verify} に渡して、署名されたコミットオブジェクトの有効性を確認し、出力を表示します。

@item  @samp{--no-commit-id} 
@samp{git diff-tree} は、該当する場合、コミットIDを含む行を出力します。このフラグは、コミットIDの出力を抑制します。

@item  @samp{-c} 
このフラグは、マージコミットの表示方法を変更します(つまり、コマンドに1つの <tree-ish> 、または @samp{--stdin} が指定されている場合にのみ役立ちます)。これは、親と結果を一度に1つずつ表示するのではなく、各親とマージ結果の違いを同時に表示します(これは、 @samp{-m} オプションが行うことです)。さらに、すべての親から変更されたファイルのみが一覧表示されます。

@item  @samp{--cc} 
このフラグは、 @samp{-c} オプションと同様に、マージコミットパッチの表示方法を変更します。これは @samp{-c} と @samp{-p} オプションの機能を含んでいて、さらに、パッチの出力を圧縮するために、親のコンテンツが二つのバリエーションしかなく、マージ結果がそのうちの一つをそのまま選んでしまうような、つまらないハンクは省きます。すべてのハンクがつまらない場合、他の「空の差分」の場合と同様に、コミット自体とコミットログメッセージは表示されません。

@item  @samp{--combined-all-paths} 
このフラグにより、結合された差分(combined diff)(マージコミットに使用)にすべての親からのファイルの名前が一覧表示されます。したがって、 @samp{-c} または @samp{--cc} が指定されている場合にのみ有効であり、ファイル名の変更が検出された場合(つまり、名前変更またはコピーの検出が要求された場合)にのみ役立つ可能性があります。

@item  @samp{--always} 
差分自体が空の場合でも、コミット自体とコミットログメッセージを表示します。
@end table

@noindent

@chapheading PRETTY FORMATS

コミットがマージであり、 pretty-format が @samp{oneline} または @samp{email} または @samp{raw} で無い場合、 @samp{Author:} 行の前に追加の行が挿入されます。この行は "Merge: " で始まり、先祖のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合、リストされたコミットは必ずしも @strong{直接} の親コミットのリストではない可能性があることに注意してください。

いくつかの組み込みフォーマットがあります。そして以下で説明するように、 pretty.<name> 構成オプション(config option)を別のフォーマット名または @samp{format:} 文字列に設定することで、追加のフォーマットを定義できます(git-config(1) 参照)。組み込みフォーマットの詳細は以下のとおりです:

@itemize 

@item
@samp{oneline}

@example
<hash> <title-line>
@end example

これは、可能な限りコンパクトになるように設計されています。

@item
@samp{short}

@example
commit <hash>
Author: <author>
@end example

@example
<title-line>
@end example

@item
@samp{medium}

@example
commit <hash>
Author: <author>
Date:   <author-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{full}

@example
commit <hash>
Author: <author>
Commit: <committer>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{fuller}

@example
commit <hash>
Author:     <author>
AuthorDate: <author-date>
Commit:     <committer>
CommitDate: <committer-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{reference}

@example
<abbrev-hash> (<title-line>, <short-author-date>)
@end example

この形式は、コミットメッセージ内の別のコミットを参照するために使用され、 @samp{--pretty='format:%C(auto)%h (%s, %ad)'} と同じです。 デフォルトでは、別の @samp{--date} オプションが明示的に指定されていない限り、日付は @samp{--date=short} でフォーマットされます。formatプレースホルダーを使用する他の @samp{format:} と同様に、その出力は、 @samp{--decorate} や @samp{--walk-reflogs} などの他のオプションの影響を受けません。

@item
@samp{email}

@example
From <hash> <date>
From: <author>
Date: <author-date>
Subject: [PATCH] <title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{mboxrd}

@samp{email} と同様ですが、コミットメッセージの "From " で始まる行(前に0個以上の @samp{>} が付いている)は @samp{>} でクォートされているため、新しいコミットの開始と混同されることはありません。

@item
@samp{raw}

@samp{raw} 形式は、コミットオブジェクトに格納されているとおりにコミット全体を正確に表示します。とりわけ @samp{--abbrev} または @samp{--no-abbrev} のどちらが使用されているかに関係なく、ハッシュは完全に表示され、「親」(parents)情報は、移植や履歴の単純化を考慮せずに、真の親のコミットを示します。この形式は、コミットの表示方法に影響しますが、いわゆる @samp{git log --raw} の差分の表示方法ではありません。生のdiff形式で完全なオブジェクト名を取得するには、 @samp{--no-abbrev} を使用します。

@item
@samp{format:<format-string>}

@samp{format:<format-string>} 形式を使用すると、表示する情報を指定できます。注意: これはprintf書式に少し似ていますが、 @samp{\n} の代わりに @samp{%n} を使用して改行を取得するという例外に注意してください。

例: @samp{format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"} は以下のように表示されます:

@example
The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<
@end example


さて、以下がプレースホルダー達です:

@itemize 

@item
単一のリテラル文字に展開されるプレースホルダー:

@table @asis

@item  @samp{%n} 
改行(newline)

@item  @samp{%%} 
`%`そのもの

@item  @samp{%x00} 
16進数のバイト値を出力
@end table

@item
これより後ろのプレースホルダーのフォーマッティングに影響を与えるプレースホルダー:

@table @asis

@item  @samp{%Cred} 
赤色に切り替える

@item  @samp{%Cgreen} 
緑色に切り替える

@item  @samp{%Cblue} 
青色に切り替える。

@item  @samp{%Creset} 
色をリセットする

@item  @samp{%C(...)} 
git-config(1) の「CONFIGURATION FILE」の Values で説明されている色の指定。 デフォルトでは、色はログ出力が有効になっている場合にのみ表示されます(@samp{color.diff} または @samp{color.ui} または @samp{--color} によって、ターミナルに出す場合は前者の @samp{auto} 設定を尊重します)。 @samp{%C(auto,...)} は、 default の歴史的同義語として受け入れられます(例: @samp{%C(auto,red)})。 @samp{%C(always,...)} を指定すると、色が有効になっていない場合でも色が表示されます(この形式やgitが色付けする可能性のある他のすべてのものを含め、出力全体の色を有効にするために @samp{--color=always} の使用を検討してください)。 @samp{auto} のみ(つまり、 @samp{%C(auto)})は、色が再び切り替えられるまで、これに続くプレースホルダーで自動色付けをオンにします。

@item  @samp{%m} 
左(@samp{<}) または 右(@samp{>}) または 境界 (@samp{-}) の印

@item  @samp{%w([<w>[,<i1>[,<i2>]]])} 
git-shortlog(1) の -w オプションのように、行の折返しを切り替えます。

@item  @samp{%<( <N> [,trunc|ltrunc|mtrunc])} 
これの次のプレースホルダーが少なくとも N 列幅になるようにし、必要に応じて右側にスペースを詰めます。出力が N 列より長い場合は、オプションで、左側 (ltrunc) @samp{..ft} 切り捨て、または 中央 (mtrunc) @samp{mi..le} 切り捨て、または末尾切り捨て (trunc) @samp{rig..} ます (@emph{..} は省略符号)。 注意1: 切り捨ては N >= 2 の場合にのみ正しく機能します。 注意2: N および M (以下参照) 値の前後の空白はオプションです。 注意3: 絵文字やその他のワイド・キャラクタは表示桁を2つ必要とするため、桁の境界を超える可能性があります。 注意4: 複合文字マーク(character combining marks)が詰物境界で誤って分割配置される可能性があります。

@item  @samp{%<|( <M> )} 
これの次のプレースホルダーが少なくとも M 桁目の表示桁までを占めるようにし、必要に応じて右側に空白を詰めます。 端末ウィンドウの右端から測定した桁位置には、負の M 値を使用して下さい。

@item  @samp{%>( <N> )}, @samp{%>|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、左側に空白が埋め込まれます

@item  @samp{%>>( <N> )}, @samp{%>>|( <M> )} 
それぞれ @samp{%>( <N> )}, @samp{%>|( <M> )} に似ていますが、 これに続くプレースホルダーが指定よりも多くの空白を使用し、その左側に空白がある場合は、それらの空白を使用します

@item  @samp{%><( <N> )}, @samp{%><|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、 両側にパディングがあります(つまり、 テキストが中央に配置されます)
@end table

@item
コミットから抽出された情報に展開するプレースホルダー:

@table @asis

@item  @samp{%H} 
コミットハッシュ

@item  @samp{%h} 
省略されたコミットハッシュ

@item  @samp{%T} 
ツリーハッシュ

@item  @samp{%t} 
省略されたツリーハッシュ

@item  @samp{%P} 
親のハッシュ達

@item  @samp{%p} 
省略された親のハッシュ達

@item  @samp{%an} 
作者名

@item  @samp{%aN} 
作者名( .mailmap に関しては、 git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ae} 
作者電子メールアドレス

@item  @samp{%aE} 
作者電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%al} 
作者電子メールアドレスアカウント名(local-part)(@samp{@@} の前の部分)

@item  @samp{%aL} 
作者電子メールアカウント名(@samp{%al} 参照)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ad} 
作成日(フォーマットに関しては --date= オプション参照)

@item  @samp{%aD} 
作成日 RFC2822形式

@item  @samp{%ar} 
作成日 相対(relative)形式

@item  @samp{%at} 
作成日 UNIXタイムスタンプ形式

@item  @samp{%ai} 
作成日 ISO 8601風形式

@item  @samp{%aI} 
作成日 厳密なISO 8601形式

@item  @samp{%as} 
作成日 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ah} 
作者作成日(author date)の人間が読める形式(human style)(git-rev-list(1) の ‘--date=human’ に似ている)

@item  @samp{%cn} 
コミッター名

@item  @samp{%cN} 
コミッター名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ce} 
コミッター電子メールアドレス

@item  @samp{%cE} 
コミッター電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cl} 
コミッター電子メールアドレスアカウント名(local-part)( @samp{@@} の前の部分)

@item  @samp{%cL} 
コミッター電子メールアカウント名(local-part)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cd} 
コミッター日付(フォーマットに関しては @samp{--date=} オプション参照)

@item  @samp{%cD} 
コミッター日付 RFC2822形式

@item  @samp{%cr} 
コミッター日付 相対(relative)形式

@item  @samp{%ct} 
コミッター日付 UNIXタイムスタンプ形式

@item  @samp{%ci} 
コミッター日付 ISO 8601風形式

@item  @samp{%cI} 
コミッター日付 厳密なISO 8601形式

@item  @samp{%cs} 
コミッター日付 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ch} 
コミッター日付 人間が読める形式(git-rev-list(1) の @samp{--date=human} に似ている)

@item  @samp{%d} 
ref名 git-log(1) の --decorate オプションみたいなの

@item  @samp{%D} 
" (", ")" で囲ってないref名

@item  @samp{%(describe[:options])} 
git-describe(1) のような人間が読める名前。説明できないコミットの場合は空の文字列。 @samp{describe} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。タグの追加や削除を同時に行うと、説明に一貫性がなくなる可能性があります。

@itemize 

@item
@samp{tags[=<bool-value>]}: 注釈付きタグ(annotated tags)だけを考慮するのではなく、軽量タグ(lightweight tags)も考慮してください。

@item
@samp{abbrev=<number>}: 短縮ブジェクト名のデフォルトの 16 進数の桁数 (デフォルトは 7 で、リポジトリ内のオブジェクトの数によって異なります) を使用する代わりに、 <number> 桁数を指定するか、または 一意のオブジェクト名を形成するために必要な桁数。

@item
@samp{match=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグのみを考慮します。

@item
@samp{exclude=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグを対象にしません。
@end itemize

@item  @samp{%S} 
(@samp{git log --source} のような、)コマンドラインで指定した、コミットに到達したref名で、 @samp{git log} でのみ機能します。

@item  @samp{%e} 
エンコーディング

@item  @samp{%s} 
件名(subject)

@item  @samp{%f} 
ファイル名に適した、サニタイズされた件名

@item  @samp{%b} 
本文(body)

@item  @samp{%B} 
生本文(raw body)(行折り曲げされてない件名と本文)

@item  @samp{%N} 
コミットノート(commit notes)

@item  @samp{%GG} 
署名されたコミットの為のGPGからの生の検証メッセージ

@item  @samp{%G?} 
@table @asis

@item  G 
良い(good)な(有効な)署名の場合はこの文字に置換されます。

@item  B 
悪い署名(bad signature)の場合はこの文字に置換されます。

@item  U 
有効性が不明(unknown validity)な良い署名の場合はこの文字に置換されます。

@item  X 
期限切れ(eXpired)の良い署名の場合はこの文字に置換されます。

@item  Y 
期限切れのキーで作成された良い署名の場合はこの文字に置換されます。

@item  R 
取り消されたキーによって作成された良い署名の場合はこの文字に置換されます。

@item  E 
署名を確認できない場合(キーの欠落など)の場合はこの文字に置換されます。

@item  N 
署名がない場合の場合はこの文字に置換されます。
@end table

@item  @samp{%GS} 
署名されたコミットの署名者の名前を表示する

@item  @samp{%GK} 
署名されたコミットに署名するために使用されるキーを表示する

@item  @samp{%GF} 
署名されたコミットに署名するために使用されるキーのフィンガープリントを表示する

@item  @samp{%GP} 
署名付きコミットの署名に使用されたサブキー(subkey)の主キー(primary key)のフィンガープリントを表示します

@item  @samp{%GT} 
署名されたコミットに署名するために使用されるキーの信頼レベル(trust level)を表示します

@item  @samp{%gD} 
reflog セレクター(例えば @samp{refs/stash@@@{1@}} とか @samp{refs/stash@@@{2 minutes ago@}})。 この形式は、 @samp{-g} オプションで説明されている規則に従います。 @samp{@@} の前の部分は、コマンドラインで指定されたrefnameです(したがって、 @samp{git log -g refs/heads/master} は @samp{refs/heads/master@@@{0@}} を生成します)。

@item  @samp{%gd} 
短縮 reflog セレクター。 @samp{%gD} と同一ですが、人間が読みやすい形式でrefname部分が短縮されています(したがって、 @samp{refs/heads/master} は単に @samp{master} になります)。

@item  @samp{%gn} 
reflog ID名

@item  @samp{%gN} 
reflog ID名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ge} 
reflog ID 電子メールアドレス

@item  @samp{%gE} 
reflog ID 電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%gs} 
reflog 件名

@item  @samp{%(trailers[:options])} 
git-interpret-trailers(1) によって解釈されるようにボディのトレーラーを表示します。 @samp{trailers} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。いずれかのオプションが複数回提供された場合、それぞれ最後のものが優先されます。

@itemize 

@item
@samp{key=<key>}: 指定された <key> を持つトレーラーのみを表示します。マッチングは大文字と小文字を区別せずに行われ、末尾のコロンはオプションです。オプションが複数回指定されている場合、いずれかのキーに一致するトレーラー行が表示されます。このオプションは自動的に @samp{only} オプションを有効にして、トレーラーブロック内の非トレーラー行が非表示になるようにします。それが望ましくない場合は、 @samp{only=false} で無効にすることができます。 たとえば、 @samp{%(trailers:key=Reviewed-by)} は、キーが `Reviewed-by`のトレーラー行を表示します。

@item
@samp{only[=<bool>]}: トレーラーブロックに非トレーラー行を含めるかどうかを選択します。

@item
@samp{separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラー行は改行文字で終了します。文字列 <sep> には、上記のリテラルフォーマットコードが含まれる場合があります。区切り文字としてコンマを使用するには、次のオプションとして解析されないよう @samp{%x2C} を使用する必要があります。 たとえば、 @samp{%(trailers:key=Ticket,separator=%x2C )} は、キーが @samp{Ticket} であるすべてのトレーラー行をカンマとスペースで区切って表示します。

@item
@samp{unfold[=<bool>]}: interpret-trailer の @samp{--unfold} オプションが指定されたかのように動作させます。たとえば、 @samp{%(trailers:only,unfold=true)} が展開され、すべてのトレーラー行が表示されます。

@item
@samp{keyonly[=<bool>]}: トレーラーのキー部分のみを表示。

@item
@samp{valueonly[=<bool>]}: トレーラーの値部分のみ表示。

@item
@samp{key_value_separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラーのキーと値のペアは ": " で区切られます。 それ以外の場合は、上記の @samp{separator=<sep>} と同じセマンティクスを共有します。
@end itemize
@end table
@end itemize
@end itemize

@quotation

@strong{Note}

一部のプレースホルダーは、リビジョントラバーサルエンジンに指定された他のオプションに依存する場合があります。 たとえば、 @samp{%g*} reflogオプションは、reflogエントリをトラバースしない限り(たとえば、 @samp{git log -g} によって)空の文字列を挿入します。コマンドラインで @samp{--decorate} がまだ指定されていない場合、 @samp{%d} と @samp{%D} プレースホルダーは「短い」(short)装飾形式を使用します。
@end quotation

ブール値オプションは、オプションの値 @samp{[=<bool-value>]} を受け入れます。 値 @samp{true} 、@samp{false} 、 @samp{on} 、@samp{off} などはすべて受け入れられます。 git-config(1) の "EXAMPLES" の "boolean" サブセクションを参照してください。ブール値オプションが値なしで指定された場合、それは有効を指定した事になります。

プレースホルダーの @samp{%} の後に @samp{+} (プラス記号)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。

プレースホルダーの @samp{%} の後に @samp{-} (マイナス記号)を追加すると、プレースホルダーが空の文字列に展開された場合にのみ、展開の直前の連続するすべての改行が削除されます。

プレースホルダーの @samp{%} の後に " " (スペース)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前にスペースが挿入されます。

@itemize 

@item
@samp{tformat:}

@samp{tformat:} 形式は、 "separator" セマンティクスの代わりに "terminator" セマンティクスを提供することを除いて、 @samp{format:} とまったく同じように機能します。 つまり、各コミットには、エントリ間に区切り文字を配置するのではなく、メッセージターミネータ文字(通常は改行)が追加されます。 これは、「1行」形式と同様に、1行形式の最終エントリが新しい行で適切に終了することを意味します。 例えば以下のようになります:

@example
$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973
@end example


加えて、 @samp{%} が含まれている認識されない文字列は、その前に @samp{tformat:} があるかのように解釈(interpret)されます。 たとえば、以下の2つは同等です:

@example
$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef
@end example

@end itemize

@noindent

@chapheading Raw output format

@samp{git-diff-index} と @samp{git-diff-tree} と @samp{git-diff-files} と @samp{git diff --raw} からの生の出力形式は非常に似ています。

これらのコマンドはすべて、2つのセットを比較します。なお、比較されるものは異なります:

@table @asis

@item  git-diff-index <tree-ish> 
<tree-ish> とファイルシステム上のファイルを比較します。

@item  git-diff-index --cached <tree-ish> 
<tree-ish> とインデックスを比較します。

@item  git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>…] 
2つの引数で指定されたツリーを比較します。

@item  git-diff-files [<pattern>…] 
インデックスとファイルシステム上のファイルを比較します。
@end table

"git-diff-tree" コマンドは、比較対象のハッシュ値を出力することで出力を開始します。その後、すべてのコマンドは、変更されたファイルごとに1つの出力行を出力します。

出力行は以下のようにフォーマットされます:

@example
in-place edit  :100644 100644 bcd1234 0123456 M file0
copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2
rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3
create         :000000 100644 0000000 1234567 A file4
delete         :100644 000000 1234567 0000000 D file5
unmerged       :000000 000000 0000000 0000000 U file6
@end example


つまり、左から右へ:

@enumerate 

@item
コロン(:)

@item
"src" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"dst" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"src" のsha1。作成(creation)またはマージされていない(unmerged)場合は 0@{40@}

@item
空白

@item
"dst" のsha1; 削除、またはマージされていない(unmerged)、または「ワーク・ツリーがインデックスと同期していない」場合は 0@{40@}

@item
空白

@item
ステータスの後に、オプションの「スコア数」("score" number)が続きます

@item
@samp{-z} オプションが使用されている場合はタブまたはNUL

@item
"src" のパス

@item
@samp{-z} オプションが使用されている場合タブまたはNUL。ステータスCまたはRにのみ存在します

@item
"dst" のパス。ステータスCまたはRにのみ存在します

@item
LFでレコードを終了します。 @samp{-z} オプションが使用されている場合はNULでレコードを終了します。
@end enumerate

ステータス文字の種類は以下のとおり:

@itemize 

@item
A: ファイルの追加

@item
C: ファイルを新しいファイルにコピー

@item
D: ファイルの削除

@item
M: ファイルの内容やモードの変更

@item
R: ファイル名の名前変更

@item
T: ファイルのタイプを変更(通常ファイル または シンボリックリンク または サブモジュール)

@item
U: ファイルはマージされていません(コミットする前にマージを完了する必要があります)

@item
X: 「不明な」変更タイプ(おそらくバグです。報告してください)
@end itemize

ステータス文字CとRの後には常にスコアが続きます(移動またはコピーのソースとターゲットの間の類似性のパーセンテージを示します)。ステータス文字Mの後には、ファイルの書き換えのスコア(非類似度のパーセンテージを示す)が続く場合があります。

ファイルシステム上のファイルがインデックスと同期していない場合、 ”dst” の sha1 はすべて 0 として表示されます。

例:

@example
:100644 100644 5be4a4a 0000000 M file.c
@end example


@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

@noindent

@chapheading diff format for merges

"git-diff-tree" と "git-diff-files" と "git-diff --raw" は、 @samp{-c} または @samp{--cc} オプションを使用して、マージコミットに対してもdiff出力を生成できます。出力は、以下の点で上記の形式とは異なります:

@enumerate 

@item
親ごとにコロン(:)があります

@item
より多くの "src" モードと "src" sha1があります

@item
statusは、各親のステータス文字を連結したものです

@item
オプションの「スコア数」はありません

@item
ファイルのタブ区切りのパス名
@end enumerate

@samp{-c} および ` -cc` の場合、履歴のいずれかの側でファイルの名前が変更された場合でも、宛先(dst)または最終パスのみが表示されます。 @samp{--combined-all-paths} を使用すると、各親のパスの名前が表示され、それに続いてマージコミットのパスの名前が表示されます。

例: @samp{--combined-all-paths} を使用しない @samp{-c} および @samp{--cc} の場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       phooey.c
@end example


例: @samp{-c} または @samp{--cc} のいずれかに @samp{--combined-all-paths} が追加された場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c  desc.c  desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       foo.sh  bar.sh  bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       fooey.c fuey.c  phooey.c
@end example


注意: @samp{combined diff} は、すべての親から変更されたファイルのみをリストすることに注意してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading other diff formats

@samp{--summary} オプションは、新しく追加、削除、名前変更、およびコピーされたファイルを説明します。@samp{--stat} オプションは、 diffstat(1) グラフ を出力に追加します。これらのオプションは、 @samp{-p} などの他のオプションと組み合わせることができ、人間が読むことを目的としています。

名前の変更またはコピーを伴う変更を表示する場合、 @samp{--stat} 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。 たとえば、4行を変更(modify)しながら @samp{arch/i386/Makefile} を @samp{arch/x86/Makefile} に移動(move)する変更(change)は、次のように表示されます:

@example
arch/@{i386 => x86@}/Makefile    |   4 +--
@end example


@samp{--numstat} オプションは diffstat(1) 情報を提供しますが、人間ではなくソフトウェアで読むのを容易にするように設計されています。 @samp{--numstat} 出力のエントリは以下のようになります:

@example
1       2       README
3       1       arch/@{i386 => x86@}/Makefile
@end example


この形式は、左から右へ:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
パス名(おそらく rename/copy 情報を含む)

@item
改行
@end enumerate

@samp{-z} 出力オプションが有効な場合、出力は以下のようにフォーマットされます:

@example
1       2       README NUL
3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
@end example


これは:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
NUL(rename/copy された場合のみ存在します)

@item
プリイメージのパス名

@item
NUL(rename/copy された場合のみ存在します)

@item
ポストイメージのパス名(rename/copy された場合のみ存在します)

@item
NUL
@end enumerate

名前が変更された場合のプリイメージパスの前の追加の @samp{NUL} は、出力を読み取るスクリプトが、先読みせずに、読み取られている現在のレコードがシングルパスレコードであるか、名前変更/コピーレコードであるか、を判断できるようにするためです。追加および削除された行を読み取った後、 @samp{NUL} まで読み取るとパス名が生成されますが、それが @samp{NUL} の場合、レコードには2つのパスが表示されます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-diff,,,Top
@chapheading Name

git-diff — コミット、コミット、作業ツリーなどの間の変更を表示する

@noindent

@chapheading Synopsis

@display
git diff [<options>] [<commit>] [--] [<path>…]
git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>…]
git diff [<options>] [--merge-base] <commit> [<commit>…] <commit> [--] [<path>…]
git diff [<options>] <commit>…<commit> [--] [<path>…]
git diff [<options>] <blob> <blob>
git diff [<options>] --no-index [--] <path> <path>
@end display


@noindent

@chapheading DESCRIPTION

作業ツリーとインデックスまたはツリー間の変更、インデックスとツリー間の変更、2つのツリー間の変更、マージによる変更、2つのBLOBオブジェクト間の変更、ディスク上の2つのファイル間の変更を表示します。

@table @asis

@item  @samp{git diff [<options>] [--] [<path>...]} 
この形式は、インデックス(次のコミットのステージング領域)に関連して行った変更を表示するためのものです。 言い換えれば、差異は、Gitにさらにインデックスに追加するように指示「可能な」ものですが、まだ追加していないものです。 git-add(1) を使用して、これらの変更をステージングできます。

@item  @samp{git diff [<options>] --no-index [--] <path> <path>} 
この形式は、ファイルシステム上の指定された2つのパスを比較するためのものです。 Gitによって制御される作業ツリーでコマンドを実行し、パスの少なくとも1つが作業ツリーの外部を指す場合、またはGitによって制御される作業ツリーの外部でコマンドを実行する場合は、 @samp{--no-index} オプションを省略できます。 この形式は、 @samp{--exit-code} の指定を含んでいます。

@item  @samp{git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]} 
この形式は、指定された<commit>に関連する次のコミットのためにステージングした変更を表示するためのものです。 通常、最新のコミットとの比較が必要になるため、<commit>を指定しない場合、デフォルトでHEADになります。 HEADが存在せず(つまり、まだブランチが無い)、かつ、<commit>が指定されていない場合、すべてのステージされた変更が表示されます。 @samp{--staged} は @samp{--cached} の同義語です。

@samp{--merge-base} が指定されている場合は、<commit>を使用する代わりに、<commit>とHEADのマージベースを使用します。 @samp{git diff --cached --merge-base A} は @samp{git diff --cached $(git merge-base A HEAD)} と同等です。

@item  @samp{git diff [<options>] [--merge-base] <commit> [--] [<path>...]} 
この形式は、指定された<commit>に関連する作業ツリーでの変更を表示するためのものです。 HEADを使用して最新のコミットと比較したり、ブランチ名を使用して別のブランチの先端と比較したりできます。

@samp{--merge-base} が指定されている場合は、<commit>を使用する代わりに、<commit>とHEADのマージベースを使用します。 @samp{git diff --merge-base A} は @samp{git diff $(git merge-base A HEAD)} と同等です。

@item  @samp{git diff [<options>] [--merge-base] <commit> <commit> [--] [<path>...]} 
これは、2つの任意の<commit>間の変更を表示するためのものです。

@samp{--merge-base} が指定されている場合は、「前」側に2つのコミットのマージベースを使用します。 @samp{git diff --merge-base A B} は @samp{git diff --merge-baseAB} と同等です。

@item  @samp{git diff [<options>] <commit> <commit>... <commit> [--] [<path>...]} 
This form is to view the results of a merge commit. The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents. Convenient ways to produce the desired set of revisions are to use the suffixes @samp{^@@} and @samp{^!}. If A is a merge commit, then @samp{git diff A A^@@}, @samp{git diff A^!} and @samp{git show A} all give the same combined diff.

@item  @samp{git diff [<options>] <commit>..<commit> [--] [<path>...]} 
これは、2つの任意の<commit>間の変更を表示するための以前の形式(@samp{..} なし)と同義です。片側の<commit>を省略すると、代わりにHEADを使用した場合と同じ効果があります。

@item  @samp{git diff [<options>] <commit>\...<commit> [--] [<path>...]} 
この形式は、両方の<commit>の共通の祖先から開始して、2番目の<commit>を含むブランチの変更を表示するためのものです。 @samp{git diff A...B} は @samp{git diff $(git merge-base A B) B} と同等です。 <commit>のいずれかを省略できます。これは、代わりにHEADを使用するのと同じ効果があります。
@end table

Just in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the @samp{--merge-base} case and in the last two forms that use @samp{..} notations, can be any <tree>. A tree of interest is the one pointed to by the special ref @samp{AUTO_MERGE}, which is written by the @emph{ort} merge strategy upon hitting merge conflicts (see git-merge(1)). Comparing the working tree with @samp{AUTO_MERGE} shows changes you’ve made so far to resolve textual conflicts (see the examples below).

<commit>を綴る方法のより完全なリストについては、 gitrevisions(7) の「SPECIFYING REVISIONS」セクションを参照してください。 ただし、 diffは範囲ではなく2つの「エンドポイント」を比較することであり、その範囲表記(@samp{<commit>..<commit>} や @samp{<commit>...<commit>})は、 gitrevisions(7) の「SPECIFYING RANGES」セクションで定義されている範囲を意味するものではありません。

@table @asis

@item  @samp{git diff [<options>] <blob> <blob>} 
この形式は、2つのBLOBオブジェクトの生のコンテンツの違いを表示するためのものです。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p").
これがデフォルトです。

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
生形式(raw format)でdiffを生成します。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
@samp{--raw} または @samp{--numstat} または @samp{--name-only} または @samp{--name-status} が指定されている場合は
パス名を変更せず、出力フィールドターミネータとしてNULLを使用してください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。
@samp{color.ui} と @samp{color.diff} 構成設定で
変更できます。

@item  @samp{--no-color} 
カラーdiffをオフにします。
これは、構成設定(configuration settings)を上書きするために使用できます。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
これは、 @samp{diff.colorMoved} 構成設定によって変更できます。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
@samp{diff.colorMovedWS} 構成設定で設定できます。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
名前の変更(renames)を検知する。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--exit-code} 
diff(1）と同様のコードでプログラムを終了させます。つまり、違いがあった場合は 1 で終了し、 0 は違いがないことを意味します。

@item  @samp{--quiet} 
プログラムのすべての出力を無効にします。 @samp{--exit-code} を意味します。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@table @asis

@item  @samp{-1 --base} 
@itemx  @samp{-2 --ours} 
@itemx  @samp{-3 --theirs} 
作業ツリーを、「base」バージョン(ステージ #1)または「our branch」(私達のブランチ)(ステージ #2)または「their branch」(彼らのブランチ)(ステージ #3) と比較します。 インデックスには、マージされていないエントリの場合、つまり競合を解決している場合にのみ、これらのステージが含まれます。 詳細については、 git-read-tree(1) の「3-Way Merge」セクションを参照してください。

@item  @samp{-0} 
マージされていないエントリのdiff出力を省略し、「Unmerged」とだけ表示します。 作業ツリーをインデックスと比較する場合にのみ使用できます。

@item  <path>… 
<paths>パラメータを指定すると、diffを名前付きパスに制限するために使用されます(あなたはディレクトリ名を指定して、その下にあるすべてのファイルのdiffを取得できます)。
@end table

@noindent

@chapheading Raw output format

@samp{git-diff-index} と @samp{git-diff-tree} と @samp{git-diff-files} と @samp{git diff --raw} からの生の出力形式は非常に似ています。

これらのコマンドはすべて、2つのセットを比較します。なお、比較されるものは異なります:

@table @asis

@item  git-diff-index <tree-ish> 
<tree-ish> とファイルシステム上のファイルを比較します。

@item  git-diff-index --cached <tree-ish> 
<tree-ish> とインデックスを比較します。

@item  git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>…] 
2つの引数で指定されたツリーを比較します。

@item  git-diff-files [<pattern>…] 
インデックスとファイルシステム上のファイルを比較します。
@end table

"git-diff-tree" コマンドは、比較対象のハッシュ値を出力することで出力を開始します。その後、すべてのコマンドは、変更されたファイルごとに1つの出力行を出力します。

出力行は以下のようにフォーマットされます:

@example
in-place edit  :100644 100644 bcd1234 0123456 M file0
copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2
rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3
create         :000000 100644 0000000 1234567 A file4
delete         :100644 000000 1234567 0000000 D file5
unmerged       :000000 000000 0000000 0000000 U file6
@end example


つまり、左から右へ:

@enumerate 

@item
コロン(:)

@item
"src" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"dst" のモード。作成(creation)またはマージされていない(unmerged)場合は 000000

@item
空白

@item
"src" のsha1。作成(creation)またはマージされていない(unmerged)場合は 0@{40@}

@item
空白

@item
"dst" のsha1; 削除、またはマージされていない(unmerged)、または「ワーク・ツリーがインデックスと同期していない」場合は 0@{40@}

@item
空白

@item
ステータスの後に、オプションの「スコア数」("score" number)が続きます

@item
@samp{-z} オプションが使用されている場合はタブまたはNUL

@item
"src" のパス

@item
@samp{-z} オプションが使用されている場合タブまたはNUL。ステータスCまたはRにのみ存在します

@item
"dst" のパス。ステータスCまたはRにのみ存在します

@item
LFでレコードを終了します。 @samp{-z} オプションが使用されている場合はNULでレコードを終了します。
@end enumerate

ステータス文字の種類は以下のとおり:

@itemize 

@item
A: ファイルの追加

@item
C: ファイルを新しいファイルにコピー

@item
D: ファイルの削除

@item
M: ファイルの内容やモードの変更

@item
R: ファイル名の名前変更

@item
T: ファイルのタイプを変更(通常ファイル または シンボリックリンク または サブモジュール)

@item
U: ファイルはマージされていません(コミットする前にマージを完了する必要があります)

@item
X: 「不明な」変更タイプ(おそらくバグです。報告してください)
@end itemize

ステータス文字CとRの後には常にスコアが続きます(移動またはコピーのソースとターゲットの間の類似性のパーセンテージを示します)。ステータス文字Mの後には、ファイルの書き換えのスコア(非類似度のパーセンテージを示す)が続く場合があります。

ファイルシステム上のファイルがインデックスと同期していない場合、 ”dst” の sha1 はすべて 0 として表示されます。

例:

@example
:100644 100644 5be4a4a 0000000 M file.c
@end example


@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

@noindent

@chapheading diff format for merges

"git-diff-tree" と "git-diff-files" と "git-diff --raw" は、 @samp{-c} または @samp{--cc} オプションを使用して、マージコミットに対してもdiff出力を生成できます。出力は、以下の点で上記の形式とは異なります:

@enumerate 

@item
親ごとにコロン(:)があります

@item
より多くの "src" モードと "src" sha1があります

@item
statusは、各親のステータス文字を連結したものです

@item
オプションの「スコア数」はありません

@item
ファイルのタブ区切りのパス名
@end enumerate

@samp{-c} および ` -cc` の場合、履歴のいずれかの側でファイルの名前が変更された場合でも、宛先(dst)または最終パスのみが表示されます。 @samp{--combined-all-paths} を使用すると、各親のパスの名前が表示され、それに続いてマージコミットのパスの名前が表示されます。

例: @samp{--combined-all-paths} を使用しない @samp{-c} および @samp{--cc} の場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       phooey.c
@end example


例: @samp{-c} または @samp{--cc} のいずれかに @samp{--combined-all-paths} が追加された場合:

@example
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c  desc.c  desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       foo.sh  bar.sh  bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       fooey.c fuey.c  phooey.c
@end example


注意: @samp{combined diff} は、すべての親から変更されたファイルのみをリストすることに注意してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading other diff formats

@samp{--summary} オプションは、新しく追加、削除、名前変更、およびコピーされたファイルを説明します。@samp{--stat} オプションは、 diffstat(1) グラフ を出力に追加します。これらのオプションは、 @samp{-p} などの他のオプションと組み合わせることができ、人間が読むことを目的としています。

名前の変更またはコピーを伴う変更を表示する場合、 @samp{--stat} 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。 たとえば、4行を変更(modify)しながら @samp{arch/i386/Makefile} を @samp{arch/x86/Makefile} に移動(move)する変更(change)は、次のように表示されます:

@example
arch/@{i386 => x86@}/Makefile    |   4 +--
@end example


@samp{--numstat} オプションは diffstat(1) 情報を提供しますが、人間ではなくソフトウェアで読むのを容易にするように設計されています。 @samp{--numstat} 出力のエントリは以下のようになります:

@example
1       2       README
3       1       arch/@{i386 => x86@}/Makefile
@end example


この形式は、左から右へ:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
パス名(おそらく rename/copy 情報を含む)

@item
改行
@end enumerate

@samp{-z} 出力オプションが有効な場合、出力は以下のようにフォーマットされます:

@example
1       2       README NUL
3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
@end example


これは:

@enumerate 

@item
追加行数

@item
タブ

@item
削除行数

@item
タブ

@item
NUL(rename/copy された場合のみ存在します)

@item
プリイメージのパス名

@item
NUL(rename/copy された場合のみ存在します)

@item
ポストイメージのパス名(rename/copy された場合のみ存在します)

@item
NUL
@end enumerate

名前が変更された場合のプリイメージパスの前の追加の @samp{NUL} は、出力を読み取るスクリプトが、先読みせずに、読み取られている現在のレコードがシングルパスレコードであるか、名前変更/コピーレコードであるか、を判断できるようにするためです。追加および削除された行を読み取った後、 @samp{NUL} まで読み取るとパス名が生成されますが、それが @samp{NUL} の場合、レコードには2つのパスが表示されます。

@noindent

@chapheading EXAMPLES

@table @asis

@item  あなたの作業ツリーを確認するさまざまな方法 
@example
$ git diff            (1)
$ git diff --cached   (2)
$ git diff HEAD       (3)
$ git diff AUTO_MERGE (4)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
次のコミットのためにまだステージングされていない作業ツリーの変更。

@item @pxref{CO1-2,,(2)}
インデックスと最後のコミットの間の変更。 @samp{-a} オプションなしで @samp{git commit} を実行した場合にコミットする内容です。

@item @pxref{CO1-3,,(3)}
最後のコミット以降の作業ツリーの変更。 @samp{git commit -a} を実行した場合にコミットする内容です。

@item @pxref{CO1-4,,(4)}
Changes in the working tree you’ve made to resolve textual conflicts so far.
@end table

@item  任意のコミットとの比較 
@example
$ git diff test            (1)
$ git diff HEAD -- ./test  (2)
$ git diff HEAD^ HEAD      (3)
@end example


@table @asis

@item @pxref{CO2-1,,(1)}
現在のブランチの先端を使用する代わりに、「テスト」ブランチの先端と比較してください。

@item @pxref{CO2-2,,(2)}
「test」ブランチの先端と比較する代わりに、現在のブランチの先端と比較しますが、比較をファイル「test」に限定します。

@item @pxref{CO2-3,,(3)}
最後のコミットと、最後のコミットのその前のバージョンを比較します。
@end table

@item  Comparing branches 
@example
$ git diff topic master    (1)
$ git diff topic..master   (2)
$ git diff topic...master  (3)
@end example


@table @asis

@item @pxref{CO3-1,,(1)}
topicの先端とmasterブランチの間の変更。

@item @pxref{CO3-2,,(2)}
上と同じ。

@item @pxref{CO3-3,,(3)}
topicブランチが開始されてからmasterブランチで発生した変更。
@end table

@item  Limiting the diff output 
@example
$ git diff --diff-filter=MRC            (1)
$ git diff --name-status                (2)
$ git diff arch/i386 include/asm-i386   (3)
@end example


@table @asis

@item @pxref{CO4-1,,(1)}
変更、名前変更、コピーのみを表示し、追加や削除は表示しません。

@item @pxref{CO4-2,,(2)}
名前と変更の性質のみを表示し、実際の差分出力は表示しません。

@item @pxref{CO4-3,,(3)}
diff出力を名前付きサブツリーに制限します。
@end table

@item  diff出力をこねくりまわす(muging) 
@example
$ git diff --find-copies-harder -B -C  (1)
$ git diff -R                          (2)
@end example


@table @asis

@item @pxref{CO5-1,,(1)}
名前の変更、コピー、完全な書き換えを見つけるために余分なサイクルを費やします(非常に高価です)。

@item @pxref{CO5-2,,(2)}
逆のdiffを出力します。
@end table
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  diff.autoRefreshIndex 
@emph{git diff} を使用して作業ツリーファイルと比較する場合、統計のみの変更を変更されたものと見なさない。代わりに、サイレントに @samp{git update-index --refresh} を実行して、ワークツリーの内容がインデックスの内容と一致するパスの、キャッシュされた統計情報を更新します。このオプションのデフォルトはtrueです。注意: これは @samp{git diff} 磁器コマンドにのみ影響し、 @samp{git diff-files} などの下位レベルのdiffコマンドには影響しないことに注意してください。

@item  diff.dirstat 
git-diff(1) およびその仲間に対する @samp{--dirstat} オプションのデフォルトの動作を指定する @samp{--dirstat} パラメーターのコンマ区切りリスト。デフォルトは(@samp{--dirstat=<param1,param2,...>} を使用して)コマンドラインでオーバーライドできます。フォールバックのデフォルトは @samp{changes,noncumulative,3} です(@samp{diff.dirstat} によって変更されていない限り)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加 された行数を合計して、dirstat数を計算します。(バイナリファイルの場合、バイナリファイルには行の自然な概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりもコストのかかる @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。 結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最も安価な @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更もカウントします。 @samp{cumulative} を使用する場合、報告されるパーセンテージの合計が100％を超える場合があることに注意してください。 デフォルトの(非累積的な)動作は、 @samp{non-cumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。変更への貢献がこの割合より少ないディレクトリは出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウントする: @samp{files,10,cumulative}

@item  diff.statGraphWidth 
@samp{--stat} 出力でグラフ部分の幅を制限します。設定されている場合、format-patchを除く @samp{--stat} 出力を生成するすべてのコマンドに適用されます。

@item  diff.context 
デフォルトの3ではなく<n>行のコンテキストで差分を生成します。この値は @samp{-U} オプションによってオーバーライドされます。

@item  diff.interHunkContext 
指定された行数までのdiffハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。この値は、 @samp{--inter-hunk-context} コマンドラインオプションのデフォルトとして機能します。

@item  diff.external 
この構成変数が設定されている場合、diffの生成は、内部のdiff機構を使用して実行されるのではなく、指定されたコマンドを使用して実行されます。 ‘GIT_EXTERNAL_DIFF’ 環境変数でオーバーライドできます。このコマンドは、 git(1) の「git Diffs」で説明されているパラメーターを使用して呼び出されます。 注意: ファイルのサブセットでのみ外部diffプログラムを使用する場合は、代わりに gitattributes(5) を使用することをお勧めします。

@item  diff.ignoreSubmodules 
@samp{--ignore-submodules} のデフォルト値を設定します。これは @samp{git diff} 磁器コマンドにのみ影響し、 @samp{git diff-files} などの下位レベルのdiffコマンドには影響しないことに注意してください。 @samp{git checkout} や @samp{git switch} も、コミットされていない変更を報告するときにこの設定を尊重します。 @emph{all} に設定すると、 @samp{--ignore-submodules} コマンドラインオプションを使用してオーバーライドされない限り、 @samp{status.submoduleSummary} が設定されている場合、通常は @emph{git commit} および @emph{git status} で表示されるサブモジュールの概要が無効になります。 @emph{git submodule} コマンドは、この設定の影響を受けません。デフォルトでは、これは untracked に設定されているため、追跡されていないサブモジュールはすべて無視されます。

@item  diff.mnemonicPrefix 
設定されている場合、 @samp{git diff} は、比較対象に応じて標準の @emph{a/} や @emph{b/} とは異なるプレフィックスのペアを使用します。この構成が有効な場合、逆差分出力でもプレフィックスの順序が入れ替わります:

@table @asis

@item  @samp{git diff} 
(i)ndex と (w)ork tree を比較

@item  @samp{git diff HEAD} 
(c)ommit と (w)ork tree を比較

@item  @samp{git diff --cached} 
(c)ommit と (i)ndex を比較

@item  @samp{git diff HEAD:file1 file2} 
(o)bject と (w)ork tree エンティティを比較

@item  @samp{git diff --no-index a b} 
2つの非git項目 (1) と (2) を比較
@end table

@item  diff.noprefix 
設定されている場合、 @samp{git diff} は送信元または宛先のプレフィックスを表示しません。

@item  diff.relative 
@emph{true} に設定すると、 @emph{git diff} はディレクトリ外の変更を表示せず、現在のディレクトリへの相対的なパス名を表示します。

@item  diff.orderFile 
diff内でファイルを並べ替える方法を示すファイル。 詳細については、 git-diff(1) の @samp{-O} オプションを参照してください。 @samp{diff.orderFile} が相対パス名の場合、作業ツリーの最上位を基準として扱います。

@item  diff.renameLimit 
コピー/名前変更 の検出の徹底的な部分で考慮するファイルの数。 @emph{git diff} の @samp{-l} オプションと同等です。設定されていない場合、デフォルト値は現在1000です。この設定は、名前変更の検出がオフになっている場合は効果がありません。

@item  diff.renames 
Gitが名前の変更を検出するかどうかとその方法。 "false" に設定すると、名前変更の検出が無効になります。 "true" に設定すると、基本的な名前変更の検出が有効になります。 "copies" または "copy" に設定されている場合、Gitはコピーも検出します。デフォルトはtrueです。これは git-diff(1) や git-log(1) のような @emph{git diff} 磁器コマンドにのみ影響し、 git-diff-files(1) などの下位レベルのコマンドには影響しないことに注意してください。

@item  diff.suppressBlankEmpty 
空の出力行の前にスペースを印刷する標準的な動作を禁止するブール値。デフォルトはfalseです。

@item  diff.submodule 
サブモジュールの違いを表示する形式を指定します。 "short" 形式は、範囲の最初と最後にコミットの名前を表示するだけです。 "log" 形式は、 git-submodule(1) の @samp{summary} のように範囲内のコミットをリストします。 "diff" 形式は、サブモジュールの変更された内容のインラインdiffを示します。デフォルトは "short" です。

@item  diff.wordRegex 
単語ごとの差の計算を実行するときに「単語」(word)とは何かを判別するために使用されるPOSIX拡張正規表現。正規表現に一致する文字シーケンスは「単語」(words)であり、他のすべての文字は*無視できる*空白(whitespace)です。

@item  diff.<driver>.command 
カスタムdiffドライバーコマンド。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.xfuncname 
diffドライバーがハンクヘッダーを認識するために使用する必要がある正規表現。内蔵パターンを使用することもできます。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.binary 
このオプションをtrueに設定すると、diffドライバーがファイルをバイナリとして処理します。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.textconv 
ファイルのテキスト変換バージョンを生成するためにdiffドライバーが呼び出す必要のあるコマンド。変換の結果は、人間が読める形式のdiffを生成するために使用されます。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.wordRegex 
diffドライバーが単語(words)を1行に分割するために使用する必要がある正規表現。詳細については gitattributes(5) を参照してください。

@item  diff.<driver>.cachetextconv 
このオプションをtrueに設定すると、diffドライバーがテキスト変換出力をキャッシュするようになります。詳細については gitattributes(5) を参照してください。

@table @asis

@item  @samp{araxis} 
Use Araxis Merge (requires a graphical session)

@item  @samp{bc} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc3} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc4} 
Use Beyond Compare (requires a graphical session)

@item  @samp{codecompare} 
Use Code Compare (requires a graphical session)

@item  @samp{deltawalker} 
Use DeltaWalker (requires a graphical session)

@item  @samp{diffmerge} 
Use DiffMerge (requires a graphical session)

@item  @samp{diffuse} 
Use Diffuse (requires a graphical session)

@item  @samp{ecmerge} 
Use ECMerge (requires a graphical session)

@item  @samp{emerge} 
Use Emacs' Emerge

@item  @samp{examdiff} 
Use ExamDiff Pro (requires a graphical session)

@item  @samp{guiffy} 
Use Guiffy’s Diff Tool (requires a graphical session)

@item  @samp{gvimdiff} 
Use gVim (requires a graphical session)

@item  @samp{kdiff3} 
Use KDiff3 (requires a graphical session)

@item  @samp{kompare} 
Use Kompare (requires a graphical session)

@item  @samp{meld} 
Use Meld (requires a graphical session)

@item  @samp{nvimdiff} 
Use Neovim

@item  @samp{opendiff} 
Use FileMerge (requires a graphical session)

@item  @samp{p4merge} 
Use HelixCore P4Merge (requires a graphical session)

@item  @samp{smerge} 
Use Sublime Merge (requires a graphical session)

@item  @samp{tkdiff} 
Use TkDiff (requires a graphical session)

@item  @samp{vimdiff} 
Use Vim

@item  @samp{winmerge} 
Use WinMerge (requires a graphical session)

@item  @samp{xxdiff} 
Use xxdiff (requires a graphical session)
@end table

@item  diff.indentHeuristic 
このオプションを @samp{false} に設定すると、パッチを読みやすくするためにdiffハンク境界をシフトするデフォルトのヒューリスティックが無効になります。

@item  diff.algorithm 
diffアルゴリズムを選択します。 派生形は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして。可能な限り最小の差分が生成されるようにします。

@item  @samp{patience} 
パッチを生成するときは、patience diff(忍耐差分)アルゴリズムを使用してください。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズムを拡張して、「発生頻度の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

@item  diff.wsErrorHighlight 
差分の @samp{context} または @samp{old または `new} 行の空白エラー(whitespace errors)を強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は @samp{old,new,context} の省略形です。空白のエラー(whitespace errors)は @samp{color.diff.whitespace} で色分けされています。コマンドラインオプション @samp{--ws-error-highlight=<kind>} はこの設定を上書きします。

@item  diff.colorMoved 
有効な @samp{<mode>} またはtrueのいずれかに設定すると、diff内の移動された行が異なる色で表示されます。有効なモードの詳細については、 git-diff(1) の @samp{--color-moved} を参照してください。単にtrueに設定すると、デフォルトのカラーモードが使用されます。 falseに設定すると、移動した行は色付けされません。

@item  diff.colorMovedWS 
このオプションは、例えば @samp{diff.colorMoved} 設定を使用して移動した行に色を付ける場合、スペース(spaces)をどのように扱うかを @samp{<mode>} で制御します。有効なモードの詳細については git-diff(1) の @samp{--color-moved-ws} を参照してください。
@end table

@noindent

@chapheading SEE ALSO

diff(1), git-difftool(1), git-log(1), gitdiffcore(7), git-format-patch(1), git-apply(1), git-show(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-difftool,,,Top
@chapheading Name

git-difftool — 一般的なdiffツールを使用して変更を表示します

@noindent

@chapheading Synopsis

@display
git difftool [<options>] [<commit> [<commit>]] [--] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

@samp{git difftool} は、一般的なdiffツールを使用してリビジョン間でファイルを比較および編集できるようにするGitコマンドです。 @samp{git difftool} は @samp{git diff} のフロントエンドであり、同じオプションと引数を受け入れます。 git-diff(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-d} 
@itemx  @samp{--dir-diff} 
変更したファイルを一時的な場所にコピーし、それらに対してディレクトリdiffを実行します。 このモードは、diffツールを起動する前にプロンプトを表示することはありません。

@item  @samp{-y} 
@itemx  @samp{--no-prompt} 
diffツールを起動する前にプロンプトを表示しないでください。

@item  @samp{--prompt} 
diffツールを呼び出す前にプロンプトを表示します。 これがデフォルトの振る舞いです。 オプションは、構成設定を上書きするために提供されています。

@item  @samp{--rotate-to=<file>} 
指定のパスのdiffの表示から開始します。これ以前のパスは最後の後ろに回されます(訳注: @samp{git difftool} で a,b,c,d,e の場合、 @samp{--rotate-to=c} とすると、 c,d,e,a,b,c の順になる)

@item  @samp{--skip-to=<file>} 
その前のすべてのパスをスキップして、指定されたパスのdiffの表示から開始します(訳注: a,b,c,d,e の場合、 @samp{--skip-to=c} は c,d,e)

@item  @samp{-t <tool>} 
@itemx  @samp{--tool=<tool>} 
<tool> で指定されたdiffツールを使用します。 有効な値には emergeやkompareやmeldやvimdiffも含まれています。有効な<tool>設定のリストについては、 @samp{git difftool --tool-help} を実行してください。

diffツールが指定されていない場合、 @samp{git difftool} は構成変数 @samp{diff.tool} を使用します。 構成変数 @samp{diff.tool} が設定されていない場合、 @samp{git difftool} は適切なデフォルトを選択します。

あなたは構成変数 @samp{difftool.<tool>.path} を設定することにより、ツール(<tool>)へのフルパスを明示的に指定できます。 たとえば、 @samp{difftool.kdiff3.path} を設定することにより、kdiff3への絶対パスを構成できます。 それ以外の場合、 @samp{git difftool} は、ツールがPATH上にあると想定します。

既知のdiffツールの1つを実行する代わりに、構成変数 @samp{difftool.<tool>.cmd} で、呼び出すコマンドラインを指定することにより、 @samp{git difftool} をカスタマイズして代替プログラムを実行できます。

このツールを使用して(@samp{-t} または @samp{--tool} オプションまたは @samp{diff.tool} 構成変数を介して、) @samp{git difftool} を呼び出すと、構成されたコマンドラインが次の変数を使用して呼び出されます。 @samp{$LOCAL} は、diff pre-imageの内容を含む一時ファイルの名前に設定され、 @samp{$REMOTE} は、diff post-imageの内容を含む一時ファイルの名前に設定されます。 @samp{$MERGED} は、比較されるファイルの名前です。 @samp{$BASE} は、カスタムマージツールコマンドとの互換性のために提供されており、 @samp{$MERGED} と同じ値です。

@item  @samp{--tool-help} 
@samp{--tool} で使用できるdiffツールのリストを出力します。

@item  @samp{--[no-]symlinks} 
@samp{git difftool} のデフォルトの動作は、 @samp{--dir-diff} モードで実行したときに、作業ツリーへのシンボリックリンクを作成することです。つまり、比較の右側は、作業ツリーのファイルそのものです。

@samp{--no-symlinks} を指定すると、代わりにコピーを作成するように @samp{git difftool} に指示します。 @samp{--no-symlinks} はWindowsのデフォルトです。

@item  @samp{-x <command>} 
@itemx  @samp{--extcmd=<command>} 
diffを表示するためのカスタムコマンドを指定します。 @samp{git-difftool} は、構成されたデフォルトを無視し、このオプションが指定されている場合は @samp{$command $LOCAL $REMOTE} を実行します。 さらに、`$BASE`が環境に設定されます。

@item  @samp{-g} 
@itemx  @samp{--[no-]gui} 
When @emph{git-difftool} is invoked with the @samp{-g} or @samp{--gui} option the default diff tool will be read from the configured @samp{diff.guitool} variable instead of @samp{diff.tool}. This may be selected automatically using the configuration variable @samp{difftool.guiDefault}. The @samp{--no-gui} option can be used to override these settings. If @samp{diff.guitool} is not set, we will fallback in the order of @samp{merge.guitool}, @samp{diff.tool}, @samp{merge.tool} until a tool is found.

@item  @samp{--[no-]trust-exit-code} 
@samp{git-difftool} は、各ファイルで個別にdiffツールを呼び出します。diff分ツールによって報告されたエラーは、デフォルトでは無視されます。呼び出されたdiffツールがゼロ以外の終了コードを返したときに @samp{--trust-exit-code`を使用して、 `git-difftool} を終了させます。

@samp{git-difftool} は、 @samp{--trust-exit-code} が使用されている場合、呼び出されたツールの終了コードを転送します。
@end table

サポートされているオプションの完全なリストについては、 git-diff(1) を参照してください。

@noindent

@chapheading CONFIGURATION

同等のdifftoolが定義されていない場合、 @samp{git difftool} は @samp{git mergetool} 構成変数にフォールバックします。

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  diff.tool 
git-difftool(1) で使用する diff ツールを制御します。 この変数は、 @samp{merge.tool} で構成された値をオーバーライドします。 以下のリストは、有効な組み込み値を示しています。 その他の値はカスタム diff ツール(tool)として扱われ、対応する difftool.<tool>.cmd 変数を定義する必要があります。

@item  diff.guitool 
@samp{-g}/@samp{--gui} フラグが指定されている場合に、 git-difftool(1) によって使用されるdiffツールを制御します。 この変数は、 @samp{merge.guitool} で構成された値をオーバーライドします。 以下のリストは、有効な組み込み値を示しています。 その他の値はカスタム diff ツール(tool)として扱われ、対応する difftool.<guitool>.cmd 変数を定義する必要があります。

@item  difftool.<tool>.cmd 
指定のdiffツール(<tool>)を呼び出すコマンドを指定します。指定されたコマンドは、次の変数を使用してシェルで評価されます: @samp{LOCAL} は、diff pre-imageの内容を含む一時ファイルの名前に設定され、 @samp{REMOTE} は、diff post-imageの内容を含む一時ファイルの名前に設定されます。

詳細については、 git-difftool(1) の @samp{--tool=<tool>} オプションを参照してください。

@item  difftool.<tool>.path 
指定のツール(<tool>)のパスを上書きします。これは、あなたのツールがPATHにない場合に役立ちます。

@item  difftool.trustExitCode 
呼び出された difftool がゼロ以外の終了ステータス(exit status)を返す場合は、difftool を終了(exit)します。

詳細については、 git-difftool(1) の @samp{--trust-exit-code} オプションを参照してください。

@item  difftool.prompt 
diffツールを呼び出す前にプロンプトを表示します。

@item  difftool.guiDefault 
Set @samp{true} to use the @samp{diff.guitool} by default (equivalent to specifying the @samp{--gui} argument), or @samp{auto} to select @samp{diff.guitool} or @samp{diff.tool} depending on the presence of a @samp{DISPLAY} environment variable value. The default is @samp{false}, where the @samp{--gui} argument must be provided explicitly for the @samp{diff.guitool} to be used.
@end table

@noindent

@chapheading SEE ALSO

@table @asis

@item  git-diff(1) 
コミット、コミット、作業ツリー等の間の変更を表示する

@item  git-mergetool(1) 
マージ競合解決ツールを実行して、マージ競合を解決します

@item  git-config(1) 
リポジトリまたはグローバルオプションの取得と設定
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fast-export,,,Top
@chapheading Name

git-fast-export — Gitデータエクスポーター

@noindent

@chapheading Synopsis

@display
git fast-export [<options>] | git fast-import
@end display


@noindent

@chapheading DESCRIPTION

このプログラムは、指定されたリビジョンを @samp{git fast-import} にパイプするのに適した形式でダンプします。

人間が読める形式のバンドル置換として(linkgit：git-bundle[1] 参照)、または履歴の書き換えを行うために @samp{git fast-import} にフィードする前に編集できる形式として使用できます(@samp{git filter-repo} などのツールの能力に依存します)。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--progress=<n>} 
インポート中に @samp{git fast-import} で表示されるように、<n>オブジェクトごとに @samp{progress} ステートメントを挿入します。

@item  @samp{--signed-tags=(verbatim|warn|warn-strip|strip|abort)} 
署名付きタグの処理方法を指定します。 エクスポート後の変換によってタグ名が変更される可能性があるため(リビジョンを除外する場合にも発生する可能性があります)、署名は一致しません。

@samp{abort} (デフォルト)を要求すると、このプログラムは署名されたタグに遭遇すると停止します。 @samp{strip} を使用すると、タグは黙って署名なしになり、 @samp{warn-strip} を使用すると、タグは署名なしになりますが、警告が表示されます。 @samp{verbatim} を使用すると、タグは黙ってにエクスポートされ、 @samp{warn} を使用すると、 エクスポートされますが、警告が表示されます。

@item  @samp{--tag-of-filtered-object=(abort|drop|rewrite)} 
タグ付けされたオブジェクトが除外される、タグの処理方法を指定します。 エクスポートするリビジョンとファイルはパスによって制限される可能性があるため、タグ付けされたオブジェクトは完全にフィルタリングされる可能性があります。

@samp{abort} (デフォルト)を要求すると、このプログラムはそのようなタグに遭遇すると停止します。 @samp{drop} を使用すると、そのようなタグが出力から省略されます。 @samp{rewrite} を使用すると、タグ付けされたオブジェクトがコミットの場合、タグを書き換えて祖先のコミットにタグを付けます(親の書き換えを介して、 git-rev-list(1) 参照)

@item  @samp{-M} 
@itemx  @samp{-C} 
git-diff(1) のマニュアルページで説明されているように、移動 および/または コピーの検出を実行し、それを使用して、出力ダンプに rename および copy コマンドを生成します。

注意: これらのオプションを指定した場合、このコマンドの以前のバージョンは警告を出さずに誤った結果を生成することに注意してください。

@item  @samp{--export-marks=<file>} 
完了すると、内部マークテーブルを<file>にダンプします。 マークは1行に1つずつ @samp{:markid SHA-1} として書き込まれます。 リビジョンのマークのみがダンプされます。 ブロブのマークは無視されます。 バックエンドはこのファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行(incremental runs)全体でマークテーブルを保存したりできます。 <file>は完了時にのみ開かれ、切り捨てられるため、同じパスを @samp{--import-marks} に安全に指定することもできます。 新しいオブジェクトが マーク/エクスポート されていない場合、ファイルは書き込まれません。

@item  @samp{--import-marks=<file>} 
入力を処理する前に、<file>で指定されたマークをロードします。 入力ファイルは存在し、読み取り可能であり、 @samp{--export-marks} によって生成されたものと同じ形式を使用する必要があります。

@item  @samp{--mark-tags} 
マークIDでブロブとコミットにラベルを付けることに加えて、タグにもラベルを付けます。 これは、 @samp{--export-marks} および @samp{--import-marks} と組み合わせて使用すると便利です。また、ネストされたタグのエクスポートにも役立ちます(そして必要です)。 それは他のケースを損なうことはなく、デフォルトになりえますが、多くのfast-importフロントエンドは、マーク識別子を持つタグを受け入れる準備ができていません。

すでにマークされているコミット(またはタグ)は、再度エクスポートされません。 バックエンドが同様の @samp{--import-marks} ファイルを使用する場合、これにより、複数実行に渡ってマークを同一に保つことにより、リポジトリの増分双方向エクスポートが可能になります。

@item  @samp{--fake-missing-tagger} 
一部の古いリポジトリには、taggerのないタグがあります。 fast-importプロトコルはそれについてかなり厳格であり、それを許可しません。 したがって、出力を高速にインポートできるように、taggerを偽造します。

@item  @samp{--use-done-feature} 
@samp{feature done} 句(stanza)でストリームを開始し、 @samp{done} コマンドで終了します。

@item  @samp{--no-data} 
ブロブオブジェクトの出力をスキップし、代わりに元のSHA-1ハッシュを介してブロブを参照します。 これは、個々のファイルの内容に触れることなく、リポジトリのディレクトリ構造または履歴を書き換える場合に役立ちます。 結果のストリームは、必要なオブジェクトがすでに含まれているリポジトリでのみ使用できることに注意してください。

@item  @samp{--full-tree} 
このオプションにより、fast-exportは、コミットごとに @samp{deleteall} ディレクティブを発行し、その後にコミット内のすべてのファイルの完全なリストを発行します(コミットの最初の親とは異なるファイルをリストするだけではありません)。

@item  @samp{--anonymize} 
履歴と保存されたツリーの形を維持しながら、リポジトリのコンテンツを匿名化(anonymize)します。 以下の「ANONYMIZING」のセクションを参照してください。

@item  @samp{--anonymize-map=<from>[:<to>]} 
匿名化(anonymized)された出力でトークン @samp{<from>} を @samp{<to>} に変換します。 @samp{<to>`を省略した場合は、 `<from>} をそれ自体にマップします(つまり、匿名化しません)。 以下の「ANONYMIZING」セクションを参照してください。

@item  @samp{--reference-excluded-parents} 
デフォルトでは、 @samp{git fast-export master~5..master} などのコマンドを実行すると、コミット master~5 が含まれなくなり、master~4 の親として master~5 がなくなります( ただし、古い master~4 と 新しい master~4 の両方に同じファイルがあります)。 @samp{--reference-excluded-parents} を使用して、代わりに、sha1sum によって除外された履歴範囲内のコミットをストリームに参照させます。 結果のストリームは、必要な親コミットがすでに含まれているリポジトリでのみ使用できることに注意してください。

@item  @samp{--show-original-ids} 
コミットとブロブの出力に追加のディレクティブ @samp{original-oid <SHA1SUM>} を追加します。 このようなディレクティブは git-fast-import などのインポーターによって無視される可能性がありますが、中間フィルター(たとえば、古いコミットを参照するコミットメッセージの書き換え、またはIDによるブロブの削除)に役立つ場合があります。

@item  @samp{--reencode=(yes|no|abort)} 
コミットオブジェクトで @samp{encoding} ヘッダーを処理する方法を指定します。 @samp{abort} (デフォルト)を要求すると、このプログラムはそのようなコミットオブジェクトに遭遇すると停止します。 @samp{yes} を使用すると、コミットメッセージがUTF-8に再エンコードされます。 @samp{no} を使用すると、元のエンコーディングが保持されます。

@item  @samp{--refspec} 
指定されたrefspecをエクスポートされた各refに適用します。複数指定することができます。

@item  [<git-rev-list-args>…] 
エクスポートする特定のオブジェクトと参照を指定する、 @samp{git rev-parse} および @samp{git rev-list} に受け入れられる引数のリスト。 たとえば、 @samp{master~10..master} を使用すると、現在のmaster参照が、10番目の祖先のコミット以降に追加されたすべてのオブジェクト、および (--reference-excluded-parentsオプションが指定されていない場合、) master~9 と master~10 に共通のすべてのファイルとともにエクスポートされます。
@end table

@noindent

@chapheading EXAMPLES

@example
$ git fast-export --all | (cd /empty/repository && git fast-import)
@end example


これにより、リポジトリ全体がエクスポートされ、既存の空のリポジトリにインポートされます。 UTF-8でないコミットの再エンコードを除いて、1対1のミラーになります。

@example
$ git fast-export master~5..master |
        sed "s|refs/heads/master|refs/heads/other|" |
        git fast-import
@end example


これにより、 @samp{master~5..master} から @samp{other} という新しいブランチが作成されます(つまり、 @samp{master} に線形履歴がある場合は、最後の5回のコミットが必要になります)。

注意: これは、そのリビジョン範囲によって参照されるブロブとコミットメッセージのいずれにも文字列 @samp{refs/heads/master} が含まれていないことを前提としていることに注意してください。

@noindent

@chapheading ANONYMIZING(匿名化)

@samp{--anonymize} オプションが指定されている場合、gitは、いくつかのバグを再現するのに十分な元のツリーと履歴パターンを保持しながら、リポジトリからすべての識別情報(identifying information)を削除しようとします。 その目標は、プライベートリポジトリで見つかったgitバグが匿名化されたリポジトリに残り、匿名化されたリポジトリをgit開発者と共有してバグの解決に役立てることです。

このオプションを使用すると、gitは、出力内のすべての refname、パス、ブロブコンテンツ、コミットメッセージ、タグメッセージ、名前、電子メールアドレス を匿名化されたデータに置き換えます。 同じ文字列の2つのインスタンスは同等に置き換えられます(たとえば、同じ作者による2つのコミットは、出力に同じ匿名の作者が含まれますが、元の作者文字列とは類似していません)。 コミット、ブランチ、タグの関係、コミット のタイムスタンプは保持されます(ただし、コミットメッセージとrefnameは元のメッセージとは似ていません)。 ツリーの相対的な構成は保持されますが(たとえば、10個のファイルと3個のツリーを持つルートツリーがある場合、出力も保持されます)、それらの名前とファイルの内容は置き換えられます。

あなたがgitのバグを見つけたと思う場合は、リポジトリ全体の匿名化されたストリームをエクスポートすることから始めることができます:

@example
$ git fast-export --anonymize --all >anon-stream
@end example


次に、そのストリームから作成されたリポジトリでバグが持続することを確認します(多くのバグは、リポジトリの正確な内容に依存しているため、持続しません):

@example
$ git init anon-repo
$ cd anon-repo
$ git fast-import <../anon-stream
$ ... test your bug ...
@end example


匿名化されたリポジトリにバグが表示されている場合は、通常のバグレポートと一緒に @samp{anon-stream} を共有する価値があるかもしれません。 匿名化されたストリームは非常によく圧縮されるため、gzipすることをお勧めします。ストリームを調べてプライベートデータが含まれていないことを確認する場合は、送信する前にストリームを直接確認できます。 また、試してみることもできます:

@example
$ perl -pe 's/\d+/X/g' <anon-stream | sort -u | less
@end example


これは、すべての一意の行を表示します("User 0"、 "User 1" などを "User X" に折りたたむために、数字を "X" に変換します)。 これにより、出力がはるかに小さくなり、通常、ストリームにプライベートデータがないことをすばやく確認するのは簡単です。

一部のバグを再現するには、特定のコミットまたはパスを参照する必要がある場合があります。これは、refnameおよびパスが匿名化された後に困難になります。 特定のトークンをそのままにするか、新しい値にマップするように要求できます。 たとえば、 @samp{git rev-list sensitive -- secret.c} で再現されるバグがある場合は、以下のコマンドを実行できます:

@example
$ git fast-export --anonymize --all \
      --anonymize-map=sensitive:foo \
      --anonymize-map=secret.c:bar.c \
      >stream
@end example


ストリームをインポートした後、匿名化されたリポジトリで @samp{git rev-list foo -- bar.c} を実行できます。

注意: パスとrefnameは、スラッシュ(@samp{/})境界でトークンに分割されることに注意してください。 上記のコマンドは、 @samp{subdir/secret.c} を @samp{path123/bar.c} のようなものとして匿名化します。 次に、あなたは匿名化されたリポジトリで @samp{bar.c} を検索して、最終的なパス名を決定できます。

最終パス名の参照を簡単にするために、各パスコンポーネントをマップできます。 したがって、@samp{subdir} も @samp{publicdir} に匿名化すると、最終的なパス名は @samp{publicdir/bar.c} になります。

@noindent

@chapheading LIMITATIONS

@samp{git fast-import} はツリーにタグを付けることができないため、コミットではなくツリーを参照するタグが含まれている linux.git リポジトリを完全にエクスポートすることはできません。

@noindent

@chapheading SEE ALSO

git-fast-import(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fast-import,,,Top
@chapheading Name

git-fast-import — 高速Gitデータインポーターのバックエンド

@noindent

@chapheading Synopsis

@display
frontend | git fast-import [<options>]
@end display


@noindent

@chapheading DESCRIPTION

このプログラムは通常、エンドユーザーが直接実行したいものではありません。 ほとんどのエンドユーザーは、既存のフロントエンドプログラムの1つを使用したいと考えています。このプログラムは、特定の種類の外部ソースをパースし、そこに保存されているコンテンツを @samp{git fast-import} に送ります。

fast-importは、標準入力から 混合 コマンド/データストリーム を読み取り、1つ以上のパックファイルを現在のリポジトリに直接書き込みます。 EOFが標準入力で受信されると、高速インポートは更新されたブランチとタグの参照を書き出し、新しくインポートされたデータで現在のリポジトリを完全に更新します。

高速インポートバックエンド自体は、空のリポジトリ(@samp{git init} によってすでに初期化されているリポジトリ)にインポートすることも、既存の入力済みリポジトリを増分更新(incrementally update)することもできます。 特定の外部ソースからの増分インポートがサポートされているかどうかは、使用しているフロントエンドプログラムによって異なります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--force} 
コミットが失われる場合でも(新しいコミットには古いコミットが含まれていないため)、変更された既存のブランチを強制的に更新します。

@item  @samp{--quiet} 
@samp{--stats} で示される出力を無効にし、正常に実行されると、通常、fast-importをサイレントにします。 ただし、インポートストリームに、ユーザー出力を表示することを目的としたディレクティブ(`progress`ディレクティブなど)がある場合も対応するメッセージが表示されます。

@item  @samp{--stats} 
fast-importが作成したオブジェクト、それらが保存されたパックファイル、およびこの実行中にfast-importによって使用されたメモリに関するいくつかの基本的な統計を表示します。 この出力の表示は現在デフォルトですが、 @samp{--quiet} を使用して無効にすることができます。

@item  @samp{--allow-unsafe-features} 
@samp{feature} または @samp{option} コマンドを使用して、高速インポートストリーム自体の一部として多くのコマンドラインオプションを提供できます。 ただし、これらのオプションの一部は安全ではありません(たとえば、高速インポートでリポジトリの外部のファイルシステムにアクセスできるようにするなど)。 これらのオプションはデフォルトで無効になっていますが、コマンドラインでこのオプションを指定することで許可できます。 これは現在、 @samp{export-marks} と @samp{import-marks} と @samp{import-marks-if-exists} 機能コマンドにのみ影響します。

@example
高速インポートストリームを生成するプログラムを信頼する場合にのみ、このオプションを有効にしてください。 このオプションは、独自のコードを実行することがすでに信頼されているため、 `import` 機能を使用するリモートヘルパーに対して自動的に有効になります。
@end example
@end table

@noindent

@heading Options for Frontends

@table @asis

@item  @samp{--cat-blob-fd=<fd>} 
@samp{get-mark} と @samp{cat-blob} と @samp{ls} クエリへの応答を、 @samp{stdout} ではなくファイルデスクリプタ<fd>に書き込みます。 エンドユーザー向けの @samp{progress} 出力を他の出力から分離できるようにします。

@item  @samp{--date-format=<fmt>} 
フロントエンドが高速インポートに提供する日付のタイプを、 @samp{author} と @samp{committer} と`tagger` コマンド内で指定します。 サポートされているフォーマットとその構文の詳細については、以下の「Date Formats」を参照してください。

@item  @samp{--done} 
ストリームの最後に @samp{done} コマンドがない場合は、エラーで終了(terminate)します。 このオプションは、フロントエンドがストリームの書き込みを開始する前に終了する原因となるエラーを検出するのに役立つ場合があります。
@end table

@noindent

@heading Locations of Marks Files

@table @asis

@item  @samp{--export-marks=<file>} 
完了すると、内部マークテーブルを<file>にダンプします。 マークは1行に1つずつ @samp{:markid SHA-1} として書き込まれます。 フロントエンドは、このファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行(incremental runs)全体でマークテーブルを保存したりできます。 <file>はチェックポイント(または完了)でのみ開かれ(open)、切り捨て(truncate)られるため、同じパスを @samp{--import-marks} に安全に指定することもできます。

@item  @samp{--import-marks=<file>} 
入力を処理する前に、<file>で指定されたマークをロードします。 入力ファイルは存在し、読み取り可能であり、 @samp{--export-marks} によって生成されたものと同じ形式を使用する必要があります。 複数のマークのセットをインポートするために、オプションを複数回指定できます。 マークが異なる値に定義されている場合、最後のファイルが優先されます。

@item  @samp{--import-marks-if-exists=<file>} 
@samp{--import-marks} と同様ですが、エラーが発生する代わりに、ファイルが存在しない場合は黙ってスキップします。

@item  @samp{--[no-]relative-marks} 
@samp{--relative-marks} を指定した後、 @samp{--import-marks=} と @samp{--export-marks=} で指定されたパスは、現在のリポジトリの内部ディレクトリからの相対パスになります。 git-fast-importでは、これはパスが @samp{.git/info/fast-import} ディレクトリから相対的であることを意味します。 ただし、他のインポーターは別の場所を使用する場合があります。

@samp{--(no-)-relative-marks} を @samp{--(import|export)-marks=} と織り交ぜることで、相対マークと非相対マークを組み合わせることができます。
@end table

@noindent

@heading Submodule Rewriting

@table @asis

@item  @samp{--rewrite-submodules-from=<name>:<file>} 
@itemx  @samp{--rewrite-submodules-to=<name>:<file>} 
Rewrite the object IDs for the submodule specified by <name> from the values used in the from <file> to those used in the to <file>. The from marks should have been created by @samp{git fast-export}, and the to marks should have been created by @samp{git fast-import} when importing that same submodule.

<name>は、コロン文字を含まない任意の文字列にすることができますが、対応するマークを指定するときは、両方のオプションで同じ値を使用する必要があります。 <name>の値が異なる複数のサブモジュールを指定できます。 対応するペアでこれらのオプションを使用しないのはエラーです。

これらのオプションは、リポジトリをあるハッシュアルゴリズムから別のハッシュアルゴリズムに変換するときに主に役立ちます。 それらがないと、オブジェクトIDを新しいハッシュアルゴリズムに書き込む方法がないため、サブモジュールが検出された場合、fast-importは失敗します。
@end table

@noindent

@heading Performance and Compression Tuning

@table @asis

@item  @samp{--active-branches=<n>} 
一度にアクティブを維持するブランチの最大数。 詳細については、下記「Memory Utilization」(メモリ使用率)を参照してください。 デフォルトは5です。

@item  @samp{--big-file-threshold=<n>} 
fast-importがデルタを作成しようとするブロブの最大サイズ(バイト単位)。 デフォルトは512m(512 MiB)です。 一部のインポーターは、メモリが制限されているシステムでこの値を下げることを希望する事があります。

@item  @samp{--depth=<n>} 
ブロブとツリーの差分化(deltification)の最大デルタ深度。 デフォルトは50です。

@item  @samp{--export-pack-edges=<file>} 
パックファイルを作成した後、データの行を<file>に出力して、パックファイルのファイル名と、そのパックファイルに書き込まれた各ブランチの最後のコミットをリストします。 この情報は、オブジェクトセットの合計が4 GiBパックファイルの制限を超えるプロジェクトをインポートした後に役立つ場合があります。 これらのコミットは、 @samp{git pack-objects} の呼び出し中にエッジポイントとして使用できるためです。

@item  @samp{--max-pack-size=<n>} 
各出力パックファイルの最大サイズ。 デフォルトは無制限です。

@item  fastimport.unpackLimit 
git-config(1) 参照
@end table

@noindent

@chapheading PERFORMANCE

高速インポートの設計により、最小限のメモリ使用量と処理時間で大規模なプロジェクトをインポートできます。 フロントエンドが高速インポートに対応し、一定のデータストリームをフィードできると仮定すると、10年以上の履歴を保持し、100,000以上の個別のコミットを含むプロジェクトのインポート時間は、通常、非常に控えめな(〜$2,000 USD)ハードウェアで、わずか1〜2時間で完了します。

ほとんどのボトルネックは、外部ソースデータアクセス(ソースがリビジョンを十分に速く抽出できない)、またはディスクI/O(ディスクがデータを取得するのと同じ速さで高速インポート書き込み)にあるように見えます。 ソースデータが宛先Gitリポジトリとは異なるドライブに保存されている場合、(I/Oの競合が少ないため)、インポートはより高速に実行されます。

@noindent

@chapheading DEVELOPMENT COST

fast-importの一般的なフロントエンドは、200行程度の Perl/Python/Ruby コードを使用する傾向があります。 ほとんどの開発者は、fast-import、場合によってはGitに初めて触れたとしても、わずか数時間で実用的なインポーターを作成することができました。 ほとんどの変換ツールが使い捨て(一度使用すると、決して振り返ることがない)であることを考えると、これは理想的な状況です。

@noindent

@chapheading PARALLEL OPERATION

@samp{git push} や @samp{git fetch} と同様に、fast-importによって処理されるインポートは、並列の @samp{git repack -a -d} や @samp{git gc} の呼び出し、またはその他のGit操作(@samp{git prune} を含む、そしてfast-importでは緩いオブジェクト(loose objects)は使用されないため。)と一緒に実行しても安全です。

fast-importは、アクティブにインポートしているブランチまたはタグ参照をロックしません。 インポート後、refの更新フェーズで、fast-importは、既存の各ブランチrefをテストして、更新が早送り更新(fast-forward update)になることを確認(verifty)します(refに格納されているコミットは、書き込まれるコミットの新しい履歴に含まれます)。 更新が早送り更新でない場合、fast-importはその参照の更新をスキップし、代わりに警告メッセージを出力します。 fast-importは常にすべてのブランチ参照を更新しようとし、最初の失敗で停止(stop)しません。

ブランチの更新は @samp{--force} を使用して強制できますが、それ以外の場合は静かなリポジトリ(quiet repository)でのみ使用することをお勧めします。 空のリポジトリへの最初のインポートには、 @samp{--force} を使用する必要はありません。

@noindent

@chapheading TECHNICAL DISCUSSION

fast-importは、メモリ内の一連のブランチを追跡します。 入力ストリームで @samp{commit} コマンドを送信することにより、インポートプロセス中の任意の時点で任意のブランチを作成または変更できます。 この設計により、フロントエンドプログラムは無制限の数のブランチを同時に処理し、ソースデータから利用可能な順序でコミットを生成できます。 また、フロントエンドプログラムを大幅に簡素化します。

fast-importは、現在の作業ディレクトリまたはその中のファイルを使用または変更しません。 (ただし、 @samp{GIT_DIR} で参照されるように、現在のGitリポジトリを更新します。) したがって、インポートフロントエンドは、外部ソースからファイルリビジョンを抽出するなど、独自の目的で作業ディレクトリを使用する場合があります。 この、作業ディレクトリの無感知により、ブランチを切り替えるときにコストのかかるファイル更新操作を実行する必要がないため、fast-importを非常に迅速に実行することもできます。

@noindent

@chapheading INPUT FORMAT

(Gitが解釈しない)生のファイルデータを除いて、fast-import入力形式はテキスト(ASCII)ベースです。 このテキストベースの形式は、特にPerl、Python、Rubyなどの高級言語が使用されている場合に、フロントエンドプログラムの開発とデバッグを簡素化します。

fast-importは、入力に関して非常に厳密です。 以下でSPと言う場合、「正確に」1つのスペースを意味します。 同様に、LFは1つ(そして1つだけ)の改行を意味し、HTは1つ(そして1つだけ)の水平タブを意味します。追加の空白文字を指定すると、名前の先頭または末尾にスペースが含まれるブランチ名やファイル名などの予期しない結果が発生したり、予期しない入力が発生した場合に高速インポートが早期に終了したりします。

@noindent

@heading Stream Comments

フロントエンドのデバッグを支援するために、fast-importは、 @samp{#} (ASCII シャープ/ハッシュ) で始まり、@samp{LF} で終わる行を無視します。 コメント行には、LFを含まないバイトのシーケンスを含めることができるため、フロントエンドに固有でfast-importのデータストリームを検査するときに役立つ詳細なデバッグ情報を含めるために使用できます。

@noindent

@heading Date Formats

以下の日付形式がサポートされています。 フロントエンドは、@samp{--date-format=<fmt>} コマンドラインオプションで形式名を渡すことにより、このインポートに使用する形式を選択する必要があります。

@table @asis

@item  @samp{raw} 
これはGitのネイティブ形式であり、 @samp{<time>SP<offutc>} です。 @samp{--date-format} が指定されていない場合は、fast-importのデフォルト形式でもあります。

イベントの時刻は、UNIXエポック(1970年1月1日午前0時、UTC)からの秒数として @samp{<time>} で指定され、ASCIIの10進整数として書き込まれます。

ローカルオフセットは、UTCからの正または負のオフセットとして @samp{<offutc>} によって指定されます。 たとえば、EST(UTCから5時間遅れている)は、UTCが「+0000」であるのに対し、「<tz>」は「-0500」で表されます。 ローカルオフセットは @samp{<time>} には影響しません。 これは、フォーマットルーチンがタイムスタンプを表示するのに役立つアドバイスとしてのみ使用されます。

ローカルオフセットがソース素材で使用できない場合は、「+0000」、または最も一般的なローカルオフセットを使用します。 たとえば、多くの組織には、同じ場所とタイムゾーンにいるユーザーだけがアクセスしたことのあるCVSリポジトリがあります。 この場合、UTCからの妥当なオフセットを想定できます。

@samp{rfc2822} 形式とは異なり、この形式は非常に厳密です。 フォーマッティングに変化があると、fast-importが値を拒否し、数値の健全性チェックも実行される場合があります。

@item  @samp{raw-permissive} 
これは、数値エポックとローカルオフセットの健全性チェックが実行されないことを除いて、@samp{raw} と同じです。 これは、例えば、偽のタイムゾーン値を使用して既存の履歴をフィルタリングまたはインポートしようとする場合に役立ちます。

@item  @samp{rfc2822} 
これは、RFC2822で説明されている標準の電子メール形式です。

この値は例えば @samp{Tue Feb 6 11:22:18 2007 -0500} です。 Gitパーサーは正確ですが、ちょっぴり寛大です。 これは、電子メールから受信したパッチを適用するときに @samp{git am} によって使用されるのと同じパーサーです。

一部の不正な形式の文字列が、有効な日付として受け入れられる場合があります。 これらの場合のいくつかでは、Gitは不正な形式の文字列から正しい日付を取得できます。 また、Gitが誤ってパースし、それでも有効と見なす不正な形式の文字列の種類もあります。 ひどくおかしい文字列は拒否されます。

上記の`raw`形式とは異なり、RFC2822日付文字列に含まれる タイムゾーン/UTC オフセット情報は、保存前に日付値をUTCに調整するために使用されます。 したがって、この情報が可能な限り正確であることが重要です。

もしソース素材がRFC2822スタイルの日付を使っているなら、フロントエンドは(自分でやろうとするよりも、)fast-importにパースと変換を任せるべきです。なぜなら、Gitパーサーは実際によくテストされているからです。

フロントエンドは、ソース素材がすでに UNIX-epoch フォーマットを使っていて、そのフォーマットで日付を与えるように言いくるめられる場合、あるいはパースに曖昧さがないため、そのフォーマットが簡単に @samp{raw} フォーマットに変換できる場合は、 @samp{raw} フォーマットを優先するべきです。

@item  @samp{now} 
常に現在の時間とタイムゾーンを使用します。 @samp{<when>} には常に @samp{now} というリテラルを指定しなければなりません。

これはおもちゃのフォーマット(toy format)です。 このシステムの現在の時刻とタイムゾーンは、fast-importによって作成されるときに常にID文字列にコピーされます。 別の時間またはタイムゾーンを指定する方法はありません。

この特定の形式は、実装が簡単なために提供されており、作業ディレクトリや @samp{git update-index} を使用せずに、今すぐ新しいコミットを作成したいプロセスに役立つ場合があります。

@samp{commit} で別々の @samp{author} コマンドと @samp{committer} コマンドが使用されている場合、システムクロックが2回(コマンドごとに1回)ポーリングされるため、タイムスタンプが一致しない可能性があります。 作者とコミッターの両方のID情報のタイムスタンプが同じであることを確認する唯一の方法は、 @samp{author} を省略するか(したがって @samp{committer} からコピーする)、または @samp{now} 以外の日付形式を使用することです。
@end table

@noindent

@heading Commands

fast-importは、現在のリポジトリを更新し、現在のインポートプロセスを制御するためのいくつかのコマンドを受け入れます。 各コマンドの詳細(例を含む)については後述します。

@table @asis

@item  @samp{commit} 
新しいコミットを作成し、新しく作成されたコミットを指すようにブランチを更新することにより、新しいブランチを作成するか、既存のブランチを更新します。

@item  @samp{tag} 
既存のコミットまたはブランチから注釈付きタグオブジェクト(annotated tag object)を作成します。 軽量タグ(Lightweight tags)は、意味のある時点を記録するためには推奨されていないため、このコマンドではサポートされていません。

@item  @samp{reset} 
既存のブランチ(または新しいブランチ)を特定のリビジョンにリセットします。 このコマンドは、ブランチをコミットせずに特定のリビジョンに変更する目的で使用する必要があります。

@item  @samp{blob} 
将来 @samp{commit} コマンドで使用するために、生のファイルデータをブロブに変換します。 このコマンドはオプションであり、インポートを実行するために必要ではありません。

@item  @samp{alias} 
最初に新しいオブジェクトを作成せずに、マークが特定のオブジェクトを参照していることを記録します。 @samp{--import-marks} を使用し、欠落しているマークを参照すると fast-import が失敗するため、エイリアスは、刈り込まれたコミットを有効な値(刈り込まれていない最も近い祖先など)に設定する方法を提供できます。

@item  @samp{checkpoint} 
fast-importを強制して、現在のパックファイルを閉じ、一意のSHA-1チェックサムとインデックスを生成して、新しいパックファイルを開始します。 このコマンドはオプションであり、インポートを実行するために必須ではありません。

@item  @samp{progress} 
fast-importにより、行全体が自身の標準出力にエコーされます。このコマンドはオプションであり、インポートを実行するために必要ではありません。

@item  @samp{done} 
ストリームの終わりを示します。 @samp{--done} コマンドラインオプションまたは @samp{feature done} コマンドを使用して @samp{done} 機能が要求された場合を除き、このコマンドはオプションです。

@item  @samp{get-mark} 
fast-import により、マークに対応するSHA-1が、 @samp{--cat-blob-fd} にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。

@item  @samp{cat-blob} 
fast-importにより、 @samp{cat-file --batch} 形式のブロブが、 @samp{--cat-blob-fd} にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。

@item  @samp{ls} 
fast-importにより、ディレクトリエントリを @samp{ls-tree} 形式で記述した行が、 @samp{--cat-blob-fd} にて設定されたファイルデスクリプタへ出力されるか、または、指定されていない場合は stdout のファイルデスクリプタへ出力されます。

@item  @samp{feature} 
指定された機能を有効にします。 これには、fast-importが指定された機能をサポートしている必要があり、サポートしていない場合は中止(abort)されます。

@item  @samp{option} 
フロントエンドのニーズに合わせてストリームセマンティックを変更しないオプションの下にリストされているオプションのいずれかを指定します。 このコマンドはオプションであり、インポートを実行するために必須ではありません。
@end table

@noindent

@heading commit

新しいコミットでブランチを作成または更新し、プロジェクトへの1つの論理的な変更を記録します。

@example
        'commit' SP <ref> LF
        mark?
        original-oid?
        ('author' (SP <name>)? SP LT <email> GT SP <when> LF)?
        'committer' (SP <name>)? SP LT <email> GT SP <when> LF
        ('encoding' SP <encoding>)?
        data
        ('from' SP <commit-ish> LF)?
        ('merge' SP <commit-ish> LF)*
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
        LF?
@end example

ここで、 @samp{<ref>} はコミットを行うブランチの名前です。 通常、Gitではブランチ名の前に @samp{refs/heads/} が付いているため、CVSブランチシンボル @samp{RELENG-1_0} をインポートすると、 @samp{<ref>} の値に @samp{refs/heads/RELENG-1_0} が使用されます。 @samp{<ref>} の値は、Gitで有効なrefnameである必要があります。 @samp{LF} はGit refnameでは無効であるため、ここではクォートやエスケープ構文はサポートされていません。

@samp{mark} コマンドがオプションで表示され、フロントエンドで将来使用するために新しく作成されたコミットへの参照を保存するようにfast-importを要求する場合があります(形式については以下を参照)。 フロントエンドが作成するすべてのコミットにマークを付けることは非常に一般的であり、これにより、インポートされたコミットから将来のブランチを作成できます。

@samp{committer} に続く @samp{data} コマンドは、コミットメッセージを提供する必要があります(@samp{data} コマンドの構文については以下を参照してください)。 空のコミットメッセージをインポートするには、長さ0のデータを使用します。 コミットメッセージは自由形式であり、Gitによって解釈されません。 fast-importでは他のエンコードを指定できないため、現在はUTF-8でエンコードする必要があります。

コミットを作成する前にブランチの内容を更新するために、0個以上の @samp{filemodify} 、 @samp{filedelete} 、 @samp{filecopy} 、 @samp{filerename} 、 @samp{filedeleteall} 、 @samp{notemodify} コマンドを含めることができます。 これらのコマンドは、任意の順序で指定できます。 ただし、 @samp{filedeleteall} はブランチをクリーンにワイプするため、 @samp{filedeleteall} コマンドを同じコミット内のすべての @samp{filemodify} 、 @samp{filecopy} 、 @samp{filerename} 、 ` notemodify` コマンドの前に置くことをお勧めします(下記参照)。

コマンドの後の @samp{LF} はオプションです(以前は必須でした)。 下位互換性の理由から、コミットが @samp{data} コマンドで終了する場合(つまり、 @samp{from} 、 @samp{merge} 、 @samp{filemodify} 、 @samp{filedelete} 、 @samp{filecopy} 、 @samp{filerename} 、 @samp{filedeleteall} 、 @samp{notemodify} コマンドがないことに注意してください)の場合、コマンドの最後に1つではなく2つの @samp{LF} コマンドが表示される場合があります。

@noindent

@subheading author

作者情報がコミッター情報と異なる場合は、オプションで @samp{author} コマンドが表示されることがあります。 @samp{author} を省略すると、fast-importはコミットの作者部分にコミッターの情報を自動的に使用します。 @samp{author} のフィールドの説明については、 @samp{committer} と同じであるため、以下を参照してください。

@noindent

@subheading committer

@samp{committer} コマンドは、誰がこのコミットを行ったのか、いつ行ったのかを示します。

ここで、 @samp{<name>} は個人の表示名(たとえば、 "Com M Itter")であり、 @samp{<email>} は個人の電子メールアドレス("cm@@example.com")です。 @samp{LT} と @samp{GT} は、文字通りの小なり記号(\x3c)と大なり記号(\x3e)です。 これらは、行の他のフィールドから電子メールアドレスを区切るために必要です。 @samp{<name>} と @samp{<email>} は自由形式であり、 @samp{LT} 、@samp{GT} 、 @samp{LF} を除く任意のバイトシーケンスを含むことができることに注意してください。 @samp{<name>} は通常UTF-8でエンコードされています。

変更時刻は、 @samp{--date-format=<fmt>} コマンドラインオプションで選択された日付形式を使用して @samp{<when>} で指定されます。サポートされている形式のセットとその構文については、上記「Date Formats」を参照してください。

@noindent

@subheading encoding

オプションの @samp{encoding} コマンドは、コミットメッセージのエンコーディングを示します。 ほとんどのコミットはUTF-8であり、エンコードは省略されていますが、これにより、最初に再エンコードせずにコミットメッセージをgitにインポートできます。

@noindent

@subheading from

@samp{from} コマンドは、このブランチを初期化するコミットを指定するために使用されます。 このリビジョンは、新しいコミットの最初の祖先になります。 このコミットで構築されたツリーの状態は、 @samp{from} コミットでの状態で始まり、このコミットでのコンテンツの変更によって交換(alter)されます。

新しいブランチの最初のコミットで @samp{from} コマンドを省略すると、fast-importが祖先なしでそのコミットを作成します。 これは、プロジェクトの最初のコミットでのみ必要になる傾向があります。 新しいブランチを作成するときにフロントエンドがすべてのファイルを最初から作成する場合は、 @samp{from} の代わりに @samp{merge} コマンドを使用して、空のツリーでコミットを開始できます。 そのブランチの現在のコミットは自動的に新しいコミットの最初の祖先であると見なされるため、既存のブランチでは通常は @samp{from} コマンドを省略することが望まれます。

@samp{LF} は Git refname または SHA-1式では無効であるため、@samp{<commit-ish>} 内でのクォートまたはエスケープ構文はサポートされていません。

ここで、@samp{<commit-ish>} は以下のいずれかです:

@itemize 

@item
fast-importの内部ブランチテーブルにすでに存在する既存のブランチの名前。 fast-importが名前を知らない場合は、SHA-1式として扱われます。

@item
マーク参照: <idnum> 。ここで、 @samp{<idnum>} はマーク番号です。

fast-importがマーク参照を示すために @samp{:} を使用する理由は、この文字がGitブランチ名では無効であるためです。 先頭 @samp{:} を使用すると、マーク42(@samp{:42})とブランチ42(@samp{42} または @samp{refs/heads/42})、または、たまたま10進数で構成されていた省略形のSHA-1を、簡単に区別できます。

マークは、使用する前に( @samp{mark} を介して)宣言する必要があります。

@item
完全な40バイトまたは省略された16進数のコミットSHA-1。

@item
コミットに解決される有効な Git SHA-1式。 詳細については、 gitrevisions(7) の「SPECIFYING REVISIONS」を参照してください。

@item
特別な null SHA-1(40個のゼロ)は、ブランチが削除されることを指定します。
@end itemize

現在のブランチ値から増分インポート(incremental import)を再スタートする特殊なケースは、以下のように記述する必要があります:

@example
        from refs/heads/branch^0
@end example


fast-importはブランチをそれ自体から開始することを許可しないため、 @samp{^0} サフィックスが必要です。ブランチは、 @samp{from} コマンドが入力から読み取られる前にメモリに作成されます。 @samp{^0} を追加すると、fast-importは、内部ブランチテーブルではなく、Gitのリビジョンパースライブラリを介してコミットを解決し、ブランチの既存の値をロードします。

@noindent

@subheading merge

1つの追加の祖先コミットが含まれます。 追加の祖先リンクは、このコミットでツリー状態が構築される方法を変更しません。 新しいブランチを作成するときに @samp{from} コマンドを省略すると、最初の @samp{merge} コミットが現在のコミットの最初の祖先になり、ブランチはファイルなしで開始されます。 fast-importでは、コミットごとに無制限の数の @samp{merge} コマンドが許可されるため、n方向(n-way)マージが確立されます。

ここで、 @samp{<commit-ish>} は、 @samp{from} でも受け入れられるコミット仕様式のいずれかです(上記参照)。

@noindent

@subheading filemodify

新しいファイルを追加したり、既存のファイルの内容を変更したりするために @samp{commit} コマンドに含まれています。 このコマンドには、ファイルの内容を指定する2つの異なる方法があります。

@table @asis

@item  External data format 
ファイルのデータコンテンツは、以前の @samp{blob} コマンドによってすでに提供されています。フロントエンドはそれに接続する必要があります。

@example
        'M' SP <mode> SP <dataref> SP <path> LF
@end example

ここで通常、 @samp{<dataref>} は、前の @samp{blob} コマンドによって設定されたマーク参照(@samp{:<idnum>})か、既存のGitブロブオブジェクトの完全な40バイトのSHA-1である必要があります。 @samp{<mode>} が @samp{040000} の場合、 @samp{<dataref>} は既存のGitツリーオブジェクトの完全な40バイトのSHA-1または @samp{--import-marks} で設定されたマーク参照である必要があります。

@item  Inline data format 
ファイルのデータコンテンツはまだ提供されていません。 フロントエンドは、この変更コマンドの一部としてそれを提供したいと考えています。

@example
        'M' SP <mode> SP 'inline' SP <path> LF
        data
@end example

@samp{data} コマンドの詳細については下記参照。
@end table

どちらの形式でも、 @samp{<mode>} はファイルエントリのタイプであり、8進数で指定されます。 Gitは以下のモードのみをサポートします:

@itemize 

@item
@samp{100644} または @samp{644} : 通常の(実行可能でない)ファイル。 ほとんどのプロジェクトのファイルの大部分はこのモードを使用しています。迷ったらコレ。

@item
@samp{100755} または @samp{755} : 通常の、しかし実行可能なファイル。

@item
@samp{120000}: シンボリックリンク。ファイルの内容がリンクターゲットになります。

@item
@samp{160000} : gitlink、オブジェクトのSHA-1は、他のリポジトリのコミットを参照しています。 Gitリンクは、SHAまたはコミットマークを介してのみ指定できます。 これらは、サブモジュールを実装するために使用されます。

@item
@samp{040000}: サブディレクトリ。 サブディレクトリは、SHAによって、または @samp{--import-marks} で設定されたツリーマークを介してのみ指定できます。
@end itemize

どちらの形式でも、 @samp{<path>} は、追加(まだ存在しない場合)または変更(すでに存在する場合)するファイルの完全なパスです。

@samp{<path>} 文字列はUNIXスタイルのディレクトリ区切り文字(スラッシュ @samp{/})を使用する必要があり、 @samp{LF} 以外のバイトを含めることができ、二重引用符(@samp{"})で始めることはできません。

パスはC言語スタイルの文字列クォートを使用できます。 これはすべての場合に受け入れられ、ファイル名が二重引用符で始まるか、@samp{LF} を含む場合は必須です。 C言語スタイルのクォートでは、完全な名前を二重引用符で囲み、 @samp{LF}、 バックスラッシュ(@samp{\})、または二重引用符の文字の前に円記号を付けてエスケープする必要があります(例: @samp{"path/with\n, \\ and \" in it"} )。

@samp{<path>} の値は標準形(canonical form)でなければなりません。以下は禁止です:

@itemize 

@item
空のディレクトリコンポーネントが含まれている(例: @samp{foo//bar} は無効)、

@item
ディレクトリ区切り文字で終了する(例: @samp{foo/} は無効)、

@item
ディレクトリ区切り文字で始まる(例: @samp{/foo} は無効)、

@item
特別なコンポーネント @samp{.} または @samp{..} を含む(例: @samp{foo/./bar} や @samp{foo/../bar} は無効)。
@end itemize

ツリーのルートは、 @samp{<path>} に空の文字列を指定します。

@samp{<path>} は常にUTF-8を使用してエンコードすることをお勧めします。

@noindent

@subheading filedelete

ファイルを削除したり、ブランチからディレクトリ全体を再帰的に削除したりするために @samp{commit} コマンドに含まれています。 ファイルまたはディレクトリを削除して、その親ディレクトリが空になると、親ディレクトリも自動的に削除されます。 これは、最初の空でないディレクトリまたはルートに到達するまで、ツリーを上流へ連鎖的にたどります(cascade up)。

@example
        'D' SP <path> LF
@end example

ここで、 @samp{<path>} は、ブランチから削除されるファイルまたはサブディレクトリの完全なパスです。 @samp{<path>} の詳細な説明については、上記の @samp{filemodify} を参照してください。

@noindent

@subheading filecopy

既存のファイルまたはサブディレクトリをブランチ内の別の場所に再帰的にコピーします。 既存のファイルまたはディレクトリが存在する必要があります。 宛先が存在する場合は、ソースからコピーされたコンテンツに完全に置き換えられます。

@example
        'C' SP <path> SP <path> LF
@end example

ここで、最初の @samp{<path>} はソースの場所であり、2番目の @samp{<path>} は宛先です。 @samp{<path>} がどのように見えるかの詳細な説明については、上記の @samp{filemodify} を参照してください。 SPを含むソースパスを使用するには、パスを引用符で囲む必要があります。

@samp{filecopy} コマンドの効果は即時です。ソースの場所が宛先にコピーされると、ソースの場所に適用される以降のコマンドは、コピーの宛先に影響を与えません。

@noindent

@subheading filerename

既存のファイルまたはサブディレクトリの名前をブランチ内の別の場所に変更します。 既存のファイルまたはディレクトリが存在する必要があります。 宛先が存在する場合は、ソースディレクトリに置き換えられます。

@example
        'R' SP <path> SP <path> LF
@end example

ここで、最初の @samp{<path>} はソースの場所であり、2番目の @samp{<path>} は宛先です。 @samp{<path>} がどのように見えるかの詳細な説明については、上記の @samp{filemodify} を参照してください。 SPを含むソースパスを使用するには、パスを引用符で囲む必要があります。

@samp{filerename} コマンドの効果は即時です。 ソースの場所の名前が宛先に変更されると、ソースの場所に適用される将来のコマンドは、そこに新しいファイルを作成し、名前変更の宛先に影響を与えません。

注意: @samp{filerename} は、 @samp{filecopy} の後にソースの場所の @samp{filedelete} が続くのと同じであることに注意してください。 @samp{filerename} を使用することにはわずかなパフォーマンス上の利点がありますが、その利点は非常に小さいため、ソース素材の 削除/追加ペア を高速インポート用の名前変更に変換する価値はありません。 この @samp{filerename} コマンドは、名前変更情報がすでにあるフロントエンドを単純化するために提供されており、それを @samp{filecopy} とそれに続く @samp{filedelete} に分解する必要はありません。

@noindent

@subheading filedeleteall

ブランチからすべてのファイル(およびすべてのディレクトリ)を削除するために @samp{commit} コマンドに含まれています。 このコマンドは、内部ブランチ構造をリセットしてファイルを含まないようにし、フロントエンドの関心あるすべてのファイルを最初から追加できるようにします。

@example
        'deleteall' LF
@end example

このコマンドは、フロントエンドが現在ブランチ上にあるファイルを知らない(あるいは知ろうとしない)ため、コンテンツを更新するための適切な @samp{filedelete} コマンドを生成できない場合に非常に役立ちます。

正しいコンテンツを設定するために @samp{filedeleteall} の後に必要な @samp{filemodify} コマンドを発行すると、必要な @samp{filemodify} および @samp{filedelete} コマンドのみを送信するのと同じ結果が得られます。 しかし、@samp{filedeleteall} のアプローチでは、fast-import がアクティブブランチごとに若干多くのメモリの使用を必要する場合があります(ほとんどの大規模プロジェクトでも1 MiB未満ではありますが)。 したがって、コミットの影響を受けるパスのみを簡単に取得できるフロントエンドは、コミットの影響を受けるパスのみを取得することをお勧めします。

@noindent

@subheading notemodify

@samp{<commit-ish>} に注釈する新しいノートを追加したり、この注釈の内容を変更したりするために @samp{commit} @samp{<notes_ref>} コマンドに含まれています。 内部的には、 @samp{<commit-ish>} パスの @samp{filemodify 100644} に似ています(サブディレクトリに分割されている可能性があります)。 @samp{filedeleteall} 以外のコマンドを使用して @samp{<notes_ref>} ツリーに書き込み、このツリー内の既存のノートをすべて削除することはお勧めしません。 このコマンドには、ノートの内容を指定する2つの異なる方法があります。

@table @asis

@item  External data format 
ノートのデータコンテンツは、以前の @samp{blob} コマンドによってすでに提供されています。 フロントエンドは、注釈を付けるコミットに接続する必要があります。

@example
        'N' SP <dataref> SP <commit-ish> LF
@end example

ここで、 @samp{<dataref>} は、前の @samp{blob} コマンドによって設定されたマーク参照(@samp{:<idnum>})、または既存のGitブロブオブジェクトの完全な40バイトのSHA-1のいずれかです。

@item  Inline data format 
ノートのデータ内容はまだ提供されていません。 フロントエンドは、この変更コマンドの一部としてそれを提供したいと考えています。

@example
        'N' SP 'inline' SP <commit-ish> LF
        data
@end example

@samp{data} コマンドの詳細については下記参照。
@end table

どちらの形式でも、 @samp{<commit-ish>} は、 @samp{from} でも受け入れられるコミット仕様式のいずれかです(上記参照)。

@noindent

@heading mark

fast-import を手配して現在のオブジェクトへの参照を保存し、フロントエンドがSHA-1を知らなくても、将来の時点でこのオブジェクトを呼び出すことができるようにします。 ここで、現在のオブジェクトは、 @samp{mark} コマンドが含まれるオブジェクト作成コマンドです。 これは @samp{commit} や @samp{tag} や @samp{blob} にすることができますが、 @samp{commit} が最も一般的な使用法です。

@example
        'mark' SP ':' <idnum> LF
@end example

ここで、 @samp{<idnum>} は、フロントエンドによってこのマークに割り当てられた番号です。 @samp{<idnum>} の値は、ASCIIの10進整数として表されます。 値0は予約されており、マークとして使用することはできません。 1以上の値のみをマークとして使用できます。

新しいマークは自動的に作成されます。 同じ @samp{<idnum>} を別の @samp{mark} コマンドで再利用するだけで、既存のマークを別のオブジェクトに移動できます。

@noindent

@heading original-oid

元のソース管理システムのオブジェクトの名前を提供します。 fast-import はこのディレクティブを単に無視しますが、fast-importにフィードする前にストリームを操作および変更するフィルタープロセスは、この情報を使用する場合があります。

@example
        'original-oid' SP <object-identifier> LF
@end example

ここで、 @samp{<object-identifier>} は LF を含まない任意の文字列です。

@noindent

@heading tag

特定のコミットを参照する注釈付きタグ(annotated tag)を作成します。 軽量(注釈なし)タグ(lightweight tag)を作成するには、下記 @samp{reset} コマンドを参照してください。

@example
        'tag' SP <name> LF
        mark?
        'from' SP <commit-ish> LF
        original-oid?
        'tagger' (SP <name>)? SP LT <email> GT SP <when> LF
        data
@end example

ここで、 @samp{<name>} は作成するタグの名前です。

タグ名はGitに保存されるときに自動的に @samp{refs/tags/} のプレフィックスが付けられるため、CVSブランチシンボル @samp{RELENG-1_0-FINAL} をインポートすると、 @samp{<name>} に @samp{RELENG-1_0-FINAL} だけが使用され、 fast-importは対応するrefを @samp{refs/tags/RELENG-1_0-FINAL} として書き込みます。

@samp{<name>} の値は、Gitで有効なrefnameである必要があるため、スラッシュを含めることができます。 @samp{LF} はGit refnameでは無効であるため、ここではクォートやエスケープ構文はサポートされていません。

@samp{from} コマンドは @samp{commit} コマンドと同じです。 詳細については、上記を参照してください。

@samp{tagger} コマンドは、 @samp{commit} 内の @samp{committer} と同じ形式を使用します。 詳細については、再度上記を参照してください。

@samp{tagger} に続く @samp{data} コマンドは、注釈付きのタグメッセージを提供する必要があります(@samp{data} コマンドの構文については以下を参照してください)。 空のタグメッセージをインポートするには、長さ0のデータを使用します。 タグメッセージは自由形式であり、Gitによって解釈されません。 fast-importでは他のエンコードを指定できないため、現在はUTF-8でエンコードする必要があります。

fast-import内からのインポート中に注釈付きタグに署名することはサポートされていません。 フロントエンドは通常そのような署名に入るバイトの完全なセットに(簡単に)アクセスできないため、独自の PGP/GPG 署名を含めることはお勧めしません。 署名が必要な場合は、 @samp{reset} を使用してfast-import内から軽量タグを作成し、標準の @samp{git tag} プロセスを使用してそれらのタグの注釈付きバージョンをオフラインで作成します。

@noindent

@heading reset

名前付きブランチを作成(または再作成)します。オプションで、特定のリビジョンから開始します。 resetコマンドを使用すると、フロントエンドは既存のブランチに対して新しい @samp{from} コマンドを発行したり、新しいコミットを作成せずに既存のコミットから新しいブランチを作成したりできます。

@example
        'reset' SP <ref> LF
        ('from' SP <commit-ish> LF)?
        LF?
@end example

@samp{<ref>} と @samp{<commit-ish>} の詳細については、上記 @samp{commit} と @samp{from} を参照してください。

コマンドの後の @samp{LF} はオプションです(以前は必須でした)。

@samp{reset} コマンドを使用して、軽量(注釈なし)タグ(lightweight tag)を作成することもできます。 例えば:

@example
reset refs/tags/938
from :938
@end example

これはコミットマーク @samp{:938} が参照するものを参照して、軽量タグ @samp{refs/tags/938} を作成します。

@noindent

@heading blob

パックファイルに1つのファイルリビジョンを書き込むように要求します。 リビジョンはコミットに接続されていません。 この接続は、割り当てられたマークを介してブロブを参照することにより、後続の @samp{commit} コマンドで形成する必要があります。

@example
        'blob' LF
        mark?
        original-oid?
        data
@end example

一部のフロントエンドが独自にブロブのGitSHA-1を生成し、それを直接 @samp{commit} にフィードすることを選択したため、ここではmarkコマンドはオプションです。 ただし、マークは安価で保管しやすく、使い勝手も良いため、これは一般的にはマークより手間がかかると思われます。

@noindent

@heading data

生データ(ブロブ/ファイル コンテンツ または コミットメッセージ または 注釈付きタグメッセージ として使用するため)をfast-importに提供します。 データは、正確なバイトカウントを使用して提供することも、終了行で区切ることもできます。 本番品質の変換を目的とした実際のフロントエンドは、より堅牢でパフォーマンスが高いため、常に正確なバイトカウント形式を使用する必要があります。 区切られた形式は、主にfast-importのテストを目的としています。

@samp{data} コマンドの @samp{<raw>} 部分に表示されるコメント行は、常にデータの本文の一部と見なされるため、fast-importによって無視されることはありません。 これにより、行が @samp{#} で始まる可能性のある ファイル/メッセージ コンテンツを安全にインポートできます。

@table @asis

@item  Exact byte count format 
フロントエンドは、データのバイト数を指定する必要があります。

@example
        'data' SP <count> LF
        <raw> LF?
@end example

ここで、@samp{<count>} は @samp{<raw>} 内に表示される正確なバイト数です。 @samp{<count>} の値はASCII10進整数として表されます。 @samp{<raw>} の両側の @samp{LF} は @samp{<count>} に含まれず、インポートされたデータに含まれません。

@samp{<raw>} の後の @samp{LF} はオプションです(以前は必須でした)が、推奨されます。 @samp{<raw>} が @samp{LF} で終わっていなくても、次のコマンドは常に次の行の列0で開始するため、常にこれを含めると、fast-importストリームのデバッグが容易になります。

@item  Delimited format 
区切り文字列は、データの終わりを示すために使用されます。 fast-importは、区切り文字を検索して長さを計算します。 この形式は主にテストに役立ち、実際のデータにはお勧めしません。

@example
        'data' SP '<<' <delim> LF
        <raw> LF
        <delim> LF
        LF?
@end example

ここで、@samp{<delim>} は選択された区切り文字列です。 文字列 @samp{<delim>} は、 @samp{<raw>} 内の行に単独で表示されてはなりません。そうしないと、fast-importはデータが実際よりも早く終了すると見なします。 @samp{<raw>} の直後に続く @samp{LF} は @samp{<raw>} の一部です。 これは区切り形式の制限の1つであり、最後のバイトとしてLFを持たないデータチャンクを提供することはできません。

@samp{<delim> LF} の後の @samp{LF} はオプションです(以前は必須でした)。
@end table

@noindent

@heading alias

最初に新しいオブジェクトを作成せずに、マークが特定のオブジェクトを参照していることを記録します。

@example
        'alias' LF
        mark
        'to' SP <commit-ish> LF
        LF?
@end example

@samp{<commit-ish>} の詳細については、上記の @samp{from} を参照してください。

@noindent

@heading checkpoint

fast-importを強制して、現在のパックファイルを閉じ、新しいパックファイルを開始し、現在のすべてのブランチ参照とタグとマークを保存します。

@example
        'checkpoint' LF
        LF?
@end example

注意: fast-importは、現在のパックファイルが @samp{--max-pack-size} または 4 GiB のいずれか小さい方の制限に達すると、パックファイルを自動的に切り替えることに注意してください。 自動パックファイル切り替え中、fast-importは、ブランチの参照またはタグまたはマーク を更新しません。

@samp{checkpoint} はかなりのCPU時間とディスクI/Oを必要とする可能性があるため(パック全体のSHA-1チェックサムを計算し、対応するインデックスファイルを生成し、refを更新するため)、単一の @samp{checkpoint} コマンド完了に数分かかる場合があります。

フロントエンドは、非常に大規模で長時間実行されるインポート中、または別のGitプロセスにブランチへのアクセスを許可する必要があるときにチェックポイントを発行することを選択できます。 ただし、30 GiB Subversion リポジトリを fast-import によって約3時間でGitにロードできることを考えると、明示的なチェックポイントは必要ない場合があります。

コマンドの後の @samp{LF} はオプションです(以前は必須でした)。

@noindent

@heading progress

コマンドが入力ストリームから処理されるときに、fast-importが @samp{progress} 行全体を変更せずに標準の出力チャネル(ファイルデスクリプタ 1)に出力します。 それ以外の場合、このコマンドは現在のインポートやfast-importの内部状態には影響しません。

@example
        'progress' SP <any> LF
        LF?
@end example

コマンドの @samp{<any>} 部分には、 @samp{LF`を含まないバイトシーケンスを含めることができます。 コマンドの後の `LF} はオプションです。 呼び出し元は、sedなどのツールを使用して出力を処理し、行の先頭部分を削除したい場合があります。以下に例を示します:

@example
frontend | git fast-import | sed 's/^progress //'
@end example

@samp{checkpoint} の直後に @samp{progress`コマンドを配置すると、 `checkpoint} が完了したときにリーダーに通知され、fast-importで更新されたrefに安全にアクセスできます。

@noindent

@heading get-mark

fast-importが、標準出力または @samp{--cat-blob-fd} 引数であらかじめ指定されたファイルディスクリプタに、マークに対応するSHA-1を表示するようにします。 それ以外の場合、コマンドは現在のインポートに影響を与えません。 その目的は、後でコミットがコミットメッセージで参照する可能性のあるSHA-1を取得することです。

@example
        'get-mark' SP ':' <idnum> LF
@end example

この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。

@noindent

@heading cat-blob

fast-importにより、以前に @samp{--cat-blob-fd} 引数で設定されたファイルデスクリプタにブロブが出力されます。 それ以外の場合、コマンドは現在のインポートに影響を与えません。 その主な目的は、fast-importのメモリにある可能性があるが、ターゲットリポジトリからはアクセスできないブロブを取得することです。

@example
        'cat-blob' SP <dataref> LF
@end example

@samp{<dataref>} は、以前に設定されたマーク参照(@samp{:<idnum>})か、既存または書き込みの準備ができているGitブロブの完全な40バイトのSHA-1のいずれかです。

出力は @samp{git cat-file --batch} と同一形式を使用します:

@example
<sha1> SP 'blob' SP <size> LF
<contents> LF
@end example

このコマンドは、 @samp{filemodify} ディレクティブを表示できる場所で使用でき、コミットの途中で使用できます。 インラインディレクティブを使用する @samp{filemodify} の場合、 @samp{data} ディレクティブの直前に表示することもできます。

この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。

@noindent

@heading ls

パスにあるオブジェクトに関する情報を、事前に @samp{--cat-blob-fd} 引数で指定したファイルディスクリプタへ出力します。 これにより、アクティブなコミットからブロブを表示したり(@samp{cat-blob} を使用)、以前のコミットからブロブやツリーをコピーして現在のコミットで使用したり(@samp{filemodify} を使用))することができます。

@samp{ls} コマンドは、 @samp{filemodify} ディレクティブを表示できる場所でも使用でき、コミットの途中で使用できます。

@table @asis

@item  Reading from the active commit 
この形式は、@samp{commit} の途中でのみ使用できます。 パスは、fast-importのアクティブなコミット内のディレクトリエントリに名前を付けます。 この場合、パスはクォートする必要があります。

@example
        'ls' SP <path> LF
@end example

@item  Reading from a named tree 
@samp{<dataref>} は、マーク参照(@samp{:<idnum>})、またはGitタグ、コミット、ツリーオブジェクトの完全な40バイトのSHA-1であり、既存または書き込みを待機しています。 パスは、 @samp{<dataref>} で指定されたツリーの最上位を基準にしています。

@example
        'ls' SP <dataref> SP <path> LF
@end example
@end table

@samp{<path>} の詳細な説明については、上記の @samp{filemodify} を参照してください。

出力は @samp{git ls-tree <tree> -- <path>} と同一形式を使用します:

@example
<mode> SP ('blob' | 'tree' | 'commit') SP <dataref> HT <path> LF
@end example

<dataref>は、<path>にあるblob、tree、またはcommitオブジェクトを表し、後の @samp{get-mark} 、 @samp{cat-blob} 、 @samp{filemodify} 、 @samp{ls} コマンドで使用できます。

そのパスにファイルまたはサブツリーがない場合、 @samp{git fast-import} が代わりに報告します

@example
missing SP <path> LF
@end example

この出力を安全に読み取る方法の詳細については、以下の「Responses To Commands」(コマンドへの応答)を参照してください。

@noindent

@heading feature

fast-importが指定の機能をサポートすることを要求するか、サポートしない場合は中止(abort)します。

@example
        'feature' SP <feature> ('=' <argument>)? LF
@end example

コマンドの <feature> 部分は、以下のいずれかになります:

@table @asis

@item  date-format 
@itemx  export-marks 
@itemx  relative-marks 
@itemx  no-relative-marks 
@itemx  force 
先頭に @samp{--} が付いた対応するコマンドラインオプションが、コマンドラインで渡されたかのように動作します(上記 OPTIONS 参照)。

@item  import-marks 
@itemx  import-marks-if-exists 
@samp{--import-marks} と同様ですが、2つの点が異なります。まず、ストリームごとに1つの @samp{feature import-marks} または @samp{feature import-marks-if-exists} コマンドのみが許可されます。 次に、 @samp{--import-marks=} または @samp{--import-marks-if-exists} コマンドラインオプションは、ストリーム内のこれらの「feature」コマンドのいずれかをオーバーライドします。 第3に、対応するコマンドラインオプションのような @samp{feature import-marks-if-exists} は、存在しないファイルを黙ってスキップします。

@item  get-mark 
@itemx  cat-blob 
@itemx  ls 
バックエンドがそれぞれ @samp{get-mark} または @samp{cat-blob} または @samp{ls} コマンドをサポートしていることを要求します。 指定されたコマンドをサポートしていないバージョンのfast-importは、そのことを示すメッセージとともに終了します。 これにより、サポートされていないコマンドが検出される前にインポートの初期部分で時間を無駄にするのではなく、明確なメッセージでインポートエラーを早期に発生させることができます。

@item  notes 
バックエンドが @samp{commit} コマンドの @samp{notemodify} (N) サブコマンドをサポートしていることを要求します。 ノートをサポートしていないfast-importのバージョンは、そのことを示すメッセージとともに終了します。

@item  done 
@samp{done} コマンドなしでストリームが終了した場合はエラーになります。 この機能がないと、ストリーム内の便利なポイントでフロントエンドが突然終了する原因となるエラーが検出されなくなる可能性があります。 これは、たとえば、インポートフロントエンドがその下位のgit fast-importインスタンスでSIGTERMまたはSIGKILLを発行せずに、操作の途中で停止した場合に発生する可能性があります。
@end table

@noindent

@heading option

指定されたオプションを処理して、git fast-importがフロントエンドのニーズに合った方法で動作するようにします。 フロントエンドで指定されたオプションは、ユーザーがgit fast-import自体に指定したオプションによって上書きされることに注意してください。

@example
    'option' SP <option> LF
@end example

コマンドの @samp{<option>} 部分には、OPTIONSセクションにリストされているオプションのいずれかを含めることができます。これらのオプションは、先頭の @samp{--} がなくても、インポートのセマンティクスを変更せず、同じように扱われます。

optionコマンドは、非オプションコマンドがエラーになった後にオプションコマンドを与えるために、入力の最初のコマンドである必要があります(featureコマンドはカウントされません)。

以下のコマンドラインオプションはインポートセマンティクスを変更するため、オプションとして渡されない場合があります:

@itemize 

@item
date-format

@item
import-marks

@item
export-marks

@item
cat-blob-fd

@item
force
@end itemize

@noindent

@heading done

@samp{done} 機能が使用されていない場合は、EOFが読み取られたかのように扱われます。 これを使用して、fast-importに早期に終了するように指示できます。

@samp{--done} コマンドラインオプションまたは @samp{feature done} コマンドが使用されている場合、 @samp{done} コマンドは必須であり、ストリームの終わりを示します。

@noindent

@chapheading RESPONSES TO COMMANDS

fast-importによって作成された新しいオブジェクトはすぐには利用できません。 ほとんどのfast-importコマンドは、次のチェックポイント(または完了)まで目に見える効果はありません。 フロントエンドは、コマンドが有効になる速度を気にせずに、fast-importの入力パイプを埋めるためのコマンドを送信できます。これにより、スケジューリングが簡素化され、パフォーマンスが向上します。

ただし、一部のフロントエンドでは、更新中に現在のリポジトリからデータを読み戻すことができると便利です(たとえば、ソース素材が、以前にインポートされたオブジェクトに適用されるパッチの観点からオブジェクトを記述している場合)。 これは、フロントエンドとfast-importを双方向パイプを介して接続することで実現できます:

@example
mkfifo fast-import-output
frontend <fast-import-output |
git fast-import >fast-import-output
@end example

このように設定されたフロントエンドは、 @samp{progress} 、 @samp{get-mark} 、 @samp{ls} 、 @samp{cat-blob} コマンドを使用して、進行中のインポートから情報を読み取ることができます。

デッドロックを回避するために、このようなフロントエンドは、ブロックする可能性のあるfast-importへの書き込みを実行する前に、 @samp{progress} 、 @samp{ls} 、 @samp{get-mark} 、 @samp{cat-blob} からの保留中の出力を完全に消費する必要があります。

@noindent

@chapheading CRASH REPORTS

fast-importに無効な入力が指定された場合、ゼロ以外の終了ステータスで終了し、インポート先のGitリポジトリのトップレベルにクラッシュレポートが作成されます。 クラッシュレポートには、内部のfast-import状態のスナップショットと、クラッシュにつながる最も最近のコマンドが含まれています。

最近のすべてのコマンド(ストリームコメント、ファイル変更、進行状況コマンドを含む)は、クラッシュレポート内のコマンド履歴に表示されますが、生のファイルデータとコミットメッセージはクラッシュレポートから除外されます。 この除外により、レポートファイル内のスペースが節約され、fast-importが実行中に実行する必要のあるバッファリングの量が削減されます。

クラッシュレポートを作成した後、fast-importは現在のパックファイルを閉じ、マークテーブルをエクスポートします。 これにより、フロントエンド開発者はリポジトリの状態を検査し、クラッシュしたポイントからインポートを再開できます。 インポートが正常に完了しなかったため、変更されたブランチとタグはクラッシュ時に更新されません。 ブランチとタグの情報はクラッシュレポートに記載されており、更新が必要な場合は手動で適用する必要があります。

クラッシュ例:

@example
        $ cat >in <<END_OF_INPUT
        # my very first test commit
        commit refs/heads/master
        committer Shawn O. Pearce <spearce> 19283 -0400
        # who is that guy anyway?
        data <<EOF
        this is my commit
        EOF
        M 644 inline .gitignore
        data <<EOF
        .gitignore
        EOF
        M 777 inline bob
        END_OF_INPUT

        $ git fast-import <in
        fatal: Corrupt mode: M 777 inline bob
        fast-import: dumping crash report to .git/fast_import_crash_8434

        $ cat .git/fast_import_crash_8434
        fast-import crash report:
            fast-import process: 8434
            parent process     : 1391
            at Sat Sep 1 00:58:12 2007

        fatal: Corrupt mode: M 777 inline bob

        Most Recent Commands Before Crash
        ---------------------------------
          # my very first test commit
          commit refs/heads/master
          committer Shawn O. Pearce <spearce> 19283 -0400
          # who is that guy anyway?
          data <<EOF
          M 644 inline .gitignore
          data <<EOF
        * M 777 inline bob

        Active Branch LRU
        -----------------
            active_branches = 1 cur, 5 max

          pos  clock name
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           1)      0 refs/heads/master

        Inactive Branches
        -----------------
        refs/heads/master:
          status      : active loaded dirty
          tip commit  : 0000000000000000000000000000000000000000
          old tree    : 0000000000000000000000000000000000000000
          cur tree    : 0000000000000000000000000000000000000000
          commit clock: 0
          last pack   :


        -------------------
        END OF CRASH REPORT
@end example

@noindent

@chapheading TIPS AND TRICKS

以下のヒントとコツは、fast-importのさまざまなユーザーから収集されたものであり、提案として提供されています。

@noindent

@heading Use One Mark Per Commit

リポジトリ変換を行うときは、コミットごとに一意のマーク(@samp{mark :<n>})を使用し、コマンドラインで @samp{--export-marks} オプションを指定します。 fast-importは、すべてのマークとそれに対応するGitオブジェクトSHA-1をリストするファイルをダンプします。 フロントエンドがマークをソースリポジトリに結び付けることができる場合、各Gitコミットを対応するソースリビジョンと比較することで、インポートの正確性と完全性を簡単に確認できます。

PerforceやSubversionなどのシステムから来る場合、これは非常に単純なはずです。fast-importマークは、Perforceのチェンジセット番号またはSubversionのリビジョン番号でもある可能性があるためです。

@noindent

@heading Freely Skip Around Branches

インポート中に一度に1つのブランチに固執するようにフロントエンドをわざわざ最適化しようとしないでください。 これを行うと、fast-importの場合は少し速くなる可能性がありますが、フロントエンドコードの複雑さが大幅に増す傾向があります。

高速インポートに組み込まれているブランチLRUは非常に適切に動作する傾向があり、非アクティブなブランチをアクティブ化するコストは非常に低いため、ブランチ間でのバウンスはインポートのパフォーマンスに実質的に影響しません。

@noindent

@heading Handling Renames

名前を変更したファイルまたはディレクトリをインポートするときは、対応するコミット中に古い名前を削除し、新しい名前を変更するだけです。 Gitは、コミット中に明示的にではなく、事後に名前変更の検出を実行します。

@noindent

@heading Use Tag Fixup Branches

他のいくつかのSCMシステムでは、ユーザーは同じ コミット/チェンジセット からではない複数のファイルからタグを作成できます。 または、リポジトリで使用可能なファイルのサブセットであるタグを作成します。

これらのタグをそのままGitにインポートするには、タグのコンテンツと一致するようにファイルを「修正」するコミットを少なくとも1つ実行する必要があります。 fast-importの @samp{reset} コマンドを使用して、通常のブランチスペースの外側にあるダミーブランチをタグのベースコミットにリセットし、1つ以上のファイル修正コミットをコミットして、最後にダミーブランチにタグを付けます。

たとえば、すべての通常のブランチは @samp{refs/heads/} の下に保存されるため、タグ修正ブランチには @samp{TAG_FIXUP} という名前を付けます。 このように、インポーターによって使用される修正ブランチが、ソースからインポートされた実際のブランチと名前空間の競合を持つことは不可能です((名前 @samp{TAG_FIXUP} は @samp{refs/heads/TAG_FIXUP} ではありません)。

フィックスアップ(fixup)をコミットするときは、 @samp{merge} を使用してファイルリビジョンを提供しているコミットをフィックスアップブランチに接続することを検討してください。 そうすることで、 @samp{git blame} などのツールが実際のコミット履歴を追跡し、ソースファイルに適切に注釈を付けることができます。

fast-importが終了した後、フロントエンドはダミーブランチを削除するために @samp{rm .git/TAG_FIXUP} を実行する必要があります。

@noindent

@heading Import Now, Repack Later

fast-importが完了するとすぐに、Gitリポジトリは完全に有効になり、使用できるようになります。 通常、これは非常に大規模なプロジェクト(100,000以上のコミット)の場合でも、非常に短い時間しかかかりません。

ただし、データの局所性とアクセスパフォーマンスを向上させるには、リポジトリを再パックする必要があります。 また、非常に大規模なプロジェクトでは数時間かかる場合があります(特に、 @samp{-f} および 大きな @samp{--window} パラメーターが使用されている場合)。 再パックはリーダーやライターと一緒に実行しても安全なので、バックグラウンドで再パックを実行し、再パックが終了したらリーダーやライターを終了させます。 あなたが新しいGitプロジェクトに挑戦するのを待たされる事はありません！

あなたが再パックを待つことを選択した場合は、再パックが完了するまでベンチマークやパフォーマンステストを実行しないでください。 その場合、 fast-importは、実際の使用状況では決して見られないような、最適でないパックファイルを出力します。

@noindent

@heading Repacking Historical Data

非常に古くにインポートされたデータ(たとえば、昨年より古い)を再パックする場合は、 @samp{git repack} を実行するときに、 @samp{--window=50} (またはそれ以上)を指定して余分なCPU時間を費やすことを検討してください。 これには時間がかかりますが、作成されるパックファイルも小さくなります。 あなたが労力を費やす必要があるのは1回だけで、あなたのプロジェクトを使用するすべての人が小さくなったリポジトリの恩恵を受けることができます。

@noindent

@heading Include Some Progress Messages

時々、フロントエンドに @samp{progress} メッセージを送信してfast-importします。 メッセージの内容は完全に自由形式であるため、現在のコミット日が翌月に移動するたびに、現在の月と年を出力することをお勧めします。あなたのユーザーは、処理されたデータストリームの量をよりよく知ることができます。

@noindent

@chapheading PACKFILE OPTIMIZATION

ブロブを高速にパックする場合、インポートは常に最後に書き込まれたブロブに対して削除を試みます。 フロントエンドによって特別に調整されていない限り、これはおそらく同じファイルの以前のバージョンではないため、生成されるデルタは可能な限り最小にはなりません。 結果のパックファイルは圧縮されますが、最適ではありません。

単一のファイルのすべてのリビジョンに効率的にアクセスできるフロントエンド(たとえば、 RCS/CVS ,v file の読み取り)は、連続する @samp{blob} コマンドのシーケンスとして、そのファイルのすべてのリビジョンを提供することを選択できます。 これにより、fast-importでさまざまなファイルリビジョンを相互に区別し、最終的なパックファイルのスペースを節約できます。 マークは、後で一連の @samp{commit} コマンド中に個々のファイルリビジョンを識別するために使用できます。

fast-importによって作成されたパックファイルは、適切なディスクアクセスパターンを促進しません。 これは、標準入力で受信した順序でデータをfast-importで書き込むことが原因ですが、Gitは通常、パックファイル内のデータを整理して、最新の(現在の先端)データを履歴データの前に表示します。 Gitはまた、コミットをクラスター化し、キャッシュの局所性を向上させることでリビジョンのトラバーサルを高速化します。

このため、fast-importが完了した後、ユーザーがリポジトリを @samp{git repack -a -d} で再パックし、Gitがパックファイルを再編成してデータアクセスを高速化できるようにすることを強くお勧めします。 ブロブデルタが最適ではない場合(上記参照)、すべてのデルタの再計算を強制するために @samp{-f} オプションを追加すると、最終的なパックファイルサイズを大幅に減らすことができます(ほとんどの場合30〜50%小さくなります)。

@samp{git repack} を実行する代わりに、 @samp{git gc --aggressive} を実行することもできます。これにより、インポート後に他のものも最適化されます(たとえば、loose refs をパックします)。 git-gc(1) の「AGGRESSIVE」セクションに記載されているように、 @samp{--aggressive`オプションは、 linkgit:git-repack[1] への `-f} オプションを使用して新しいデルタを検索します。 上記で詳しく説明した理由により、fast-importの後に @samp{--aggressive} を使用することは、価値があることがわかっている数少ないケースの1つです。

@noindent

@chapheading MEMORY UTILIZATION

fast-importがインポートを実行するために必要なメモリの量に影響を与えるいくつかの要因があります。 コアGitのクリティカルセクションと同様に、fast-importは独自のメモリアロケータを使用して、mallocに関連するオーバーヘッドを減らします。 実際には、fast-importは、大きなブロック割り当てを使用するため、mallocオーバーヘッドを0に減らす傾向があります。

@noindent

@heading per object

fast-importは、この実行で書き込まれるすべてのオブジェクトのメモリ内構造を維持します。 32ビットシステムでは、構造は32バイトですが、64ビットシステムでは、構造は40バイトです(ポインタサイズが大きいため)。 テーブル内のオブジェクトは、fast-importが終了するまで割り当てが解除されません。 32ビットシステムに200万個のオブジェクトをインポートするには、約64MiBのメモリが必要です。

オブジェクトテーブルは、実際にはオブジェクト名(一意のSHA-1)をキーとするハッシュテーブルです。 このストレージ構成により、fast-importで既存または既に書き込まれたオブジェクトを再利用し、出力パックファイルへの重複の書き込みを回避できます。 インポートでは、ブロブの重複が驚くほど一般的です。これは通常、ソースでのブランチのマージが原因です。

@noindent

@heading per mark

マークは、マークごとに1つのポインター(ポインターのサイズに応じて4バイトまたは8バイト)を使用して、まばらな配列に格納されます。 配列はまばらですが、フロントエンドでは 1〜n のマークを使用することを強くお勧めします。ここで、n はこのインポートに必要なマークの総数です。

@noindent

@heading per branch

ブランチはアクティブと非アクティブにクラス分けされます。 2つのクラスのメモリ使用量は大幅に異なります。

非アクティブなブランチは、ブランチごとに96バイトまたは120バイト(それぞれ32ビットまたは64ビットシステム)とブランチ名の長さ(通常は200バイト未満)を使用する構造に格納されます。 fast-importは、2MiB未満のメモリで10,000もの非アクティブなブランチを簡単に処理します。

アクティブなブランチには非アクティブなブランチと同じオーバーヘッドがありますが、そのブランチで最近変更されたすべてのツリーのコピーも含まれています。 ブランチがアクティブになってからサブツリー @samp{include} が変更されていない場合、その内容はメモリに読み込まれませんが、ブランチがアクティブになってからコミットによってサブツリー @samp{src} が変更されている場合、その内容はメモリに読み込まれます。

アクティブなブランチは、そのブランチに含まれるファイルに関するメタデータを格納するため、メモリ内のストレージサイズがかなり大きくなる可能性があります(以下参照)。

fast-importは、単純な「最も最近使用されていない」アルゴリズム(least-recently-used algorithm)に基づいて、アクティブなブランチを自動的に非アクティブなステータスに移動します。 LRUチェーンは、@samp{commit} コマンドごとに更新されます。 アクティブなブランチの最大数は、コマンドラインで @samp{--active-branches=} を使用して増減できます。

@noindent

@heading per active tree

ツリー(別名ディレクトリ)は、エントリに必要なメモリに加えて、わずか12バイトのメモリを使用します(以下「per active file」参照)。 ツリーのオーバーヘッドは個々のファイルエントリで償却されるため、ツリーのコストは実質的に0です。

@noindent

@heading per active file entry

アクティブツリー内のファイル(およびサブツリーへのポインター)には、エントリごとに52バイトまたは64バイト(32/64 ビットプラットフォーム)が必要です。 スペースを節約するために、ファイル名とツリー名は共通の文字列テーブルにプールされ、ファイル名 @samp{Makefile} が(文字列ヘッダーのオーバーヘッドを含めた後)、プロジェクト内で何度発生しても、わずか16バイトしか使用しないようにします。

アクティブブランチLRUは、ファイル名文字列プールおよびサブツリーの遅延読み込みと組み合わせると、fast-importにより、非常に限られたメモリフットプリント(アクティブブランチあたり2.7 MiB未満)で2,000以上のブランチと45,114以上のファイルを持つプロジェクトを効率的にインポートできます。

@noindent

@chapheading SIGNALS

@strong{SIGUSR1} を @samp{git fast-import} プロセスに送信すると、現在のパックファイルが早期に終了し、 @samp{checkpoint} コマンドがシミュレートされます。 せっかちなオペレーターは、この機能を使用して、実行時間の追加と圧縮率の低下を犠牲にして、進行中のインポートからオブジェクトとrefを確認できます。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  fastimport.unpackLimit 
git-fast-import(1) によってインポートされたオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、インポートされたオブジェクトの数がこの制限以上の場合、パックはパックとして保存されます。 fast-import(高速インポート)からパックを保存すると、特に低速のファイルシステムで、インポート操作をより速く完了することができます。 設定されていない場合は、代わりに @samp{transfer.unpackLimit} の値が使用されます。
@end table

@noindent

@chapheading SEE ALSO

git-fast-export(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fetch-pack,,,Top
@chapheading Name

git-fetch-pack — 別のリポジトリから不足しているオブジェクトを受け取ります

@noindent

@chapheading Synopsis

@display
git fetch-pack [--all] [--quiet|-q] [--keep|-k] [--thin] [--include-tag]
        [--upload-pack=<git-upload-pack>]
        [--depth=<n>] [--no-progress]
        [-v] <repository> [<refs>…]
@end display


@noindent

@chapheading DESCRIPTION

通常は、代わりにこのコマンドの上位レベルのラッパーである @samp{git fetch} を使用することをお勧めします。

おそらくはリモートリポジトリで @samp{git-upload-pack} を起動し、このリポジトリから不足しているオブジェクトを送信し、名前付きの head を更新するよう問合せます。ローカルで利用可能なコミットの一覧は、ローカルの refs/ 階層をスキャンして見つけ、相手側で実行されている @samp{git-upload-pack} に送信されます。

このコマンドは、ローカル側に共通の祖先コミットがない場合には、リモート側から要求された参照を完了するためにすべてをダウンロードするよう機能縮退します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--all} 
すべてのリモート参照をフェッチします。

@item  @samp{--stdin} 
stdinから参照のリストを1行に1つずつ取得します。このオプションに加えてコマンドラインで参照が指定されている場合、stdinからの参照はコマンドラインでの参照の後に処理されます。

このオプションと一緒に @samp{--stateless-rpc} を指定する場合、参照のリストはパケット形式(pkt-line)である必要があります。各refは個別のパケットに含まれている必要があり、リストはフラッシュパケットで終了している必要があります。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{-q} フラグを @samp{git unpack-objects} に渡します。 これにより、クローン作成プロセスのおしゃべりが減ります。

@item  @samp{-k} 
@itemx  @samp{--keep} 
受信したデータに対して @samp{git unpack-objects} を呼び出さないでください。代わりに、そのデータから単一のパックファイルを作成し、オブジェクトデータベースに保存してください。このオプションが2回指定された場合、パックは再パックに対してロックされます(the pack is locked against repacking)。

@item  @samp{--thin} 
ネットワークトラフィックを軽減するために、パックに含まれないオブジェクトを元に、オブジェクトを差分化(デルタ化)して記録する「薄い」パック(thin pack)をフェッチします。

@item  @samp{--include-tag} 
リモート側がサポートしている場合、タグが参照するオブジェクトがダウンロードされると、注釈付きタグオブジェクトが他のオブジェクトと同じ接続(same connection)でダウンロードされます。それ以外の場合、呼び出し元は、このオプションで使用できるタグを決定する必要があります。

@item  @samp{--upload-pack=<git-upload-pack>} 
あなたの $PATHに見つからない場合は、これを使用して、リモート側の @samp{git-upload-pack} へのパスを指定します。sshdをインストールすると、ログインシェル用のユーザーの環境設定スクリプト(@samp{.bash_profile} など)が無視され、プライベートにインストールされたgitがシステムのデフォルトの$PATHで見つけられない場合があります。推奨される別の回避策は、 @samp{.bashrc} に $PATHを設定することですが、このフラグは、(ほとんどのものを.bash_profileに設定して、)中身の無い @samp{.bashrc} ファイルを使用して非対話型シェルのオーバーヘッドを支払いたくない人向けです。

@item  @samp{--exec=<git-upload-pack>} 
@samp{--upload-pack=<git-upload-pack>} と同じ。

@item  @samp{--depth=<n>} 
フェッチを n 以下の祖先チェーンに制限します。 @samp{git-upload-pack} は、特別な深さ2147483647が指定された場合、その深さの祖先チェーンがある場合でも、それを無限として扱います。

@item  @samp{--shallow-since=<date>} 
浅いリポジトリ(shallow repository)の履歴を更に深くするか更に浅くするかして、 <date> 以降の到達可能なすべてのコミットを含めます。

@item  @samp{--shallow-exclude=<revision>} 
浅いリポジトリ(shallow repository)の履歴を深くするか浅くするかして、指定されたリモートブランチまたはタグから到達可能なコミットを除外します。このオプションは複数回指定できます。

@item  @samp{--deepen-relative} 
引数 @samp{--depth} は、各リモートブランチ履歴の先端からではなく、現在の浅い境界(shallow boundary)からのコミット数を指定します。

@item  @samp{--refetch} 
マッチするすべてのオブジェクトをフェッチするために、サーバーとのコミットのネゴシエーションをスキップします。 新しい部分クローン ブロブ/ツリー フィルターを再適用するために使用します。

@item  @samp{--no-progress} 
進捗状況を表示しないでください。

@item  @samp{--check-self-contained-and-connected} 
受信したパックが自己完結型で接続されている場合は、 "connectivity-ok" を出力します。

@item  @samp{-v} 
おしゃべりになります。

@item  <repository> 
リモートリポジトリへのURL。

@item  <refs>… 
更新元のリモートヘッド。これは $GIT_DIR に関連しています(例: @samp{HEAD} 、 @samp{refs/heads/master} )。指定しない場合は、リモート側が持つすべてのヘッドから更新します。

リモートがオプション @samp{uploadpack.allowTipSHA1InWant} または @samp{uploadpack.allowReachableSHA1InWant} または @samp{uploadpack.allowAnySHA1InWant} を有効にしている場合、それらはリモートに存在する 16進40桁 sha1 である可能性があります。
@end table

@noindent

@chapheading SEE ALSO

git-fetch(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fetch,,,Top
@chapheading Name

git-fetch — 別のリポジトリからオブジェクトとrefsをダウンロードします

@noindent

@chapheading Synopsis

@display
git fetch [<options>] [<repository> [<refspec>…]]
git fetch [<options>] <group>
git fetch --multiple [<options>] [(<repository> | <group>)…]
git fetch --all [<options>]
@end display


@noindent

@chapheading DESCRIPTION

履歴を完成させるために必要なオブジェクトとともに、1つ以上の他のリポジトリからブランチやタグ(総称して「refs」)を取得します。 リモート追跡ブランチが更新されます(この振る舞いを制御する方法については、以下の <refspec> の説明を参照してください)。

デフォルトでは、フェッチされている履歴を指すタグもフェッチされます。 その効果は、関心のあるブランチを指すタグをフェッチすることです。 このデフォルトの振る舞いは、 @samp{--tags} または @samp{--no-tags} オプションを使用するか、 remote.<name>.tagOpt を構成することで変更できます。 あなたは、タグを明示的にフェッチするrefspecを使用することで、関心のあるブランチを指していないタグもフェッチできます。

@samp{git fetch} は、単一の名前付きリポジトリまたはURLから、あるいは、 <group> が指定され、かつ、構成ファイルに remotes.<group> エントリがある場合は、一度に複数のリポジトリからフェッチできます。 (git-config(1) 参照)。

「リモート」が指定されていない場合、現在のブランチ用にアップストリームブランチが構成されていない限り、デフォルトで @samp{origin} リモートが使用されます。

フェッチされたrefの名前は、それらが指すオブジェクト名とともに、 @samp{.git/FETCH_HEAD} に書き込まれます。 この情報は、スクリプトまたは git-pull(1) などの他のgitコマンドで使用される場合があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--all} 
すべてのリモートをフェッチします。

@item  @samp{-a} 
@itemx  @samp{--append} 
フェッチされた参照の参照名とオブジェクト名を @samp{.git/FETCH_HEAD} の既存のコンテンツに追加します。 このオプションがないと、 @samp{.git/FETCH_HEAD} の古いデータが上書きされます。

@item  @samp{--atomic} 
アトミックトランザクションを使用して、ローカル参照を更新します。 すべての参照が更新されるか、あるいは、エラーが発生してすべての参照が新されないか、のいずれかです。

@item  @samp{--depth=<depth>} 
各リモートブランチ履歴の先端からの指定されたコミット数にフェッチを制限します。 @samp{--depth=<depth>} オプションを指定して @samp{git clone} によって作成された浅いリポジトリ(shallow repository)からフェッチする場合(git-clone(1) 参照)、指定されたコミット数まで履歴を深くするか浅くするかします。

@item  @samp{--deepen=<depth>} 
@samp{--depth} に似ていますが、各リモートブランチ履歴の先端からではなく、現在の浅い境界(shallow boundary)からのコミット数を指定する点が異なります。

@item  @samp{--shallow-since=<date>} 
浅い(shallow)リポジトリの履歴を深くしたり浅くしたりして、<date>以降の到達可能なすべてのコミットを含めます。

@item  @samp{--shallow-exclude=<revision>} 
浅いリ(shallow)ポジトリの履歴を深くするか浅くするかして、指定されたリモートブランチまたはタグから到達可能なコミットを除外します。 このオプションは複数回指定できます。

@item  @samp{--unshallow} 
ソースリポジトリが完全な場合は、浅いリ(shallow)ポジトリを完全なリポジトリに変換し、浅い(shallow)リポジトリによって課せられるすべての制限を取り除きます。

ソースリポジトリが浅い(shallow)場合は、現在のリポジトリがソースリポジトリと同じ履歴を持つように、可能な限りフェッチします。

@item  @samp{--update-shallow} 
デフォルトでは、浅い(shallow)リポジトリからフェッチする場合、 @samp{git fetch} は @samp{.git/shallow} の更新が必要なrefを拒否します。 このオプションは @samp{.git/should} を更新し、そのようなrefを受け入れます。

@item  @samp{--negotiation-tip=<commit|glob>} 
デフォルトでは、Gitは、受信するパックファイルのサイズを縮小するために、すべてのローカルrefから到達可能なコミットをサーバーに報告して、共通のコミットを見つけます。 指定した場合、Gitは指定された先端から到達可能なコミットのみを報告します。 これは、フェッチされるアップストリームrefと共通のコミットを持つ可能性のあるローカルrefがユーザーにわかっている場合に、フェッチを高速化するのに役立ちます。

このオプションは複数回指定できます。 その場合、Gitは指定されたコミットのいずれかから到達可能なコミットを報告します。

このオプションの引数は、ref名またはrefまたはコミットの(おそらく省略された)SHA-1のグロブである可能性があります。グロブを指定することは、一致するref名ごとに1つずつ、このオプションを複数回指定することと同じです。

git-config(1) に記載されている @samp{fetch.negotiationAlgorithm} と @samp{push.negotiate} 構成変数、および、以下の @samp{--negotiate-only} オプションも参照してください。

@item  @samp{--negotiate-only} 
サーバーから何もフェッチせず、代わりに、サーバーと共通している、提供された @samp{--negotiation-tip=*} 引数の祖先を出力します。

これは @samp{--recurse-submodules=[yes|on-demand]} と互換性がありません。 内部的には、これは @samp{push.negotiate} オプションを実装するために使用されます。 git-config(1) を参照してください。

@item  @samp{--dry-run} 
変更を加えずに、何が行われるかを示します。

@item  @samp{--porcelain} 
Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch(1) for details.

This is incompatible with @samp{--recurse-submodules=[yes|on-demand]} and takes precedence over the @samp{fetch.output} config option.

@item  @samp{--[no-]write-fetch-head} 
@samp{$GIT_DIR} のすぐ下の @samp{FETCH_HEAD} ファイルにフェッチされたリモートrefのリストを書き込みます。 これがデフォルトです。 コマンドラインから @samp{--no-write-fetch-head} を渡すと、Gitにファイルを書き込まないように指示します。 @samp{--dry-run} オプションでは、ファイルが書き込まれることはありません。

@item  @samp{-f} 
@itemx  @samp{--force} 
@samp{git fetch} を @samp{<src>:<dst>} refspecと一緒に使用すると、既に説明したようにローカルブランチの更新を拒否する場合があります
以下の @samp{<refspec>} の部分にあります。
このオプションは、そのチェックをオーバーライドします。

@item  @samp{-k} 
@itemx  @samp{--keep} 
ダウンロードしたパックを保持してください。

@item  @samp{--multiple} 
複数の<repository>および<group>引数を指定できるようにします。 <refspec>を指定することはできません。

@item  @samp{--[no-]auto-maintenance} 
@itemx  @samp{--[no-]auto-gc} 
最後に @samp{git maintenance run --auto} を実行して、必要に応じて自動リポジトリメンテナンスを実行します。 (@samp{--[no-]auto-gc} は同義語です。) これはデフォルトで有効になっています。

@item  @samp{--[no-]write-commit-graph} 
フェッチ後にコミットグラフ(commit-graph)を記述します。 これは、構成設定 @samp{fetch.writeCommitGraph} をオーバーライドします。

@item  @samp{--prefetch} 
構成されたrefspecを変更して、すべてのrefを @samp{refs/prefetch/} 名前空間に配置します。 git-maintenance(1)の @samp{prefetch} タスクを参照してください。

@item  @samp{-p} 
@itemx  @samp{--prune} 
フェッチする前に、リモートに存在しなくなったリモート追跡参照を削除します。 タグは、デフォルトのタグの自動追跡または @samp{--tags} オプションのためにのみフェッチされた場合(コマンドラインまたはリモート構成のいずれかで、たとえば、リモートが @samp{--mirror} オプションでcloneされた場合)、刈り込み(pruning)の対象にはなりません。 ただし、明示的なrefspecが原因でタグがフェッチされた場合、それらも刈り込み(pruning)の対象になります。 @samp{--prune-tags} を指定することは、タグrefspecを提供するための省略形です。

詳細については、下記の「PRUNING」セクションを参照してください。

@item  @samp{-P} 
@itemx  @samp{--prune-tags} 
@samp{--prune} が有効になっている場合は、フェッチする前に、リモートに存在しなくなったローカルタグをすべて削除します。 このオプションは、 @samp{--prune} とは異なり、より慎重に使用する必要があります。作成されたローカル参照(ローカルタグ)はすべて削除されます。 このオプションは、明示的なタグrefspecを @samp{--prune} とともに提供するための省略形です。これについては、そのドキュメントの説明を参照してください。

詳細については、下記の「PRUNING」セクションを参照してください。

@item  @samp{-n} 
@itemx  @samp{--no-tags} 
デフォルトでは、リモートリポジトリからダウンロードされたオブジェクトを指すタグがフェッチされ、ローカルに保存されます。このオプションは、この自動タグ追跡を無効にします。 リモートのデフォルトの動作は、 @samp{remote.<name>.tagOpt} 設定で指定できます。 git-config(1) を参照してください。

@item  @samp{--refetch} 
すでにローカルに存在するコミットとその関連オブジェクトの転送を避けるためにサーバーと交渉(negotiate)する代わりに、 このオプションは新しいクローン(fresh clone)のようにすべてのオブジェクトをフェッチします。 これを使用して、構成から部分(partial)クローン・フィルターを再適用するか、または、フィルター定義が変更されたときに @samp{--filter=} を使用します。 フェッチ後の自動メンテナンスにより、オブジェクト・データベース・パックの統合が実行され、重複オブジェクトが削除されます。

@item  @samp{--refmap=<refspec>} 
コマンドラインにリストされているrefをフェッチするときは、リモートリポジトリの @samp{remote.*.fetch} 構成変数の値の代わりに、指定されたrefspec(複数回指定可能)を使用してrefをリモート追跡ブランチにマップします。 空の @samp{<refspec>} を @samp{--refmap} オプションに指定すると、Gitは構成されたrefspecsを無視し、コマンドライン引数として提供されたrefspecsに完全に依存します。 詳細については、「Configured Remote-tracking Branches」のセクションを参照してください。

@item  @samp{-t} 
@itemx  @samp{--tags} 
他の方法でフェッチされるものに加えて、リモートからすべてのタグをフェッチします(つまり、リモートタグ @samp{refs/tags/*} を同じ名前のローカルタグにフェッチします)。 このオプションを単独で使用しても、 @samp{--prune} が使用されている場合でも、タグは刈り込み(pruning)の対象にはなりません(ただし、タグが明示的なrefspecの宛先でもある場合は、タグは刈り込み(pruning)される可能性があります。 @samp{--prune} を参照してください)。

@item  @samp{--recurse-submodules[=yes|on-demand|no]} 
このオプションは、サブモジュールの新しいコミットも取得する必要があるかどうか、およびどのような条件で取得するかを制御します。 サブモジュールを再帰するとき、 @samp{git fetch} は常に「変更された」サブモジュール、つまり、新しく取得(fetch)されたスーパープロジェクト・コミットによって参照されるが、ローカル・サブモジュール・クローンにないコミットを持つサブモジュールを取得(fetch)しようとします。 変更されたサブモジュールは、ローカル、たとえば @samp{$GIT_DIR/modules/} 内に存在する限り取得(fetch)できます(gitsubmodules(7) を参照)。 アップストリームが新しいサブモジュールを追加した場合、そのサブモジュールはクローン、たとえば @samp{git submodule update} されるまで取得(fetch)できません。

@samp{on-demand} に設定すると、 変更されたサブモジュールのみがフェッチされます。 @samp{yes} に設定すると、すべての入力済みサブモジュールと、未入力かつ変更されたサブモジュールが、フェッチされます。 @samp{no} に設定すると、サブモジュールはフェッチされません。

指定されていない場合、 @samp{fetch.recurseSubmodules} が設定されている場合は @samp{fetch.recurseSubmodules} の値が使用され(git-config(1) 参照)、 @samp{fetch.recurseSubmodules} も設定されていない場合はデフォルトで @samp{on-demand} になります。 このオプションを値なしで使用すると、デフォルトで @samp{yes} になります。

@item  @samp{-j} 
@itemx  @samp{--jobs=<n>} 
すべての形式のフェッチに使用されるparallel childrenの数。

@samp{--multiple} オプションが指定された場合、異なるリモートが並行してフェッチされます。 複数のサブモジュールがフェッチされる場合、それらは並行してフェッチされます。 それらを個別に制御するには、構成設定 @samp{fetch.parallel} と @samp{submodule.fetchJobs} を使用します(git-config(1) 参照)。

通常、並列再帰フェッチとマルチリモートフェッチの方が高速です。デフォルトでは、フェッチは並列ではなく順次実行されます。

@item  @samp{--no-recurse-submodules} 
サブモジュールの再帰的フェッチを無効にします(これは、 @samp{--recurse-submodules=no} オプションを使用するのと同一の効果があります)。

@item  @samp{--set-upstream} 
リモートが正常にフェッチされた場合は、引数のない git-pull(1) およびその他のコマンドで使用されるアップストリーム(追跡)参照を追加します。 詳細については、 git-config(1) の @samp{branch.<name>.merge} および @samp{branch.<name>.remote} を参照してください。

@item  @samp{--submodule-prefix=<path>} 
「Fetching submodule foo」などの情報メッセージに出力されるパスの前に<path>を付けます。このオプションは、サブモジュールを再帰的に実行するときに内部的に使用されます。

@item  @samp{--recurse-submodules-default=[yes|on-demand]} 
このオプションは、 @samp{--recurse-submodules} オプションに負でないデフォルト値を一時的に提供するために内部的に使用されます。 フェッチのサブモジュール再帰を構成する他のすべての方法(gitmodules(5) や git-config(1) の設定など) は、 @samp{--[no-]recurse-submodules} を直接指定する場合と同様に、このオプションをオーバーライドします。

@item  @samp{-u} 
@itemx  @samp{--update-head-ok} 
デフォルトでは、 @samp{git fetch} は現在のブランチに対応するヘッドの更新を拒否します。 このフラグはそのチェックを無効にします。 これは純粋に @samp{git pull} が @samp{git fetch} と通信するための内部使用のためであり、あなたが独自の磁器コマンドを実装していない限り、あなたがそれを使用することは想定されていません。

@item  @samp{--upload-pack <upload-pack>} 
指定され、フェッチ元のリポジトリが @samp{git fetch-pack} によって処理されると、 @samp{--exec=<upload-pack>} がコマンドに渡され、もう一方の端で実行されるコマンドのデフォルト以外のパスが指定されます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{--quiet} を @samp{git-fetch-pack} に渡し、内部で使用される他のgitコマンドをすべて静粛にさせます。 進行状況は標準エラーストリームに報告されません。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
おしゃべりにします。

@item  @samp{--progress} 
@samp{-q} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{-o <option>} 
@itemx  @samp{--server-option=<option>} 
プロトコルバージョン2を使用して通信する場合は、指定された文字列をサーバーに送信します。 指定された文字列には、NUL文字またはLF文字を含めることはできません。 不明なオプションを含むサーバーオプションのサーバー処理は、サーバー固有です。 複数の @samp{--server-option=<option>} が指定されている場合、それらはすべてコマンドラインにリストされている順序で相手側に送信されます。

@item  @samp{--show-forced-updates} 
デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 これは @samp{fetch.showForcedUpdates} を介して無効にすることができますが、 @samp{--show-forced-updates} オプションはこのチェックが行われることを保証します。 git-config(1) を参照してください。

@item  @samp{--no-show-forced-updates} 
デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 @samp{--no-show-forced-updates} を渡すか、 @samp{fetch.showForcedUpdates} を @samp{false} に設定して、パフォーマンス上の理由からこのチェックをスキップします。 @samp{git-pull} 処理中に使用された場合、 @samp{--ff-only} オプションは、早送り(fast-forward)更新を試行する前に、強制更新をチェックします。 git-config(1) を参照してください。

@item  @samp{-4} 
@itemx  @samp{--ipv4} 
IPv6アドレスを無視して、IPv4アドレスのみを使用します。

@item  @samp{-6} 
@itemx  @samp{--ipv6} 
IPv4アドレスを無視して、IPv6アドレスのみを使用します。

@item  <repository> 
フェッチまたはプル操作のソースである「リモート」リポジトリ。このパラメーターは、URL(以下の GIT URLS  セクションを参照)またはリモートの名前(以下の REMOTES (@pxref{[REMOTES]}) セクションを参照)のいずれかです。

@item  <group> 
構成ファイル内のリモート。 <group> の値としてリポジトリーのリストを参照する名前。(git-config(1) を参照)。

@item  <refspec> 
フェッチするrefと更新するローカルrefを指定します。コマンドラインに <refspec> がない場合、フェッチするrefは代わりに @samp{remote.<repository>.fetch} 変数から読み取られます。
(下記 CONFIGURED REMOTE-TRACKING BRANCHES (@pxref{[CRTB]}) 参照)

<refspec> パラメータの組織は、オプションのプラス @samp{+} に続いて ソースの <src> 、コロン @samp{:} 宛先refの <dst> の順です。 <dst> が空の場合、コロン(@samp{:})は省略できます。 <src> は通常、refですが、フルスペルの16進オブジェクト名にすることもできます。

<refspec> の <src> には、単純なパターン一致を示すための @samp{*} が含まれている場合があります。このようなrefspecは、同じプレフィックスを持つ任意のrefに一致するglobのように機能します。パターン<refspec>では、 <src> と <dst> の両方に @samp{*} が含まれている必要があります。 @samp{*} をソースから一致したコンテンツに置き換えることにより、refを宛先にマッピングします。

refspecの前に @samp{^} が付いている場合、それはネガティブのrefspecとして解釈されます。このようなrefspecは、フェッチするrefや更新するローカルrefを指定するのではなく、除外するrefを指定します。 refは、少なくとも1つのポジティブ(通常)のrefspecと一致し、ネガティブのrefspecと一致しない場合、一致すると見なされます。ネガティブのrefspecは、特定のrefが含まれないように、パターンrefspecのスコープを制限するのに役立ちます。ネガティブのrefspecは、それ自体がパターンrefspecである可能性があります。 ただし、 <src> のみを含めることができ、 <dst> を指定することはできません。 フルスペルの16進オブジェクト名もサポートされていません。

@samp{tag <tag>} は、 @samp{refs/tags/<tag>:refs/tags/<tag>} と同じ意味です。指定されたタグまでのすべてをフェッチするように要求します。

<src> に一致するリモートrefがフェッチされ、 <dst> が空の文字列でない場合は、それに一致するローカルrefを更新しようとします。

その更新が @samp{--force} なしで許可されるかどうかは、フェッチ先のref名前空間、フェッチされるオブジェクトのタイプ、および更新がfast-forwardであると見なされるかどうかによって異なります。一般に、プッシュする場合と同じルールがフェッチに適用されます。それらが何であるかについては、 git-push(1)の @samp{<refspec>...} セクションを参照してください。 @emph{git fetch} に固有の例外ルールを以下に示します。

Gitバージョン2.20までは、 git-push(1) でプッシュする場合とは異なり、 @samp{refs/tags/*} の更新は、 refspec に @samp{+} がなくても(または @samp{--force} 指定が無くても)受け入れられます。フェッチするとき、リモートからのすべてのタグ更新を強制フェッチとしていました。Gitバージョン2.20以降では、 @samp{refs/tags/*} を更新するためのフェッチは、プッシュする場合と同じように機能します。 つまり refspecに @samp{+} が無い場合(または @samp{--force} が無い場合)、更新は拒否されます。

git-push(1) でプッシュするときとは異なり、 @samp{refs/@{tags,heads@}/*} 以外の更新は、 refspecに @samp{+} がなくても(あるいは @samp{--force} 指定が無くても)受け付けられます。例えば、ツリーオブジェクトとブロブを交換したり、あるコミットを、祖先を持たない別のコミットと交換したりできます。

git-push(1) でプッシュする場合とは異なり、これらのルールを修正する構成はなく、 @samp{pre-receive} フックに類似した @samp{pre-fetch} フックのようなものはありません。

git-push(1) を使用したプッシュと同様に、更新として許可されないものに関する上記のすべてのルールは、refspec先頭にオプションで @samp{+} をに追加する(または @samp{--force} コマンドラインオプションを使用する)ことでオーバーライドできます。これに対する唯一の例外は、 @samp{refs/heads/*} 名前空間が非コミットオブジェクトを受け入れるように強制することはないということです。

@quotation

@strong{Note}

フェッチするリモートブランチが定期的に巻き戻されてリベースされることがわかっている場合、その新しい先端は(最後にフェッチしたときにリモートトラッキングブランチに保存された)以前の先端の子孫ではないことが予想されます。あなたは @samp{+} 記号を使用して、そのようなブランチにnon-fast-forwardの更新が必要であることを指示します。この操作でブランチがリポジトリで使用可能になることを決定または宣言する方法はありません。プルするユーザーは、これがブランチの予想される使用パターンであることを知っている必要があります。
@end quotation

@item  @samp{--stdin} 
引数として提供されているものに加えて、標準入力からrefspecsを1行に1つずつ読み取ります。 「tag <name>」形式はサポートされていません。
@end table

@noindent

@chapheading GIT URLS

一般に、URLには、トランスポートプロトコル、リモートサーバーのアドレス、およびリポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、一部の情報が欠落している場合があります。

Gitはsshとgitとhttpとhttpsプロトコルをサポートします(さらにftpとftpsをフェッチに使用できますが、これは非効率的で非推奨です。使用しないでください)。

ネイティブトランスポート(つまり、 git:// URL)は認証を行わないため、セキュリティで保護されていないネットワークでは注意して使用する必要があります。

以下の構文を使用できます:

@itemize 

@item
ssh://[user@@]host.xz[:port]/path/to/repo.git/

@item
git://host.xz[:port]/path/to/repo.git/

@item
http[s]://host.xz[:port]/path/to/repo.git/

@item
ftp[s]://host.xz[:port]/path/to/repo.git/
@end itemize

代替のscpのような構文をsshプロトコルで使用することもできます:

@itemize 

@item
[user@@]host.xz:path/to/repo.git/
@end itemize

この構文は、最初のコロン(:)の前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス @samp{foo:bar} を、絶対パスまたは @samp{./foo:bar} として指定して、 ssh url として誤って解釈されないようにすることができます。

sshおよびgitプロトコルは、さらに ~username 拡張をサポートします:

@itemize 

@item
ssh://[user@@]host.xz[:port]/~[user]/path/to/repo.git/

@item
git://host.xz[:port]/~[user]/path/to/repo.git/

@item
[user@@]host.xz:/~[user]/path/to/repo.git/
@end itemize

Gitでもネイティブにサポートされているローカルリポジトリの場合、以下の構文を使用できます:

@itemize 

@item
/path/to/repo.git/

@item
file:///path/to/repo.git/
@end itemize

これらの2つの構文は、前者が @samp{--local} オプションの機能を含むクローン作成の場合を除いて、ほとんど同等です。 詳細については、 git-clone(1) を参照してください。

「git clone」と「git fetch」と「git pull」は、「git push」と違って適切なバンドルファイルを受け入れます。 git-bundle(1) を参照してください。

Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、Gitは @emph{remote-<transport>} リモートヘルパー(存在する場合)を使用しようとします。リモートヘルパーを明示的に要求するには、以下の構文を使用できます:

@itemize 

@item
<transport>::<address>
@end itemize

ここで、 <address> は、パス、サーバーとパス、または呼び出されている特定のリモートヘルパーによって認識される任意のURLのような文字列です。詳細については、 gitremote-helpers(7) を参照してください。

同じ名前のリモートリポジトリが多数あり、それらに異なる形式を使用する場合(あなたの使用するURLが機能するURLに書き換えられるように)、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                insteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:
@end example


"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、任意のコンテキストで、"git://git.host.xz/repo.git" に書き換えられます。

プッシュ専用のURLを書き換えたい場合は、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                pushInsteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/
@end example


"git://example.org/path/to/repo.git" のようなURLは、プッシュの場合は "ssh://example.org/path/to/repo.git" に書き換えられますが、プルは引き続き元のURLのままです。

@noindent

@chapheading REMOTES

@samp{<repository>} 引数として、URLの代わりに以下のいずれかの名前を使用できます:

@itemize 

@item
Git構成ファイル(configuration file)内のリモート(remote)として、 @samp{$GIT_DIR/config} または

@item
@samp{$GIT_DIR/remotes} ディレクトリ内のファイル または

@item
@samp{$GIT_DIR/branches} ディレクトリ内のファイル
@end itemize

これらはすべて、gitがデフォルトで使用するrefspecをそれぞれ含んでいるため、コマンドラインからrefspecを省略できます。

@noindent

@heading Named remote in configuration file

あなたは、 git-remote(1) を使うか、または git-config(1) を使うか、または @samp{$GIT_DIR/config} ファイルを手動で編集して、これ以前に構成したリモートの名前から選択できます。このリモートのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このリモートのrefspecがデフォルトで使用されます。構成ファイルのエントリは以下のようになります:

@example
        [remote "<name>"]
                url = <URL>
                pushurl = <pushurl>
                push = <refspec>
                fetch = <refspec>
@end example


The @samp{<pushurl>} is used for pushes only. It is optional and defaults to @samp{<URL>}. Pushing to a remote affects all defined pushurls or to all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.

@noindent

@heading Named file in $GIT_DIR/remotes

あなたは、 @samp{$GIT_DIR/remotes} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このファイルのrefspecがデフォルトとして使用されます。このファイルの形式は以下のとおりです:

@example
        URL: one of the above URL format
        Push: <refspec>
        Pull: <refspec>
@end example


@samp{Push:} 行は @samp{git push} で使用され、 @samp{Pull:} 行は @samp{git pull} と @samp{git fetch} で使用されます。追加のブランチマッピングのために、複数の @samp{Push:} および @samp{Pull:} 行を指定できます。

@noindent

@heading Named file in $GIT_DIR/branches

@samp{$GIT_DIR/branches} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。 このファイルの形式は以下のとおりです:

@example
        <URL>#<head>
@end example


@samp{<URL>} は必須です。 @samp{#<head>} はオプションです。

コマンドラインで指定しない場合、操作に応じて、gitは以下のrefspecのいずれかを使用します。 @samp{<branch>} は @samp{$GIT_DIR/branchs} 内のこのファイルの名前であり、 @samp{<head>`はデフォルトで `master} になります。

git fetch は以下を使用します:

@example
        refs/heads/<head>:refs/heads/<branch>
@end example


git push は以下を使用します:

@example
        HEAD:refs/heads/<head>
@end example


@noindent

@chapheading CONFIGURED REMOTE-TRACKING BRANCHES

あなたは、定期的かつ繰り返しフェッチすることで、同じリモートリポジトリとやり取りすることがよくあります。 このようなリモートリポジトリの進行状況を追跡するために、 @samp{git fetch} では @samp{remote.<repository>.fetch} 構成変数を構成できます。

通常、このような変数は以下のようになります:

@example
[remote "origin"]
        fetch = +refs/heads/*:refs/remotes/origin/*
@end example


この構成は、以下の2つの方法で使用されます:

@itemize 

@item
コマンドラインで取得するブランチやタグを指定せずに @samp{git fetch} を実行した場合、例えば @samp{git fetch origin} や @samp{git fetch} では @samp{remote.<repository>.fetch} の値が refspecs として使用され、取得する ref と更新するローカル ref を指定します。 上記の例では、@samp{origin} に存在するすべてのブランチ(つまり、値の左辺 @samp{refs/heads/*} にマッチするすべての ref)を取得し、対応するリモート追跡ブランチを @samp{refs/remotes/origin/*} 階層にあるものに更新します。

@item
フェッチするブランチやタグをコマンドラインで明示的に指定して、 @samp{git fetch} を実行した場合、 たとえば @samp{git fetch origin master} すると、コマンドラインで指定された<refspec>が何をフェッチするかを決定し(たとえば、この例の @samp{master`は、 `master:} の省略形で、 「 @samp{master' ブランチを取得しますが、どのリモート追跡ブランチを更新するかはコマンドラインから明示的に指示しません」を意味します)、サンプルコマンドは「 'master' ブランチのみ」をフェッチします。 `remote.<repository>.fetch} 値は、更新されるリモート追跡ブランチがある場合はそれを決定します。 このような使い方をすると、 @samp{remote.<repository>.fetch} 値は、「何をフェッチするか」を決定するのに効果がありません(つまり、コマンドラインにrefspecsがリストされている場合、 @samp{remote.<repository>.fetch} 値はrefspecsとして使用されません)。 これらは、マッピングとして機能することにより、フェッチされたrefがどこに保存されるかを決定するためにのみ使用されます。
@end itemize

後者の @samp{remote.<repository>.fetch} 値の使用は、コマンドラインで @samp{--refmap=<refspec>} パラメーターを指定することでオーバーライドできます。

@noindent

@chapheading PRUNING

Gitには、明示的に破棄されない限り、データを保持するというデフォルトの性質があります。 これは、ブランチを削除したリモートのブランチへのローカル参照を保持することにまで及びます。

蓄積したままにしておくと、これらの古い参照は、ブランチの撹拌が多い大きく忙しいリポジトリでパフォーマンスを低下させる可能性があります。 @samp{git branch -a --contains <commit>} のようなコマンドの出力を不必要に冗長にし、既知の参照の完全なセットで機能する他のすべてに影響を与えます。

これらのリモート追跡参照は、1回限りの利用で、以下のいずれかを使用して削除できます:

@example
# While fetching
$ git fetch --prune <name>

# Only prune, don't fetch
$ git remote prune <name>
@end example


あなたの通常の作業フローの一部として参照を刈り込むには、それを実行することを覚えておく必要はありません。設定で @samp{fetch.prune} をグローバルに設定するか、 @samp{remote.<name>.prune} をリモート毎に設定します。 git-config(1) を参照してください。

ここで、物事がトリッキーでより具体的になります。 刈り込み機能は実際にはブランチを気にせず、代わりにリモートのrefspecの関数として @samp{local <--> remote-references} を刈り込みます( @samp{<refspec>} および 上記 CONFIGURED REMOTE-TRACKING BRANCHES (@pxref{[CRTB]}) 参照)。

したがって、リモートの refspec に、 たとえば @samp{refs/tags/*:refs/tags/*} が含まれていたり、 手動でたとえば @samp{git fetch --prune <name> "refs/tags/*:refs/tags/*"} を実行したりすると、削除されるのは古いリモート追跡ブランチではなく、リモートには存在しないローカルタグが削除されます。

これはあなたが期待したものではない可能性があります。つまり、リモート @samp{<name>} を刈り込むだけでなく、そこからタグを明示的にフェッチするため、そこからフェッチするときに、すべてのローカルタグを削除します。 そのほとんどは、そもそも @samp{<name>} リモートからのものではない可能性があります。

したがって、これを @samp{refs/tags/*:refs/tags/*} のようなrefspec、または複数のリモートからの参照を同じローカル名前空間にマップする可能性のある他のrefspecで使用する場合は注意してください。

リモートのブランチとタグの両方を最新に保つことはよくあることなので、 @samp{--prune} と一緒に @samp{--prune-tags} オプションを指定することで、リモートに存在しないローカルタグを削除し、異なるタグを強制更新することができます。 タグの刈り込みは、設定ファイルの @samp{fetch.pruneTags} や @samp{remote.<name>.pruneTags} で有効にすることもできます。 git-config(1) を参照してください。

@samp{--prune-tags} オプションは、「リモート」のrefspecsで @samp{refs/tags/*:refs/tags/*} を宣言するのと同じです。 これは、一見奇妙な相互作用につながる可能性があります:

@example
# These both fetch tags
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin
@end example


@samp{--prune} またはその構成変数版なしで提供されたときにエラーにならない理由は、構成変数版の柔軟性と、コマンドラインフラグの機能と構成変数版の機能の間の 一対一 のマッピングを維持するためです。

たとえば、 @samp{~/.gitconfig} で @samp{fetch.pruneTags=true} を構成して、 @samp{--prune} なしで @samp{git fetch} を呼び出すたびにエラーが発生することなく、 @samp{git fetch --prune} が実行されるたびにタグが刈り込まれるようにします。

@samp{--prune-tags} によるタグの刈り込みは、名前付きリモートの代わりに URL を取得するときにも機能します。 これらはすべて、origin で見つからなかったタグを刈り込みます。

@example
$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch <url of origin> --prune --prune-tags
$ git fetch <url of origin> --prune 'refs/tags/*:refs/tags/*'
@end example


@noindent

@chapheading OUTPUT

@samp{git fetch} の出力は、使用する転送方法によって異なります。 このセクションでは、Gitプロトコル(ローカルまたはssh経由)およびスマートHTTPプロトコルを介してフェッチする場合の出力について説明します。

フェッチのステータスは表形式で出力され、各行は単一のrefのステータスを表します。 各行の形式は以下のとおりです:

@example
 <flag> <summary> <from> -> <to> [<reason>]
@end example


When using @samp{--porcelain}, the output format is intended to be machine-parseable. In contrast to the human-readable output formats it thus prints to standard output instead of standard error. Each line is of the form:

@example
<flag> <old-object-id> <new-object-id> <local-reference>
@end example


最新のrefのステータスは、 @samp{--verbose} オプションが使用されている場合にのみ表示されます。

構成変数fetch.outputで指定されたコンパクト出力モードでは、他の文字列に @samp{<from>} または @samp{<to>} 全体が見つかった場合、他の文字列内では @samp{*} に置き換えられます。 たとえば、 @samp{master -> origin/master} は @samp{master -> origin/*} になります。

@table @asis

@item  flag 
refのステータスを示す1文字:

@table @asis

@item  (space) 
フェッチされた早送りの成功

@item  @samp{+} 
強制更新の成功

@item  @samp{-} 
refの刈り込みの成功

@item  @samp{t} 
タグ更新の成功

@item  @samp{*} 
新しいrefのフェッチの成功

@item  @samp{!} 
拒否された、または更新に失敗したref

@item  @samp{=} 
最新であり、フェッチする必要がなかったref
@end table

@item  summary 
成功裏にフェッチされたrefの場合、概要には、refの古い値と新しい値が @samp{git log} の引数として使用するのに適した形式で表示されます(これはほとんどの場合 @samp{<old>..<new>} であり、強制的な非早送り(non-fast-forward)更新の場合は @samp{<old>...<new>} です)。

@item  from 
フェッチ元のリモートrefの名前から、その @samp{refs/<type>/`プレフィックスを差し引いたもの。 削除の場合、リモートrefの名前は `(none)} です。

@item  to 
更新されるローカルrefの名前から、その @samp{refs/<type>/} プレフィックスを差し引いたもの。

@item  reason 
人間が読める説明。 正常にフェッチされたrefの場合、説明は必要ありません。 失敗したrefについては、失敗の理由が説明されています。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
リモートトラッキングブランチを更新します:

@example
$ git fetch origin
@end example


The above command copies all branches from the remote @samp{refs/heads/} namespace and stores them to the local @samp{refs/remotes/origin/} namespace, unless the @samp{remote.<repository>.fetch} option is used to specify a non-default refspec.

@item
refspecsの明示的な使用:

@example
$ git fetch origin +seen:seen maint:tmp
@end example


これにより、リモートリポジトリからブランチ @samp{seen} と @samp{maint} を(それぞれ)フェッチすることにより、ローカルリポジトリでブランチ @samp{seen} と @samp{tmp} が更新(または必要に応じて作成)されます。

@samp{seen} ブランチは、接頭辞にプラス記号(@samp{+})が付いているため、早送りしなくても更新されます。 @samp{tmp} はそうしません。

@item
あなたのローカルリポジトリで「リモート」を構成せずに、リモートのブランチをちらっと見ます(peek):

@example
$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD
@end example


最初のコマンドは @samp{git://git.kernel.org/pub/scm/git/git.git} のリポジトリから @samp{maint} ブランチをフェッチし、2番目のコマンドは @samp{FETCH_HEAD} を使用して git-log(1) でブランチを調べます。 フェッチされたオブジェクトは、最終的にgitの組み込みの家政婦(housekeeping)によって削除されます(git-gc(1) を参照)。
@end itemize

@noindent

@chapheading SECURITY

フェッチおよびプッシュプロトコルは、共有することを意図していない一方の側が他方のリポジトリからデータを盗むのを防ぐようには設計されていません。悪意のある者から保護する必要のあるプライベートデータがある場合、最善のオプションはそれを別のリポジトリに保存することです。これは、クライアントとサーバーの両方に適用されます。特に、サーバー上の名前空間は、読み取りアクセス制御には効果的ではありません。リポジトリ全体への読み取りアクセスで信頼できるクライアントにのみ、名前空間への読み取りアクセスを許可する必要があります。

既知の攻撃ベクトル(attack vectors)は以下のとおりです:

@enumerate 

@item
被害者は、明示的に共有することを意図していないオブジェクトのIDをアドバタイズする "have" 行を送信しますが、他にもIDを持っている者が居る場合は、転送を最適化するために使用できます。攻撃者はオブジェクトID Xを選択して盗み、refをXに送信しますが、被害者はすでにXのコンテンツを持っているため、Xのコンテンツを送信する必要はありません。 これで、被害者は攻撃者がXを持っていると信じ、Xのコンテンツを後で攻撃者に送り返します。 (この攻撃は、クライアントがアクセスできる名前空間にXへのrefを作成してフェッチすることにより、クライアントがサーバー上で実行するのが最も簡単です。サーバーがクライアント上で実行する最も可能性の高い方法は、Xをパブリックブランチにマージし、ユーザーがこのブランチで追加の作業を行い、マージに気付かずにサーバーにプッシュバックすることを期待します。)

@item
#1 と同様に、攻撃者は盗むオブジェクトID Xを選択します。被害者は、攻撃者がすでに持っているオブジェクトYを送信し、攻撃者はYではなくXを持っていると誤って主張するため、被害者はYをXに対するデルタとして送信します。デルタは、攻撃者にYに類似したXの領域を明らかにします。
@end enumerate

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  fetch.recurseSubmodules 
このオプションは、 @samp{git fetch}(および @samp{git pull} の基になるフェッチ)が入力されたサブモジュールに再帰的にフェッチするかどうかを制御します。 このオプションは、ブール値または @samp{on-demand} のいずれかに設定できます。 ブール値に設定すると、フェッチとプルの動作が変更され、trueに設定されている場合は無条件にサブモジュールに再帰し、falseに設定されている場合はまったく再帰しません。 @samp{on-demand} に設定すると、フェッチとプルは、スーパープロジェクトがサブモジュールの参照を更新するコミットを取得したときにのみ、入力されたサブモジュールに再帰します。 デフォルトは @samp{on-demand} 、または @samp{submodule.recurse} が設定されている場合はその値です。

@item  fetch.fsckObjects 
trueに設定されている場合、git-fetch-packはフェッチされたすべてのオブジェクトをチェックします。 チェックされる内容については、 @samp{transfer.fsckObjects} を参照してください。 デフォルトはfalseです。 設定されていない場合は、代わりに @samp{transfer.fsckObjects} の値が使用されます。

@item  fetch.fsck.<msg-id> 
@samp{fsck.<msg-id>} のように機能しますが、 git-fsck(1) の代わりに git-fetch-pack(1) によって使用されます。 詳細については、 @samp{fsck.<msg-id>} のドキュメントを参照してください。

@item  fetch.fsck.skipList 
@samp{fsck.skipList} のように機能しますが、 git-fsck(1) の代わりに git-fetch-pack(1) によって使用されます。 詳細については、 @samp{fsck.skipList} のドキュメントを参照してください。

@item  fetch.unpackLimit 
Gitネイティブ転送を介してフェッチされるオブジェクトの数がこの制限を下回る場合、オブジェクトは緩いオブジェクト(loose object)ファイルに解凍されます。 ただし、受信したオブジェクトの数がこの制限以上の場合、受信したパックは、欠落しているデルタベースを追加した後、パックとして保存されます。 プッシュからパックを保存すると、特に低速のファイルシステムで、プッシュ操作をより速く完了することができます。 これが設定されていない場合は、代わりに @samp{transfer.unpackLimit} の値が使用されます。

@item  fetch.prune 
trueの場合、fetchはコマンドラインで @samp{--prune} オプションが指定されたかのように自動的に動作します。 @samp{remote.<name>.prune} および git-fetch(1) の「PRUNING」セクションも参照してください。

@item  fetch.pruneTags 
trueの場合、フェッチは、まだ設定されていない場合、刈り込み(pruning)時に @samp{refs/tags/*:refs/tags/*} refspecが提供されたかのように自動的に振る舞います。 これにより、このオプションと @samp{fetch.prune} の両方を設定して、アップストリーム参照への 1=1 マッピングを維持できます。 @samp{remote.<name>.pruneTags} および git-fetch(1) の「PRUNING」セクションも参照してください。

@item  fetch.output 
ref updateステータスの出力方法を制御します。 有効な値は @samp{full} と @samp{compact} です。 デフォルト値は @samp{full} です。 詳細については、 git-fetch(1) の「OUTPUT」セクションを参照してください。

@item  fetch.negotiationAlgorithm 
サーバーによって送信されるパックファイルの内容をネゴシエートするときに、ローカルリポジトリ内のコミットに関する情報がどのように送信されるかを制御します。 @samp{consecutive} に設定すると、連続したコミットをそれぞれチェックするアルゴリズムを使用します。 @samp{skipping} に設定すると、収束を高速化するためにコミットをスキップするアルゴリズムが使用されますが、必要以上の大きさのパックファイルが生成される可能性があります。 または、 @samp{noop} に設定して情報をまったく送信しないようにします。これにより、ほぼ確実に必要以上に大きなパックファイルが生成されますが、ネゴシエーション・ステップはスキップされます。 @samp{default} に設定すると、それ以前に行われた設定をオーバーライドしてデフォルトの振る舞いをします。 デフォルトは通常 @samp{consecutive} ですが、 @samp{feature.experimental} が true の場合、デフォルトは @samp{skipping} です。 値が不明な場合、 @samp{git fetch} でエラーが発生します。

git-fetch(1) の @samp{--negotiate-only} および @samp{--negotiation-tip} オプションも参照してください。

@item  fetch.showForcedUpdates 
falseに設定すると、 git-fetch(1) および git-pull(1) コマンドで @samp{--no-show-forced-updates} が有効になります。 デフォルトはtrueです。

@item  fetch.parallel 
一度に並行して実行されるフェッチ操作の最大数を指定します(サブモジュール、または、git-fetch(1) の @samp{--multiple} オプションが有効な場合はリモート)。

値0は、適切なデフォルトを提供します。 設定されていない場合、デフォルトで1になります。

サブモジュールの場合、この設定は、 @samp{submodule.fetchJobs} 構成設定を使用してオーバーライドできます。

@item  fetch.writeCommitGraph 
リモートからパックファイルをダウンロードするすべての @samp{git fetch} コマンドの後でcommit-graphを書き込むには、trueに設定します。 @samp{--split} オプションを使用すると、ほとんどの実行で、既存のcommit-graphファイルの上に非常に小さなcommit-graphファイルが作成されます。 場合によっては、これらのファイルがマージされ、書き込みに時間がかかることがあります。 更新されたcommit-graphファイルがあると、 @samp{git merge-base} や @samp{git push -f} や @samp{git log --graph} などの多くのGitコマンドのパフォーマンス改善に役立ちます。 デフォルトはfalseです。

@item  fetch.bundleURI 
This value stores a URI for downloading Git object data from a bundle URI before performing an incremental fetch from the origin Git server. This is similar to how the @samp{--bundle-uri} option behaves in git-clone(1). @samp{git clone --bundle-uri} will set the @samp{fetch.bundleURI} value if the supplied bundle URI contains a bundle list that is organized for incremental fetches.

If you modify this value and your repository has a @samp{fetch.bundleCreationToken} value, then remove that @samp{fetch.bundleCreationToken} value before fetching from the new bundle URI.

@item  fetch.bundleCreationToken 
When using @samp{fetch.bundleURI} to fetch incrementally from a bundle list that uses the "creationToken" heuristic, this config value stores the maximum @samp{creationToken} value of the downloaded bundles. This value is used to prevent downloading bundles in the future if the advertised @samp{creationToken} is not strictly larger than this value.

The creation token values are chosen by the provider serving the specific bundle URI. If you modify the URI at @samp{fetch.bundleURI}, then be sure to remove the value for the @samp{fetch.bundleCreationToken} value before fetching.
@end table

@noindent

@chapheading BUGS

@samp{--recurse-submodules} を使用すると、ローカルに存在するサブモジュール、たとえば @samp{$GIT_DIR/modules/} 内の新しいコミットのみを取得(fetch)できます。 アップストリームが新しいサブモジュールを追加した場合、そのサブモジュールは、たとえば @samp{git submodule update} によるクローンが作成されるまで取得(fetch)できません。 これは、将来の Git バージョンで修正される予定です。

@noindent

@chapheading SEE ALSO

git-pull(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-filter-branch,,,Top
@chapheading Name

git-filter-branch — ブランチを書き換えます

@noindent

@chapheading Synopsis

@display
git filter-branch [--setup <command>] [--subdirectory-filter <directory>]
        [--env-filter <command>] [--tree-filter <command>]
        [--index-filter <command>] [--parent-filter <command>]
        [--msg-filter <command>] [--commit-filter <command>]
        [--tag-name-filter <command>] [--prune-empty]
        [--original <namespace>] [-d <directory>] [-f | --force]
        [--state-branch <branch>] [--] [<rev-list options>…]
@end display


@noindent

@chapheading WARNING

@samp{git filter-branch} には、意図した履歴の書き換えに加えて明白でない変なものを生成することができる沢山の落とし穴があります(そして、酷い性能なので、そのような問題を調査する時間がほとんどありません)。 これらの安全性とパフォーマンスの問題は、下位互換性を持って修正することはできないため、 @samp{git filter-branch} 使用はお勧めしません。 @uref{https://github.com/newren/git-filter-repo/,git filter-repo} などの代わりの履歴フィルタリングツールを使用してください。 それでもあなたが @samp{git filter-branch} を使用する必要がある場合は、 @ref{SAFETY} (と @ref{PERFORMANCE})を注意深く読んで、filter-branchの地雷について学び、リストされている危険の多くを注意深く可能な限り回避してください。

@noindent

@chapheading DESCRIPTION

あなたは <rev-list options> に記載されているブランチを書き換え、各リビジョンにカスタムフィルターを適用することで、Gitリビジョン履歴を書き換えることができます。 これらのフィルターは、各ツリー(ファイルの削除やすべてのファイルに対するperlリライトの実行など)または各コミットに関する情報を変更できます。 それ以外の場合は、すべての情報(元のコミット時間またはマージ情報を含む)が保持されます。

このコマンドは、コマンドラインに記載されている「明らかな」ref(positive ref)のみを書き換えます(たとえば、@samp{a..b} を渡すと、 @samp{b} のみが書き換えられます)。 フィルタを指定しない場合、コミットは変更なしで再コミットされますが、通常は効果がありません。 それでも、これは将来、Gitのバグなどを補うのに役立つ可能性があるため、このような使用は許可されています。

@quotation

@strong{Note}

このコマンドは、 @samp{.git/info/grafts} ファイルと @samp{refs/replace/} 名前空間のrefを尊重します。 graftsまたは置換refが定義されている場合、このコマンドを実行するとそれらが永続的になります。
@end quotation

@quotation

@strong{Warning}

書き換えられた履歴は、すべてのオブジェクトに対して異なるオブジェクト名を持ち、元のブランチに収束しません。 書き直されたブランチを元のブランチの上に簡単にプッシュして配布することはできません。 あなたが完全な影響がわからない場合はこのコマンドを使用しないでください。 問題を解決するのに単純な単一のコミットで十分な場合は、とにかく使用しないでください。 (公開された履歴の書き換えの詳細については、 git-rebase(1) の「RECOVERING FROM UPSTREAM REBASE」セクションを参照してください。)
@end quotation

書き換えられたバージョンが正しいことを常に確認(verify)してください。書き換えられたものと異なる場合、元のrefは名前空間 @samp{refs /original/} に格納されます。

注意: この操作は入出力に非常にコストがかかるため、 @samp{-d} オプションを使用して一時ディレクトリをディスク外にリダイレクト、たとえば tmpfs にすることをお勧めします。 聞いた限りでは、スピードアップは非常に顕著です。

@noindent

@heading Filters

フィルタは、以下リストされた順序で適用されます。 <command> 引数は、(技術的な理由より、コミットフィルターを除き、)常に @samp{eval} コマンドを使用してシェルコンテキストで評価されます。 その前に @samp{$GIT_COMMIT} 環境変数は、書き換えられるコミットのIDを含むように設定されます。 また、GIT_AUTHOR_NAME と GIT_AUTHOR_EMAIL と GIT_AUTHOR_DATE と GIT_COMMITTER_NAME と GIT_COMMITTER_EMAIL と GIT_COMMITTER_DATE 環境変数は現在のコミットから取得されて環境変数にエクスポートされ、フィルター実行後に git-commit-tree(1) が作成する代替コミット(replacement commit)の作者とコミッターに影響を及ぼします。

<command> のいずれかの評価がゼロ以外のexitステータスを返す場合、操作全体が中止(abort)されます。

「元のsha1 ID」引数を取り、コミットがすでに書き換えられている場合は「書き換えられたsha1 ID」を出力し、それ以外の場合は「元のsha1 ID」を出力する「map」関数を使用できます。 コミットフィルターが複数のコミットを発行した場合、「map」関数は別々の行に複数のIDを返すことができます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--setup <command>} 
これは、コミットごとに実行される実際のフィルターではなく、ループの直前に1回だけセットアップされます。 したがって、このフィルターコマンドではコミット固有の変数はまだ定義されていません。 ここで定義された関数または変数は、技術的な理由により、コミットフィルターを除く次のフィルターステップで使用または変更できます。

@item  @samp{--subdirectory-filter <directory>} 
指定のサブディレクトリにアクセスする履歴のみを探してください。 結果には、そのディレクトリ(かつ、それのみ)がプロジェクトルートとして含まれます。 @ref{Remap to ancestor} を含んでいます。

@item  @samp{--env-filter <command>} 
このフィルターは、コミットが実行される環境変数を変更するだけでよい場合に使用できます。 具体的には、 作者/コミッター名/電子メールアドレス/時間 の環境変数を書き直したい場合です(詳細については、 git-commit-tree(1) 参照)。

@item  @samp{--tree-filter <command>} 
これは、ツリーとその内容を書き換えるためのフィルターです。 フィルターコマンドの引数は、チェックアウトされたツリーのルートに設定された作業ディレクトリを使用してシェルで評価されます。 その後、新しいツリーがそのまま使用されます(新しいファイルは自動的に追加され、消えたファイルは自動的に削除されます。 @samp{.gitignore} ファイルも他の無視ルールも「効果がありません！」)。

@item  @samp{--index-filter <command>} 
インデックスを書き換えるためのフィルタです。 これはツリーフィルターに似ていますが、ツリーをチェックアウトしないため、はるかに高速になります。 @samp{git rm --cached --ignore-unmatch ...} で頻繁に使用されます。以下の例を参照してください。 ぞっとするほど危険なケースについては、 git-update-index(1) を参照してください。

@item  @samp{--parent-filter <command>} 
これは、コミットの親リストを書き換えるためのフィルターです。 フィルターコマンドは stdinで親の文字列を受け取り、stdoutで新しい親の文字列を出力します。 親の文字列は、 git-commit-tree(1) で説明されている形式です。最初のコミットの場合は空、通常のコミットの場合は @samp{-p parent} 、 マージコミットの場合は @samp{-p parent1 -p parent2 -p parent3 ...} です。

@item  @samp{--msg-filter <command>} 
これは、コミットメッセージを書き換えるためのフィルターです。 フィルターへの引数は、標準入力の元のコミットメッセージを使用してシェルで評価されます。 フィルターの標準出力は、新しいコミットメッセージとして使用されます。

@item  @samp{--commit-filter <command>} 
これは、コミットを実行するためのフィルターです。 このフィルターを指定すると、 @samp{git commit-tree} コマンドの代わりに、フィルターコマンドは `<TREE_ID> [(-p <PARENT_COMMIT_ID>)…]｀ 形式の引数とstdinのログメッセージを使用して呼び出されます。 stdoutにはコミットIDを出力することが期待されています。

特別な拡張機能として、コミットフィルターは複数のコミットIDを発行する場合があります。 その場合、元のコミットの書き直された子は、それらすべてを親として持ちます。

あなたはこのフィルターで「map」便利関数やその他の便利関数を使用することもできます。 たとえば、 @samp{skip_commit "$@@"} を呼び出すと、現在のコミットが除外されます(ただし、変更は除外されます！ 必要に応じて、代わりに @samp{git rebase} を使用してください)。

単一の親でコミットを保持したくない場合は、 @samp{git commit-tree "$@@"} の代わりに @samp{git_commit_non_empty_tree "$@@"} を使用することもできます。これにより、ツリーは変更されることはありません。

@item  @samp{--tag-name-filter <command>} 
これは、タグ名を書き換えるためのフィルターです。 このフィルタが渡されると、書き換えられたオブジェクト(または書き換えられたオブジェクトを指すタグオブジェクト)を指す全てのタグrefに対してこのフィルタが呼び出されます。 元のタグ名は標準入力を介して渡され、新しいタグ名を標準出力に出力することが期待されます。

元のタグは削除されませんが、上書きできます。 @samp{--tag-name-filter cat} を使用して、タグを更新するだけです。 この場合、変換が失敗した場合に備えて、古いタグをバックアップしておくなど、十分な注意が必要です。

タグオブジェクトは、ほぼ適切な書き換えがサポートされています。 タグにメッセージが添付されている場合、同一のメッセージと作者とタイムスタンプを使用して新しいタグオブジェクトが作成されます。 タグに署名が付いている場合、署名は削除されます。 定義上、署名を保持することは不可能です。 これが「ほぼ」適切である理由は、理想的には、タグが変更されていない場合(同じオブジェクトを指している、同じ名前を持っているなど)、署名を保持する必要があるためです。しかし署名は保持されません。 署名は常に削除されます。 利用者は注意してください。 また、作者またはタイムスタンプ(またはそのことについてのタグメッセージ)を変更することもサポートされていません。 他のタグを指すタグは、基になるコミットを指すように書き直されます。

@item  @samp{--prune-empty} 
一部のフィルターは、ツリーをそのままにしておく空のコミットを生成します。 このオプションは、刈り込みされていない親が1個または0個しかない場合に、そのようなコミットを削除するようにgit-filter-branchに指示します。 したがって、マージコミットはそのまま残ります。 このオプションは @samp{--commit-filter} と一緒に使用することはできませんが、コミットフィルターで提供されている @samp{git_commit_non_empty_tree} 関数を使用することで同じ効果を得ることができます。

@item  @samp{--original <namespace>} 
このオプションを使用して、元のコミットが保存される名前空間を設定します。 デフォルト値は @samp{refs/original} です。

@item  @samp{-d <directory>} 
このオプションを使用して、書き換えに使用される一時ディレクトリへのパスを設定します。 ツリーフィルターを適用する場合、コマンドは一時的にツリーをあるディレクトリにチェックアウトする必要があります。これは、大規模なプロジェクトの場合、かなりのスペースを消費する可能性があります。 デフォルトでは、これは @samp{.git-rewrite/} ディレクトリで行われますが、このパラメータでその選択を上書きできます。

@item  @samp{-f} 
@itemx  @samp{--force} 
@samp{git filter-branch} は、強制されない限り、既存の一時ディレクトリでの開始を拒否するか、 @samp{refs/original/} で始まるrefがすでに存在する場合に拒否します。

@item  @samp{--state-branch <branch>} 
このオプションを使用すると、古いオブジェクトから新しいオブジェクトへのマッピングが、起動時に名前付きブランチから読み込まれ、終了時にそのブランチへの新しいコミットとして保存され、大きなツリーの増分が可能になります。 @samp{<branch>} が存在しない場合は、作成されます。

@item  <rev-list options>… 
@samp{git rev-list} の引数。 これらのオプションに含まれるすべての正のref(positive refs)は書き直されます。 @samp{--all} などのオプションを指定することもできますが、それらを @samp{git filter-branch} のオプションから分離するには @samp{--} を使用する必要があります。 @ref{Remap to ancestor} を含んでいます。
@end table

@noindent

@heading Remap to ancestor

git-rev-list(1) の引数、たとえばパスリミッター、を使用すると、書き換えられるリビジョンのセットを制限できます。 ただし、コマンドラインの正のrefは区別されます。このようなリミッターによって除外されることはありません。 この目的のために、代わりに、除外されなかった最も近い祖先を指すように書き直されます。

@noindent

@chapheading EXIT STATUS

成功すると、終了ステータスは「0」になります。 フィルタが書き換えるコミットを見つけられない場合、終了ステータスは「2」です。 その他のエラーの場合、終了ステータスはその他のゼロ以外の値である可能性があります。

@noindent

@chapheading EXAMPLES

すべてのコミットからファイル(機密情報または著作権違反を含む)を削除するとすると:

@example
git filter-branch --tree-filter 'rm filename' HEAD
@end example


しかしながら、ファイルがコミットのツリーに存在しない場合、単純な @samp{rm filename} はそのツリーとコミットで失敗します。 したがって、代わりにスクリプトとして @samp{rm -f filename} を使用することをお勧めします。

@samp{--index-filter} を @samp{git rm} と一緒に使用すると、非常に高速なバージョンが生成されます。 @samp{rm filename} を使用する場合と同様に、ファイルがコミットのツリーに存在しない場合、 @samp{git rm --cached filename} は失敗します。 ファイルを「完全に忘れる」場合は、ファイルがいつ履歴に入力されたかは関係ないため、 @samp{--ignore-unmatch} :

@example
git filter-branch --index-filter 'git rm --cached --ignore-unmatch filename' HEAD
@end example


これで、書き換えられた履歴がHEADに保存されます。

@samp{foodir/} がプロジェクトルートであるかのようにリポジトリを書き直し、他のすべての履歴を破棄するには:

@example
git filter-branch --subdirectory-filter foodir -- --all
@end example


したがって、たとえば、ライブラリサブディレクトリを独自のリポジトリに変えることができます。 注意: @samp{filter-branch} オプションをリビジョンオプションから分離する @samp{--} と、すべてのブランチとタグを書き換えるための @samp{--all} に注意してください。

(通常は他の履歴の先端にある)あるコミットを現在の初期コミットの親に設定し、他の履歴を現在の履歴の後ろに貼り付ける:

@example
git filter-branch --parent-filter 'sed "s/^\$/-p <graft-id>/"' HEAD
@end example


(親の文字列が空の場合 — それは最初のコミットを処理しているときに発生します — 親として graftcommit を追加します)。 注意: これは、単一のルートを持つ履歴を想定していることに注意してください(つまり、共通の祖先がないとマージは発生しません)。 そうでない場合は、以下を使用してください:

@example
git filter-branch --parent-filter \
        'test $GIT_COMMIT = <commit-id> && echo "-p <graft-id>" || cat' HEAD
@end example


または、さらに簡単に:

@example
git replace --graft $commit-id $graft-id
git filter-branch $graft-id..HEAD
@end example


「Darl McBribe」によって作成されたコミットを履歴から削除するには:

@example
git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_NAME" = "Darl McBribe" ];
        then
                skip_commit "$@@";
        else
                git commit-tree "$@@";
        fi' HEAD
@end example


関数 @samp{skip_commit} は以下のように定義されています:

@example
skip_commit()
@{
        shift;
        while [ -n "$1" ];
        do
                shift;
                map "$1";
                shift;
        done;
@}
@end example


シフトの魔法により、最初にツリーIDを破棄し、次に @samp{-p} パラメーターを破棄します。 注意: このハンドルは適切にマージされます！ DarlがP1とP2の間のマージをコミットした場合、それは適切に伝播され、マージのすべての子は、マージコミットではなく、親としてP1、P2を持つマージコミットになります。

@quotation

@strong{Note}

コミットによって導入され、後続のコミットによって元に戻され無い変更は、引き続き書き換えられたブランチに残ります。 あなたがコミットと一緒に「変更」を破棄したい場合、 あなたは @samp{git rebase} の対話モードを使用する必要があります。
@end quotation

@samp{--msg-filter} を使用してコミットログメッセージを書き換えることができます。 たとえば、 @samp{git svn} によって作成されたリポジトリ内の "git svn-id" 文字列は、以下の方法で削除できます:

@example
git filter-branch --msg-filter '
        sed -e "/^git-svn-id:/d"
'
@end example


たとえば、最後の10個のコミット(いずれもマージではない)に @samp{Acked-by} 行を追加する必要がある場合は、以下のコマンドを使用します:

@example
git filter-branch --msg-filter '
        cat &&
        echo "Acked-by: Bugs Bunny <bunny@@bugzilla.org>"
' HEAD~10..HEAD
@end example


@samp{--env-filter} オプションを使用して、コミッターや作者のIDを変更できます。 たとえば、user.emailの設定が間違っているためにコミットのIDが間違っていることがわかった場合は、プロジェクトを公開する前に、以下のように修正できます:

@example
git filter-branch --env-filter '
        if test "$GIT_AUTHOR_EMAIL" = "root@@localhost"
        then
                GIT_AUTHOR_EMAIL=john@@example.com
        fi
        if test "$GIT_COMMITTER_EMAIL" = "root@@localhost"
        then
                GIT_COMMITTER_EMAIL=john@@example.com
        fi
' -- --all
@end example


履歴の一部のみに書き換えを制限するには、新しいブランチ名に加えてリビジョン範囲を指定します。 新しいブランチ名は、この範囲の @samp{git rev-list} が出力する最上位のリビジョンを指します。

以下の履歴について考えてみましょう:

@example
     D--E--F--G--H
    /     /
A--B-----C
@end example


コミット D,E,F,G,H だけを書き換えて、 A,B,C はそのままにするには、以下のようにします:

@example
git filter-branch ... C..H
@end example


コミット E,F,G,H を書き換えるには、以下のどちらかを使用します:

@example
git filter-branch ... C..H --not D
git filter-branch ... D..H --not C
@end example


ツリー全体をサブディレクトリに移動する、またはそこから削除するには:

@example
git filter-branch --index-filter \
        'git ls-files -s | sed "s-\t\"*-&newsubdir/-" |
                GIT_INDEX_FILE=$GIT_INDEX_FILE.new \
                        git update-index --index-info &&
         mv "$GIT_INDEX_FILE.new" "$GIT_INDEX_FILE"' HEAD
@end example


@noindent

@chapheading リポジトリ縮小チェックリスト

git-filter-branchは、ファイルのサブセットを取り除くために使用できます。通常は、 @samp{--index-filter} と @samp{--subdirectory-filter} を組み合わせて使用します。 人々は結果のリポジトリが元のリポジトリよりも小さいことを期待していますが、Gitは指示があるまでオブジェクトを失わないように努力するため、実際にリポジトリを小さくするにはさらにいくつかの手順が必要です。 まずは以下のことを確認してください:

@itemize 

@item
ブロブがその存続期間中に移動された場合、あなたはファイル名のすべての派生を本当に削除したことになります。 @samp{git log --name-only --follow --all -- filename} は、名前の変更を見つけるのに役立ちます。

@item
git-filter-branch を呼び出す際に @samp{--tag-name-filter cat -- --all} を使用すると、本当にすべての refs をフィルタリングすることができます。
@end itemize

次に、より小さなリポジトリを取得する2つの方法があります。 より安全な方法は、クローンを作成することです。これにより、あなたの元のファイルがそのまま保持されます。

@itemize 

@item
@samp{git clone file:///path/to/repo} でクローンを作成します。 クローンには削除されたオブジェクトはありません。 git-clone(1) を参照してください。 (注意: 普通のパス指定でクローンを作成すると、すべてがハードリンクされてしまうことに注意してください！)
@end itemize

あなたがなんらかの理由でマヂでクローンを作成したくない場合は、代わりに以下の点を(この順序で)確認してください。 これは非常に破壊的なアプローチであるため、「バックアップを作成」するか、クローン作成に戻ってください。いいですね？我々はちゃんと警告しましたよ。

@itemize 

@item
git-filter-branchによってバックアップされた元のrefを削除します。そのためには @samp{git for-each-ref --format="%(refname)" refs/original/ | xargs -n 1 git update-ref -d} とします。

@item
@samp{git reflog expire --expire=now --all} を使用してすべてのreflogを期限切れにします。

@item
ガベージコレクションでは、参照されていないすべてのオブジェクトを @samp{git gc --prune=now} で収集します(または、git-gcが @samp{--prune} の引数をサポートするほど新しいバージョンでない場合は、代わりに @samp{git repack -ad; git prune} を使用します)。
@end itemize

@noindent

@chapheading PERFORMANCE

git-filter-branch の性能は氷河の流れのように劇遅で、その設計上、後方互換性のある実装が高速になることはあり得ません:

@itemize 

@item
ファイルの編集では、git-filter-branchは設計上、元のリポジトリに存在していたすべてのコミットをチェックアウトします。 リポジトリに @samp{10^5}(10万)個のファイルと @samp{10^5}(10万)個のコミットがあり、それぞれのコミットで変更されるのが5個のファイルしか変更していない場合、git-filter-branchを使用すると、(最大)@samp{5*10^5}(50万)個のユニークなブロブしかないにもかかわらず、あなたは @samp{10^10}(百億)個の変更を行うハメになります。

@item
あなたがズルしようとして、コミットで変更されたファイルに対してのみgit-filter-branchが機能するようにしようとすると、2つのことが起こります。

@itemize 

@item
ユーザーが単にファイルの名前を変更しようとすると、削除の問題が発生します(存在しないファイルを削除しようとすると、何もしない(no-op)ように見えるためです。 ユーザーが提供する任意のシェルを介して名前の変更が行われる場合、ファイルの名前変更全体で削除を再マップするには、多少の手間がかかります)

@item
あなたが map-deletes-for-renames という奇策によって成功した場合でも、技術的に下位互換性に違反します。なぜなら、ユーザーはファイルの内容や名前だけに基づいてフィルタリングするのではなく、コミットのトポロジに依存する方法でファイルをフィルタリングできるからです(ただし、実際にこれが観察されたわけではありません)。
@end itemize

@item
あなたはファイルを編集する必要はないが、たとえば 一部の名前を変更または削除すると、各ファイルのチェックアウトを回避できます(つまり、 @samp{--index-filter} を使用できます)が、あなたのフィルターのシェルスニペットは引き続き渡されます。つまり、コミットごとに、これらのフィルターを実行できるgitリポジトリを準備する必要があります。 これは重要な設定です。

@item
さらに、git-filter-branchによって、コミットごとにいくつかの追加ファイルが作成または更新されます。 これらのいくつかは、git-filter-branchによって提供される便利な関数(map()など)をサポートするためのものであり、その他は内部状態を追跡するためのものです(ただし、ユーザーフィルターによってアクセスされる可能性もあります。 git-filter-branch の回帰(regression)テストはそうします)。 これは基本的に、ファイルシステムをgit-filter-branchとユーザー提供のフィルター間のIPCメカニズムとして使用することを意味します。 ディスクは遅いIPCメカニズムになりがちで、これらのファイルを書くことは、コミットするたびにぶつかる、別々のプロセス間の強制的な同期ポイントを効果的に表しています。

@item
ユーザー提供のシェルコマンドには、コマンドのパイプラインが含まれる可能性が高く、コミットごとに多くのプロセスが作成されます。 別のプロセスを作成して実行するのにかかる時間はOSによって大きく異なりますが、どのプラットフォームでも関数を呼び出すのに比べると非常に遅くなります。

@item
git-filter-branch自体はシェルで記述されているため、少し時間がかかります。 これは、下位互換性で修正できるパフォーマンスの問題の1つですが、git-filter-branchの設計に固有の上記の問題と比較すると、ツール自体の言語は比較的小さな問題です。

@itemize 

@item
補足: 残念ながら、人々はシェルで書かれた側面に固執し、パフォーマンスの問題を修正するためにgit-filter-branchを別の言語で書き直すことができるかどうかを定期的に尋ねる傾向があります。それは、設計に内在する大きな問題を無視することになるばかりか、期待するほどには役に立たないでしょう。 もし git-filter-branch 自体が shell でなかったら、便利な関数 (map(), skip_commit() など) と @samp{--setup} 引数はプログラムの最初に一度実行するだけでよくなり、代わりにすべてのユーザーフィルターで前置する必要がありました(つまりコミットごとに再実行されることになります)。
@end itemize
@end itemize

@uref{https://github.com/newren/git-filter-repo/,git filter-repo} ツールは、git-filter-branchの代替手段で、これらのパフォーマンスの問題や安全性の問題(後述)の影響を受けません。 git-filter-branchに依存する既存のツールを使用している場合、 @samp{git filter-repo} は @uref{https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely,filter-lamely} も提供し、これは差し込み式の git-filter-branch の代替品です(いくつかの注意点があります)。 filter-lamelyは、git-filter-branchと同じ安全性の問題に悩まされていますが、少なくともパフォーマンスの問題を少し改善します。

@noindent

@chapheading SAFETY

git-filter-branch は、様々な方法で簡単にリポジトリを破損させたり、最初よりもひどい状態に陥らせたりするゴチャゴチャがたくさんあります:

@itemize 

@item
誰かが「動作してテストされたフィルター」のセットを持っている可能性があり、それを文書化するか、同僚に提供し、同僚は、同じコマンドが 動作/テスト されていない別のOSでそれらを実行したとします(git-filter-branchのmanページのいくつかの例もこの影響を受けます)。 BSDとGNUのユーザーランドの違いが本当に噛み付いてくる可能性があります(運が良ければ、エラーメッセージが表示されます)。 同様に、コマンドは要求されたフィルタリングを実行しないか、不要な変更を加えることで黙って破損させます。 不要な変更は、いくつかのコミットにのみ影響する可能性があるため、必ずしも明らかではありません。 (問題が明らかにならないということは、書き換えた履歴がしばらく使われていないと気づかない可能性が高く、気付いた時点で、もう一度書き換えるための正当な位置を探し出すのは本当に難しいのです。)

@item
スペースを含むファイル名は、シェルパイプラインに問題を引き起こすため、シェルスニペットによって誤って処理されることがよくあります。 誰もが @samp{find -print0} 、 @samp{xargs -0} 、@samp{git-ls-files -z} などに精通しているわけではありません。 これらに精通している人でさえ、フィルタリングを行っている人がプロジェクトに参加する前に、他の誰かが既にリポジトリ内のそのようなファイルの名前を変更済であったため、そのようなフラグは関係ないと考えるかもしれません。 そして、しばしば、スペースを使用した引数の処理に精通している人でさえ、うまくいかない可能性のあるすべてのことを考えるという考え方を持っていないという理由でそうしない場合があります。

@item
非ASCIIファイル名は、目的のディレクトリにあるにもかかわらず、黙って削除できます。 必要なパスのみを保持することは、多くの場合、 @samp{git ls-files | grep -v ^WANTED_DIR/ | xargs git rm} のようなパイプラインを使用して行われます。 ls-filesは必要な場合にのみファイル名を引用するため、ファイルの1つが正規表現と一致しなかったことに気付かない場合があります(少なくとも手遅れになるまでは)。 ええ、 core.quotePath を知っている人は(@samp{\t}, @samp{\n}, or @samp{"} などの他の特殊文字がなければ、)これを避けることができるし、 @samp{ls-files -z} を grep 以外のもので使う人はこれを避けることができますが、だからといって避けてくれるとは限りません。

@item
同様に、ファイルを移動すると、ASCII以外の文字または特殊文字を含むファイル名が、二重引用符を含む別のディレクトリに配置されることがあります。 (これは技術的には上記のクォートと同じ問題ですが、おそらく興味深いことに、この問題は別の形で現れる可能性がありますし、実際に問題として現れています。)

@item
実に簡単に古い履歴と新しい履歴を誤って混同してしまいます。それはどのツールでも起こりうるのですが、git-filter-branch その多くをやらかします。 運が良ければ、唯一の欠点は、リポジトリを縮小して古いものを削除する方法がわからないことにユーザーが不満を感じることです。 運が悪ければ、古い履歴と新しい履歴がマージされ、各コミットの複数の「コピー」が作成されます。その中には、不要なファイルや機密ファイルが含まれるものと、含まれないものがあります。 これが複数の異なる方法で発生します。

@itemize 

@item
履歴の部分的な書き換えのみを行うデフォルト(@samp{--all} はデフォルトではない。そして、これを示す例もほとんどない)。

@item
実行後の自動クリーンアップがないという事実

@item
@samp{--tag-name-filter} (タグの名前を変更するために使用される場合)は古いタグを削除せず、新しい名前で新しいタグを追加するだけであるという事実

@item
書き換えの影響や、古い履歴と新しい履歴の混在を避ける方法をユーザーに知らせるための教育的な情報がほとんど提供されていないことです。 たとえば、この man ページでは、すべてのブランチの変更を新しい履歴の上にリベースする((あるいは削除して再クローンする)必要があることをユーザーが理解する必要があることを述べていますが、これは考慮すべき複数の懸念事項のうちのひとつにすぎません。 詳しくは、 @samp{git filter-repo} マニュアルページの「DISCUSSION」セクションをご覧ください。
@end itemize

@item
以下の2つの問題のいずれかが原因で、注釈付きタグが誤って軽量タグに変換される可能性があります:

@itemize 

@item
誰かが履歴の書き換えを行い、混乱したことに気づき、 @samp{refs/original/} のバックアップから復元してから、git-filter-branchコマンドをやり直すことができます。 (@samp{refs/original/} のバックアップは実際のバックアップではありません。最初にタグを逆参照します。)

@item
<rev-list options> で @samp{--tags} または @samp{--all} を指定してgit-filter-branchを実行します。 注釈付きタグ(annotated tags)を注釈(annotated)として保持するには、 @samp{--tag-name-filter} を使用する必要があります(以前に失敗した書き換えで @samp{refs/original/} から復元してはいけません)。
@end itemize

@item
エンコーディング指定のコミットメッセージは、書き換えによって破損します。 git-filter-branchはエンコーディングを無視し、元のバイトを取得して、適切なエンコーディングを通知せずにコミットツリーにフィードします。 (これは、 @samp{--msg-filter} が使用されているかどうかに関係なく発生します。)

@item
コミットメッセージ(それが全てUTF-8であっても)はデフォルトでは更新されないため破損します — コミットメッセージ内の他のコミットハッシュへの参照は、もはや存在しないコミットを参照するようになります。

@item
ユーザーが削除すべき不純物を見つけるのを助ける機能はありません。つまり、不完全または部分的なクリーンアップが行われる可能性が高く、時には混乱を招き、人々は理解しようとして時間を浪費することになります。 (たとえば、ユーザーは大きなディレクトリや拡張子ではなく、削除すべき大きなファイルを探す傾向があり、いったんそうしてしまうと、後で新しいリポジトリを使って履歴を調べている人たちは、いくつかのファイルがあるのに他のファイルがないビルド成果物ディレクトリや、いくつかのファイルがないので機能しなかったはずの依存関係のキャッシュ((node_modules など)に気づくことになります)。

@item
@samp{--prune-empty} が指定されていない場合、フィルタリングプロセスにより、混乱を招く空のコミットが大量に発生する可能性があります

@item
@samp{--prune-empty} が指定されている場合、フィルタリングルールによって空になったコミットを刈り込みするだけでなく、フィルタリング操作の前から意図的に配置された空のコミットも刈り込みされます。

@item
@samp{--prune-empty} が指定されている場合、空のコミットが失われたり、とにかく全部残されることがあります(多少まれなバグですが、発生します…)

@item
些細なことですが、リポジトリ内のすべての名前と電子メールを更新するという目標を持っているユーザーは、著者とコミッターのみを更新し、タガー(tagger)を見逃す @samp{--env-filter} に誘導されるかもしれません。

@item
ユーザーが複数のタグを同じ名前にマップする @samp{--tag-name-filter} を提供した場合、警告やエラーは提供されません。 git-filter-branchは、文書化されていない事前定義された順序で各タグを上書きするだけで、最後に1つのタグのみが生成されます。 (git-filter-branch回帰テストは、この驚くべき振る舞いがを要求します。)
@end itemize

また、 @samp{git-filter-branch} のパフォーマンスが低いと、安全性の問題が発生することがよくあります:

@itemize 

@item
あなたが望むフィルタリングを行うための正しいシェルスニペットを考え出すことは、いくつかのファイルを削除するような些細な修正を行うのでない限り、時に困難なことです。 しかし、その正否は特殊な状況((ファイル名にスペースがある、非ASCIIのファイル名、おかしな著者名やメール、無効なタイムゾーン、grafts や replace オブジェクトがあるなど)によって異なるため、長い間待ってエラーになり、再起動しなければならないことがあります。 git-filter-branch の性能は非常に悪いので、このサイクルは苦痛であり、慎重に再チェックする時間が減ってしまいます (たとえ技術的に余裕があったとしても、書き直す人の忍耐力に影響を与えることは言うまでもありません)。 壊れたフィルターによるエラーは長い間表示されなかったり、出力の海に紛れたりするので、この問題はさらに深刻になります。 さらに悪いことに、フィルターが壊れていると、ただ黙って間違った書き直しをすることになりがちです。

@item
さらに言えば、ユーザーがようやく動作するコマンドを見つけたら、それを共有したいと思うのは自然なことです。 しかし、自分のリポジトリにはない特別なケースが他の人のリポジトリにはあることに気づいていないかもしれません。 そのため、異なるリポジトリを持つ他の人が同じコマンドを実行すると、上記のような問題に見舞われることになります。 あるいは、そのユーザーは、本当に特殊なケースを想定して吟味されたコマンドを実行しているだけなのですが、それを別のOSで実行すると、上に書いたように、うまくいかないのです。
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fmt-merge-msg,,,Top
@chapheading Name

git-fmt-merge-msg — git-fmt-merge-msg-マージコミットメッセージを生成します

@noindent

@chapheading Synopsis

@display
git fmt-merge-msg [-m <message>] [--into-name <branch>] [--log[=<n>] | --no-log]
git fmt-merge-msg [-m <message>] [--log[=<n>] | --no-log] -F <file>
@end display


@noindent

@chapheading DESCRIPTION

標準入力からマージされたオブジェクトのリストを取得し、マージコミットに使用される適切なコミットメッセージを生成します。通常は、 @samp{git merge} の @samp{<merge-message>} 引数として渡されます。

このコマンドは主に、 @samp{git merge} を自動的に呼び出すスクリプトによる内部使用を目的としています。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--log[=<n>]} 
ブランチ名に加えて、マージされている実際のコミットからの1行説明をログメッセージに入力します。各マージ親からの最大で <n> のコミットが使用されます(<n> が省略されている場合は20)。これは、 @samp{merge.log} 構成変数をオーバーライドします。

@item  @samp{--no-log} 
マージされる実際のコミットからの1行説明をリストしません。

@item  @samp{--[no-]summary} 
@samp{--log} や @samp{--no-log} の同義語。これは非推奨であり、将来削除される予定です。

@item  @samp{-m <message>} 
@itemx  @samp{--message <message>} 
ログメッセージの最初の行に、ブランチ名の代わりに <message> を使用します。 @samp{--log} で使用します。

@item  @samp{--into-name <branch>} 
マージ先の実際のブランチの名前ではなく、 ブランチ @samp{<branch>} にマージするかのようにマージ・メッセージを準備します。

@item  @samp{-F <file>} 
@itemx  @samp{--file <file>} 
標準入力の代わりに <file> からマージされたオブジェクトのリストを取得します。
@end table

@noindent

@chapheading CONFIGURATION

@table @asis

@item  merge.branchdesc 
ブランチ名に加えて、それらに関連付けられたブランチの説明テキストをログメッセージに入力します。デフォルトはfalseです。

@item  merge.log 
ブランチ名に加えて、マージされる実際のコミットからの最大「指定の数」の親コミットの1行説明をログメッセージに入力します。デフォルトはfalseで、trueは20の同義語です。

@item  merge.suppressDest 
統合ブランチの名前に一致するグロブをこの複数値の構成変数(multi-valued configuration variable)に追加することにより、これらの統合ブランチへのマージに対して計算されるデフォルトのマージメッセージは、タイトルから「into <branch name>」を省略します。

空の値を持つ要素を使用して、以前の構成エントリから蓄積されたグロブのリストをクリアできます。 @samp{merge.suppressDest} 変数が定義されていない場合、下位互換性のためにデフォルト値の @samp{master} が使用されます。

@item  merge.summary 
@samp{merge.log} の同義語。これは非推奨であり、将来削除される予定です。
@end table

@noindent

@chapheading EXAMPLES

@example
$ git fetch origin master
$ git fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD
@end example


「origin」リモートからの「master」ブランチのマージを説明するログメッセージを出力します。

@noindent

@chapheading SEE ALSO

git-merge(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-for-each-ref,,,Top
@chapheading Name

git-for-each-ref — 各refに関する情報を出力します

@noindent

@chapheading Synopsis

@display
git for-each-ref [--count=<count>] [--shell|--perl|--python|--tcl]
                   [(--sort=<key>)…] [--format=<format>]
                   [ --stdin | <pattern>… ]
                   [--points-at=<object>]
                   [--merged[=<object>]] [--no-merged[=<object>]]
                   [--contains[=<object>]] [--no-contains[=<object>]]
@end display


@noindent

@chapheading DESCRIPTION

@samp{<pattern>} に一致するすべてのrefを繰り返し、指定された @samp{<key>} の組に従って並べ替えた後、指定の @samp{<format>} に従って表示します。 @samp{<count>} が指定されている場合は、その数のrefを表示した後で停止します。 @samp{<format>} のプレースホルダで差し込みされる値は、オプションで、指定のホストプログラム言語の文字列リテラルとなるようクォートでき、そのホストプログラム言語で直接評価できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  <pattern>… 
1つ以上のパターンが指定されている場合、少なくとも1つのパターンに一致する参照のみが表示されます。fnmatch(3) を使用するか、文字通り(lietrally)に書くかです。文字通りに書いた場合場合、完全に一致するか、最初からスラッシュ(@samp{/})まで一致するかです。

@item  @samp{--stdin} 
If @samp{--stdin} is supplied, then the list of patterns is read from standard input instead of from the argument list.

@item  @samp{--count=<count>} 
デフォルトでは、コマンドは @samp{<pattern>} に一致するすべてのrefを表示します。このオプションは、指定の数のrefを表示した後に停止します。

@item  @samp{--sort=<key>} 
並べ替えるフィールド名。 プレフィックス @samp{-`を使用して、値の降順で並べ替えます。 並べ替えるフィールド名を指定しない場合 `refname} が使用されます。 @samp{--sort=<key>} オプションは複数回使用できます。その場合、最後のキーが主キー(primary key)になります。

@item  @samp{--format=<format>} 
表示されているrefとそれが指すオブジェクトを @samp{%(fieldname)} によってを差し込みする書式文字列。 @samp{fieldname} の前にアスタリスク(@samp{*})が付いていて、refがタグオブジェクトを指している場合は、(タグオブジェクトのフィールドではなく)タグオブジェクトが参照するオブジェクトのフィールドの値を使用します。このオプションを指定しない場合、 @samp{<format>} はデフォルトで @samp{%(objectname) SPC %(objecttype) TAB %(refname)} です。また @samp{%%} は @samp{%} を差し込み、 @samp{%xx} (@samp{xx} は16進数)は16進コード @samp{xx} の文字を差し込みます。 たとえば、@samp{%00} は @samp{\0} (NUL) を、 @samp{%09} は @samp{\t} (TAB) を、 @samp{%0a} は @samp{\n} (LF) を、それぞれ差し込みます。

@item  @samp{--color[=<when>]} 
@samp{--format} オプションで指定された色を尊重します。 @samp{<when>} フィールドは @samp{always} または @samp{never} または @samp{auto} のいずれかでなければなりません(@samp{<when>} がない場合は、 @samp{always} が指定されたかのように動作します)。

@item  @samp{--shell} 
@itemx  @samp{--perl} 
@itemx  @samp{--python} 
@itemx  @samp{--tcl} 
指定した場合、 @samp{%(fieldname)} プレースホルダーを置き換える文字列は、指定のホストプログラム言語に適した文字列リテラルとしてクォートします。これは、直接「評価」(eval)できるスクリプトレットを作成することを目的としています。

@item  @samp{--points-at=<object>} 
指定のオブジェクトを指すrefのみをリストします。

@item  @samp{--merged[=<object>]} 
指定のコミット(指定されていない場合はHEAD)から先端に到達できるrefのみをリストします。

@item  @samp{--no-merged[=<object>]} 
指定のコミット(指定されていない場合はHEAD)から先端に到達できないrefのみをリストします。

@item  @samp{--contains[=<object>]} 
指定のコミット(指定されていない場合はHEAD)を含むrefのみをリストします。

@item  @samp{--no-contains[=<object>]} 
指定のコミット(指定されていない場合はHEAD)を含まないrefのみをリストします。

@item  @samp{--ignore-case} 
refの並べ替え(sort)とフィルタリングでは英大文字小文字を区別しません。

@item  @samp{--omit-empty} 
Do not print a newline after formatted refs where the format expands to the empty string.
@end table

@noindent

@chapheading FIELD NAMES

参照オブジェクトの構造化フィールドのさまざまな値を使用して、結果の出力に差し込みしたり、ソートキーとして使用したりできます。

すべてのオブジェクトで、以下の名前を使用できます:

@table @asis

@item  refname 
refの名前( $GIT_DIR/ の後の部分)。refのあいまいでない短い名前の場合は、 @samp{:short} を追加します。オプション core.warnAmbiguousRefs は、厳密な省略形モードを選択するために使用されます。 @samp{lstrip=<N>} (@samp{rstrip=<N>}) が追加された場合、refnameの前(後ろ)からスラッシュ(@samp{/})で区切られたパスの部分を`<N>` 個削除します(例: @samp{%(refname:lstrip=2)} は @samp{refs/tags/foo} を @samp{foo} に変換し、 @samp{%(refname:rstrip=2)} は @samp{refs/tags/foo} を @samp{refs} に変換します。 @samp{<N>} が負の数の場合、指定された端から必要な数のパスコンポーネントを削除して、 @samp{-<N>} パス部分を残します(たとえば、 @samp{%(refname:lstrip=-2)} は @samp{refs/tags/foo} を @samp{tags/foo} に変換し、 @samp{%(refname:rstrip=-1)} は @samp{refs/tags/foo} を @samp{refs} に変換します)。refに十分な数のパス部品がない場合、正の <N> でストリッピングすると結果は空の文字列になり、負の<N>でストリッピングすると完全なrefnameになります。どちらもエラーではありません。

@samp{strip} は @samp{lstrip} の同義語として使用できます。

@item  objecttype 
オブジェクトのタイプ( @samp{blob} 、@samp{tree} 、 @samp{commit} 、@samp{tag} )。

@item  objectsize 
オブジェクトのサイズ(@samp{git cat-file -s} がレポートするものと同じです)。 @samp{:disk} を追加して、オブジェクトがディスク上で占めるサイズをバイト単位で取得できます。以下の「CAVEATS」(注意事項)セクションのディスク上のサイズに関する注記を参照してください。

@item  objectname 
オブジェクト名(別名SHA-1)。オブジェクト名のあいまいでない省略形については、 @samp{:short} を追加してください。目的の長さのオブジェクト名の省略形については、 @samp{:short=<length>} を追加します。ここで、最小の長さは MINIMUM_ABBREV です。一意のオブジェクト名を確保するために、指定の長さを超える場合があります。

@item  deltabase 
デルタとして保存されている場合、これは指定されたオブジェクトのデルタベースのオブジェクト名に展開されます。それ以外の場合は、ヌルオブジェクト名(すべてゼロ)に展開されます。

@item  upstream 
表示されたrefから「上流」(upstream)と見なすことができるローカル参照の名前。 上記の @samp{refname} と同じように、 @samp{:short} や @samp{:lstrip} や @samp{:rstrip} を尊重します。さらに、 @samp{:track} は @samp{[ahead N, behind M]} を表示し、 @samp{:trackshort} は @samp{>} (ahead) または @samp{<} (behind) または "<>" (ahead and behind) または "=" (in sync) という簡潔なバージョンを表示します。 @samp{:track} は不明なアップストリーム参照が検出されるたびに @samp{[gone]} も出力します。 @samp{:track,nobracket} を追加すると角かっこ(@samp{[} と @samp{]} )無しで追跡情報を表示します（つまり、 @samp{ahead N, behind M} )。

リモート追跡ブランチの @samp{%(upstream)} と @samp{%(upstream:remotename)} と @samp{%(upstream:remoteref)`は、それぞれリモートの名前と追跡されたリモートrefの名前を参照します。つまり、 refspec `%(upstream:remoteref):%(upstream)} を使用して @samp{%(upstream:remotename)} からフェッチすることにより、リモートト追跡ブランチを明示的かつ個別に更新できます。

refに追跡情報が関連付けられていない場合、効果はありません。 @samp{nobracket} 以外のすべてのオプションは相互に排他的ですが、一緒に使用する場合は最後のオプションが選択されます。

@item  push 
表示されたrefの @samp{@@@{push@}} の場所を表すローカルrefの名前。 @samp{upstream} と同様に @samp{:short} ・ @samp{:lstrip} ・ @samp{:rstrip} ・ @samp{:track} ・ @samp{:trackshort} ・ @samp{:remotename} ・ @samp{:remoteref} オプションを尊重します。 @samp{@@@{push@}} refが設定されていない場合、空の文字列を生成します。

@item  HEAD 
HEADが現在のref (チェックアウトされたブランチ)と一致する場合は @samp{*} 、それ以外の場合は ' ' 。

@item  color 
出力色を変更します。 その後に @samp{:<colorname>} が続きます。色の名前は、 git-config(1) の「CONFIGURATION FILE」セクションの「Values」で説明されています。 たとえば、 @samp{%(color:bold red)} です。

@item  align 
コンテンツを %(align:…) から %(end) の間で左揃え、中央揃え、または右揃えにします。 @samp{align:} の後には、 @samp{width=<width>} と @samp{position=<position>} がコンマ(@samp{,})で区切られた任意の順序で続きます。ここで、 @samp{<position>} は left または right または middle のいずれかで、@samp{<position>} の デフォルトは left で @samp{<width>} のデフォルトは配置されたコンテンツの全長です。 簡潔にするために、 @samp{width=} および/または @samp{position=} プレフィックスを省略して、代わりに裸の <width> および <position> を使用することができます。 たとえば、 @samp{%(align:<width>,<position>)} です。 コンテンツの長さがwidthよりも大きい場合、位置合わせは実行されません。 @samp{--quote} とともに使用すると、 %(align:…) から %(end) の間のすべてがクォートされまれますが、ネストされている場合は、最上位レベルのみがクォートされます。

@item  if 
%(if) … %(then) … %(end) または %(if) … %(then) … %(else) … %(end) として使用されます。 %(if) の後に値または文字列リテラルを持つアトムがある場合は、 %(then) の後のすべてが出力されます。そうでない場合、 %(else) アトムが使用されている場合は、 %(else) の後のすべてが出力されます。 %(then) の前の文字列を評価するときはスペースを無視します。これは、 @samp{*} または ` ` のいずれかを出力する %(HEAD) アトムを使用し、 HEAD ref にのみ if 条件を適用する場合に役立ちます。 @samp{:equals=<string>} または @samp{:notequals=<string>} を追加して、 %(if:…) アトムと %(then) アトムの間の値を指定された文字列と比較します。(訳注:つまり、 %(if) から %(then) の間がconditionである)

@item  symref 
与えられたシンボリックrefが参照するref。シンボリックrefでない場合、何も出力されません。上記の @samp{refname} と同じ方法で、 @samp{:short} と @samp{:lstrip} と @samp{:rstrip} オプションを尊重します。

@item  signature 
The GPG signature of a commit.

@item  signature:grade 
Show "G" for a good (valid) signature, "B" for a bad signature, "U" for a good signature with unknown validity, "X" for a good signature that has expired, "Y" for a good signature made by an expired key, "R" for a good signature made by a revoked key, "E" if the signature cannot be checked (e.g. missing key) and "N" for no signature.

@item  signature:signer 
The signer of the GPG signature of a commit.

@item  signature:key 
The key of the GPG signature of a commit.

@item  signature:fingerprint 
The fingerprint of the GPG signature of a commit.

@item  signature:primarykeyfingerprint 
The primary key fingerprint of the GPG signature of a commit.

@item  signature:trustlevel 
The trust level of the GPG signature of a commit. Possible outputs are @samp{ultimate}, @samp{fully}, @samp{marginal}, @samp{never} and @samp{undefined}.

@item  worktreepath 
リンクされたワークツリー(linked worktree)でチェックアウトされている場合、refがチェックアウトされているワークツリーへの絶対パス。それ以外の場合は空文字列です。

@item  ahead-behind:<committish> 
Two integers, separated by a space, demonstrating the number of commits ahead and behind, respectively, when comparing the output ref to the @samp{<committish>} specified in the format.
@end table

上記に加えて、commitとtagオブジェクトの場合、ヘッダーフィールド名(@samp{tree} と @samp{parent} と @samp{object} と @samp{type} と @samp{tag})を使用して、ヘッダーフィールドの値を指定できます。 フィールド @samp{tree} と @samp{parent} は、 @samp{objectname} と同じように、修飾子 @samp{:short} や @samp{:short=<length>} とともに使用することもできます。

commitオブジェクトとtagオブジェクトの場合、特別な @samp{creatordate} フィールドと @samp{creator} フィールドは、オブジェクトタイプに応じて、 @samp{committer} または @samp{tagger} フィールドの適切な日付またはname-email-dateタプルに対応します。これらは、注釈付きタグと軽量タグの組み合わせでの作業を目的としています。

name-email-dateタプルを値として持つフィールド(@samp{author} と @samp{committer} と @samp{tagger})には、名前付きコンポーネントを抽出するために @samp{name} と @samp{email} と @samp{date} の接尾辞を付けることができます。メールフィールド(@samp{authoremail} と @samp{committeremail} と @samp{taggeremail})の場合、 @samp{:trim} を追加すると山かっこ(@samp{<}, @samp{>})なしでメールを取得し、 @samp{:localpart} を追加すると電子メールアドレスをトリミングして @samp{@@} 記号の前の部分を取得できます。

オブジェクトの生データは @samp{raw} です。

@table @asis

@item  raw:size 
オブジェクトの生データサイズ。
@end table

注意: @samp{--format=%(raw)} は、 @samp{--python} や @samp{--shell} や @samp{--tcl} と一緒に使用できないことに注意してください。これらのプログラム言語は、文字列変数タイプで任意のバイナリデータをサポートしていない可能性があるためです。

コミットまたはタグオブジェクト内のメッセージは @samp{contents} であり、そこから @samp{contents:<part>} を使用して以下によりさまざまな部分を抽出できます:

@table @asis

@item  contents:size 
コミットメッセージまたはタグメッセージのバイト単位のサイズ。

@item  contents:subject 
メッセージの最初の段落(通常は1行)は、コミットまたはタグメッセージの「件名」(subject)と見なされます。 @samp{contents：subject} の代わりに、フィールド @samp{subject} を使用して同じ結果を取得することもできます。 @samp{subject} に追加できる @samp{:sanitize} は、件名行をファイル名に適した形にします。

@item  contents:body 
コミットメッセージまたはタグメッセージの「件名」に続く残りの部分。

@item  contents:signature 
タグのオプションのGPG署名。

@item  contents:lines=N 
メッセージの最初の N行。
@end table

加えて、 git-interpret-trailers(1) によって解釈されるトレーラーは、 @samp{trailers[:options]} として(または履歴エイリアス @samp{contents:trailers[:options]} を使用して)取得されます。有効な [:option] 値については、 git-log(1) の @samp{trailers} セクションを参照してください。

並べ替えの目的のため、数値のフィールドは数値順で並べ替えられます(@samp{objectsize} 、@samp{authordate} 、 @samp{committerdate} 、@samp{creatordate} 、 @samp{taggerdate})。他のすべてのフィールドは、バイト値の順序で並べ替えられます。

バージョンで並べ替えるオプションもあります。これは、フィールド名 @samp{version:refname} またはそのエイリアス @samp{v:refname} を使用して行うことができます。

いずれの場合も、refによって参照されるオブジェクトに適用できないフィールドを参照するフィールド名はエラーを引き起こしません。代わりに空文字列を返します。

日付タイプフィールドの特殊なケースとして、 @samp{:} の後に日付フォーマット名を追加して日付のフォーマットを指定できます(git-rev-list(1) の @samp{--date} オプションのが取る値を参照してください)。

%(align) や %(if) などの一部のアトムには、常に対応する %(end) が必要です。 %(align) や %(if) などの一部のアトムを「開始アトム」(opening atoms)と呼び、 %($open) と表記することもあります。

スクリプト言語固有のクォートが有効な場合、トップレベルの開始アトムとそれに対応する %(end) の間のすべてが、トップレベル開始アトムのセマンティクスに従って評価され、そのトップレベルからの結果のみがクォートされます。

@noindent

@chapheading EXAMPLES

フォーマットされたテキストを直接生成する例。 直近の3つのタグ付きコミットを表示します:

@example
#!/bin/sh

git for-each-ref --count=3 --sort='-*authordate' \
--format='From: %(*authorname) %(*authoremail)
Subject: %(*subject)
Date: %(*authordate)
Ref: %(*refname)

%(*body)
' 'refs/tags'
@end example


出力でのshell evalの使用を示す簡単な例で、@samp{--shell} の使用を示しています。 すべてのheadのプレフィックスを一覧表示します:

@example
#!/bin/sh

git for-each-ref --shell --format="ref=%(refname)" refs/heads | \
while read entry
do
        eval "$entry"
        echo `dirname $ref`
done
@end example


タグに関するもう少し手の込んだレポートで、スクリプト全体のフォーマットである可能性があることを示しています:

@example
#!/bin/sh

fmt='
        r=%(refname)
        t=%(*objecttype)
        T=$@{r#refs/tags/@}

        o=%(*objectname)
        n=%(*authorname)
        e=%(*authoremail)
        s=%(*subject)
        d=%(*authordate)
        b=%(*body)

        kind=Tag
        if test "z$t" = z
        then
                # could be a lightweight tag
                t=%(objecttype)
                kind="Lightweight tag"
                o=%(objectname)
                n=%(authorname)
                e=%(authoremail)
                s=%(subject)
                d=%(authordate)
                b=%(body)
        fi
        echo "$kind $T points at a $t object $o"
        if test "z$t" = zcommit
        then
                echo "The commit was authored by $n $e
at $d, and titled

    $s

Its message reads as:
"
                echo "$b" | sed -e "s/^/    /"
                echo
        fi
'

eval=`git for-each-ref --shell --format="$fmt" \
        --sort='*objecttype' \
        --sort=-taggerdate \
        refs/tags`
eval "$eval"
@end example


%(if) … %(then) … %(else) … %(end) の使用法を示す例。 これにより、現在のブランチの前にアスタリスクが付けられます。

@example
git for-each-ref --format="%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)" refs/heads/
@end example


%(if) … %(then) … %(end) の使用法を示す例。 存在する場合、これは作者名を出力します。

@example
git for-each-ref --format="%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)"
@end example


@noindent

@chapheading CAVEATS

注意: ディスク上のオブジェクトのサイズは正確に報告されますが、どのrefまたはオブジェクトがディスクの使用に関与しているかについて結論を出す際には注意が必要です。パックされた非デルタオブジェクトのサイズは、それに対してデルタするオブジェクトのサイズよりもはるかに大きい場合がありますが、ベースとデルタのオブジェクトの選択は任意であり、再パック中に変更される可能性があります。

注意: オブジェクトの複数のコピーがオブジェクトデータベースに存在する可能性があることにも注意してください。この場合、どのコピーのサイズまたはデルタベースが報告されるかは未定義です。

@noindent

@chapheading NOTES

複数の @samp{--contains} フィルターと @samp{--no-contains} フィルターを組み合わせる場合、少なくとも1つの @samp{--contains} コミットを含み、 @samp{--no-contains} コミットを含まない参照のみが表示されます。

複数の @samp{--merged} フィルターと @samp{--no-merged} フィルターを組み合わせると、少なくとも1つの @samp{--merged} コミットから到達可能で、 @samp{--no-merged} コミットのいずれからも到達できない参照のみが表示されます。

@noindent

@chapheading SEE ALSO

git-show-ref(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-for-each-repo,,,Top
@chapheading Name

git-for-each-repo — リポジトリのリストでGitコマンドを実行します

@noindent

@chapheading Synopsis

@display
git for-each-repo --config=<config> [--] <arguments>
@end display


@noindent

@chapheading DESCRIPTION

リポジトリのリストでGitコマンドを実行します。既知のオプションや @samp{--} の、後ろの引数は、Gitサブプロセスの引数として使用されます。

！！このコマンドは実験的なものです！！動作が変わる可能性があります！！

たとえば、以下を使用して、 @samp{maintenance.repo} 構成変数に格納されているリポジトリのリストのそれぞれに対して maintenance を実行できます。

@example
git for-each-repo --config=maintenance.repo maintenance run
@end example


これにより、複数値の構成変数である @samp{maintenance.repo} の各値である @samp{<repo>} ごとに @samp{git -C <repo> maintenance run} が実行されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--config=<config>} 
指定された構成変数を、絶対パス名を格納する複数値リストとして使用します。そのパスのリストを繰り返して(iterate)、指定された引数を実行します。

これらの構成値は、利用可能な場合、システム、グローバル、およびローカルのGit構成からロードされます。 @samp{git for-each-repo} がGitリポジトリではないディレクトリで実行される場合、システムとグローバル設定のみが使用されます。
@end table

@noindent

@chapheading SUBPROCESS BEHAVIOR

@samp{git -C <repo> <arguments>} サブプロセスがゼロ以外の終了コードを返す場合、 @samp{git for-each-repo} プロセスはそれ以上のサブプロセスを実行せずにその終了コードを返します。

各 @samp{git -C <repo> <arguments>} サブプロセスは、標準のファイルデスクリプタ @samp{stdin} と @samp{stdout} と @samp{stderr} を継承します。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-format-patch,,,Top
@chapheading Name

git-format-patch — 電子メール送信用のパッチを準備します

@noindent

@chapheading Synopsis

@display
git format-patch [-k] [(-o|--output-directory) <dir> | --stdout]
                   [--no-thread | --thread[=<style>]]
                   [(--attach|--inline)[=<boundary>] | --no-attach]
                   [-s | --signoff]
                   [--signature=<signature> | --no-signature]
                   [--signature-file=<file>]
                   [-n | --numbered | -N | --no-numbered]
                   [--start-number <n>] [--numbered-files]
                   [--in-reply-to=<message id>] [--suffix=.<sfx>]
                   [--ignore-if-in-upstream] [--always]
                   [--cover-from-description=<mode>]
                   [--rfc] [--subject-prefix=<subject prefix>]
                   [(--reroll-count|-v) <n>]
                   [--to=<email>] [--cc=<email>]
                   [--[no-]cover-letter] [--quiet]
                   [--[no-]encode-email-headers]
                   [--no-notes | --notes[=<ref>]]
                   [--interdiff=<previous>]
                   [--range-diff=<previous> [--creation-factor=<percent>]]
                   [--filename-max-length=<n>]
                   [--progress]
                   [<common diff options>]
                   [ <since> | <revision range> ]
@end display


@noindent

@chapheading DESCRIPTION

UNIXメールボックスに似た形式で、コミットごとに1つの「メッセージ」に「パッチ」を含む各非マージコミットを準備します。このコマンドの出力は、電子メールの送信や「git am」での使用に便利です。

コマンドによって生成される「メッセージ」は、以下の3つの部分で構成されます:

@itemize 

@item
短いメタデータヘッダー。「file(1)」などのプログラムが、ファイルがこのコマンドからの出力であることを認識できるように「From <commit>」と、固定の日付スタンプ「Mon Sep 17 00:00:00 2001」で始まり、 作者ID(author identity)や作者の日付(author date)や変更のタイトル(title of the change)(コミットログメッセージの最初の段落から取得)が記入されたフィールドがあります。

@item
コミットログメッセージの2番目以降の段落。

@item
コミットとその親の間の @samp{diff -p --stat} 出力(linkgit: git-diff[1] 参照)である「パッチ」。
@end itemize

ログメッセージとパッチは、3本のダッシュ(@samp{---})で区切られています。

操作するコミットを指定する方法は2つあります。

@enumerate 

@item
単一のコミット<since>は、現在のブランチの先端につながるコミットで、<since>が出力される履歴にないことを指定します。

@item
一般的な <revision range> 評価式 (gitrevisions(7) の「SPECIFYING REVISIONS」セクション参照)は、指定された範囲でのコミットを意味します。
@end enumerate

単一の <commit> の場合、最初のルールが優先されます。2番目のルールを適用する、つまり、履歴の開始から <commit> までのすべてをフォーマットするには、 @samp{--root} オプションを使用します: @samp{git format-patch --root <commit>} とします。あなたが <commit> 自体のみをフォーマットしたい場合は、 @samp{git format-patch -1 <commit>} を使用して行うことができます。

デフォルトでは、各出力ファイルには1から順番に番号が付けられ、ファイル名としてコミットメッセージの最初の行(パス名の安全のためにもみもみ(massage)れます)が使用されます。 @samp{--numbered-files} オプションを使用すると、出力ファイル名は数字のみになり、コミットの最初の行は追加されません。 `--stdout`オプションが指定されていない限り、出力ファイル名が標準出力に出力されます。

@samp{-o} を指定すると、出力ファイルは <dir> に作成されます。それ以外の場合は、現在の作業ディレクトリに作成されます。デフォルトのパスは、@samp{format.outputDirectory} 構成オプションで設定できます。 @samp{-o} オプションは @samp{format.outputDirectory} よりも優先されます。 @samp{format.outputDirectory} が他の場所を指している場合でも、パッチを現在の作業ディレクトリに保存したいときは、@samp{-o.} を使用します。すべてのディレクトリコンポーネントが作成されます。

デフォルトでは、単一のパッチの件名は "[PATCH] " で、その後に、コミットメッセージから最初の空白行までの行が連結されます (git-commit(1)の DISCUSSION セクション参照)。

複数のパッチが出力される場合、件名のプレフィックスは "[PATCH n/m] " になります。 1つのパッチに 1/1 を強制的に追加するには @samp{-n} を使用します。件名からパッチ番号を省略するには @samp{-N} を使用します。

If given @samp{--thread}, @samp{git-format-patch} will generate @samp{In-Reply-To} and @samp{References} headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a @samp{Message-ID} header to reference.

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
@itemx  @samp{--no-stat} 
diffstatsなしでプレーンパッチを生成します。

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
名前の変更(renames)を検知する。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@table @asis

@item  @samp{-<n>} 
最上位から見て <n> 個目のコミットからパッチを準備します。

@item  @samp{-o <dir>} 
@itemx  @samp{--output-directory <dir>} 
現在の作業ディレクトリの代わりに、 <dir> を使用して結果のファイルを保存します。

@item  @samp{-n} 
@itemx  @samp{--numbered} 
単一のパッチでも、 @samp{[PATCH n/m]} 形式で名前を出力します。

@item  @samp{-N} 
@itemx  @samp{--no-numbered} 
@samp{[PATCH]} 形式 で名前を出力します。

@item  @samp{--start-number <n>} 
パッチの番号付けを1ではなく<n>から開始します。

@item  @samp{--numbered-files} 
出力ファイル名群は、コミットのデフォルトの最初の行が追加されていない単純な一連番号になります。

@item  @samp{-k} 
@itemx  @samp{--keep-subject} 
コミットログメッセージの最初の行から @samp{[PATCH]} を削除/追加 しないでください。

@item  @samp{-s} 
@itemx  @samp{--signoff} 
あなた自身ののコミッターIDを使用して、コミットメッセージに @samp{Signed-off-by} トレーラーを追加します。詳細については、 git-commit(1)の signoff オフオプションを参照してください。

@item  @samp{--stdout} 
コミットごとにファイルを作成するのではなく、すべてのコミットをmbox形式で標準出力に出力します。

@item  @samp{--attach[=<boundary>]} 
マルチパート/混合の添付(multipart/mixed attachment)を作成します。最初の部分はコミットメッセージで、2番目の部分はパッチ自体です。 @samp{Content-Disposition: attachment} を使用します。

@item  @samp{--no-attach} 
添付ファイルの作成を無効にして、構成設定を上書きします。

@item  @samp{--inline[=<boundary>]} 
マルチパート/混合の添付(multipart/mixed attachment)を作成します。最初の部分はコミットメッセージで、2番目の部分はパッチ自体です。 @samp{Content-Disposition: inline} を使用します。

@item  @samp{--thread[=<style>]} 
@itemx  @samp{--no-thread} 
Controls addition of @samp{In-Reply-To} and @samp{References} headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the @samp{Message-ID} header to reference.

オプションの <style> 引数は、 @samp{shallow} または @samp{deep} のいずれかです。 「shallow」スレッドは、すべてのメールをシリーズの先頭に返信します。先頭は、送付状と @samp{--in-reply-to} と最初のパッチメールからこの順序で選択されます。「deep」スレッドは、すべてのメールを前のメールへの返信にします。

The default is @samp{--no-thread}, unless the @samp{format.thread} configuration is set. @samp{--thread} without an argument is equivalent to @samp{--thread=shallow}.

@samp{git send-email} のデフォルトが、電子メール自体をスレッド化することであることに注意してください。 @samp{git format-patch} でスレッド化を処理する場合は、 @samp{git send-email} でスレッド化が無効になっていることを確認する必要があります。

@item  @samp{--in-reply-to=<message id>} 
最初のメール(または @samp{--no-thread} を含むすべてのメール)を、指定の <message id> への応答として表示します。これにより、スレッドが壊れて新しいパッチシリーズが提供されるのを防ぎます。

@item  @samp{--ignore-if-in-upstream} 
@samp{<until>..<since>} のコミットに一致するパッチを含めないでください。 これにより、<since>から到達可能で、<until>からは到達できないすべてのパッチが調べられ、生成されているパッチと比較されます。一致するパッチはすべて無視されます。

@item  @samp{--always} 
デフォルトでは省略されている、変更を導入しないコミットのパッチを含めます。

@item  @samp{--cover-from-description=<mode>} 
ブランチの説明を使用して、送付状のどの部分に自動的に入力されるかを制御します。

@samp{<mode>} が @samp{message} または @samp{default} の場合、送付状の件名にプレースホルダーテキストが入力されます。送付状の本文には、ブランチの説明が入力されます。 これは、構成またはコマンドラインオプションが指定されていない場合のデフォルトモードです。

@samp{<mode>} が @samp{subject} の場合、ブランチの説明の最初の段落を送付状の件名に入力します。ブランチの説明の残りの部分は、送付状の本文に入力されます。

@samp{<mode>} が @samp{auto} の場合、 ブランチの説明の最初の段落 > 100バイト なら、モードは @samp{message} になり、そうでない場合は @samp{subject} が使用されます。

@samp{<mode>} が @samp{none} の場合、送付状の件名と本文の両方にプレースホルダーテキストが入力されます。

@item  @samp{--subject-prefix=<subject prefix>} 
件名の標準の @samp{[PATCH]} プレフィックスの代わりに、 @samp{[<subjectprefix>]} を使用してください。これにより、パッチシリーズの有用な命名が可能になり、 @samp{--numbered} オプションと組み合わせることができます。

@item  @samp{--filename-max-length=<n>} 
標準の64バイトの代わりに、生成された出力ファイル名を約 @samp{<n>} バイトに切り捨て(短すぎると、値が適切な長さに黙って引き上げられます)。 デフォルトは @samp{format.filenameMaxLength} 構成変数の値、または構成されていない場合は64です。

@item  @samp{--rfc} 
@samp{--subject-prefix="RFC PATCH"} のエイリアス。 RFCは「Request For Comments」を意味します。アプリケーションではなく、議論のために実験的なパッチを送信するときにこれを使用します。

@item  @samp{-v <n>} 
@itemx  @samp{--reroll-count=<n>} 
Mark the series as the <n>-th iteration of the topic. The output filenames have @samp{v<n>} prepended to them, and the subject prefix ("PATCH" by default, but configurable via the @samp{--subject-prefix} option) has ` v<n>` appended to it. E.g. @samp{--reroll-count=4} may produce @samp{v4-0001-add-makefile.patch} file that has "Subject: [PATCH v4 1/20] Add makefile" in it. @samp{<n>} does not have to be an integer (e.g. "--reroll-count=4.4", or "--reroll-count=4rev2" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new iteration is compared against.

@item  @samp{--to=<email>} 
メールヘッダーに @samp{To:} ヘッダーを追加します。 これは、任意の構成済みのヘッダー群に追加されるものであり、複数回使用される場合があります。 否定形式の @samp{--no-to} は、これまでに追加されたすべての @samp{To:} ヘッダーを(構成またはコマンドラインから)破棄します。

@item  @samp{--cc=<email>} 
メールヘッダーに @samp{Cc:} ヘッダーを追加します。 これは、任意の構成済みのヘッダー群に追加されるものであり、複数回使用される場合があります。 否定形式の @samp{--no-cc} は、これまでに追加されたすべての @samp{Cc:} ヘッダーを(構成またはコマンドラインから)破棄します。

@item  @samp{--from} 
@itemx  @samp{--from=<ident>} 
各コミットメールの @samp{From:} ヘッダーで <ident> を使用します。 コミットの作成者IDが、提供された <ident> とテキストで同一でない場合は、元の作成者とのメッセージの本文に @samp{From:} ヘッダーを配置します。 <ident> が指定されていない場合は、コミッターIDを使用します。

注意: このオプションは、実際にメールを送信していて、自分を送信者として識別したいが、元の作成者を保持したい場合にのみ役立ちます(そして、 @samp{git am} は本文のヘッダーを正しく取得します)。 また、 @samp{git send-email} はすでにこの変換を処理するようになっているため、結果を @samp{git send-email} にフィードする場合は、このオプションを使用しないでください。

@item  @samp{--[no-]force-in-body-from} 
@samp{--from} オプションで電子メールの送信者を指定すると、デフォルトでは、作者と送信者が異なる場合、コミットの実際の作者を識別するための本文内の @samp{From:} がコミット・ログ・メッセージの先頭に追加されます。 このオプションを使用すると、送信者と作者が同じ名前とアドレスを持っている場合でも、本文内の @samp{From:} が追加されます。これは、メーリング・リスト・ソフトウェアが送信者の身元を解読する場合に役立ちます。 デフォルトは @samp{format.forceInBodyFrom} 構成変数の値です。

@item  @samp{--add-header=<header>} 
電子メールヘッダーに任意のヘッダーを追加します。これは、構成済みのヘッダーに追加されるものであり、複数回使用される場合があります。 たとえば、 @samp{--add-header="Organization: git-foo"} です。 否定形式の @samp{--no-add-header} は、構成またはコマンドラインからこれまでに追加された「すべての」(@samp{To:} と @samp{Cc:} と カスタム)ヘッダーを破棄します。

@item  @samp{--[no-]cover-letter} 
パッチに加えて、ブランチの説明、ショートログ、および全体的なdiffstatを含むカバーレターファイルを生成します。あなたは、送信する前に、ファイルに説明を入力できます。

@item  @samp{--encode-email-headers} 
@itemx  @samp{--no-encode-email-headers} 
ヘッダーをそのまま(verbatim)出力する代わりに、非ASCII文字を含む電子メールヘッダーを @samp{Q-encoding} (RFC 2047で説明)でエンコードします。 デフォルトは、 @samp{format.encodeEmailHeaders} 構成変数の値です。

@item  @samp{--interdiff=<previous>} 
レビュアーの補助として、カバーレターに、あるいは1パッチシリーズの単独パッチの解説として、パッチシリーズの前のバージョンと現在フォーマットされているシリーズとの違いを示す interdiff を挿入してください。 @samp{previous} は、フォーマット中のシリーズと共通のベースを持つ、前のシリーズの先端を示す単一のリビジョンです(例えば、 @samp{git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2} )。

@item  @samp{--range-diff=<previous>} 
レビューの補助として、カバーレターに range-diff (git-range-diff(1) 参照) を挿入するか、1パッチシリーズの単独パッチの解説として、そのパッチシリーズの前のバージョンと現在フォーマットされているシリーズとの相違を示します。 前バージョンは、フォーマットされるシリーズと共通のベースがある場合、前のシリーズの先端を示す単一のリビジョン(例えば @samp{git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2} )、またはシリーズの二つのバージョンが分離している場合、リビジョンレンジ(例えば @samp{git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2} )が使用されます。

注意: コマンドに渡される diff オプションは、 @samp{format-patch} の基本製造物の生成方法に影響し、カバーレターの実体を生成するために使用される基礎となる @samp{range-diff} 機構には渡されないことに注意してください(これは将来変更される可能性があります)。

@item  @samp{--creation-factor=<percent>} 
@samp{--range-diff} とともに使用すると、 作成/削除 のコストファッジ係数(cost fudge factor)を調整することにより、以前の一連のパッチと現在の一連のパッチの間でコミットを一致させるヒューリスティックを微調整します。 詳細については、 git-range-diff(1) を参照してください。

@item  @samp{--notes[=<ref>]} 
@itemx  @samp{--no-notes} 
3つの破線(@samp{---})行の後に、コミットのnotes (linkgit: git-notes[1] を参照)を追加します。

この場合、コミットログメッセージに属さないコミットの説明を書いて、パッチを送信する際に添付することが期待されます。これらの説明は、単に @samp{format-patch} を実行した後で送信する前に書くこともできますが、Git notes として残しておくと、パッチシリーズのバージョン間でそれらを維持することができます(ただし、この作業フローを使用するには git-notes(1) の @samp{notes.rewrite} 設定オプションに関するdiscussionを参照してください)。

@samp{format.notes} 構成が設定されていない限り、デフォルトは @samp{--no-notes} です。

@item  @samp{--[no-]signature=<signature>} 
生成された各メッセージに署名を追加します。 RFC 3676に従い、署名は `-- ` が付いた行で本文から区切られています。署名オプションを省略した場合、署名はデフォルトでGitバージョン番号になります。

@item  @samp{--signature-file=<file>} 
署名がファイルから読み取られることを除いて、 @samp{--signature} と同じように機能します。

@item  @samp{--suffix=.<sfx>} 
生成されたファイル名のサフィックスとして @samp{.patch} を使用する代わりに、指定されたサフィックスを使用します。 一般的な代替手段は @samp{--suffix=.txt} です。 これを空のままにすると、 @samp{.patch} サフィックスが削除されます。

注意: 先行する文字はドット(@samp{.})である必要はないことに注意してください。 たとえば、 @samp{--suffix=-patch} を使用して @samp{0001-description-of-my-change-patch} とかすることができます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
生成されたファイルの名前を標準出力に出力しないでください。

@item  @samp{--no-binary} 
バイナリファイルの変更内容を出力せず、代わりにそれらのファイルが変更されたという通知を表示します。このオプションを使用して生成されたパッチは適切に適用できませんが、コードレビューには役立ちます。

@item  @samp{--zero-commit} 
コミットのハッシュの代わりに、各パッチのFromヘッダーにすべてゼロのハッシュを出力します。

@item  @samp{--[no-]base[=<commit>]} 
ベースツリー情報を記録して、パッチシリーズが適用される状態を特定します。 詳細については、下記「BASE TREE INFORMATION」セクションを参照してください。 <commit> が @samp{auto} の場合、ベースコミットが自動的に選択されます。 @samp{--no-base} オプションは、 @samp{format.useAutoBase} 構成をオーバーライドします。

@item  @samp{--root} 
単一のコミットであっても、リビジョン引数を <revision range> として扱います(通常は <since> として扱われます)。 指定された範囲に含まれるルートコミットは、このフラグとは関係なく、常に作成パッチとしてフォーマットされることに注意してください。

@item  @samp{--progress} 
パッチが生成されるときに、stderrへ進捗レポートを表示します。
@end table

@noindent

@chapheading CONFIGURATION

あなたは、各メッセージに追加するメールヘッダー行の指定、件名のプレフィックスとファイルのサフィックスのデフォルト、複数のパッチを出力する場合のパッチ番号の指定、 @samp{To:} または @samp{Cc:} ヘッダーの追加、添付ファイルの設定、パッチ出力ディレクトリの変更、設定変数によるパッチのサインオフ、が可能です。

@example
[format]
        headers = "Organization: git-foo\n"
        subjectPrefix = CHANGE
        suffix = .txt
        numbered = auto
        to = <email>
        cc = <email>
        attach [ = mime-boundary-string ]
        signOff = true
        outputDirectory = <directory>
        coverLetter = auto
        coverFromDescription = auto
@end example


@noindent

@chapheading DISCUSSION

@samp{git format-patch} によって生成されたパッチはUNIXメールボックス形式であり、ファイルが実際のメールボックスではなくformat-patchから出力されることを示す固定の「魔法の」タイムスタンプ(fixed "magic" time stamp)が付いています。

@example
From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001
From: Tony Luck <tony.luck@@intel.com>
Date: Tue, 13 Jul 2010 11:42:54 -0700
Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=
 =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

arch/arm config files were slimmed down using a python script
(See commit c2330e286f68f1c408b4aa6515ba49d57f05beae comment)

Do the same for ia64 so we can have sleek & trim looking
...
@end example


通常、MUAの下書きフォルダに配置され、タイムリーなコメントを追加するように編集されます。このコメントは、3つのダッシュ(@samp{---})の後に変更ログに記録されないように編集され、メッセージとして送信されます。この例では、本文は @samp{arch/arm config files were...} です。受信側では、読者は興味あるパッチをUNIXメールボックスに保存し、 git-am(1) を使用してそれらを適用できます。

パッチが進行中の議論の一部である場合、 @samp{git format-patch} によって生成されたパッチは、@samp{git am --scissors} 機能を利用するように調整できます。議論への応答の後に、@samp{-- >8 --} （訳注: @samp{>8} は、ハサミを横にしたアスキーアート(?))のみで構成される行があり、その後に不要なヘッダーフィールドが削除されたパッチが続きます:

@example
...
> So we should do such-and-such.

Makes sense to me.  How about this patch?

-- >8 --
Subject: [IA64] Put ia64 config files on the Uwe Kleine-König diet

arch/arm config files were slimmed down using a python script
...
@end example


この方法でパッチを送信する場合、ほとんどの場合、独自のパッチを送信するため、 @samp{From $SHA1 $magic_timestamp} マーカーに加えて、パッチファイルから @samp{From:} と @samp{Date:} 行を省略する必要があります。パッチのタイトルは、パッチが、応答するディスカッションの主題とは異なる可能性が高いため、上記の例のように、 @samp{Subject:} 行を保持する必要がある可能性があります。

@noindent

@heading パッチの破損のチェック

多くのメーラーは、適切に設定されていないと空白(whitespace)を破損します。破損の一般的な2つのタイプは以下のとおりです:

@itemize 

@item
どの空白(whitespace)もない空のコンテキスト行。

@item
先頭に1つの余分な空白(whitespace)がある空でないコンテキスト行。
@end itemize

あなたのMUAが正しく設定されているかどうかをテストする方法のひとつは以下のとおりです:

@itemize 

@item
リストとメンテナのアドレスを含まない To: 行 と Cc: 行 を除き、全く同じ方法で、パッチを自分自身に送信します。

@item
そのパッチをUNIXメールボックス形式のファイルに保存します。それを a.patch と呼ぶことにしましょう。

@item
それをapplyします:

@example
$ git fetch <project> master:test-apply
$ git switch test-apply
$ git restore --source=HEAD --staged --worktree :/
$ git am a.patch
@end example
@end itemize

これが正しく適用されない場合、さまざまな理由が考えられます。

@itemize 

@item
パッチ自体はきれいに適用されません。それは悪いことですが、しかしあなたのMUAとはあまり関係がありません。この場合、パッチを再生成する前に、 git-rebase(1) を使用してパッチをリベースすることをお勧めします。

@item
MUAがあなたのパッチ破損させました。 @samp{am} は、パッチが適用されないと文句を言います。 .git/rebase-apply/ サブディレクトリを調べて、 @samp{patch} ファイルに含まれているものを確認し、上記の一般的な破損パターンを確認します。

@item
そのとき、 @samp{info} ファイルと @samp{final-commit} ファイルも確認してください。 @samp{final-commit} にあるものが、コミットログメッセージに表示したいものと正確に一致しない場合、パッチを適用するときに受信者がログメッセージを手作業で編集してしまう可能性が非常に高くなります。 パッチの電子メールの "Hi, this is my first patch.\n" のようなものは、コミットメッセージの終わりを示す3本の破線(@samp{---})の後に来るはずです。
@end itemize

@noindent

@chapheading MUA-SPECIFIC HINTS

さまざまなメーラーを使用してパッチをインラインで正常に送信する方法に関するヒントをいくつか。

@noindent

@heading GMail

Gmailには、Webインターフェイスでの行の折り返しをオフにする方法がないため、送信するすべての電子メールが破損します。 ただし、 @samp{git send-email} を使用して、GMail SMTPサーバーを介してパッチを送信するか、任意のIMAPメールクライアントを使用してgoogle IMAPサーバーに接続し、それを介してメールを転送することができます。

@samp{git send-email} を使用して GMail SMTP サーバーを介してパッチを送信するためのヒントについては、 git-send-email(1) のEXAMPLEセクションを参照してください。

IMAPインターフェースを使用した送信のヒントについては、 git-imap-send(1) の EXAMPLE セクションを参照してください。

@noindent

@heading Thunderbird

デフォルトでは、Thunderbirdはメールの行を折り返す(wrap)だけでなく、 @samp{format=flowed} としてフラグを立てます。このため、結果のメールはGitで使用できなくなります。

3つの異なるアプローチがあります: アドオンを使用して行の折り返し(line wraps)をオフにする、またはパッチを切り刻まないようにThunderbirdを構成する、または外部エディターを使用してThunderbirdがパッチを切り刻まないようにします。

@noindent

@subheading Approach #1 (add-on)

@uref{https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/,https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/} から Toggle Word Wrap アドオンをインストールします。これは、コンポーザーの「オプション」メニューに「Enable Word Wrap」というメニュー項目を追加し、チェックを入れることができるようにします。これで、他の方法と同じようにメッセージを作成することができますが(カット＆ペースト、 @samp{git format-patch | git imap-send} など)、入力したテキストには手動で改行を挿入する必要があります。

@noindent

@subheading Approach #2 (configuration)

3ステップ:

@enumerate 

@item
メールサーバーの構成をプレーンテキストとして構成します。 [Edit…Account Settings…Composition & Addressing] で、 [Compose Messages in HTML] のチェックを外します(訳注:手元のThunderBird 91.7.0(64ビット)では、メールごとの[アカウント設定…編集とアドレス入力…編集][HTML形式でメッセージを編集する©])

@item
行の折返しをしないように、あなたの一般作文ウィンドウ(general composition window)を設定します。

Thunderbird 2: [Edit..Preferences..Composition] で、 [wrap plain text messages] を 0 にセットする。

Thunderbird 3 : [Edit..Preferences..Advanced..ConfigEditor] で "mail.wrap_long_lines" を検索します。 それをトグルして @samp{false} に設定されていることを確認します。 また、 @samp{mailnews.wraplength} を検索し、値を0に設定します(訳注: ThunderBird 91.7.0(64ビット) 全体の設定…一般…の一番下にある[設定エディター…©]ボタン押下して「高度な設定」タブを開く。後は上記と一緒です)

@item
format=flowed の使用を無効にします: [Edit..Preferences..Advanced..Config Editor](訳注:上記[設定エディター…©]参照) "mailnews.send_plaintext_flowed" を検索します。トグルして @samp{false} に設定されていることを確認します。
@end enumerate

これで今後は、あなたは他の方法(カット＆ペーストや @samp{git format-patch | git imap-send} など)で電子メールを作成できるようになり、パッチが破損することはありません。

@noindent

@subheading Approach #3 (external editor)

Thunderbird拡張機能が必要です： AboutConfig ( @uref{http://aboutconfig.mozdev.org/,http://aboutconfig.mozdev.org/} ) と External Editor (@uref{http://globs.org/articles.php?lng=en&pg=8,http://globs.org/articles.php?lng=en&pg=8}) です。

@enumerate 

@item
あなたが選択した方法を使用して、パッチをテキストファイルとして準備します。

@item
作文ウィンドウ(compose window)を開く前に、 [Edit…Account] を使用して、パッチの送信に使用するアカウントの[Composition & Addressing]パネルの[Compose messages in HTML format]設定のチェックを外します(訳注:手元のThunderBird 91.7.0(64ビット)では、メールごとの[アカウント設定…編集とアドレス入力…編集][HTML形式でメッセージを編集する©])。

@item
Thunderbirdのメインウィンドウで、パッチの作成ウィンドウを開く前に、 [Tools]→ [about:config] を使用して、以下を指定された値に設定します(訳注: ThunderBird 91.7.0(64ビット) 設定…一般…の一番下にある[設定エディター…©]ボタン押下して「高度な設定」タブを開く):

@example
        mailnews.send_plaintext_flowed  => false
        mailnews.wraplength             => 0
@end example


@item
作文ウィンドウを開き、外部エディターアイコンをクリックします。

@item
外部エディタウィンドウで、パッチファイルを読み込み、通常どおりエディタを終了します。
@end enumerate

補足: aboutconfig と以下の設定を使用して 手順2 を実行できる場合がありますが、まだ誰も試していません。

@example
        mail.html_compose                       => false
        mail.identity.default.compose_html      => false
        mail.identity.id?.compose_html          => false
@end example


contrib/thunderbird-patch-inline には、あなたがThunderbirdにパッチを簡単にインクルードするのに役立つスクリプトがあります。これを使用するには、上記の手順を実行してから、スクリプトを外部エディターとして使用します。

@noindent

@heading KMail

これは、KMailを使用してパッチをインラインで送信するのに役立ちます。

@enumerate 

@item
パッチをテキストファイルとして準備します。

@item
「New Mail」をクリックします。

@item
Composer ウィンドウの [Options] の下に移動し、[Word wrap] が設定されていないことを確認します。

@item
Use Message → Insert file して、パッチを挿入します。

@item
作文ウィンドウに戻ります。メッセージに他のテキストを追加し、アドレス指定フィールドと件名フィールドに入力して、送信を押します。
@end enumerate

@noindent

@chapheading BASE TREE INFORMATION

ベースツリー情報ブロックは、メンテナやサードパーティテスタが、パッチシリーズが適用される正確な状態を知るために使用されます。ベースツリー情報ブロックは、「ベースコミット」（プロジェクトの安定した歴史の一部であり、他のすべての人がそれを元に作業する）と、ゼロ個以上の「前提条件パッチ」(ベースコミットにまだ含まれない、よく知られたパッチで、パッチを適用する前にベースコミットにトポロジカルに追加する必要があります)で構成されています。

「ベースコミット」は、 @samp{base-commit: ` の後にコミットオブジェクト名の40進数が続くものとして表示されます。 `prerequisite patch} は @samp{prerequisite-patch-id: ` の後に40-hexの `patch id} として表示されます。これは、パッチを @samp{git patch-id --stable} コマンドに渡すことで取得できます。

パブリックコミットPに加えて、他の誰かからのよく知られたパッチ X、Y、Z を適用し、3つのパッチシリーズ A、B、C を作成したと想像してください。その履歴は以下のようになります:

@example
---P---X---Y---Z---A---B---C
@end example

@samp{git format-patch --base=P -3 C} (またはその変形、たとえば @samp{--cover-letter} または @samp{-3C} の代わりに @samp{Z..C} を使用して範囲を指定する)、 ベースツリー情報ブロックは、コマンドが出力する最初のメッセージ(最初のパッチまたはカバーレターのいずれか)の最後に、以下のように表示されます:

@example
base-commit: P
prerequisite-patch-id: X
prerequisite-patch-id: Y
prerequisite-patch-id: Z
@end example


以下のようなのような非線形トポロジーの場合

@example
---P---X---A---M---C
    \         /
     Y---Z---B
@end example

@samp{git format-patch --base=P -3 C} を使用して A、B、C のパッチを生成することもできます。そして P、X、Y、Z の識別子が最初のメッセージの最後に追加されます。

cmdline で @samp{--base=auto} を設定すると、cmdline で指定されたリモート追跡ブランチとリビジョン範囲の先端コミットのマージ・ベースとしてベース・コミットが自動的に計算されます。 ローカルブランチの場合、このオプションを使用する前に、 @samp{gitbranch --set-upstream-to} でリモートブランチを追跡する必要があります。

@noindent

@chapheading EXAMPLES

@itemize 

@item
リビジョンR1とR2の間のコミットを抽出します。そして、 それらをチェリーピックするために @samp{git am} を使用して現在のブランチの先頭にそれらを適用します:

@example
$ git format-patch -k --stdout R1..R2 | git am -3 -k
@end example


@item
現在のブランチにはあるが、元のブランチにはないすべてのコミットを抽出します:

@example
$ git format-patch origin
@end example


コミットごとに、現在のディレクトリに個別のファイルが作成されます。

@item
プロジェクトの開始以降で @samp{origin} につながるすべてのコミットを抽出します。

@example
$ git format-patch --root origin
@end example


@item
以下は上記と同一です:

@example
$ git format-patch -M -B origin
@end example


さらに、名前変更を検出して処理し、名前変更パッチを生成するためにインテリジェントに書き換えを完了します。 名前の変更パッチは、テキスト出力の量を減らし、一般的にレビューを容易にします。 Git以外の「パッチ」プログラムはパッチの名前変更を理解しないため、受信者がGitを使用してパッチを適用していることがわかっている場合にのみ使用してください。

@item
現在のブランチの先頭から3つのコミットを抽出し、それらを電子メールで送信可能なパッチとしてフォーマットします:

@example
$ git format-patch -3
@end example

@end itemize

@noindent

@chapheading CAVEATS

注意: `format-patch`は、要求された範囲の一部であっても、出力からマージコミットを省略します。単純な「パッチ」には、受信側が同じマージコミットを再現するための十分な情報が含まれていません。

@noindent

@chapheading SEE ALSO

git-am(1), git-send-email(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fsck-objects,,,Top
@chapheading Name

git-fsck-objects — データベース内のオブジェクトの接続性(connectivity)と有効性(validity)を検証(verify)します

@noindent

@chapheading Synopsis

@display
git fsck-objects …
@end display


@noindent

@chapheading DESCRIPTION

これは git-fsck(1) の同義語です。 git-fsck(1) の文書を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fsck,,,Top
@chapheading Name

git-fsck — データベース内のオブジェクトの接続性(connectivity)と有効性(validity)を検証します

@noindent

@chapheading Synopsis

@display
git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]
         [--[no-]full] [--strict] [--verbose] [--lost-found]
         [--[no-]dangling] [--[no-]progress] [--connectivity-only]
         [--[no-]name-objects] [<object>…]
@end display


@noindent

@chapheading DESCRIPTION

データベース内のオブジェクトの接続性(connectivity)と有効性(validity)を検証します

@noindent

@chapheading OPTIONS

@table @asis

@item  <object> 
到達不能追跡のheadとして扱うオブジェクト。

オブジェクトが指定されていない場合、 @samp{git fsck} はデフォルトでインデックスファイルと、 @samp{refs} 名前空間内のすべてのSHA-1参照と、(@samp{--no-reflogs} が与えられて無い場合)すべてのreflogsを、headとして使用します。

@item  @samp{--unreachable} 
存在するが、どの参照ノードからも到達できないオブジェクトを印刷します。

@item  @samp{--[no-]dangling} 
存在するが「直接」使用されることのないオブジェクトを印刷します(デフォルト)。 @samp{--no-dangling} を使用して、この情報を出力から省略することができます。

@item  @samp{--root} 
ルートノードを報告します。

@item  @samp{--tags} 
タグを報告します。

@item  @samp{--cache} 
インデックスに記録されているオブジェクトを、到達不能追跡のheadノードとしても考慮します。

@item  @samp{--no-reflogs} 
reflogのエントリによってのみ参照されるコミットが到達可能であるとは見なさないようにします。このオプションは、以前はrefに含まれていたが、現在は含まれていないが、対応するreflogに残っているコミットを検索することのみを目的としています。

@item  @samp{--full} 
GIT_OBJECT_DIRECTORY（$GIT_DIR/objects) 内のオブジェクトだけでなく、GIT_ALTERNATE_OBJECT_DIRECTORIES または $GIT_DIR/objects/info/alternates にリストされている代替オブジェクトプール、および $GIT_DIR/objects/pack にあるパックされたGitアーカイブにあるオブジェクトもチェックします。サブディレクトリを代替オブジェクトプールにパックします。いまやこれがデフォルトになりました。 @samp{--no-full} でオフにできます。

@item  @samp{--connectivity-only} 
到達可能なオブジェクトの接続のみをチェックし、到達可能なタグ、コミット、またはツリーによって参照されるオブジェクトが存在することを確認します。これにより、ブロブの読み取りを完全に回避することで操作が高速化されます(ただし、参照されたブロブが存在するかどうかは引き続きチェックされます)。 これにより、コミットとツリーの破損が検出されますが、セマンティックチェック(フォーマットエラーなど)は行われません。ブロブオブジェクトの破損はまったく検出されません。

到達不能なタグ、コミット、およびツリーにもアクセスして、履歴のぶら下がっているセグメントのヒントを見つけることができます。この出力を気にせず、さらに高速化したい場合は、 @samp{--no-dangling} を使用してください。

@item  @samp{--strict} 
より厳密なチェックを有効にします。つまり、古いバージョンのGitによって作成された g+w ビットセットで記録されたファイルモードをキャッチします。Linuxカーネル、Git自体、スパースリポジトリなどの既存のリポジトリには、このチェックをトリガーする古いオブジェクトがありますが、このフラグを使用して新しいプロジェクトをチェックすることをお勧めします。

@item  @samp{--verbose} 
おしゃべりになります。

@item  @samp{--lost-found} 
タイプに応じて、ぶら下がっているオブジェクトを .git/lost-found/commit/ または .git/lost-found/other/ に書き込みます。オブジェクトがブロブの場合、コンテンツはそのオブジェクト名ではなくファイルに書き込まれます。

@item  @samp{--name-objects} 
到達可能なオブジェクトの名前を表示する場合、SHA-1に加えて、それらがどのように到達可能であるかを説明する名前も表示します。 git-rev-parse(1) と互換性があります。 例えば @samp{HEAD@@@{1234567890@}~25^2:src/}

@item  @samp{--[no-]progress} 
@samp{--no-progress} または @samp{--verbose} が指定されていない限り、進行状況ステータスは、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 @samp{--progress} は、標準エラーストリームが端末に送信されていない場合でも、進行状況出力を強制します。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  fsck.<msg-id> 
fsck中に、gitは、現在のバージョンのgitでは生成されず、 @samp{transfer.fsckObjects} が設定されている場合はネットワーク経由で送信されない、レガシーデータの問題を検出する場合があります。この機能は、そのようなデータを含むレガシーリポジトリの操作をサポートすることを目的としています。

@samp{fsck.<msg-id>} 設定は、 git-fsck(1) によって取得されますが、代わりに、そのようなデータセット @samp{receive.fsck.<msg-id>} のプッシュを受け入れるか、または、クローンまたはフェッチのセットである @samp{fetch.fsck.<msg-id>} を使用します。

この文書の残りの部分では、簡潔にするために @samp{fsck.*} 変数について説明していますが、対応する @samp{receive.fsck.*} 変数と @samp{fetch.<msg-id>.*} 変数にも同じことが当てはまります。

@samp{color.ui} や @samp{core.editor} のような変数とは異なり、 @samp{receive.fsck.<msg-id>} と @samp{fetch.fsck.<msg-id>} 変数は、設定されていない場合、 @samp{fsck.<msg-id>} 構成にフォールバックしません。さまざまな状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。

@samp{fsck.<msg-id>} が設定されている場合、 @samp{fsck.<msg-id>} の値を @samp{error} 、 @samp{warn} 、@samp{ignore} のいずれか一つとすることにより、エラーを警告に切り替える事もでき、その逆も可能です。そして @samp{<msg-id>} の部分はメッセージIDです。便利なように、fsckはエラー/警告メッセージの前にメッセージIDを付けます。たとえば「missingEmail: invalid author/committer line - missing email」は、 @samp{fsck.missingEmail = ignore} を設定するとその問題が非表示になることを意味します。

一般に、これらの問題のあるオブジェクトが共有する破損の種類をリストして無視するのではなく、 @samp{fsck.skipList} に問題のある既存のオブジェクトを列挙することをお勧めします。前者を実行すると、同じ破損の新しいインスタンスが見過ごされる可能性があります。

不明な @samp{fsck.<msg-id>} 値を設定すると、fsckが停止(die)しますが、 @samp{receive.fsck.<msg-id>} や @samp{fetch.fsck.<msg-id>} に対して同じことを行うと、gitは単に警告するだけです。

See @samp{Fsck Messages} section of git-fsck(1) for supported values of @samp{<msg-id>}.

@item  fsck.skipList 
非致命的な理由により既に壊れている(broken)ことが分かっているため無視する必要があるオブジェクト名(1行につき1つの省略されてないSHA-1)のリストへのパス。Git 2.20 以降では、コメント(@samp{#})文字から行末までと、空行と、先頭と末尾の空白(whitespace)は無視されます。それより古いバージョンでは1行につき1つのSHA-1以外は全てエラーになります。

この機能は、無効なコミッターの電子メールアドレスなど、初期のコミットにもかかわらず、安全に無視できるエラーを含む、確立されたプロジェクトを受け入れる必要がある場合に役立ちます。 注意: この設定では、corruptオブジェクトをスキップすることはできません。

@samp{fsck.<msg-id>} と同様に、この変数に対応する @samp{receive.fsck.skipList} 派生と @samp{fetch.fsck.skipList} 派生があります。

@samp{color.ui} や @samp{core.editor} のような変数とは異なり、 @samp{receive.fsck.skipList} 変数と @samp{fetch.fsck.skipList} 変数は、設定されていない場合、 @samp{fsck.skipList} 構成にフォールバックしません。さまざまな状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。

古いバージョンのGit(2.20より前)では、オブジェクト名リストを並べ替える必要があることが文書化されています。これは必須ではなく、オブジェクト名は任意の順序で表示できますが、リストを読み取るときに、内部バイナリ検索実装の目的でリストが並べ替えられているかどうかを追跡しました。これにより、既に並べ替えられたリストでは作業を節約できます。膨大なリストがない限り、リストを事前に並べ替える必要はありませんでした。 Gitバージョン2.20以降では、代わりにハッシュ実装が使用されるため、リストを事前に並べ替える必要はありません。
@end table

@noindent

@chapheading DISCUSSION

git-fsckは、SHA-1と一般的なオブジェクトの健全性をテストし、結果として得られる到達可能性とその他すべてを完全に追跡します。検出した破損(オブジェクトの欠落または不良)を出力し、 @samp{--unreachable} フラグを使用すると、存在するが指定されたheadノード(または上記デフォルト達)のいずれからも到達できないオブジェクトも出力します。

つまり、それは、あなたのバックアップや、他のアーカイブで見つけなければならない破損したオブジェクトです(つまり、あなたは、それらを削除して、他の誰かが破損したオブジェクトを持っていることを期待して、他のサイトと「rsync」を実行できます)。

core.commitGraph が true の場合、 commit-graph ファイルも「git commit-graph verify」を使用して検査されます。 git-commit-graph(1) を参照してください。

@noindent

@chapheading Extracted Diagnostics

@table @asis

@item  unreachable <type> <object> 
<type> というタイプである <object> というオブジェクトは、表示されるツリーまたはコミットのいずれにおいても、実際には直接または間接的に参照されていません。これは、指定していない別のルートノードがあるか、ツリーが破損していることを意味している可能性があります。ルートノードを見逃していない場合は、到達不能なノードは使用できないため、削除することをお勧めします。

@item  missing <type> <object> 
この <type> というタイプの <object> というオブジェクトは参照されていますが、データベースに存在しません。

@item  dangling <type> <object> 
この <type> タイプの <object> というオブジェクトはデータベースに存在しますが、「直接」使用されることはありません。 ぶら下がっているコミットはルートノードである可能性があります。

@item  hash mismatch <object> 
データベースに、ハッシュがオブジェクトデータベースの値と一致しないオブジェクトがあります。これは、深刻なデータ整合性の問題を示しています。
@end table

@noindent

@chapheading FSCK MESSAGES

The following lists the types of errors @samp{git fsck} detects and what each error means, with their default severity. The severity of the error, other than those that are marked as "(FATAL)", can be tweaked by setting the corresponding @samp{fsck.<msg-id>} configuration variable.

@table @asis

@item  @samp{badDate} 
(ERROR) Invalid date format in an author/committer line.

@item  @samp{badDateOverflow} 
(ERROR) Invalid date value in an author/committer line.

@item  @samp{badEmail} 
(ERROR) Invalid email format in an author/committer line.

@item  @samp{badFilemode} 
(INFO) A tree contains a bad filemode entry.

@item  @samp{badName} 
(ERROR) An author/committer name is empty.

@item  @samp{badObjectSha1} 
(ERROR) An object has a bad sha1.

@item  @samp{badParentSha1} 
(ERROR) A commit object has a bad parent sha1.

@item  @samp{badTagName} 
(INFO) A tag has an invalid format.

@item  @samp{badTimezone} 
(ERROR) Found an invalid time zone in an author/committer line.

@item  @samp{badTree} 
(ERROR) A tree cannot be parsed.

@item  @samp{badTreeSha1} 
(ERROR) A tree has an invalid format.

@item  @samp{badType} 
(ERROR) Found an invalid object type.

@item  @samp{duplicateEntries} 
(ERROR) A tree contains duplicate file entries.

@item  @samp{emptyName} 
(WARN) A path contains an empty name.

@item  @samp{extraHeaderEntry} 
(IGNORE) Extra headers found after @samp{tagger}.

@item  @samp{fullPathname} 
(WARN) A path contains the full path starting with "/".

@item  @samp{gitattributesBlob} 
(ERROR) A non-blob found at @samp{.gitattributes}.

@item  @samp{gitattributesLarge} 
(ERROR) The @samp{.gitattributes} blob is too large.

@item  @samp{gitattributesLineLength} 
(ERROR) The @samp{.gitattributes} blob contains too long lines.

@item  @samp{gitattributesMissing} 
(ERROR) Unable to read @samp{.gitattributes} blob.

@item  @samp{gitattributesSymlink} 
(INFO) @samp{.gitattributes} is a symlink.

@item  @samp{gitignoreSymlink} 
(INFO) @samp{.gitignore} is a symlink.

@item  @samp{gitmodulesBlob} 
(ERROR) A non-blob found at @samp{.gitmodules}.

@item  @samp{gitmodulesLarge} 
(ERROR) The @samp{.gitmodules} file is too large to parse.

@item  @samp{gitmodulesMissing} 
(ERROR) Unable to read @samp{.gitmodules} blob.

@item  @samp{gitmodulesName} 
(ERROR) A submodule name is invalid.

@item  @samp{gitmodulesParse} 
(INFO) Could not parse @samp{.gitmodules} blob.
@end table

@samp{gitmodulesLarge};
(ERROR) @samp{.gitmodules} blob is too large to parse.

@table @asis

@item  @samp{gitmodulesPath} 
(ERROR) @samp{.gitmodules} path is invalid.

@item  @samp{gitmodulesSymlink} 
(ERROR) @samp{.gitmodules} is a symlink.

@item  @samp{gitmodulesUpdate} 
(ERROR) Found an invalid submodule update setting.

@item  @samp{gitmodulesUrl} 
(ERROR) Found an invalid submodule url.

@item  @samp{hasDot} 
(WARN) A tree contains an entry named @samp{.}.

@item  @samp{hasDotdot} 
(WARN) A tree contains an entry named @samp{..}.

@item  @samp{hasDotgit} 
(WARN) A tree contains an entry named @samp{.git}.

@item  @samp{mailmapSymlink} 
(INFO) @samp{.mailmap} is a symlink.

@item  @samp{missingAuthor} 
(ERROR) Author is missing.

@item  @samp{missingCommitter} 
(ERROR) Committer is missing.

@item  @samp{missingEmail} 
(ERROR) Email is missing in an author/committer line.

@item  @samp{missingNameBeforeEmail} 
(ERROR) Missing name before an email in an author/committer line.

@item  @samp{missingObject} 
(ERROR) Missing @samp{object} line in tag object.

@item  @samp{missingSpaceBeforeDate} 
(ERROR) Missing space before date in an author/committer line.

@item  @samp{missingSpaceBeforeEmail} 
(ERROR) Missing space before the email in author/committer line.

@item  @samp{missingTag} 
(ERROR) Unexpected end after @samp{type} line in a tag object.

@item  @samp{missingTagEntry} 
(ERROR) Missing @samp{tag} line in a tag object.

@item  @samp{missingTaggerEntry} 
(INFO) Missing @samp{tagger} line in a tag object.

@item  @samp{missingTree} 
(ERROR) Missing @samp{tree} line in a commit object.

@item  @samp{missingType} 
(ERROR) Invalid type value on the @samp{type} line in a tag object.

@item  @samp{missingTypeEntry} 
(ERROR) Missing @samp{type} line in a tag object.

@item  @samp{multipleAuthors} 
(ERROR) Multiple author lines found in a commit.

@item  @samp{nulInCommit} 
(WARN) Found a NUL byte in the commit object body.

@item  @samp{nulInHeader} 
(FATAL) NUL byte exists in the object header.

@item  @samp{nullSha1} 
(WARN) Tree contains entries pointing to a null sha1.

@item  @samp{treeNotSorted} 
(ERROR) A tree is not properly sorted.

@item  @samp{unknownType} 
(ERROR) Found an unknown object type.

@item  @samp{unterminatedHeader} 
(FATAL) Missing end-of-line in the object header.

@item  @samp{zeroPaddedDate} 
(ERROR) Found a zero padded date in an author/commiter line.

@item  @samp{zeroPaddedFilemode} 
(WARN) Found a zero padded filemode in a tree.
@end table

@noindent

@chapheading Environment Variables

@table @asis

@item  GIT_OBJECT_DIRECTORY 
オブジェクトデータベースのルート(通常は $GIT_DIR/objects )を指定するために使用されます

@item  GIT_INDEX_FILE 
インデックスのインデックスファイルを指定するために使用されます

@item  GIT_ALTERNATE_OBJECT_DIRECTORIES 
追加のオブジェクトデータベースルートを指定するために使用されます(通常は未設定)
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-fsmonitor--daemon,,,Top
@chapheading Name

git-fsmonitor--daemon — A Built-in Filesystem Monitor

@noindent

@chapheading Synopsis

@display
git fsmonitor--daemon start
git fsmonitor--daemon run
git fsmonitor--daemon stop
git fsmonitor--daemon status
@end display


@noindent

@chapheading DESCRIPTION

A daemon to watch the working directory for file and directory changes using platform-specific filesystem notification facilities.

このデーモンは、 低速の githooks(5) インターフェイスではなく、 @uref{technical/api-simple-ipc.html,simple IPC} インターフェイスを使用して、 @samp{git status} などのコマンドと直接通信(communicate)します。

このデーモンは Git に組み込まれているため、 サードパーティのツールは必要ありません。

@noindent

@chapheading OPTIONS

@table @asis

@item  start 
バックグラウンドでデーモンを開始(start)します。

@item  run 
フォアグラウンドでデーモンを実行します。

@item  stop 
存在する場合、 現在の作業ディレクトリで実行されているデーモンを停止(stop)します。

@item  status 
デーモンが現在の作業ディレクトリを監視している場合、 ゼロ・ステータスで終了(exit)します。
@end table

@noindent

@chapheading REMARKS

このデーモンは、 単一の作業ディレクトリを監視し、 最近変更されたファイルとディレクトリのリストを維持するために使用される長時間実行プロセスです。 作業ディレクトリへの変更の概要を要求するだけで、 ディスクのスキャンを回避できる場合、 @samp{git status} などのコマンドのパフォーマンスを向上させることができます。

@samp{core.fsmonitor} が @samp{true} に設定されている場合 (git-config(1) 参照)、 @samp{git status} などのコマンドはデーモンに変更を要求し、 必要に応じてデーモンを自動的に起動します。

詳細については、 git-update-index(1) の「File System Monitor」セクションを参照してください。

@noindent

@chapheading CAVEATS

The fsmonitor daemon does not currently know about submodules and does not know to filter out filesystem events that happen within a submodule. If fsmonitor daemon is watching a super repo and a file is modified within the working directory of a submodule, it will report the change (as happening against the super repo). However, the client will properly ignore these extra events, so performance may be affected but it will not cause an incorrect result.

By default, the fsmonitor daemon refuses to work against network-mounted repositories; this may be overridden by setting @samp{fsmonitor.allowRemote} to @samp{true}. Note, however, that the fsmonitor daemon is not guaranteed to work correctly with all network-mounted repositories and such use is considered experimental.

On Mac OS, the inter-process communication (IPC) between various Git commands and the fsmonitor daemon is done via a Unix domain socket (UDS) — a special type of file — which is supported by native Mac OS filesystems, but not on network-mounted filesystems, NTFS, or FAT32. Other filesystems may or may not have the needed support; the fsmonitor daemon is not guaranteed to work with these filesystems and such use is considered experimental.

By default, the socket is created in the @samp{.git} directory, however, if the @samp{.git} directory is on a network-mounted filesystem, it will be instead be created at @samp{$HOME/.git-fsmonitor-*} unless @samp{$HOME} itself is on a network-mounted filesystem in which case you must set the configuration variable @samp{fsmonitor.socketDir} to the path of a directory on a Mac OS native filesystem in which to create the socket file.

If none of the above directories (@samp{.git}, @samp{$HOME}, or @samp{fsmonitor.socketDir}) is on a native Mac OS file filesystem the fsmonitor daemon will report an error that will cause the daemon and the currently running command to exit.

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  fsmonitor.allowRemote 
By default, the fsmonitor daemon refuses to work against network-mounted repositories. Setting @samp{fsmonitor.allowRemote} to @samp{true} overrides this behavior. Only respected when @samp{core.fsmonitor} is set to @samp{true}.

@item  fsmonitor.socketDir 
This Mac OS-specific option, if set, specifies the directory in which to create the Unix domain socket used for communication between the fsmonitor daemon and various Git commands. The directory must reside on a native Mac OS filesystem. Only respected when @samp{core.fsmonitor} is set to @samp{true}.
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-gc,,,Top
@chapheading Name

git-gc — 不要なファイルをクリーンアップし、ローカルリポジトリを最適化する

@noindent

@chapheading Synopsis

@display
git gc [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]
@end display


@noindent

@chapheading DESCRIPTION

ファイルリビジョンの圧縮(ディスクスペースの削減とパフォーマンスの向上)または、「git add」の以前の呼び出しから作成された可能性のある到達不能オブジェクトの削除または、refのパッキングまたは、reflogの剪定(prune)または、メタデータまたは古い作業ツリーのrerere、など、現在のリポジトリ内で多数のハウスキーピングタスクを実行します。 commit-graphなどの補助インデックスも更新される場合があります。

オブジェクトを作成する一般的な磁器コマンド操作を実行すると、最後のメンテナンス以降にリポジトリが大幅に拡張されているかどうかが確認され、拡張されている場合は、 @samp{git gc} が自動的に実行されます。この動作を無効にする方法については、以下の @samp{gc.auto} を参照してください。

@samp{git gc} を手動で実行する必要があるのは、そのような磁器コマンドを定期的に実行せずにオブジェクトをリポジトリに追加する場合、1回限りのリポジトリ最適化を行う場合などです。最適ではない大量インポートをクリーンアップします。インポートの場合の詳細については、 git-fast-import(1)の「PACKFILE OPTIMIZATION」セクションを参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--aggressive} 
通常、「git gc」は非常に高速に実行され、ディスクスペースの使用率とパフォーマンスは良好です。このオプションを使用すると、「git gc」はリポジトリをより積極的に最適化できますが、時間がかかります。この最適化の効果は割と持続性があります。詳細については、以下の「AGGRESSIVE」セクションを参照してください。

@item  @samp{--auto} 
このオプションを使用すると、「git gc」はハウスキーピングが必要かどうかを確認します。 そうでない場合は、作業を実行せずに終了します。

このヒューリスティックな作業がどのように機能するかについては、以下の「CONFIGURATION」セクションの「gc.auto」オプションを参照してください。

@samp{gc.auto} や @samp{gc.autoPackLimit} などの構成オプションの制限を超えてハウスキーピングがトリガーされると、他のすべてのハウスキーピングタスク（rerere、working tree、reflogなど）も実行されます。

@item  @samp{--[no-]cruft} 
When expiring unreachable objects, pack them separately into a cruft pack instead of storing them as loose objects. @samp{--cruft} is on by default.

@item  @samp{--prune=<date>} 
指定の日付より古いルーズオブジェクトを削除します(デフォルトは2週間前で、構成変数 @samp{gc.pruneExpire} で上書きできます)。 @samp{--prune=now} は、日付に関係なく緩いオブジェクトを削除し、別のプロセスが同時にリポジトリに書き込んでいる場合に破損のリスクが高まります。以下の「NOTES」を参照してください。 @samp{--prune} はデフォルトでオンになっています。

@item  @samp{--no-prune} 
任意のルーズオブジェクトを剪定しません。

@item  @samp{--quiet} 
すべての進捗レポートを抑制します。

@item  @samp{--force} 
このリポジトリで別の @samp{git gc} インスタンスが実行されている場合でも、 @samp{git gc} を強制的に実行します。

@item  @samp{--keep-largest-pack} 
All packs except the largest non-cruft pack, any packs marked with a @samp{.keep} file, and any cruft pack(s) are consolidated into a single pack. When this option is used, @samp{gc.bigPackThreshold} is ignored.
@end table

@noindent

@chapheading AGGRESSIVE

@samp{--aggressive} オプションが指定されている場合、 git-repack(1) は @samp{-f} フラグを指定して呼び出され、次に @samp{--no-reuse-delta} が git-pack-objects(1) に渡されます。これにより、既存のデルタが破棄されて再計算され、再パッキングに多くの時間を費します。

この効果は割と長続きします。例えばパックとルーズオブジェクトが互いに合体すると、そのパック内の既存のデルタが再利用される可能性がありますが、代わりに新しいパックから次善のデルタを選択する場合もあります。

さらに、 @samp{--aggressive} を指定すると、 git-repack(1) に渡される @samp{--depth} と @samp{--window} オプションが微調整されます。以下の @samp{gc.aggressiveDepth} と @samp{gc.aggressiveWindow} 設定を参照してください。より大きなウィンドウサイズを使用することで、より最適なデルタを見つける可能性が高くなります。

カスタマイズされたパフォーマンスベンチマークを実行せずに、特定のリポジトリでこのオプションを使用することはおそらく価値がありません。それにはもっと時間がかかり、結果として生じるスペース/デルタの最適化はそれだけの価値があるかもしれませんし、そうでないかもしれません。これをまったく使用しないことは、ほとんどのユーザーとそのリポジトリにとって正しいトレードオフです。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  gc.aggressiveDepth 
@samp{git gc --aggressive} で使用されるデルタ圧縮アルゴリズムで使用される深さパラメーター。これはデフォルトで50に設定されています。これは @samp{--aggressive} が使用されていない場合の @samp{--depth} オプションのデフォルトです。

詳細については git-repack(1) の @samp{--depth} オプションの文書を参照してください。

@item  gc.aggressiveWindow 
@samp{git gc --aggressive} で使用されるデルタ圧縮アルゴリズムで使用されるウィンドウサイズパラメータ。これはデフォルトで250に設定されています。これは、 @samp{--window} のデフォルト値の10よりもはるかに積極的なウィンドウサイズです。

詳細については、 git-repack(1) の @samp{--window} オプションの文書を参照してください。

@item  gc.auto 
リポジトリにおおよそ指定の値より多くのルーズオブジェクトがある場合、 @samp{git gc --auto} はそれらをパックします。一部の磁器コマンドは、このコマンドを使用して、軽量のガベージコレクションを時々実行します。デフォルト値は6700です。

これを0に設定すると、ルーズオブジェクトの数に基づく自動パッキングが無効にななります。また、他のヒューリスティックな @samp{git gc --auto} が、 @samp{gc.autoPackLimit} などの作業があるかどうかを判断するためにこの値を使用します。

@item  gc.autoPackLimit 
リポジトリに @samp{* .keep} ファイルでマークされていないパックがこの設定値より多くある場合、 @samp{git gc --auto} はそれらを1つの大きなパックに統合します。デフォルト値は50です。これを0に設定すると、無効になります。 @samp{gc.auto} を0に設定すると、この設定も無効になります。

以下の @samp{gc.bigPackThreshold} 構成変数を参照してください。この設定を使用中は、自動パックの制限がどのように機能するかに影響します。

@item  gc.autoDetach 
システムがサポートしている場合は @samp{git gc --auto} は即座戻り、実行はバックグラウンドで行われます。デフォルトはtrueです。

@item  gc.bigPackThreshold 
If non-zero, all non-cruft packs larger than this limit are kept when @samp{git gc} is run. This is very similar to @samp{--keep-largest-pack} except that all non-cruft packs that meet the threshold are kept, not just the largest pack. Defaults to zero. Common unit suffixes of @emph{k}, @emph{m}, or @emph{g} are supported.

注意: 保持されるパックの数が gc.autoPackLimit を超える場合、この構成変数は無視され、基本パックを除くすべてのパックが再パックされることに注意してください。再パック後、パックの数は gc.autoPackLimit を下回り、再び gc.bigPackThreshold が尊重されるでしょう。

@samp{git repack} がスムーズに実行されると推定されるメモリ量が利用できず、かつ、 @samp{gc.bigPackThreshold} が設定されていない場合、最大のパックも除外されます(これは、 @samp{--keep-largest-pack} を指定して @samp{git gc} を実行するのと同じです)。

@item  gc.writeCommitGraph 
trueの場合、 git-gc(1) が実行されると、 gcはcommit-graphファイルを書き換えます。 @samp{git gc --auto} を使用する場合、ハウスキーピングが必要な場合はコミットグラフが更新されます。デフォルトはtrueです。詳細については git-commit-graph(1) を参照してください。

@item  gc.logExpiry 
ファイルgc.logが存在する場合、 @samp{git gc --auto} はそのコンテンツを出力し、そのファイルが「gc.logExpiry」より古い場合を除いて、実行する代わりにステータス0で終了します。デフォルトは「1.day」です。その他の値の指定方法については @samp{gc.pruneExpire} を参照してください。

@item  gc.packRefs 
リポジトリで @samp{git pack-refs} を実行すると、HTTPなどの馬鹿プロトコル(dumb transport) を介して 1.5.1.2 より前のGitバージョンではクローンが作成できなくなります。この変数は、「git gc」が「git pack-refs」を実行するかどうかを決定します。これを @samp{notbare} に設定して、すべての非ベアリポジトリ内で有効にするか、ブール値に設定することができます。 デフォルトは @samp{true} です。

@item  gc.cruftPacks 
Store unreachable objects in a cruft pack (see git-repack(1)) instead of as loose objects. The default is @samp{true}.

@item  gc.pruneExpire 
@samp{git gc} を実行すると、 @samp{prune --expire 2.weeks.ago} が呼び出されます(そして @samp{gc.cruftPacks} または @samp{--cruft} を介してクラフトパック(cruft packs)を使用している場合は、 @samp{repack --cruft --cruft-expiration 2.weeks.ago} が呼び出されます)。 この構成変数で猶予期間をオーバーライドします。 値 @samp{now} を使用してこの猶予期間を無効にし、到達不能なオブジェクトを常にすぐに刈り込み(prune)するか、 @samp{never} を使用して刈り込みを抑制することができます。この機能は @samp{git gc} が、リポジトリに書き込む別のプロセスと並列実行される場合の破損を防ぐのに役立ちます。 git-gc(1) の「NOTES」セクションを参照してください。

@item  gc.worktreePruneExpire 
@samp{git gc} が実行されると、 @samp{git worktree prune --expire3.months.ago} が呼び出されます。この構成変数を使用して、別の猶予期間を設定できます。値「now」を使用して猶予期間を無効にし、 @samp{$GIT_DIR/worktrees} をすぐに剪定(prune)するか、「never」を使用して剪定を抑制することができます。

@item  gc.reflogExpire 
@itemx  gc.<pattern>.reflogExpire 
「git reflog expire」は、この時間より古いreflogエントリを削除します。デフォルトは90日です。値「now」はすべてのエントリをすぐに期限切れにし、「never」は期限切れを完全に抑制します。中央に「<pattern>」(例:「refs/stash」)がある場合、設定は <pattern> に一致するrefにのみ適用されます。

@item  gc.reflogExpireUnreachable 
@itemx  gc.<pattern>.reflogExpireUnreachable 
@samp{git reflog expire} は、この時間より古いreflogエントリを削除し、現在の先端(the current tip)から到達不能にします。デフォルトは30日です。値「now」はすべてのエントリをすぐに期限切れにし、「never」は期限切れを完全に抑制します。中央に「<pattern>」(例:「refs/stash」)がある場合、設定は <pattern> に一致するrefにのみ適用されます。

これらのタイプのエントリは通常、 @samp{git commit--amend} または @samp{git rebase} を使用した結果として作成され、修正またはリベースが発生する前のコミットです。これらの変更は現在のプロジェクトの一部ではないため、ほとんどのユーザーはそれらをより早く期限切れにしたいと思うでしょう。そのため、デフォルトは @samp{gc.reflogExpire} よりも積極的です。

@item  gc.recentObjectsHook 
When considering whether or not to remove an object (either when generating a cruft pack or storing unreachable objects as loose), use the shell to execute the specified command(s). Interpret their output as object IDs which Git will consider as "recent", regardless of their age. By treating their mtimes as "now", any objects (and their descendants) mentioned in the output will be kept regardless of their true age.

Output must contain exactly one hex object ID per line, and nothing else. Objects which cannot be found in the repository are ignored. Multiple hooks are supported, but all must exit successfully, else the operation (either generating a cruft pack or unpacking unreachable objects) will be halted.

@item  gc.rerereResolved 
以前に解決した競合するマージの記録は、「git rerere gc」が実行されるときに、この設定値で指定の日数保持されます。より人間が読める「1.month.ago」などを使用することもできます。デフォルトは60日です。 git-rerere(1) を参照してください。

@item  gc.rerereUnresolved 
@samp{git rerere gc} が実行されると、解決していない競合するマージの記録がこの設定値の日数保持されます。より人間が読める `1.month.ago`などを使用することもできます。デフォルトは15日です。 git-rerere(1) を参照してください。
@end table

@noindent

@chapheading NOTES

@samp{git gc} は、リポジトリ内のどこかで参照されているオブジェクトを削除しないように非常に努力しています。特に、現在のブランチとタグのセットによって参照されるオブジェクトだけでなく、インデックス、リモートトラッキングブランチ、reflog（後で修正または巻き戻されたブランチのコミットを参照する可能性がある）などによって参照されるオブジェクトも保持されます。それ以外の場合は、 refs/* 名前空間にあります。オブジェクトに添付された(「git notes」によって作成された種類の) noteは、オブジェクトの存続に寄与しないことに注意してください。一部のオブジェクトが削除されることを期待していて、削除されない場合は、それらの場所をすべて確認し、それらの参照を削除することが理にかなっているかどうかを判断してください。

一方、「git gc」が別のプロセスと同時に実行されると、他のプロセスが使用しているが参照を作成していないオブジェクトが削除されるリスクがあります。これにより、他のプロセスが失敗したり、他のプロセスが後で削除されたオブジェクトへの参照を追加した場合にリポジトリが破損したりする可能性があります。 Gitには、この問題を大幅に軽減する2つの機能があります:

@enumerate 

@item
@samp{--prune} の日付よりも新しい変更時刻を持つオブジェクトは、そこから到達可能なすべてのモノと共にに保持されます。

@item
データベースにオブジェクトを追加するほとんどの操作は、オブジェクトがすでに存在する場合はその変更時刻を更新して、 #1 が適用されるようにします。
@end enumerate

ただし、これらの機能は完全なソリューションには及ばないため、コマンドを同時に実行するユーザーは、破損のリスクを抱えて生活する必要があります(実際にはリスクは低いようです)。

@noindent

@chapheading HOOKS

@samp{git gc --auto} コマンドは、 @samp{pre-auto-gc} フックを実行します。 詳細については、 githooks(5) を参照してください。

@noindent

@chapheading SEE ALSO

git-prune(1) git-reflog(1) git-repack(1) git-rerere(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-get-tar-commit-id,,,Top
@chapheading Name

git-get-tar-commit-id — git-archiveを使用して作成されたアーカイブからコミットIDを抽出します

@noindent

@chapheading Synopsis

@display
git get-tar-commit-id
@end display


@noindent

@chapheading DESCRIPTION

@emph{git archive} によって作成されたtarアーカイブを標準入力から読み取り、そこに保存されているコミットIDを抽出します。入力の最初の1024バイトのみを読み取るため、実行時間はtarアーカイブのサイズに大きく影響されることはありません。

コミットIDが見つからない場合、 @emph{git get-tar-commit-id} は何も出力せずリターンコード1を返すだけです。これは、アーカイブが @emph{git archive} を使用して作成されていない場合、または @emph{git archive} の最初のパラメーターが、コミットIDまたはタグではなくツリーIDだった場合に発生する可能性があります。(訳注:入力がtarアーカイブで無い場合はstderrにtarアーカイブで無い旨のエラー出力があり、exit code は 128。入力がtarアーカイブの場合で、コミットIDが見つからない場合は表記どおりstdout/stderr出力一切無しでexit code 1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-grep,,,Top
@chapheading Name

git-grep — パターンにマッチする行を出力します

@noindent

@chapheading Synopsis

@display
git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]
           [-v | --invert-match] [-h|-H] [--full-name]
           [-E | --extended-regexp] [-G | --basic-regexp]
           [-P | --perl-regexp]
           [-F | --fixed-strings] [-n | --line-number] [--column]
           [-l | --files-with-matches] [-L | --files-without-match]
           [(-O | --open-files-in-pager) [<pager>]]
           [-z | --null]
           [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]
           [--max-depth <depth>] [--[no-]recursive]
           [--color[=<when>] | --no-color]
           [--break] [--heading] [-p | --show-function]
           [-A <post-context>] [-B <pre-context>] [-C <context>]
           [-W | --function-context]
           [(-m | --max-count) <num>]
           [--threads <num>]
           [-f <file>] [-e] <pattern>
           [--and|--or|--not|(|)|-e <pattern>…]
           [--recurse-submodules] [--parent-basename <basename>]
           [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree>…]
           [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

作業ツリーの追跡ファイル(tracked files)内または、インデックスファイルに登録されているブロブまたは、指定のツリーオブジェクトのブロブ、で指定のパターンを探します。 パターンは、改行文字(newline characters)で区切られた1つ以上の検索式のリストです。 検索式としての空文字列は、すべての行にマッチします。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--cached} 
作業ツリーで追跡中のファイル(tracked files)を検索する代わりに、インデックスファイルに登録されているブロブを検索します。

@item  @samp{--no-index} 
Git管理管理下に無い、現在のディレクトリ内のファイルを検索します。

@item  @samp{--untracked} 
作業ツリーで、追跡中のファイル(tracked files)を検索するだけでなく、追跡されていないファイル(untracked files)も検索します。

@item  @samp{--no-exclude-standard} 
また、 @samp{.gitignore} メカニズムを尊重せずに、無視されたファイル(ignored files)を検索します。 @samp{--untracked} でのみ役立ちます。

@item  @samp{--exclude-standard} 
@samp{.gitignore} メカニズムを介して指定されている、無視されたファイル(ignored files)に注意を払わないでください。 @samp{--no-index} を使用して現在のディレクトリ内のファイルを検索する場合にのみ役立ちます。

@item  @samp{--recurse-submodules} 
リポジトリ内で、アクティブかつチェックアウトされている各サブモジュールを再帰的に検索します。 <tree> オプションと組み合わせて使用すると、すべてのサブモジュール出力のプレフィックスは、親プロジェクトの <tree> オブジェクトの名前になります。 @samp{--no-index} が指定されている場合、このオプションは効果がありません。

@item  @samp{-a} 
@itemx  @samp{--text} 
バイナリファイルをテキストであるかのように処理します。

@item  @samp{--textconv} 
textconvフィルター設定を尊重します。

@item  @samp{--no-textconv} 
textconvフィルター設定を尊重しません。 これがデフォルトです。

@item  @samp{-i} 
@itemx  @samp{--ignore-case} 
パターンとファイルの間で英大文字小文字の違いは無視(ignore case)してください。

@item  @samp{-I} 
バイナリファイルでパターンのマッチをしないでください。

@item  @samp{--max-depth <depth>} 
コマンドラインで指定された<pathspec>ごとに、最大 <depth> レベルまでディレクトリを降りていくかを指定します。 -1 は、制限がないことを意味します。 <pathspec> にアクティブなワイルドカード(active wildcards)が含まれている場合、このオプションは無視されます。言い換えると、 @samp{a*} が @samp{a*} という名前のディレクトリと一致する場合、 @samp{*} は文字通り一致するため、 @samp{--max-depth} は引き続き有効です。

@item  @samp{-r} 
@itemx  @samp{--recursive} 
@samp{--max-depth=-1} と同一です。これがデフォルトです。

@item  @samp{--no-recursive} 
@samp{--max-depth=0} と同一です。

@item  @samp{-w} 
@itemx  @samp{--word-regexp} 
パターンは単語(word)単位でのみ一致します(行頭で開始するかまたは単語以外の文字が先行するかのいずれか。行末で終わるか、単語以外の文字が続きます)。

@item  @samp{-v} 
@itemx  @samp{--invert-match} 
一致しない行を選択します。

@item  @samp{-h} 
@itemx  @samp{-H} 
デフォルトでは、コマンドは各々マッチしたファイル名を表示します。 @samp{-h} オプションは、この出力を抑制するために使用されます。@samp{-H} はオプション機能として完全を期すためにあり、コマンドラインで @samp{-H} 以前に指定した @samp{-h} を打ち消す以外は何もしません。

@item  @samp{--full-name} 
サブディレクトリから実行する場合、コマンドは通常、現在のディレクトリからの相対パスを出力します。 このオプションは、プロジェクトの最上位ディレクトリを基準にしたパスを出力します。

@item  @samp{-E} 
@itemx  @samp{--extended-regexp} 
@itemx  @samp{-G} 
@itemx  @samp{--basic-regexp} 
パターンにはPOSIX 拡張/基本 正規表現を使用します。 デフォルトでは基本正規表現を使用します。

@item  @samp{-P} 
@itemx  @samp{--perl-regexp} 
パターンにはPerl互換の正規表現を使用してください。

これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。 Gitがこれらのサポート付きでコンパイルされていない場合、このオプションを指定するとGitが停止(die)します。

@item  @samp{-F} 
@itemx  @samp{--fixed-strings} 
パターンには固定文字列を使用します(パターンを正規表現として解釈しないでください)。

@item  @samp{-n} 
@itemx  @samp{--line-number} 
マッチした行の前に行番号を付けます。

@item  @samp{--column} 
マッチがあった行の中で(複数マッチするかもしれないので)、最初にマッチしたぶんの行頭(行頭を0じゃなくて1とする)からのオフセットバイト(1-indexed byte-offset)を行頭に置きます。

@item  @samp{-l} 
@itemx  @samp{--files-with-matches} 
@itemx  @samp{--name-only} 
@itemx  @samp{-L} 
@itemx  @samp{--files-without-match} 
一致したすべての行を表示する代わりに、一致を含む(または含まない;@samp{--files-without-match})ファイル名のみを表示します。 @samp{git diff} との互換性を高めるために、@samp{--name-only} が @samp{--files-with-matches} の同義語となっています。

@item  @samp{-O[<pager>]} 
@itemx  @samp{--open-files-in-pager[=<pager>]} 
一致するファイルをページャーで開きます(ただし、 @samp{grep} の出力ではありません)。 ページャーがたまたま「less」または「vi」であり、ユーザーが1つのパターンのみを指定した場合、 最初に開かれるファイルは自動的に最初のマッチになります。 @samp{pager} 引数はオプションです。 指定する場合は、 スペースなしでオプションに固定する必要があります。 @samp{pager} が指定されていない場合、 デフォルトのページャーが使用されます(git-config(1) の`core.pager` を参照)。(訳注:lessで次のファイルに移動するには :n とタイプする。詳しくはmanページ参照)

@item  @samp{-z} 
@itemx  @samp{--null} 
出力のパス名の区切り文字として @samp{\0} を使用し、そのまま(verbatim)出力します。 このオプションがないと、構成変数 core.quotePath で説明されているように、「異常な」文字を含むパス名がクォートされます(git-config(1) 参照)。

@item  @samp{-o} 
@itemx  @samp{--only-matching} 
マッチがある行のマッチする(空でない)部分のみを出力し、行内で複数マッチした場合、そのような各部分を別々の行に出力します。(訳注: 例えば @samp{git grep -n --break --column --only-matching hoge})

@item  @samp{-c} 
@itemx  @samp{--count} 
マッチした行を全て表示する代わりに、ファイル毎にマッチした行の行数を表示します。

@item  @samp{--color[=<when>]} 
色付きのマッチ表示します。 値は always (デフォルト) または never または auto である必要があります。

@item  @samp{--no-color} 
構成ファイルがデフォルトでカラー出力を提供している場合でも、マッチのハイライト表示をオフにします。 @samp{--color=never} と同じです。

@item  @samp{--break} 
一致の出力で、異なるファイルの間に(区切りとして)1行の空行を出力します。(訳注:例 @samp{git grep --break --heading hoge})

@item  @samp{--heading} 
マッチしたのを表示する各行の初めファイル名を表示するのではなく、表示するファイル毎に、その直前にファイル名だけの行を出力します。 (訳注:例 @samp{git grep --break --heading hoge})

@item  @samp{-p} 
@itemx  @samp{--show-function} 
マッチした行が関数名そのものでない限り、 マッチした関数名を含む先行の行を表示します。 名前は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます (gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{-<num>} 
@itemx  @samp{-C <num>} 
@itemx  @samp{--context <num>} 
各マッチ行ごとに <num>行の先行する行と後続する行も表示し、 マッチしたグループ毎に @samp{--} 行を挿入します。

@item  @samp{-A <num>} 
@itemx  @samp{--after-context <num>} 
各マッチ行ごとに <num> 行の後続行も表示し、マッチしたグループ毎に @samp{--} 行を挿入します。

@item  @samp{-B <num>} 
@itemx  @samp{--before-context <num>} 
各マッチした行ごとに <num> 行の先行する行も表示し、 マッチしたグループ毎に @samp{--} 行を挿入します。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数名を含む前の行から次の関数名の前の行までの周囲のテキストを表示し、マッチした関数全体を効果的に示します。 関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{-m <num>} 
@itemx  @samp{--max-count <num>} 
ファイルごとのマッチ数を制限します。 @samp{-v} または @samp{--invert-match} オプションを使用すると、指定された数の不一致の後に検索(search)が停止(stop)します。 -1 の値は無制限の結果を返します (デフォルト)。 0 の値は、ゼロ以外のステータスですぐに終了します。

@item  @samp{--threads <num>} 
使用するgrepワーカースレッドの数。 詳細については、「CONFIGURATION」の「grep.threads」を参照してください。

@item  @samp{-f <file>} 
<file>から1行に1つずつパターンを読み取ります。

<file>を介してパターンを渡すと、 @samp{\0} を含む検索パターンを指定できます。

すべてのパターンタイプが @samp{\0} を含むパターンをサポートしているわけではありません。 特定のパターンタイプがそのようなパターンをサポートできない場合、Gitはエラーになります。 PCRE v2 バックエンドに対してコンパイルされた場合の @samp{--perl-regexp} パターンタイプは、これらのタイプのパターンを最も広くサポートしています。

Git の 2.23.0 より前のバージョンでは、 @samp{\0} を含むパターンは黙って修正されます。 これは全く文書化されておらず、また、例えば @samp{\0} を含む非ASCIIパターンと @samp{--ignore-case} との間の文書化されていない奇妙な相互作用がありました。

将来のバージョンでは、より多くの検索バックエンドが @samp{\0} を含むパターンをサポートする可能性がありますが、それまでは、問題のパターンタイプがそれらをサポートしない場合は終了(die)します。

@item  @samp{-e} 
これに続く次のパラメータはパターンであることを示します。 このオプションは、 @samp{-} で始まるパターンに使用する必要があり、ユーザー入力をgrepに渡すスクリプトで使用する必要があります。複数のパターンは or 結合されます。

@item  @samp{--and} 
@itemx  @samp{--or} 
@itemx  @samp{--not} 
@itemx  @samp{( ... )} 
ブール式を使用して、複数のパターンを組み合わせる方法を指定します。 @samp{--or} はデフォルトの演算子です。 @samp{--and} は @samp{--or} よりも優先されます。 @samp{-e} はすべてのパターンに使用する必要があります。

@item  @samp{--all-match} 
@samp{--or} と組み合わせて複数のパターン式を指定する場合、このフラグを指定して、すべてにマッチする行を持つファイルにマッチを制限します。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
マッチした行を出力しないでください。 代わりに、マッチした場合は終了ステータス0で終了し、マッチしない場合は終了ステータスがゼロ以外で終了します。

@item  @samp{<tree>...} 
作業ツリーで追跡中のファイル(tracked files)を検索する代わりに、指定のツリーでブロブを検索します。

@item  @samp{--} 
コマンドにオプション指定の終了を教えます。 残りのパラメーターは <pathspec> リミッターです。

@item  @samp{<pathspec>...} 
指定されている場合は、検索を少なくとも1つのパターンに一致するパスに制限します。 パスの先行一致 と glob(7)パターン の両方がサポートされます。

<pathspec> 構文の詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git grep 'time_t' -- '*.[ch]'} 
作業ディレクトリとそのサブディレクトリで、追跡中(tracked)のすべての .c ファイルと .h ファイルで @samp{time_t} を探します。

@item  @samp{git grep -e '#define' --and \( -e MAX_PATH -e PATH_MAX \)} 
@samp{#define} かつ、 @samp{MAX_PATH} または @samp{PATH_MAX} のいずれか、を持つ行を探します。

@item  @samp{git grep --all-match -e NODE -e Unexpected} 
各ファイル内で @samp{NODE} または @samp{Unexpected} を探し、かつ、 @samp{NODE} と @samp{Unexpected} の両方を持つ行があるファイルだけを表示します。

@item  @samp{git grep solution -- :^Documentation} 
@samp{Documentation} ファイルを除くファイル達から @samp{solution} を探します。
@end table

@noindent

@chapheading NOTES ON THREADS

@samp{--open-files-in-pager} が使用されている場合、 @samp{--threads} オプション(および grep.threads 構成)は無視され、シングルスレッド実行が強制されます。

オブジェクトストアを(@samp{--cached} を使用して、またはツリーオブジェクトを指定して)grepする場合、 @samp{--textconv} が指定され、テキスト変換が多すぎると、複数のスレッドで実行するとシングルスレッドよりもパフォーマンスが低下する可能性があります。 したがって、このような場合でパフォーマンスが低下する時は、 @samp{--threads=1} を使用することが望ましい場合があります。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  grep.lineNumber 
trueに設定すると、デフォルトで @samp{-n} オプションが有効になります。

@item  grep.column 
trueに設定されている場合、デフォルトで @samp{--column} オプションを有効にします。

@item  grep.patternType 
デフォルトのマッチング動作を設定します。 @samp{basic} または @samp{extended} または @samp{fixed} または @samp{perl} の値を使用すると、それぞれに応じて @samp{--basic-regexp} または ` --extended-regexp` または @samp{--fixed-strings} または @samp{--perl-regexp} オプションが有効になります。 値 @samp{default} は @samp{grep.extendedRegexp} オプションを使用して @samp{basic} と @samp{extended} のどちらかを選択します。

@item  grep.extendedRegexp 
trueに設定されている場合、デフォルトで @samp{--extended-regexp} オプションを有効にします。 @samp{grep.patternType} オプションが @samp{default} 以外の値に設定されている場合、このオプションは無視されます。

@item  grep.threads 
使用する grep ワーカー・スレッドの数。 設定しない場合(または 0 に設定した場合)、 Git は使用可能な論理コアの数と同じ数のスレッドを使用します。

@item  grep.fullName 
trueに設定すると、デフォルトで @samp{--full-name} オプションが有効になります。

@item  grep.fallbackToNoIndex 
trueに設定すると、 @samp{git grep} がgitリポジトリの外部で実行される場合は、 @samp{git grep --no-index} にフォールバックします。 デフォルトはfalseです。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-gui,,,Top
@chapheading Name

git-gui — Gitのための移植性の高いGUI

@noindent

@chapheading Synopsis

@display
git gui [<command>] [<arguments>]
@end display


@noindent

@chapheading DESCRIPTION

Gitの為の Tcl/Tk ベースのGUIです。「git gui」は、ユーザーが新しいコミットを作成し、既存のコミットを修正し、ブランチを作成し、ローカルマージを実行し、リモートリポジトリにフェッチ/プッシュすることでリポジトリに変更を加えることができるようにすることに重点を置いています。

gitk とは異なり、 @samp{git gui} はコミットの生成と単一ファイルの注釈に焦点を合わせており、プロジェクトの履歴は表示しません。 ただし、 @samp{git gui} 内から gitk セッションを開始するためのメニュー操作を提供します。

「git gui」は、すべての一般的なUNIXシステム、Mac OS X、およびWindows(CygwinとMSYSの両方)で動作することが知られています。可能な限り、OS固有のユーザーインターフェイスガイドラインに従い、「git gui」を各OSのユーザーにとってかなり自然なインターフェイスにしようとしています。

@noindent

@chapheading COMMANDS

@table @asis

@item  blame 
指定されたバージョンの指定されたファイル(または指定されていない場合は作業ディレクトリ)でblameビューアを起動します。

@item  browser 
指定されたコミット内のすべてのファイルを表示するツリーブラウザを起動します。ブラウザで選択したファイルをblemeビューアで開きます。

@item  citool 
@samp{git gui} を開始し、シェルを終了してシェルに戻る前に、正確に1つのコミットを行うように調整します。インターフェイスはコミットアクションのみに制限されているため、アプリケーションの起動時間がわずかに短縮され、メニューバーが簡素化されます。

@item  version 
現在実行中の「git gui」のバージョンを表示します。
@end table

@noindent

@chapheading Examples

@table @asis

@item  @samp{git gui blame Makefile} 
現在の作業ディレクトリにあるファイル「Makefile」の内容を表示し、各行の元の作成者と、その行を現在の場所に移動した人の両方に注釈を付けます。コミットされていないファイルには注釈が付けられ、(存在する場合)コミットされていない変更は「まだコミットされていません」と明示されます。

@item  @samp{git gui blame v0.99.8 Makefile} 
リビジョン「v0.99.8」の「Makefile」の内容を表示し、各行に注釈を付けます。上記の例とは異なり、ファイルは作業ディレクトリではなくオブジェクトデータベースから読み取られます。

@item  @samp{git gui blame --line=100 Makefile} 
上記のように注釈をロードし、100行目を中心にビューを自動的にスクロールします。

@item  @samp{git gui citool} 
1つのコミットを行い、完了したらシェルに戻ります。このコマンドは、コミットを行う以外の方法でウィンドウが閉じられた場合、ゼロ以外の終了コードを返します。

@item  @samp{git gui citool --amend} 
インターフェイスの「Amend Last Commit」モードを自動的に開始します。

@item  @samp{git gui citool --nocommit} 
通常のcitoolとして動作しますが、コミットを行う代わりに、ゼロの終了コードで終了します。インデックスにマージされていないエントリが含まれていないことを引き続きチェックするため、 git-mergetool(1) のGUIバージョンとして使用できます。

@item  @samp{git citool} 
@samp{git gui citool} (上記)と同じです。

@item  @samp{git gui browser maint} 
maint ブランチのツリーのブラウザを表示します。ブラウザで選択したファイルは、内部のblameビューアで表示できます。
@end table

@noindent

@chapheading SEE ALSO

@table @asis

@item  gitk(1) 
Gitリポジトリブラウザ。 ブランチ、コミット履歴、ファイルの差分を表示します。 gitkは、「git gui」のリポジトリ視覚化操作によって開始されるユーティリティです。
@end table

@noindent

@chapheading Other

「git gui」は実際には独立したプロジェクトとして維持されていますが、エンドユーザーの便宜のために安定したバージョンがGitスイートの一部として配布されています。

@samp{git gui} プロジェクトの公式リポジトリは以下の場所にあります:

@example
https://github.com/prati0100/git-gui.git/
@end example

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-hash-object,,,Top
@chapheading Name

git-hash-object — Compute object ID and optionally create an object from a file

@noindent

@chapheading Synopsis

@display
git hash-object [-t <type>] [-w] [--path=<file> | --no-filters]
                [--stdin [--literally]] [--] <file>…
git hash-object [-t <type>] [-w] --stdin-paths [--no-filters]
@end display


@noindent

@chapheading DESCRIPTION

指定のファイル(作業ツリーの外部にある可能性あり)の内容を使用して、指定されたタイプのオブジェクトのオブジェクトID値を計算し、オブジェクトIDを標準出力に報告します。オプションで結果のオブジェクトをオブジェクトデータベースに書き込みます。 <type> が指定されていない場合、デフォルトで「blob」になります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-t <type>} 
Specify the type of object to be created (default: "blob"). Possible values are @samp{commit}, @samp{tree}, @samp{blob}, and @samp{tag}.

@item  @samp{-w} 
実際にオブジェクトをオブジェクトデータベースに書き込みます。

@item  @samp{--stdin} 
ファイルからではなく、標準入力からオブジェクトを読み取ります。

@item  @samp{--stdin-paths} 
コマンドラインからではなく、標準入力から1行に1つずつファイル名を読み取ります。

@item  @samp{--path} 
指定されたパスにあるオブジェクトをハッシュします。ファイルの場所はハッシュ値に直接影響しませんが、パスを使用して、オブジェクトデータベースに配置する前にオブジェクトに適用するGitフィルターを決定し、フィルターを適用した結果、実際のブロブを配置します。オブジェクトデータベースへの入力は、指定されたファイルとは異なる場合があります。このオプションは主に、作業ディレクトリの外部にある一時ファイルまたは標準入力から読み取られたファイルをハッシュする場合に役立ちます。

@item  @samp{--no-filters} 
行末変換など、属性メカニズムによって選択された入力フィルターを無視して、コンテンツをそのままハッシュします。 ファイルが標準入力から読み取られる場合、 @samp{--path} オプションが指定されていない限り、これは常に暗黙に指定されたものとみなします。

@item  @samp{--literally} 
@samp{--stdin} が、標準のオブジェクトパースやgit-fsckチェックに合格しない可能性のあるガベージをハッシュして緩いオブジェクトにできるようにします。Git自体のストレステストや、野生で遭遇した破損または偽のオブジェクトの特性の再現に役立ちます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-help,,,Top
@chapheading Name

git-help — Gitに関するヘルプ情報を表示します

@noindent

@chapheading Synopsis

@display
git help [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]
git help [[-i|--info] [-m|--man] [-w|--web]] [<command>|<doc>]
git help [-g|--guides]
git help [-c|--config]
git help [--user-interfaces]
git help [--developer-interfaces]
@end display


@noindent

@chapheading DESCRIPTION

オプションがなく、 @samp{<command>} または @samp{<doc>} が指定されていない場合、 gitコマンドの概要と最も一般的に使用されるGitコマンドのリストが標準出力に出力されます。

オプション @samp{--all} または @samp{-a} を指定すると、使用可能なすべてのコマンドが標準出力に出力されます。

オプション @samp{--guides} または @samp{-g} を指定すると、Gitコンセプトガイドのリストも標準出力に出力されます。

コマンドまたはその他のドキュメントを指定すると、 関連するマニュアル・ページが表示されます。 @samp{man} プログラムは、この目的のためにデフォルトで使用されますが、これは他のオプションまたは構成変数によってオーバーライドできます。

エイリアスが指定されている場合、gitは標準出力にエイリアスの定義を表示します。 エイリアスコマンドのマニュアルページを取得するには、 @samp{git <command> --help} を使用します。

注意: @samp{git --help...} は @samp{git help ...} と同じであることに注意してください。これは、前者が内部で後者に変換されるためです。

git(1) のマニュアルページを表示するには、 @samp{git help git} を使用します。

このページは、 @samp{git help help} または @samp{git help --help} で表示できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
@itemx  @samp{--all} 
使用可能なすべてのコマンドを標準出力に出力します。

@item  @samp{--no-external-commands} 
@samp{--all} とともに使用すると、 @samp{$PATH} 上にある外部の @samp{git-*} コマンドのリストが除外されます。

@item  @samp{--no-aliases} 
@samp{--all} とともに使用すると、構成されたエイリアス(configured aliases)のリストが除外されます。

@item  @samp{--verbose} 
@samp{--all} と一緒に使用すると、認識されたすべてのコマンドの説明が出力されます。 これがデフォルトです。

@item  @samp{-c} 
@itemx  @samp{--config} 
使用可能なすべての構成変数をリストします。 これは、 git-config(1) のリストの簡単な要約です。

@item  @samp{-g} 
@itemx  @samp{--guides} 
Gitコンセプトガイドのリストを標準出力に出力します。

@item  @samp{--user-interfaces} 
リポジトリや、コマンドや、ファイル・インターフェイス・ドキュメントのリストを標準出力に出力します。

@samp{.git/info/exclude} などのリポジトリ内ファイル・インターフェース(gitrepository-layout(5) 参照)は、@samp{.mailmap} などのツリー内設定(gitmailmap(5) 参照)と同様に、ここに文書化されています。

ドキュメントのこのセクションでは、一般的または広範なユーザー・インターフェイス規則(例: gitcli(7))や、 githooks(5) で説明されているファイル・ベースの @samp{.git/hooks/*} インターフェイスなどの疑似構成についても説明します。

@item  @samp{--developer-interfaces} 
ファイル形式や、プロトコルや、その他の開発者インターフェース・キュメントのリストを標準出力に出力します。

@item  @samp{-i} 
@itemx  @samp{--info} 
コマンドのマニュアルページをinfo形式で表示します。 @samp{info} プログラムがその目的で使用されます。

@item  @samp{-m} 
@itemx  @samp{--man} 
コマンドのマニュアルページをman形式で表示します。 このオプションは、 @samp{help.format} 構成変数に設定された値をオーバーライドするために使用できます。

デフォルトでは、 @samp{man} プログラムを使用してマニュアルページを表示しますが、 @samp{man.viewer} 構成変数を使用して他の表示プログラムを選択することもできます(後述)。

@item  @samp{-w} 
@itemx  @samp{--web} 
コマンドのマニュアルページを @samp{web} (HTML)形式で表示します。その目的のためにウェブブラウザが使用されます。

Webブラウザーは、構成変数 @samp{help.browser} または @samp{web.browser} を使用して指定できます。前者が設定されていない場合は、 @samp{web.browser} を使用します。 これらの構成変数のいずれも設定されていない場合、 (@samp{git help} によって呼び出される、) @samp{git web@{litdd@}browse} ヘルパースクリプトが適切なデフォルトを選択します。 詳細については、 git-web--browse(1) を参照してください。
@end table

@noindent

@chapheading CONFIGURATION VARIABLES

@noindent

@heading help.format

コマンドラインオプションが渡されない場合、 @samp{help.format} 構成変数がチェックされます。 この変数では、以下の値がサポートされています。 これらは @samp{git help} の対応するコマンドラインオプションとして動作します:

@itemize 

@item
@samp{man} は @samp{-m|--man} に対応します。

@item
@samp{info} は @samp{-i|--info} に対応します。

@item
@samp{web} または @samp{html} は @samp{-w|--web} に対応します。
@end itemize

@noindent

@heading help.browser と web.browser と browser.<tool>.path

@samp{help.browser} と @samp{web.browser} と @samp{browser.<tool>.path} は、 (コマンドラインオプションまたは構成変数のいずれかによって、) @samp{web} 形式が選択されているかどうかもチェックされます。上記「OPTIONS」セクションの @samp{-w|--web} と および git-web--browse(1) を参照してください。

@noindent

@heading man.viewer

@samp{man} 形式が選択されている場合、 @samp{man.viewer} 構成変数がチェックされます。 現在、以下の値がサポートされています:

@itemize 

@item
@samp{man} : 通常どおり @samp{man} プログラムを使用します。

@item
@samp{woman} : @samp{emacsclient} を使用してemacsで @samp{woman} モードを起動します(これはemacsclientバージョン22以降でのみ機能します)。

@item
@samp{konqueror} : @samp{kfmclient} を使用して、新しいkonquerorタブでマニュアルページを開きます(以下の「Note about konqueror」を参照)。
@end itemize

対応する @samp{man.<tool>.cmd} 構成エントリがある場合は、他のツールの値を使用できます(後述)。

@samp{man.viewer} 構成変数に複数値を指定できます。対応するプログラムは、構成ファイルにリストされている順序で試されます。

たとえば、以下の構成:

@example
        [man]
                viewer = konqueror
                viewer = woman
@end example


最初にkonquerorを使用しようと試みます。 ただし、これは失敗する可能性があり(たとえば、DISPLAYが設定されていない場合)、その場合、emacsのwomanモードが試されます。

すべてが失敗した場合、またはビューアが設定されていない場合は、 @samp{GIT_MAN_VIEWER} 環境変数で指定されたビューアが試されます。それも失敗した場合は、とにかく @samp{man} プログラムが試されます。

@noindent

@heading man.<tool>.path

構成変数 @samp{man.<tool>.path} を設定することにより、優先するmanビューアへのフルパスを明示的に指定できます。 たとえば、 @samp{man.konqueror.path} を設定することで、konquerorへの絶対パスを設定できます。 それ以外の場合、 @samp{git help} はツールがPATH上にあると想定します。

@noindent

@heading man.<tool>.cmd

@samp{man.viewer} 構成変数で指定されたmanビューアがサポートされているものに含まれていない場合、対応する @samp{man.<tool>.cmd} 構成変数が検索されます。 この変数が存在する場合、指定されたツールはカスタムコマンドとして扱われ、シェルのevalを使用して、引数として渡されたマニュアルページを使用してコマンドを実行します。

@noindent

@heading Note about konqueror

@samp{man.viewer} 構成変数で @samp{konqueror} が指定されている場合、可能であれば、 @samp{kfmclient} を起動して、既に開いているkonquerorのmanページを新しいタブで開こうとします。

一貫性を保つために、 @samp{man.konqueror.path} が @samp{A_PATH_TO/konqueror} のようなものに設定されている場合にも、このようなトリックを試します。 つまり、代わりに @samp{A_PATH_TO/kfmclient} を起動しようとします。

あなたが本当に @samp{konqueror} を使用したい場合は、以下のようなものを使用できます:

@example
        [man]
                viewer = konq

        [man "konq"]
                cmd = A_PATH_TO/konqueror
@end example


@noindent

@heading Note about git config --global

注意: これらの構成変数はすべて、たとえば以下のように、 @samp{--global} フラグを使用して設定する必要があることに注意してください:

@example
$ git config --global help.format web
$ git config --global web.browser firefox
@end example


それらは、おそらくリポジトリ固有というよりはユーザー固有であるためです。 詳細については、 git-config(1) を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-hook,,,Top
@chapheading Name

git-hook — gitフックの実行

@noindent

@chapheading Synopsis

@display
git hook run [--ignore-missing] [--to-stdin=<path>] <hook-name> [-- <hook-args>]
@end display


@noindent

@chapheading DESCRIPTION

他のスクリプト化された git コマンドで使用するための、 git フック(githooks(5) 参照) を実行するためのコマンド・インターフェイス。

@noindent

@chapheading SUBCOMMANDS

@table @asis

@item  run 
@samp{<hook-name>} フックを実行します。 サポートされているフック名については、 githooks(5) を参照してください。

フックへの位置引数は、 必須の @samp{--} (または @samp{--end-of-options} については gitcli(7) 参照)の後ろで渡す必要があります。 フックが期待する引数(存在する場合)については、 githooks(5) を参照してください。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--to-stdin} 
For "run"; Specify a file which will be streamed into the hook’s stdin. The hook will receive the entire file from beginning to EOF.

@item  @samp{--ignore-missing} 
見つからないフックを無視し、黙ってゼロを返します。 存在するかどうかわからないフックを一発で実行したいツールに使用します。
@end table

@noindent

@chapheading SEE ALSO

githooks(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-http-backend,,,Top
@chapheading Name

git-http-backend — Git over HTTP のサーバー側実装

@noindent

@chapheading Synopsis

@display
git http-backend
@end display


@noindent

@chapheading DESCRIPTION

@samp{http://} と @samp{https://} プロトコルを介してリポジトリにアクセスするGitクライアントにGitリポジトリのコンテンツを提供するための単純なCGIプログラム。 このプログラムは、スマートHTTPプロトコルと下位互換性のあるダムHTTPプロトコルの両方を使用してフェッチするクライアント、およびスマートHTTPプロトコルを使用してプッシュするクライアントをサポートします。 適切に構成されていれば、Gitのより効率的な「v2」プロトコルもサポートします。 以下の「ENVIRONMENT」セクションの「GIT_PROTOCOL」の説明を参照してください。

ディレクトリにマジックファイル @samp{git-daemon-export-ok} があることを確認し、この方法でエクスポートのマークが明示されていないGitディレクトリのエクスポートを拒否します(@samp{GIT_HTTP_EXPORT_ALL} 環境変数が設定されている場合を除く)。

デフォルトでは、 @samp{upload-pack} サービスのみが有効になっており、 @samp{git fetch} や @samp{git pull} や @samp{git clone} から呼び出される @samp{git fetch-pack} クライアントと @samp{git ls-remote} クライアントにサービスを提供します。クライアントが認証されると、 @samp{receive-pack} サービスが有効になります。このサービスは @samp{git push} から呼び出される @samp{git send-pack} クライアントにサービスを提供します。

@noindent

@chapheading SERVICES

これらのサービスは、リポジトリごとの構成ファイルを使用して有効/無効にできます。

@table @asis

@item  http.getanyfile 
これは、アップロードパックサービスを使用できないバージョン1.6.6より古いGitクライアントにサービスを提供します。 有効にすると、クライアントは、ブランチから到達できなくなったがまだ存在しているオブジェクトを含む、リポジトリ内の任意のファイルを読み取ることができます。 デフォルトで有効になっていますが、リポジトリはこの構成アイテムを「false」に設定することで無効にできます。

@item  http.uploadpack 
これは、 @samp{git fetch-pack} および @samp{git ls-remote} クライアントにサービスを提供します。 デフォルトで有効になっていますが、リポジトリはこの構成アイテムを「false」に設定することで無効にできます。

@item  http.receivepack 
これは @samp{git send-pack} クライアントにサービスを提供し、プッシュを可能にします。 匿名ユーザーの場合はデフォルトで無効になっており、Webサーバーによって認証されたユーザーの場合はデフォルトで有効になっています。 この項目を @samp{false} に設定することで無効にするか、 @samp{true} に設定することで匿名ユーザーを含むすべてのユーザーに対して有効にすることができます。
@end table

@noindent

@chapheading URL TRANSLATION

ディスク上のリポジトリの場所を特定するために、 @samp{git http-backend} は、Webサーバーによって自動的に設定される環境変数PATH_INFOと、Webサーバー構成で手動で設定する必要があるGIT_PROJECT_ROOTを連結します。 GIT_PROJECT_ROOTが設定されていない場合、 @samp{git http-backend} はPATH_TRANSLATEDを読み取ります。これも、Webサーバーによって自動的に設定されます。

@noindent

@chapheading EXAMPLES

以下の例はすべて、 @samp{http://$hostname/git/foo/bar.git} を @samp{/var/www/git/foo/bar.git} にマップします。

@table @asis

@item  Apache 2.x 
mod_cgiとmod_aliasとmod_envが有効になっていることを確認し、 GIT_PROJECT_ROOT (またはDocumentRoot)を適切に設定して、CGIにScriptAliasを作成します:

@example
SetEnv GIT_PROJECT_ROOT /var/www/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/

# This is not strictly necessary using Apache and a modern version of
# git-http-backend, as the webserver will pass along the header in the
# environment as HTTP_GIT_PROTOCOL, and http-backend will copy that into
# GIT_PROTOCOL. But you may need this line (or something similar if you
# are using a different webserver), or if you want to support older Git
# versions that did not do that copying.
#
# Having the webserver set up GIT_PROTOCOL is perfectly fine even with
# modern versions (and will take precedence over HTTP_GIT_PROTOCOL,
# which means it can be used to override the client's request).
SetEnvIf Git-Protocol ".*" GIT_PROTOCOL=$0
@end example


匿名の読み取りアクセスを有効にし、認証された書き込みアクセスを有効にするには、最初のref広告(クエリ文字列のサービスパラメーターを介したプッシュとして検出)とreceive-pack呼び出し自体の両方の承認(authorization)が必要です。

@example
RewriteCond %@{QUERY_STRING@} service=git-receive-pack [OR]
RewriteCond %@{REQUEST_URI@} /git-receive-pack$
RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]

<LocationMatch "^/git/">
        Order Deny,Allow
        Deny from env=AUTHREQUIRED

        AuthType Basic
        AuthName "Git Access"
        Require group committers
        Satisfy Any
        ...
</LocationMatch>
@end example


クエリ文字列と照合するために使用できる @samp{mod_rewrite} がない場合は、以下のように @samp{git-receive-pack} 自体を保護するだけで十分です:

@example
<LocationMatch "^/git/.*/git-receive-pack$">
        AuthType Basic
        AuthName "Git Access"
        Require group committers
        ...
</LocationMatch>
@end example


このモードでは、サーバーは、クライアントが最初の接続中ではなく、プッシュのオブジェクトネゴシエーションフェーズを実際に開始するまで、認証(authentication)を要求しません。 このため、プッシュを受け入れる必要のあるリポジトリでは、 @samp{http.receivepack} 設定オプションも有効にする必要があります。 @samp{http.receivepack} が設定されていない場合のデフォルトの動作は、認証されていないユーザーによるプッシュを拒否することです。 したがって、最初のリクエストは、認証の機会さえ与えずに、クライアントに @samp{403 Forbidden} を報告します。

読み取りと書き込みの両方に認証を要求するには、リポジトリまたはその親ディレクトリの1つでLocationディレクティブを使用します:

@example
<Location /git/private>
        AuthType Basic
        AuthName "Private Git Access"
        Require group committers
        ...
</Location>
@end example


同一URLでgitwebを提供するには、ScriptAliasMatchを使用して @samp{git http-backend} が処理できるURLのみを取得し、残りをgitwebに転送します:

@example
ScriptAliasMatch \
        "(?x)^/git/(.*/(HEAD | \
                        info/refs | \
                        objects/(info/[^/]+ | \
                                 [0-9a-f]@{2@}/[0-9a-f]@{38@} | \
                                 pack/pack-[0-9a-f]@{40@}\.(pack|idx)) | \
                        git-(upload|receive)-pack))$" \
        /usr/libexec/git-core/git-http-backend/$1

ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/
@end example


単一のリポジトリで異なる gitnamespaces(7) から複数のリポジトリを提供するには:

@example
SetEnvIf Request_URI "^/git/([^/]*)" GIT_NAMESPACE=$1
ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1
@end example


@item  Accelerated static Apache 2.x 
上記と同様ですが、Apacheを使用して、ディスクに保存されている静的ファイルを返すことができます。 多くのシステムでは、Apacheがカーネルにファイルの内容をファイルシステムからネットワークに直接コピーするように要求できるため、これはより効率的です:

@example
SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]@{2@}/[0-9a-f]@{38@})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]@{40@}.(pack|idx))$ /var/www/git/$1
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/
@end example


これは、gitweb構成と組み合わせることができます:

@example
SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]@{2@}/[0-9a-f]@{38@})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]@{40@}.(pack|idx))$ /var/www/git/$1
ScriptAliasMatch \
        "(?x)^/git/(.*/(HEAD | \
                        info/refs | \
                        objects/info/[^/]+ | \
                        git-(upload|receive)-pack))$" \
        /usr/libexec/git-core/git-http-backend/$1
ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/
@end example


@item  Lighttpd 
@samp{mod_cgi} 、 @samp{mod_alias} 、 @samp{mod_auth} 、 @samp{mod_setenv} がロードされていることを確認してから、 @samp{GIT_PROJECT_ROOT} を適切に設定し、すべてのリクエストをCGIにリダイレクトします。

@example
alias.url += ( "/git" => "/usr/lib/git-core/git-http-backend" )
$HTTP["url"] =~ "^/git" @{
        cgi.assign = ("" => "")
        setenv.add-environment = (
                "GIT_PROJECT_ROOT" => "/var/www/git",
                "GIT_HTTP_EXPORT_ALL" => ""
        )
@}
@end example


匿名での読み取りアクセスを有効にする一方、認証された書き込みアクセスを有効にするには:

@example
$HTTP["querystring"] =~ "service=git-receive-pack" @{
        include "git-auth.conf"
@}
$HTTP["url"] =~ "^/git/.*/git-receive-pack$" @{
        include "git-auth.conf"
@}
@end example


ここで、 @samp{git-auth.conf} は以下のようになります:

@example
auth.require = (
        "/" => (
                "method" => "basic",
                "realm" => "Git Access",
                "require" => "valid-user"
               )
)
# ...and set up auth.backend here
@end example


読み取りと書き込みの両方に認証を要求するには:

@example
$HTTP["url"] =~ "^/git/private" @{
        include "git-auth.conf"
@}
@end example

@end table

@noindent

@chapheading ENVIRONMENT

@samp{git http-backend} は、呼び出し元のWebサーバーによって設定された @samp{CGI} 環境変数に依存します:

@itemize 

@item
PATH_INFO (GIT_PROJECT_ROOTが設定されている場合。それ以外の場合はPATH_TRANSLATED)

@item
REMOTE_USER

@item
REMOTE_ADDR

@item
CONTENT_TYPE

@item
QUERY_STRING

@item
REQUEST_METHOD
@end itemize

@samp{GIT_HTTP_EXPORT_ALL} 環境変数を @samp{git-http-backend} に渡して、各リポジトリの @samp{git-daemon-export-ok} ファイルのチェックをバイパスしてから、そのリポジトリのエクスポートを許可することができます。

@samp{GIT_HTTP_MAX_REQUEST_BUFFER} 環境変数(または @samp{http.maxRequestBuffer} 構成変数)は、gitがフェッチ中に処理する最大のrefネゴシエーション要求を変更するように設定できます。これより大きなバッファを必要とするフェッチは成功しません。 通常、この値を変更する必要はありませんが、ref数が非常に多いリポジトリからフェッチする場合に役立つことがあります。 値は単位毎に指定できます(たとえば、100メガバイトの場合は「100M」)。 デフォルトは10メガバイトです。

クライアントは、 @samp{Git-Protocol} HTTPヘッダーを使用して、オプションのプロトコル機能（v2プロトコルなど）を探査(probe)できます。 これらをサポートするには、そのヘッダーの内容が @samp{GIT_PROTOCOL} 環境変数に含まれている必要があります。 ほとんどのウェブサーバーはこのヘッダーを @samp{HTTP_GIT_PROTOCOL} 変数を介してCGIに渡し、@samp{git-http-backend} はそれを @samp{GIT_PROTOCOL} に自動的にコピーします。 ただし、一部のWebサーバーは、渡すヘッダーをより選択的にする場合があります。その場合には明示的に構成する必要があります(上記EXAMPLESセクションのApache構成の「Git-Protocol」の説明を参照してください)。

バックエンドプロセスは、GIT_COMMITTER_NAMEを @samp{$REMOTE_USER} に設定し、 GIT_COMMITTER_EMAILを @samp{$\@{REMOTE_USER@}@@http.$\@{REMOTE_ADDR\@}} に設定して、 @samp{git-receive-pack} によって作成されたreflogにプッシュを実行したリモートユーザの識別情報が含まれるようにします。

すべての @samp{CGI} 環境変数は、 @samp{git-receive-pack} によって呼び出される各フックで使用できます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-http-fetch,,,Top
@chapheading Name

git-http-fetch — HTTPでリモートGitリポジトリからダウンロード

@noindent

@chapheading Synopsis

@display
git http-fetch [-c] [-t] [-a] [-d] [-v] [-w <filename>] [--recover] [--stdin | --packfile=<hash> | <commit>] <URL>
@end display


@noindent

@chapheading DESCRIPTION

HTTPでリモートGitリポジトリからダウンロード

このコマンドは常にすべてのオブジェクトを取得します。歴史的に、ダウンロードするオブジェクトを選択するには、 @samp{-a} と @samp{-c} と @samp{-t} の3つのオプションがありました。それらは現在、何も警告を出さずに無視されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  commit-id 
プルするハッシュ、または [URL]/refs/ 下のファイル名 のいずれか。

@item  @samp{-a, -c, -t} 
これらのオプションは、歴史的な理由により無視されます。

@item  @samp{-v} 
ダウンロードしたものを報告します。

@item  @samp{-w <filename>} 
転送が完了した後、ローカル側ドの $GIT_DIR/refs/<filename> の下のファイル名にcommit-idを書き込みます。

@item  @samp{--stdin} 
(この場合は期待されていない)コマンドラインのコミットIDの代わりに、 @samp{githttp-fetch} は標準入力からの行を以下の形式であると期待します

@example
<commit-id>['\t'<filename-as-in--w>]
@end example

@item  @samp{--packfile=<hash>} 
内部使用のみ。 (この場合は期待されていない)コマンドラインのコミットIDの代わりに、 @samp{git http-fetch} は指定されたURLで直接パックファイルをフェッチし、 index-pack を使用して対応する .idx ファイルと .keep ファイルを生成します。ハッシュは一時ファイルの名前を決定するために使用され、任意です。 index-pack の出力は stdout に出力されます。 @samp{--index-pack-args} が必要です。

@item  @samp{--index-pack-args=<args>} 
内部使用のみ。 ダウンロードしたパックの内容に対して実行するコマンド。引数はスペースで区切られURLエンコードされます。

@item  @samp{--recover} 
ターゲットから到達可能なすべてのものがフェッチされていることを確認します。以前のフェッチが中断された後に使用されます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-http-push,,,Top
@chapheading Name

git-http-push — HTTP/DAV を介してオブジェクトを別のリポジトリにプッシュする

@noindent

@chapheading Synopsis

@display
git http-push [--all] [--dry-run] [--force] [--verbose] <URL> <ref> [<ref>…]
@end display


@noindent

@chapheading DESCRIPTION

リモートに不足しているオブジェクトをリモートリポジトリに送信し、リモートブランチを更新します。

@strong{注} : libcurlが7.16より古い場合、このコマンドは一時的に無効になります。
これは、組み合わせが機能しないことが報告されており、
リポジトリが破損する場合があるためです。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--all} 
リモートリポジトリが現在の状態で完全であると想定しません。また、ローカルrefの履歴全体のすべてのオブジェクトがリモートリポジトリに存在することを確認します。

@item  @samp{--force} 
通常、コマンドは、上書きに使用されたローカルrefの祖先ではないリモートrefの更新を拒否します。このフラグはこのチェックを無効にします。これが意味するのは、リモートリポジトリがコミットを失う可能性があるということです。注意して使用してください。

@item  @samp{--dry-run} 
実際に更新を送信する以外はすべて行います。

@item  @samp{--verbose} 
ローカルでウォークされているオブジェクトのリストと、リモートリポジトリに正常に送信されたオブジェクトのリストを報告します。

@item  @samp{-d} 
@itemx  @samp{-D} 
リモートリポジトリから <ref> を削除します。指定のブランチをリモートHEADにすることはできません。 @samp{-d} を指定する場合は、以下の他の条件も満たす必要があります:

@itemize 

@item
リモートHEADは、ローカルに存在するオブジェクトに名前解決(resolve)できなければなりません。

@item
指定のブランチは、ローカルに存在するオブジェクトに名前解決(resolve)します。

@item
指定のブランチは、リモートHEADの祖先です。
@end itemize

@item  <ref>… 
更新したいリモートrefs
@end table

@noindent

@chapheading SPECIFYING THE REFS

@samp{<ref>} 指定は、単一のパターン、またはコロン @samp{:} で区切られた、そのようなパターンのペアのいずれかです(これは、ref名にコロンを含めることができないことを意味します)。 単一のパターン @samp{<name>} は、 @samp{<name>:<name>} の短縮形です。

各パターン ペア @samp{<src>:<dst>} は、ソース側 (コロンの前) と宛先側 (コロンの後) で構成されます。 プッシュされるrefは、ソース側に一致する一致を見つけることによって決定され、プッシュされる場所は、宛先側を使用して決定されます。

@itemize 

@item
@samp{<src>} がローカルrefの1つと正確に一致しない場合は、エラーになります。

@item
@samp{<dst>} がどのリモートrefとも一致しない場合、以下のどちらかです

@itemize 

@item
"refs/" で始まる必要があります。この場合、文字通り <dst> が宛先として使用されます。

@item
<src> == <dst> かつ <src> に一致するrefは、リモートrefのセットに存在してはなりません。ローカルで一致するref <src> は、宛先の名前として使用されます。
@end itemize
@end itemize

@samp{--force} の指定が無く、<dst> が存在しない場合または <dst> が <src> の適切なサブセット(つまり、祖先)である場合のみリモートに保存されます。 "fast-forward check" (早送りチェック)と呼ばれるこのチェックは、リモートrefを誤って上書きして、そこから他の人のコミットを失うことを回避するために実行されます。

@samp{--force} を使用すると、すべてのrefに対して fast-forward check が無効になります。

オプションで、<ref> パラメーターの前に「+」記号を付けて、そのrefでのみ fast-forward check を無効にすることができます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-imap-send,,,Top
@chapheading Name

git-imap-send — 標準入力からIMAPフォルダへパッチのコレクションを送信します

@noindent

@chapheading Synopsis

@display
git imap-send [-v] [-q] [--[no-]curl]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、 @samp{git format-patch} で生成されたmailboxをIMAPドラフトフォルダーにアップロードします。これにより、mailboxファイルを直接読み取ることができないメールクライアントを使用している場合と同じように、パッチを送信できます。このコマンドは、電子メールのフィールドが「From」、「Date」、「Subject」の順になっている一般的なmailboxでも機能します。

一般的な使用法は以下のようになります:

git format-patch --signoff --stdout --attach origin | git imap-send

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
@itemx  @samp{--verbose} 
にぎやかにしろや。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにしろや。

@item  @samp{--curl} 
トンネリングしない限り、libcurl を使用してIMAPサーバーと通信します。Gitが USE_CURL_FOR_IMAP_SEND オプションを設定せずにビルドされた場合は無視されます。

@item  @samp{--no-curl} 
libcurl を使用する代わりに、git独自のIMAPルーチンを使用してIMAPサーバーと通信します。Gitが NO_OPENSSL オプションを設定してビルドされた場合は無視されます。
@end table

@noindent

@chapheading CONFIGURATION

このツールを使用するには、 @samp{imap.folder} と、 @samp{imap.tunnel} または @samp{imap.host} のいずれかを、適切な値に設定する必要があります。

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  imap.folder 
メールをドロップするフォルダー。通常はドラフトフォルダーです。 例：「INBOX.Drafts」とか「INBOX/Drafts」とか「[Gmail]/Drafts」です。必須です。

@item  imap.tunnel 
サーバーへの直接ネットワーク接続を使用する代わりに、コマンドがパイプされるIMAPサーバーへのトンネルをセットアップするために使用されるコマンド。 imap.host が設定されていない場合に必須です。

@item  imap.host 
サーバーを識別するURL。 非セキュア接続には @samp{imap://} プレフィックスを使用し、セキュア接続には @samp{imaps://} プレフィックスを使用します。 imap.tunnel が設定されている場合は無視されますが、それ以外の場合は必須です。

@item  imap.user 
サーバーにログインするときに使用するユーザー名。

@item  imap.pass 
サーバーにログインするときに使用するパスワード。

@item  imap.port 
サーバー上で接続する整数のポート番号。 デフォルトは、 imap:// ホストの場合は143、 imaps:// ホストの場合は993です。 imap.tunnel が設定されている場合は無視されます。

@item  imap.sslverify 
SSL/TLS接続で使用されるサーバー証明書の検証を有効/無効にするブール値。デフォルトは @samp{true} です。 imap.tunnel が設定されている場合は無視されます。

@item  imap.preformattedHTML 
パッチを送信するときにhtmlエンコーディングの使用を有効/無効にするブール値。 htmlでエンコードされたパッチは <pre> で囲まれ、コンテンツタイプは text/html になります。皮肉なことに、このオプションを有効にすると、Thunderbirdはパッチを plane/text の format=fixed メールとして送信します。デフォルトは @samp{false} です。

@item  imap.authMethod 
IMAPサーバーでの認証の認証方法を指定します。GitがNO_CURLオプションを使用してビルドされた場合、curlバージョンが7.34.0より古い場合、またはgit-imap-sendを @samp{--no-curl} オプションを指定して実行している場合、サポートされるメソッドは @emph{CRAM-MD5} のみです。これが設定されていない場合、「git imap-send」は基本的なIMAPプレーンテキストLOGINコマンドを使用します。
@end table

@noindent

@chapheading EXAMPLES

トンネル(tunnel)モード使用:

@example
[imap]
    folder = "INBOX.Drafts"
    tunnel = "ssh -q -C user@@example.com /usr/bin/imapd ./Maildir 2> /dev/null"
@end example

直接(direct)モード使用:

@example
[imap]
    folder = "INBOX.Drafts"
    host = imap://imap.example.com
    user = bob
    pass = p4ssw0rd
@end example

SSLで直接モードを使用:

@example
[imap]
    folder = "INBOX.Drafts"
    host = imaps://imap.example.com
    user = bob
    pass = p4ssw0rd
    port = 123
    ; sslVerify = false
@end example

@quotation

@strong{Note}

接続の問題が、セットアップしようとしている(またはセットアップ済の)プライベートサーバー @samp{example.com} で使用している証明書が正しく検証されていないことが原因であると思われる場合、トラブルシューティング中に @samp{sslVerify=false} を使用することをお勧めします。
@end quotation

GmailのIMAPインターフェースの使用:

@example
[imap]
        folder = "[Gmail]/Drafts"
        host = imaps://imap.gmail.com
        user = user@@gmail.com
        port = 993
@end example


@quotation

@strong{Note}

"Folder doesn’t exist" というエラーが発生した場合は、代わりに @samp{folder = "[Google Mail]/Drafts"} を使用する必要があります。
@end quotation

@quotation

@strong{Note}

Gmailアカウントが英語以外の言語に設定されている場合、 "Drafts" フォルダの名前がローカライズされます。
@end quotation

コミットを送信する準備ができたら、以下のコマンドを実行します:

@example
$ git format-patch --cover-letter -M --stdout origin/master | git imap-send
@end example

メールクライアントで行の折り返しを無効にしてください(GmailのWebインターフェイスは何があっても行を折り返すため、実際のIMAPクライアント(real IMAP client)を使用する必要があります)。

@noindent

@chapheading CAUTION

電子メールプログラムによって送信される電子メールメッセージがプロジェクトの基準を満たしていることを確認するのは、依然としてあなたの責任です。多くのプロジェクトは、パッチを電子メールに添付することを好みません。一部のメールエージェントは、パッチを失敗させる方法でパッチを変換します(たとえば、行を折り返し、format=flowed として送信します)。これをチェックしておかないと、怒りの炎があなたを襲います。

特に Thunderbird は問題があることが知られています。
Thunderbird のユーザーは右記のWebページにアクセスして詳細を確認できます:
@uref{http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email,http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email}

@noindent

@chapheading SEE ALSO

git-format-patch(1), git-send-email(1), mbox(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-index-pack,,,Top
@chapheading Name

git-index-pack — 既存のパックされたアーカイブのパックインデックスファイル構築

@noindent

@chapheading Synopsis

@display
git index-pack [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>
git index-pack --stdin [--fix-thin] [--keep] [-v] [-o <index-file>]
                  [--[no-]rev-index] [<pack-file>]
@end display


@noindent

@chapheading DESCRIPTION

指定されたファイルからパックされたアーカイブ(.pack)を読み取り、そのためのパックインデックスファイル(.idx)を作成します。オプションで、指定されたパックの逆インデックス(reverse-index)(.rev)を書き込みます。パックされたアーカイブは、パックインデックスとともに、Gitリポジトリの objects/pack/ ディレクトリに配置できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
進捗状況など、何が起こっているかについて詳しく説明します。

@item  @samp{-o <index-file>} 
生成されたパックインデックスを指定のファイルに書き込みます。このオプションがない場合、パックインデックスファイルの名前は、 .pack を .idx に置き換えることにより、パックされたアーカイブファイルの名前から作成されます(パックされたアーカイブの名前が .pack で終わらない場合、プログラムは失敗します)。

@item  @samp{--[no-]rev-index} 
このフラグが指定されている場合、指定されたパックに対応する逆インデックス(reverse index)(@samp{.rev} ファイル)を生成します。 @samp{--verify} が指定されている場合は、既存の逆インデックスが正しいことを確認し保証(ensure)します。 @samp{pack.writeReverseIndex} よりも優先されます。

@item  @samp{--stdin} 
このフラグが指定されると、コマンドラインの代わりにパックがstdinから読み取られ、コピーが <pack-file> に書き込まれます。 <pack-file> が指定されていない場合、パックは現在のGitリポジトリの objects/pack/ ディレクトリに書き込まれ、デフォルト名はパックの内容から決定されます。 <pack-file> が指定されていない場合は、 @samp{--keep} を使用して、このプロセスと @samp{git repack} の間の競合状態を防ぐことを検討してください。

@item  @samp{--fix-thin} 
デルタ化オブジェクトが基づいている除外されたオブジェクトをパックに追加することにより、 @samp{git pack-objects --thin} によって生成された「薄い」パックを修正します(詳細は git-pack-objects(1) を参照)。 このオプションは、@samp{--stdin} と組み合わせた場合にのみ意味があります。

@item  @samp{--keep} 
インデックスを最終的な宛先に移動する前に、関連するパックファイル用に空の .keep ファイルを作成します。このオプションは通常、 @samp{--stdin} と一緒に指定する必要があります。これは、パックに含まれるオブジェクトを使用するようにrefを更新する前に、 @samp{git repack} プロセスが新しく構築されたパックとインデックスを同時に削除しないようにするためです。

@item  @samp{--keep=<msg>} 
@samp{--keep} のように、インデックスを最終的な宛先に移動する前に .keep ファイルを作成しますが、空のファイルを作成するのではなく、 .keep ファイル内で <msg> の後にLFを配置します。 後ですべての .keep ファイル内で <msg> メッセージを検索して、使い古されたものを見つけることができます。

@item  @samp{--index-version=<version>[,<offset>]} 
これは、テストスイートでのみ使用することを目的としています。 生成されたパックインデックスのバージョンを強制し、指定されたオフセットにあるオブジェクトに64ビットインデックスエントリを強制することができます。

@item  @samp{--strict} 
パックに壊れたオブジェクトやリンクが含まれている場合は、終了します(die)。

@item  @samp{--progress-title} 
内部使用のみ。

プログレスバーのタイトルを設定します。 タイトルはデフォルトで「Receiving objects」(オブジェクトの受信)であり、 @samp{--stdin} が指定されている場合は「Indexing objects」(オブジェクトのインデックス作成)です。

@item  @samp{--check-self-contained-and-connected} 
パックに壊れたリンクが含まれている場合は終了(die)します。内部使用のみ。

@item  @samp{--fsck-objects} 
内部使用のみ。

パックに壊れたオブジェクトが含まれている場合は終了(die)します。 存在しない .gitmodulesblob を指すツリーがパックに含まれている場合、 pack/idx ファイルの名前に含まれるハッシュの後に、(呼び出し元が確認できるように)そのブロブのハッシュを出力します(「Notes」参照)。

@item  @samp{--threads=<n>} 
デルタを解決するときに生成するスレッドの数を指定します。これには、インデックスパックを pthreads でコンパイルする必要があります。そうでない場合、このオプションは警告とともに無視されます。これは、マルチプロセッサマシンでのパッキング時間を短縮することを目的としています。ただし、デルタ検索ウィンドウに必要なメモリ量は、スレッド数で乗算されます。0を指定すると、GitはCPUの数を自動検出し、最大3つのスレッドを使用します。

@item  @samp{--max-input-size=<size>} 
パックが <size> を超える場合は、終了(die)します。

@item  @samp{--object-format=<hash-algorithm>} 
パックに指定するオブジェクト形式(ハッシュアルゴリズム)を指定します。有効な値は @samp{sha1} と @samp{sha256} (有効な場合) です。デフォルトは、(@samp{extensions.objectFormat} で設定する、)現在のリポジトリのアルゴリズム、または値が設定されていないかリポジトリの外部にある場合は @samp{sha1} です。

このオプションは @samp{--stdin} オプションと一緒に使用することはできません。

このオプションは実験的なものです！ SHA-256のサポートは実験的なものであり、まだ初期段階です。 SHA-256リポジトリは、通常、「通常の」SHA-1リポジトリと作業を共有できません。 たとえば、SHA-256リポジトリに関連するGit内部ファイル形式は、下位互換性のない方法で変更される可能性があると想定する必要があります。テスト目的でのみ @samp{--object-format=sha256} を使用してください。

@item  @samp{--promisor[=<message>]} 
pack-index をコミットする前に、このパックの @samp{.promisor} ファイルを作成します。 パックが完全に書き込まれるまでパックの名前は最終的ではないため、 @samp{--fix-thin} を使用して プロミサー・パック(promisor pack)を書き込む場合に特に役立ちます。 @samp{<message>} が指定されている場合、その内容は後で参照できるように @samp{.promisor} ファイルに書き込まれます。 詳細については、 @uref{technical/partial-clone.html,partial clone} を参照してください。
@end table

@noindent

@chapheading NOTES

一旦インデックスが作成されると、 pack/idx ファイルの名前に含まれるハッシュがstdoutに出力されます。 @samp{--stdin} も使用された場合、これには @samp{pack\t} 、または新しい @samp{.keep} ファイルが正常に作成された場合は @samp{keep\t} の、どちらかのプレフィックスが付きます。 これは、 上記 @samp{git repack} との競合を防ぐためにロックとして使用されている keep ファイルを削除するのに役立ちます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-init-db,,,Top
@chapheading Name

git-init-db — 空のGitリポジトリを作成

@noindent

@chapheading Synopsis

@display
git init-db [-q | --quiet] [--bare] [--template=<template-directory>] [--separate-git-dir <git-dir>] [--shared[=<permissions>]]
@end display


@noindent

@chapheading DESCRIPTION

これは git-init(1) の同義語です。 git-init(1) コマンドの文書を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-init,,,Top
@chapheading Name

git-init — 空のGitリポジトリを作成するか、既存のリポジトリを再初期化します

@noindent

@chapheading Synopsis

@display
git init [-q | --quiet] [--bare] [--template=<template-directory>]
          [--separate-git-dir <git-dir>] [--object-format=<format>]
          [-b <branch-name> | --initial-branch=<branch-name>]
          [--shared[=<permissions>]] [<directory>]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、空のGitリポジトリを作成します。基本的には、 @samp{objects} と @samp{refs/heads} と @samp{refs/tags} と テンプレートファイルのためのサブディレクトリを持つ @samp{.git} ディレクトリです。コミットのない初期ブランチが作成されます(初期ブランチの名前については、以下の @samp{--initial-branch} オプションを参照してください)。

@samp{$GIT_DIR} 環境変数が設定されている場合、リポジトリのベースに @samp{./.git} の代わりに、 @samp{$GIT_DIR} で指定されたパスを使います。

オブジェクトストレージディレクトリが @samp{$GIT_OBJECT_DIRECTORY} 環境変数を介して指定されている場合、sha1ディレクトリがその下に作成されます。それ以外の場合は、デフォルトの @samp{$GIT_DIR/objects} ディレクトリが使用されます。

既存のリポジトリで「git init」を実行しても安全です。すでに存在するものを上書きすることはありません。「git init」を再実行する主な理由は、新しく追加されたテンプレートを取得することです(または、 @samp{--separate-git-dir} が指定されている場合はリポジトリを別の場所に移動します)。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q} 
@itemx  @samp{--quiet} 
エラーメッセージと警告メッセージのみを出力します。 他のすべての出力は抑制されます。

@item  @samp{--bare} 
ベア(bare)リポジトリを作成します。 @samp{GIT_DIR} 環境変数が設定されていない場合は、現在の作業ディレクトリに設定されます。

@item  @samp{--object-format=<format>} 
リポジトリに設定するブジェクト形式(ハッシュアルゴリズム)を指定します。 有効な値は「sha1」および、(有効な場合、)「sha256」です。「sha1」がデフォルトです。

このオプションは実験的なものです！ SHA-256のサポートは実験的なものであり、まだ初期段階です。 SHA-256リポジトリは、通常、「通常の」SHA-1リポジトリと作業を共有できません。 たとえば、SHA-256リポジトリに関連するGit内部ファイル形式は、下位互換性のない方法で変更される可能性があると想定する必要があります。テスト目的でのみ @samp{--object-format=sha256} を使用してください。

@item  @samp{--template=<template-directory>} 
テンプレートが使用するディレクトリを指定します。 (以下の「TEMPLATE DIRECTORY」セクションを参照してください。)

@item  @samp{--separate-git-dir=<git-dir>} 
リポジトリをディレクトリとして @samp{$GIT_DIR} または @samp{./.git/} に初期化する代わりに、実際のリポジトリへのパスを含むテキストファイルをそこに作成します。 このファイルは、ファイルシステムに依存しない、リポジトリへのGitシンボリックリンクとして機能します。

これが再初期化の場合、リポジトリは指定されたパスに移動されます。

@item  @samp{-b <branch-name>} 
@itemx  @samp{--initial-branch=<branch-name>} 
新しく作成されたリポジトリの最初のブランチには、指定された名前を使用します。 指定しない場合は、デフォルト名にフォールバックします(現在は @samp{master} ですが、将来変更される可能性があります。名前は @samp{init.defaultBranch} 構成変数を使用してカスタマイズできます)。

@item  @samp{--shared[=(false|true|umask|group|all|world|everybody|<perm>)]} 
Gitリポジトリを複数のユーザー間で共有することを指定します。 これにより、同じグループに属するユーザーがそのリポジトリにプッシュできるようになります。 指定すると、構成変数 @samp{core.sharedRepository} が設定され、 @samp{$GIT_DIR} の下のファイルとディレクトリが要求された権限で作成されます。 指定しない場合、Gitは umask(2) によって報告された権限を使用します。

オプションには以下の値を指定できます。値が指定されていない場合、デフォルトで @samp{group} になります。

@table @asis

@item  @samp{umask} (or @samp{false}) 
umask(2) によって報告されたアクセス許可を使用します。 @samp{--shared} が指定されていない場合のデフォルトです。

@item  @samp{group} (or @samp{true}) 
リポジトリをグループ書き込み可能にします(gitグループがすべてのユーザーのプライマリグループではない可能性があるため、 @samp{g+sx} )。 これは、そうしないでいれば安全な umask(2) 値の権限を緩めるために使用されます。 注意: umaskは他の権限ビットにも適用されることに注意してください(たとえば、umaskが @samp{0022} の場合、 @samp{group} を使用しても他の(グループ以外の)ユーザーからの読み取り権限は削除されません)。 リポジトリの権限を正確に指定する方法については、 @samp{0xxx} を参照してください。

@item  @samp{all} (または @samp{world} または @samp{everybody}) 
@samp{group} と同じですが、すべてのユーザーからリポジトリを読めるようにします。

@item  @samp{<perm>} 
各ファイルはモード @samp{<perm>} を持ち、 @samp{<perm>} は、 (訳注:C言語流に、) @samp{0} が先頭に付いた 3 桁の 8 進数です。 @samp{<perm>} は、ユーザーの umask(2) 値を上書きします(@samp{group} や @samp{all} のように許可を緩めるだけではありません)。 @samp{0640} は、 グループで読み取り可能であるが、 グループで書き込み可能でなく、 他のユーザーがアクセスできないリポジトリを作成します。 @samp{0660} は、現在のユーザーとグループが読み書きできるが、 他のユーザーがアクセスできないリポジトリを作成します(ディレクトリと実行可能ファイルは、ユーザーの対応するクラスの @samp{r} ビットから @samp{x} ビットを取得します)。
@end table
@end table

デフォルトでは、共有リポジトリ内で、構成フラグ @samp{receive.denyNonFastForwards} が有効(ture)になっているため、早送り(fast-forward)以外のプッシュを強制することはできません。

directory(ディレクトリ)を指定すると、コマンドはその内部で実行されます。指定のディレクトリが存在しない場合は、作成されます。

@noindent

@chapheading TEMPLATE DIRECTORY

名前がドット(@samp{.})で始まらないテンプレートディレクトリ内のファイルとディレクトリは、作成後に @samp{$GIT_DIR} にコピーされます。

テンプレートディレクトリは、以下のいずれかになります(この優先順位です):

@itemize 

@item
@samp{--template} オプションで指定された引数

@item
@samp{$GIT_TEMPLATE_DIR} 環境変数の内容

@item
@samp{init.templateDir} 構成変数

@item
デフォルトのテンプレートディレクトリ: @samp{/usr/share/git-core/templates}
@end itemize

デフォルトのテンプレートディレクトリには、いくつかのディレクトリ構造、推奨される「除外パターン」(exclude patterns)(gitignore(5) 参照)、およびサンプルフックファイルが含まれています。

サンプルフックはデフォルトですべて無効になっています。 サンプルフックを有効にするには、 @samp{.sample} サフィックスを削除して名前を変更します。

フックの実行に関するより一般的な情報については、 githooks(5) を参照してください。

@noindent

@chapheading EXAMPLES

@table @asis

@item  既存のコードベースの新しいGitリポジトリを開始します 
@example
$ cd /path/to/my/codebase
$ git init      (1)
$ git add .     (2)
$ git commit    (3)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
/path/to/my/codebase/.git ディレクトリを作成します。

@item @pxref{CO1-2,,(2)}
既存のすべてのファイルをインデックスに追加します。

@item @pxref{CO1-3,,(3)}
履歴の最初のコミットとして、初期の状態を記録します。
@end table
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  init.templateDir 
テンプレートのコピー元のディレクトリを指定します。 (git-init(1) の「TEMPLATE DIRECTORY」セクションを参照してください。)

@item  init.defaultBranch 
デフォルトのブランチ名を上書きできます。例えば、新しいリポジトリを初期化するとき。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-instaweb,,,Top
@chapheading Name

git-instaweb — gitwebで作業リポジトリをインスタントにブラウズします

@noindent

@chapheading Synopsis

@display
git instaweb [--local] [--httpd=<httpd>] [--port=<port>]
               [--browser=<browser>]
git instaweb [--start] [--stop] [--restart]
@end display


@noindent

@chapheading DESCRIPTION

ローカルリポジトリを参照するための @samp{gitweb} とWebサーバーを設定するための簡単なスクリプト。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-l} 
@itemx  @samp{--local} 
WebサーバーをローカルIP(127.0.0.1)にのみバインドします。

@item  @samp{-d} 
@itemx  @samp{--httpd} 
実行されるHTTPデーモンのコマンドライン。コマンドラインオプションはここで指定でき、構成ファイルはコマンドラインの最後に追加されます。現在、apache2、lighttpd、mongoose、plackup、python、webrickがサポートされています。（デフォルト：lighttpd）

@item  @samp{-m} 
@itemx  @samp{--module-path} 
モジュールパス(httpdがApacheの場合にのみ必要)。(デフォルト: /usr/lib/apache2/modules )

@item  @samp{-p} 
@itemx  @samp{--port} 
httpdをバインドするポート番号。(デフォルト: 1234)

@item  @samp{-b} 
@itemx  @samp{--browser} 
gitwebページを表示するために使用する必要があるWebブラウザー。これは、gitwebインスタンスのURLとともに @emph{git web--browse} ヘルパースクリプトに渡されます。詳細については、 git-web--browse(1) を参照してください。スクリプトが失敗した場合、URLはstdoutに出力されます。

@item  start 
@itemx  @samp{--start} 
httpdインスタンスを開始して本コマンドを終了します。新しいインスタンスを生成するために、必要に応じて構成ファイルを再生成します。

@item  stop 
@itemx  @samp{--stop} 
httpdインスタンスを停止して本コマンドを終了します。これにより、新しいインスタンスを生成するための構成ファイルが生成されたり、ブラウザーが閉じられたりすることはありません。

@item  restart 
@itemx  @samp{--restart} 
httpdインスタンスを再起動して本コマンドを終了します。 新しいインスタンスを生成するために、必要に応じて構成ファイルを再生成します。
@end table

@noindent

@chapheading CONFIGURATION

あなたは .git/config で構成を指定できます

@example
[instaweb]
        local = true
        httpd = apache2 -f
        port = 4321
        browser = konqueror
        modulePath = /usr/lib/apache2/modules
@end example


構成変数 @samp{instaweb.browser} が設定されていない場合に、@samp{web.browser} が定義されていれば、代わりに @samp{web.browser} が使用されます。詳細については、 git-web--browse(1) を参照してください。

@noindent

@chapheading SEE ALSO

gitweb(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-interpret-trailers,,,Top
@chapheading Name

git-interpret-trailers — コミットメッセージの構造化情報を追加またはパースします

@noindent

@chapheading Synopsis

@display
git interpret-trailers [--in-place] [--trim-empty]
                        [(--trailer <token>[(=|:)<value>])…]
                        [--parse] [<file>…]
@end display


@noindent

@chapheading DESCRIPTION

Add or parse @emph{trailer} lines that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message. For example, in the following commit message

@example
subject

Lorem ipsum dolor sit amet, consectetur adipiscing elit.

Signed-off-by: Alice <alice@@example.com>
Signed-off-by: Bob <bob@@example.com>
@end example


the last two lines starting with "Signed-off-by" are trailers.

This command reads commit messages from either the <file> arguments or the standard input if no <file> is specified. If @samp{--parse} is specified, the output consists of the parsed trailers. Otherwise, this command applies the arguments passed using the @samp{--trailer} option, if any, to each input file. The result is emitted on the standard output.

This command can also operate on the output of git-format-patch(1), which is more elaborate than a plain commit message. Namely, such output includes a commit message (as above), a "---" divider line, and a patch part. For these inputs, the divider and patch parts are not modified by this command and are emitted as is on the output, unless @samp{--no-divider} is specified.

Some configuration variables control the way the @samp{--trailer} arguments are applied to each input and the way any existing trailer in the input is changed. They also make it possible to automatically add some trailers.

By default, a @emph{<token>=<value>} or @emph{<token>:<value>} argument given using @samp{--trailer} will be appended after the existing trailers only if the last trailer has a different (<token>, <value>) pair (or if there is no existing trailer). The <token> and <value> parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed <token> and <value> will appear in the output like this:

@example
token: value
@end example


This means that the trimmed <token> and <value> will be separated by @samp{': '} (one colon followed by one space). For convenience, the <token> can be a shortened string key (e.g., "sign") instead of the full string which should appear before the separator on the output (e.g., "Signed-off-by"). This can be configured using the @emph{trailer.<token>.key} configuration variable.

By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear at the end of the input. A blank line will be added before the new trailer if there isn’t one already.

Existing trailers are extracted from the input by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the input or be the last non-whitespace lines before a line that starts with @emph{---} (followed by a space or the end of the line).

When reading trailers, there can be no whitespace before or inside the <token>, but any number of regular space and tab characters are allowed between the <token> and the separator. There can be whitespaces before, inside or after the <value>. The <value> may be split over multiple lines with each subsequent line starting with at least one whitespace, like the "folding" in RFC 822. Example:

@example
token: This is a very long value, with spaces and
  newlines in it.
@end example


Note that trailers do not follow (nor are they intended to follow) many of the rules for RFC 822 headers. For example they do not follow the encoding rule.

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--in-place} 
その場でファイルを編集します。

@item  @samp{--trim-empty} 
If the <value> part of any trailer contains only whitespace, the whole trailer will be removed from the output. This applies to existing trailers as well as new trailers.

@item  @samp{--trailer <token>[(=|:)<value>]} 
Specify a (<token>, <value>) pair that should be applied as a trailer to the inputs. See the description of this command.

@item  @samp{--where <placement>} 
@itemx  @samp{--no-where} 
すべての新しいトレーラーが追加される場所を指定します。 @samp{--where} で指定する設定は、すべての構成変数をオーバーライドし、 @samp{--where} または @samp{--no-where} が次に出現するまですべての @samp{--trailer} オプションに適用されます。 <placement> として可能な値は、 @samp{after} または @samp{before} または @samp{end} または @samp{start} です。

@item  @samp{--if-exists <action>} 
@itemx  @samp{--no-if-exists} 
Specify what action will be performed when there is already at least one trailer with the same <token> in the input. A setting provided with @emph{--if-exists} overrides all configuration variables and applies to all @emph{--trailer} options until the next occurrence of @emph{--if-exists} or @emph{--no-if-exists}. Possible actions are @samp{addIfDifferent}, @samp{addIfDifferentNeighbor}, @samp{add}, @samp{replace} and @samp{doNothing}.

@item  @samp{--if-missing <action>} 
@itemx  @samp{--no-if-missing} 
Specify what action will be performed when there is no other trailer with the same <token> in the input. A setting provided with @emph{--if-missing} overrides all configuration variables and applies to all @emph{--trailer} options until the next occurrence of @emph{--if-missing} or @emph{--no-if-missing}. Possible actions are @samp{doNothing} or @samp{add}.

@item  @samp{--only-trailers} 
トレーラーのみを出力し、入力の他の部分は出力しません。

@item  @samp{--only-input} 
入力に存在するトレーラーのみを出力します。コマンドラインや、構成された @samp{trailer.*} ルールに従って追加することはありません。

@item  @samp{--unfold} 
トレーラーの複数行に渡る先頭空白による継続を解除して、各トレーラーが1行で完結するよう出力します。

@item  @samp{--parse} 
@samp{--only-trailers --only-input --unfold} の便利なエイリアス。

@item  @samp{--no-divider} 
@samp{---} をコミットメッセージの終わりとして扱わないでください。(電子メールや `git format-patch`の出力が含まれておらず、)入力にコミットメッセージ自体だけが含まれていることがわかっている場合にこれを使用します。
@end table

@noindent

@chapheading CONFIGURATION VARIABLES

@table @asis

@item  trailer.separators 
このオプションは、どの文字がトレーラー区切り文字として認識されるかを示します。 デフォルトでは、 @samp{:} のみがトレーラー区切り文字として認識されます。ただし、他のgitコマンドとの互換性のために、コマンドラインでは @samp{=} が常に受け入れられます。

このオプションで指定された最初の1文字は、このトレーラーの構成で別の区切り文字が指定されていない場合に使用されるデフォルトの文字になります。

たとえば、このオプションの値が "%=$" の場合、 @samp{<token><sep><value>} の形式を使用し、<sep> に @samp{%} または @samp{=} または @samp{$} と、空白達を含む行のみトレーラーと見なされます。 また、 @samp{%} がデフォルトの区切り文字として使用されるため、デフォルトでは、トレーラーは @samp{<token>% <value>} と出力されます(デフォルトの場合はこのようにトークンと値の間に1つの区切り文字列の最初の文字(パーセント記号)と「1つのスペース」が出力されます)。

@item  trailer.where 
このオプションは、新しいトレーラーが追加される場所を示します。

これは、デフォルトの @samp{end} の他に @samp{start} または @samp{after} または @samp{before} にすることができます。

@samp{end} の場合、新しいトレーラーはそれぞれ、既存のトレーラーの最後に出力されます。

@samp{start} の場合、新しい各トレーラーは、既存のトレーラーの最後ではなく、最初に出力されます。

@samp{after} の場合、新しいトレーラーはそれぞれ、同じ <token> を持つ最後のトレーラーの直後に出力されます。

@samp{before} の場合、新しい各トレーラーは、同じ <token> を持つ最初のトレーラーの直前に出力されます。

@item  trailer.ifexists 
This option makes it possible to choose what action will be performed when there is already at least one trailer with the same <token> in the input.

このオプションの有効な値は、 @samp{addIfDifferentNeighbor} (デフォルト)、 または @samp{addIfDifferent} または @samp{add} または @samp{replace} または @samp{doNothing} です。

@samp{addIfDifferentNeighbor} を使用すると、同一のペア(<token>、<value>)のトレーラーが、新しいトレーラーが追加される行の上または下にない場合にのみ、新しいトレーラーが追加されます。

With @samp{addIfDifferent}, a new trailer will be added only if no trailer with the same (<token>, <value>) pair is already in the input.

With @samp{add}, a new trailer will be added, even if some trailers with the same (<token>, <value>) pair are already in the input.

@samp{replace} を使用すると、同じ <token> を持つ既存のトレーラーが削除され、新しいトレーラーが追加されます。削除されるトレーラーは、新しいトレーラーが追加される場所に最も近い(同じ <token> を持つ)トレーラーになります。

With @samp{doNothing}, nothing will be done; that is no new trailer will be added if there is already one with the same <token> in the input.

@item  trailer.ifmissing 
This option makes it possible to choose what action will be performed when there is not yet any trailer with the same <token> in the input.

このオプションの有効な値は、 @samp{add} (デフォルト)と @samp{doNothing} です。

`add`を使用すると、新しいトレーラーが追加されます。

@samp{doNothing} を使用すると、何も実行されません。

@item  trailer.<token>.key 
この キー(key) は、トレーラーで <token> の代わりに使用されます。このキーの後ろに、区切り文字を出力してから、いくつかのスペース文字を出力できます。デフォルトでは、有効な区切り文字は @samp{:} のみですが、これは @samp{trailer.separators} 構成変数を使用して変更できます。

トレーラーを追加するときに、この構成値内に区切り文字がある場合、 <token> とデフォルトの区切り文字の両方(つまり、<token><区切り文字><空白1つ>)がキーで置き換えられます。

@item  trailer.<token>.where 
このオプションは、「trailer.where」構成変数と同じ値を取り、指定された <token> を持つトレーラーに対してそのオプションで指定されたものをオーバーライドします。

@item  trailer.<token>.ifexists 
このオプションは、「trailer.ifexists」構成変数と同じ値を取り、指定された <token> を持つトレーラーに対してそのオプションで指定されたものをオーバーライドします。

@item  trailer.<token>.ifmissing 
このオプションは、「trailer.ifmissing」構成変数と同じ値を取り、指定された <token> を持つトレーラーに対してそのオプションで指定されたものをオーバーライドします。

@item  trailer.<token>.command 
Deprecated in favor of @emph{trailer.<token>.cmd}. This option behaves in the same way as @emph{trailer.<token>.cmd}, except that it doesn’t pass anything as argument to the specified command. Instead the first occurrence of substring $ARG is replaced by the <value> that would be passed as argument.

Note that $ARG in the user’s command is only replaced once and that the original way of replacing $ARG is not safe.

@samp{trailer.<token>.cmd} と @samp{trailer.<token>.command} の両方が同じ<token>で指定されている場合、 @samp{trailer.<token>.cmd} が使用され、 @samp{trailer.<token>.command} は無視されます。

@item  trailer.<token>.cmd 
This option can be used to specify a shell command that will be called once to automatically add a trailer with the specified <token>, and then called each time a @emph{--trailer <token>=<value>} argument is specified to modify the <value> of the trailer that this option would produce.

指定のコマンドを最初に呼び出して、指定の <token> のトレーラーを追加すると、動作は、「git interpret-trailers」コマンドの先頭に特別な @samp{--trailer <token>=<value>} 引数が追加されたかのように振る舞います。ここで、 <value> は、先頭と末尾の空白が削除された、コマンドからの標準出力と見なされます。

いくつかの @samp{--trailer <token>=<value>} 引数がコマンドラインで渡された場合、同じ <token> を持つこれらの引数ごとにコマンドが1回呼び出されます。そして、これらの引数の <value> 部分は、もしあれば、最初の引数としてコマンドに渡されます。このようにして、コマンドは @samp{--trailer <token>=<value>} 引数で渡された <value> から計算された <value> を生成できます。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
Configure a @emph{sign} trailer with a @emph{Signed-off-by} key, and then add two of these trailers to a commit message file:

@example
$ git config trailer.sign.key "Signed-off-by"
$ cat msg.txt
subject

body text
$ git interpret-trailers --trailer 'sign: Alice <alice@@example.com>' --trailer 'sign: Bob <bob@@example.com>' <msg.txt
subject

body text

Signed-off-by: Alice <alice@@example.com>
Signed-off-by: Bob <bob@@example.com>
@end example


@item
Use the @samp{--in-place} option to edit a commit message file in place:

@example
$ cat msg.txt
subject

body text

Signed-off-by: Bob <bob@@example.com>
$ git interpret-trailers --trailer 'Acked-by: Alice <alice@@example.com>' --in-place msg.txt
$ cat msg.txt
subject

body text

Signed-off-by: Bob <bob@@example.com>
Acked-by: Alice <alice@@example.com>
@end example


@item
最後のコミットをパッチとして抽出し、それに「Cc」トレーラーと「Reviewed-by」トレーラーを追加します:

@example
$ git format-patch -1
0001-foo.patch
$ git interpret-trailers --trailer 'Cc: Alice <alice@@example.com>' --trailer 'Reviewed-by: Bob <bob@@example.com>' 0001-foo.patch >0001-bar.patch
@end example


@item
「Signed-off-by: 」がまだない場合にのみ、作者情報を含む「Signed-off-by: 」を自動的に追加するコマンドを伴って「sign」トレーラーを構成し、それがどのように機能するかを示します:

@example
$ cat msg1.txt
subject

body text
$ git config trailer.sign.key "Signed-off-by: "
$ git config trailer.sign.ifmissing add
$ git config trailer.sign.ifexists doNothing
$ git config trailer.sign.cmd 'echo "$(git config user.name) <$(git config user.email)>"'
$ git interpret-trailers --trailer sign <msg1.txt
subject

body text

Signed-off-by: Bob <bob@@example.com>
$ cat msg2.txt
subject

body text

Signed-off-by: Alice <alice@@example.com>
$ git interpret-trailers --trailer sign <msg2.txt
subject

body text

Signed-off-by: Alice <alice@@example.com>
@end example


@item
trailer.fix.key に 区切り文字 @samp{#} を含み、その後ろにスペースを含まないキーを使用して「fix」トレーラーを構成し、それがどのように機能するかを示します:

@example
$ git config trailer.separators ":#"
$ git config trailer.fix.key "Fix #"
$ echo "subject" | git interpret-trailers --trailer fix=42
subject

Fix #42
@end example


@item
cmdを使用して「ヘルプ」トレーラーを構成します。スクリプト @samp{glog-find-author} を使用して、gitリポジトリのgitログから指定された作成者IDを検索し、その動作を示します。

@example
$ cat ~/bin/glog-find-author
#!/bin/sh
test -n "$1" && git log --author="$1" --pretty="%an <%ae>" -1 || true
$ cat msg.txt
subject

body text
$ git config trailer.help.key "Helped-by: "
$ git config trailer.help.ifExists "addIfDifferentNeighbor"
$ git config trailer.help.cmd "~/bin/glog-find-author"
$ git interpret-trailers --trailer="help:Junio" --trailer="help:Couder" <msg.txt
subject

body text

Helped-by: Junio C Hamano <gitster@@pobox.com>
Helped-by: Christian Couder <christian.couder@@gmail.com>
@end example


@item
cmdを使用して @samp{ref} トレーラーを構成し、スクリプト @samp{glog-grep} を使用して、gitリポジトリのgitログから最後の関連するコミットをgrepし、それがどのように機能するかを示します。

@example
$ cat ~/bin/glog-grep
#!/bin/sh
test -n "$1" && git log --grep "$1" --pretty=reference -1 || true
$ cat msg.txt
subject

body text
$ git config trailer.ref.key "Reference-to: "
$ git config trailer.ref.ifExists "replace"
$ git config trailer.ref.cmd "~/bin/glog-grep"
$ git interpret-trailers --trailer="ref:Add copyright notices." <msg.txt
subject

body text

Reference-to: 8bc9a0c769 (Add copyright notices., 2005-04-07)
@end example


@item
関連するコミットの件名を出力し、それがどのように機能するかを示すコマンドを使用して、「see」トレーラーを構成します:

@example
$ cat msg.txt
subject

body text

see: HEAD~2
$ cat ~/bin/glog-ref
#!/bin/sh
git log -1 --oneline --format="%h (%s)" --abbrev-commit --abbrev=14
$ git config trailer.see.key "See-also: "
$ git config trailer.see.ifExists "replace"
$ git config trailer.see.ifMissing "doNothing"
$ git config trailer.see.cmd "glog-ref"
$ git interpret-trailers --trailer=see <msg.txt
subject

body text

See-also: fe3187489d69c4 (subject of related commit)
@end example


@item
空の値を持ついくつかのトレーラーを使用してコミットテンプレートを構成し(sedを使用してトレーラーの後に末尾のスペースを出力および保持します)、次に、「git interpret-trailers」を使用するcommit-msgフックを構成して、値が空のトレーラーを削除し、「git-version」トレーラーを追加します:

@example
$ cat temp.txt
***subject***

***message***

Fixes: Z
Cc: Z
Reviewed-by: Z
Signed-off-by: Z
$ sed -e 's/ Z$/ /' temp.txt > commit_template.txt
$ git config commit.template commit_template.txt
$ cat .git/hooks/commit-msg
#!/bin/sh
git interpret-trailers --trim-empty --trailer "git-version: \$(git describe)" "\$1" > "\$1.new"
mv "\$1.new" "\$1"
$ chmod +x .git/hooks/commit-msg
@end example

@end itemize

@noindent

@chapheading SEE ALSO

git-commit(1), git-format-patch(1), git-config(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-log,,,Top
@chapheading Name

git-log — コミットのログを表示

@noindent

@chapheading Synopsis

@display
git log [<options>] [<revision-range>] [[--] <path>…]
@end display


@noindent

@chapheading DESCRIPTION

コミットのログを表示します。

指定されたコミットから「親」リンクをたどることによって到達可能なコミットをリストしますが、その前に ^ が付いているコミットから到達可能なコミットは除外します。デフォルトでは、出力は時系列の逆順で表示されます。

これは集合演算と考えることができます。 コマンドラインで指定されたコミットのいずれかから到達可能なコミットのセットを形成し、 ^ が前に付いたコミットのいずれかから到達可能なコミットがそのセットから差し引かれます。差し引かれた残りのコミットは、コマンドの出力に出力されるものです。他のさまざまなオプションとパスパラメータ(pats parameters)を使用して、結果をさらに制限できます。

したがって、以下のコマンド:

@example
$ git log foo bar ^baz
@end example


は、「foo または bar から到達可能であるが、 baz からは到達できないすべてのコミットをリストする」を意味します。

特別な表記 @samp{<commit1>..<commit2>} は、 @samp{^<commit1> <commit2>} の省略形として使用できます。たとえば、以下のどちらかを同じ意味で使用できます:

@example
$ git log origin..HEAD
$ git log HEAD ^origin
@end example


もう1つの特別な表記法は、マージに役立つ @samp{<commit1>...<commit2>} です。結果として得られるコミットのセットは、2つのオペランド間の対称差(symmetric difference)です。以下の2つのコマンドは同等です:

@example
$ git log A B --not $(git merge-base --all A B)
$ git log A...B
@end example


このコマンドは、 git-rev-list(1) コマンドに適用可能なオプションを使用して、表示内容と方法を制御し、そして git-diff(1) コマンドに適用可能なオプションを使用して、各コミットによって導入される変更の表示方法を制御します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--follow} 
ファイル名が途中でリネームされていてもそこで中断することなく、そのファイルの一覧を続けて表示します(単一のファイルに対してのみ機能します)。

@item  @samp{--no-decorate} 
@itemx  @samp{--decorate[=short|full|auto|no]} 
表示されているコミットのref名を出力します。 short が指定されている場合、ref名の接頭辞 refs/heads/ と refs/tags/ と refs/remotes/ は出力されません。 full が指定されている場合、完全なref名(接頭辞を含む)が出力されます。 auto が指定されている場合、出力が端末に送られると、ref名は short が指定されているかのように表示され、それ以外の場合はref名は表示されません。オプション @samp{--decorate} は @samp{--decorate=short} の省略形です。構成されている場合はデフォルトで構成値の @samp{log.decorate} になり、構成されていない場合は @samp{auto} になります。

@item  @samp{--decorate-refs=<pattern>} 
@itemx  @samp{--decorate-refs-exclude=<pattern>} 
候補ごとに、@samp{--decorate-refs-exclude} に指定されたパターンのいずれにもマッチしない場合、または @samp{--decorate-refs} に指定されたパターンのいずれにもマッチしない場合は、装飾に使用しないでください。 @samp{log.excludeDecoration} 構成オプションを使用すると、装飾からrefを除外できますが、明示的な @samp{--decorate-refs} パターンは @samp{log.excludeDecoration} のマッチングをオーバーライドします。

これらのオプションまたは構成設定のいずれも指定されていない場合、参照が @samp{HEAD} または @samp{refs/heads/} または @samp{refs/remotes/} または @samp{refs/stash/} または @samp{refs/tags/} にマッチする場合、参照は装飾(decoration)として使用されます。

@item  @samp{--clear-decorations} 
このオプションを指定すると、以前のすべての @samp{--decorate-refs} または @samp{--decorate-refs-exclude} オプションがクリアされ、すべての参照が含まれるようにデフォルトの装飾(decoration)フィルタが緩和されます。 このオプションは、構成値 @samp{log.initialDecorationSet} が @samp{all} に設定されている場合に想定されます。

@item  @samp{--source} 
各コミットがコマンドラインで指定のコミットのいずれかから到達できる祖先である場合、当該コミット毎にコマンドラインで指定のコミットのref名で表示します。

@item  @samp{--[no-]mailmap} 
@itemx  @samp{--[no-]use-mailmap} 
mailmapファイルを使用して、作者名(author names)とコミッター名(committer names)と電子メールアドレス(email addresses)を、正式な本名と電子メールアドレスにマップします。 git-shortlog(1) 参照。

@item  @samp{--full-diff} 
このフラグがない場合、 @samp{git log -p <path>...} は、指定されたパスに関連(touch)するコミットを示し、その指定されたパスについての差分を取ります。これにより、指定されたパスに関連するコミットの完全な差分が表示されます。これは、 "<path>…" がコミットのみを制限し、それらのコミットの差分を制限しないことを意味します。

これは、例えば @samp{--stat} によって生成されたものなど、すべての差分ベースの出力タイプに影響することに注意してください。

@item  @samp{--log-size} 
各コミットの出力に “log size <number>” という行を含めます。ここで、 <number> はそのコミットのメッセージの長さ(バイト単位)です。プログラムがスペースをコミットのメッセージ読み込み前に割り当てられるようにして、 @samp{git log} 出力からログメッセージを読み取るツールを高速化することを目的としています。

@item  @samp{-L<start>,<end>:<file>} 
@itemx  @samp{-L:<funcname>:<file>} 
<file> 内で、 @samp{<start>,<end>} 、または正規表現の関数名 <funcname> で指定された行範囲をトレースします。pathspec リミッターを指定することはできません。これは現在、単一のリビジョンから開始するウォークに制限されています。つまり、0個または1個の正のリビジョン引数のみを指定でき、 <start> と <end> (または <funcname>) が開始リビジョンに存在する必要があります。このオプションは複数回指定できます。これは @samp{--patch} オプションの機能を含んでいます。パッチ出力は @samp{--no-patch} を使用して抑制できますが、他の差分形式(つまり、 @samp{--raw}, @samp{--numstat}, @samp{--shortstat}, @samp{--dirstat}, @samp{--summary}, @samp{--name-only}, @samp{--name-status}, @samp{--check})は現在実装されていません。

<start> と <end> は、以下のいずれかの形式です:

@itemize 

@item
数値

<start> または <end> が数値の場合、絶対行番号を指定します(行は1から数えます)。

@item
@samp{/regex/}

この形式は、指定されたPOSIX正規表現に一致する最初の行を使用します。 <start> が正規表現の場合、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 <start> が @samp{^/regex/} の場合、ファイルの先頭から検索します。 <end> が正規表現の場合、 <start> で指定された行から検索開始します。

@item
+offset or -offset

これは <end> に対してのみ有効であり、 <start> で指定された行の前後の行数を指定します。
@end itemize

<start> と <end> の代わりに @samp{:<funcname>} が指定されている場合、これは <funcname> に一致する最初の関数名行から次の関数名行までの範囲を示す正規表現です。 @samp{:<funcname>} は、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 @samp{^:<funcname>} はファイルの先頭から検索します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  <revision-range> 
指定されたリビジョン範囲のコミットのみを表示します。 <revision-range> が指定されていない場合、デフォルトで @samp{HEAD} (つまり、現在のコミットにつながる履歴全体)になります。 @samp{origin..HEAD} は、現在のコミット(つまり、@samp{HEAD})から到達可能なすべてのコミットを指定しますが、`origin`からは指定しません。 <revision-range> の綴り方の完全なリストについては、 gitrevisions(7) の「Specifying Ranges」節を参照してください。

@item  [--] <path>… 
指定されたパスに一致するファイルがどのようになったかを説明するのに必要十分なコミットのみを表示します。詳細およびその他の簡略化モードについては、以下の「History Simplification」を参照してください。

混乱が生じた場合、パスをオプションまたはリビジョン範囲から分離するために、パスの前に @samp{--} を付ける必要がある場合があります。
@end table

@noindent

@heading Commit Limiting

ここで説明されている特別な表記法を使用してリストする必要があるコミットの範囲を指定することに加えて、追加のコミット制限が適用される場合があります。

より多くのオプションを使用すると、通常、出力がさらに制限されます(たとえば、 @samp{--since=<date1>} は @samp{<date1>} より新しいコミットに制限され、 @samp{--grep=<pattern>} と一緒に使用すると、ログメッセージに @samp{<pattern>} と一致する行があるコミットにさらに制限されます)。

注意: これらは、 @samp{--reverse} などのコミット順序およびフォーマットオプションの前に適用されることに注意してください。

@table @asis

@item  @samp{-<number>} 
@itemx  @samp{-n <number>} 
@itemx  @samp{--max-count=<number>} 
出力するコミットの数を制限します。

@item  @samp{--skip=<number>} 
コミット出力の表示を開始する前に、number 個のコミットをスキップします。

@item  --since=<date> 
@itemx  @samp{--after=<date>} 
指定の日付よりも新しいコミットを表示します。

@item  @samp{--since-as-filter=<date>} 
特定の日付より新しいすべてのコミットを表示します。 これは、特定の日付より古い最初のコミットで停止するのではなく、範囲内のすべてのコミットを訪問します。

@item  @samp{--until=<date>} 
@itemx  @samp{--before=<date>} 
指定の日付より古いコミットを表示します。

@item  @samp{--author=<pattern>} 
@itemx  @samp{--committer=<pattern>} 
コミット出力を、指定されたパターン(正規表現)に一致する作者(author)/コミッター(committer)ヘッダー行を持つものに制限します。複数の @samp{--author=<pattern>} がある場合、作者が指定されたパターンのいずれかに一致するコミットが選択されます(複数の @samp{--committer=<pattern>} の場合も同様)。

@item  @samp{--grep-reflog=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するreflogエントリを持つものに制限します。 複数の @samp{--grep-reflog} を使用すると、 指定されたパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。 @samp{--walk-reflogs} が使用されていない限り、 このオプションを使用するとエラーになります。

@item  @samp{--grep=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するログメッセージを持つものに制限します。 複数の @samp{--grep=<pattern>} を使用すると、 指定されたパターンのいずれかにメッセージが一致するコミットが選択されます(全てに一致するコミットだけを選択したい場合、@samp{--all-match} を参照してください)。

@samp{--notes} が有効な場合、ノートからのメッセージは、ログメッセージの一部であるかのようにマッチングされます。

@item  @samp{--all-match} 
コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての @samp{--grep} に一致するものに制限します。

@item  @samp{--invert-grep} 
コミット出力を、 @samp{--grep=<pattern>} で指定されたパターンと一致しないログメッセージを持つものに制限します。

@item  @samp{-i} 
@itemx  @samp{--regexp-ignore-case} 
大文字小文字に関係なく、正規表現の制限パターンに一致します。

@item  @samp{--basic-regexp} 
制限パターンを基本正規表現として扱います。これがデフォルトです。

@item  @samp{-E} 
@itemx  @samp{--extended-regexp} 
制限パターンを、デフォルトの基本正規表現の代わりに拡張正規表現として扱います。

@item  @samp{-F} 
@itemx  @samp{--fixed-strings} 
制限パターンを固定文字列として扱います(パターンを正規表現として解釈しないでください)。

@item  @samp{-P} 
@itemx  @samp{--perl-regexp} 
制限パターンをPerl互換の正規表現として扱います。

これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。Gitが当該のサポート付きでコンパイルされていない場合、このオプションを提供すると、Gitが死にます(die)。

@item  @samp{--remove-empty} 
指定されたパスがツリーから見えなくなったら停止(stop)します。

@item  @samp{--merges} 
マージコミットのみを印刷します。これは @samp{--min-parents=2} とまったく同じです。

@item  @samp{--no-merges} 
複数の親を持つコミットを出力しない。これは @samp{--max-parents=1} とまったく同じです。

@item  @samp{--min-parents=<number>} 
@itemx  @samp{--max-parents=<number>} 
@itemx  @samp{--no-min-parents} 
@itemx  @samp{--no-max-parents} 
量の多少に関わらず、 とにかく複数の親コミットがあるコミットのみを表示します。特に、 @samp{--max-parents=1} は @samp{--no-merges} と同じであり、 @samp{--min-parents=2} は @samp{--merges} と同じです。 @samp{--max-parents=0} はすべてのルートコミットを提供し、 @samp{--min-parents=3} はすべてのタコ足マージ(octopus merges)を示します。

@samp{--no-min-parents} と @samp{--no-max-parents} は、これらの制限を(制限なしに)再度リセットします。同等の形式は、 @samp{--min-parents=0} (すべてのコミットに0個以上の親があります)および @samp{--max-parents=-1} (マイナスの数は上限がないことを示します)です。

@item  @samp{--first-parent} 
インクルードするコミットを探すとき、マージ・コミットの最初の親コミットのみをたどります。 このオプションは、特定のトピックブランチの進化を表示するときに、より良い概要を提供できます。トピックブランチへのマージは、時々更新されるアップストリームに調整することだけである傾向があり、このオプションを使用すると、そのようなマージによって履歴に取り込まれた個々のコミットを無視できます。

このオプションは、マージコミットのデフォルトのdiff形式も @samp{first-parent} に変更します。詳細については、 @samp{--diff-merges=first-parent} を参照してください。

@item  @samp{--exclude-first-parent-only} 
( @samp{^} を使用して)除外するコミットを見つけるときは、 判明したマージ・コミットの最初の親コミットのみに従います。 任意のマージが有効なトピック・ブランチの変更になる可能性がある場合、 これを使用して、 リモート・ブランチから分岐したポイントからトピック・ブランチ内の一連の変更を見つけることができます。

@item  @samp{--not} 
次に現れる @samp{--not} までの間、後続のすべてのリビジョン指定子の @samp{^}(カレット)接頭辞(またはその欠如)の意味を逆にします。

@item  @samp{--all} 
@samp{refs/} 内のすべてのrefが HEAD とともに、コマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--branches[=<pattern>]} 
@samp{refs/heads} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--tags[=<pattern>]} 
@samp{refs/tags} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合は、指定されたシェルグロブ(shell glob)に一致するタグにタグを制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--remotes[=<pattern>]} 
@samp{refs/remotes} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、リモート追跡ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--glob=<glob-pattern>} 
シェルグロブ <glob-pattern> に一致するすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。先頭の @samp{refs/} は、欠落している場合は自動的に先頭に追加されます。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--exclude=<glob-pattern>} 
次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} が別の方法で考慮する <glob-pattern> に一致するrefを含めないでください。このオプションを繰り返すと、次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} オプションまで除外パターンが蓄積されます(他のオプションまたは引数は、蓄積されたパターンをクリアしません)。

与えられたパターンは、それぞれ @samp{--branches} または @samp{--tags} または @samp{--remotes} に適用される場合、 @samp{refs/heads} または @samp{refs/tags} または @samp{refs/remotes} で始まるべきではありません。 @samp{--glob} または @samp{--all} に適用する場合は、 @samp{refs/} で始める必要があります。末尾の "/*" を意図している場合は、明示的に指定する必要があります。

@item  @samp{--exclude-hidden=[fetch|receive|uploadpack]} 
Do not include refs that would be hidden by @samp{git-fetch}, @samp{git-receive-pack} or @samp{git-upload-pack} by consulting the appropriate @samp{fetch.hideRefs}, @samp{receive.hideRefs} or @samp{uploadpack.hideRefs} configuration along with @samp{transfer.hideRefs} (see git-config(1)). This option affects the next pseudo-ref option @samp{--all} or @samp{--glob} and is cleared after processing them.

@item  @samp{--reflog} 
reflogsで言及されているすべてのオブジェクトがコマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--alternate-refs} 
代替リポジトリのref先端として言及されているすべてのオブジェクトがコマンドラインにリストされているかのように見せかけます。 代替リポジトリは、 オブジェクトディレクトリが @samp{objects/info/alternates} で指定されているリポジトリです。 インクルードされたオブジェクトのセットは、 @samp{core.alternateRefsCommand} などによって変更できます。 git-config(1)を参照してください。

@item  @samp{--single-worktree} 
デフォルトでは、 作業ツリーが複数ある場合、 @samp{--all} と @samp{-reflog} と @samp{--indexed-objects} では、 すべての作業ツリーが検査されます(git-worktree(1)を参照)。 このオプションは、 現在の作業ツリーのみを調べるように強制します。

@item  @samp{--ignore-missing} 
入力に無効なオブジェクト名が含まれている場合、そもそもその不正な入力が行われていないかのように見せかけます。

@item  @samp{--bisect} 
コマンドラインで、bad bisection ref @samp{refs/bisect/bad} がリストされ、その後に @samp{--not} と good bisection ref @samp{refs/bisect/good-*} が続くかのように見せかけます。

@item  @samp{--stdin} 
In addition to getting arguments from the command line, read them for standard input as well. This accepts commits and pseudo-options like @samp{--all} and @samp{--glob=}. When a @samp{--} separator is seen, the following input is treated as paths and used to limit the result.

@item  @samp{--cherry-mark} 
@samp{--cherry-pick}（以下を参照）と同様ですが、同等のコミットを省略せずに @samp{=} と印し、同等でないコミットを @samp{+} と印します。

@item  @samp{--cherry-pick} 
コミットの組を対称差(symmetric difference)に制限する場合、「反対側」の別のコミットと同じ変更を導入するコミットを省略します。

たとえば、@samp{A} と @samp{B} の2つのブランチがある場合、それらの片側だけですべてのコミットを一覧表示する通常の方法は、 @samp{--left-right} を使用することです(@samp{--left-right} オプションの説明の以下の例を参照してください)。ただし、他のブランチからは(ブランチAと重複しない)厳選されたコミットが表示されます(たとえば、「3rd onb」はブランチAからチェリーピックされる可能性があります)。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。

@item  @samp{--left-only} 
@itemx  @samp{--right-only} 
リストは、 対称差のそれぞれの側でのみコミットします。 つまり、 @samp{--left-right} で @samp{<} と印されるのだけか、あるいは @samp{--left-right} で @samp{>} と印されるものだけです。

たとえば、 @samp{--cherry-pick --right-only A...B} は、 @samp{A} にある、 または @samp{A} のコミットとパッチと同等のコミットを @samp{B} から省略します。 つまり、 これは @samp{git cherry A B} からの @samp{+} コミットをリストします。 より正確に書くと、 @samp{--cherry-pick --right-only --no-merges} により正確なリストを提供します。

@item  @samp{--cherry} 
@samp{--right-only --cherry-mark --no-merges} の同義語です。 出力を私たちの側のコミットに制限し、 フォークされた履歴の反対の側に適用されたものを、 @samp{git cherry upstream mybranch} と同様に @samp{git log --cherry upstream...mybranch} でマークするのに役立ちます。

@item  @samp{-g} 
@itemx  @samp{--walk-reflogs} 
コミットの祖先チェーンをたどる代わりに、 reflogエントリを最新のものから古いものに移動します。 このオプションを使用する場合、 除外するコミットを指定することはできません(つまり、 @samp{^commit} や @samp{commit1..commit2} や @samp{commit1...commit2} 表記は使用できません)。

(明らかな理由で、)@samp{oneline} と @samp{reference} 以外の @samp{--pretty} 形式では、 これにより、 出力にreflogから取得された2行の追加情報が含まれます。 出力のreflog指定子は、 @samp{ref@@@{Nth@}} (@samp{Nth} はreflogの逆時系列インデックス(reverse-chronological index))または @samp{ref@@@{timestamp@}} (そのエントリのタイムスタンプ付き)として表示されます。表示は下記のいくつかのルールに依存します:

@enumerate 

@item
開始点が @samp{ref@@@{Nth@}} として指定されている場合は、インデックス形式を表示します。

@item
開始点が @samp{ref@@@{now@}} として指定されている場合は、タイムスタンプ形式を表示します。

@item
上記のどちらも使用されていないが、コマンドラインで @samp{--date} が指定されている場合は、 @samp{--date} で要求された形式でタイムスタンプを表示します。

@item
それ以外の場合は、インデックス形式を表示します。
@end enumerate

@samp{--pretty = oneline} では、コミットメッセージの前にこの情報が同じ行に付けられます。このオプションを @samp{--reverse} と組み合わせることはできません。 git-reflog(1)も参照してください。

@samp{--pretty=reference} では、この情報はまったく表示されません。

@item  @samp{--merge} 
マージが失敗した後、競合があり、マージするすべてのheadに存在しないファイルに関連(touch)するrefを表示します。

@item  @samp{--boundary} 
除外された境界コミットを出力します。 境界コミットの前には @samp{-} が付いています。
@end table

@noindent

@heading History Simplification

特定の<path>を変更するコミットなど、履歴の一部のみに関心がある場合があります。ただし、「履歴の簡略化」(History Simplification)は2つの部分から成ります。履歴を簡略化するためにはさまざまな戦略があるためです。その1つはコミットの選択であり、もう1つはそれを行う方法です。

以下のオプションは、表示するコミットを選択します:

@table @asis

@item  <paths> 
指定された<パス>を変更するコミットが選択されます。

@item  @samp{--simplify-by-decoration} 
いくつかのブランチまたはタグによって参照されるコミットが選択されます。
@end table

注意: 意味のある重要な履歴のために、追加のコミットを表示できることに注意してください。

以下のオプションは、簡略化の実行方法に影響します。

@table @asis

@item  Default mode 
履歴を、ツリーの最終状態を説明する最も単純な履歴に単純化します。最終結果が同じである場合(つまり、同じコンテンツのブランチをマージする場合)、いくつかの傍流ブランチ(side branches)を削除するため、最も単純です。

@item  @samp{--show-pulls} 
デフォルトモードからのすべてのコミットを含めますが、最初の親へのTREESAMEではなく、後の親へのTREESAMEであるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに役立ちます。(訳注:TREESAME=pathspecが全く同一であるツリー)

@item  @samp{--full-history} 
デフォルトモードと同じですが、一部の履歴を削除しません。

@item  @samp{--dense} 
選択したコミットのみが表示され、重大で意味のある履歴を持つコミットもいくつか表示されます。

@item  @samp{--sparse} 
簡略化された履歴内のすべてのコミットが表示されます。

@item  @samp{--simplify-merges} 
このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除するための`--full-history`への追加オプション。

@item  @samp{--ancestry-path[=<commit>]} 
表示するコミットの範囲を指定すると(例: @samp{commit1..commit2} または @samp{commit2 ^commit1})、その範囲内で <commit> の祖先、<commit> の子孫、または <commit> 自身であるコミットのみを表示します。 コミットが指定されていない場合は、@samp{commit1} (範囲の除外部分) を <commit> として使用します。 複数回渡すことができます。 その場合、あるコミットが指定されたコミットのいずれかであるか、それらのいずれかの祖先または子孫である場合、そのコミットは含まれます。
@end table

より詳細な説明は以下のとおりです。

<paths> として @samp{foo} を指定したとします。 @samp{foo} !TREESAME を変更するコミットを呼び出し、残りをTREESAMEと呼びます。( @samp{foo} のためにフィルタリングされた差分では、それぞれ異なって見えたりたり等しく見えたりします。）

以下、簡略化設定の違いを説明するために、同じ履歴例を使います。このコミットグラフでは、ファイル @samp{foo} をフィルタリングしていると想定しています:

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \   /   /   /   /   /
          `-------------'   X
@end example


履歴 A---Q の水平線は、各マージの最初の親と見なされます。その各コミットは以下のとおりです:

@itemize 

@item
@samp{I} は最初のコミットであり、ファイル foo が内容 “asdf” で存在し、ファイル quux は内容 “quux” で存在します。最初のコミットは空のツリーと比較されるため、@samp{I} は !TREESAME です。

@item
@samp{A} では、 foo には “foo” だけが含まれています。

@item
@samp{B} には @samp{A} と同じ変更が含まれています。そのマージ @samp{M} は些細なことであり、したがってすべての親にとって TREESAME です。

@item
@samp{C} は @samp{foo} を変更しませんが、そのマージ @samp{N} はそれを “foobar” に変更するので、どの親にとっても TREESAME ではありません。

@item
@samp{D} は @samp{foo} を “baz” に設定します。そのマージ @samp{O} は、 @samp{N} と @samp{D} から “foobarbaz” への文字列を結合します。つまり、どの親にとっても TREESAME ではありません。

@item
@samp{E} は @samp{quux} を “xyzzy” に変更し、そのマージ @samp{P} は文字列を “quuxxyzzy” に結合します。 @samp{P} は @samp{O} に対して TREESAME ですが、 @samp{E} に対してはそうではありません。

@item
@samp{X} は、新ファイル @samp{side} を追加し、 @samp{Y} がそれを変更した独立したルートコミットです。 @samp{Y} は @samp{X} へのTREESAMEです。そのマージ @samp{Q} は @samp{P} に @samp{side} を追加し、 @samp{Q} は @samp{P} にはTREESAMEですが、@samp{Y} に対してはそうではありません。
@end itemize

@samp{rev-list} は、 @samp{--full-history} および/または、( @samp{--parents} または @samp{--children} を介して)親の書き換えが使用されているかどうかに基づいて、コミットを含めたり除外したりして、履歴を逆方向にウォークスルーします。以下の設定が可能です。

@table @asis

@item  Default mode 
コミットは、どの親に対してもTREESAMEでない場合に含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。コミットがマージであり、一方の親に対するTREESAMEであった場合は、その親のみをフォローします。(TREESAMEの親が複数ある場合でも、そのうちの1つだけをフォローします)。それ以外の場合は、すべての親をフォローします。

これにより、以下のようになります:

@example
          .-A---N---O
         /     /   /
        I---------D
@end example


TREESAMEの親のみに従うルールが利用可能な場合は、 @samp{B} を検討対象から完全に削除したことに注意してください。 @samp{C} は @samp{N} を介して考慮されましたが、しかしそれはTREESAMEです。ルートコミットは空のツリーと比較されるため、 @samp{I} は !TREESAME です。

親子関係は @samp{--parents} でのみ表示されますが、デフォルトモードで選択されたコミットには影響しないため、親の行を示しました。

@item  @samp{--full-history without parent rewriting} 
このモードは、デフォルトとはある一点で異なります。つまり、いずれかの親に対してTREESAMEであっても、常にマージのすべての親に従います。マージの複数の側にコミットが含まれている場合でも、これはマージ自体が含まれていることを意味するものではありません！ 例では以下のようになります。

@example
        I  A  B  N  D  O  P  Q
@end example


@samp{M} は、両方の親にとってTREESAMEであるため、除外されました。 @samp{E} と @samp{C} と @samp{B} をすべて巡りましたが、 @samp{B} だけが !TREESAME だったので、他は表示されません。

注意: 親の書き換え(rewrite)がないと、コミット間の親子関係について話す(talk)ことは実際には不可能であるため、それらが切断されている(disconnected)ことを示していることに注意してください。

@item  @samp{--full-history with parent rewriting} 
通常のコミットは !TREESAME の場合にのみ含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。

マージは常に含まれます。ただし、親リストは書き直されます。各親に沿って、自分自身に含まれていないコミットを削除します。 これにより以下のようになります。

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /
        I     B   /   D   /
         \   /   /   /   /
          `-------------'
@end example


上記を書き直さずに @samp{--full-history} と比較してください。 @samp{E} はTREESAMEであるため削除されましたが、Pの親リストは @samp{E} の親 @samp{I} を含むように書き直されていることに注意してください。 @samp{C} と @samp{N} および @samp{X} と @samp{Y} と @samp{Q} についても同じことが起こりました。
@end table

上記の設定に加えて、あなたはTREESAMEが包含に影響を与えるかどうかを変更できます:

@table @asis

@item  @samp{--dense} 
巡ったコミットは、親にとってTREESAMEでない場合に含まれます。

@item  @samp{--sparse} 
巡ったすべてのコミットが含まれます。

@samp{--full-history} がなくても、これによりマージが単純化されることに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側を巡ることはありません。

@item  @samp{--simplify-merges} 
最初に、親を書き換えた @samp{--full-history} と同じ方法で履歴グラフを作成します(上記を参照)。

それから、以下のルールに従って、各コミット @samp{C} を最終履歴内の置換 @samp{C'} に単純化します:

@itemize 

@item
@samp{C'} を @samp{C} にセットします。

@item
@samp{C'} の各親 @samp{P} をその簡略化された @samp{P'} に置き換えます。その過程で、他の親の祖先であるか、ルートである親を削除すると、TREESAMEが空のツリーにコミットされ、重複が削除されますが、TREESAMEであるすべての親を削除しないように注意してください。

@item
この親の書き換え後、 @samp{C'} がルートまたはマージコミット(0または >1 の親を持つ)、境界コミット、または !TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。
@end itemize

この効果は、親の書き換えを使用した @samp{--full-history} と比較することで最もよく示されます。例は以下のようになります:

@example
          .-A---M---N---O
         /     /       /
        I     B       D
         \   /       /
          `---------'
@end example


注意: @samp{--full-history} に対する @samp{N} と @samp{P} と @samp{Q} の主な違いに注意してください:

@itemize 

@item
@samp{N} の親リストは、他の親 @samp{M} の祖先であるため、 @samp{I} が削除されました。それでも、 !TREESAME なので @samp{N} が残りました。

@item
@samp{P} の親リストも同様に @samp{I} が削除されました。 @samp{P} は、親が1つで TREESAMEであるため、完全に削除されました。

@item
@samp{Q} の親リストでは、 @samp{Y} が @samp{X} に簡略化されていました。その後、 @samp{X} はTREESAMEルートであったため、削除されました。 @samp{Q} は、親が1つで TREESAMEであるため、完全に削除されました。
@end itemize
@end table

利用可能な別の簡略化モードがあります:

@table @asis

@item  @samp{--ancestry-path[=<commit>]} 
表示されるコミットを <commit> の祖先、または <commit> の子孫、または <commit> 自身に制限します。

ユースケースの例として、以下のコミット履歴について考えます:

@example
            D---E-------F
           /     \       \
          B---C---G---H---I---J
         /                     \
        A-------K---------------L--M
@end example


通常の @samp{D..M} は、 @samp{M} の祖先であるコミットのセットを計算しますが、 @samp{D} の祖先であるコミットは除外します。 これは、「 @samp{M} には @samp{D} には存在しなかったものがある」という意味で、 @samp{D} 以降の @samp{M} に至るまでの歴史に何が起こったのかを知るのに役立ちます。この例の結果は、 @samp{A} と @samp{B} (そしてもちろん @samp{D} 自体)を除くすべてのコミットになります。

ただし、 @samp{M} のコミットが @samp{D} で入ったバグで汚染されており、修正が必要な場合は、実際には @samp{D} の子孫である @samp{D..M} のサブセットのみを表示する必要があります。つまり、 @samp{C} と @samp{K} を除外します。これはまさに @samp{--ancestry-path} オプションが行うことです。これを @samp{D..M} 範囲に適用すると、以下のようになります:

@example
                E-------F
                 \       \
                  G---H---I---J
                               \
                                L--M
@end example


@samp{--ancestry-path} の代わりに @samp{--ancestry-path=D} を使用することもできます。これは、@samp{D..M} 範囲に適用された場合と同じことを意味しますが、より明示的です。

代わりに、この範囲内の特定のトピックに関心があり、そのトピックによって影響を受けるすべてのコミットに関心がある場合、祖先パスにそのトピックを含む @samp{D..M} のサブセットのみを表示したい場合があります。 たとえば、@samp{--ancestry-path=H D..M} を使用すると、以下のようになります:

@example
                E
                 \
                  G---H---I---J
                               \
                                L--M
@end example


一方、@samp{--ancestry-path=K D..M} は以下のようになります

@example
                K---------------L--M
@end example

@end table

別のオプション @samp{--show-pulls} について説明する前に、新しいサンプル履歴を作成する必要があります。

簡略化された履歴を見るときにユーザーが直面する一般的な問題は、ファイルを変更したことがわかっているコミットが、ファイルの簡略化された履歴に表示されないことです。そこで、新しい例を示し、その場合に @samp{--full-history} や @samp{--simplify-merges} などのオプションがどのように機能するかを示しましょう。

@example
          .-A---M-----C--N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`-Z'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `---Y--'
@end example


この例では、 @samp{I} が @samp{file.txt} を作成し、それが @samp{A} と`B` と @samp{X} にてさまざまな方法で変更されたとします。ひとり親のコミット @samp{C} と @samp{Z} と @samp{Y} は @samp{file.txt} を変更していません。マージコミット @samp{M} は、マージの競合を解決して、 @samp{A} と @samp{B} の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。ただし、マージコミット @samp{R} は、 @samp{M} の @samp{file.txt`の内容を無視し、 `X} の @samp{file.txt} の内容のみを取得することによって作成されました。 したがって、 @samp{R} は @samp{X} へのTREESAMEですが、 @samp{M} はそうではありません。最後に、 @samp{N} を作成するための自然なマージ解決は、 @samp{R} で @samp{file.txt} の内容を取得することです。したがって、 @samp{N} は @samp{C} ではなく @samp{R} へのTREESAMEです。マージコミット @samp{O} と @samp{P} は、最初の親にはTREESAMEですが、2番目の親である @samp{Z} と @samp{Y} にはついてはそうではありません。

デフォルトモードを使用する場合、 @samp{N} と @samp{R} は両方ともTREESAMEの親を持っているため、これらのエッジはウォークされ、他のエッジは無視されます。結果の履歴グラフは以下のとおりです:

@example
        I---X
@end example


@samp{--full-history} を使用する場合、Gitはすべてのエッジを巡ります。これにより、コミット @samp{A} と @samp{B} と マージ @samp{M} が検出されますが、マージコミット @samp{O} と @samp{P} も明らかになります。 親を書き換えると、結果のグラフは以下のようになります:

@example
          .-A---M--------N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`--'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `------'
@end example


ここで、マージコミット @samp{O} と @samp{P} は、実際には @samp{file.txt} への変更を提供しなかったため、余分なノイズを提供します。古いバージョンの @samp{file.txt} に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です。 @samp{--full-history} の結果には、関連のない多くのマージが表示されます。

@samp{--simplify-merges} オプションを使用すると、コミット @samp{O} と @samp{P} が結果から消えます。 これは、 @samp{O} と @samp{P} の書き直された2番目の親が、最初の親から到達可能であるためです。これらのエッジが削除されると、コミットは、親にとってTREESAMEである単一の親のコミットのように見えます。これはコミット @samp{N} にも発生し、以下のような履歴ビューが表示されます:

@example
          .-A---M--.
         /     /    \
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


このビューでは、 @samp{A} と @samp{B} と @samp{X} からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ @samp{M} とそれほど慎重に解決されていないマージ @samp{R} も表示されます。これは通常、コミット @samp{A} と @samp{B} がデフォルトのビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。

最初の問題はパフォーマンスです。以前のオプションとは異なり、 @samp{--simplify-merges} オプションでは、単一の結果を返す前にコミット履歴全体をウォークする必要があります。これにより、非常に大規模なリポジトリでこのオプションを使用するのが難しくなる可能性があります。

2番目の問題は監査の1つです。多くの寄稿者が同じリポジトリで作業している場合、どのマージコミットが重要なブランチに変更を導入したかが重要です。上記の問題のあるマージ @samp{R} は、重要なブランチにマージするために使用されたマージコミットではない可能性があります。 代わりに、マージ @samp{N} を使用して @samp{R} と @samp{X} を重要なブランチにマージしました。このコミットには、変更 @samp{X} がコミットメッセージの @samp{A} と @samp{B} からの変更を上書きするようになった理由に関する情報が含まれている可能性があります。

@table @asis

@item  @samp{--show-pulls} 
デフォルトの履歴に表示されるコミットに加えて、最初の親にはTREESAMEではなく、後の親にはTREESAMEである各マージコミットを表示します。

マージコミットが @samp{--show-pulls} に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で @samp{--show-pulls} を使用すると(他のオプションは使用しない場合、)結果のグラフは行かのようになります:

@example
        I---X---R---N
@end example


ここで、コミット @samp{X} と @samp{R} をそれぞれベースブランチにプルしたため、マージコミット @samp{R} と @samp{N} が含まれています。これらのマージは、コミット @samp{A} と @samp{B} がデフォルトの履歴に表示されない理由です。

@samp{--show-pulls} が @samp{--simplify-merges} とペアになっている場合、グラフには必要なすべての情報が含まれます:

@example
          .-A---M--.   N
         /     /    \ /
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


@samp{M} は @samp{R} から到達可能であるため、 @samp{N} から @samp{M} へのエッジが単純化されていることに注意してください。ただし、 @samp{N} は、変更 @samp{R} をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。
@end table

@samp{--simplify-by-decoration} オプションを使用すると、タグで参照されていないコミットを省略して、履歴のトポロジの全体像のみを表示できます。コミットは、(1)タグによって参照されている場合、または (2)コマンドラインで指定されたパスの内容を変更した場合に、!TREESAMEとしてマークされます(つまり、上記の履歴簡略化ルールの後に保持されます)。他のすべてのコミットはTREESAMEとしてマークされます(簡略化される可能性があります)。

@noindent

@heading Commit Ordering

デフォルトでは、コミットは新しい順に表示されます。

@table @asis

@item  @samp{--date-order} 
すべての子が表示されるまで親を表示しませんが、それ以外の場合はコミットタイムスタンプの順序でコミットを表示します。

@item  @samp{--author-date-order} 
すべての子が表示されるまで親を表示しませんが、それ以外の場合は、作者(author)のタイムスタンプ順にコミットを表示します。

@item  @samp{--topo-order} 
すべての子が表示されるまで親を表示せず、複数の履歴行が混在するコミットを表示しないようにします。

たとえば、以下のようなコミット履歴があります:

@example
    ---1----2----4----7
        \              \
         3----5----6----8---
@end example


ここで、数字はコミットタイムスタンプの順序を示し、 @samp{gitrev-list} と @samp{--date-order} のある友達は、タイムスタンプの順序でコミットを示します。つまり、8 7 6 5 4 3 2 1

@samp{--topo-order} を使用すると、8 6 5 3 7 4 2 1（または8 7 4 2 6 5 3 1）が表示されます。2つの並列開発トラックからのコミットが混在して表示されないようにするために、いくつかの古いコミットが新しいコミットの前に表示されます。

@item  @samp{--reverse} 
表示するように選択したコミットを逆の順序で出力します(上記の Commit Limiting 節を参照)。 @samp{--walk-reflogs} と組み合わせることはできません。
@end table

@noindent

@heading Object Traversal

これらのオプションは、主にGitリポジトリのパッキングを対象としています。

@table @asis

@item  @samp{--no-walk[=(sorted|unsorted)]} 
指定されたコミットのみを表示し、祖先をトラバースしない。範囲が指定されている場合、これは効果がありません。引数 @samp{unsorted} が指定されている場合、コミットはコマンドラインで指定された順序で表示されます。それ以外の場合( @samp{sorted} または引数が指定されていない場合)、コミットはコミット時間の逆順に表示されます。 @samp{--graph} と組み合わせることはできません。

@item  @samp{--do-walk} 
以前の @samp{--no-walk} を上書きします。
@end table

@noindent

@heading Commit Formatting

@table @asis

@item  @samp{--pretty[=<format>]} 
@itemx  @samp{--format=<format>} 
コミットログの内容を指定された形式できれいに印刷(pretty-print)します。 <format> は oneline、short、medium、full、fuller、reference、email、raw、format:<string>、tformat:<string> のいずれかになります。 <format> が上記のいずれでもなく、「%プレースホルダー」が含まれている場合、 @samp{--pretty=tformat:<format>} が指定されたかのように動作します。

各フォーマットの詳細については、「PRETTY FORMATS」セクションを参照してください。 @samp{=<format>} の部分を省略すると、デフォルトで medium になります。

注意: リポジトリー構成でデフォルトのpretty formatを指定できます(git-config(1) 参照)。

@item  @samp{--abbrev-commit} 
40バイトの16進コミットオブジェクト名全体を表示する代わりに、オブジェクトに一意の名前を付けるプレフィックスを表示します。 "--abbrev=<n>" (表示されている場合はdiff出力も変更します)オプションを使用して、プレフィックスの最小長を指定できます。

これにより、80桁幅の端末を使用している人にとって "--pretty=oneline" がずっと読みやすくなるはずです。

@item  @samp{--no-abbrev-commit} 
完全な40バイトの16進コミットオブジェクト名を表示します。 これにより、明示的または "--oneline" などの他のオプションによって暗黙的に示される @samp{--abbrev-commit} が無効になります。また、 @samp{log.abbrevCommit} 変数をオーバーライドします。

@item  @samp{--oneline} 
これは、 "--pretty=oneline --abbrev-commit" を一緒に使用するための省略形です。

@item  @samp{--encoding=<encoding>} 
コミットオブジェクトは、ログメッセージに使用される文字エンコードをエンコードヘッダーに記録します。このオプションを使用して、ユーザーが好むエンコーディングでコミットログメッセージを再コーディングするようにコマンドに指示できます。配管以外のコマンドの場合、これはデフォルトでUTF-8になります。オブジェクトが @samp{X} でエンコードされていると主張し、 @samp{X} で出力している場合、オブジェクトをそのまま出力することに注意してください。これは、元のコミットの無効なシーケンスが出力にコピーされる可能性があることを意味します。 同様に、 iconv(3) がコミットの変換に失敗した場合、 元のオブジェクトをそのまま黙って出力します。

@item  @samp{--expand-tabs=<n>} 
@itemx  @samp{--expand-tabs} 
@itemx  @samp{--no-expand-tabs} 
出力に表示する前に、ログメッセージでタブ展開を実行します(タブ幅を <n> とみなして <n> 境界に揃うように空白で調整する)。 @samp{--expand-tabs} は @samp{--expand-tabs=8} の省略形であり、 @samp{--no-expand-tabs} は @samp{--expand-tabs=0} の省略形です。タブの展開を無効にします。

デフォルトでは、タブはログメッセージを4つのスペースでインデントするきれいな形式(pretty formats)で展開されます(つまり、medium (これがデフォルト) と full と fuller)。

@item  @samp{--notes[=<ref>]} 
コミットログメッセージを表示するときに、コミットに注釈を付けるnotes(git-notes(1) 参照)を表示します。これは、コマンドラインに @samp{--pretty} 、@samp{--format} または @samp{--oneline} オプションが指定されていない場合の、 @samp{git log} と @samp{git show} と ` git whatchanged` コマンドのデフォルトです。

デフォルトでは、表示されるnotesは、 @samp{core.notesRef} および @samp{notes.displayRef} 変数(または対応する環境変数オーバーライド)にリストされているnote refからのものです。詳細については git-config(1) を参照してください。

オプションの <ref> 引数を使用して、refを使用して表示するnotesを検索します。 refは、 @samp{refs/notes/} で始まる完全なrefnameを指定できます。 @samp{notes/} で始まるか、 @samp{refs/} で始まるか、それ以外で始まる場合、 @samp{refs/notes/} が接頭辞として付けられ、refのフルネームを形成します。

複数の --notes オプションを組み合わせて、表示するノートを制御できます。 例: "--notes=foo" は "refs/notes/foo" からのnotesのみを表示します。 "--notes=foo --notes" は、 "refs/notes/foo" とデフォルトのnotes ref(s) の両方のnotesを表示します。

@item  @samp{--no-notes} 
notesを表示しないでください。 これは、notesが表示されるnotes refのリストをリセットすることにより、上記の @samp{--notes} オプションを無効にします。 オプションは、コマンドラインで指定された順序で解析されます。 "--notes --notes=foo --no-notes --notes=bar" は、 "refs/notes/bar" からのnotesのみを表示します。

@item  @samp{--show-notes[=<ref>]} 
@itemx  @samp{--[no-]standard-notes} 
これらのオプションは非推奨です。 代わりに、上記の --notes/--no-notes オプションを使用してください。

@item  @samp{--show-signature} 
署名を @samp{gpg --verify} に渡して、署名されたコミットオブジェクトの有効性を確認し、出力を表示します。

@item  @samp{--relative-date} 
@samp{--date=relative} と同じ。

@item  @samp{--date=<format>} 
@samp{--pretty} を使用する場合など、人間が読める形式で表示される日付に対してのみ有効になります。 @samp{log.date} 構成変数(config variable)は、logコマンドの @samp{--date} オプションのデフォルト値を設定します。デフォルトでは、日付は元のタイムゾーン(コミッターの、または作者のいずれか)で表示されます。フォーマットに @samp{-local} が追加されている場合(例: @samp{iso-local} )、代わりにユーザーのローカルタイムゾーンが使用されます。

@samp{--date=relative} は、現在の時刻を基準にした日付を示します。例: “2 hours ago” 。 @samp{-local} オプションは @samp{--date = relative} には効果がありません。

@samp{--date=local} は @samp{--date=default-local} のエイリアスです。

@samp{--date=iso} (または @samp{--date=iso8601} )は、タイムスタンプをISO 8601のような形式で表示します。厳密なISO 8601形式との違いは以下のとおりです:

@itemize 

@item
@samp{T} 日付/時刻区切り文字の代わりにスペース

@item
時間とタイムゾーンの間のスペース

@item
タイムゾーンの時間と分の間にコロンがありません
@end itemize

@samp{--date=iso-strict} (または @samp{--date=iso8601-strict} )は、タイムスタンプを厳密なISO 8601形式で表示します。

@samp{--date=rfc} (または @samp{--date=rfc2822} )は、RFC 2822形式のタイムスタンプを示します。これは、電子メールメッセージでよく見られます。

@samp{--date=short} は、日付のみを表示し、時刻は表示せず、 @samp{YYYY-MM-DD} 形式で表示します。

@samp{--date=raw} は、エポック(1970-01-01 00:00:00 UTC)からの秒数、スペース、UTCからのオフセット(@samp{+} または @samp{-} の付いた4桁数字で、最初の2つは時間、次の2つは分です)。つまり、タイムスタンプが @samp{strftime("%s %z")} でフォーマットされているかのようになります。 @samp{-local} オプションは、seconds-since-epoch値(常にUTCで測定されます)には影響しませんが、付随するタイムゾーン値を切り替えることに注意してください。

@samp{--date=human} は、タイムゾーンが現在のタイムゾーンと一致しない場合はタイムゾーンを表示し、一致する場合は日付全体を印刷しません(つまり、「今年」の日付の場合は年の印刷をスキップしますが、何があったか覚えてるような過去数日については日付自体もスキップします)。 古い日付の場合、時と分も省略されます。

@samp{--date=unix} は、日付をUnixエポックタイムスタンプ(1970年からの秒数)として表示します。 @samp{--raw} と同様に、これは常にUTCであるため、 ` -local` は効果がありません。

@samp{--date=format:...} は、内部で処理される%sと%zと%Zを除いて、フォーマット @samp{...} をあなたのシステムの @samp{strftime} に送ります。 @samp{--date=format:%c} を使用して、システムロケールの推奨形式で日付を表示します。フォーマットプレースホルダーの完全なリストについては、 @samp{strftime} マニュアルを参照してください。 @samp{-local} を使用する場合、正しい構文は @samp{--date=format-local:...} です。

@samp{--date=default} is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in "HH:MM:SS" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. @samp{Thu Jan 1 00:00:00 1970 +0000}.

@item  @samp{--parents} 
コミットの親も出力します( "commit parent…" の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。

@item  @samp{--children} 
コミットの子も出力します( "commit child…" の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。

@item  @samp{--left-right} 
対称差のどちら側からコミットに到達できるかをマークします。左側からのコミットには @samp{<} が付けられ、右側からのコミットには @samp{>} が付けられます。 @samp{--boundary} と組み合わせると、それらのコミットの前に @samp{-} が付きます。

たとえば、以下のトポロジーの場合:

@example
             y---b---b  branch B
            / \ /
           /   .
          /   / \
         o---x---a---a  branch A
@end example


以下のような出力が得られます:

@example
        $ git rev-list --left-right --boundary --pretty=oneline A...B

        >bbbbbbb... 3rd on b
        >bbbbbbb... 2nd on b
        <aaaaaaa... 3rd on a
        <aaaaaaa... 2nd on a
        -yyyyyyy... 1st on b
        -xxxxxxx... 1st on a
@end example


@item  @samp{--graph} 
出力の左側に、コミット履歴のテキストベースのグラフィック表現を描画します。グラフ履歴を適切に描画するために、コミットの間に余分な行が出力される可能性があります。 @samp{--no-walk} と組み合わせることはできません。

これにより、親の書き換えが可能になります。上記「History Simplification」を参照してください。

これは、デフォルトで @samp{--topo-order} オプションを意味しますが、 @samp{--date-order} オプションも指定できます。

@item  @samp{--show-linear-break[=<barrier>]} 
--graph を使用しない場合、すべての履歴ブランチがフラット化されるため、2つの連続するコミットが線形ブランチに属していないことがわかりにくくなる可能性があります。このオプションは、その場合、それらの間に障壁を置きます。 @samp{<barrier>} が指定されている場合、デフォルトの障壁文字列の代わりに @samp{<barrier>} が表示されます。
@end table

@noindent

@chapheading PRETTY FORMATS

コミットがマージであり、 pretty-format が @samp{oneline} または @samp{email} または @samp{raw} で無い場合、 @samp{Author:} 行の前に追加の行が挿入されます。この行は "Merge: " で始まり、先祖のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合、リストされたコミットは必ずしも @strong{直接} の親コミットのリストではない可能性があることに注意してください。

いくつかの組み込みフォーマットがあります。そして以下で説明するように、 pretty.<name> 構成オプション(config option)を別のフォーマット名または @samp{format:} 文字列に設定することで、追加のフォーマットを定義できます(git-config(1) 参照)。組み込みフォーマットの詳細は以下のとおりです:

@itemize 

@item
@samp{oneline}

@example
<hash> <title-line>
@end example

これは、可能な限りコンパクトになるように設計されています。

@item
@samp{short}

@example
commit <hash>
Author: <author>
@end example

@example
<title-line>
@end example

@item
@samp{medium}

@example
commit <hash>
Author: <author>
Date:   <author-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{full}

@example
commit <hash>
Author: <author>
Commit: <committer>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{fuller}

@example
commit <hash>
Author:     <author>
AuthorDate: <author-date>
Commit:     <committer>
CommitDate: <committer-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{reference}

@example
<abbrev-hash> (<title-line>, <short-author-date>)
@end example

この形式は、コミットメッセージ内の別のコミットを参照するために使用され、 @samp{--pretty='format:%C(auto)%h (%s, %ad)'} と同じです。 デフォルトでは、別の @samp{--date} オプションが明示的に指定されていない限り、日付は @samp{--date=short} でフォーマットされます。formatプレースホルダーを使用する他の @samp{format:} と同様に、その出力は、 @samp{--decorate} や @samp{--walk-reflogs} などの他のオプションの影響を受けません。

@item
@samp{email}

@example
From <hash> <date>
From: <author>
Date: <author-date>
Subject: [PATCH] <title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{mboxrd}

@samp{email} と同様ですが、コミットメッセージの "From " で始まる行(前に0個以上の @samp{>} が付いている)は @samp{>} でクォートされているため、新しいコミットの開始と混同されることはありません。

@item
@samp{raw}

@samp{raw} 形式は、コミットオブジェクトに格納されているとおりにコミット全体を正確に表示します。とりわけ @samp{--abbrev} または @samp{--no-abbrev} のどちらが使用されているかに関係なく、ハッシュは完全に表示され、「親」(parents)情報は、移植や履歴の単純化を考慮せずに、真の親のコミットを示します。この形式は、コミットの表示方法に影響しますが、いわゆる @samp{git log --raw} の差分の表示方法ではありません。生のdiff形式で完全なオブジェクト名を取得するには、 @samp{--no-abbrev} を使用します。

@item
@samp{format:<format-string>}

@samp{format:<format-string>} 形式を使用すると、表示する情報を指定できます。注意: これはprintf書式に少し似ていますが、 @samp{\n} の代わりに @samp{%n} を使用して改行を取得するという例外に注意してください。

例: @samp{format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"} は以下のように表示されます:

@example
The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<
@end example


さて、以下がプレースホルダー達です:

@itemize 

@item
単一のリテラル文字に展開されるプレースホルダー:

@table @asis

@item  @samp{%n} 
改行(newline)

@item  @samp{%%} 
`%`そのもの

@item  @samp{%x00} 
16進数のバイト値を出力
@end table

@item
これより後ろのプレースホルダーのフォーマッティングに影響を与えるプレースホルダー:

@table @asis

@item  @samp{%Cred} 
赤色に切り替える

@item  @samp{%Cgreen} 
緑色に切り替える

@item  @samp{%Cblue} 
青色に切り替える。

@item  @samp{%Creset} 
色をリセットする

@item  @samp{%C(...)} 
git-config(1) の「CONFIGURATION FILE」の Values で説明されている色の指定。 デフォルトでは、色はログ出力が有効になっている場合にのみ表示されます(@samp{color.diff} または @samp{color.ui} または @samp{--color} によって、ターミナルに出す場合は前者の @samp{auto} 設定を尊重します)。 @samp{%C(auto,...)} は、 default の歴史的同義語として受け入れられます(例: @samp{%C(auto,red)})。 @samp{%C(always,...)} を指定すると、色が有効になっていない場合でも色が表示されます(この形式やgitが色付けする可能性のある他のすべてのものを含め、出力全体の色を有効にするために @samp{--color=always} の使用を検討してください)。 @samp{auto} のみ(つまり、 @samp{%C(auto)})は、色が再び切り替えられるまで、これに続くプレースホルダーで自動色付けをオンにします。

@item  @samp{%m} 
左(@samp{<}) または 右(@samp{>}) または 境界 (@samp{-}) の印

@item  @samp{%w([<w>[,<i1>[,<i2>]]])} 
git-shortlog(1) の -w オプションのように、行の折返しを切り替えます。

@item  @samp{%<( <N> [,trunc|ltrunc|mtrunc])} 
これの次のプレースホルダーが少なくとも N 列幅になるようにし、必要に応じて右側にスペースを詰めます。出力が N 列より長い場合は、オプションで、左側 (ltrunc) @samp{..ft} 切り捨て、または 中央 (mtrunc) @samp{mi..le} 切り捨て、または末尾切り捨て (trunc) @samp{rig..} ます (@emph{..} は省略符号)。 注意1: 切り捨ては N >= 2 の場合にのみ正しく機能します。 注意2: N および M (以下参照) 値の前後の空白はオプションです。 注意3: 絵文字やその他のワイド・キャラクタは表示桁を2つ必要とするため、桁の境界を超える可能性があります。 注意4: 複合文字マーク(character combining marks)が詰物境界で誤って分割配置される可能性があります。

@item  @samp{%<|( <M> )} 
これの次のプレースホルダーが少なくとも M 桁目の表示桁までを占めるようにし、必要に応じて右側に空白を詰めます。 端末ウィンドウの右端から測定した桁位置には、負の M 値を使用して下さい。

@item  @samp{%>( <N> )}, @samp{%>|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、左側に空白が埋め込まれます

@item  @samp{%>>( <N> )}, @samp{%>>|( <M> )} 
それぞれ @samp{%>( <N> )}, @samp{%>|( <M> )} に似ていますが、 これに続くプレースホルダーが指定よりも多くの空白を使用し、その左側に空白がある場合は、それらの空白を使用します

@item  @samp{%><( <N> )}, @samp{%><|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、 両側にパディングがあります(つまり、 テキストが中央に配置されます)
@end table

@item
コミットから抽出された情報に展開するプレースホルダー:

@table @asis

@item  @samp{%H} 
コミットハッシュ

@item  @samp{%h} 
省略されたコミットハッシュ

@item  @samp{%T} 
ツリーハッシュ

@item  @samp{%t} 
省略されたツリーハッシュ

@item  @samp{%P} 
親のハッシュ達

@item  @samp{%p} 
省略された親のハッシュ達

@item  @samp{%an} 
作者名

@item  @samp{%aN} 
作者名( .mailmap に関しては、 git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ae} 
作者電子メールアドレス

@item  @samp{%aE} 
作者電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%al} 
作者電子メールアドレスアカウント名(local-part)(@samp{@@} の前の部分)

@item  @samp{%aL} 
作者電子メールアカウント名(@samp{%al} 参照)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ad} 
作成日(フォーマットに関しては --date= オプション参照)

@item  @samp{%aD} 
作成日 RFC2822形式

@item  @samp{%ar} 
作成日 相対(relative)形式

@item  @samp{%at} 
作成日 UNIXタイムスタンプ形式

@item  @samp{%ai} 
作成日 ISO 8601風形式

@item  @samp{%aI} 
作成日 厳密なISO 8601形式

@item  @samp{%as} 
作成日 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ah} 
作者作成日(author date)の人間が読める形式(human style)(git-rev-list(1) の ‘--date=human’ に似ている)

@item  @samp{%cn} 
コミッター名

@item  @samp{%cN} 
コミッター名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ce} 
コミッター電子メールアドレス

@item  @samp{%cE} 
コミッター電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cl} 
コミッター電子メールアドレスアカウント名(local-part)( @samp{@@} の前の部分)

@item  @samp{%cL} 
コミッター電子メールアカウント名(local-part)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cd} 
コミッター日付(フォーマットに関しては @samp{--date=} オプション参照)

@item  @samp{%cD} 
コミッター日付 RFC2822形式

@item  @samp{%cr} 
コミッター日付 相対(relative)形式

@item  @samp{%ct} 
コミッター日付 UNIXタイムスタンプ形式

@item  @samp{%ci} 
コミッター日付 ISO 8601風形式

@item  @samp{%cI} 
コミッター日付 厳密なISO 8601形式

@item  @samp{%cs} 
コミッター日付 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ch} 
コミッター日付 人間が読める形式(git-rev-list(1) の @samp{--date=human} に似ている)

@item  @samp{%d} 
ref名 git-log(1) の --decorate オプションみたいなの

@item  @samp{%D} 
" (", ")" で囲ってないref名

@item  @samp{%(describe[:options])} 
git-describe(1) のような人間が読める名前。説明できないコミットの場合は空の文字列。 @samp{describe} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。タグの追加や削除を同時に行うと、説明に一貫性がなくなる可能性があります。

@itemize 

@item
@samp{tags[=<bool-value>]}: 注釈付きタグ(annotated tags)だけを考慮するのではなく、軽量タグ(lightweight tags)も考慮してください。

@item
@samp{abbrev=<number>}: 短縮ブジェクト名のデフォルトの 16 進数の桁数 (デフォルトは 7 で、リポジトリ内のオブジェクトの数によって異なります) を使用する代わりに、 <number> 桁数を指定するか、または 一意のオブジェクト名を形成するために必要な桁数。

@item
@samp{match=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグのみを考慮します。

@item
@samp{exclude=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグを対象にしません。
@end itemize

@item  @samp{%S} 
(@samp{git log --source} のような、)コマンドラインで指定した、コミットに到達したref名で、 @samp{git log} でのみ機能します。

@item  @samp{%e} 
エンコーディング

@item  @samp{%s} 
件名(subject)

@item  @samp{%f} 
ファイル名に適した、サニタイズされた件名

@item  @samp{%b} 
本文(body)

@item  @samp{%B} 
生本文(raw body)(行折り曲げされてない件名と本文)

@item  @samp{%N} 
コミットノート(commit notes)

@item  @samp{%GG} 
署名されたコミットの為のGPGからの生の検証メッセージ

@item  @samp{%G?} 
@table @asis

@item  G 
良い(good)な(有効な)署名の場合はこの文字に置換されます。

@item  B 
悪い署名(bad signature)の場合はこの文字に置換されます。

@item  U 
有効性が不明(unknown validity)な良い署名の場合はこの文字に置換されます。

@item  X 
期限切れ(eXpired)の良い署名の場合はこの文字に置換されます。

@item  Y 
期限切れのキーで作成された良い署名の場合はこの文字に置換されます。

@item  R 
取り消されたキーによって作成された良い署名の場合はこの文字に置換されます。

@item  E 
署名を確認できない場合(キーの欠落など)の場合はこの文字に置換されます。

@item  N 
署名がない場合の場合はこの文字に置換されます。
@end table

@item  @samp{%GS} 
署名されたコミットの署名者の名前を表示する

@item  @samp{%GK} 
署名されたコミットに署名するために使用されるキーを表示する

@item  @samp{%GF} 
署名されたコミットに署名するために使用されるキーのフィンガープリントを表示する

@item  @samp{%GP} 
署名付きコミットの署名に使用されたサブキー(subkey)の主キー(primary key)のフィンガープリントを表示します

@item  @samp{%GT} 
署名されたコミットに署名するために使用されるキーの信頼レベル(trust level)を表示します

@item  @samp{%gD} 
reflog セレクター(例えば @samp{refs/stash@@@{1@}} とか @samp{refs/stash@@@{2 minutes ago@}})。 この形式は、 @samp{-g} オプションで説明されている規則に従います。 @samp{@@} の前の部分は、コマンドラインで指定されたrefnameです(したがって、 @samp{git log -g refs/heads/master} は @samp{refs/heads/master@@@{0@}} を生成します)。

@item  @samp{%gd} 
短縮 reflog セレクター。 @samp{%gD} と同一ですが、人間が読みやすい形式でrefname部分が短縮されています(したがって、 @samp{refs/heads/master} は単に @samp{master} になります)。

@item  @samp{%gn} 
reflog ID名

@item  @samp{%gN} 
reflog ID名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ge} 
reflog ID 電子メールアドレス

@item  @samp{%gE} 
reflog ID 電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%gs} 
reflog 件名

@item  @samp{%(trailers[:options])} 
git-interpret-trailers(1) によって解釈されるようにボディのトレーラーを表示します。 @samp{trailers} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。いずれかのオプションが複数回提供された場合、それぞれ最後のものが優先されます。

@itemize 

@item
@samp{key=<key>}: 指定された <key> を持つトレーラーのみを表示します。マッチングは大文字と小文字を区別せずに行われ、末尾のコロンはオプションです。オプションが複数回指定されている場合、いずれかのキーに一致するトレーラー行が表示されます。このオプションは自動的に @samp{only} オプションを有効にして、トレーラーブロック内の非トレーラー行が非表示になるようにします。それが望ましくない場合は、 @samp{only=false} で無効にすることができます。 たとえば、 @samp{%(trailers:key=Reviewed-by)} は、キーが `Reviewed-by`のトレーラー行を表示します。

@item
@samp{only[=<bool>]}: トレーラーブロックに非トレーラー行を含めるかどうかを選択します。

@item
@samp{separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラー行は改行文字で終了します。文字列 <sep> には、上記のリテラルフォーマットコードが含まれる場合があります。区切り文字としてコンマを使用するには、次のオプションとして解析されないよう @samp{%x2C} を使用する必要があります。 たとえば、 @samp{%(trailers:key=Ticket,separator=%x2C )} は、キーが @samp{Ticket} であるすべてのトレーラー行をカンマとスペースで区切って表示します。

@item
@samp{unfold[=<bool>]}: interpret-trailer の @samp{--unfold} オプションが指定されたかのように動作させます。たとえば、 @samp{%(trailers:only,unfold=true)} が展開され、すべてのトレーラー行が表示されます。

@item
@samp{keyonly[=<bool>]}: トレーラーのキー部分のみを表示。

@item
@samp{valueonly[=<bool>]}: トレーラーの値部分のみ表示。

@item
@samp{key_value_separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラーのキーと値のペアは ": " で区切られます。 それ以外の場合は、上記の @samp{separator=<sep>} と同じセマンティクスを共有します。
@end itemize
@end table
@end itemize
@end itemize

@quotation

@strong{Note}

一部のプレースホルダーは、リビジョントラバーサルエンジンに指定された他のオプションに依存する場合があります。 たとえば、 @samp{%g*} reflogオプションは、reflogエントリをトラバースしない限り(たとえば、 @samp{git log -g} によって)空の文字列を挿入します。コマンドラインで @samp{--decorate} がまだ指定されていない場合、 @samp{%d} と @samp{%D} プレースホルダーは「短い」(short)装飾形式を使用します。
@end quotation

ブール値オプションは、オプションの値 @samp{[=<bool-value>]} を受け入れます。 値 @samp{true} 、@samp{false} 、 @samp{on} 、@samp{off} などはすべて受け入れられます。 git-config(1) の "EXAMPLES" の "boolean" サブセクションを参照してください。ブール値オプションが値なしで指定された場合、それは有効を指定した事になります。

プレースホルダーの @samp{%} の後に @samp{+} (プラス記号)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。

プレースホルダーの @samp{%} の後に @samp{-} (マイナス記号)を追加すると、プレースホルダーが空の文字列に展開された場合にのみ、展開の直前の連続するすべての改行が削除されます。

プレースホルダーの @samp{%} の後に " " (スペース)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前にスペースが挿入されます。

@itemize 

@item
@samp{tformat:}

@samp{tformat:} 形式は、 "separator" セマンティクスの代わりに "terminator" セマンティクスを提供することを除いて、 @samp{format:} とまったく同じように機能します。 つまり、各コミットには、エントリ間に区切り文字を配置するのではなく、メッセージターミネータ文字(通常は改行)が追加されます。 これは、「1行」形式と同様に、1行形式の最終エントリが新しい行で適切に終了することを意味します。 例えば以下のようになります:

@example
$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973
@end example


加えて、 @samp{%} が含まれている認識されない文字列は、その前に @samp{tformat:} があるかのように解釈(interpret)されます。 たとえば、以下の2つは同等です:

@example
$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef
@end example

@end itemize

@noindent

@chapheading DIFF FORMATTING

デフォルトでは、 @samp{git log} はdiff出力を生成しません。以下のオプションを使用して、各コミットによって行われた変更を表示できます。

注意: @samp{--diff-merges} のバリエーション(短い @samp{-m}、 @samp{-c}、 @samp{--cc} オプションを含む)の1つが明示的に指定されていない限り、マージコミットはdiffを表示しませんし、@samp{--patch`のようなdiff書式が選択されていても、}-S`のような検索オプションと一致しません。例外は、`--first-parent`が使用されている場合です。この場合、`first-parent`がデフォルトの書式です。

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p" (@pxref{Generating patch text with -p})).

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)} 
@itemx  @samp{--no-diff-merges} 
マージコミットに使用するdiff形式を指定します。 @samp{--first-parent} が使用されている場合を除き、デフォルトは @samp{off} です。使用されている場合は、 @samp{first-parent} がデフォルトです。

@table @asis

@item  @samp{--diff-merges=(off|none)} 
@itemx  @samp{--no-diff-merges} 
マージコミットのdiffの出力を無効にします。暗黙の値を上書きするのに便利です。

@item  @samp{--diff-merges=on} 
@itemx  @samp{--diff-merges=m} 
@itemx  @samp{-m} 
このオプションにより、マージコミットのdiff出力がデフォルトの形式で表示されます。 @samp{-m} は、 @samp{-p} も指定されている場合にのみ出力を生成します。デフォルトの形式は、 @samp{log.diffMerges} 構成パラメーター(configuration parameter)を使用して変更できます。デフォルト値は @samp{separate} です。

@item  @samp{--diff-merges=first-parent} 
@itemx  @samp{--diff-merges=1} 
このオプションにより、マージコミットは最初の親に関してのみ完全なdiffを表示します。

@item  @samp{--diff-merges=separate} 
これにより、マージコミットは各親に関して完全なdiffを表示します。親ごとに個別のログエントリとdiffが生成されます。

@item  @samp{--diff-merges=remerge} 
@itemx  @samp{--diff-merges=r} 
@itemx  @samp{--remerge-diff} 
このオプションを使用すると、2 つの親マージ・コミットが再マージされて、一時的なツリー・オブジェクトが作成されます。 — これには、競合マーカーなどを含むファイルが含まれる可能性があります。 次に、その一時ツリーと実際のマージ・コミットの間の差分が表示されます。

このオプションが使用されたときの出力は変更される可能性があり、他のオプションとの相互作用も変更される可能性があります (明示的に文書化されていない限り)。

@item  @samp{--diff-merges=combined} 
@itemx  @samp{--diff-merges=c} 
@itemx  @samp{-c} 
このオプションを使用すると、マージコミットのdiff出力は、親と結果のペアごとの差分を一度に1つずつ表示するのではなく、各親からの差分をマージ結果に同時に表示します。さらに、すべての親から変更されたファイルのみが一覧表示されます。 @samp{-c} は @samp{-p} の機能を含んでいます。

@item  @samp{--diff-merges=dense-combined} 
@itemx  @samp{--diff-merges=cc} 
@itemx  @samp{--cc} 
このオプションを使用すると、 @samp{--diff-merges=Combined} によって生成される出力は、親のコンテンツに2つの派生(variants)しかない、興味のないハンクを省略してさらに圧縮され、マージ結果は変更なしでそのうちの1つを選択します。 @samp{--cc} は @samp{-p} の機能を含んでいます。
@end table

@item  @samp{--combined-all-paths} 
このフラグにより、結合された差分(マージコミットに使用)にすべての親からのファイルの名前が一覧表示されます。したがって、これは @samp{--diff-merges=[dense-]combined} が使用されている場合にのみ有効であり、ファイル名の変更が検出された場合(つまり、名前の変更またはコピーの検出が要求された場合)にのみ役立つ可能性があります。

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
コミットごとに、生の差分形式を使用して変更の概要を表示します。
git-diff(1) の "RAW OUTPUT FORMAT" セクションを参照してください。
これは、ログ自体をraw形式で表示することとは異なります。
これは @samp{--format=raw} で
実現できます。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{-t} 
diff出力にツリーオブジェクトを表示します。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
改行(newline)ではなく、NULでコミットを区切ります。

また、 @samp{--raw} または @samp{--numstat} を指定した場合は、パス名を難読化(munge)したり、出力フィールドターミネータとしてNULを使用したりしないでください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。

@item  @samp{--no-color} 
カラーdiffをオフにします。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
diffを生成する場合は、コミットごとに名前の変更を検出して報告します。
履歴をトラバースしながら名前を変更してファイルをフォローする方法については、
@samp{--follow} を参照してください。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git log --no-merges} 
コミット履歴全体を表示しますが、マージはスキップします

@item  @samp{git log v2.6.12.. include/scsi drivers/scsi} 
バージョン v2.6.12 以降で include/scsi または drivers/scsi サブディレクトリ内のファイルの変更がある、すべてのコミットを表示します

@item  @samp{git log --since="2 weeks ago" -- gitk} 
gitk ファイルの変更について過去2週間の範囲で表示します。 @samp{--} は「ブランチ名のgitk」と混同しないようにするために必要です。

@item  @samp{git log --name-status release..test} 
「test」ブランチにはあるがまだ「release」ブランチにはないコミットを、各コミットが変更するパスのリストとともに表示します。

@item  @samp{git log --follow builtin/rev-list.c} 
ファイルに現在の名前が付けられる前に発生したコミット(訳注:つまりファイル名が変更される前の当該ファイル)を含め、@samp{builtin/rev-list.c} を変更したコミットを表示します。

@item  @samp{git log --branches --not --remotes=origin} 
ローカルブランチ origin にあり、 origin のリモート追跡ブランチのいずれにも存在していないコミットを表示します。

@item  @samp{git log master --not --remotes=*/master} 
ローカルmasterにはあるが、リモートリポジトリmasterブランチにはないすべてのコミットを表示します。

@item  @samp{git log -p -m --first-parent} 
変更の差分を含む履歴を表示しますが、「主ブランチ」の観点からのみ、マージされたブランチからのコミットをスキップし、マージによって導入された変更の完全な差分を表示します。これは、単一の統合ブランチにとどまり、そのブランチにすべてのトピックブランチをマージするという厳格なポリシーに従う場合にのみ意味があります。

@item  @samp{git log -L '/int main/',/^@}/:main.c} 
ファイル @samp{main.c} の関数 @samp{main()} が時間の経過とともにどのように進化したかを示します。

@item  @samp{git log -3} 
表示するコミットの数を3個に制限します。
@end table

@noindent

@chapheading DISCUSSION

Gitは、ある程度までは文字エンコードに依存しません。

@itemize 

@item
ブロブオブジェクトの内容は、解釈されていないバイトのシーケンスです。コアレベルでのエンコーディング変換はありません。

@item
パス名はUTF-8正規化形式C(UTF-8 normalization form C)でエンコードされます。これは、ツリーオブジェクト、インデックスファイル、ref名、およびコマンドライン引数、環境変数、構成ファイル( @samp{.git/config} (git-config(1) 参照) と gitignore(5) と gitattributes(5) と gitmodules(5)) のパス名に適用されます。

コアレベルのGitは、パス名を単に非NULバイトのシーケンスとして扱い、パス名をエンコードする変換はありません(MacとWindowsを除く)。したがって、非ASCIIパス名の使用は、レガシー拡張ASCIIエンコーディングを使用するプラットフォームやファイルシステムでもほとんど機能します。ただし、そのようなシステムで作成されたリポジトリは、UTF-8ベースのシステム(Linux、Mac、Windowsなど)では正しく機能しません。その逆も同様です。さらに、多くのGitベースのツールは、パス名がUTF-8であると単純に想定しており、他のエンコーディングを正しく表示できません。

@item
コミットログメッセージは通常UTF-8でエンコードされますが、他の拡張ASCIIエンコードもサポートされています。これには、ISO-8859-x、CP125xなどが含まれますが、UTF-16/32、EBCDIC、およびCJKマルチバイトエンコーディング(GBK、Shift-JIS、Big5、EUC-x、CP9xxなど)は含まれません。
@end itemize

我々はコミットログメッセージをUTF-8でエンコードすることをお勧めしますが、コアとGit Porcelainはどちらも、プロジェクトでUTF-8を強制しないように設計されています。特定のプロジェクトのすべての参加者がレガシーエンコーディングを使用する方が便利だと感じた場合、Gitはそれを禁止しません。 ただし、覚えておくべきことがいくつかあります。

@enumerate 

@item
@samp{git commit} と @samp{git commit-tree} は、プロジェクトがレガシーエンコーディングを使用していることを明示的に指定しない限り、与えられたコミットログメッセージが有効なUTF-8文字列のように見えない場合に警告を発します。明示的に指定する方法は、以下のように、 @samp{.git/config} ファイルに @samp{i18n.commitEncoding} を含めることです。

@example
[i18n]
        commitEncoding = ISO-8859-1
@end example


上記の設定で作成されたコミットオブジェクトは、 @samp{encoding} ヘッダーに @samp{i18n.commitEncoding} の値を記録します。 これは、後でそれらを見る他の人々を助けるためです。このヘッダーがないということは、コミットログメッセージがUTF-8でエンコードされていることを意味します。

@item
@samp{git log} や @samp{git show} や @samp{git blame} とその仲間たちは、コミットオブジェクトの @samp{encoding} ヘッダーを見て、特に指定がない限り、ログメッセージをUTF-8に再コーディングしようとします。あなたは以下のように、 @samp{.git/config} ファイルの @samp{i18n.logOutputEncoding} を使用して目的の出力エンコーディングを指定できます。

@example
[i18n]
        logOutputEncoding = ISO-8859-1
@end example


この構成変数がない場合は、代わりに @samp{i18n.commitEncoding} の値が使用されます。
@end enumerate

UTF-8への再コーディングは必ずしも可逆的な操作ではないため、我々はコミットが行われたときにコミットログメッセージを再コーディングしないことを意図的に選択したことに注意してください。

@noindent

@chapheading CONFIGURATION

コア変数については git-config(1) を、diff生成に関連する設定については git-diff(1) を参照してください。

@table @asis

@item  format.pretty 
@samp{--format} オプションのデフォルト。(上記「Pretty Formats」を参照してください。)デフォルトは medium です。

@item  i18n.logOutputEncoding 
ログを表示するときに使用するエンコーディング。(上記「Discussion」を参照してください。)デフォルトでは、設定されている場合は @samp{i18n.commitEncoding} の値になり、そうでない場合は UTF-8 になります。
@end table

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  log.abbrevCommit 
trueの場合、 linkgit:git-log [1] と git-show(1) と git-whatchanged(1) に @samp{--abbrev-commit} を想定させます。 このオプションは @samp{--no-abbrev-commit} で上書きできます。

@item  log.date 
@samp{log} コマンドのデフォルトの日時モードを設定します。 log.dateの値の設定は、 @samp{git log} の @samp{--date} オプションと同様です。 詳細については、 git-log(1) を参照してください。

形式が @samp{auto:foo} に設定されていて、ページャーが使用されている場合、形式 @samp{foo} が日付形式に使用されます。 それ以外の場合は、 @samp{default} が使用されます。

@item  log.decorate 
logコマンドで表示されるコミットのref名を出力します。 @samp{short} が指定されている場合、ref名の接頭辞 @samp{refs/heads/} と @samp{refs/tags/} と @samp{refs/remotes/} は出力されません。 @samp{full} が指定されている場合、完全なref名(接頭辞を含む)が出力されます。 @samp{auto} が指定されている場合、出力が端末に送られる場合、ref名は @samp{short} が指定されているかのように表示されます。それ以外の場合、ref名は表示されません。 これは、 @samp{git log} の @samp{--decorate} オプションと同じです。

@item  log.initialDecorationSet 
デフォルトでは、 @samp{git log} は特定の既知の ref 名前空間の装飾(decorations)のみを表示します。 @samp{all} が指定されている場合は、すべてのrefを装飾として表示します。

@item  log.excludeDecoration 
ログ装飾(log decorations)から指定されたパターンを除外します。 これは @samp{--decorate-refs-exclude} コマンドラインオプションに似ていますが、構成オプションは @samp{--decorate-refs} オプションで上書きできます。

@item  log.diffMerges 
Set diff format to be used when @samp{--diff-merges=on} is specified, see @samp{--diff-merges} in git-log(1) for details. Defaults to @samp{separate}.

@item  log.follow 
@samp{true} の場合、 @samp{git log} は、単一の<path>が指定されたときに @samp{--follow} オプションが使用されたかのように機能します。 これには @samp{--follow} と同じ制限があります。つまり、複数のファイルを追跡するために使用することはできず、非線形履歴ではうまく機能しません。

@item  log.graphColors 
@samp{git log --graph} で履歴線(history lines)を描画するために使用できる、コンマで区切られた色のリスト。

@item  log.showRoot 
trueの場合、最初のコミットは大きな作成イベントとして表示されます。 これは、空のツリーに対するdiffに相当します。 git-log(1) や git-whatchanged(1) などのツールは、通常はルートコミットを隠していますが、今後は表示されるようになります。 デフォルトでは True です。

@item  log.showSignature 
trueの場合、 git-log(1) と git-show(1) と git-whatchanged(1) に @samp{--show-signature} を想定させます。

@item  log.mailmap 
trueの場合、 git-log(1) と git-show(1) と git-whatchanged(1) で @samp{--use-mailmap} を想定させ、それ以外の場合は @samp{--no-use-mailmap} を想定させます。 デフォルトではtrueです。

@item  notes.mergeStrategy 
ノートの競合を解決するときにデフォルトで選択するマージ戦略。 @samp{manual} 、` ours`、 @samp{theirs}、` union` 、@samp{cat_sort_uniq} のいずれかである必要があります。 デフォルトは @samp{manual} です。 各戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

この設定は、 @samp{--strategy} オプションを git-notes(1) に渡すことでオーバーライドできます。

@item  notes.<name>.mergeStrategy 
@samp{refs/notes/<name>} にノートをマージするときに、どのマージ戦略を選択するか。 これは、より一般的な @samp{notes.mergeStrategy} をオーバーライドします。 利用可能な戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

@item  notes.displayRef 
@samp{git log} 系のコマンドでコミット・メッセージを表示する際に、 @samp{core.notesRef} や @samp{GIT_NOTES_REF} で設定したデフォルトに加えて、どのref (グロブ、または複数回指定されている場合は複数ref)からノートを読み込むかを指定します。

この設定は、 @samp{GIT_NOTES_DISPLAY_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

存在しないrefsに対しては警告が発行されますが、どのrefsにもマッチしないグロブは黙って無視されます。

この設定は、コマンドの @samp{git log} 系の @samp{--no-notes} オプション、またはこれらのコマンドで受け入れられる @samp{--notes=<ref>} オプションによって無効にすることができます。

@samp{core.notesRef} の有効な値(GIT_NOTES_REFによってオーバーライドされる可能性があります)も、表示されるrefのリストに暗黙的に追加されます。

@item  notes.rewrite.<command> 
<command> (現在は @samp{amend} または @samp{rebase})でコミットを書き換え、 そして、 この変数が @samp{false} に設定されている場合、git はノートを元のコミットから書き換えられたコミットにコピーしません。 デフォルトは @samp{true} です。 下記 @samp{notes.rewriteRef} も参照してください。

この設定は、 @samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

@item  notes.rewriteMode 
書き換え時にノートをコピーする場合(@samp{notes.rewrite.<command>} オプション参照)、ターゲットコミットにすでにノートがある場合の対処方法を決定します。 @samp{overwrite} 、 @samp{concatenate} 、 @samp{cat_sort_uniq} 、 @samp{ignore} のいずれかである必要があります。 デフォルトは @samp{concatenate} です。

この設定は、 @samp{GIT_NOTES_REWRITE_MODE} 環境変数でオーバーライドできます。

@item  notes.rewriteRef 
書き換え中にノートをコピーする場合は、ノートをコピーする(完全修飾された)refを指定します。 グロブと見なしたら、マッチするすべてのrefのノートがコピーされます。 この構成を複数回指定することもできます。

デフォルト値はありません。 ノートの書き換えを有効にするには、この変数を構成する必要があります。 デフォルトのコミットノートの書き換えを有効にするには、これを @samp{refs/notes/commits} に設定します。

@samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドできます。 その形式の詳細については、上記 @samp{notes.rewrite.<command>} を参照してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-ls-files,,,Top
@chapheading Name

git-ls-files — インデックスと作業ツリーのファイルに関する情報を表示する

@noindent

@chapheading Synopsis

@display
git ls-files [-z] [-t] [-v] [-f]
                [-c|--cached] [-d|--deleted] [-o|--others] [-i|--ignored]
                [-s|--stage] [-u|--unmerged] [-k|--killed] [-m|--modified]
                [--resolve-undo]
                [--directory [--no-empty-directory]] [--eol]
                [--deduplicate]
                [-x <pattern>|--exclude=<pattern>]
                [-X <file>|--exclude-from=<file>]
                [--exclude-per-directory=<file>]
                [--exclude-standard]
                [--error-unmatch] [--with-tree=<tree-ish>]
                [--full-name] [--recurse-submodules]
                [--abbrev[=<n>]] [--format=<format>] [--] [<file>…]
@end display


@noindent

@chapheading DESCRIPTION

これにより、インデックス内のファイルリストが実際の作業ディレクトリリストとマージされ、2つのさまざまな組み合わせが表示されます。

One or more of the options below may be used to determine the files shown, and each file may be printed multiple times if there are multiple entries in the index or multiple statuses are applicable for the relevant file selection options.

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-c} 
@itemx  @samp{--cached} 
Show all files cached in Git’s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)

@item  @samp{-d} 
@itemx  @samp{--deleted} 
Show files with an unstaged deletion

@item  @samp{-m} 
@itemx  @samp{--modified} 
Show files with an unstaged modification (note that an unstaged deletion also counts as an unstaged modification)

@item  @samp{-o} 
@itemx  @samp{--others} 
その他(たとえば 追跡されていない)ファイルを出力に表示します

@item  @samp{-i} 
@itemx  @samp{--ignored} 
Show only ignored files in the output. Must be used with either an explicit @emph{-c} or @emph{-o}. When showing files in the index (i.e. when used with @emph{-c}), print only those files matching an exclude pattern. When showing "other" files (i.e. when used with @emph{-o}), show only those matched by an exclude pattern. Standard ignore rules are not automatically activated, therefore at least one of the @samp{--exclude*} options is required.

@item  @samp{-s} 
@itemx  @samp{--stage} 
ステージングされたコンテンツのモードビット、オブジェクト名、ステージ番号を出力に表示します。

@item  @samp{--directory} 
If a whole directory is classified as "other", show just its name (with a trailing slash) and not its whole contents. Has no effect without -o/--others.

@item  @samp{--no-empty-directory} 
空のディレクトリをリストしないでください。 @samp{--directory} を指定していないと効果がありません。

@item  @samp{-u} 
@itemx  @samp{--unmerged} 
Show information about unmerged files in the output, but do not show any other tracked files (forces --stage, overrides --cached).

@item  @samp{-k} 
@itemx  @samp{--killed} 
Show untracked files on the filesystem that need to be removed due to file/directory conflicts for tracked files to be able to be written to the filesystem.

@item  @samp{--resolve-undo} 
Show files having resolve-undo information in the index together with their resolve-undo information. (resolve-undo information is what is used to implement "git checkout -m $PATH", i.e. to recreate merge conflicts that were accidentally resolved)

@item  @samp{-z} 
\ 0出力での行の終了であり、ファイルをクォートしません。 詳細については、以下の「OUTPUT」を参照してください。

@item  @samp{--deduplicate} 
ファイル名のみが表示されている場合は、マージ中に複数のステージがあること、または @samp{--deleted} と @samp{--modified} オプションを同時に指定することで発生する可能性のある重複を抑制します。 @samp{-t} または @samp{--unmerged} または @samp{--stage} オプションのいずれかが使用されている場合、このオプションは効果がありません。

@item  @samp{-x <pattern>} 
@itemx  @samp{--exclude=<pattern>} 
パターンに一致する追跡されていないファイルをスキップします。パターンはシェルワイルドカードパターンであることに注意してください。 詳細については、以下の「EXCLUDE PATTERNS」を参照してください。

@item  @samp{-X <file>} 
@itemx  @samp{--exclude-from=<file>} 
<file> から除外パターンを読み取ります。1行に1つづつです。

@item  @samp{--exclude-per-directory=<file>} 
Read additional exclude patterns that apply only to the directory and its subdirectories in <file>. Deprecated; use --exclude-standard instead.

@item  @samp{--exclude-standard} 
標準のGit除外を追加します: .git/info/exclude と 各ディレクトリの .gitignore と ユーザーのグローバル除外ファイル。

@item  @samp{--error-unmatch} 
<file> がインデックスに現れない場合は、これをエラーとして扱います(1を返します)。

@item  @samp{--with-tree=<tree-ish>} 
@samp{--error-unmatch} を使用して、ユーザーが指定した <file>（つまり、パスパターン）引数をパスに展開する場合、名前付きの <tree-ish> がまだ存在するためにインデックスから削除されたパスを装います。 このオプションを @samp{-s} または @samp{-u} オプションと一緒に使用しても意味がありません。

@item  @samp{-t} 
Show status tags together with filenames. Note that for scripting purposes, git-status(1) @samp{--porcelain} and git-diff-files(1) @samp{--name-status} are almost always superior alternatives, and users should look at git-status(1) @samp{--short} or git-diff(1) @samp{--name-status} for more user-friendly alternatives.

This option provides a reason for showing each filename, in the form of a status tag (which is followed by a space and then the filename). The status tags are all single characters from the following list:

@table @asis

@item  H 
tracked file that is not either unmerged or skip-worktree

@item  S 
tracked file that is skip-worktree

@item  M 
tracked file that is unmerged

@item  R 
tracked file with unstaged removal/deletion

@item  C 
tracked file with unstaged modification/change

@item  K 
untracked paths which are part of file/directory conflicts which prevent checking out tracked files

@item  ? 
untracked file

@item  U 
file with resolve-undo information
@end table

@item  @samp{-v} 
@samp{-t} に似ていますが、「assume unchanged」(変更されていないと仮定する)とマークされたファイルには小文字を使用します(git-update-index(1) を参照)。

@item  @samp{-f} 
@samp{-t} に似ていますが、「fsmonitor valid」とマークされているファイルには小文字を使用します(git-update-index(1) を参照)。

@item  @samp{--full-name} 
サブディレクトリから実行する場合、コマンドは通常、現在のディレクトリからの相対パスを出力します。 このオプションは、プロジェクトの最上位ディレクトリを基準にしたパスを強制的に出力します。

@item  @samp{--recurse-submodules} 
リポジトリ内のアクティブなサブモジュールごとに ls-files を再帰的に呼び出します。 現在、 @samp{--cached} モードと @samp{--stage} モードのみがサポートされています。

@item  @samp{--abbrev[=<n>]} 
40バイトの16進数のオブジェクト行全体を表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> の長さ16進数の長さの最短のプレフィックスを表示します。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{--debug} 
ファイルを説明する各行の後に、そのキャッシュエントリに関するデータを追加します。これは、手動検査のために可能な限り多くの情報を表示することを目的としています。正確な形式は予告なく変更される可能性があります。

@item  @samp{--eol} 
ファイルの <eolinfo> と <eolattr> を表示します。 <eolinfo> は、「text」属性が「auto」の場合(または設定されておらず、 core.autocrlf が false でない場合)にGitが使用するファイルコンテンツIDです。 <eolinfo> は、「-text」、「none」、「lf」、「crlf」、「mixed」、「」のいずれかです。

「」は、ファイルが通常のファイルではない、インデックスにない、または作業ツリーでアクセスできないことを意味します。

<eolattr> は、チェックアウトまたはコミット時に使用される属性であり、「」・「-text」・「text」・「text=auto」・「text eol=lf」・「text eol=crlf」 のいずれかです。 Git 2.10以降では「text=auto eol=lf」と「text=auto eol=crlf」がサポートされています。

通常のファイルの場合、インデックス("i/<eolinfo>")と作業ツリー("w/<eolinfo>")の両方の<eolinfo>が表示され、そのうしろに "attr/<eolattr>" が続きます。

@item  @samp{--sparse} 
インデックスがスパース(sparse)の場合、含まれているファイルに展開せずにスパース・ディレクトリを表示します。 スパース・ディレクトリは、 スパース・ディレクトリ @samp{x} の場合は @samp{x/} のように、末尾にスラッシュを付けて表示されます。

@item  @samp{--format=<format>} 
表示される各結果に対して <format> 文字列を適用します。その際 <format> 文字列中の @samp{%(fieldname)} は展開(interpolate)されます。 これはまた、 @samp{%%} を @samp{%} に展開し、@samp{%xx} (@samp{xx} は 16 進数字) を 16 進コード @samp{xx} のキャラクタに展開します。 たとえば、@samp{%00} は @samp{\0} (NUL) に、@samp{%09} は @samp{\t} (TAB) に、%0a は @samp{\n} (LF) に展開されます。 @samp{--format} は、 @samp{-s}, @samp{-o}, @samp{-k}, @samp{-t}, @samp{--resolve-undo}, @samp{--eol} と組み合わせることはできません。 (訳注: sprintf の 書式文字列 みたいに自由な文章書ける。意味は無いけど @samp{git ls-files --format='hogehoge'} とかもOK)

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <file> 
表示するファイル。ファイルが指定されていない場合、他の指定された基準に一致するすべてのファイルが表示されます。
@end table

@noindent

@chapheading OUTPUT

@samp{git ls-files} は、 @samp{--stage} が指定されていない限り、ファイル名を出力するだけです。指定されている場合は、以下のように出力されます:

@example
[<tag> ]<mode> <object> <stage> <file>
@end example

@samp{git ls-files --eol} の場合:
i/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><file>

@samp{git ls-files --unmerged} と @samp{git ls-files --stage} を使用して、マージされていないパスの詳細情報を調べることができます。

マージされていないパスの場合、単一の モード/SHA-1 ペアを記録する代わりに、インデックスは最大3つのそのようなペアを記録します。 ステージ1のツリーOから一つと、ステージ2のAから一つと、ステージ3のBからの一つです。この情報は、ユーザー(または磁器コマンド)がパスに最終的に記録する内容を確認するために使用できます。(状態の詳細については、 git-read-tree(1) を参照してください)

@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、「異常な」文字を含むパス名がクォートされます(git-config(1) を参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

@samp{%(fieldname)} 表記を使用してさまざまなフィールドを展開可能な @samp{--format} オプションを使用して、 カスタム形式で表示することができます。 たとえば、 @samp{objectname} フィールドと @samp{path} フィールドのみを気にする場合は、以下のような特定の @samp{--format} で実行できます

@example
git ls-files --format='%(objectname) %(path)'
@end example

@noindent

@chapheading FIELD NAMES

各パスの表示方法は、 @samp{--format=<format>} オプションを使用してカスタマイズできます。このオプションでは、インデックス・エントリのさまざまな側面の <format> 文字列の %(fieldname) が展開されます。以下の「フィールド名」(fieldname)に対応しています:

@table @asis

@item  objectmode 
インデックスに記録されるファイルのモード。

@item  objecttype 
The object type of the file which is recorded in the index.

@item  objectname 
インデックスに記録されるファイルの名前。

@item  objectsize[:padded] 
The object size of the file which is recorded in the index ("-" if the object is a @samp{commit} or @samp{tree}). It also supports a padded format of size with "%(objectsize:padded)".

@item  stage 
インデックスに記録されるファイルのステージ。

@item  eolinfo:index 
@itemx  eolinfo:worktree 
パスのインデックスまたはワークツリー内のコンテンツの <eolinfo> (@samp{--eol} オプションの説明を参照)。

@item  eolattr 
パスに適用される <eolattr> (@samp{--eol} オプションの説明を参照)。

@item  path 
インデックスに記録されるファイルのパス名。
@end table

@noindent

@chapheading EXCLUDE PATTERNS

@samp{git ls-files} は、ディレクトリツリーをトラバースし、フラグ @samp{--others} または @samp{--ignored} が指定されている場合に表示するファイルを検索するときに、「除外パターン」(exclude patterns)のリストを使用できます。 gitignore(5) は、除外パターンの形式を指定します。

Generally, you should just use --exclude-standard, but for historical reasons the exclude patterns can be specified from the following places, in order:

@enumerate 

@item
コマンドラインフラグ @samp{--exclude=<pattern>} は、単一のパターンを指定します。 パターンは、コマンドラインに現れるのと同じ順序で並べられます。

@item
コマンドラインフラグ @samp{--exclude-from=<file>} は、パターンのリストを含むファイルを指定します。 パターンは、ファイルに現れるのと同じ順序で並べられます。

@item
コマンドラインフラグ @samp{--exclude-per-directory=<name> ` は、 `git ls-files} が調べる各ディレクトリ内のファイルの名前(通常は @samp{.gitignore} )を指定します。 より深いディレクトリ内のファイルが優先されます。パターンは、ファイルに現れるのと同じ順序で並べられます。
@end enumerate

コマンドラインで @samp{--exclude} で指定されたパターン、または @samp{--exclude-from} で指定されたファイルから読み取られたパターンは、ディレクトリツリーの最上位を基準にしています。 @samp{--exclude-per-directory} で指定されたファイルから読み取られたパターンは、パターンファイルが置かれているディレクトリを基準にしています。

@noindent

@chapheading SEE ALSO

git-read-tree(1), gitignore(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-ls-remote,,,Top
@chapheading Name

git-ls-remote — リモートリポジトリの参照を一覧表示する

@noindent

@chapheading Synopsis

@display
git ls-remote [--heads] [--tags] [--refs] [--upload-pack=<exec>]
              [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]
              [--symref] [<repository> [<patterns>…]]
@end display


@noindent

@chapheading DESCRIPTION

リモートリポジトリで有効な参照を、関連するコミットIDとともに表示します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-h} 
@itemx  @samp{--heads} 
@itemx  @samp{-t} 
@itemx  @samp{--tags} 
それぞれ、refs/heads と refs/tags のみに制限します。これらのオプションは相互に排他的ではありません。両方を指定すると、 refs/heads と refs/tags に保存されている参照が表示されます。コマンドラインで他に何も指定せずに使用された @samp{git ls-remote -h} は、他のgitサブコマンドと同じようにヘルプを提供することに注意してください。

@item  @samp{--refs} 
ピーリングされたタグ(peeled tag)や @samp{HEAD} のような疑似参照(pseudoref)を出力に表示しないでください。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
stderrにリモートURLを出力しないでください。

@item  @samp{--upload-pack=<exec>} 
リモートホストの「git-upload-pack」のフルパスを指定します。これにより、SSH経由でアクセスされ、SSHデーモンがユーザーによって構成されたPATHを使用しないリポジトリからの参照を一覧表示できます。

@item  @samp{--exit-code} 
リモートリポジトリに一致する参照が見つからない場合は、ステータス「2」で終了します。通常、コマンドはステータス「0」で終了し、一致する参照が見つかったかどうかに関係なく、リモートリポジトリと正常に通信したことを示します。

@item  @samp{--get-url} 
@samp{url.<base>.insteadOf} 構成設定(git-config(1)を参照)を考慮して、指定されたリモートリポジトリのURLを展開し、リモートと通信せずに終了します。

@item  @samp{--symref} 
それが指すオブジェクトに加えて、シンボリックrefを表示するときに、それが指す基になるrefを表示します。 現在、upload-packはsymref HEADのみを表示するため、ls-remoteによって表示されるのはこれだけです。

@item  @samp{--sort=<key>} 
指定されたキーに基づいて並べ替えます。接頭辞 @samp{-} を使用して、値の降順で並べ替えます。 @samp{version:refname} または @samp{v:refname} をサポートします(タグ名はバージョンとして扱われます)。 @samp{version:refname} のソート順は、 @samp{versionsort.suffix} 構成変数の影響も受ける可能性があります。 その他の並べ替えオプションについては git-for-each-ref(1) を参照してください。ただし、オブジェクト自体へのアクセスを必要とする @samp{committerdate} のようなキーは、オブジェクトがまだリモートからフェッチされていないrefに対しては機能せず、 @samp{missing object} エラーが発生することに注意してください。

@item  @samp{-o <option>} 
@itemx  @samp{--server-option=<option>} 
プロトコルバージョン2を使用して通信する場合は、指定された文字列をサーバーに送信します。指定された文字列には、NULまたはLF文字を含めることはできません。 複数の @samp{--server-option=<option>} が指定されている場合、それらはコマンドラインにリストされている順序で送信されます。

@item  <repository> 
クエリする「リモート」リポジトリ。 このパラメーターは、URLまたはリモートの名前のいずれかです(git-fetch(1) の「GIT URLS」と「REMOTES」セクションを参照してください)。

@item  <patterns>… 
When unspecified, all references, after filtering done with --heads and --tags, are shown. When <patterns>… are specified, only references matching one or more of the given patterns are displayed. Each pattern is interpreted as a glob (see @samp{glob} in gitglossary(7)) which is matched against the "tail" of a ref, starting either from the start of the ref (so a full name like @samp{refs/heads/foo} matches) or from a slash separator (so @samp{bar} matches @samp{refs/heads/bar} but not @samp{refs/heads/foobar}).
@end table

@noindent

@chapheading OUTPUT

The output is in the format:

@example
<oid> TAB <ref> LF
@end example


When showing an annotated tag, unless @samp{--refs} is given, two such lines are shown: one with the refname for the tag itself as @samp{<ref>}, and another with @samp{<ref>} followed by @samp{^@{@}}. The @samp{<oid>} on the latter line shows the name of the object the tag points at.

@noindent

@chapheading EXAMPLES

@itemize 

@item
List all references (including symbolics and pseudorefs), peeling tags:

@example
$ git ls-remote
27d43aaaf50ef0ae014b88bba294f93658016a2e        HEAD
950264636c68591989456e3ba0a5442f93152c1a        refs/heads/main
d9ab777d41f92a8c1684c91cfb02053d7dd1046b        refs/heads/next
d4ca2e3147b409459955613c152220f4db848ee1        refs/tags/v2.40.0
73876f4861cd3d187a4682290ab75c9dccadbc56        refs/tags/v2.40.0^@{@}
@end example


@item
List all references matching given patterns:

@example
$ git ls-remote http://www.kernel.org/pub/scm/git/git.git master seen rc
5fe978a5381f1fbad26a80e682ddd2a401966740        refs/heads/master
c781a84b5204fb294c9ccc79f8b3baceeb32c061        refs/heads/seen
@end example


@item
List only tags matching a given wildcard pattern:

@example
$ git ls-remote --tags http://www.kernel.org/pub/scm/git/git.git v\*
485a869c64a68cc5795dd99689797c5900f4716d        refs/tags/v2.39.2
cbf04937d5b9fcf0a76c28f69e6294e9e3ecd7e6        refs/tags/v2.39.2^@{@}
d4ca2e3147b409459955613c152220f4db848ee1        refs/tags/v2.40.0
73876f4861cd3d187a4682290ab75c9dccadbc56        refs/tags/v2.40.0^@{@}
@end example

@end itemize

@noindent

@chapheading SEE ALSO

git-check-ref-format(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-ls-tree,,,Top
@chapheading Name

git-ls-tree — ツリーオブジェクトの内容を一覧表示します

@noindent

@chapheading Synopsis

@display
git ls-tree [-d] [-r] [-t] [-l] [-z]
            [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<format>]
            <tree-ish> [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

「/bin/ls -a」が現在の作業ディレクトリで行うことのように、特定のツリーオブジェクトの内容を一覧表示します。 ただし以下の点に注意してください:

@itemize 

@item
動作は「/bin/ls」の動作とは少し異なり、「<path>」は一致するパターンのリストのみを示します。 したがって、( @samp{-r} なしで)ディレクトリ名を指定すると動作が異なり、引数の順序は重要ではありません。

@item
@samp{<path>} が現在の作業ディレクトリを基準にして取得されるという点で、動作は「/bin/ls」の動作と似ています。例えば、あなたの現在の作業ディレクトリが「sub」で、その下にサブディレクトリ「dir」がある場合は、「git ls-tree -r HEAD dir」を実行すると、「dir」ツリーの内容を一覧表示できます(つまり、「HEAD」の「sub/dir」) 。あなたが、ルートレベル以外のツリーを直接指定したいとします(たとえば @samp{git ls-tree -r HEAD:sub dir} と指定します)。しかし、この場合は結果として @samp{HEAD} コミットで @samp{sub/sub/dir} を要求したことになります(そしてそんなディレクトリはないので何も表示されない)。ただし、 @samp{--full-tree} プションを渡すと、現在の作業ディレクトリを無視できます(つまり、 @samp{git ls-tree --fulltree -r HEAD:sub dir} とすれば意図したとおりに動く)
@end itemize

@noindent

@chapheading OPTIONS

@table @asis

@item  <tree-ish> 
ツリーっぽい何か(tree-ish)のID

@item  @samp{-d} 
名前付きツリーエントリ自体のみを表示し、その子供たちは表示しません。

@item  @samp{-r} 
サブツリーに再帰的に入っていきます

@item  @samp{-t} 
サブツリーに再帰的入っていく場合でも、ツリーエントリを表示します。 @samp{-r} が渡されなかった場合は効果がありません。 @samp{-d} は @samp{-t} の意味を含んでいます。

@item  @samp{-l} 
@itemx  @samp{--long} 
ブロブ(ファイル)エントリのオブジェクトサイズを表示します。

@item  @samp{-z} 
@samp{\0} (NULバイト)出力での行終了であり、ファイル名をクォートしません。 詳細については、以下の OUTPUT FORMAT を参照してください。

@item  @samp{--name-only} 
@itemx  @samp{--name-status} 
(「long」出力ではなく)ファイル名のみを1行に1つずつリストします。 @samp{--object-only} と組み合わせることはできません。

@item  @samp{--object-only} 
オブジェクトの名前のみを 1 行に 1 つずつリストします。 @samp{--name-only} または @samp{--name-status} と組み合わせることはできません。 これは、 @samp{--format='%(objectname)'} を指定するのと同じですが、このオプションとその正確な形式の両方で、コマンドは一般的なフォーマット・メカニズムを経由する代わりに、手動で最適化されたコードパス(hand-optimized codepath)を使用します。

@item  @samp{--abbrev[=<n>]} 
40バイトの16進オブジェクト行全体を表示する代わりに、オブジェクトを一意に参照できる、少なくとも @samp{<n>} 以上の長さの最短のプレフィックスを表示します。デフォルト以外の桁数は @samp{--abbrev=<n>} で指定できます。(訳注:手元ではデフォルトは10桁で表示された。 @samp{--abbrev=1} とすると5桁(一部6桁)表示となった)

@item  @samp{--full-name} 
現在の作業ディレクトリに関連するパス名を表示する代わりに、フルパス名を表示します。

@item  @samp{--full-tree} 
現在の作業ディレクトリを無視して、ルートレベルを起点として一覧表示します。 @samp{--full-name} の意味を含んでいます。

@item  @samp{--format=<format>} 
A string that interpolates @samp{%(fieldname)} from the result being shown. It also interpolates @samp{%%} to @samp{%}, and @samp{%xNN} where @samp{NN} are hex digits interpolates to character with hex code @samp{NN}; for example @samp{%x00} interpolates to @samp{\0} (NUL), @samp{%x09} to @samp{\t} (TAB) and @samp{%x0a} to @samp{\n} (LF). When specified, @samp{--format} cannot be combined with other format-altering options, including @samp{--long}, @samp{--name-only} and @samp{--object-only}.

@item  [<path>…] 
パスが指定されたら、それらを表示します(これは実際には生のパス名ではなく、一致するパターンのリストであることに注意してください)。 それ以外の場合は、ツリーのルートレベルを唯一のパス引数として暗黙的に使用します。
@end table

@noindent

@chapheading Output Format

@samp{ls-tree} の出力形式は、@samp{--format} オプションまたは @samp{--name-only} などの他の書式変更(format-altering)オプションのいずれかによって決定されます(上記 @samp{--format} 参照)。

特定の @samp{--format} ディレクティブを使用することは、これらのオプションを使用することと同等ですが、フルフルのフォーマット機構を呼び出すと、適切なフォーマット・オプションを使用するよりも遅くなる可能性があります。

@samp{--format} が既存のオプション @samp{ls-tree} に正確にマッピングされる場合、適切な高速パス(appropriate faster path)が使用されます。 したがって、デフォルトの形式は以下と同等です:

@example
%(objectmode) %(objecttype) %(objectname)%x09%(path)
@end example

この出力形式は、 @samp{git update-index} の @samp{--index-info--stdin} が期待するものと互換性があります。

@samp{-l} オプションを使用すると、形式が以下のように変わります

@example
%(objectmode) %(objecttype) %(objectname) %(objectsize:padded)%x09%(path)
@end example

<objectname> のオブジェクトのサイズ(@samp{%(objectsize:padded)})はバイト単位で表され、そのフィールドは最小幅 7 文字で右寄せされます。オブジェクト サイズは、 ブロブ (ファイル) エントリに対してのみ指定されます。 他のエントリでは、サイズの代わりに @samp{-} 文字が使用されます。

@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、「異常な」文字を含むパス名が引用符で囲まれます(git-config(1) を参照)。 @samp{-z} を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。

Customized format:

@samp{%(fieldname)} 表記を使用してさまざまなフィールドを展開できる @samp{--format} オプションを使用して、カスタム形式で表示することができます。 たとえば、 @samp{objectname} フィールドと @samp{path} フィールドのみを気にする場合は、以下のような特定の @samp{--format} で実行できます

@example
git ls-tree --format='%(objectname) %(path)' <tree-ish>
@end example

@noindent

@chapheading FIELD NAMES

Various values from structured fields can be used to interpolate into the resulting output. For each outputting line, the following names can be used:

@table @asis

@item  objectmode 
オブジェクトのモード。

@item  objecttype 
オブジェクトのタイプ(@samp{commit} または @samp{blob} または @samp{tree})。

@item  objectname 
オブジェクトの名前。

@item  objectsize[:padded] 
@samp{blob} オブジェクトのサイズ (@samp{commit} または @samp{tree} の場合は @samp{-})。また、 @samp{%(objectsize:padded)} を使用したサイズのパディング形式もサポートしています。

@item  path 
オブジェクトのパス名。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mailinfo,,,Top
@chapheading Name

git-mailinfo — 単一の電子メールメッセージからパッチと作成者を抽出します

@noindent

@chapheading Synopsis

@display
git mailinfo [-k|-b] [-u | --encoding=<encoding> | -n]
               [--[no-]scissors] [--quoted-cr=<action>]
               <msg> <patch>
@end display


@noindent

@chapheading DESCRIPTION

標準入力から単一の電子メールメッセージを読み取り、コミットログメッセージを <msg> ファイルに書き込み、パッチを <patch> ファイルに書き込みます。作者名と電子メールアドレスと電子メールの件名は、コミットを作成する @samp{git am} で使用するために標準出力に書き出されます。通常、このコマンドをユーザーが直接使用する必要はありません。代わりに git-am(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-k} 
通常、プログラムは、 @samp{Subject:} ヘッダー行から電子メール特有の断片文字列を取り除き、コミットログメッセージのタイトル行を取り出します。このオプションは、この変更をある程度防ぎ、 @samp{git format-patch -k} 出力を読み返すために使用する場合に最も役立つようにします。

具体的には、以下のものがなくなるまでは削除を行います:

@itemize 

@item
先頭と末尾の空白(whitespace)を削除。

@item
先頭の @samp{Re:} や @samp{re:} や @samp{:} を削除。

@item
先頭のブラケットで囲まれた文字列( @samp{[} 〜 @samp{]} 、
通常は @samp{[PATCH]} ) 。
@end itemize

最後に、空白類(whitespace)は単一のASCIIスペース文字(\x20)に正規化されます。

@item  @samp{-b} 
@samp{-k} が有効でない場合、 先頭のブラケット @samp{[} と @samp{]} のペアで囲まれたすべての文字列が削除されます。このオプションは、括弧で囲まれた文字列に @samp{PATCH} という単語が含まれているペアのみに削除を制限します。

@item  @samp{-u} 
コミットログメッセージ、作者名、作者の電子メールアドレスは電子メールから取得され、MIME転送エンコーディングを最小限にデコードした後、それらを変換することにより、 @samp{i18n.commitEncoding} (デフォルトはUTF-8) で指定された文字セットに再コーディングされます。これは以前はオプションでしたが、現在はデフォルトです。

注意: このフラグがあっても、パッチは常に文字セット変換なしでそのまま使用されることに注意してください。

@item  @samp{--encoding=<encoding>} 
@samp{-u} に似ています。 ただし、再コーディング時には、 @samp{i18n.commitEncoding} で指定された文字セットまたはUTF-8の代わりに、ここで指定した文字セットが使用されます。

@item  @samp{-n} 
メタデータのすべての文字セットの再コーディングを無効にします。

@item  @samp{-m} 
@itemx  @samp{--message-id} 
コミットメッセージの最後にあるMessage-IDヘッダーをコピーします。これは、コミットをメーリングリストのディスカッションに関連付けるのに役立ちます。

@item  @samp{--scissors} 
本文で切り取り線(例えば @samp{-- >8 --} )の前にあるすべてを取り除きます。 この線は、はさみ(scissors)とミシン目マークを表しており、その行でメッセージをカットするように読者に要求するために使用されます。パッチの前のメッセージの本文にその行が表示されている場合、このオプションを使用すると、その行の前のすべて(切り取り線の行自体を含む)が無視されます(訳注: @samp{>8} や @samp{8<} は「ハサミ」を示す絵文字)。

これは、返信するメッセージに関するコメントと提案を含むディスカッションスレッドでメッセージを開始し、パッチの送信でメッセージを終了し、ディスカッションと提案されたコミットログメッセージの開始を切り取り線で区切る場合に役立ちます。

これは、構成オプション mailinfo.scissors を使用してデフォルトで有効にできます。

@item  @samp{--no-scissors} 
切り取り線を無視します。 mailinfo.scissors 設定を上書きするのに便利です。

@item  @samp{--quoted-cr=<action>} 
base64またはquoted-printableエンコーディングで送信された電子メールメッセージを処理し、デコードされた行が単純なLFではなくCRLFで終了する場合の操作(action)を指定。

有効な操作(action)は:

@itemize 

@item
@samp{nowarn}: そのようなCRLFが見つかった場合、Gitは何もしません。

@item
@samp{warn}: そのようなCRLFが見つかった場合、
Gitはメッセージごとに警告を発行します。

@item
@samp{strip}: GitはそれらのCRLFをLFに変換します。
@end itemize

デフォルトの操作(action)は、構成オプション @samp{mailinfo.quotedCR} で設定できます。そのような構成オプションが設定されていない場合、 @samp{warn} が使用されます。

@item  <msg> 
電子メールから抽出されたコミットログメッセージ。通常、電子メールの件名から抽出したタイトル行は除きます。

@item  <patch> 
電子メールから抽出されたパッチ。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  mailinfo.scissors 
trueの場合、 git-mailinfo(1) (それゆえ git-am(1) も)は、コマンドラインで @samp{--scissors} オプションが指定されているかのようにデフォルトで動作します。この機能がアクティブな場合、メッセージ本文から切り取り線(つまり、主に ">8" や "8<" や "-" で構成される)行とそれより前のすべてを削除します。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mailsplit,,,Top
@chapheading Name

git-mailsplit — 簡易 UNIX mbox 分割プログラム

@noindent

@chapheading Synopsis

@display
git mailsplit [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]
                -o<directory> [--] [(<mbox>|<Maildir>)…]
@end display


@noindent

@chapheading DESCRIPTION

mboxファイルまたはMaildirを指定のディレクトリ内でファイルのリストに分割し("0001" "0002" ..)、そこからさらに処理できるようにします。

@quotation

@strong{Important}

Maildirの分割は、ファイル名が正しい順序でパッチを出力するためにソートされていることに依存しています。
@end quotation

@noindent

@chapheading OPTIONS

@table @asis

@item  <mbox> 
分割するmboxファイル。指定しない場合、mboxは標準入力から読み取られます。

@item  <Maildir> 
分割するMaildirのルート。このディレクトリには、cur と tmp とnew サブディレクトリが含まれている必要があります。

@item  @samp{-o<directory>} 
個々のメッセージを配置するディレクトリ。

@item  @samp{-b} 
ファイルがFrom行で始まらない場合は、エラーにするのではなく、単一のメールメッセージであると想定してください。

@item  @samp{-d<prec>} 
先行ゼロを含むデフォルトの4桁の代わりに、生成するファイル名に異なる桁数を指定できます。

@item  @samp{-f<nn>} 
出力ファイル名の最初の <nn> 番号までをスキップします。たとえば、 -f3 が指定されている場合は、番号を0004から始めます。

@item  @samp{--keep-cr} 
@samp{\r\n} で終わる行から @samp{\r} を削除しないでください。

@item  @samp{--mboxrd} 
入力は「mboxrd」形式であり、 "^>+From " 行のエスケープは逆になります。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-maintenance,,,Top
@chapheading Name

git-maintenance — Gitリポジトリのデータを最適化するためのタスクの実行

@noindent

@chapheading Synopsis

@display
git maintenance run [<options>]
git maintenance start [--scheduler=<scheduler>]
git maintenance (stop|register|unregister) [<options>]
@end display


@noindent

@chapheading DESCRIPTION

タスクを実行してGitリポジトリデータを最適化し、他のGitコマンドを高速化し、リポジトリのストレージ使用量を減らします。

リポジトリのデータを追加するGitコマンド、例えば @samp{git add} や @samp{git fetch} は、応答性の良いユーザー体験(user experience)を実現するために最適化されています。これらのコマンドは、Gitデータを最適化するのに時間がかかりません。なぜなら、これらのユーザーコマンドはそれぞれ比較的小さなアクションを実行するのに対して、その最適化はリポジトリのフルサイズでスケールするからです。

@samp{git maintenance} コマンドはGitリポジトリを最適化する方法に柔軟性を提供します。

@noindent

@chapheading SUBCOMMANDS

@table @asis

@item  run 
1つ以上のメンテナンスタスクを実行します。 1つ以上の @samp{--task} オプションが指定されている場合、それらのタスクは指定した順序で実行されます。 それ以外の場合、タスクは、どの @samp{maintenance.<task>.enabled} 構成オプションがtrueであるかによって決定されます。 デフォルトでは、 @samp{maintenance.gc.enabled} のみがtrueです。

@item  start 
現在のリポジトリでメンテナンスの実行を開始します。 これにより、 @samp{register} サブコマンドと同一構成の更新が実行され、バックグラウンドスケジューラが更新されて、1時間ごとに @samp{git maintenance run --scheduled} が実行されます。

@item  stop 
バックグラウンドメンテナンススケジュールを停止します。 バックグラウンドメンテナンスが後で再開された場合に備えて、現在のリポジトリはメンテナンスされたリポジトリのリストから削除されません。

@item  register 
Initialize Git config values so any scheduled maintenance will start running on this repository. This adds the repository to the @samp{maintenance.repo} config variable in the current user’s global config, or the config specified by --config-file option, and enables some recommended configuration values for @samp{maintenance.<task>.schedule}. The tasks that are enabled are safe for running in the background without disrupting foreground processes.

@samp{register} サブコマンドは、@samp{maintenance.strategy} 構成値が以前に設定されていない場合、@samp{maintenance.strategy} を @samp{incremental} に設定します。 @samp{incremental} 戦略では、メンテナンスタスクごとに以下のスケジュールを使用します:

@itemize 

@item
@samp{gc}: disabled.

@item
@samp{commit-graph}: hourly.

@item
@samp{prefetch}: hourly.

@item
@samp{loose-objects}: daily.

@item
@samp{incremental-repack}: daily.
@end itemize

@samp{git maintenance register} は、現在のリポジトリで @samp{maintenance.auto = false} を設定することにより、フォアグラウンドメンテナンスも無効にします。 この設定設定は、 @samp{git maintenance unregister} コマンドの後も残ります。

@item  unregister 
現在のリポジトリをバックグラウンドメンテナンスから削除します。 構成済みリストからリポジトリが削除されるだけです。 バックグラウンドメンテナンスプロセスの実行を停止することはありません。

The @samp{unregister} subcommand will report an error if the current repository is not already registered. Use the @samp{--force} option to return success even when the current repository is not registered.
@end table

@noindent

@chapheading TASKS

@table @asis

@item  commit-graph 
@samp{commit-graph} ジョブは @samp{commit-graph} ファイルを段階的に更新し、書き込まれたデータが正しいことを確認します。段階的書き込みは、前の @samp{commit-graph-chain} ファイルにあった @samp{.graph} ファイルを期限切れにしないため、並行Gitプロセスと一緒に安全に実行できます。 それらは、有効期限延長に基づいて、のちの実行で削除されます。

@item  prefetch 
@samp{prefetch} タスクは、登録されているすべてのリモートからの最新のオブジェクトでオブジェクトディレクトリを更新します。 リモートごとに、 @samp{git fetch} コマンドが実行されます。 構成されたrefspecは、要求されたすべてのrefを @samp{refs/prefetch/} 内に配置するように変更されます。 また、タグは更新されません。

これは、リモート追跡ブランチの一時不通(disrupting)を回避するために行われます。 エンドユーザーは、フェッチを開始しない限り、これらのrefが移動されないままになることを期待しています。 ただし、prefetchタスクでは、後で実際のフェッチを完了するために必要なオブジェクトがすでに取得されているため、実際のフェッチはより高速になります。 理想的なケースでは、オブジェクトを転送せずに、一連のリモート追跡ブランチの更新ができます。

@item  gc 
不要なファイルをクリーンアップし、ローカルリポジトリを最適化します。 「GC」は「ガベージコレクション」の略で、このタスクは多くの小さなタスクを実行します。 このタスクは、すべてのGitオブジェクトを単一のパックファイルに再パックするため、大規模なリポジトリではコストがかかる可能性があります。 また、古いデータを削除するため、状況によっては混乱を招く可能性があります。 Gitでのガベージコレクションの詳細については、 git-gc(1) を参照してください。

@item  loose-objects 
@samp{loose-objects} ジョブは、緩いオブジェクト(loose objects)をクリーンアップし、パックファイルに配置します。 並行Gitコマンドによる競合状態を防ぐために、2段階で処理を行います。 まず、パックファイルにすでに存在する緩いオブジェクトを削除します。 並行Gitプロセスは、緩いオブジェクトではなく、オブジェクトデータのパックファイルを調べます。 次に、緩いオブジェクトのバッチを含む新しいパックファイル(@samp{loose-} で始まる)を作成します。 バッチサイズは5万オブジェクトに制限されており、多量の緩いオブジェクトがあるリポジトリでジョブに時間がかかりすぎるのを防ぎます。 @samp{gc} タスクは、到達不能なオブジェクトを、パックファイルに再追加されない場合にのみ、後の段階でクリーンアップされる緩いオブジェクトとして書き込みます。 このため、 @samp{loose-objects} タスクと @samp{gc} タスクの両方を同時に有効にすることはお勧めできません。

@item  incremental-repack 
@samp{incremental-repack} ジョブは、 @samp{multi-pack-index} 機能を使用してオブジェクトディレクトリを再パックします。 並行Gitコマンドによる競合状態を防ぐために、2段階の処理を行います。 まず、 @samp{gitmulti-pack-indexexpire} を呼び出して @samp{multi-pack-index} ファイルによって参照されていないパックファイルを削除します。 次に、 @samp{git multi-pack-index repack} を呼び出して、いくつかの小さなパックファイルを選択し、それらをより大きなファイルに再パックし、次に、小さなパックファイルを参照する @samp{multi-pack-index} エントリを更新して、新しいパックファイルを参照します。 これにより、これらの小さなパックファイルは、次回の @samp{gitmulti-pack-indexexpire} の実行時に削除できるようになります。 小さいパックファイルの選択は、大きいパックファイルの予想サイズが少なくともバッチサイズになるように行われます。 git-multi-pack-index(1) の @samp{repack} サブコマンドの @samp{--batch-size} オプションを参照してください。 デフォルトのバッチサイズはゼロです。これは、すべてのパックファイルを単一のパックファイルに再パックしようとする特殊なケースです。

@item  pack-refs 
@samp{pack-refs} タスクは、緩い参照ファイル(loose reference files)を収集し、それらを1つのファイルに纏めます。 これにより、多くの参照間で反復する必要のある操作が高速化されます。 詳細については、 git-pack-refs(1) を参照してください。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--auto} 
@samp{run} サブコマンドと組み合わせると、特定のしきい値が満たされた場合にのみメンテナンスタスクを実行します。 たとえば、 @samp{gc} タスクは、緩いオブジェクトの数が @samp{gc.auto} 構成設定に格納されている数を超えた場合、またはパックファイルの数が @samp{gc.autoPackLimit} 構成設定を超えた場合に実行されます。 @samp{--schedule} オプションとは互換性がありません。

@item  @samp{--schedule} 
@samp{run} サブコマンドと組み合わせると、 各 @samp{<task>} の @samp{maintenance.<task>.schedule} 構成値で指定されているように、特定の時間条件が満たされた場合にのみメンテナンスタスクを実行します。 この構成値は、@samp{maintenance.<task>.lastRun} 構成値に従って、そのタスクが最後に実行されてからの秒数を指定します。 テストされるタスクは、 @samp{--task=<task>} オプションによって提供されるタスク、または @samp{maintenance.<task>.enabled} がtrueに設定されているタスクです。

@item  @samp{--quiet} 
(stderrを介して)進捗状況やその他の情報を報告しないでください。

@item  @samp{--task=<task>} 
このオプションを1回以上指定した場合は、指定したタスクを指定した順序でのみ実行してください。 @samp{--task=<task>} 引数が指定されていない場合、 @samp{maintenance.<task>.enabled} が @samp{true} として構成されているタスクのみが考慮されます。 受け入れられる @samp{<task>} 値のリストについては、「TASKS」セクションを参照してください。

@item  @samp{--scheduler=auto|crontab|systemd-timer|launchctl|schtasks} 
@samp{start} サブコマンドと組み合わせる場合は、 @samp{git maintenance run} を毎時(hourly)、毎日(daily)、毎週(weekly)に実行するスケジューラーを指定します。 @samp{<scheduler>} に指定できる値は、 @samp{auto} 、 @samp{crontab}(POSIX)、 @samp{systemd-timer}(Linux)、 @samp{launchctl}(macOS)、 @samp{schtasks}(Windows) です。 @samp{auto} が指定されている場合、適切なプラットフォーム固有のスケジューラが使用されます。 Linuxでは、使用可能な場合は @samp{systemd-timer} が使用され、 @samp{systemd-timer} が使用できない場合は @samp{crontab} が使用されます。 デフォルトは`auto`です。
@end table

@noindent

@chapheading TROUBLESHOOTING

@samp{git maintenance} コマンドは、Gitコマンド実行中のユーザーの待ち時間を最小限に抑えながら、リポジトリのメンテナンスパターンを簡素化するように設計されています。この処理をカスタマイズできるように、さまざまな構成オプションを利用できます。 デフォルトのメンテナンスオプションは、大規模なリポジトリであっても、迅速に完了する操作に重点を置いています。

スケジュールされたメンテナンスタスクが、ユーザーが意図したほど頻繁に実行されない場合があります。 各 @samp{git maintenance run} コマンドは、リポジトリのオブジェクトデータベースをロックします。これにより、他の並列の @samp{git maintenance run} コマンドが同じリポジトリで実行されなくなります。この安全柵がないと、競合するプロセスによってリポジトリが予測できない状態になる可能性があります。

バックグラウンドメンテナンススケジュールは、1時間ごとに @samp{git maintenance run} プロセスを実行します。 実行するたびに、「毎時」のタスクが実行されます。 深夜に、そのプロセスは「毎日」のタスクも実行します。 週の最初の日の深夜に、そのプロセスは「毎週」のタスクも実行します。 単一のプロセスが登録された各リポジトリを反復処理し、その頻度でスケジュールされたタスクを実行します。 登録されているリポジトリの数とそのサイズによっては、このプロセスに1時間以上かかる場合があります。 この場合、複数の @samp{git maintenance run} コマンドが同じリポジトリで同時に実行され、オブジェクトデータベースのロックを引き起こす可能性があります。 これにより、2つのタスクのどちらかが実行されなくなります。

一部のメンテナンスウィンドウの完了に1時間以上かかる場合は、メンテナンスタスクの複雑さを軽減することを検討してください。 たとえば、 @samp{incremental-repack} タスクは @samp{gc} タスクよりもはるかに高速です。しかし、その代償として、オブジェクトデータベースが若干大きくなってしまいます。 より高価なタスクを移動して、実行頻度を減らすことを検討してください。

エキスパートユーザーは、 @samp{git maintenance start} およびGit構成オプションで利用できるスケジュールとは異なるスケジュールを使用して独自のメンテナンスタスクをスケジュールすることを検討できます。 これらのユーザーは、オブジェクトデータベースのロックと、並列実行の @samp{git maintenance run} コマンドの動作に注意する必要があります。 さらに、@samp{git gc} コマンドを @samp{git maintenance run} コマンドと組み合わせないでください。 @samp{git gc} はオブジェクトデータベースを変更しますが、 @samp{git maintenance run} のようにロックを取得しません。 可能であれば、 @samp{git gc} の代わりに @samp{git maintenance run --task=gc} を使用してください。

次のセクションでは、 @samp{git maintenance start} によるバックグラウンドメンテナンスを実行するために導入されたメカニズムとそれらをカスタマイズする方法について説明します。

@noindent

@chapheading BACKGROUND MAINTENANCE ON POSIX SYSTEMS

POSIXシステムでバックグラウンドタスクをスケジュールするための標準メカニズムは cron(8) です。 このツールは、指定されたスケジュールに基づいてコマンドを実行します。 ユーザーがスケジュールしたタスクの現在のリストは、@samp{crontab -l} を実行することで見つけることができます。 @samp{git maintenances tart} が書いたスケジュールは以下のようになります:

@example
# BEGIN GIT MAINTENANCE SCHEDULE
# The following schedule was created by Git
# Any edits made in this region might be
# replaced in the future by a Git command.

0 1-23 * * * "/<path>/git" --exec-path="/<path>" for-each-repo --config=maintenance.repo maintenance run --schedule=hourly
0 0 * * 1-6 "/<path>/git" --exec-path="/<path>" for-each-repo --config=maintenance.repo maintenance run --schedule=daily
0 0 * * 0 "/<path>/git" --exec-path="/<path>" for-each-repo --config=maintenance.repo maintenance run --schedule=weekly

# END GIT MAINTENANCE SCHEDULE
@end example


コメントは、Gitによって作成されたスケジュールをマークするための領域として使用されます。 この領域内の変更は、 @samp{git maintenance stop} によって完全に削除されるか @samp{git maintenance start} によって上書きされます。

@samp{crontab} エントリは、実行された @samp{git} コマンドが @samp{PATH} とは無関係に @samp{git maintenance start} が発行したものと同じであることを保証するために @samp{git} 実行可能ファイルのフルパスを指定します。 同じユーザーが複数のGit実行可能ファイルで @samp{git maintenance start} を実行する場合、最新の実行可能ファイルのみが使用されます。

これらのコマンドは、 @samp{git for-each-repo --config=maintenance.repo} を使用して、複数値の @samp{maintenance.repo} 構成オプションにリストされている各リポジトリで @samp{git maintenance run --schedule=<frequency>} を実行します。 これらは通常、ユーザー固有のグローバル構成からロードされます。 次に、 @samp{git maintenance} プロセスは @samp{maintenance.<task>.schedule} 設定オプションを使用して、 各 @samp{<frequency>} で各リポジトリで実行するように設定されているメンテナンスタスクを決定します。 これらの値は、グローバルまたはリポジトリ構成値からロードされます。

構成値が、目的のバックグラウンドメンテナンススケジュールを達成するには不十分な場合は、あなた独自のスケジュールを作成できます。 @samp{crontab -e} を実行すると、エディターはユーザー固有の @samp{cron} スケジュールをロードします。 そのエディターでは、独自のスケジュール行を追加できます。 あなたは前述のデフォルトのスケジュールを採用することから始めるか、あるいは高度なスケジューリング手法について crontab(5) のドキュメントを読むことができます。 あなたのスケジュールで正しいバイナリを実行していることを確認するために、デフォルトのスケジュールから、フルパスと @samp{--exec-path} の手法を流用してください。

@noindent

@chapheading BACKGROUND MAINTENANCE ON LINUX SYSTEMD SYSTEMS

Linux は @samp{cron} をサポートしていますが、ディストリビューションによっては @samp{cron} はオプションパッケージで、必ずしもインストールされるとは限りません。最近の Linux ディストリビューションでは、systemd タイマー がこれに取って代わっています。

ユーザーsystemdタイマーが使用可能な場合、それらが @samp{cron} の代わりに使用されます。

この場合、 @samp{git Maintenance start} はユーザーsystemdタイマーユニットを作成し、タイマーを開始します。 ユーザーがスケジュールしたタスクの現在のリストは、 @samp{systemctl --user list-timers} を実行することで見つけることができます。 @samp{git maintenance start} によって書かれたタイマー以下のような感じになります:

@example
$ systemctl --user list-timers
NEXT                         LEFT          LAST                         PASSED     UNIT                         ACTIVATES
Thu 2021-04-29 19:00:00 CEST 42min left    Thu 2021-04-29 18:00:11 CEST 17min ago  git-maintenance@@hourly.timer git-maintenance@@hourly.service
Fri 2021-04-30 00:00:00 CEST 5h 42min left Thu 2021-04-29 00:00:11 CEST 18h ago    git-maintenance@@daily.timer  git-maintenance@@daily.service
Mon 2021-05-03 00:00:00 CEST 3 days left   Mon 2021-04-26 00:00:11 CEST 3 days ago git-maintenance@@weekly.timer git-maintenance@@weekly.service
@end example


@samp{--schedule=<frequency>} オプションごとに1つのタイマーが登録されます。

systemdユニットの定義は、以下のファイルで調べることができます:

@example
~/.config/systemd/user/git-maintenance@@.timer
~/.config/systemd/user/git-maintenance@@.service
~/.config/systemd/user/timers.target.wants/git-maintenance@@hourly.timer
~/.config/systemd/user/timers.target.wants/git-maintenance@@daily.timer
~/.config/systemd/user/timers.target.wants/git-maintenance@@weekly.timer
@end example


@samp{git maintenance start} はこれらのファイルを上書きし、 @samp{systemctl --user} でタイマーを再開するため、カスタマイズは差し込み式ファイル(drop-in file)ドロップインファイル、つまり @samp{~/.config/systemd/user/git-maintenance@@.service.d} ディレクトリに @samp{.conf} 拡張子のファイルを作成して行う必要があります。

@samp{git maintenance stop} は、ユーザーのsystemdタイマーを停止し、上記のファイルを削除します。

詳細は @samp{systemd.timer(5)} を参照して下さい。

@noindent

@chapheading BACKGROUND MAINTENANCE ON MACOS SYSTEMS

macOSは技術的には @samp{cron} をサポートしていますが、 @samp{crontab -e} を使用するには昇格された権限が必要であり、実行されるプロセスには完全なユーザーコンテキストがありません。 完全なユーザーコンテキストがないと、Gitとその資格情報ヘルパーは保存されている資格情報にアクセスできないため、一部のメンテナンスタスクは機能しません。

代わりに、 @samp{git maintenance start} は @samp{launchctl} ツールと相呼応します。これはmacOSで時限ジョブをスケジュールするための推奨される方法です。 @samp{git maintenance (start|stop)} によるメンテナンスのスケジュールには、macOS10.11以降でのみ利用可能ないくつかの @samp{launchctl} 機能が必要です。

ユーザー固有のスケジュールされたタスクは、XML形式の @samp{.plist} ファイルとして @samp{~/Library/LaunchAgents/} に保存されます。 あなたは以下のコマンドを使用して、現在登録されているタスクを確認できます:

@example
$ ls ~/Library/LaunchAgents/org.git-scm.git*
org.git-scm.git.daily.plist
org.git-scm.git.hourly.plist
org.git-scm.git.weekly.plist
@end example


@samp{--schedule=<frequency>} オプションごとに1つのタスクが登録されます。 XML形式で各スケジュールがどのように記述されているかを調べるには、これらの @samp{.plist} ファイルの1つをエディターで開き、 @samp{<key>StartCalendarInterval</key>} 要素に続く`<array>` 要素を調べます。

@samp{git maintenance start} はこれらのファイルを上書きし、タスクを @samp{launchctl} に再度登録するため、カスタマイズは、個別の名前で独自の @samp{.plist} ファイルを作成して行う必要があります。 同様に、 @samp{git maintenance stop} コマンドは @samp{launchctl} でタスクの登録を解除し、 @samp{.plist} ファイルを削除します。

バックグラウンドタスクのより高度なカスタマイズの作成の詳細については launchctl.plist(5) を参照してください。

@noindent

@chapheading BACKGROUND MAINTENANCE ON WINDOWS SYSTEMS

Windowsは @samp{cron} をサポートしておらず、代わりにバックグラウンドタスクをスケジュールするための独自のシステムを備えています。 @samp{git maintenance start} コマンドは、 @samp{schtasks} コマンドを使用してこのシステムにタスクを送信します。 タスクスケジューラアプリケーションを使用して、すべてのバックグラウンドタスクを検査できます。 Gitによって追加されたタスクには、 @samp{Git Maintenance (<frequency>)} という形式の名前が付いています。 タスクスケジューラGUIには、これらのタスクを検査する方法がありますが、タスクをXMLファイルにエクスポートして、そこで詳細を表示することもできます。

注意: Gitはコンソールアプリケーションであるため、これらのバックグラウンドタスクにより、現在のユーザーに表示されるコンソールウィンドウが作成されることに注意してください。 これは、タスクスケジューラの「Run whether user is logged in or not」(ユーザーがログインしているかどうかに関係なく実行する)オプションを選択することで手動で変更できます。 この変更にはパスワードの入力が必要で、そのため @samp{git maintenance start} はデフォルトではこのオプションを選択しません。

バックグラウンドタスクをカスタマイズする場合は、タスクの名前を変更して、その後に @samp{git maintenance (start|stop)} を呼び出してもカスタムタスクが上書きされないようにしてください。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  maintenance.auto 
このブール構成オプションは、一部のコマンドが通常の作業を行った後に @samp{git maintenance run --auto} を実行するかどうかを制御します。 デフォルトはtrueです。

@item  maintenance.strategy 
この文字列設定オプションは、バックグラウンドメンテナンスのいくつかの推奨スケジュールの1つを指定する方法を提供します。 これは、 @samp{--task=<task>} 引数が指定されていない場合、 @samp{git maintenance run --schedule=X} コマンド中に実行されるタスクにのみ影響します。 さらに、 @samp{maintenance.<task>.schedule} 構成値が設定されている場合、 @samp{maintenance.strategy} によって提供される値の代わりにその値が使用されます。 戦略として指定可能な文字列は以下のとおりです:

@itemize 

@item
@samp{none}: このデフォルト設定は、どのスケジュールでもタスクが実行されないことを意味します。

@item
@samp{incremental}: この設定は、データを削除しない小さなメンテナンスアクティビティの実行に最適化されています。 これは @samp{gc} タスクをスケジュールしませんが、 @samp{prefetch} および @samp{commit-graph} タスクを1時間ごとに実行し、 @samp{loose-objects} および @samp{incremental-repack} タスクを毎日実行し、 @samp{pack-refs} タスクを毎週実行します。
@end itemize

@item  maintenance.<task>.enabled 
このブール構成オプションは、 @samp{git maintenance run} に @samp{--task} オプションが指定されていない場合に、 @samp{<task>} という名前のメンテナンスタスクを実行するかどうかを制御します。 @samp{--task} オプションが存在する場合、これらの構成値は無視されます。 デフォルトでは、 @samp{maintenance.gc.enabled} のみがtrueです。

@item  maintenance.<task>.schedule 
この設定オプションは、指定された @samp{<task>} が @samp{git maintenance run --schedule=<frequency>} コマンド中に実行されるかどうかを制御します。 値は、 "hourly", "daily", "weekly" のいずれかである必要があります。

@item  maintenance.commit-graph.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{commit-graph} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{commit-graph} タスクは`--auto` オプションで実行されません。負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、commit-graphファイルにない到達可能なコミットの数が @samp{maintenance.commit-graph.auto} の値以上であるときにコマンドを実行する必要があることを意味します。デフォルト値は100です。

@item  maintenance.loose-objects.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{loose-objects} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{loose-objects} タスクは @samp{--auto} オプションでは実行されません。 負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、緩いオブジェクト(loose objects)の数が @samp{maintenance.loose-objects.auto} の値以上であるときにコマンドを実行する必要があることを意味します。 デフォルト値は100です。

@item  maintenance.incremental-repack.auto 
この整数値構成オプションは、 @samp{git maintenance run --auto} の一部として @samp{incremental-repack} タスクを実行する頻度を制御します。 ゼロの場合、 @samp{incremental-repack} タスクは @samp{--auto} オプションでは実行されません。 負の値を指定すると、タスクは毎回実行されます。 それ以外の場合、正の値は、multi-pack-indexにないpack-fileの数が @samp{maintenance.incremental-repack.auto} の値以上であるときにコマンドを実行する必要があることを意味します。 デフォルト値は10です。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge-base,,,Top
@chapheading Name

git-merge-base — マージのために可能な限り良い共通の祖先を見つけます

@noindent

@chapheading Synopsis

@display
git merge-base [-a | --all] <commit> <commit>…
git merge-base [-a | --all] --octopus <commit>…
git merge-base --is-ancestor <commit> <commit>
git merge-base --independent <commit>…
git merge-base --fork-point <ref> [<commit>]
@end display


@noindent

@chapheading DESCRIPTION

@samp{git merge-base} は、3方向マージで使用する2つのコミット間で最良の共通の祖先を探します。「ある共通の祖先」の祖先が、「別の共通の祖先」である場合、「ある共通の祖先」は「別の共通の祖先」よりも「より良い」です。より良い共通の祖先を持たない共通の祖先は、「最良の共通の祖先」、つまり「マージベース」です。注意: コミットのペアに対して複数のマージベースが存在する可能性があることに注意してください。

@noindent

@chapheading OPERATION MODES

最も一般的な特別のケースとして、コマンドラインで2つのコミットのみを指定することは、指定された2つのコミット間のマージベースを計算することを意味します。

より一般的には、マージベースを計算する2つのコミットのうち、1つはコマンドラインの最初のコミット引数で指定されます。もう1つのコミットは、コマンドラインの残りのすべてのコミットをマージする(おそらく仮想の)コミットです。

結果として、3つ以上のコミットが指定されている場合、「マージベース」は必ずしも各コミット引数に含まれているとは限りません。 これは、 @samp{--merge-base} オプションを伴った git-show-branch(1) とは異なります。

@table @asis

@item  @samp{--octopus} 
n方向マージの準備として、提供されたすべてのコミットの最良の共通の祖先を計算します。これは、 @samp{git show-branch --merge-base} の振る舞いを模倣しています。

@item  @samp{--independent} 
マージベースを出力する代わりに、提供されたコミットの最小限のサブセットを同一祖先で出力します。言い換えれば、与えられたコミットの中にで他から到達できないコミットをリストします。これは、 @samp{git show-branch --independent} の振る舞いを模倣しています。

@item  @samp{--is-ancestor} 
1番目の <commit> が2番目の <commit> の祖先であるかどうかを確認し、trueの場合はステータス0で終了し、そうでない場合はステータス1で終了します。 エラーは、1では無い、かつ、ゼロ以外のステータスによって通知されます。

@item  @samp{--fork-point} 
ブランチ(または <commit> につながる履歴)が、別のブランチ(または参照) <ref> から分岐したポイントを見つけます。これは、2つのコミットの共通の祖先を探すだけでなく、 <ref> のreflogを考慮して、 <commit> につながる履歴がブランチ <ref> の以前の実体(incarnation)から分岐したかどうかを確認します(下記の、このモードに関するdiscussionを参照してください)。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
@itemx  @samp{--all} 
1つだけではなく、コミットのすべてのマージベースを出力します。
@end table

@noindent

@chapheading DISCUSSION

2つのコミット「A」と「B」が与えられると、「git merge-base A B」は、親子関係を辿って「A」と「B」の両方から到達可能なコミットを出力します。

たとえば、このトポロジでは以下のようになります:

@example
         o---o---o---B
        /
---o---1---o---o---o---A
@end example

「A」と「B」の間のマージベースは「1」です。

3つのコミット「A」、「B」、「C」が与えられると、「git merge-base A B C」は、「A」と仮想のコミット「M」の間のマージベースを計算します。仮想のコミット「M」は、「B」と「C」のマージです。たとえば、このトポロジでは以下のようになります:

@example
       o---o---o---o---C
      /
     /   o---o---o---B
    /   /
---2---1---o---o---o---A
@end example

@samp{git merge-base A B C} の結果は「1」です。 これは、「B」と「C」の間にマージコミット「M」がある同等のトポロジが以下のとおりであるためです:

@example
       o---o---o---o---o
      /                 \
     /   o---o---o---o---M
    /   /
---2---1---o---o---o---A
@end example

そして、 @samp{git merge-base A M} の結果は「1」です。 コミット「2」も「A」と「M」の間の共通の祖先ですが、「2」は「1」の祖先であるため、「1」の方がよりよい共通の祖先です。 したがって、「2」はマージベースではありません。

@samp{git merge-base --octopus A B C} の結果は「2」です。これは、「2」がすべてのコミットの中で最も共通の祖先であるためです。

履歴に交差マージ(criss-cross merges)が含まれる場合、2つのコミットに対して「最良の」共通の祖先が複数存在する可能性があります。 たとえば、このトポロジでは以下のようになります:

@example
---1---o---A
    \ /
     X
    / \
---2---o---o---B
@end example

「1」と「2」はどちらもAとBのマージベースです。どちらももう一方よりも優れているわけではありません（どちらも「最良の」マージベースです）。 @samp{--all} オプションが指定されていない場合、どちらの最良のマージベースが出力されるかは指定されていません。

2つのコミットAとBの間の「早送り性」(fast-forward-ness)をチェックする、という慣用句は、AとBの間のマージベースを計算し(少なくとも以前はそうでした)、それがAと同一かどうかをチェックすることで、その場合AはBの祖先です。この慣用句は古いスクリプトでよく使用されます。

@example
A=$(git rev-parse --verify A)
if test "$A" = "$(git merge-base A B)"
then
        ... A is an ancestor of B ...
fi
@end example

現在gitでは、あなたは以下のように、これをより直接的な方法で言うことができます:

@example
if git merge-base --is-ancestor A B
then
        ... A is an ancestor of B ...
fi
@end example

このように、上記にとって代わります。

@noindent

@chapheading Discussion on fork-point mode

@samp{git switch -c topic origin/master} で作成された @samp{topic} ブランチで作業した後、リモート追跡ブランチ @samp{origin/master} の履歴が巻き戻されて再構築された可能性があり、以下形の履歴につながります:

@example
                 o---B2
                /
---o---o---B1--o---o---o---B (origin/master)
        \
         B0
          \
           D0---D1---D (topic)
@end example

ここで、 @samp{origin/master} はコミットB0、B1、B2を指していましたが、現在はBを指しています。そして、 @samp{origin/master} がB0にあったときに、あなたの @samp{topic} ブランチがその上で開始されました。あなたは、その上に、D0、D1、Dの3つのコミットを作成しました。あなたは更新された origin/master の上に、トピックで行った作業をリベースしたいとします。

このような場合、 @samp{git merge-base origin/master topic} は上の図のB0の親を返しますが、 @samp{B0^..D} はBの上でリプレイしたいコミットの範囲ではありません(これには、あなたが書いたものではないB0が含まれます。これは、先端をB0からB1に移動したときに破棄された自分側で無い側(the other side)のコミットです)。

@samp{git merge-base --fork-point origin/master topic} は、このような場合に役立つように設計されています。 Bだけでなく、B0、B1、およびB2も(つまり、リポジトリのreflogが知っているリモート追跡ブランチの古い先端も)考慮に入れて、あなたのtopicブランチが構築されたコミットを確認し、B0を見つけます。これにより、topicのコミットのみをリプレイできます。ただし、自分の側で無い側(the other side)で後で破棄されるコミットは除きます。

したがって、以下は

@example
$ fork_point=$(git merge-base --fork-point origin/master topic)
@end example

B0 を見つけ、そして

@example
$ git rebase --onto origin/master $fork_point topic
@end example

以下の形の新しい履歴を作成するために、B の上で D0 と D1 と D をリプレイします:

@example
                 o---B2
                /
---o---o---B1--o---o---o---B (origin/master)
        \                   \
         B0                  D0'--D1'--D' (topic - updated)
          \
           D0---D1---D (topic - old)
@end example

注意点としては、リポジトリ内の古いreflogエントリが @samp{git gc} によって期限切れになる可能性があることです。 B0がリモート追跡ブランチ @samp{origin/ master} のreflogに表示されなくなった場合、@samp{--fork-point} モードは明らかにそれを見つけることができず失敗し、ランダムで役に立たない結果(@samp{--fork-point} オプション無しの同じコマンドが返すB0の親など)を与えることを避けます。

また、 @samp{--fork-point} モードを使用するリモート追跡ブランチは、あなたのトピックがその先端から分岐したものである必要があります。先端よりも古いコミットからフォークした場合、このモードではフォークポイントが見つかりません。(上記の履歴例でB0が存在せず、 origin/master がB1で始まり、B2、次にBに移動し、 origin/master がB1のときに、 @samp{origin/master^} でトピックをフォークしたと想像してください。履歴の形は上記と同じですが、B0はありません。B1の親は、 @samp{git merge-base origin/master topic} が正しく検出するものですが、 @samp{--fork-point} モードは検出しません。なぜなら origin/master の先端にあったコミットの1つではないためです。）

@noindent

@chapheading See also

git-rev-list(1), git-show-branch(1), git-merge(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge-file,,,Top
@chapheading Name

git-merge-file — 3方向ファイルマージを実行する

@noindent

@chapheading Synopsis

@display
git merge-file [-L <current-name> [-L <base-name> [-L <other-name>]]]
        [--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>]
        [--[no-]diff3] <current-file> <base-file> <other-file>
@end display


@noindent

@chapheading DESCRIPTION

@samp{git merge-file} は、 @samp{<base-file>} から @samp{<other-file>} へのすべての変更を @samp{<current-file>} に組み込みます。結果は通常 @samp{<current-file>} に入ります。 @samp{git merge-file} は、元のファイルへの個別の変更を組み合わせるのに役立ちます。 @samp{<base-file>} がオリジナルであり、 @samp{<current-file>} と @samp{<other-file>} の両方が @samp{<base-file>} の変更であるとすると、 @samp{git merge-file} は両方の変更を結合します。

@samp{<current-file>} と @samp{<other-file>} の両方の行の共通セグメントに変更がある場合、競合が発生します。競合が見つかった場合、「git merge-file」は通常、警告を出力し、 @samp{<<<<<<<} および @samp{>>>>>>>} マーカーを含む行で競合を囲みます。典型的な競合は以下のようになります:

@example
<<<<<<< A
lines in file A
=======
lines in file B
>>>>>>> B
@end example

競合がある場合、ユーザーは結果を編集して、選択肢の1つを削除する必要があります。 ただし @samp{--ours} または @samp{--theirs} または @samp{--union} オプションが有効な場合、これらの競合は、 @samp{<current-file>} の行または @samp{<other-file>} の行または両方からの行を優先して解決します。競合マーカーの長さは @samp{--marker-size} オプションで指定できます。

このプログラムの終了値は、エラーの場合は負数であり、それ以外の場合は競合した数です(競合たくさんの場合は127に切り捨てられます)。マージがクリーンだった場合、終了値は0です。

@samp{git merge-file} は、RCS用マージの最小限のクローンになるように設計されています。つまり git(1) に必要なRCSのマージ機能をすべて実装します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-L <label>} 
このオプションは最大3回指定でき、競合レポートで対応するファイル名の代わりに使用するラベルを指定します。 つまり @samp{git merge-file -L x -L y -L z a b c} は、ファイルa、b、cからではなく、ファイルx、y、zから来たように見える出力を生成します。

@item  @samp{-p} 
@samp{<current-file>} を上書きする代わりに、結果を標準出力に送信します。

@item  @samp{-q} 
静かにします(quiet)。競合について警告しないでください。

@item  @samp{--diff3} 
@samp{diff3} スタイルで競合を表示します。

@item  @samp{--zdiff3} 
@samp{zdiff3} スタイルで競合を表示します。

@item  @samp{--ours} 
@itemx  @samp{--theirs} 
@itemx  @samp{--union} 
ファイルに競合を残す代わりに、競合部分の、our (または their または 両方)側に有利な競合解決します。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git merge-file README.my README README.upstream} 
README以降のREADME.myとREADME.upstreamの変更を組み合わせて、それらをマージしようとし、結果をREADME.myに書き込みます。

@item  @samp{git merge-file -L a -L b -L c tmp/a123 tmp/b234 tmp/c345} 
tmp/a123 と tmp/c345 をベースの tmp/b234 とマージしますが、 @samp{tmp/a123} と @samp{tmp/c345} の代わりにラベル @samp{a} と @samp{c} を使用します。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge-index,,,Top
@chapheading Name

git-merge-index — マージが必要なファイルのマージを実行します

@noindent

@chapheading Synopsis

@display
git merge-index [-o] [-q] <merge-program> (-a | ( [--] <file>…) )
@end display


@noindent

@chapheading DESCRIPTION

これにより、インデックス内の <file> が検索され、マージエントリがある場合は、それらのファイルのSHA-1ハッシュが引数1、2、3（ファイルがない場合は空の引数）として、および、引数4として <file> が渡されます。引数1、2、3の3つのファイルのファイルモードは、引数5、6、7として渡されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--} 
これ以後の引数をオプションとして解釈しないでください。

@item  @samp{-a} 
インデックス内のマージが必要なすべてのファイルに対してマージを実行します。

@item  @samp{-o} 
最初に失敗したマージで停止するのではなく、すべてを一度に実行します。前のマージでエラーが返された場合でもマージを続行し、すべてのマージ後にエラーコードを返します。

@item  @samp{-q} 
マージプログラムの失敗について文句を言わないでください(マージプログラムの失敗は通常、マージ中の競合を示します)。 これは、カスタムメッセージを送信する可能性のある磁器コマンド用です。
@end table

@samp{git merge-index} が複数の <file> (または @samp{-a} )で呼び出された場合、それらを順番に処理し、マージがゼロ以外の終了コードを返した場合にのみ停止します。

通常、これは、RCSパッケージの「マージ」コマンドのGitの模倣を呼び出すスクリプトで実行されます。

@samp{git merge-one-file} というサンプルスクリプトがディストリビューションに含まれています。

警告！警告！警告！ Gitの「オブジェクトのマージ順序」は、RCSの「マージ」プログラムのオブジェクトのマージ順序とは異なります。上記の順番では、オリジナルが最初です。しかし、3方向マージプログラム「マージ」の引数の順序は、オリジナルを中央に置きます。理由は聞かないで…

例:

@example
torvalds@@ppc970:~/merge-test> git merge-index cat MM
This is MM from the original tree.              # original
This is modified MM in the branch A.            # merge1
This is modified MM in the branch B.            # merge2
This is modified MM in the branch B.            # current contents
@end example


または

@example
torvalds@@ppc970:~/merge-test> git merge-index cat AA MM
cat: : No such file or directory
This is added AA in the branch A.
This is added AA in the branch B.
This is added AA in the branch B.
fatal: merge program failed
@end example


後者の例は、何かがエラーを返した後、 @samp{git merge-index} がマージの試行を停止する方法を示しています(つまり、「cat」は元のファイルに存在しなかったため、AAファイルのエラーを返しました。 @samp{git merge-index} はMMをマージしようとさえしませんでした)。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge-one-file,,,Top
@chapheading Name

git-merge-one-file — git-merge-indexで使用する標準のヘルパープログラム

@noindent

@chapheading Synopsis

@display
git merge-one-file
@end display


@noindent

@chapheading DESCRIPTION

これは、 @emph{git merge-index} で行われた簡単なマージの後にマージを解決するために、 @emph{git read-tree -m} で使用する標準のヘルパープログラムです。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge-tree,,,Top
@chapheading Name

git-merge-tree — インデックスまたは作業ツリーにに触れずに(without touching)マージを実行する

@noindent

@chapheading Synopsis

@display
git merge-tree [--write-tree] [<options>] <branch1> <branch2>
git merge-tree [--trivial-merge] <base-tree> <branch1> <branch2> (deprecated)
@end display


@noindent

@chapheading DESCRIPTION

このコマンドには、 モダンな @samp{--write-tree} モードと非推奨の @samp{--trivial-merge} モードがあります。 最後の DEPRECATED DESCRIPTION (@pxref{DEPRECATED DESCRIPTION}) セクションを除いて、このドキュメントの残りの部分では、モダンな @samp{--write-tree} モードについて説明します。

マージを実行しますが、新しいコミットは作成せず、作業ツリーまたはインデックスからの読み取りも書き込みも行いません。

実行されるマージは、 以下を含む、「実際」の git-merge(1) と同じ機能を使用します:

@itemize 

@item
個々のファイルの 3 方向のコンテンツ・マージ

@item
名前変更検出

@item
適切な ディレクトリ/ファイル の競合処理

@item
再帰的な祖先の統合(つまり、複数のマージ・ベースがある場合、マージ・ベースをマージして仮想マージ・ベースを作成)

@item
等々。
@end itemize

マージが完了すると、新しいトップレベル・ツリー・オブジェクトが作成されます。 詳細については、下記「OUTPUT」を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-z} 
<Conflicted file info> セクションでファイル名をクォートしないでください。各ファイル名は、改行(newline)ではなく NUL 文字で終了してください。 また、 改行(newline)の代わりに NUL 文字でメッセージ・セクションを開始します。 詳細については、 下記 @ref{OUTPUT} を参照してください。

@item  @samp{--name-only} 
競合するファイルの情報(Conflicted file info)セクションでは、競合するファイルの出力に (mode, oid, stage, path) のタプルのリストを書き込む代わりに、 競合するファイル名のリストを提供するだけです(そして、複数の競合するステージがある場合、ファイル名を複数回リストしません)。

@item  @samp{--[no-]messages} 
「Auto-merging <path>」や CONFLICT 通知などの情報メッセージを stdout の最後に書き込みます。 指定されていない場合、デフォルトでは、マージの競合がある場合はこれらのメッセージが含まれ、そうでない場合は省略されます。

@item  @samp{--allow-unrelated-histories} 
指定の 2 つのブランチの間に共通の履歴の共有が無い場合、 merge-tree はデフォルトでエラーになります。 このフラグを指定して、 そのチェックをオーバーライドし、 とにかくマージを続行させることができます。

@item  @samp{--merge-base=<commit>} 
Instead of finding the merge-bases for <branch1> and <branch2>, specify a merge-base for the merge, and specifying multiple bases is currently not supported. This option is incompatible with @samp{--stdin}.
@end table

@noindent

@chapheading OUTPUT

マージが成功した場合、 git-merge-tree からの出力は以下の 1 行だけです:

@example
<OID of toplevel tree>
@end example

一方、競合するマージの場合、出力はデフォルトでは以下の形式になります:

@example
<OID of toplevel tree>
<Conflicted file info>
<Informational messages>
@end example

これらについては、後で個別に説明します。

However, there is an exception. If @samp{--stdin} is passed, then there is an extra section at the beginning, a NUL character at the end, and then all the sections repeat for each line of input. Thus, if the first merge is conflicted and the second is clean, the output would be of the form:

@example
<Merge status>
<OID of toplevel tree>
<Conflicted file info>
<Informational messages>
NUL
<Merge status>
<OID of toplevel tree>
NUL
@end example

@noindent

@heading Merge status

This is an integer status followed by a NUL character. The integer status is:

@example
0: merge had conflicts
1: merge was clean
<0: something prevented the merge from running (e.g. access to repository
    objects denied by filesystem)
@end example

@noindent

@heading OID of toplevel tree

これは、 @samp{git merge} の最後に作業ツリーでチェックアウトされるものを表すツリー・オブジェクトです。 競合があった場合、このツリー内のファイルには競合マーカーが埋め込まれている可能性があります。 このセクションの後には常に改行(newline)(または @samp{-z} が渡された場合は NUL)が続きます。

@noindent

@heading Conflicted file info

これは、以下の形式の一連の行です

@example
<mode> <object> <stage> <filename>
@end example

ファイル名は、 構成変数 @samp{core.quotePath} で説明されているようにクォートされます(git-config(1) 参照)。 ただし、 @samp{--name-only} オプションが渡された場合、モードとオブジェクトとステージは省略されます。 @samp{-z} が渡された場合、「行」は改行文字の代わりに NUL 文字で終了します。

@noindent

@heading Informational messages

This section provides informational messages, typically about conflicts. The format of the section varies significantly depending on whether @samp{-z} is passed.

If @samp{-z} is passed:

The output format is zero or more conflict informational records, each of the form:

@example
<list-of-paths><conflict-type>NUL<conflict-message>NUL
@end example

where <list-of-paths> is of the form

@example
<number-of-paths>NUL<path1>NUL<path2>NUL...<pathN>NUL
@end example

and includes paths (or branch names) affected by the conflict or informational message in <conflict-message>. Also, <conflict-type> is a stable string explaining the type of conflict, such as

@itemize 

@item
"Auto-merging"

@item
"CONFLICT (rename/delete)"

@item
"CONFLICT (submodule lacks merge base)"

@item
"CONFLICT (binary)"
@end itemize

and <conflict-message> is a more detailed message about the conflict which often (but not always) embeds the <stable-short-type-description> within it. These strings may change in future Git versions. Some examples:

@itemize 

@item
"Auto-merging <file>"

@item
"CONFLICT (rename/delete): <oldfile> renamed…but deleted in…"

@item
"Failed to merge submodule <submodule> (no merge base)"

@item
"Warning: cannot merge binary files: <filename>"
@end itemize

If @samp{-z} is NOT passed:

This section starts with a blank line to separate it from the previous sections, and then only contains the <conflict-message> information from the previous section (separated by newlines). These are non-stable strings that should not be parsed by scripts, and are just meant for human consumption. Also, note that while <conflict-message> strings usually do not contain embedded newlines, they sometimes do. (However, the free-form messages will never have an embedded NUL character). So, the entire block of information is meant for human readers as an agglomeration of all conflict messages.

@noindent

@chapheading EXIT STATUS

For a successful, non-conflicted merge, the exit status is 0. When the merge has conflicts, the exit status is 1. If the merge is not able to complete (or start) due to some kind of error, the exit status is something other than 0 or 1 (and the output is unspecified). When --stdin is passed, the return status is 0 for both successful and conflicted merges, and something other than 0 or 1 if it cannot complete all the requested merges.

@noindent

@chapheading USAGE NOTES

このコマンドは、 git-hash-object(1) や git-mktree(1) や git-commit-tree(1) や git-write-tree(1) や git-update-ref(1) や git-mktag(1) と同様に、低レベルの配管コマンドとして意図されています。 したがって、以下のような一連のステップの一部として使用できます:

@example
NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)
test $? -eq 0 || die "There were conflicts..."
NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)
git update-ref $BRANCH1 $NEWCOMMIT
@end example

注意: 終了ステータス(exit status)がゼロ以外の場合、このシーケンスの @samp{NEWTREE} には単なるツリーよりも多くの出力が含まれることに注意してください。

競合の場合、出力には git-merge(1) で得られるものと同じ情報が含まれます:

@itemize 

@item
作業ツリーに何が書き込まれるか (OID of toplevel tree (@pxref{OID of toplevel tree}))

@item
インデックスに書き込まれる高次ステージ(Conflicted file info (@pxref{Conflicted file info}))

@item
stdout に出力されるメッセージ(Informational messages (@pxref{Informational messages}))
@end itemize

@noindent

@chapheading INPUT FORMAT

@emph{git merge-tree --stdin} input format is fully text based. Each line has this format:

@example
[<base-commit> -- ]<branch1> <branch2>
@end example

If one line is separated by @samp{--}, the string before the separator is used for specifying a merge-base for the merge and the string after the separator describes the branches to be merged.

@noindent

@chapheading MISTAKES TO AVOID

結果のトップレベル・ツリーを調べて、競合するファイルを見つけようと試みません。 代わりに Conflicted file info (@pxref{Conflicted file info}) セクションをパースします。 大規模なリポジトリではツリー全体のパースが非常に遅くなるだけでなく、競合マーカーで表現できない競合の種類(変更/削除、モードの競合、両側で変更されたバイナリ・ファイル、ファイル/ディレクトリの競合、さまざまな名前変更の競合順列など)が数多くあります

空の Conflicted file info (@pxref{Conflicted file info}) リストをクリーンなマージ(clean merge)として解釈(interpret)しないでください。終了ステータス(exit status)を確認します。 マージでは、個々のファイルが競合しなくても競合が発生する可能性があります(このカテゴリに分類されるいくつかのタイプのディレクトリ名変更の競合があり、他のものも将来追加される可能性があります)。

Conflicted file info (@pxref{Conflicted file info}) リストから競合タイプを推測しようとしたり、ユーザーに推測させたりしないでください。 そこにある情報はそうするには不十分です。 例: Rename/rename(1to2) 競合(両側が同一ファイルの名前を別々に名前変更)により、3 つの異なるファイルが上位ステージ (ただし、それぞれ上位ステージは 1 つしかない) になり、 どの 3 つのファイルが関連しているかを (Informational messages (@pxref{Informational messages}) セクション以外で、) 判断する方法がありません。 ファイル/ディレクトリの競合によっても、1 つだけ上位ステージを持つファイルが生成されます。 ディレクトリ名の変更に関与する可能性のある(Possibly-involved-in-directory-rename)競合 ( @samp{merge.directoryRenames} が設定されていない(unset)か、 あるいは @samp{merge.directoryRenames} が @samp{conflicts} に設定されている(set)場合)も、正確に 1 つの上位ステージを持つファイルになります。 すべての場合において、 Informational messages (@pxref{Informational messages}) セクションには必要な情報が含まれていますが、プログラムでパースできる(machine parseable)ようには設計されていません。

Conflicted file info (@pxref{Conflicted file info}) からの各パスと、 Informational messages (@pxref{Informational messages}) の論理的競合が 1 対 1 のマッピングを持っている、 または 1 対多のマッピングがあると想定しないでください。 マッピングではなく、 多対 1 のマッピングでもありません。 多対多のマッピングが存在します。つまり、各パスは 1 回のマージで多くの論理競合タイプを持つことができ、各論理競合タイプは多くのパスに影響を与える可能性があります。

Informational messages (@pxref{Informational messages}) セクションにリストされているすべてのファイル名に競合があったと想定しないでください。 「Auto-merging <file>」など、競合のないファイルにメッセージを含めることができます。

Conflicted file info (@pxref{Conflicted file info}) から OID を取得し、それらを再マージして競合をユーザーに提示することは避けてください。 これにより、情報が失われます。 代わりに、 OID of toplevel tree (@pxref{OID of toplevel tree}) 内で見つかったファイルのバージョンを検索し、代わりにそれを表示します。 特に、 後者には、マージされている元の ブランチ/コミット と、名前変更が含まれている場合は元のファイル名で注釈が付けられた競合マーカーがあります。 再マージ時に競合マーカーの注釈に元の ブランチ/コミット を含めることはできますが、 元のファイル名は Conflicted file info (@pxref{Conflicted file info}) から入手できないため、ユーザーが競合を解決するのに役立つ情報を失うことになります。

@noindent

@chapheading DEPRECATED DESCRIPTION

DESCRIPTION (@pxref{DESCRIPTION}) に従う、このドキュメントの残りの部分とは異なり、このセクションでは非推奨の @samp{--trivial-merge} モードについて説明します。

オプションの @samp{--trivial-merge} を除いて、このモードはオプションを受け入れません。

このモードは 3 つのツリーっぽいものを読み取り、些細なマージ(trivial merge)結果と競合するステージを準差分(semi-diff)形式で標準出力に出力します。 これは、高レベルのスクリプトがその結果を使用してインデックスにマージするように設計されているため、 <branch1> に一致するエントリが省略されます。 この 2 番目の形式の結果は、 3 方向の @samp{git read-tree -m} と似ていますが、 結果をインデックスに格納する代わりに、そのコマンドはエントリを標準出力に出力します。

この形式は適用範囲が限られている(些細なマージ(trivial merge)では、個々のファイルの内容のマージのや、名前変更の検出や、適切な ディレクトリ/ファイル の競合の処理などを扱えません)だけでなく、出力形式も扱いにくく、通常、マージが成功した場合でも最初の形式よりもパフォーマンスが低下します(特に大規模なリポジトリで作業している場合)。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-merge,,,Top
@chapheading Name

git-merge — 2つまたはそれ以上の開発履歴を結合します

@noindent

@chapheading Synopsis

@display
git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]
        [--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]
        [--[no-]allow-unrelated-histories]
        [--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]
        [--into-name <branch>] [<commit>…]
git merge (--continue | --abort | --quit)
@end display


@noindent

@chapheading DESCRIPTION

名前付きのコミット(その履歴が現在のブランチから分岐した時点以降のもの)からの変更を現在のブランチに取り込みます。 このコマンドは、別のリポジトリからの変更を組み込むために @samp{git pull} によって使用され、そして、あるブランチから別のブランチに変更をマージするために手動で使用できます。

以下の履歴が存在し、現在のブランチが @samp{master} であるとします:

@example
          A---B---C topic
         /
    D---E---F---G master
@end example


Then "@samp{git merge topic}" will replay the changes made on the @samp{topic} branch since it diverged from @samp{master} (i.e., @samp{E}) until its current commit (@samp{C}) on top of @samp{master}, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes. Before the operation, @samp{ORIG_HEAD} is set to the tip of the current branch (@samp{C}).

@example
          A---B---C topic
         /         \
    D---E---F---G---H master
@end example


2番目の構文(@samp{git merge --abort})は、マージによって競合が発生した後にのみ実行できます。 @samp{git merge --abort`はマージ処理を中止し、マージ前の状態を再構築しようとします。 ただし、マージの開始時にコミットされていない変更があった場合(特に、マージの開始後にそれらの変更がさらに変更された場合)、 `git merge --abort} は、元の(マージ前の)変更を再構築できない場合があります。つまり以下の事が言えます:

@quotation

@strong{Warning}

自明でない未コミットの変更に対して @samp{git merge} を実行することは推奨されません。
可能ではありますが、
競合が発生した場合に元に戻すのが難しい状態になる可能性があります。
@end quotation

3番目の構文(@samp{git merge --continue})は、マージによって競合が発生した後にのみ実行できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--commit} 
@itemx  @samp{--no-commit} 
マージを実行し、結果をコミットします。 このオプションは、 @samp{--no-commit} をオーバーライドするために使用できます。

@samp{--no-commit} を使用すると、マージを実行し、マージコミットを作成する直前に停止して、ユーザーに、コミットする前にマージ結果を検査し、さらに微調整する機会を提供します。

注意: 早送り(fast-forward)更新はマージコミットを作成しないため、 @samp{--no-commit} を使用してこれらのマージを停止する方法はないことに注意してください。 したがって、mergeコマンドによってブランチが変更または更新されないようにする場合は、 @samp{--no-ff} と @samp{--no-commit} を使用します。

@item  @samp{--edit} 
@itemx  @samp{-e} 
@itemx  @samp{--no-edit} 
機械的マージがを成功する前にエディターを呼び出して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージについて説明して正当化できるようにします。 @samp{--no-edit} オプションを使用して、自動生成されたメッセージを受け入れることができます(これは一般的には推奨されていません)。
@samp{--edit}(または @samp{-e}) オプションは、あなたがコマンドラインから @samp{-m} オプションで与えた下書きメッセージをエディタで編集したい場合にも便利です。

古いスクリプトは、ユーザーがマージログメッセージを編集できないようにするという過去の動作に依存している可能性があります。 そのような場合は @samp{git merge} を実行すると、エディターを開く事になります。 このようなスクリプトを簡単に最新の挙動に合わせるために、環境変数 @samp{GIT_MERGE_AUTOEDIT} をスクリプトの先頭で @samp{no} に設定できます。

@item  @samp{--cleanup=<mode>} 
このオプションは、コミットする前にマージメッセージをクリーンアップする方法を決定します。 詳細については、 git-commit(1)を参照してください。 加えて、 @samp{<mode>} に @samp{scissors} 値が指定されている場合、マージの競合が発生した時に、切り取り線(scissors)はコミット機構に渡される前に @samp{MERGE_MSG} に追加されます。

@item  @samp{--ff} 
@itemx  @samp{--no-ff} 
@itemx  @samp{--ff-only} 
マージされた履歴がすでに現在の履歴の子孫である場合に、マージがどのように処理されるかを指定します。 @samp{--ff} は、 @samp{refs/tags/} 階層の自然な場所に格納されていない注釈付き(および場合によっては署名済み)タグをマージしない限り、デフォルトです。マージする場合は、@samp{--no-ff} が想定されます。

@samp{--ff} を使用すると、可能であれば、マージを早送り(fast-forward)(マージされたブランチに一致するようにブランチポインタを更新するだけです。マージコミットは作成しません)として解決します。 不可能な場合(マージされた履歴が現在の履歴の子孫ではない場合)は、マージコミットを作成します。

@samp{--no-ff} を使用すると、マージが早送り(fast-forward)として解決できる場合でも、すべての場合にマージコミットを作成します。

@samp{--ff-only} を使用して、可能な場合はマージを早送り(fast-forward)として解決します。不可能な場合は、マージを拒否し、ゼロ以外のステータスで終了します。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
マージコミット結果にGPG署名します。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに串刺しする必要があります。 @samp{--no-gpg-sign} は、 @samp{commit.gpgSign} 構成変数と、これ以前に指定した @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{--log[=<n>]} 
@itemx  @samp{--no-log} 
ブランチ名に加えて、マージされている実際のコミットから最大<n>個のコミットの1行説明をログメッセージに入力します。 git-fmt-merge-msg(1) も参照してください。

@samp{--no-log} を使用すると、マージされる実際のコミットからの1行説明が一覧表示されません。

@item  @samp{--signoff} 
@itemx  @samp{--no-signoff} 
コミットログメッセージの最後に、コミッターによる「Signed-off-by」トレーラーを追加します。signoffの意味は、コミットしているプロジェクトによって異なります。たとえば、コミッターがプロジェクトのライセンスに基づいて作品を提出する権利を持っていることを証明したり、開発者の原産地証明書などの寄稿者の代表に同意したりする場合があります。(LinuxカーネルおよびGitプロジェクトで使用されるものについては、http：//developercertificate.orgを参照してください)。プロジェクトでsignoffがどのように使用されるかを理解するには、貢献しているプロジェクトのドキュメントまたはリーダーシップ(leadership)を参照してください。

@samp{--no-signoff} オプションを使用すると、コマンドラインで以前の @samp{--signoff} オプションを無効にすることができます。

@item  @samp{--stat} 
@itemx  @samp{-n} 
@itemx  @samp{--no-stat} 
マージの最後にdiffstatを表示します。 diffstatは、構成オプションmerge.statによっても制御されます。

@samp{-n} または @samp{--no-stat} を使用すると、マージの最後に diffstat が表示されません。

@item  @samp{--squash} 
@itemx  @samp{--no-squash} 
(マージ情報を除く)実際のマージが発生したかのように作業ツリーとインデックスの状態を生成しますが、実際にコミットしたり、 @samp{HEAD} を移動したり、 (次の @samp{git commit} コマンドでマージコミットを作成する、) @samp{$GIT_DIR/MERGE_HEAD} を記録したりしないでください。 これにより、現在のブランチの上に単一のコミットを作成できます。その効果は、別のブランチ(または octopusの場合はそれ以上)をマージするのと同じです。

@samp{--no-squash} を使用してマージを実行し、結果をコミットします。 このオプションは、 @samp{--squash} をオーバーライドするために使用できます。

@samp{--squash} を使用すると、 @samp{--commit} は許可されず、失敗します。

@item  @samp{--[no-]verify} 
デフォルトでは、 pre-merge フックと commit-msg フックが実行されます。 @samp{--no-verify} が指定されている場合、これらはバイパスされます。 githooks(5) も参照してください。

@item  @samp{-s <strategy>} 
@itemx  @samp{--strategy=<strategy>} 
指定されたマージ戦略を使用します。 試行する順序を指定するために、複数回指定できます。 @samp{-s} オプションがない場合は、代わりに組み込みの戦略リストが使用されます(単一のヘッドをマージする場合は @samp{ort}、それ以外の場合は @samp{octopus})。

@item  @samp{-X <option>} 
@itemx  @samp{--strategy-option=<option>} 
マージ戦略固有のオプションをマージ戦略に渡します。

@item  @samp{--verify-signatures} 
@itemx  @samp{--no-verify-signatures} 
マージされるサイドブランチの先端コミットが有効なキー、つまり有効なuidを持つキーで署名されていることを確認します。デフォルトの信頼モデルでは、これは署名キーが信頼できるキーによって署名されていることを意味します。サイドブランチの先端コミットが有効なキーで署名されていない場合、マージは中止されます。

@item  @samp{--summary} 
@itemx  @samp{--no-summary} 
@samp{--stat} および @samp{--no-stat} の同義語。 これらは非推奨であり、将来削除される予定です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かに実行します。 @samp{--no-progress} の指定を含んでいます。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
にぎやかにします。

@item  @samp{--progress} 
@itemx  @samp{--no-progress} 
進行状況を明示的にオン/オフにします。 どちらも指定されていない場合、標準エラーが端末に接続されていれば進行状況が表示されます。 すべてのマージ戦略が進捗レポートをサポートしているわけではないことに注意してください。

@item  @samp{--autostash} 
@itemx  @samp{--no-autostash} 
操作を開始する前に一時的なスタッシュエントリを自動的に作成し、それを特別なref @samp{MERGE_AUTOSTASH} に記録し、操作の終了後にapplyします。 これは、ダーティワークツリーで操作を実行できることを意味します。 ただし、注意して使用してください。マージが成功した後の最後のstashアプリケーションは、深刻な競合を引き起こす可能性があります。

@item  @samp{--allow-unrelated-histories} 
デフォルトでは、 @samp{git merge} コマンドは、共通の祖先を共有しない履歴のマージを拒否します。 このオプションは、独立して産まれた2つのプロジェクトの履歴をマージするときにこのセーフティを無効にするために使用できます。 これは非常にまれなケースであるため、これをデフォルトで有効にする構成変数は存在せず、今後も追加されません。

@item  @samp{-m <msg>} 
マージコミットに使用するコミットメッセージを設定します(マージコミットが作成された場合)。

@samp{--log} が指定されている場合、マージされるコミットのショートログが与えられたメッセージに追加されます。

@samp{git fmt-merge-msg} コマンドを使用して、自動化された @samp{git merge} 呼び出しに適切なデフォルトを与えることができます。 自動メッセージには、ブランチの説明を含めることができます。

@item  @samp{--into-name <branch>} 
マージ先の実際のブランチの名前ではなく、ブランチ @samp{<branch>} にマージするかのように、デフォルトのマージ・メッセージを準備します。

@item  @samp{-F <file>} 
@itemx  @samp{--file=<file>} 
マージコミットに使用されるコミットメッセージを読み取ります(マージコミットが作成された場合)。

@samp{--log} が指定されている場合、マージされるコミットのショートログが与えられたメッセージに追加されます。

@item  @samp{--rerere-autoupdate} 
@itemx  @samp{--no-rerere-autoupdate} 
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 @samp{--no-rerere-autoupdate} は、別の @samp{git add} で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。

@item  @samp{--overwrite-ignore} 
@itemx  @samp{--no-overwrite-ignore} 
マージ結果から無視されたファイルを黙って上書きします。 これがデフォルトの動作です。 中止(abort)するには、 @samp{--no-overwrite-ignore} を使用します。

@item  @samp{--abort} 
現在の競合解決プロセスを中止(abort)し、マージ前の状態を再構築してみてください。 自動スタッシュエントリが存在する場合は、それをワークツリーに適用します。

マージの開始時にコミットされていないワークツリーの変更が存在した場合、 @samp{git merge --abort} は、これらの変更を再構築できない場合があります。 したがって、 @samp{git merge} を実行する前に、常にあなたの変更をコミット、またはスタッシュしておくことをお勧めします。

@samp{git merge --abort} は、 @samp{MERGE_HEAD} がある場合は @samp{git reset --merge} と同じです。ただし @samp{MERGE_AUTOSTASH} もある場合は @samp{git merge --abort} はスタッシュエントリをワークツリーに適用しますが、 @samp{git reset --merge} は スタッシュリストにスタッシュした変更を保持したままにします。

@item  @samp{--quit} 
進行中の現在のマージを忘れさせます。 インデックスと作業ツリーはそのままにしておきます。 @samp{MERGE_AUTOSTASH} が存在する場合、スタッシュエントリはスタッシュリストに保存されます。

@item  @samp{--continue} 
競合が原因で @samp{git merge} が停止(stop)した後で、 @samp{git merge --continue} を実行してマージを終了できます(下記「HOW TO RESOLVE CONFLICTS」セクション参照)。

@item  <commit>… 
私たちのブランチにマージするコミットです。通常は他のブランチヘッドです。 複数のコミットを指定すると、3つ以上の親とのマージが作成されます(Octopusマージという愛称で親しまれています)。

コマンドラインからコミットが指定されていない場合は、現在のブランチがアップストリームとして使用するように構成されているリモート追跡ブランチをマージします。 このマニュアルページの構成(configuration)セクションも参照してください。

FETCH_HEAD` が指定された場合(他のコミットは指定しない場合)、直前の @samp{git fetch} によるマージによって @samp{.git/FETCH_HEAD} ファイルに記録されたブランチは、現在のブランチにマージされます。
@end table

@noindent

@chapheading PRE-MERGE CHECKS

外部の変更を適用する前に、自分の作業を良好な状態にしてローカルでコミットしとく必要があります。これにより、競合が発生した場合に作業が中断されることはなくなります。 git-stash(1) も参照してください。 @samp{git pull}/@samp{git merge} は、ローカルのコミットされていない変更が @samp{git pull}/@samp{git merge} の更新が必要なファイルと重複する場合、何もせずに停止(stop)します。

マージコミットに無関係な変更が記録されないようにするために、 @samp{HEAD} コミットに関連する変更がインデックスに登録されている場合、 @samp{git pull} と @samp{git merge} も中止(abort)されます。 (使用されているマージ戦略によっては、このルールに対する特別な狭い例外が存在する場合がありますが、通常、インデックスはHEADと一致する必要があります。)

すべての名前付きコミットがすでに @samp{HEAD} の祖先である場合、@samp{git merge} は "Already up to date." (既に最新です)というメッセージで早期に終了(exit)します。

@noindent

@chapheading FAST-FORWARD MERGE

多くの場合、現在のブランチヘッドは、指定のコミットの祖先です。 これは、特に @samp{git pull} から呼び出された場合に最も一般的なケースです: 例えば、あなたはアップストリームリポジトリを追跡していて、ローカルの変更をコミットしていないので、新しいアップストリームリビジョンに更新する必要があります。 この場合、結合された履歴を保存するために新しいコミットは必要ありませんが、代わりに、「HEAD」（およびインデックス）は、追加のマージコミットを作成せずに、指定のコミットを指すように更新されます。

この振る舞いは、@samp{--no-ff} オプションで抑制できます。

@noindent

@chapheading TRUE MERGE

早送りマージ(fast-forward merge)(上記参照)を除いて、マージされるブランチは、両方を親として持つマージコミットによって結合する必要があります。

マージされるすべてのブランチの変更を調整したマージバージョンがコミットされ、@samp{HEAD}、インデックス、作業ツリーがそのコミットに更新されます。 作業ツリーには、重ならない限りは変更を加えることができます。

変更を調停する方法が明確でない場合、以下のようになります:

@enumerate 

@item
@samp{HEAD} ポインタは同一のままです。

@item
@samp{MERGE_HEAD} ref は、他方のブランチヘッド(the other branch head)を指すように設定されています。

@item
正常にマージされたパスは、インデックスファイルとあなたの作業ツリーの両方で更新されます。

@item
For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from @samp{HEAD}, and stage 3 from @samp{MERGE_HEAD} (you can inspect the stages with @samp{git ls-files -u}). The working tree files contain the result of the merge operation; i.e. 3-way merge results with familiar conflict markers @samp{<<<} @samp{===} @samp{>>>}.

@item
A special ref @samp{AUTO_MERGE} is written, pointing to a tree corresponding to the current content of the working tree (including conflict markers for textual conflicts). Note that this ref is only written when the @emph{ort} merge strategy is used (the default).

@item
その他の変更は行われません。 特に、マージを開始する前に行ったローカルの変更は同じままであり、それらのインデックスエントリはそのまま、つまり「HEAD」と一致します。
@end enumerate

試しにマージした結果、複雑な競合が発生してしまったのでやり直したいという場合は、 @samp{git merge --abort} で回復(recover)することができます。

@noindent

@chapheading MERGING TAG

注釈付きの(可能ならば署名された)タグをマージする場合、早送りマージが可能であっても、Gitは常にマージコミットを作成し、コミットメッセージテンプレートはタグメッセージ付きで準備されます。 さらに、タグが署名されている場合、シグネチャチェックはメッセージテンプレートのコメントとして報告されます。 git-tag(1) も参照してください。

たまたまタグ付けされたコミットにつながる作業と統合し、例えば、アップストリームのリリースポイントと同期したい場合、あなたは不要なマージコミットを作成したくない場合があります。

このような場合、タグを @samp{git merge} にフィードする前に自分で「包装を解く」(unwrap)か、自分で作業を行わない場合は @samp{--ff-only} を渡すことができます。 例えば以下ようにします

@example
git fetch origin
git merge v1.2.3^0
git merge --ff-only v1.2.3
@end example


@noindent

@chapheading HOW CONFLICTS ARE PRESENTED

マージ中に、作業ツリーのファイルが更新されてマージの結果が反映されます。 共通の祖先のバージョンに加えられた変更の中で、重複しないもの(つまり、ファイルの領域を変更し、反対側がその領域をそのままにしておく、またはその逆)が最終結果にそのまま組み込まれます。 ただし、両方の側が同じ領域に変更を加えた場合、Gitは一方の側をもう一方の側からランダムに選択することはできず、両方の側がその領域に行ったことをファイルに残してあなたに解決するように求めます。

デフォルトでは、GitはRCSスイートの「マージ」プログラムで使用されるものと同じスタイルを使用して、以下のように競合するハンクを表示します:

@example
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed,
or cleanly resolved because both sides changed the same way.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
@end example


競合する変更のペアが発生した領域は、マーカー @samp{<<<<<<<} 、 @samp{=======} 、 @samp{>>>>>>>} でマークされます。 @samp{=======} の前の部分は通常あなた側(your side)であり、後の部分は通常彼ら側(their side)です。

デフォルトの形式では、競合している部分でオリジナルが何を言っているのかは分かりません。 自分側の何行が削除され、バービー人形の発言に置き換えられているのかは分かりません。 唯一わかるのは、あなた側(your side)は大変だから買い物に行きたいと言いたいのに、相手側(the other size)は簡単だと主張したいということです。

@samp{merge.conflictStyle} 構成変数を @samp{diff3} または @samp{zdiff3} に設定することで、別のスタイルを使用できます。 @samp{diff3} スタイルでは、上記の競合は以下のようになります:

@example
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed,
<<<<<<< yours:sample.txt
or cleanly resolved because both sides changed the same way.
Conflict resolution is hard;
let's go shopping.
||||||| base:sample.txt
or cleanly resolved because both sides changed identically.
Conflict resolution is hard.
=======
or cleanly resolved because both sides changed the same way.
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
@end example


@samp{zdiff3} スタイルでは、以下のようになります:

@example
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed,
or cleanly resolved because both sides changed the same way.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
||||||| base:sample.txt
or cleanly resolved because both sides changed identically.
Conflict resolution is hard.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
@end example


@samp{<<<<<<<} 、 @samp{=======} 、 @samp{>>>>>>>} マーカーに加えて、@samp{|||||||} マーカーにオリジナルのテキストが続きます。 オリジナルは事実を述べただけであり、あなたの側(your side)は単にその声明に屈して諦めたのに対し、他の側(the oter side)はより前向きな態度をとろうとしたことがわかります。 オリジナルを表示することで、より良い解決策を思い付くことができる場合があります。

@noindent

@chapheading HOW TO RESOLVE CONFLICTS

競合を目にした後、あなたは以下の2つのことができます:

@itemize 

@item
マージしないことを決定します。 必要なクリーンアップは、インデックスファイルを @samp{HEAD} コミットにリセットして (2) をリバースし、 (2) と (3) によって行われた作業ツリーの変更をクリーンアップすることだけです。 これには @samp{git merge --abort} を使用できます。

@item
競合を解決します。 Gitは、作業ツリーの競合をマークします。 ファイルを編集して形にし、@samp{git add} してインデックスに追加します。 @samp{git commit} または @samp{git merge --continue} を使用して、取引を成立させます。 後者のコマンドは、 @samp{git commit} を呼び出す前に、進行中の(中断(interrupted)された)マージがあるかどうかをチェックします。
@end itemize

あなたはいくつかの道具を使用して、競合を解決できます:

@itemize 

@item
mergetoolの利用。 あなたが @samp{git mergetool} を実行すると、グラフィカルな mergetool が起動し、マージ作業を行えます。

@item
Look at the diffs. @samp{git diff} will show a three-way diff, highlighting changes from both the @samp{HEAD} and @samp{MERGE_HEAD} versions. @samp{git diff AUTO_MERGE} will show what changes you’ve made so far to resolve textual conflicts.

@item
各ブランチからのdiffを見てください。 @samp{git log --merge -p <path>} は、最初に @samp{HEAD} バージョンの差分を表示し、次に @samp{MERGE_HEAD} バージョンを表示します。

@item
オリジナルを見てください。 @samp{git show :1:filename} は共通の祖先を示し、 @samp{git show :2:filename} は @samp{HEAD} バージョンを示し、 @samp{git show :3:filename} は @samp{MERGE_HEAD} バージョンを示します。
@end itemize

@noindent

@chapheading EXAMPLES

@itemize 

@item
現在のブランチにブランチ @samp{fixes} と @samp{enhancements} をマージし、octopusマージします:

@example
$ git merge fixes enhancements
@end example


@item
@samp{ours} マージ戦略を使用して、ブランチ @samp{obsolete} を現在のブランチにマージします:

@example
$ git merge -s ours obsolete
@end example


@item
ブランチ @samp{maint} を現在のブランチにマージしますが、新しいコミットを自動的に行わないでください:

@example
$ git merge --no-commit maint
@end example


これは、マージにさらに変更を加えたい場合、または独自のマージコミットメッセージを作成したい場合に使用できます。

大幅な変更をマージコミットに忍び込ませるために、このオプションを悪用することは控えてください。 bumping release(微修正)/version name(バージョン名変更) のような小さな修正は許容されます。
@end itemize

@noindent

@chapheading MERGE STRATEGIES

マージ機構(@samp{git merge} と @samp{git pull} コマンド)では、バックエンドの「マージ戦略」を @samp{-s} オプションで選択することができます。 いくつかの戦略では、独自のオプションを指定することができます。これは、 @samp{git merge} や @samp{git pull} に @samp{-X<option>} 引数として渡すことができます。

@table @asis

@item  ort 
これは、1つのブランチをプルまたはマージするときのデフォルトのマージ戦略です。この戦略では、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。さらに、この戦略では、名前の変更を伴うマージを検出して処理できます。検出されたコピーは使用しません。このアルゴリズムの名前は "Ostensibly Recursive’s Twin" (表面上は再帰の双子)の頭文字を取ったものであり、以前のデフォルトのアルゴリズムである「recursive」の代わりとして作成されたという事実に由来しています。

@samp{ort} 戦略は、以下のオプションを取ることができます:

@table @asis

@item  ours 
このオプションは、「our」バージョンを優先することにより、競合するハンクをクリーンに自動解決するように強制します。 our側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリファイルの場合、内容全体がour側から取得されます。

これを「ours」マージ戦略と混同しないでください。この戦略では、他のツリーに何が含まれているのかさえまったく調べません。それは他のツリーが行ったすべてを破棄し、「our」履歴にはその中で起こったすべてが含まれていると宣言します。

@item  theirs 
これは「ours」の反対です。 「ours」とは異なり、このmergeオプションを混同する「theirs」マージ戦略はないことに注意してください。

@item  ignore-space-change 
@itemx  ignore-all-space 
@itemx  ignore-space-at-eol 
@itemx  ignore-cr-at-eol 
指示されたタイプの空白(whitespace)の変更を含む行を、3方向マージのために変更されていないものとして扱います。行に対する、他の変更と空白(whitespace)の変更との混合は、無視されません。 git-diff(1) の @samp{-b} と @samp{-w} と @samp{--ignore-space-at-eol} と @samp{--ignore-cr-at-eol} も参照してください。

@itemize 

@item
「their」バージョンが行に空白の変更のみを導入する場合、「our」バージョンが使用されます。

@item
「our」バージョンで空白の変更が導入されたが、「their」バージョンに大幅な変更が含まれている場合は、「their」バージョンが使用されます。

@item
それ以外の場合、マージは通常の方法で進行します。
@end itemize

@item  renormalize 
これにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインが実行されます。このオプションは、ブランチをさまざまなクリーンフィルターまたは行末正規化ルールとマージするときに使用することを目的としています。詳細については、 gitattributes(5) の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)を参照してください。

@item  no-renormalize 
@samp{renormalize} オプションを無効にします。 これは、 @samp{merge.renormalize} 構成変数をオーバーライドします。

@item  find-renames[=<n>] 
名前変更(rename)の検出をオンにし、オプションで類似性のしきい値(similarity threshold)を設定します。これがデフォルトです。 これは、 @samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--find-renames} も参照してください。

@item  rename-threshold=<n> 
@samp{find-renames=<n>} の非推奨の同義語。

@item  subtree[=<path>] 
このオプションは「subtree」戦略をさらに発展させたもので、2つの木をマージする際に、どのようにずらせば互いにマッチするかを推測するものである。その代わり、指定されたパスは、2つの木の形が一致するように前置される(または、最初から取り除かれる)。
@end table

@item  recursive 
これは、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。 これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。 さらに、これにより、名前変更を含むマージを検出して処理できます。 検出されたコピーは使用しません。 これは、Git v0.99.9k 〜 v2.33.0 まで、2つのヘッドを解決するためのデフォルトの戦略でした。

「recursive」(再帰的)戦略は「ort」と同じオプションを取る。 しかし、「ort」が無視する3つのオプション(上記には書かれていない)があり、 「recursive」戦略で有用となる可能性がある:

@table @asis

@item  patience 
@samp{diff-algorithm=patience} の非推奨の同義語。

@item  diff-algorithm=[patience|minimal|histogram|myers] 
マージ中に別の差分アルゴリズムを使用すると、重要でない一致行(異なる関数の中括弧など)が原因で発生するミスマージを回避できます。 git-diff(1) @samp{--diff-algorithm} も参照してください。注意: 特に、「ort」は @samp{diff-algorithm=histogram} を使用しますが、「recursive」はデフォルトで 「diff.algorithm」 設定を使う事に注意して下さい。

@item  no-renames 
名前変更(rename)の検出をオフにします。 これは、@samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--no-renames} も参照してください。
@end table

@item  resolve 
これは、3方向マージアルゴリズムを使用して、2つのヘッド（つまり、現在のブランチとプルした別のブランチ）のみを解決できます。 交差マージ(criss-cross merge)のあいまいさを注意深く検出しようとします。 名前の変更は処理しません。

@item  octopus 
これにより、3つ以上のヘッドを持つケースが解決されますが、手動解決が必要な複雑なマージの実行は拒否されます。これは主に、トピックの分岐ヘッドを纏めるために使用されることを意図しています。これは、複数のブランチをプルまたはマージする場合のデフォルトのマージ戦略です。

@item  ours 
これにより、任意の数のヘッドが解決されますが、結果として得られるマージのツリーは常に現在のブランチヘッドのツリーであり、他のすべてのブランチからのすべての変更を事実上無視します。 これは、サイドブランチの古い開発履歴に取って代わるために使用されることを意図しています。 これは、「recursive」マージ戦略の @samp{-Xours} オプションとは異なることに注意してください。

@item  subtree 
これは改造された「ort」戦略です。 ツリーAとBをマージするとき、BがAのサブツリーに対応する場合、同じレベルのツリーを読み取るのではなく、Bは最初にAのツリー構造に一致するように調整されます。 この調整は、共通の祖先ツリーに対しても行われます。
@end table

3方向マージ(デフォルトの「ort」を含む)を使用する戦略では、両方のブランチで変更が行われたが、後で一方のブランチで元に戻された場合、その変更はマージされた結果に表示されます。一部の人々は、この振る舞いを混乱させると感じています。これは、個々のコミットではなく、ヘッドとマージベースのみがマージの実行時に考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンに置き換えます。

@noindent

@chapheading CONFIGURATION

@table @asis

@item  branch.<name>.mergeOptions 
ブランチ <name> にマージするためのデフォルトオプションを設定します。 構文とサポートされているオプションは @samp{git merge} のものと同じですが、空白文字を含むオプション値は現在サポートされていません。
@end table

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  merge.conflictStyle 
マージ時に競合するハンクが作業ツリーファイルに書き出されるスタイルを指定します。 デフォルトは @samp{merge`です。これは、 `<<<<<<<} 競合マーカー、一方の側で行われた変更、 @samp{=======} マーカー、もう一方の側で行われた変更、そして @samp{>>>>>>>} マーカーというスタイルです。 別のスタイル「diff3」は、 @samp{|||||||} マーカーと元のテキストを @samp{=======} マーカーの前に追加します。 @samp{merge} スタイルは、元のテキストの除外と、行のサブセットが、両側で一致する場合に競合領域から引き抜かれるため、 @samp{diff3} よりも小さな競合領域を生成する傾向があります。 もう 1 つの代替スタイル @samp{zdiff3} は @samp{diff3} に似ていますが、 両側で一致する行が競合領域の開始または最後近くに現れる場合、競合領域から削除します。

@item  merge.defaultToUpstream 
コミット引数なしでmergeが呼び出された場合は、リモート追跡ブランチに格納されている最後に観測された値を使用して、現在のブランチ用に構成されたアップストリームブランチをマージします。 @samp{branch.<currentbranch>.remote} によって指定されたリモートのブランチに名前を付ける @samp{branch.<currentbranch>.merge} の値が参照され、次に、それらは @samp{remote.<remote>.fetch} を介して対応するリモート追跡ブランチにマッピングされ、そして、これらの追跡ブランチの先端がマージされます。 デフォルトはtrueです。

@item  merge.ff 
デフォルトでは、Gitは、現在のコミットの子孫であるコミットをマージするときに、追加のマージコミットを作成しません。 代わりに、現在のブランチの先端が早送り(fast-forward)されます。 @samp{false} に設定すると、この変数はGitにそのような場合に追加のマージコミットを作成するように指示します(コマンドラインから @samp{--no-ff} オプションを指定するのと同じです)。 @samp{only} に設定すると、そのような早送りマージのみが許可されます(コマンドラインから @samp{--ff-only} オプションを指定するのと同じです)。

@item  merge.verifySignatures 
trueの場合、これは @samp{--verify-signatures} コマンドラインオプションと同等です。 詳細については、 git-merge(1) を参照してください。

@item  merge.branchdesc 
ブランチ名に加えて、それらに関連付けられたブランチの説明テキストをログメッセージに入力します。デフォルトはfalseです。

@item  merge.log 
ブランチ名に加えて、マージされる実際のコミットからの最大「指定の数」の親コミットの1行説明をログメッセージに入力します。デフォルトはfalseで、trueは20の同義語です。

@item  merge.suppressDest 
統合ブランチの名前に一致するグロブをこの複数値の構成変数(multi-valued configuration variable)に追加することにより、これらの統合ブランチへのマージに対して計算されるデフォルトのマージメッセージは、タイトルから「into <branch name>」を省略します。

空の値を持つ要素を使用して、以前の構成エントリから蓄積されたグロブのリストをクリアできます。 @samp{merge.suppressDest} 変数が定義されていない場合、下位互換性のためにデフォルト値の @samp{master} が使用されます。

@item  merge.renameLimit 
マージ処理中に名前変更検出の網羅的な部分で考慮するファイルの数。 指定されない場合、デフォルトは diff.renameLimit の値です。 merge.renameLimit と diff.renameLimit の両方が指定されていない場合、現在のデフォルトは 7000 です。 この設定は、名前変更検出がオフの場合は効果がありません。

@item  merge.renames 
Gitが名前の変更を検出するかどうか。 「false」に設定すると、名前変更の検出が無効になります。 「true」に設定すると、基本的な名前変更の検出が有効になります。 デフォルトは diff.renames の値です。

@item  merge.directoryRenames 
Gitがディレクトリの名前変更を検出するかどうか。これは、履歴の一方の側でディレクトリが名前変更されたときに、もう一方の側で追加された新しいファイルがマージ時にどうなるのかに影響します。 merge.directoryRenames を @samp{false} に設定すると、ディレクトリの名前変更の検出は無効になります。つまり、そのような新しいファイルは古いディレクトリに残されます。 @samp{true} に設定すると、ディレクトリの名前変更検出が有効になり、そのような新しいファイルは新しいディレクトリに移動されることを意味します。 @samp{conflict} に設定すると、そのようなパスに対して競合が報告されます。 merge.renames が false の場合、merge.directoryRenames は無視され、false として扱われます。 デフォルトは @samp{conflict} です。

@item  merge.renormalize 
リポジトリ内のファイルの標準の表現が時間の経過とともに変更されたことをGitに伝えます(たとえば、以前はCRLF行末のレコードテキストファイルをコミットしていましたが、最近のファイルはLF行末を使用している)。 このようなリポジトリでは、Gitは、不必要な競合を減らすために、マージを実行する前に、コミットに記録されたデータを標準形式に変換できます。 詳細については、gitattributes(5) の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)のセクションを参照してください。

@item  merge.stat 
マージの最後にORIG_HEADとマージ結果の間のdiffstatを出力するかどうか。 デフォルトではtrue。

@item  merge.autoStash 
trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。 これは、ダーティ作業ツリーでマージを実行できることを意味します。 ただし、注意して使用してください。マージが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。 このオプションは、 git-merge(1)の @samp{--no-autostash} および @samp{--autostash} オプションでオーバーライドできます。 デフォルトはfalseです。

@item  merge.tool 
git-mergetool(1) が使用するマージツールを制御します。 以下のリストは、有効な組み込み値を示しています。その他の値はカスタムマージツールとして扱われ、対応する mergetool.<tool>.cmd 変数が定義されている必要があります。

@item  merge.guitool 
@samp{-g}/@samp{--gui} フラグが指定されている場合に、 git-mergetool(1) が使用するマージツールを制御します。以下のリストは、有効な組み込み値を示しています。 その他の値はカスタムマージツールとして扱われ、対応する mergetool.<guitool>.cmd 変数が定義されている必要があります。

@table @asis

@item  @samp{araxis} 
Use Araxis Merge (requires a graphical session)

@item  @samp{bc} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc3} 
Use Beyond Compare (requires a graphical session)

@item  @samp{bc4} 
Use Beyond Compare (requires a graphical session)

@item  @samp{codecompare} 
Use Code Compare (requires a graphical session)

@item  @samp{deltawalker} 
Use DeltaWalker (requires a graphical session)

@item  @samp{diffmerge} 
Use DiffMerge (requires a graphical session)

@item  @samp{diffuse} 
Use Diffuse (requires a graphical session)

@item  @samp{ecmerge} 
Use ECMerge (requires a graphical session)

@item  @samp{emerge} 
Use Emacs' Emerge

@item  @samp{examdiff} 
Use ExamDiff Pro (requires a graphical session)

@item  @samp{guiffy} 
Use Guiffy’s Diff Tool (requires a graphical session)

@item  @samp{gvimdiff} 
Use gVim (requires a graphical session) with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{gvimdiff1} 
Use gVim (requires a graphical session) with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{gvimdiff2} 
Use gVim (requires a graphical session) with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{gvimdiff3} 
Use gVim (requires a graphical session) where only the MERGED file is shown

@item  @samp{kdiff3} 
Use KDiff3 (requires a graphical session)

@item  @samp{meld} 
Use Meld (requires a graphical session) with optional @samp{auto merge} (see @samp{git help mergetool}'s @samp{CONFIGURATION} section)

@item  @samp{nvimdiff} 
Use Neovim with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{nvimdiff1} 
Use Neovim with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{nvimdiff2} 
Use Neovim with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{nvimdiff3} 
Use Neovim where only the MERGED file is shown

@item  @samp{opendiff} 
Use FileMerge (requires a graphical session)

@item  @samp{p4merge} 
Use HelixCore P4Merge (requires a graphical session)

@item  @samp{smerge} 
Use Sublime Merge (requires a graphical session)

@item  @samp{tkdiff} 
Use TkDiff (requires a graphical session)

@item  @samp{tortoisemerge} 
Use TortoiseMerge (requires a graphical session)

@item  @samp{vimdiff} 
Use Vim with a custom layout (see @samp{git help mergetool}'s @samp{BACKEND SPECIFIC HINTS} section)

@item  @samp{vimdiff1} 
Use Vim with a 2 panes layout (LOCAL and REMOTE)

@item  @samp{vimdiff2} 
Use Vim with a 3 panes layout (LOCAL, MERGED and REMOTE)

@item  @samp{vimdiff3} 
Use Vim where only the MERGED file is shown

@item  @samp{winmerge} 
Use WinMerge (requires a graphical session)

@item  @samp{xxdiff} 
Use xxdiff (requires a graphical session)
@end table

@item  merge.verbosity 
再帰的マージ戦略によって示される出力の量を制御します。 レベル0は、競合が検出された場合の最終エラーメッセージ以外は何も出力しません。 レベル1は競合のみを出力し、レベル2は競合とファイル変更を出力します。 レベル5以上はデバッグ情報を出力します。 デフォルトはレベル2です。 @samp{GIT_MERGE_VERBOSITY} 環境変数でオーバーライドできます。

@item  merge.<driver>.name 
カスタムの低レベルマージドライバーの人間が読める名前を定義します。 詳細については、 gitattributes(5) を参照してください。

@item  merge.<driver>.driver 
カスタムの低レベルのマージドライバーを実装するコマンドを定義します。 詳細については、 gitattributes(5) を参照してください。

@item  merge.<driver>.recursive 
共通の祖先間で内部マージを実行するときに使用される低レベルのマージドライバーに名前を付けます。 詳細については、 gitattributes(5) を参照してください。
@end table

@noindent

@chapheading SEE ALSO

git-fmt-merge-msg(1), git-pull(1), gitattributes(5), git-reset(1), git-diff(1), git-ls-files(1), git-add(1), git-rm(1), git-mergetool(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mergetool--lib,,,Top
@chapheading Name

git-mergetool--lib — 共通 Gitマージツール シェル スクリプレット群

@noindent

@chapheading Synopsis

@display
TOOL_MODE=(diff|merge) . "$(git --exec-path)/git-mergetool--lib"
@end display


@noindent

@chapheading DESCRIPTION

これは、全くもってエンドユーザー向けコマンドではありません。この文書は、磁器風のスクリプトを研究している、および/または 新しいスクリプトを書いている人々を対象としています。

@emph{git-mergetool--lib} スクリプトレットは、Gitマージツールを操作するための関数を設定するために、他のシェルスクリプトから( `.`を使用して)呼び出される(source)されるように設計されています。

@emph{git-mergetool--lib} を(sourceで)実行する前に、スクリプトで @samp{TOOL_MODE} を設定して、以下にリストされている関数の操作モードを定義する必要があります。 @emph{diff} と @emph{merge} は有効な値です。

@noindent

@chapheading FUNCTIONS

@table @asis

@item  get_merge_tool 
マージツールを返します。推測されたマージツールを返した場合、戻りコードは1です。それ以外の場合は0です。適切なGUIツールを検索するために、 @emph{$GIT_MERGETOOL_GUI} を @emph{true} に設定できます。

@item  get_merge_tool_cmd 
マージツールのカスタムコマンドを返します。

@item  get_merge_tool_path 
マージツールのカスタムパスを返します。

@item  initialize_merge_tool 
マージツール固有の関数をスコープに入れて、使用またはオーバーライドできるようにします。

@item  run_merge_tool 
ツール名と true/false フラグを指定してマージツールを起動し、マージベースが存在するかどうかを示します。 @emph{$MERGED} ・ @emph{$LOCAL} ・ @emph{$REMOTE} ・ @emph{$BASE} は、マージツールで使用するために定義する必要があります。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mergetool,,,Top
@chapheading Name

git-mergetool — マージ競合解決ツールを実行して、マージ競合を解決します

@noindent

@chapheading Synopsis

@display
git mergetool [--tool=<tool>] [-y | --[no-]prompt] [<file>…]
@end display


@noindent

@chapheading DESCRIPTION

@samp{git mergetool} を使用して、いくつかのマージユーティリティの1つを実行し、マージの競合を解決します。通常、 @samp{git merge} の後に実行されます。

1つ以上の <file> パラメーターが指定されている場合、マージツールプログラムが実行され、その各ファイルの違いが解決されます(競合のないものはスキップされます)。ディレクトリを指定すると、そのパスにあるすべての未解決のファイルが含まれます。ファイル名が指定されていない場合、 @samp{git mergetool} は、マージで競合するすべてのファイルに対してマージツールプログラムを実行します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-t <tool>} 
@itemx  @samp{--tool=<tool>} 
<tool> で指定したマージ解決プログラムを使用します。 有効な値には emerge、gvimdiff、kdiff3、meld、vimdiff、tortoisemerge が含まれます。有効な <tool> 設定のリストについては、 @samp{git mergetool --tool-help} を実行してください。

マージ解決プログラムが指定されていない場合、 @samp{git mergetool} は構成変数 @samp{merge.tool} を使用します。 構成変数 @samp{merge.tool} が設定されていない場合、 @samp{git mergetool} は適切なデフォルトを選択します。

あなたは構成変数 @samp{mergetool.<tool>.path} を設定することにより、ツールへのフルパスを明示的に指定できます。たとえば、 @samp{mergetool.kdiff3.path} を設定することにより、kdiff3への絶対パスを構成できます。それ以外の場合、 @samp{git mergetool} はツールがPATHで使用可能であると想定します。

既知のマージツールプログラムの1つを実行する代わりに、構成変数 @samp{mergetool.<tool>.cmd} で呼び出すコマンドラインを指定することにより、 @samp{git mergetool} をカスタマイズして代替プログラムを実行できます。

( @samp{-t} または @samp{--tool} または @samp{merge.tool} 構成変数のいずれかを介して) @samp{git mergetool} をこのツールで呼び出すと、構成されたコマンドラインが呼び出され、 @samp{$BASE} がマージの共通ベースを含む一時ファイルの名前に設定され、使用可能な場合、 @samp{$LOCAL} は現在のブランチのファイルの内容を含む一時ファイルの名前に設定され、 @samp{$REMOTE} はマージされるファイルの内容を含む一時ファイルの名前に設定され、 @samp{$REMOTE} はマージされるファイルの内容を含む一時ファイルの名前に設定されます。

カスタムマージツールがその終了コードでマージ解決の成功を正確に示している場合、構成変数 @samp{mergetool.<tool>.trustExitCode} を @samp{true} に設定できます。それ以外の場合、 @samp{git mergetool} は、カスタムツールが終了した後、解決の成功を示すようにユーザーに促します。

@item  @samp{--tool-help} 
@samp{--tool} で使用できるマージツールのリストを出力します。

@item  @samp{-y} 
@itemx  @samp{--no-prompt} 
マージ解決プログラムを呼び出す前にプロンプトを表示しないでください。これは、マージ解決プログラムが @samp{--tool} オプションまたは @samp{merge.tool} 構成変数で明示的に指定されている場合のデフォルトです。

@item  @samp{--prompt} 
マージ解決プログラムを呼び出す前にプロンプトを表示して、ユーザーにパス(path)をスキップする機会を与えます。

@item  @samp{-g} 
@itemx  @samp{--gui} 
When @emph{git-mergetool} is invoked with the @samp{-g} or @samp{--gui} option the default merge tool will be read from the configured @samp{merge.guitool} variable instead of @samp{merge.tool}. If @samp{merge.guitool} is not set, we will fallback to the tool configured under @samp{merge.tool}. This may be autoselected using the configuration variable @samp{mergetool.guiDefault}.

@item  @samp{--no-gui} 
This overrides a previous @samp{-g} or @samp{--gui} setting or @samp{mergetool.guiDefault} configuration and reads the default merge tool from the configured @samp{merge.tool} variable.

@item  @samp{-O<orderfile>} 
<orderfile> で指定された順序でファイルを処理します。これには、1行に1つのシェルグロブパターンがあります。 これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) を参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  mergetool.<tool>.path 
指定のツール(<tool>)のパスを上書きします。 これは、ツールがPATH上にない場合に役立ちます。

@item  mergetool.<tool>.cmd 
指定のマージツール(<tool>)を呼び出すコマンドを指定します。指定されたコマンドは、次の変数を使用してシェルで評価されます: @samp{BASE} は、マージされるファイルの共通ベースを含む一時ファイルの名前です(使用可能な場合)。 @samp{LOCAL} は、現在のブランチのファイルの内容を含む一時ファイルの名前です。 @samp{REMOTE} は、マージされるブランチのファイルの内容を含む一時ファイルの名前です。 @samp{MERGED} は、マージツールが正常なマージの結果を書き込むファイルの名前が含まれています。

@item  mergetool.<tool>.hideResolved 
ユーザーが特定のツール(<tool>)のグローバルな @samp{mergetool.hideResolved} 値をオーバーライドできるようにします。 詳細については、 @samp{mergetool.hideResolved} を参照してください。

@item  mergetool.<tool>.trustExitCode 
カスタムマージコマンドの場合、マージコマンドの終了コードを使用してマージが成功したかどうかを判断できるかどうかを指定します。 これがtrueで無い場合、マージターゲットファイルのタイムスタンプがチェックされ、ファイルが更新されている場合はマージが成功したと見なされます。そうでない場合、ユーザーはマージの成功を示すように求められます。

@item  mergetool.meld.hasOutput 
古いバージョンの @samp{meld} は @samp{--output} オプションをサポートしていません。 Gitは、 @samp{meld --help} の出力を調べることで、 @samp{meld} が @samp{--output} をサポートしているかどうかを検出しようとします。 @samp{mergetool.meld.hasOutput} を設定すると、Gitはこれらのチェックをスキップし、代わりに設定された値を使用します。 @samp{mergetool.meld.hasOutput} を @samp{true} に設定すると、Gitは無条件に @samp{--output} オプションを使用するようになり、 @samp{false} は @samp{--output} の使用を回避します。

@item  mergetool.meld.useAutoMerge 
meld は @samp{--auto-merge} が指定されると、競合しないすべての部分を自動的にマージし、競合する部分を強調表示して、ユーザーの決定を待ちます。 @samp{mergetool.meld.useAutoMerge} を`true`に設定すると、Gitは @samp{--auto-merge} オプションを @samp{meld} で無条件に使用するようになります。 この値を @samp{auto} に設定すると、gitは @samp{--auto-merge} がサポートされているかどうかを検出し、使用可能な場合にのみ @samp{--auto-merge} を使用します。 @samp{false} の値はデフォルト値で、` --auto-merge` の使用を完全に回避します。

@item  mergetool.vimdiff.layout 
vimdiff バックエンドはこの変数を使用して、分割されたウィンドウがどのように見えるかを制御します。 マージ・ツールとして Neovim(@samp{nvim}) または gVim(@samp{gvim}) を使用している場合でも適用されます。 詳細については、「BACKEND SPECIFIC HINTS」セクションを参照してください。

@item  mergetool.hideResolved 
During a merge Git will automatically resolve as many conflicts as possible and write the @emph{MERGED} file containing conflict markers around any conflicts that it cannot resolve; @emph{LOCAL} and @emph{REMOTE} normally represent the versions of the file from before Git’s conflict resolution. This flag causes @emph{LOCAL} and @emph{REMOTE} to be overwritten so that only the unresolved conflicts are presented to the merge tool. Can be configured per-tool via the @samp{mergetool.<tool>.hideResolved} configuration variable. Defaults to @samp{false}.

@item  mergetool.keepBackup 
マージを実行した後、競合マーカーを含む元のファイルを、拡張子 @samp{.orig} のファイルとして保存できます。 この変数が @samp{false} に設定されている場合、このファイルは保存されません。 デフォルトは @samp{true} です(つまり、バックアップファイルを保持します)。

@item  mergetool.keepTemporaries 
カスタムマージツールを呼び出すとき、Gitは一時ファイルの組をツールに渡します。 ツールがエラーを返し、この変数が @samp{true} に設定されている場合、これらの一時ファイルは保持されます。それ以外の場合、ツールの終了後に削除されます。 デフォルトは @samp{false} です。

@item  mergetool.writeToTemp 
Gitは、デフォルトで、競合するファイルの一時的な 「BASE」バージョンと「LOCAL」バージョンと「REMOTE」バージョンをワークツリーに書き込みます。 @samp{true} に設定すると、Gitはこれらのファイルに一時ディレクトリを使用しようとします。 デフォルトは @samp{false} です。

@item  mergetool.prompt 
マージ解決プログラムを呼び出す前にプロンプトを表示します。

@item  mergetool.guiDefault 
Set @samp{true} to use the @samp{merge.guitool} by default (equivalent to specifying the @samp{--gui} argument), or @samp{auto} to select @samp{merge.guitool} or @samp{merge.tool} depending on the presence of a @samp{DISPLAY} environment variable value. The default is @samp{false}, where the @samp{--gui} argument must be provided explicitly for the @samp{merge.guitool} to be used.
@end table

@noindent

@chapheading TEMPORARY FILES

@samp{git mergetool} は、マージの解決中に @samp{*.orig} バックアップファイルを作成します。これらは、ファイルがマージされ、その @samp{git mergetool} セッションが完了したら安全に削除できます。

@samp{mergetool.keepBackup} 構成変数を @samp{false} に設定すると、ファイルが正常にマージされたときに、 @samp{git mergetool} がバックアップを自動的に削除します。

@noindent

@chapheading BACKEND SPECIFIC HINTS

@noindent

@heading vimdiff

@noindent

@subheading Description

@samp{git mergetool} で @samp{--tool=vimdiff} を指定すると、Git は以下のように4つに分割されたウィンドウ・レイアウトで Vim を開きます:

@example
------------------------------------------
|             |           |              |
|   LOCAL     |   BASE    |   REMOTE     |
|             |           |              |
------------------------------------------
|                                        |
|                MERGED                  |
|                                        |
------------------------------------------
@end example

LOCALとBASEとREMOTEは、特定のコミットで競合するファイルの内容を示す読み取り専用バッファーです(それぞれ「マージ先のコミット」と「共通の祖先コミット」と「マージ元のコミット」)。

@samp{MERGED} は、競合を解決する必要がある書き込み可能なバッファーです(他の読み取り専用バッファーを参照として使用します)。 完了したら、通常どおり Vim を保存して終了します(@samp{:wq})。中止する場合は、@samp{:cq} を使用して終了します。

@noindent

@subheading Layout configuration

以下の区切り文字が特別な意味を持つ文字列を受け入れる構成変数 @samp{mergetool.vimdiff.layout} を設定することで、 Vim が使用するウィンドウ・レイアウトを変更できます:

@itemize 

@item
@samp{+} は「open a new tab」(新しいタブを開く)ために使用されます

@item
@samp{,} は「open a new vertical split」(上下分割で開く)ために使用されます

@item
@samp{/} は「open a new horizontal split」(左右分割で開く)ために使用されます

@item
@samp{@@} は、競合を解決した後の最終バージョンを含むファイルを示すために使用されます。 存在しない場合、デフォルトで @samp{MERGED} が使用されます。
@end itemize

演算子の優先順位は以下のとおりです(括弧(parentheses)を使用して変更できます):

@example
`@@` > `+` > `/` > `,`
@end example

これがどのように機能するかを理解するためにいくつかの例を見てみましょう:

@itemize 

@item
@samp{layout = "(LOCAL,BASE,REMOTE)/MERGED"}

これは、すでに見たデフォルトのレイアウトとまったく同一です。

注意: @samp{/} は @samp{,} よりも優先されるため、この場合は括弧は不要であることに注意してください。 つまり以下のレイアウト定義と同等です:

@example
layout = "LOCAL,BASE,REMOTE / MERGED"
@end example

@item
@samp{layout = "LOCAL,MERGED,REMOTE"}

これは、もし、何らかの理由で @samp{BASE} バッファに関心がない場合です。

@example
------------------------------------------
|             |           |              |
|             |           |              |
|   LOCAL     |   MERGED  |   REMOTE     |
|             |           |              |
|             |           |              |
------------------------------------------
@end example

@item
@samp{layout = "MERGED"}

@samp{MERGED} バッファのみが表示されます。 ただし、他のすべてのものはまだvimにロードされており、 @samp{buffers} コマンドでアクセスできることに注意してください。

@example
------------------------------------------
|                                        |
|                                        |
|                 MERGED                 |
|                                        |
|                                        |
------------------------------------------
@end example

@item
@samp{layout = "@@LOCAL,REMOTE"}

@samp{MERGED} がレイアウトに存在しない場合、バッファの 1 つをアスタリスク(@samp{*})で「マーク」する必要があります。 これは、競合を解決した後に編集して保存する必要があるバッファーになります。

@example
------------------------------------------
|                   |                    |
|                   |                    |
|                   |                    |
|     LOCAL         |    REMOTE          |
|                   |                    |
|                   |                    |
|                   |                    |
------------------------------------------
@end example

@item
@samp{layout = "LOCAL,BASE,REMOTE / MERGED + BASE,LOCAL + BASE,REMOTE"}

3つのタブが開かれます: 最初の 1 つはデフォルト・レイアウトのコピーで、残りの 2 つはそれぞれ (@samp{BASE} と @samp{LOCAL}) と (@samp{BASE} と @samp{REMOTE}) の違いのみを示します。

@example
------------------------------------------
| <TAB #1> |  TAB #2  |  TAB #3  |       |
------------------------------------------
|             |           |              |
|   LOCAL     |   BASE    |   REMOTE     |
|             |           |              |
------------------------------------------
|                                        |
|                MERGED                  |
|                                        |
------------------------------------------
@end example

@example
------------------------------------------
|  TAB #1  | <TAB #2> |  TAB #3  |       |
------------------------------------------
|                   |                    |
|                   |                    |
|                   |                    |
|     BASE          |    LOCAL           |
|                   |                    |
|                   |                    |
|                   |                    |
------------------------------------------
@end example

@example
------------------------------------------
|  TAB #1  |  TAB #2  | <TAB #3> |       |
------------------------------------------
|                   |                    |
|                   |                    |
|                   |                    |
|     BASE          |    REMOTE          |
|                   |                    |
|                   |                    |
|                   |                    |
------------------------------------------
@end example

@item
@samp{layout = "LOCAL,BASE,REMOTE / MERGED + BASE,LOCAL + BASE,REMOTE + (LOCAL/BASE/REMOTE),MERGED"}

前の例と同一ですが、最初のタブと同じ情報を持つ 4 番目のタブを別のレイアウトで追加します。

@example
---------------------------------------------
|  TAB #1  |  TAB #2  |  TAB #3  | <TAB #4> |
---------------------------------------------
|       LOCAL         |                     |
|---------------------|                     |
|       BASE          |        MERGED       |
|---------------------|                     |
|       REMOTE        |                     |
---------------------------------------------
@end example

注意: 3 番目のタブ定義では、括弧を使用して @samp{,} を @samp{/} よりも優先する必要があることに注意してください。
@end itemize

@noindent

@subheading Variants

@samp{--tool=vimdiff} の代わりに、これらの他の派生のいずれかを使用することもできます:

@itemize 

@item
@samp{--tool=gvimdiff} は Vim の代わりに gVim を開きます。

@item
@samp{--tool=nvimdiff} は Vim の代わりに Neovim を開きます。
@end itemize

これらの派生を使用する場合、カスタム・レイアウトを指定するには、構成変数 @samp{mergetool.vimdiff.layout} の代わりに @samp{mergetool.gvimdiff.layout} と @samp{mergetool.nvimdiff.layout} を設定する必要があります。

さらに、以前の Git バージョンとの後方互換性を保つために、 @samp{vimdiff} や、その派生 (たとえば @samp{vimdiff3} 、 @samp{nvimdiff1} 等) の名前の後ろに @samp{1} , @samp{2} , @samp{3} を追加して、定義済みのレイアウトを使用することも可能です。 言い換えると、 @samp{--tool=[g,n,]vimdiffx} を使用するということは、 @samp{--tool=[g,n,]vimdiff} を使用し、かつ、設定変数 @samp{mergetool.[g,n,]vimdiff.layout} を以下のように設定するのと同じことです。 (訳注: @samp{--tool=[g,n,]vimdiffx} → @samp{--tool=vimdiff1}, @samp{--tool=vimdiff2}, @samp{--tool=vimdiff3}, @samp{--tool=gvimdiff1}, @samp{--tool=gvimdiff2}, @samp{--tool=gvimdiff3}, @samp{--tool=nvimdiff1}, @samp{--tool=nvimdiff2}, @samp{--tool=nvimdiff3})

@itemize 

@item
@samp{x=1}: @samp{"@@LOCAL, REMOTE"}

@item
@samp{x=2}: @samp{"LOCAL, MERGED, REMOTE"}

@item
@samp{x=3}: @samp{"MERGED"}
@end itemize

例: @samp{--tool=gvimdiff2} を使用すると、 @samp{gvim} が 3 つの列 (LOCAL、MERGED、REMOTE) で開きます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mktag,,,Top
@chapheading Name

git-mktag — 追加の検証(extra validation)でタグオブジェクトを作成します

@noindent

@chapheading Synopsis

@display
git mktag
@end display


@noindent

@chapheading DESCRIPTION

標準入力でタグの内容を読み取り、タグオブジェクトを作成します。 出力は、新しいタグの <object> IDです。

このコマンドは、 git-hash-object(1) を @samp{-t tag -w --stdin} オプションで呼び出すのとほとんど同じです。例:以下は両方とも、 @samp{my-tag} ファイル中からタグの記述を見つけ、見つけたタグの記述からをタグオブジェクトを作成して書き込みます。

@example
git mktag <my-tag
git hash-object -t tag -w --stdin <my-tag
@end example

git-hash-object(1) の違いは、タグが git-fsck(1) チェックに合格しない場合、タグを書き込む前にmktagが停止することです。

mktagで実行される「fsck」チェックは、すべての @samp{fsck.<msg-id>} メッセージが警告からエラーに昇格されるという点で git-fsck(1) がデフォルトで実行するものよりも厳密(strict)です(たとえば、tagger行の欠落はエラーです)。

Extra headers in the object are also an error under mktag, but ignored by git-fsck(1). This extra check can be turned off by setting the appropriate @samp{fsck.<msg-id>} variable:

@example
git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers
@end example

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--strict} 
デフォルトでは、mktagは git-fsck(1) の @samp{--strict} モードに相当するものをオンにします。無効にするには、 @samp{--no-strict} を使用します。
@end table

@noindent

@chapheading Tag Format

このコマンドの標準入力に供給されるタグ署名ファイル(tag signature file)は、非常に単純な固定形式です。それは以下の4行からなります。

@example
object <hash>
type <typename>
tag <tagname>
tagger <tagger>
@end example

この後ろにいくつかのオプションの自由形式のメッセージが続きます(古いGitによって作成された一部のタグには @samp{tagger} 行がない場合があります)。メッセージが存在する場合は、ヘッダーとは空白行で区切られます。メッセージ部分には、Git自体は気にしない署名が含まれている場合がありますが、それはgpgで確認できます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mktree,,,Top
@chapheading Name

git-mktree — ls-tree形式のテキストからツリーオブジェクトを構築する

@noindent

@chapheading Synopsis

@display
git mktree [-z] [--missing] [--batch]
@end display


@noindent

@chapheading DESCRIPTION

非再帰的な @samp{ls-tree} 出力形式で標準入力を読み取り、ツリーオブジェクトを作成します。ツリーエントリの順序はmktreeによって正規化されるため、入力を事前に並べ替える必要はありません。構築されたツリーオブジェクトのオブジェクト名が標準出力に書き出されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-z} 
通常の ls-tree 出力形式の代わりに、(行終端がNULLである) @samp{ls-tree -z} 出力形式を読み取ります。

@item  @samp{--missing} 
欠落しているオブジェクトを許可します。 (このオプションなしでの)デフォルトの動作では、各ツリーエントリのSHA1が、存在するオブジェクトを識別していることを確認します。なお、このオプションは、常に欠落していることが許可されている gitlink エントリ(別名「サブモジュール」)の処理には影響しません。

@item  @samp{--batch} 
終了せずに、複数のツリーオブジェクトの構築をする事を許可します。 各ツリーは単一の空行で区切られています。 最後の改行はオプションです。注意: @samp{-z} オプションを使用すると、行はNUL終端になります。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-multi-pack-index,,,Top
@chapheading Name

git-multi-pack-index — multi-pack-indexを書き出し・検証します

@noindent

@chapheading Synopsis

@display
git multi-pack-index [--object-dir=<dir>] [--[no-]bitmap] <sub-command>
@end display


@noindent

@chapheading DESCRIPTION

multi-pack-index (MIDX) ファイルを書き出し・検証します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--object-dir=<dir>} 
Gitオブジェクトの場所として、指定されたディレクトリを使用します。 現在のMIDXファイルについては @samp{<dir>/packs/multi-pack-index} をチェックし、インデックスを作成するパックファイルについては @samp{<dir>/packs} をチェックします。

@samp{<dir>} は、現在のリポジトリの代替(alternate)である必要があります。

@item  @samp{--[no-]progress} 
進行状況を明示的にオン/オフにします。どちらも指定されていない場合、標準エラーが端末に接続されていれば進行状況が表示されます。 サブコマンド @samp{write} と @samp{verify} と @samp{expire} と @samp{repack} がサポートされています。
@end table

以下のサブコマンドを使用できます:

@table @asis

@item  write 
新しいMIDXファイルを書き込みます。 @samp{write} サブコマンドでは、以下のオプションを使用できます:

@table @asis

@item  @samp{--preferred-pack=<pack>} 
オプションで、複数のパックに同じオブジェクトが含まれている場合に使用されるタイブレークパッキング(tie-breaking pack)を指定します。 @samp{<pack>} には少なくとも1つのオブジェクトが含まれている必要があります。与えられていない場合、mtimeが最も低いパックを優先して採用(ties are broken)します。

@item  @samp{--[no-]bitmap} 
マルチパックビットマップ(multi-pack bitmap)を書き込むかどうかを制御します。

@item  --stdin-packs 
stdin 経由で提供される行区切りのパック・インデックスのベース名のセットのみを含む
マルチパック・インデックスを作成します。

@item  --refs-snapshot=<path> 
@samp{--bitmap} を使用して、必要に応じて、再パックの前に作成された
「refs スナップショット」を含むファイルを指定します。

参照スナップショットは、参照先端(reference tips)に対応する行区切りの OID で構成され、通常は新しいパックを生成する前に @samp{git repack} によって取得されます。 オプションで @samp{+} 文字で始まる行は、 その OID に対応する参照が「優先」(preferred)であることを示すことができます(git-config(1) の @samp{pack.preferBitmapTips} を参照してください)。

@samp{<path>} で指定されたファイルは読み取り可能であることが期待されており、重複を含んでいる可能性があります。 (特定の OID が複数回指定されている場合、少なくとも 1 つのインスタンスが特別な @samp{+} マーカーで始まる場合、優先としてマークされます)。
@end table

@item  verify 
MIDXファイルの内容を検証(verify)します。

@item  expire 
Delete the pack-files that are tracked by the MIDX file, but have no objects referenced by the MIDX (with the exception of @samp{.keep} packs and cruft packs). Rewrite the MIDX file afterward to remove all references to these pack-files.

@item  repack 
マルチパックインデックス(multi-pack-index)によって参照される小さなパックファイル(pack-files)にオブジェクトを含む新しいパックファイルを作成します。 @samp{--batch-size=<size>} 引数で指定されたサイズがゼロの場合、マルチパックインデックスによって参照されるすべてのオブジェクトを含むパックを作成します。ゼロ以外のバッチサイズの場合は、パックを古いものから新しいものへと調べてパックファイルを選択します。マルチパックインデックスによって参照されるパック内のオブジェクトの数をカウントすることにより、「予想サイズ」を計算します。次に、予想サイズをパック内のオブジェクトの総数で割り、パックサイズを掛けます。パックのセットが少なくともバッチサイズの合計予想サイズになるまで、またはすべてのパックファイルが考慮されるまで、予想サイズがバッチサイズよりも小さいパックを選択します。パックファイルが1つだけ選択されている場合は、何もしません。 新しいパックファイルが作成された場合は、マルチパックインデックスを書き直して(rewrite)、新しいパックファイルを参照します。後で @samp{git multi-pack-index expire} を実行すると、このバッチの一部であったパックファイルが削除されます。

@samp{repack.packKeptObjects} が @samp{false`の場合、 `.keep} ファイルが関連付けられているパックファイルはバッチで再パックするために選択されません。
@end table

@noindent

@chapheading EXAMPLES

@itemize 

@item
現在の @samp{.git} ディレクトリにパックファイル達のMIDXファイルを書き込みます。

@example
$ git multi-pack-index write
@end example


@item
対応するビットマップを使用して、現在の @samp{.git} ディレクトリ内のパックファイル達のMIDXファイルを書き込みます。

@example
$ git multi-pack-index write --preferred-pack=<pack> --bitmap
@end example


@item
代替オブジェクトストア(alternate object store)にパックファイルのMIDXファイルを書き込みます。

@example
$ git multi-pack-index --object-dir <alt> write
@end example


@item
現在の @samp{.git} ディレクトリ内のパックファイル達のMIDXファイルを検証(verify)します。

@example
$ git multi-pack-index verify
@end example

@end itemize

@noindent

@chapheading SEE ALSO

マルチパックインデックス機能の詳細については、 @uref{technical/multi-pack-index.html,The Multi-Pack-Index Design Document} と gitformat-pack(5) を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-mv,,,Top
@chapheading Name

git-mv — ファイルまたはディレクトリまたはシンボリックリンクを移動(move)または名前変更(rename)します

@noindent

@chapheading Synopsis

@display
git mv [<options>] <source>… <destination>
@end display


@noindent

@chapheading DESCRIPTION

ファイルまたはディレクトリまたはシンボリックリンクを移動または名前変更します。

@example
git mv [-v] [-f] [-n] [-k] <source> <destination>
git mv [-v] [-f] [-n] [-k] <source> ... <destination directory>
@end example

最初の形式では、ファイル・シンボリックリンク・ディレクトリのいずれかである必要がある <source> の名前を <destination> に変更します。2番目の形式では、最後の引数は既存のディレクトリである必要があります。指定のソースはこのディレクトリに移動されます。

正常に完了するとインデックスは更新されますが、変更はコミットする必要があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-f} 
@itemx  @samp{--force} 
Force renaming or moving of a file even if the <destination> exists.

@item  @samp{-k} 
エラー状態になる移動または名前変更をスキップします。ソースが存在せず、Gitによって制御されていない場合、または @samp{-f} が指定されていない限り、ソースが既存のファイルを上書きする場合、エラーが発生します。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
何も操作しない。何が起こるかを示すだけです。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
移動するファイルの名前を報告します。
@end table

@noindent

@chapheading SUBMODULES

gitfile(つまり、Gitバージョン1.7.8以降で複製された)を使用してサブモジュールを移動すると、gitfileとcore.worktreeの設定が更新され、サブモジュールが新しい場所で機能するようになります。また、 gitmodules(5) ファイルの submodule.<name>.path 設定を更新し、そのファイルをステージングしようとします( @samp{-n} が使用されている場合を除く)。

@noindent

@chapheading BUGS

スーパープロジェクトの更新により、入力されたサブモジュールが移動されるたびに(たとえば、移動の前後でコミットを切り替える場合)、古いサブモジュールのチェックアウトは古い場所に残り、空のディレクトリが新しい場所に表示されます。新しい場所にサブモジュールを再度入力するには、後で「git submodule update」を実行する必要があります。古いディレクトリの削除は、gitfileを使用している場合にのみ安全です。そうでなければ、サブモジュールの履歴も削除されます。再帰的なサブモジュールの更新が実装されている場合、これらの手順は廃止されるでしょう。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-name-rev,,,Top
@chapheading Name

git-name-rev — 指定のrevのシンボリック名を検索します

@noindent

@chapheading Synopsis

@display
git name-rev [--tags] [--refs=<pattern>]
               ( --all | --annotate-stdin | <commit-ish>… )
@end display


@noindent

@chapheading DESCRIPTION

@samp{git rev-parse} で解析可能な任意の形式で指定されたリビジョンの、人間にとって読みやすい記号名を検索します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--tags} 
ブランチ名は使用せず、コミットに名前を付けるためにタグのみを使用します

@item  @samp{--refs=<pattern>} 
名前が特定のシェルパターンに一致するrefのみを使用します。 パターンは、ブランチ名、タグ名、または完全修飾ref名のいずれかです。複数回指定する場合は、指定したシェルパターンのいずれかに名前が一致するrefsを使用します。 @samp{--no-refs} を使用して、既に指定済のrefパターンをクリアします。

@item  @samp{--exclude=<pattern>} 
名前が特定のシェルパターンと一致するrefは使用しない。 パターンは、ブランチ名、タグ名、または完全修飾ref名のいずれかです。複数回指定された場合、指定されたパターンのいずれかに一致するrefは除外されます。 @samp{--refs} と一緒に使用すると、refは少なくとも1つの @samp{--refs} パターンに一致し、 @samp{--exclude} パターンに一致しない場合にのみ一致として使用されます。 @samp{--no-exclude} を使用して、除外パターンのリストをクリアします。

@item  @samp{--all} 
すべてのrefから到達可能なすべてのコミットを一覧表示します

@item  @samp{--annotate-stdin} 
Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with "$hex ($rev_name)". When used with --name-only, substitute with "$rev_name", omitting $hex altogether. This option was called @samp{--stdin} in older versions of Git.

例えば:

@example
$ cat sample.txt

An abbreviated revision 2ae0a9cb82 will not be substituted.
The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907,
while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad
(訳注: 省略されたリビジョン 2ae0a9cb82 は置き換えられません。
置換後のフル・ネームは 2ae0a9cb8298185a94e5998086f380a355dd8907 で、
そのツリー・オブジェクトは 70d105cc79e63b81cfdcb08a15297c23e60b07ad です)

$ git name-rev --annotate-stdin <sample.txt

An abbreviated revision 2ae0a9cb82 will not be substituted.
The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master),
while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad

$ git name-rev --name-only --annotate-stdin <sample.txt

An abbreviated revision 2ae0a9cb82 will not be substituted.
The full name after substitution is master,
while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad
@end example


@item  @samp{--name-only} 
SHA-1と名前の両方を印刷する代わりに、名前のみを印刷します。 @samp{--tags} を指定すると、通常のタグプレフィックス "tags/" も名前から省略され、 `git-describe`の出力とより厳密に一致します。

@item  @samp{--no-undefined} 
参照が未定義の場合、 @samp{undefined} を出力する代わりに、エラーコード != 0 で終了します。

@item  @samp{--always} 
一意を保つように省略されたコミットオブジェクトをフォールバックとして表示します。
@end table

@noindent

@chapheading EXAMPLES

コミットが与えられたら、そのローカルrefsとの相対的な位置を見つけます。 誰かがその素晴らしいコミット 33db5f4d9027a10e477ccf054b2c1ab94f74c85a についてあなたに述べたとしましょう。もちろん、あなたはそのコミットを調べますが、そこでは何が起こったのかを教えてくれるだけで、文脈は教えてくれません。

@samp{git name-rev} に入力します:

@example
% git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a
33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940
@end example


あなたは今や、v0.99より前に940のリビジョンが発生したことが分かりましたね。

別の方法:

@example
% git log | git name-rev --annotate-stdin
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node git-notes,,,Top
@chapheading Name

git-notes — オブジェクトノートを追加または検査します

@noindent

@chapheading Synopsis

@display
git notes [list [<object>]]
git notes add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]
git notes copy [-f] ( --stdin | <from-object> [<to-object>] )
git notes append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]
git notes edit [--allow-empty] [<object>] [--[no-]stripspace]
git notes show [<object>]
git notes merge [-v | -q] [-s <strategy> ] <notes-ref>
git notes merge --commit [-v | -q]
git notes merge --abort [-v | -q]
git notes remove [--ignore-missing] [--stdin] [<object>…]
git notes prune [-n] [-v]
git notes get-ref
@end display


@noindent

@chapheading DESCRIPTION

オブジェクト自体に触れることなく、オブジェクトに添付のノートを追加、削除、または読み取ります。

デフォルトでは、ノートは @samp{refs/notes/commits} に保存され、そこから読み取られますが、このデフォルトはオーバーライドできます。 以下の「OPTIONS」セクション、「CONFIGURATION」セクション、「ENVIRONMENT」のセクションを参照してください。 このrefが存在しない場合、ノートを保存するために最初に必要になったときに黙って作成されます。

ノートの一般的な使用法は、コミット自体を変更せずにコミットメッセージを補足することです。 ノートは、元のコミットメッセージとともに @samp{git log} で表示できます。 コミットオブジェクトに格納されているメッセージと区別するために、ノートはメッセージと同様にインデントされます。インデントされていない行には "Notes (<refname>):" (@samp{refs/notes/commits} の場合は "Notes:") と書かれています。

@samp{--notes} オプションを使用して、 @samp{git format-patch} で作成されたパッチにノートを追加することもできます。 このようなノートは、3つのダッシュの区切り行の後にパッチの解説として追加されます。

@samp{git log} で表示されるノートを変更するには、 @ref{CONFIGURATION} の @samp{notes.displayRef} についての議論を参照してください。

コミットを書き換えるコマンド間でノートを渡す法については、 @samp{notes.rewrite.<command>} 構成を参照してください。

@noindent

@chapheading SUBCOMMANDS

@table @asis

@item  list 
指定のオブジェクトのノートオブジェクトを一覧表示します。 オブジェクトが指定されていない場合は、すべてのノートオブジェクトとそれらが注釈を付けるオブジェクトのリストを表示します("<note object> <annotated object>" 形式)。 サブコマンドが指定されていない場合、これはデフォルトのサブコマンドです。

@item  add 
Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use @samp{-f} to overwrite existing notes). However, if you’re using @samp{add} interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the @samp{edit} subcommand). If you specify multiple @samp{-m} and @samp{-F}, a blank line will be inserted between the messages. Use the @samp{--separator} option to insert other delimiters.

@item  copy 
最初のオブジェクトのノートを2番目のオブジェクト(デフォルトはHEAD)にコピーします。 2番目のオブジェクトにすでにノートがある場合、または最初のオブジェクトにノートがない場合は中止(abort)します(@samp{-f} を使用して2番目のオブジェクトの既存のノートを上書きします)。このサブコマンドは @samp{git notes add [-f] -C $(git notes list <from-object>) <to-object>} と同等です。

@samp{--stdin} モードでは、以下の形式で行を取得します

@example
<from-object> SP <to-object> [ SP <rest> ] LF
@end example


標準入力で、各<from-object>から対応する<to-object>にノートをコピーします。 (オプションの @samp{<rest>} は無視されるため、コマンドは @samp{post-rewrite} フックに与えられた入力を読み取ることができます。)

@item  append 
Append new message(s) given by @samp{-m} or @samp{-F} options to an existing note, or add them as a new note if one does not exist, for the object (defaults to HEAD). When appending to an existing note, a blank line is added before each new message as an inter-paragraph separator. The separator can be customized with the @samp{--separator} option.

@item  edit 
指定のオブジェクトのノートを編集します(デフォルトはHEAD)。

@item  show 
指定のオブジェクトのノートを表示します(デフォルトはHEAD)。

@item  merge 
指定のノートrefを現在のノートrefにマージします。 これにより、マージベース(存在する場合)以降に指定されたnote参照(「remote」と呼ばれる）によって行われた変更が現在のノートref(「local」と呼ばれる)にマージされます。

競合が発生し、競合するノートを自動的に解決するための戦略(「NOTES MERGE STRATEGIES」セクション参照)が指定されていない場合は、「manual」(手動)リゾルバーが使用されます。 このリゾルバーは、特別なワークツリー(@samp{.git/NOTES_MERGE_WORKTREE})内の競合するノートをチェックアウトし、そこで競合を手動で解決するようにユーザーに指示します。 完了したら、ユーザーは @samp{git notes merge --commit} を使用してマージを完了するか、 @samp{git notes merge --abort} を使用してマージを中止(abort)できます。

@item  remove 
指定のオブジェクトのノートを削除します(デフォルトはHEAD)。 コマンドラインから0個または1個のオブジェクトを指定する場合、これは @samp{edit} サブコマンドに空のノートメッセージを指定することと同じです。

@item  prune 
存在しない(non-existing)/到達できない(unreachable) オブジェクトのすべてのノートを削除します。

@item  get-ref 
現在のノートを出力します。これにより、現在のノートrefを(スクリプトなどから)簡単に取得する方法が提供されます。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-f} 
@itemx  @samp{--force} 
すでにノートがあるオブジェクトにノートを追加する場合は、(中止するのではなく、)既存のノートを上書きします。

@item  @samp{-m <msg>} 
@itemx  @samp{--message=<msg>} 
Use the given note message (instead of prompting). If multiple @samp{-m} options are given, their values are concatenated as separate paragraphs. Lines starting with @samp{#} and empty lines other than a single line between paragraphs will be stripped out, if you wish to keep them verbatim, use @samp{--no-stripspace}.

@item  @samp{-F <file>} 
@itemx  @samp{--file=<file>} 
Take the note message from the given file. Use @emph{-} to read the note message from the standard input. Lines starting with @samp{#} and empty lines other than a single line between paragraphs will be stripped out, if you wish to keep them verbatim, use with @samp{--no-stripspace} option.

@item  @samp{-C <object>} 
@itemx  @samp{--reuse-message=<object>} 
Take the given blob object (for example, another note) as the note message. (Use @samp{git notes copy <object>} instead to copy notes between objects.). By default, message will be copied verbatim, but if you wish to strip out the lines starting with @samp{#} and empty lines other than a single line between paragraphs, use with`--stripspace` option.

@item  @samp{-c <object>} 
@itemx  @samp{--reedit-message=<object>} 
@emph{-C} と同様ですが、 @samp{-c} を使用するとエディタが呼び出されるため、ユーザーはノートメッセージをさらに編集できます。

@item  @samp{--allow-empty} 
空のノートオブジェクトを保存できるようにします。 デフォルトの動作では、空のノートは自動的に削除されます。

@item  @samp{--[no-]separator, --separator=<paragraph-break>} 
Specify a string used as a custom inter-paragraph separator (a newline is added at the end as needed). If @samp{--no-separator}, no separators will be added between paragraphs. Defaults to a blank line.

@item  @samp{--[no-]stripspace} 
Strip leading and trailing whitespace from the note message. Also strip out empty lines other than a single line between paragraphs. For lines starting with @samp{#} will be stripped out in non-editor cases like "-m", "-F" and "-C", but not in editor case like "git notes edit", "-c", etc.

@item  @samp{--ref <ref>} 
<ref>のノートツリーを操作します。 これは、 @samp{GIT_NOTES_REF} と、 @samp{core.notesRef} 構成をオーバーライドします。 refは、 @samp{refs/notes/} で始まる完全なref名を指定します。 @samp{notes/} で始まる場合、 @samp{refs/} が接頭辞として付けられ、それ以外の場合は @samp{refs/notes/} が接頭辞として付けられ、refのフルネームを形成します。

@item  @samp{--ignore-missing} 
ノートが添付されていないオブジェクトからノートの削除を要求することをエラーと見なさないでください。

@item  @samp{--stdin} 
また、ノートを削除するために標準入力からオブジェクト名を読み取る(コマンドラインからオブジェクト名と組み合わせることができないわけではありません)。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
何も削除しないでください。 ノートが削除されるオブジェクト名を報告するだけです。

@item  @samp{-s <strategy>} 
@itemx  @samp{--strategy=<strategy>} 
ノートをマージするときは、指定の戦略を使用してノートの競合を解決します。 次の戦略が認識されます: @samp{manual}(デフォルト)、 @samp{ours} 、 @samp{theirs} 、 @samp{union} 、 @samp{cat_sort_uniq} 。 このオプションは、 @samp{notes.mergeStrategy} 構成設定をオーバーライドします。 各ノートマージ戦略の詳細については、以下の「NOTES MERGE STRATEGIES」セクションを参照してください。

@item  @samp{--commit} 
進行中の @samp{git notes merge} を完了させます。 @samp{.git/NOTES_MERGE_WORKTREE} に保存されている @samp{git notes merge} の競合を解決した場合は、このオプションを使用します。 これにより、 @samp{.git/NOTES_MERGE_WORKTREE} にノートを追加することで、 @samp{git notes merge} (@samp{.git/NOTES_MERGE_PARTIAL} に保存)によって作成された部分的なマージコミットが修正されます。 @samp{.git/NOTES_MERGE_REF} symref に保存されているノートrefは、結果のコミットに更新されます。

@item  @samp{--abort} 
進行中の @samp{git notes merge} を 中止(abort)/リセット します。つまり、ノートのマージは競合を伴います。これにより、ノートのマージに関連するすべてのファイルが削除されます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
ノートをマージするときは、黙って作業します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
ノートをマージするときは、よりおしゃべりになります。ノートを刈り込むときは、ノートが削除されたすべてのオブジェクト名を報告してください。
@end table

@noindent

@chapheading DISCUSSION

コミットノートは、オブジェクトに関する追加情報(通常はコミットのメッセージを補足する情報)を含むブロブです。 これらのブロブは、ノートrefから取得されます。 ノートrefは通常、パスが記述されたオブジェクトのオブジェクト名である「ファイル」を含むブランチであり、パフォーマンス上の理由からいくつかのディレクトリ区切り文字が含まれています。 @footnote{ 許可されるパス名の形式は @samp{bf/fe/30/.../680d5a...} です。2桁の16進数のディレクトリ名のシーケンスそれぞれの後に、残りのオブジェクトIDを含むファイル名が続きます。 }

ノートを変更するたびに、指定したノート参照に新しいコミットが作成されます。 したがって、たとえば @samp{git log -p notes/commits} を実行することで、ノートの履歴を調べることができます。 現在のところ、コミットメッセージには更新のきっかけとなった操作が記録されているだけで、コミットの作者は通常のルールに従って決定されます(git-commit(1) 参照)。 これらの詳細は、将来的に変更される可能性があります。

ノートrefがツリーオブジェクトを直接指すことも許可されています。その場合、ノートの履歴は @samp{git log -p -g <refname>} で読み取ることができます。

@noindent

@chapheading NOTES MERGE STRATEGIES

デフォルトのノートマージ戦略は「manual」です。これは、ノートの競合を解決するために特別な作業ツリー(@samp{.git/NOTES_MERGE_WORKTREE})で競合するノートをチェックアウトし、そのワークツリーで競合を解決するようにユーザーに指示します。完了したら、ユーザーは @samp{git notes merge --commit} を使用してマージを完了するか、 @samp{git notes merge --abort} を使用してマージを中止できます。

ユーザーは、@samp{-s}/@samp{--strategy} オプションを使用するか、 notes.mergeStrategy を適宜構成して、以下の中から自動マージ戦略を選択できます:

「ours」は、競合するノートを自動的に解決して、ローカルバージョン(つまり、現在のノートref)を優先します。

「theirs」は、リモートバージョンを優先してノートの競合を自動的に解決します(つまり、指定されたノートrefが現在のノートrefにマージされます)。

「union」は、ローカルバージョンとリモートバージョンを連結することにより、ノートの競合を自動的に解決します。

「cat_sort_uniq」は @samp{union} に似ていますが、この戦略は、ローカルバージョンとリモートバージョンを連結することに加えて、結果の行を並べ替え、結果から重複する行を削除します。 これは、 @samp{cat | sort | uniq} シェルパイプラインをローカルバージョンとリモートバージョンに適用するのと同じです。この戦略は、ノートが行ベースの形式に従っていて、マージ結果で行が重複しないようにする場合に役立ちます。 ローカルバージョンまたはリモートバージョンのいずれかにマージ前に既に重複行が含まれている場合、これらもこのノートマージ戦略によって削除されることに注意してください。

@noindent

@chapheading EXAMPLES

あなたはノートを使用して、コミットが書き込まれた時点では利用できなかった情報を含む注釈を追加できます。

@example
$ git notes add -m 'Tested-by: Johannes Sixt <j6t@@kdbg.org>' 72a144e2
$ git show -s 72a144e
[...]
    Signed-off-by: Junio C Hamano <gitster@@pobox.com>

Notes:
    Tested-by: Johannes Sixt <j6t@@kdbg.org>
@end example


原則として、ノートは通常のGitブロブであり、あらゆる種類の形式(または非形式)が受け入れられます。 @samp{git hash-object} を使用して、任意のファイルから安全にノートを作成できます:

@example
$ cc *.c
$ blob=$(git hash-object -w a.out)
$ git notes --ref=built add --allow-empty -C "$blob" HEAD
@end example


(これはバイナリセーフ(binary-safe)ではないため、単純に @samp{git notes --ref=built add -F a.out HEAD} を使用することはできません。) もちろん、テキスト形式以外のノートを @samp{git log} で表示することはあまり意味がありません。なので、あなたがそのようなノートを使用する場合は、それらを使用して何か便利なことを行うために、あなたはおそらくいくつかの特別な目的のツールを作成する必要があります。

@noindent

@chapheading CONFIGURATION

@table @asis

@item  core.notesRef 
@samp{refs/notes/commits} の代わりに読み取りおよび操作するノートref。省略されていないref名である必要があります。この設定は、環境およびコマンドラインから上書きできます。
@end table

このセクションのこの行より上にあるものはすべて、 git-config(1) ドキュメントには含まれていません。 以下の内容に関しては、git-config(1) ドキュメント にあるものと同一です。

@table @asis

@item  notes.mergeStrategy 
ノートの競合を解決するときにデフォルトで選択するマージ戦略。 @samp{manual} 、` ours`、 @samp{theirs}、` union` 、@samp{cat_sort_uniq} のいずれかである必要があります。 デフォルトは @samp{manual} です。 各戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

この設定は、 @samp{--strategy} オプションを git-notes(1) に渡すことでオーバーライドできます。

@item  notes.<name>.mergeStrategy 
@samp{refs/notes/<name>} にノートをマージするときに、どのマージ戦略を選択するか。 これは、より一般的な @samp{notes.mergeStrategy} をオーバーライドします。 利用可能な戦略の詳細については、 git-notes(1) の「NOTES MERGE STRATEGIES」セクションを参照してください。

@item  notes.displayRef 
@samp{git log} 系のコマンドでコミット・メッセージを表示する際に、 @samp{core.notesRef} や @samp{GIT_NOTES_REF} で設定したデフォルトに加えて、どのref (グロブ、または複数回指定されている場合は複数ref)からノートを読み込むかを指定します。

この設定は、 @samp{GIT_NOTES_DISPLAY_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

存在しないrefsに対しては警告が発行されますが、どのrefsにもマッチしないグロブは黙って無視されます。

この設定は、コマンドの @samp{git log} 系の @samp{--no-notes} オプション、またはこれらのコマンドで受け入れられる @samp{--notes=<ref>} オプションによって無効にすることができます。

@samp{core.notesRef} の有効な値(GIT_NOTES_REFによってオーバーライドされる可能性があります)も、表示されるrefのリストに暗黙的に追加されます。

@item  notes.rewrite.<command> 
<command> (現在は @samp{amend} または @samp{rebase})でコミットを書き換え、 そして、 この変数が @samp{false} に設定されている場合、git はノートを元のコミットから書き換えられたコミットにコピーしません。 デフォルトは @samp{true} です。 下記 @samp{notes.rewriteRef} も参照してください。

この設定は、 @samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドでき、環境変数はコロンで区切られたrefまたはグロブ(glob)のリストである必要があります。

@item  notes.rewriteMode 
書き換え時にノートをコピーする場合(@samp{notes.rewrite.<command>} オプション参照)、ターゲットコミットにすでにノートがある場合の対処方法を決定します。 @samp{overwrite} 、 @samp{concatenate} 、 @samp{cat_sort_uniq} 、 @samp{ignore} のいずれかである必要があります。 デフォルトは @samp{concatenate} です。

この設定は、 @samp{GIT_NOTES_REWRITE_MODE} 環境変数でオーバーライドできます。

@item  notes.rewriteRef 
書き換え中にノートをコピーする場合は、ノートをコピーする(完全修飾された)refを指定します。 グロブと見なしたら、マッチするすべてのrefのノートがコピーされます。 この構成を複数回指定することもできます。

デフォルト値はありません。 ノートの書き換えを有効にするには、この変数を構成する必要があります。 デフォルトのコミットノートの書き換えを有効にするには、これを @samp{refs/notes/commits} に設定します。

@samp{GIT_NOTES_REWRITE_REF} 環境変数でオーバーライドできます。 その形式の詳細については、上記 @samp{notes.rewrite.<command>} を参照してください。
@end table

@noindent

@chapheading ENVIRONMENT

@table @asis

@item  @samp{GIT_NOTES_REF} 
@samp{refs/notes/commits} の代わりに、どのrefからノートを操作するか。 これは @samp{core.notesRef} 設定を上書きします。

@item  @samp{GIT_NOTES_DISPLAY_REF} 
コロンで区切られた ref または glob のリスト。コミットメッセージを表示する際に、デフォルトの @samp{core.notesRef} または @samp{GIT_NOTES_REF} に加えて、どの ref からノートを読み込むかを指定します。 これは @samp{notes.displayRef} の設定よりも優先されます。

存在しないrefに対して警告が発行されますが、どのrefとも一致しないグロブ(glob)は黙って無視されます。

@item  @samp{GIT_NOTES_REWRITE_MODE} 
書き換え中にノートをコピーするときに、ターゲットコミットにすでにノートがある場合の対処方法。 @samp{overwrite} 、@samp{concatenate} 、 @samp{cat_sort_uniq} 、@samp{ignore} のいずれかである必要があります。 これは @samp{core.rewriteMode} 設定を上書きします。

@item  @samp{GIT_NOTES_REWRITE_REF} 
コミットを書き換える場合、元のコミットから書き換えられたコミットにコピーするためのノート。refまたはグロブ(glob)のコロンで区切られたリストである必要があります。

環境で設定されていない場合、コピーするノートのリストは、 @samp{notes.rewrite.<command>} および @samp{notes.rewriteRef} の設定によって異なります。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-p4,,,Top
@chapheading Name

git-p4 — Perforceリポジトリからのインポートと、Perforceリポジトリへのsubmit

@noindent

@chapheading Synopsis

@display
git p4 clone [<sync-options>] [<clone-options>] <p4-depot-path>…
git p4 sync [<sync-options>] [<p4-depot-path>…]
git p4 rebase
git p4 submit [<submit-options>] [<master-branch-name>]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、Gitを使用してp4リポジトリと対話する方法を提供します。

@samp{git p4 clone} を使用して既存のp4リポジトリから新しいGitリポジトリを作成し、1つ以上のp4デポパス(depot path)を指定します。 @samp{git p4sync} を使用してp4の変更からの新しいコミットを組み込みます。 @samp{sync} コマンドは、他のp4デポパスからの新しいブランチを含めるためにも使用されます。 @samp{git p4 submit} を使用してGitの変更をp4に送信します。 コマンド @samp{git p4 rebase} は同期を実行し、現在のブランチを更新されたp4リモートブランチにリベースします。

@noindent

@chapheading EXAMPLES

@itemize 

@item
リポジトリをクローンします:

@example
$ git p4 clone //depot/path/project
@end example


@item
新しく作成されたGitリポジトリでいくつかの作業を行います:

@example
$ cd project
$ vi foo.h
$ git commit -a -m "edited foo.h"
@end example


@item
p4からの最近の変更でGitリポジトリを更新し、あなたの作業ツリーにリベースします:

@example
$ git p4 rebase
@end example


@item
あなたのコミットを送信しp4へ戻します:

@example
$ git p4 submit
@end example

@end itemize

@noindent

@chapheading COMMANDS

@noindent

@heading Clone

通常、 @samp{git p4 clone} は、既存のp4リポジトリから新しいGitディレクトリを作成するために使用されます:

@example
$ git p4 clone //depot/path/project
@end example


これは以下の事を行います:

@enumerate 

@item
@samp{project} というサブディレクトリに空のGitリポジトリを作成します。

@item
指定されたp4デポパス(p4 depot path)からGitブランチ @samp{refs/remotes/p4/master} の単一のコミットにヘッドリビジョンの全内容をインポートします。

@item
このリモートからローカルブランチ @samp{master} を作成し、チェックアウトします。
@end enumerate

Gitでp4履歴全体を再現するには、デポパス(dept path)で @samp{@@all} 修飾子を使用します:

@example
$ git p4 clone //depot/path/project@@all
@end example


@noindent

@heading Sync

p4リポジトリで開発が継続されていて、それらの変更をGitリポジトリに取り込むには以下を使用します:

@example
$ git p4 sync
@end example


このコマンドは、p4の新しい変更を検出し、Gitがコミットするときにそれらをインポートします。

P4リポジトリは、 @samp{git p4 sync} を使用して既存のGitリポジトリに追加することもできます:

@example
$ mkdir repo-git
$ cd repo-git
$ git init
$ git p4 sync //path/in/your/perforce/depot
@end example


これにより、指定したデポが既存のGitリポジトリの @samp{refs/remotes/p4/master} にインポートされます。 @samp{--branch} オプションを使用して、p4コンテンツに使用する別のブランチを指定することも可能です。

Gitリポジトリにブランチ @samp{refs/remotes/origin/p4} が含まれている場合、これらは @samp{git p4 sync} 実行中に最初にフェッチされて調べ(consult)られます。p4から直接インポートするのは、Gitリモートから変更をプルするよりもかなり遅いため、これは複数開発者環境(multi-developer environment)で役立ちます。

複数のブランチがある場合、 @samp{git p4 sync} を実行すると、「BRANCH DETECTION」アルゴリズムが自動的に使用され、新しい変更を適切なブランチに分割しようとします。 これを @samp{--branch} オプションでオーバーライドして、更新するブランチを1つだけ指定できます。

@noindent

@heading Rebase

一般的な動作パターンは、p4デポから最新の変更をフェッチし、それらをローカルのコミットされていない変更とマージすることです。多くの場合、p4リポジトリはすべてのコードの最終的な場所であるため、リベース作業フローは理にかなっています。このコマンドは、 @samp{git p4 sync} に続いて @samp{git rebase} を実行して、更新されたp4の変更に加えてローカルコミットを移動します。

@example
$ git p4 rebase
@end example


@noindent

@heading Submit

Gitリポジトリからp4リポジトリに変更を送信するには、別のp4クライアントワークスペース(p4 client workspace)が必要です。 これは、 @samp{P4CLIENT} 環境変数またはGit構成変数 @samp{git-p4.client} を使用して指定する必要があります。p4クライアントは存在する必要がありますが、クライアントルート(client root)がまだ存在しない場合は、クライアントルートが作成されて入力されます。

現在のGitブランチにはあるが、 @samp{p4/master} ブランチにはないすべての変更を送信するには、以下を使用します:

@example
$ git p4 submit
@end example


現在のブランチ以外のブランチを指定するには、以下を使用します:

@example
$ git p4 submit topicbranch
@end example


単一のコミットまたはコミットの範囲を指定するには、以下を使用します:

@example
$ git p4 submit --commit <sha1>
$ git p4 submit --commit <sha1..sha1>
@end example


アップストリーム参照は一般的には @samp{refs/remotes/p4/master} ですが、 @samp{--origin=} コマンドラインオプションを使用してオーバーライドできます。

p4の変更は、ユーザーが @samp{git p4 submit} を呼び出すと作成されます。 @samp{--preserve-user} オプションを使用すると、Gitコミットの作者(author)に応じて所有権が変更されます。このオプションには、 @samp{p4 protect} を使用して付与できるp4の管理者権限が必要です。

送信する代わりに変更を保存するには、以下のように @samp{--shelve} と @samp{--update-shelve} を使用します:

@example
$ git p4 submit --shelve
$ git p4 submit --update-shelve 1234 --update-shelve 2345
@end example


@noindent

@heading Unshelve

Unshelvingは、棚上げされたP4チェンジリスト(shelved P4 changelist)を取得し、ブランチ refs/remotes/p4-unshelved/<changelist> で同等のgit commitを生成します。

git commitは、現在のoriginリビジョン(デフォルトではHEAD)を基準にして作成されます。親コミットはoriginに基づいて作成され、次にunshelveコミットはそれに基づいて作成されます。

originリビジョンは、 @samp{--origin} オプションで変更できます。

refs/remotes/p4-unshelved のターゲットブランチがすでに存在する場合、古いブランチの名前が変更されます。

@example
$ git p4 sync
$ git p4 unshelve 12345
$ git show p4-unshelved/12345
<submit more changes via p4 to the same files>
$ git p4 unshelve 12345
<refuses to unshelve until git is in sync with p4 again>
@end example


@noindent

@chapheading OPTIONS

@noindent

@heading General options

cloneを除くすべてのコマンドは、これらのオプションを受け入れます。

@table @asis

@item  @samp{--git-dir <dir>} 
@samp{GIT_DIR} 環境変数を設定します。 git(1) 参照。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
より多くの進捗情報を提供します。
@end table

@noindent

@heading Sync options

これらのオプションは、最初の「クローン」(clone)操作と後続の「同期」(sync)操作で使用できます。

@table @asis

@item  @samp{--branch <ref>} 
変更を @samp{refs/remotes/p4/master} ではなく <ref> にインポートします。 <ref>が @samp{refs/} で始まる場合は、そのまま使用されます。それ以外の場合、 @samp{p4/} で始まらない場合は、その接頭辞が追加されます。

デフォルトでは、 @samp{refs/} で始まらない<ref>は、リモート追跡ブランチの名前として扱われます(@samp{refs/remotes/} の下)。この動作は、 @samp{--import-local} オプションを使用して変更できます。

<ref> のデフォルトは "master" です。

この例では、新しい remote "p4/proj2" を既存のGitリポジトリにインポートします:

@example
    $ git init
    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2
@end example


@item  @samp{--detect-branches} 
ブランチ検出アルゴリズムを使用して、p4の新しいパスを見つけます。 これは、以下の「BRANCH DETECTION」で解説してあります。

@item  @samp{--changesfile <file>} 
<file> にリストされているp4変更番号(p4 change numbers)を1行に1つずつ正確にインポートします。 通常、 @samp{git p4} は、現在のp4リポジトリの状態を検査し、インポートする必要のある変更を検出します。

@item  @samp{--silent} 
進捗情報を出力しません。

@item  @samp{--detect-labels} 
デポパス(depot paths)に関連付けられているラベルをp4に問い合わせ、Gitにタグとして追加します。新しいチェンジリストに関連付けられたラベルのみをインポートするため、有用性は限られています。非推奨です。

@item  @samp{--import-labels} 
p4からGitにラベルをインポートします。

@item  @samp{--import-local} 
デフォルトでは、p4ブランチは @samp{refs/remotes/p4/} に保存され、 git-branch(1) およびその他のコマンドによってリモート追跡ブランチとして扱われます。 このオプションは、代わりにp4ブランチを @samp{refs/heads/p4/} に配置します。このオプション使用後、今後の同期操作では、 @samp{refs/heads} でp4ブランチを見つけることができるように、 @samp{--import-local} も指定する必要があることに注意してください。

@item  @samp{--max-changes <n>} 
指定されたリビジョン指定子(revision specifier)に含まれる変更の全範囲ではなく、最大で <n> 個の変更をインポートします。通常の使用法は、リビジョン指定子として @samp{@@all} を使用しますが、 @samp{--max-changes 1000} を使用して、リビジョン履歴全体ではなく、最後の1000リビジョンのみをインポートします。

@item  @samp{--changes-block-size <n>} 
@samp{@@all} などのリビジョン指定子を特定の変更番号のリストに変換するときに使用する内部ブロックサイズ。変換の変更の完全なリストを見つけるために @samp{p4 changes} への単一の呼び出しを使用する代わりに、 @samp{p4 changes -m} への一連の呼び出しがあり、それぞれが指定のサイズの変更の1ブロックを要求します。デフォルトのブロックサイズは500で、通常はこれが適切です。

@item  @samp{--keep-path} 
デフォルトでは、p4デポパスからGitへのファイル名のマッピングには、デポパス全体の削除が含まれます。このオプションを使用すると、完全なp4デポパスがGitに保持されます。 たとえば、パス @samp{//depot/main/foo/bar.c} は、 @samp{//depot/main/} からインポートすると、 @samp{foo/bar.c} になります。 @samp{--keep-path`を使用すると、Gitパスは代わりに `depot/main/foo/bar.c} になります。

@item  @samp{--use-client-spec} 
クライアント仕様(client spec)を使用して、p4でinterestingファイルのリストを見つけます。以下の「CLIENT SPEC」セクションを参照してください。

@item  @samp{-/ <path>} 
クローン作成または同期時に、選択したデポパスを除外します。
@end table

@noindent

@heading Clone options

これらのオプションは、上記の「sync」オプションとともに、最初の「clone」で使用できます。

@table @asis

@item  @samp{--destination <directory>} 
Gitリポジトリを作成する場所。 指定しない場合、p4デポパス(p4 depot path)の最後のコンポーネントを使用して新しいディレクトリを作成します。

@item  @samp{--bare} 
ベアクローン(bare clone)を実行します。 git-clone(1) を参照してください。
@end table

@noindent

@heading Submit options

これらのオプションを使用して、「git p4 submit」の動作を変更できます。

@table @asis

@item  @samp{--origin <commit>} 
p4に送信するコミットが識別される上流の場所。デフォルトでは、これは @samp{HEAD} から到達可能な最新のp4コミットです。

@item  @samp{-M} 
名前の変更(renames)を検出します。 git-diff(1) を参照してください。名前の変更は、p4ででは明示的な「移動」操作を使用して表されます。コピーを検出するための対応するオプションはありませんが、移動とコピーの両方に変数があります。

@item  @samp{--preserve-user} 
p4に送信する前に、p4の変更を再作成(re-author)してください。このオプションには、p4管理者権限が必要です。

@item  @samp{--export-labels} 
Gitからタグをp4ラベルとしてエクスポートします。Gitで見つかったタグは、perforce 作業ディレクトリに適用されます。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
どのコミットがp4に送信されるかだけを表示します。Gitまたはp4の状態を変更しないでください。

@item  @samp{--prepare-p4-only} 
通常の送信操作と同様に、p4ワークスペースにコミットを適用し、p4でファイルを開いたり、追加したり、削除したりします。 最後の「p4送信」を発行しません。代わりに、手動で送信する方法または元に戻す方法に関するメッセージを表示します。このオプションは、最初の(最も古い)コミット後に常に停止(stop)します。Gitタグはp4にエクスポートされません。

@item  @samp{--shelve} 
送信する代わりに、一連の棚上げされたチェンジリスト(shelved changelists)を作成します。各シェルフ(shelve)を作成した後、関連するファイルは元に戻され(revert)/削除(delete)されます。保留中のコミットが複数ある場合は、複数のシェルフが作成されます。

@item  @samp{--update-shelve CHANGELIST} 
このコミットで既存の棚上げされたチェンジリスト(shelved changelist)を更新します。 @samp{--shelve} の指定を含んでいます。複数の棚上げされたチェンジリストに対して繰り返します。

@item  @samp{--conflict=(ask|skip|quit)} 
p4にコミットを適用すると、競合が発生する可能性があります。 これが発生した場合、デフォルトの動作("ask")は、このコミットをスキップして続行するか、終了するかを尋ねる動作です。このオプションを使用すると、プロンプトをバイパスして、競合するコミットを自動的にスキップしたり、プロンプトを表示せずにコミットの適用を中止(quit)したりできます。

@item  @samp{--branch <branch>} 
送信後、デフォルトの p4/master の代わりに、この名前付きブランチを同期します。詳細については、上記の「Sync options」セクションを参照してください。

@item  @samp{--commit (<sha1>|<sha1>..<sha1>)} 
現在のGitブランチにある変更の完全なリストではなく、指定されたコミットまたはコミットの範囲のみを送信します。

@item  @samp{--disable-rebase} 
すべてのコミットが正常に送信された後の自動リベースを無効にします。 git-p4.disableRebase で設定することもできます。

@item  @samp{--disable-p4sync} 
コミットが送信された後、Perforceからのp4/masterの自動同期を無効にします。 @samp{--disable-rebase} の指定を含んでいます。git-p4.disableP4Sync で設定することもできます。 可能であれば、 origin/master との同期は引き続き続行されます。
@end table

@noindent

@chapheading Hooks for submit

@noindent

@heading p4-pre-submit

@samp{p4-pre-submit} フックが存在し、実行可能である場合に実行されます。フックはパラメータを受け取らず、標準入力からも何も受け取りません。このスクリプトをゼロ以外のステータスで終了すると、 @samp{git-p4 submit} が起動しなくなります。 @samp{--no-verify} コマンドラインオプションでバイパスできます。

使用シナリオの１つは、フックで単体テストを実行することです。

@noindent

@heading p4-prepare-changelist

@samp{p4-prepare-changelist} フックは、デフォルトのチェンジリストメッセージを準備した直後、エディタが起動する前に実行されます。 これは、変更リストのテキストを含むファイルの名前という1つのパラメーターを取ります。スクリプトをゼロ以外のステータスで終了すると、プロセスが中止(abort)されます。

フックの目的は、メッセージファイルをその場で編集することであり、 @samp{--no-verify} オプションによって抑制されることはありません。このフックは、 @samp{--prepare-p4-only} が設定されている場合でも呼び出されます。

@noindent

@heading p4-changelist

@samp{p4-changelist} フックは、ユーザーがチェンジリストメッセージを編集した後に実行されます。 @samp{--no-verify} オプションでバイパスできます。提案されたチェンジリストテキストを保持するファイルの名前という単一のパラメータを取ります。ゼロ以外のステータスで終了すると、コマンドは中止(abort)されます。

フックはチェンジリストファイルの編集を許可されており、テキストをプロジェクトの標準形式に正規化するために使用できます。 また、メッセージファイルを検査した後に送信を拒否するために使用することもできます。

@noindent

@heading p4-post-changelist

@samp{p4-post-changelist} フックは、submitがP4で正常に発生した後に呼び出されます。 これはパラメーターを必要とせず、主に通知を目的としており、git p4 submitアクションの結果に影響を与えることはできません。

@noindent

@heading Rebase options

これらのオプションを使用して、「git p4 rebase」の動作を変更できます。

@table @asis

@item  @samp{--import-labels} 
p4ラベルのインポート。
@end table

@noindent

@heading Unshelve options

@table @asis

@item  @samp{--origin} 
棚上げされたP4チェンジリスト(shelved P4 changelist)が比較される git refspec を設定します。デフォルトは p4/master です。
@end table

@noindent

@chapheading DEPOT PATH SYNTAX

@samp{git p4 sync} と @samp{gitp4 clone} へのp4デポパス引数は、1つ以上のスペースで区切られたp4デポパスにすることができ、最後にオプションのp4リビジョン指定子があります:

@table @asis

@item  "//depot/my/project" 
そのツリーの下の「#head」変更内のすべてのファイルを含む1つのコミットをインポートします。

@item  "//depot/my/project@@all" 
そのデポパスの履歴の変更ごとに1つのコミットをインポートします。

@item  "//depot/my/project@@1,6" 
1から6の変更のみをインポートする。

@item  "//depot/proj1@@all //depot/proj2@@all" 
両方の名前付きのデポパスからのすべての変更を単一のリポジトリにインポートします。これらのディレクトリの下にあるファイルのみが含まれます。 Gitには、「proj1」と「proj2」ごとのサブディレクトリはありません。複数のデポパスを指定する場合は、@samp{--destination} オプションを使用する必要があります。 リビジョン指定子は、各デポパスで同じように指定する必要があります。 同じ名前のファイルがデポパスにある場合、ファイルの最新バージョンのパスがGitに表示されるパスになります。
@end table

p4リビジョン指定子の完全な構文については、「p4 help revisions」を参照してください。

@noindent

@chapheading CLIENT SPEC

p4クライアントの仕様は、 @samp{p4 client} コマンドで維持され、他のフィールドの中でも、デポがクライアントリポジトリにマップされる方法を指定するビューが含まれています。 @samp{clone} と @samp{sync`コマンドは、 `--use-client-spec} オプションが指定されているか、または useClientSpec 変数がtrueの場合に、クライアント仕様(client spec)を参照できます。 @samp{git p4 clone} の後、useClientSpec変数がリポジトリ構成ファイルに自動的に設定されます。これにより、将来の @samp{git p4 submit} コマンドが正しく機能するようになります。 submitコマンドは変数のみを調べ、コマンドラインオプションはありません。

p4ビューの完全な構文は、「p4 help views」に記載されています。 @samp{git p4} は、ビュー構文のサブセットのみを認識します。 複数行のマッピング、「+」のオーバーレイ、「-」の除外、空白の前後の二重引用符(@samp{"})を理解します。可能なワイルドカードのうち、 @samp{git p4} は @samp{...} のみを処理し、パスの最後にある場合にのみ処理します。 @samp{git p4} は、未実装のワイルドカードに遭遇すると文句を言います。

バグ: オーバーラップマッピングの実装にはバグがあります。複数のデポパスがオーバーレイを介してリポジトリ内の同じ場所にマップされる場合、 @samp{git p4} は間違ったパスを選択する可能性があります。 これは、 @samp{git p4} 専用のクライアント仕様を使用せずに解決するのは困難です。

クライアントの名前は、複数の方法で @samp{git p4} に指定できます。 変数 @samp{git-p4.client} が存在する場合は、それが優先されます。 それ以外の場合は、クライアントを決定する通常のp4メカニズムが使用されます。それは、環境変数 @samp{P4CLIENT} または`P4CONFIG` によって参照されるファイル または ローカルホスト名 です。

@noindent

@chapheading BRANCH DETECTION

P4には、Gitと同じブランチの概念はありません。代わりに、p4はそのコンテンツをディレクトリツリーとして編成します。慣例により、さまざまな論理ブランチがツリー内のさまざまな場所にあります。 @samp{p4 branch} コマンドは、ツリー内の異なる領域間のマッピングを維持し、関連するコンテンツを示すために使用されます。 @samp{git p4} は、これらのマッピングを使用してブランチの関係を判別できます。

対象のすべてのブランチが単一のデポパスのサブディレクトリとして存在するリポジトリがある場合、クローン作成または同期時に @samp{--detect-branches} を使用して、 @samp{git p4} がp4内のサブディレクトリを自動的に検出し、これらをGitのブランチとして生成できます。

たとえば、P4リポジトリ構造が以下の場合:

@example
//depot/main/...
//depot/branch1/...
@end example


そして、 @samp{p4 branch -o branch1} は、以下のようなビューライン(View line)を表示します:

@example
//depot/main/... //depot/branch1/...
@end example


次に、以下の @samp{git p4 clone} コマンドを実行します:

@example
git p4 clone --detect-branches //depot@@all
@end example


@samp{refs/remotes/p4/} には @samp{//depot/main} 用の @samp{master} というブランチと @samp{//depot/branch1} 用の @samp{depot/branch1} というブランチが別々に作成されることになります。

ただし、ブランチのように使用できるようにするために、p4でブランチを作成する必要はありません。ブランチ関係を自動的に推測することは難しいため、Git構成設定 @samp{git-p4.branchList} を使用して、ブランチ関係を明示的に識別することができます。これは、単純なp4ブランチ仕様のような "source:destination" ペアのリストであり、 "source" と "destination" はp4リポジトリ内のパス要素です。上記の例は、p4ブランチの存在に依存していました。 p4ブランチがない場合、同じ結果が以下の場合に発生します:

@example
git init depot
cd depot
git config git-p4.branchList main:branch1
git p4 clone --detect-branches //depot@@all .
@end example


@noindent

@chapheading PERFORMANCE

@samp{git p4} で使用される高速インポートメカニズムは、 @samp{git p4 sync} の呼び出しごとに1つのパックファイルを作成します。通常、Gitガベージ圧縮(git-gc(1))は、これらをより少ないパックファイルに自動的に圧縮しますが、 @samp{git repack -adf} を明示的に呼び出すと、パフォーマンスが向上する場合があります。

@noindent

@chapheading CONFIGURATION VARIABLES

以下の構成設定を使用して、 @samp{git p4} の振る舞いを変更できます。全てを見たい時は「git-p4」セクションを参照してください。

@noindent

@heading General variables

@table @asis

@item  git-p4.user 
すべてのp4コマンドのオプションとして、 @samp{-u <user>} で指定されるユーザー。代わりに環境変数 @samp{P4USER} を使用することができます。

@item  git-p4.password 
すべてのp4コマンドのオプションとして、 @samp{-P <password>} で指定されるパスワード。代わりに環境変数 @samp{P4PASS} を使用することができます。

@item  git-p4.port 
すべてのp4コマンドのオプションとして @samp{-p <port>} で指定されるポート。代わりに、環境変数 @samp{P4PORT} を使用することができます。

@item  git-p4.host 
全てのp4コマンドのオプションとして @samp{-h <host>} で指定されるホスト。代わりに環境変数 @samp{P4HOST} を使用することができます。

@item  git-p4.client 
全てのp4コマンドのオプションとして @samp{-c <client>} で指定されるクライアント。クライアントスペック(client spec)を含んでいます。

@item  git-p4.retries 
ネットワークがタイムアウトした場合にp4コマンド(特に @samp{p4 sync})を再試行する回数を指定します。デフォルト値は 3 です。再試行を無効にする場合、またはp4バージョンが再試行をサポートしていない場合(2012.2より前)は、値を0に設定します。
@end table

@noindent

@heading Clone and sync variables

@table @asis

@item  git-p4.syncFromOrigin 
他のGitリポジトリからコミットをインポートする方がp4からインポートするよりもはるかに高速であるため、Gitのリモートで最初にp4の変更を見つけるメカニズムが存在します。 @samp{refs/remote/origin/p4} の下にブランチが存在する場合、それらはp4から同期するときにフェッチされて使用されます。 この変数を @samp{false} に設定して、この動作を無効にすることができます。

@item  git-p4.branchUser 
ブランチ検出のフェーズの一つでは、p4ブランチを調べて、インポートする新しいブランチを見つけます。デフォルトでは、すべてのブランチが検査されます。 このオプションは、検索を、変数で指定した単一のユーザーが所有するものだけに制限します。

@item  git-p4.branchList 
ブランチ検出が有効になっている場合にインポートされるブランチのリスト。各エントリは、コロン(@samp{:})で区切られたブランチ名のペアである必要があります。以下の例では、branchAとbranchBの両方がmainから作成されたことを宣言しています:

@example
git config       git-p4.branchList main:branchA
git config --add git-p4.branchList main:branchB
@end example


@item  git-p4.ignoredP4Labels 
無視するp4ラベルのリスト。これは、インポートできないラベルが検出されると自動的に作成されます。

@item  git-p4.importLabels 
@samp{--import-labels} に従って、p4ラベルをgitにインポートします。

@item  git-p4.labelImportRegexp 
この正規表現にマッチするp4ラベルのみがインポートされます。 デフォルト値は @samp{[a-zA-Z0-9_\-.]+$} です。

@item  git-p4.useClientSpec 
対象のp4デポパスを識別するためにp4クライアント仕様(p4 client spec)を使用する必要があることを指定します。これは、オプション @samp{--use-client-spec} を指定するのと同じです。上記の「CLIENT SPEC」セクションを参照してください。 この変数はブール値であり、p4クライアントの名前ではありません。

@item  git-p4.pathEncoding 
Perforceは、元のOSによって指定されたパスのエンコーディングを保持します。 Gitは、UTF-8としてエンコードされたパスを想定しています。 この設定を使用して、 PERFORCEがパスに使用したエンコーディングをgit-p4に通知します。 このエンコーディングは、 パスのエンコーディングをUTF-8に変換するために使用されます。 例として、 Windows上のPerforceは、 パス名をエンコードするために @samp{cp1252} を使用することがよくあります。 このオプションが p4 clone リクエストに渡されると、 生成された新しい git リポジトリで永続化されます。

@item  git-p4.metadataDecodingStrategy 
Perforce は、 changelistの説明とユーザーのフル・ネームのエンコーディングを、指定の OS 上のクライアントによって保存されたままにします。 p4v クライアントは OS ローカル・エンコーディングを使用するため、さまざまなユーザーが、さまざまなchangelistの説明やユーザーのフル・ネームをさまざまなエンコーディングで同じデポに保存することになります。 Git は、コミット・メッセージと作者名の 一貫性のない/不適切な エンコーディングを許容はしますが、 utf-8 で指定することを想定しています。 git-p4 は、 Perforce でエンコーディングの不確実性を処理する際に、3 つの異なるデコーディング戦略を使用できます。 @samp{passthrough} は、元のバイトを Perforce から git に渡すだけです。 Perforce データが utf-8 以外でエンコードされている場合に、使用可能であるが正しくエンコードされていないデータが作成されます。 @samp{strict} は、Perforce データが utf-8 としてエンコードされることを想定しており、これが正しくない場合、インポートに失敗します。 @samp{fallback} は、データを utf-8 として解釈しようとします。それ以外の場合は、セカンダリ・エンコーディング(デフォルトでは一般的な Windows エンコーディング @samp{cp-1252})を使用するようにフォールバックします。フォールバック・エンコーディングでのデコードも失敗した場合は、上位範囲(upper-range)のバイトがエスケープされます。 歴史的な理由から、 python2 ではデフォルトの戦略は @samp{passthrough} であり、 python3 ではデフォルトは @samp{fallback} です。 @samp{strict} が選択され、デコードが失敗した場合、エラー・メッセージでは回避策としてこの構成パラメーターを変更することを提案します。 このオプションが p4 clone リクエストに渡されると、 生成された新しい git リポジトリで永続化されます。

@item  git-p4.metadataFallbackEncoding 
@samp{fallback} 戦略を使用して Perforce 作者名とchangelistの説明をデコードするときに使用するフォールバック・エンコーディングを指定します(git-p4.metadataDecodingStrategy 参照)。 フォールバック・エンコーディングは、 utf-8 としてデコードするのに失敗した場合にのみ使用されます。 このオプションのデフォルトは、一般的な Windows エンコーディングである @samp{cp1252} です。 このオプションが p4 clone リクエストに渡されると、 生成された新しい git リポジトリで永続化されます。

@item  git-p4.largeFileSystem 
大きな(バイナリ)ファイルに使用されるシステムを指定します。ラージファイルシステム(large file systems)は @samp{git p4 submit} コマンドをサポートしていないことに注意してください。 現在、Git LFSのみが実装されています(詳細については、 @uref{https://git-lfs.github.com/,https://git-lfs.github.com/} を参照してください)。このオプションを使用して以下のように構成するには、Git LFSコマンドライン拡張機能をダウンロードしてインストールします:

@example
git config       git-p4.largeFileSystem GitLFS
@end example


@item  git-p4.largeFileExtensions 
リスト内のファイル拡張子に一致するすべてのファイルは、ラージファイルシステムによって処理されます。 拡張子の前に @samp{.} を付けないでください。

@item  git-p4.largeFileThreshold 
非圧縮サイズがしきい値を超えるすべてのファイルは、ラージファイルシステム(large file system)によって処理されます。デフォルトでは、しきい値はバイト単位で定義されています。 単位を変更するには、接尾辞k、m、gを追加します。

@item  git-p4.largeFileCompressedThreshold 
圧縮サイズがしきい値を超えるすべてのファイルは、ラージファイルシステム(large file system)によって処理されます。このオプションを使用すると、クローン/同期プロセスの速度が低下する可能性があります。デフォルトでは、しきい値はバイト単位で定義されています。 単位を変更するには、接尾辞k、m、gを追加します。

@item  git-p4.largeFilePush 
大きなファイルをサーバーに自動的にプッシュするかどうかを定義するブール変数。

@item  git-p4.keepEmptyCommits 
このブールオプションがtrueに設定されている場合、除外されたファイルのみを含むチェンジリストは空のコミットとしてインポートされます。

@item  git-p4.mapUser 
P4 user をGitのnameとemail addressにマッピングします。以下の形式の文字列を使用して、マッピングを作成します:

@example
git config --add git-p4.mapUser "p4user = First Last <mail@@address.com>"
@end example


マッピングは、P4からのユーザー情報を上書きします。複数のP4ユーザーのマッピングを定義できます。
@end table

@noindent

@heading Submit variables

@table @asis

@item  git-p4.detectRenames 
名前の変更(renames)を検出します。git-diff(1) を参照してください。 これは、true または、false または @samp{git diff -M} で期待されるスコアになります。

@item  git-p4.detectCopies 
コピーを検出します。 git-diff(1) を参照してください。 これは、true または false または @samp{git diff -C} で期待されるスコアになります。

@item  git-p4.detectCopiesHarder 
コピーをより厳しく検出します。 git-diff(1) を参照してください。 ブール値です。

@item  git-p4.preserveUser 
送信時に、誰が @samp{git p4 submit} を呼び出したかに関係なく、Git作者(author)を反映するように変更を再作成(re-author)します。

@item  git-p4.allowMissingP4Users 
@samp{preserveUser} がtrueの場合、 @samp{git p4} は通常、p4ユーザーマップで作者(author)が見つからない場合に停止(die)します。この設定は、それを気にせずに変更を送信します。

@item  git-p4.skipSubmitEdit 
送信プロセスは、各p4変更が送信される前にエディタを呼び出します。ただし、この設定がtrueの場合、編集手順はスキップされます。

@item  git-p4.skipSubmitEditCheck 
p4変更メッセージを編集した後、 @samp{git p4} は、ファイルの変更時刻を調べて、説明が実際に変更されたことを確認します。このオプションは、その変更時刻を調べるテストを無効にします。

@item  git-p4.allowSubmit 
デフォルトでは、任意のブランチを @samp{git p4 submit} 操作のソースとして使用できます。 この構成変数が設定されている場合、指定されたブランチのみを送信ソースとして使用できます。ブランチ名は短い名前(@samp{refs/heads/} は不可)である必要があり、スペースを入れずにコンマ(@samp{,})で区切る必要があります。

@item  git-p4.skipUserNameCheck 
@samp{git p4 submit} を実行しているユーザーがp4ユーザーマップに存在しない場合、 @samp{git p4} は終了(exit)します。このオプションは、関係なく送信を強制するために使用できます。

@item  git-p4.attemptRCSCleanup 
有効にすると、 @samp{git p4submit} はRCSキーワード($Header$ など)のクリーンアップを試みます。そうしないと、マージの競合が発生し、送信が続行できなくなります。 このオプションは、現時点では実験的なものと見なす必要があります。

@item  git-p4.exportLabels 
@samp{--export-labels} に従って、Gitタグをp4ラベルにエクスポートします。

@item  git-p4.labelExportRegexp 
この正規表現にマッチするp4ラベルのみがエクスポートされます。 デフォルト値は @samp{[a-zA-Z0-9_\-.]+$} です。

@item  git-p4.conflict 
@samp{--conflict} に従って、p4との競合が見つかった場合の送信動作を指定します。デフォルトの動作は「ask」です。

@item  git-p4.disableRebase 
送信後に p4/master に対してツリーをリベースしないでください。

@item  git-p4.disableP4Sync 
送信後に p4/master を Perforce と同期しないでください。 git-p4.disableRebase の指定を含んでいます。
@end table

@noindent

@chapheading IMPLEMENTATION DETAILS

@itemize 

@item
p4からのチェンジセットは、Git fast-import を使用してインポートされます。

@item
クローン作成または同期には、p4クライアントは必要ありません。ファイルの内容は @samp{p4 print} を使用して収集されます。

@item
送信するには、Gitリポジトリと同じ場所にないp4クライアントが必要です。パッチは、このp4クライアントに一度に1つずつ適用され、そこから送信されます。

@item
@samp{git p4} によってインポートされた各コミットには、ログメッセージの最後にp4デポの場所と変更番号を示す行があります。 この行は、後の @samp{git p4 sync} 操作で、どのp4の変更が新しいかを知るために使用されます。
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-pack-objects,,,Top
@chapheading Name

git-pack-objects — オブジェクトのパックされたアーカイブを作成する

@noindent

@chapheading Synopsis

@display
git pack-objects [-q | --progress | --all-progress] [--all-progress-implied]
        [--no-reuse-delta] [--delta-base-offset] [--non-empty]
        [--local] [--incremental] [--window=<n>] [--depth=<n>]
        [--revs [--unpacked | --all]] [--keep-pack=<pack-name>]
        [--cruft] [--cruft-expiration=<time>]
        [--stdout [--filter=<filter-spec>] | <base-name>]
        [--shallow] [--keep-true-parents] [--[no-]sparse] < <object-list>
@end display


@noindent

@chapheading DESCRIPTION

標準入力からオブジェクトのリストを読み取り、指定されたベース名を持つ1つ以上のパックされたアーカイブをディスクに書き込むか、パックされたアーカイブを標準出力に書き出します。

パックされたアーカイブは、2つのリポジトリ間でオブジェクトのセットを転送するための効率的な方法であり、アクセス効率の高いアーカイブ形式でもあります。パックされたアーカイブでは、オブジェクトはその全体を圧縮したものとして、または他のオブジェクトとの差分として保存されます。後者はしばしばデルタ(delta)と呼ばれます。

パックされたアーカイブ形式(.pack)は、自己完結型であるように設計されているため、それ以上の情報がなくても解凍できます。したがって、デルタが依存する各オブジェクトがパック内に存在する必要があります。

パックインデックスファイル(.idx)が、パック内のオブジェクトへの高速でランダムなアクセスのために生成されます。インデックスファイル(.idx)とパックされたアーカイブ(.pack)の両方を $GIT_OBJECT_DIRECTORY の pack/ サブディレクトリ（または $GIT_ALTERNATE_OBJECT_DIRECTORIES の任意のディレクトリ)に配置すると、Gitはパックアーカイブから読み取ることができます。

@samp{git unpack-objects} コマンドは、パックされたアーカイブを読み取り、パックに含まれるオブジェクトを「1ファイル1オブジェクト」形式に展開できます。これは通常、ピアによる効率的なネットワーク転送のためにパックがオンザフライで作成されるときに、smart-pullコマンドによって実行されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  base-name 
ファイルのペア(.packと.idx)に書き込み、そして、 <base-name> を使用して、作成されたファイルの名前を決定します。このオプションを使用すると、ペアの2つのファイルが <base-name>-<SHA-1>.@{pack,idx@} ファイルに書き込まれます。 <SHA-1>は、パックの内容に基づくハッシュであり、コマンドの標準出力にも書き込まれます。

@item  @samp{--stdout} 
パックの内容(.packファイルに書き込まれる内容)を標準出力に書き込みます。

@item  @samp{--revs} 
個々のオブジェクト名ではなく、標準入力からリビジョン引数を読み取ります。リビジョン引数は、 @samp{git rev-list} と同じ方法で処理され、 @samp{--objects} フラグはその「commit」引数を使用して、出力するオブジェクトのリストを作成します。結果のリストのオブジェクトはパックされます。リビジョンに加えて、 @samp{--not} または @samp{--shallow <SHA-1>} 行も受け入れられます。

@item  @samp{--unpacked} 
これは @samp{--revs} の指定を含んでいます。標準入力から読み取られたリビジョン引数のリストを処理するときは、オブジェクトのパッキングを未だパックされていないオブジェクトに制限してください。

@item  @samp{--all} 
これは @samp{--revs} の指定を含んでいます。標準入力から読み取られたリビジョン引数のリストに加えて、 @samp{refs/} の下のすべてのrefが含まれるように指定してあるかのように振る舞います。

@item  @samp{--include-tag} 
参照するオブジェクトが結果のパックファイルに含まれている場合は、要求されていない注釈付きタグを含めます。これは、ネイティブGitクライアントに新しいタグを送信するのに役立ちます。

@item  @samp{--stdin-packs} 
オブジェクト名やリビジョン引数ではなく、標準入力からパックファイル(例: @samp{pack-1234abcd.pack})のベース名を読み取ります。 結果のパックには、除外されたパック( @samp{^`で始まる)にリストされているオブジェクトを除く、含まれているパック(}^` で始まらないもの)にリストされているすべてのオブジェクトが含まれます。

互換性のある @samp{--unpacked} を除いて、` --revs` または、 @samp{--revs} を含むオプション(` --all` など)とは互換性がありません。

@item  @samp{--cruft} 
到達不能なオブジェクトを、 @samp{.mtimes} ファイルの存在によって示される別の「クラフト・パック」にパックします。 通常は @samp{git repack --cruft} で使用されます。 呼び出し元はパック名のリストを提供し、 リポジトリに残すパックと削除するパックを示します(接頭辞 @samp{-} で示されます)。 クラフト・パックの内容は、猶予期間(下記 @samp{--cruft-expiration} 参照)を超えていない、または、猶予期間を超えているが猶予期間を超えていない他のオブジェクトから到達可能な生き残ったパックに含まれていないすべてのオブジェクトです。

入力が到達可能なすべてのオブジェクトを含むパックをリストする(そして他のすべてのパックを削除保留中としてリストする)場合、 対応するクラフト・パックには、 すべての到達不能オブジェクト(@samp{--cruft-expiration} よりも新しい mtime)が含まれます。 mtime は @samp{--cruft-expiration} よりも古いですが、 mtime が @samp{--cruft-expiration} よりも新しい到達不能オブジェクトから到達可能です。

@samp{--unpack-unreachable} や @samp{--keep-unreachable} や @samp{--pack-loose-unreachable} や @samp{--stdin-packs} と、@samp{--revs} を暗示するその他のオプションとは互換性がありません。 @samp{--max-pack-size} とも互換性がありません。 @samp{--max-pack-size} オプションが設定されている場合、パックの最大サイズは @samp{pack.packSizeLimit} から推測されません。

@item  @samp{--cruft-expiration=<approxidate>} 
指定されている場合、 mtime が @samp{<approxidate>} よりも古いオブジェクトはクラフト・パック(cruft pack)から削除されます。 指定されていない(そして @samp{--cruft} が指定されている)場合、オブジェクトは削除されません。

@item  @samp{--window=<n>} 
@itemx  @samp{--depth=<n>} 
これらの2つのオプションは、パックに含まれるオブジェクトをデルタ圧縮を使用して格納する方法に影響します。オブジェクトは最初にタイプとサイズ、および、オプションで名前で、内部的にソートされ、 @samp{--window} 内の他のオブジェクトと比較されて、デルタ圧縮を使用することでスペースが節約されるかどうかが確認されます。 @samp{--depth} は、最大デルタ深度を制限します。 深くしすぎると、必要なオブジェクトに到達するために差分データを何度も適用する必要があるため、パック解凍側のパフォーマンスに影響します。

@samp{--window} のデフォルト値は10で、 @samp{--depth} のデフォルト値は50です。 @samp{--depth} の最大深度は4095です。

@item  @samp{--window-memory=<n>} 
このオプションは、 @samp{--window} に加えて追加の制限を提供します。ウィンドウサイズは、メモリ内で @samp{<n>} バイトを超えないように動的に縮小されます。これは、大きなオブジェクトと小さなオブジェクトが混在するリポジトリで、大きなウィンドウでメモリを使い果たさないようにしつつ、小さなオブジェクトには大きなウィンドウを活用できるようにするために有効です。サイズには、「k」または「m」または「g」の接尾辞を付けることができます。 @samp{--window-memory=0} は、メモリ使用量を無制限にします。デフォルトは、 @samp{pack.windowMemory} 構成変数から取得されます。

@item  @samp{--max-pack-size=<n>} 
めったにないシナリオですが、ファイルシステム上に特定のサイズより大きいファイルを作成できない場合があります。このオプションを使用して、出力パックファイルをそれぞれ指定されたサイズ以下の複数の独立したパックファイルに分割するようにコマンドに指示できます。 サイズには、「k」または「m」または「g」の接尾辞を付けることができます。許可される最小サイズは1MiBに制限されています。 構成変数 @samp{pack.packSizeLimit} が設定されていない限り、デフォルトは無制限です。このオプションを使用すると、リポジトリが大きくなり、速度が低下する可能性があることに注意してください。 @samp{pack.packSizeLimit} の説明を参照してください。

@item  @samp{--honor-pack-keep} 
このフラグにより、.keepファイルを含むローカルパックにすでに含まれているオブジェクトは、他の方法でパックされていたとしても無視されます。

@item  @samp{--keep-pack=<pack-name>} 
このフラグにより、指定のパックにすでに含まれているオブジェクトは、他の方法でパックされていたとしても無視されます。 @samp{<pack-name>} は、先頭にディレクトリ名がないパックファイル名です(例: @samp{pack-123.pack})。このオプションは、複数のパックを保持するために複数回指定できます。

@item  @samp{--incremental} 
このフラグにより、すでにパックされているオブジェクトは、他の方法でパックされていたとしても無視されます。

@item  @samp{--local} 
このフラグにより、代替オブジェクトストアから借用されたオブジェクトは、他の方法でパックされていたとしても無視されます。

@item  @samp{--non-empty} 
少なくとも1つのオブジェクトが含まれる場合にのみパックされたアーカイブを作成します。

@item  @samp{--progress} 
@samp{-q} が指定されていない場合、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{--all-progress} 
@samp{--stdout} を指定すると、進行状況レポートはオブジェクトのカウントおよび圧縮フェーズでは表示されますが、書き込みフェーズでは禁止されます。その理由は、場合によっては、出力ストリームが別のコマンドに直接リンクされており、受信パックデータを処理するときに独自の進行状況を表示したい場合があるためです。このフラグは @samp{--progress} に似ていますが、 @samp{--stdout} が使用されている場合でも、書き込みフェーズの進行状況レポートを強制する点が異なります。

@item  @samp{--all-progress-implied} 
これは、進行状況の表示がアクティブになるたびに @samp{--all-progress} の指定を含ませるために使用されます。 @samp{--all-progress} とは異なり、このフラグは実際には進行状況の表示を強制しません。

@item  @samp{-q} 
このフラグにより、コマンドは標準エラーストリームで進行状況を報告しなくなります。

@item  @samp{--no-reuse-delta} 
既存のパックがあるリポジトリに、パックされたアーカイブを作成する場合、コマンドは既存のデルタを再利用します。これにより、パックがわずかに最適化されない場合があります。このフラグは、既存のデルタを再利用せずに最初から計算するようにコマンドに指示します。

@item  @samp{--no-reuse-object} 
このフラグは、削除されていないオブジェクトを含め、既存のオブジェクトデータをまったく再利用しないようにコマンドに指示し、すべてを強制的に再圧縮します。 これは、 @samp{--no-reuse-delta} の指定を含みます。パックされたデータに異なる圧縮レベルを大規模に適用する必要がある曖昧模糊なケースでのみ役立ちます。

@item  @samp{--compression=<n>} 
生成するパック内の新しく圧縮するデータの圧縮レベルを指定します。指定しない場合、パックの圧縮レベルは pack.compression 、core.compression の順で取得します。どちらも設定されていない場合は、zlibのデフォルトである -1 になります。ソースに関係なくすべてのデータに均一な圧縮レベルを強制する場合は、 @samp{-no-reuse-object} オプションを追加します。

@item  @samp{--[no-]sparse} 
@samp{--revs} オプションと組み合わせた場合、「スパース」(sparse)アルゴリズムを切り替えて、パックに含めるオブジェクトを決定します。このアルゴリズムは、新しいオブジェクトを導入するパスに現れるツリーのみをウォークします。これは、小さな変更を送信するためのパックを計算するときに、パフォーマンスに大きなメリットをもたらす可能性があります。ただし、含まれているコミットに特定の種類の直接名前変更(direct renames)含まれている場合は、パックファイルに追加のオブジェクトが追加される可能性があります。このオプションが含まれていない場合、デフォルトで @samp{pack.useSparse} の値になります。 @samp{pack.useSparse} の値は、特に指定されていない限りtrueです。

@item  @samp{--thin} 
ネットワーク転送を減らすために、送信者と受信者の間の共通オブジェクトを省略して「薄い」(thin)パックを作成します。このオプションは、 @samp{--stdout} と組み合わせた場合にのみ意味があります。

注意: 薄いパックは、必要なオブジェクトを省略するという理由でパックされたアーカイブ形式に違反するため、Gitは自己完結型にしないと使用できません。 @samp{git index-pack --fix-thin} (git-index-pack(1) を参照)を使用して、自己完結型のプロパティを復元します。

@item  @samp{--shallow} 
浅いリポジトリ(shallow repository)を持つクライアントに提供されるパックを最適化します。このオプションを @samp{--thin} と組み合わせると、速度を犠牲にしてパックを小さくすることができます。

@item  @samp{--delta-base-offset} 
パックされたアーカイブは、デルタのベースオブジェクトを20バイトのオブジェクト名またはストリーム内のオフセットのいずれかで表現できますが、Gitの古いバージョンは後者を理解していません。 デフォルトでは、 @samp{git pack-objects} は互換性を高めるために前者の形式のみを使用します。このオプションを使用すると、コマンドで後者の形式を使用してコンパクトにすることができます。平均デルタチェーンの長さに応じて、このオプションは通常、結果のパックファイルを3〜5パーセント縮小します。

注意: 最新のGitでは、 @samp{git gc} (git-gc(1) 参照)や @samp{git repack} (git-repack(1) 参照)などの磁器コマンドは、あなたのリポジトリ内のファイルをパックファイルに入れるときに、デフォルトでこのオプションを渡します。バンドルを作成する @samp{git bundle} (git-bundle(1) 参照)も同様です。

@item  @samp{--threads=<n>} 
最適なデルタマッチングを検索するときに生成するスレッドの数を指定します。これには、pack-objectsをpthreadでコンパイルする必要があります。そうでない場合、このオプションは警告とともに無視されます。これは、マルチプロセッサマシンでのパッキング時間を短縮することを目的としています。ただし、デルタ検索ウィンドウに必要なメモリ量は、スレッド数で乗算されます。 0を指定すると、GitはCPUの数を自動検出し、それに応じてスレッドの数を設定します。

@item  @samp{--index-version=<version>[,<offset>]} 
これは、テストスイートでのみ使用することを目的としています。生成するパックインデックスのバージョンを強制し、指定のオフセット上にあるオブジェクトに64ビットインデックスエントリを強制することができます。

@item  @samp{--keep-true-parents} 
このオプションを使用すると、graftsによって隠されている親はそれでもパックされます。

@item  @samp{--filter=<filter-spec>} 
@samp{--stdout} が必要です。結果のパックファイルから特定のオブジェクト(通常はブロブ)を省略します。 有効な @samp{<filter-spec>} 形式ついては、 git-rev-list(1) を参照してください。

@item  @samp{--no-filter} 
以前の任意の @samp{--filter=} 引数をオフにします。

@item  @samp{--missing=<missing-action>} 
将来の「partial clone」(部分クローン)開発に役立つデバッグオプション。このオプションは、欠落しているオブジェクトの処理方法を指定します。

@samp{--missing=error} は、欠落しているオブジェクトが検出された場合に、pack-objectsがエラーで停止することを要求します。リポジトリが部分クローン(partial clone)の場合は、欠落していると言う前に、欠落しているオブジェクトをフェッチしようとします。 @samp{--missing=error} がデフォルトの操作です。

@samp{--missing=allow-any} は、欠落しているオブジェクトが検出された場合でも、オブジェクトの走査(object traversal)を続行できます。欠落しているオブジェクトのフェッチは発生しません。欠落しているオブジェクトは、結果から警告無しに黙って省略されます。

@samp{--missing=allow-promisor} は @samp{allow-any} に似ていますが、オブジェクトの走査は、「予想される」promisorが欠落しているオブジェクトに対してのみ続行できます。欠落しているオブジェクトのフェッチは発生しません。予期しないオブジェクトの欠落により、エラーが発生します。

@item  @samp{--exclude-promisor-objects} 
promisorリモートにあることがわかっているオブジェクトを省略します。 (このオプションは、ローカルで作成されたオブジェクトのみを操作することを目的としているため、再パックするときに、ローカルで作成されたオブジェクト[.promisor なし]とpromisorリモートのオブジェクト[.promisor あり]の区別を維持します。) これは部分クローン(partial clone)で使用されます。

@item  @samp{--keep-unreachable} 
@samp{--unpacked=} オプションで指定されたパック内の参照から到達不能なオブジェクトは、 @samp{*.keep} ファイルでマークされたパック内にない到達可能オブジェクトに加えて、結果のパックに追加されます。 これは @samp{--revs} の指定を含んでいます。

@item  @samp{--pack-loose-unreachable} 
到達不能な緩いオブジェクト(loose objects)をパックします(そしてそれらの緩いオブジェクトを削除します)。 これは @samp{--revs} の指定を含んでいます。

@item  @samp{--unpack-unreachable} 
到達不能なオブジェクトは緩い(loose)オブジェクト形式のままにしてください。これは @samp{--revs} の指定を含んでいます。

@item  @samp{--delta-islands} 
「islands」に基づいてデルタのマッチを制限します。 以下の DELTA ISLANDS を参照してください。
@end table

@noindent

@chapheading DELTA ISLANDS

可能な場合、 @samp{pack-objects} は既存のディスク上のデルタを再利用して、その場で新しいデルタを検索する必要がないようにします。これは、フェッチを提供するための重要な最適化です。つまりこれは、サーバーがほとんどのオブジェクトの展開作業を回避し、ディスクから直接バイトを送信できることを意味するためです。この最適化は、受信側が持っていない(そしてまだ送信していない)ベースに対するデルタとしてオブジェクトが保存されている場合は機能しません。その場合、サーバーはデルタを「壊し」、CPUコストの高い新しいデルタを見つける必要があります。したがって、パフォーマンスにとって重要なのは、ディスク上のデルタ関係にあるオブジェクトのセットが、クライアントがフェッチするものと一致することです。

通常のリポジトリでは、これは自動的に機能する傾向があります。オブジェクトのほとんどはブランチとタグから到達可能であり、それがクライアントがフェッチするものです。サーバー上で検出されたデルタは、クライアントが既に持っているモノとこれから持つ予定のオブジェクトの間にある可能性があります。

ただし、一部のリポジトリ設定では、いくつかの関連しているが別個のref先端のグループがあり、クライアントはそれらのグループを個別にフェッチする傾向があります。 たとえば、単一の共有オブジェクトストアでリポジトリの複数の「フォーク」をホストし、クライアントがそれらを @samp{GIT_NAMESPACE} を介して個別のリポジトリとして、または代替メカニズムを使用して個別のリポジトリとして表示できるようにする場合を考えてみます。素朴な再パックでは、オブジェクトの最適なデルタが、別のフォークでのみ検出されるベースに対してのものであることがわかる場合があります。ただし、クライアントがフェッチするとき、クライアントにはベースオブジェクトがないため、その場で新しいデルタを見つける必要があります。

関連するオブジェクトを指す @samp{refs/heads/} と @samp{refs/tags/} のほかに多くの参照がある場合(たとえば一部のホスティングプロバイダーで使用される @samp{refs/pull} や @samp{refs/Changes} )、同様の状況が存在する可能性があります。デフォルトでは、クライアントはヘッドとタグのみをフェッチし、それらの他のグループでのみ見つかったオブジェクトに対するデルタをそのまま送信することはできません。

デルタ島(delta islands)は、refを個別の「島」にグループ化できるようにすることで、この問題を解決します。 Pack-objectsは、どのオブジェクトがどの島から到達可能かを計算し、全く @samp{A} 島に存在しないベースに対してオブジェクト @samp{A} からデルタを作成することを拒否します。これにより、パックがわずかに大きくなります(デルタ化の機会を逃すため)が、1つの島のフェッチで、島の境界を越えるためにその場でデルタを再計算する必要がないことが保証されます。

デルタ島(delta islands)で再パックする場合、デルタ窓は、構成によって禁止されている候補で詰まる傾向があります。大きな @samp{--window} で再梱包することが助けになります(コンテンツに対して計算を行う前に、島に基づいて一部のオブジェクトペアを拒否できるため、他の方法ほど長くはかかりません)。

島は、複数回指定できる @samp{pack.island} オプションを介して構成されます。各値は、refnames に一致する左アンカーの正規表現(left-anchored regular expressions)です。 例えば:

@example
[pack]
island = refs/heads/
island = refs/tags/
@end example


ヘッドとタグを島に配置します(名前は空の文字列です。名前の詳細については、以下を参照してください)。 これらの正規表現に一致しない参照(例: @samp{refs/pull/123})は、どの島にもありません。 したがって、 @samp{refs/pull/} からのみ到達可能(ヘッドやタグは不可)のオブジェクトは、 @samp{refs/heads/} のベースとして使用される候補にはなりません。

参照は「名前」に基づいて島にグループ化され、同じ名前を生成する2つの正規表現は同じ島にあると見なされます。名前は、正規表現で間に「-」ダッシュがあるキャプチャグループを連結することにより、正規表現から計算されます(訳注:[0-9]+ の部分)。(キャプチャグループがない場合、上記の例のように、名前は空の文字列になります。) これにより、任意の数の島を作成できます。 ただし、このようなキャプチャグループは最大14個しかサポートされていません。

たとえば、各フォークの参照を @samp{refs/virtual/ID} に格納するとします。ここで、 @samp{ID} は数値識別子です。 次に、以下を構成します:

@example
[pack]
island = refs/virtual/([0-9]+)/heads/
island = refs/virtual/([0-9]+)/tags/
island = refs/virtual/([0-9]+)/(pull)/
@end example


これにより、各フォークのヘッドとタグがそれぞれの島( "1234” などの名前)に配置され、それぞれのプルrefsが独自の "1234-pull" になります。

注意: 「最後の1つが勝つ」順序を使用して、正規表現ごとに1つの島を選択することに注意してください(これにより、リポジトリ固有の構成がユーザー全体の構成よりも優先されます)。

@noindent

@chapheading CONFIGURATION

さまざまな構成変数がパッキングに影響します。 git-config(1) を参照してください( pack および delta を検索してください)。

特に、デルタ圧縮は、 @samp{core.bigFileThreshold} 構成変数より大きいオブジェクト、および属性 @samp{delta} がfalseに設定されているファイルでは使用されません。

@noindent

@chapheading SEE ALSO

git-rev-list(1) git-repack(1) git-prune-packed(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-pack-redundant,,,Top
@chapheading Name

git-pack-redundant — 無駄なパックファイルを探す

@noindent

@chapheading Synopsis

@display
git pack-redundant [--verbose] [--alt-odb] (--all | <pack-filename>…)
@end display


@noindent

@chapheading WARNING

@samp{git pack-redundant} has been deprecated and is scheduled for removal in a future version of Git. Because it can only remove entire duplicate packs and not individual duplicate objects, it is generally not a useful tool for reducing repository size. You are better off using @samp{git gc} to do so, which will put objects into a new pack, removing duplicates.

Running @samp{pack-redundant} without the @samp{--i-still-use-this} flag will fail in this release. If you believe you have a use case for which @samp{pack-redundant} is better suited and oppose this removal, please contact the Git mailing list at @uref{mailto:git@@vger.kernel.org,git@@vger.kernel.org}. More information about the list is available at @uref{https://git-scm.com/community,https://git-scm.com/community}.

@noindent

@chapheading DESCRIPTION

このプログラムは、リポジトリ内のどのパックが無駄であるかを計算します。あなたがリポジトリのルートにいる場合、出力は @samp{xargsrm} へのパイプに適しています。

@samp{git pack-redundant} は、標準入力のオブジェクトのリストを受け入れます。無駄でない必要なパックを確認するとき、指定した任意のオブジェクトはすべて無視されます。これにより、到達不能なオブジェクトを含むパックを削除する場合に、以下のコマンドが役立ちます。

git fsck --full --unreachable | cut -d ' ' -f3 | \ git pack-redundant --all | xargs rm

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--all} 
すべてのパックを処理します。コマンドラインのファイル名はすべて無視されます。

@item  @samp{--alt-odb} 
Don’t require objects present in packs from alternate object database (odb) directories to be present in local packs.

@item  @samp{--verbose} 
いくつかの統計をstderrに出力します。 パフォーマンスの低下はわずかです。
@end table

@noindent

@chapheading SEE ALSO

git-pack-objects(1) git-repack(1) git-prune-packed(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-pack-refs,,,Top
@chapheading Name

git-pack-refs — 効率的なリポジトリアクセスのためにヘッド(heads)とタグ(tags)をパックします

@noindent

@chapheading Synopsis

@display
git pack-refs [--all] [--no-prune] [--include <pattern>] [--exclude <pattern>]
@end display


@noindent

@chapheading DESCRIPTION

旧来、ブランチとタグのヒント(まとめて「refs」と呼ばれます)は、refごとに1つのファイルを @samp{$GIT_DIR/refs} ディレクトリの下のディレクトリ(サブディレクトリ)に保存していました。多くのブランチヒントは頻繁に更新される傾向がありますが、ほとんどのタグと一部のブランチヒントは更新されません。リポジトリに数百または数千のタグがある場合、この 1ファイル毎に1ref形式 はストレージを浪費し、パフォーマンスを低下させます。

このコマンドは、refを単一のファイル @samp{$GIT_DIR/packed-refs} に保存することにより、ストレージとパフォーマンスの問題を解決するために使用されます。旧来の @samp{$GIT_DIR/refs} ディレクトリ階層にrefがない場合、このファイルの中から探し、見つかればそれが使用されます。

その後のブランチの更新では、常に @samp{$GIT_DIR/refs} ディレクトリ階層の下に新しいファイルが作成されます。

refが多すぎるリポジトリを処理するための推奨される方法は、refを @samp{--all} で一度パックし、ときどき @samp{git pack-refs} を実行することです。タグは定義上静止しており、変更されることは期待されていません。ブランチヘッドは最初の @samp{pack-refs --all} でパックされますが、現在アクティブなブランチヘッドのみはアンパックされ、その後 @samp{pack-refs} ( @samp{--all} なし)ではアンパックされたままになります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--all} 
The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes all refs to be packed as well, with the exception of hidden refs, broken refs, and symbolic refs. Useful for a repository with many branches of historical interests.

@item  @samp{--no-prune} 
コマンドは通常、それらをパックした後、 @samp{$GIT_DIR/refs} 階層の下の緩いrefを削除します。このオプションは、そうしないように指示します。

@item  @samp{--include <pattern>} 
Pack refs based on a @samp{glob(7)} pattern. Repetitions of this option accumulate inclusion patterns. If a ref is both included in @samp{--include} and @samp{--exclude}, @samp{--exclude} takes precedence. Using @samp{--include} will preclude all tags from being included by default. Symbolic refs and broken refs will never be packed. When used with @samp{--all}, it will be a noop. Use @samp{--no-include} to clear and reset the list of patterns.

@item  @samp{--exclude <pattern>} 
Do not pack refs matching the given @samp{glob(7)} pattern. Repetitions of this option accumulate exclusion patterns. Use @samp{--no-exclude} to clear and reset the list of patterns. If a ref is already packed, including it with @samp{--exclude} will not unpack it.
@end table

When used with @samp{--all}, pack only loose refs which do not match any of the provided @samp{--exclude} patterns.

When used with @samp{--include}, refs provided to @samp{--include}, minus refs that are provided to @samp{--exclude} will be packed.

@noindent

@chapheading BUGS

pack-refs メカニズムが導入される前に作成された古い文書では、 "branch <branch> exists" という意味の場合でも ".git/refs/heads/<branch> file exists" などと紹介される場合があります。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-patch-id,,,Top
@chapheading Name

git-patch-id — パッチの一意のIDを計算します

@noindent

@chapheading Synopsis

@display
git patch-id [--stable | --unstable | --verbatim]
@end display


@noindent

@chapheading DESCRIPTION

標準入力からパッチを読み取り、そのパッチIDを計算します。

A "patch ID" is nothing but a sum of SHA-1 of the file diffs associated with a patch, with line numbers ignored. As such, it’s "reasonably stable", but at the same time also reasonably unique, i.e., two patches that have the same "patch ID" are almost guaranteed to be the same thing.

The main usecase for this command is to look for likely duplicate commits.

@emph{git diff-tree} 出力を処理する場合、パッチの前にコミットのオブジェクト名が付いているという事実を利用して、2つの40バイトの16進文字列を出力します。最初の文字列はパッチIDで、2番目の文字列はコミットIDです。これを使用して、パッチIDからコミットIDへのマッピングを作成できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--verbatim} 
Calculate the patch-id of the input as it is given, do not strip any whitespace.

@example
This is the default if patchid.verbatim is true.
@end example

@item  @samp{--stable} 
パッチIDとして「安定した」ハッシュの合計を使用します。 このオプションを使用すると:

@itemize 

@item
パッチを構成するファイル差分を並べ替えても、IDには影響しません。特に、 "-O<orderfile>" の異なる2つの設定で同じ2つのツリーを比較することによって生成された2つのパッチは、同じパッチIDになります。これにより、計算結果をキーとして使用して、 2本のツリー間の変更に関するメタ情報にインデックスを付ける事ができます。

@item
結果として、 "-O<orderfile>" を使用せずに取得されたdiff出力で使用された場合でも、 git 1.9 以前で生成された値、または「unstable」ハッシュ(以下 @samp{--unstable} を参照)が構成されたときに生成された値とは異なります。これにより、そのような「不安定な」または過去のパッチIDを格納している既存のデータベースが使用できなくなります。

@item
All whitespace within the patch is ignored and does not affect the id.

@example
patchid.stable が true に設定されている場合は、こちらがデフォルトになります。
@end example
@end itemize

@item  @samp{--unstable} 
Use an "unstable" hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older and whitespace is ignored. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.

@example
※これがデフォルトです。
@end example
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-prune-packed,,,Top
@chapheading Name

git-prune-packed — すでにパックファイルにある余分なオブジェクトを削除します

@noindent

@chapheading Synopsis

@display
git prune-packed [-n | --dry-run] [-q | --quiet]
@end display


@noindent

@chapheading DESCRIPTION

このプログラムは、 パックファイルに現在存在するすべてのオブジェクトを、 @samp{$GIT_OBJECT_DIRECTORY} で検索し、独立したオブジェクトディレクトリでも検索します。

余分なオブジェクトはすべて削除されます。

パックは、個別に圧縮され、デルタ圧縮が適用され、単一のファイルに格納され、関連付けられたインデックスファイルを持つオブジェクトのコレクションです。

パックは、ミラーシステム、バックアップエンジン、ディスクストレージなどの負荷を軽減するために使用されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際にオブジェクトを削除するのではなく、削除されるはずのオブジェクトの表示のみを行います。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
進行状況インジケーターを黙らせます。
@end table

@noindent

@chapheading SEE ALSO

git-pack-objects(1) git-repack(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-prune,,,Top
@chapheading Name

git-prune — オブジェクトデータベースで、到達不能なすべてのオブジェクトを剪定(prune)します

@noindent

@chapheading Synopsis

@display
git prune [-n] [-v] [--progress] [--expire <time>] [--] [<head>…]
@end display


@noindent

@chapheading DESCRIPTION

@quotation

@strong{Note}

ほとんどの場合、ユーザーは @emph{git prune} を呼び出す @emph{git gc} を実行する必要があります。 以下の「NOTES」セクションを参照してください。
@end quotation

これは、 @samp{refs/} で使用可能なすべてのrefを使用して @emph{git fsck --unreachable} を実行し、オプションでコマンドラインで指定されたオブジェクトの追加セットを使用して、オブジェクトデータベースのこれらのヘッドオブジェクトから到達できないすべてのアンパックされたオブジェクトを剪定(prune)します。さらに、「git prune-packed」を実行することにより、パック内にも同じモノがあるアンパックされたオブジェクトを剪定します。 また、どのrefからも到達できないエントリを .git/shallow から削除(removes)します。

注意: 到達不能なパックされたオブジェクトが残ることに注意してください。これが望ましくない場合は、 git-repack(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
何も削除しません。何が削除される予定かを報告するだけです。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
削除されたすべてのオブジェクトを報告します。

@item  @samp{--progress} 
進捗状況を表示します。

@item  @samp{--expire <time>} 
<time> より古いルーズオブジェクトのみを期限切れにします。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <head>… 
我々の任意の参照から到達可能なオブジェクトに加えて、リストされた <head>s から到達可能なオブジェクトを保持します。
@end table

@noindent

@chapheading EXAMPLES

リポジトリで使用されていないオブジェクト、またはリポジトリから @samp{.git/objects/info/alternates} を介して借用しているオブジェクトを剪定(prune)するには:

@example
$ git prune $(cd ../another && git rev-parse --all)
@end example


@noindent

@chapheading NOTES

ほとんどの場合、ユーザーは「git prune」を直接呼び出す必要はありませんが、代わりに「git gc」を呼び出す必要があります。これは、他の多くのハウスキーピングタスクとともに剪定(plune)を処理します。

剪定(prune)の対象と見なされるオブジェクトの説明については、「git fsck」の @samp{--unreachable} オプションを参照してください。

@noindent

@chapheading SEE ALSO

git-fsck(1), git-gc(1), git-reflog(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-pull,,,Top
@chapheading Name

git-pull — 別のリポジトリまたはローカルブランチから取得して統合する

@noindent

@chapheading Synopsis

@display
git pull [<options>] [<repository> [<refspec>…]]
@end display


@noindent

@chapheading DESCRIPTION

リモートリポジトリからの変更を現在のブランチに組み込みます。 現在のブランチがリモートの後追いの場合、デフォルトでは、リモートに一致するように現在のブランチを早送り(fast-forward)します。 現在のブランチとリモートが分岐している場合、ユーザーは分岐したブランチを @samp{--rebase} または @samp{--no-rebase} (または @samp{pull.rebase} の対応する構成オプション) と調整する方法を指定する必要があります。

より正確には、 @samp{git pull} は指定されたパラメーターで @samp{git fetch} を実行し、構成オプションまたはコマンドラインフラグに応じて、 @samp{git rebase} または @samp{git merge} を呼び出して、分岐するブランチを調整します。

<repository> は、 git-fetch(1) に渡されるリモートリポジトリの名前である必要があります。 <refspec>は、任意のリモートref(たとえば、タグの名前)、または、対応するリモート追跡ブランチを持つrefのコレクション(例: refs/heads/*:refs/remotes/origin/* )に名前を付けることができますが、通常はリモートリポジトリ内のブランチの名前です。

<repository>と<branch>のデフォルト値は、 git-branch(1) の @samp{--track} によって設定された現在のブランチの「リモート」および「マージ」構成から読み取られます。

次の履歴が存在し、現在のブランチが @samp{master} であると想定します:

@example
          A---B---C master on origin
         /
    D---E---F---G master
        ^
        origin/master in your repository
@end example


次に、 @samp{git pull} は、リモートの @samp{master} ブランチから変更をフェッチしてリプレイします。これは、ローカルの @samp{master} (つまり、 @samp{E})から分岐してから、 @samp{master} 上の現在のコミット(@samp{C})までです。 そして、2つの親コミットの名前と変更を説明するユーザーからのログメッセージとともに、結果を新しいコミットに記録します。

@example
          A---B---C origin/master
         /         \
    D---E---F---G---H master
@end example


競合の表示方法や処理方法などの詳細については、 git-merge(1) を参照してください。

Git 1.7.0 以降では、競合するマージをキャンセルするには、 @samp{git reset --merge} を使用します。 @strong{警告} :古いバージョンのGitでは、コミットされていない変更を加えて @samp{git pull} を実行することはお勧めしません。それは可能ではありますが、競合が発生した場合に元に戻すのが厳しい状態になります。

リモートの変更のいずれかがローカルのコミットされていない変更と重複する場合、マージは自動的にキャンセルされ、作業ツリーは変更されません。 一般に、 プルまたは、git-stash(1) を使用してそれらを隠しておく前に、作業対象のローカルの変更を取得するのが最善です。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q} 
@itemx  @samp{--quiet} 
これは、 転送中のレポートを黙らせる為に git-fetch と、マージ中の出力を黙らせるために git-merge の、両方に渡されます。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
@samp{--verbose} を git-fetch や git-merge に渡します。

@item  @samp{--[no-]recurse-submodules[=yes|on-demand|no]} 
このオプションは、入力されたサブモジュールの新しいコミットをフェッチする必要があるかどうか、およびアクティブなサブモジュールの作業ツリーも更新する必要があるかどうかを制御します(git-fetch(1) 、git-config(1) 、gitmodules(5) を参照)。

チェックアウトがリベースを介して行われる場合、ローカルサブモジュールのコミットもリベースされます。

更新がマージを介して行われる場合、サブモジュールの競合は解決され、チェックアウトされます。
@end table

@noindent

@heading Options related to merging

@table @asis

@item  @samp{--commit} 
@itemx  @samp{--no-commit} 
マージを実行し、結果をコミットします。 このオプションは、 @samp{--no-commit} をオーバーライドするために使用できます。
マージする場合にのみ役立ちます。

@samp{--no-commit} を使用すると、マージを実行し、マージコミットを作成する直前に停止して、ユーザーに、コミットする前にマージ結果を検査し、さらに微調整する機会を提供します。

注意: 早送り(fast-forward)更新はマージコミットを作成しないため、 @samp{--no-commit} を使用してこれらのマージを停止する方法はないことに注意してください。 したがって、mergeコマンドによってブランチが変更または更新されないようにする場合は、 @samp{--no-ff} と @samp{--no-commit} を使用します。

@item  @samp{--edit} 
@itemx  @samp{-e} 
@itemx  @samp{--no-edit} 
機械的マージがを成功する前にエディターを呼び出して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージについて説明して正当化できるようにします。 @samp{--no-edit} オプションを使用して、自動生成されたメッセージを受け入れることができます(これは一般的には推奨されていません)。

古いスクリプトは、ユーザーがマージログメッセージを編集できないようにするという過去の動作に依存している可能性があります。 そのような場合は @samp{git merge} を実行すると、エディターを開く事になります。 このようなスクリプトを簡単に最新の挙動に合わせるために、環境変数 @samp{GIT_MERGE_AUTOEDIT} をスクリプトの先頭で @samp{no} に設定できます。

@item  @samp{--cleanup=<mode>} 
このオプションは、コミットする前にマージメッセージをクリーンアップする方法を決定します。 詳細については、 git-commit(1)を参照してください。 加えて、 @samp{<mode>} に @samp{scissors} 値が指定されている場合、マージの競合が発生した時に、切り取り線(scissors)はコミット機構に渡される前に @samp{MERGE_MSG} に追加されます。

@item  @samp{--ff-only} 
分岐する(divergent)ローカル履歴がない場合にのみ、新しい履歴に更新します。 これは、(@samp{--rebase=*} フラグを介して)分岐する(divergent)履歴を調整する方法が提供されていない場合のデフォルトです。

@item  @samp{--ff} 
@itemx  @samp{--no-ff} 
リベースではなくマージする場合、マージされた履歴がすでに現在の履歴の子孫である場合に、マージがどのように処理されるかを指定します。 マージが要求された場合、 @samp{refs/tags/} 階層の自然な場所に格納されていない注釈付き(および場合によっては署名された)タグをマージしない限り、 @samp{--ff} がデフォルトです。マージする場合は @samp{--no-ff} が想定されます。

@samp{--ff} を使用すると、可能であれば、マージを早送り(fast-forward)(マージされたブランチに一致するようにブランチポインタを更新するだけです。マージコミットは作成しません)として解決します。 不可能な場合(マージされた履歴が現在の履歴の子孫ではない場合)は、マージコミットを作成します。

@samp{--no-ff} を使用すると、マージが早送り(fast-forward)として解決できる場合でも、すべての場合にマージコミットを作成します。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
マージコミット結果にGPG署名します。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに串刺しする必要があります。 @samp{--no-gpg-sign} は、 @samp{commit.gpgSign} 構成変数と、これ以前に指定した @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{--log[=<n>]} 
@itemx  @samp{--no-log} 
ブランチ名に加えて、マージされている実際のコミットから最大<n>個のコミットの1行説明をログメッセージに入力します。 git-fmt-merge-msg(1) も参照してください。
マージする場合にのみ役立ちます。

@samp{--no-log} を使用すると、マージされる実際のコミットからの1行説明が一覧表示されません。

@item  @samp{--signoff} 
@itemx  @samp{--no-signoff} 
コミットログメッセージの最後に、コミッターによる「Signed-off-by」トレーラーを追加します。signoffの意味は、コミットしているプロジェクトによって異なります。たとえば、コミッターがプロジェクトのライセンスに基づいて作品を提出する権利を持っていることを証明したり、開発者の原産地証明書などの寄稿者の代表に同意したりする場合があります。(LinuxカーネルおよびGitプロジェクトで使用されるものについては、http：//developercertificate.orgを参照してください)。プロジェクトでsignoffがどのように使用されるかを理解するには、貢献しているプロジェクトのドキュメントまたはリーダーシップ(leadership)を参照してください。

@samp{--no-signoff} オプションを使用すると、コマンドラインで以前の @samp{--signoff} オプションを無効にすることができます。

@item  @samp{--stat} 
@itemx  @samp{-n} 
@itemx  @samp{--no-stat} 
マージの最後にdiffstatを表示します。 diffstatは、構成オプションmerge.statによっても制御されます。

@samp{-n} または @samp{--no-stat} を使用すると、マージの最後に diffstat が表示されません。

@item  @samp{--squash} 
@itemx  @samp{--no-squash} 
(マージ情報を除く)実際のマージが発生したかのように作業ツリーとインデックスの状態を生成しますが、実際にコミットしたり、 @samp{HEAD} を移動したり、 (次の @samp{git commit} コマンドでマージコミットを作成する、) @samp{$GIT_DIR/MERGE_HEAD} を記録したりしないでください。 これにより、現在のブランチの上に単一のコミットを作成できます。その効果は、別のブランチ(または octopusの場合はそれ以上)をマージするのと同じです。

@samp{--no-squash} を使用してマージを実行し、結果をコミットします。 このオプションは、 @samp{--squash} をオーバーライドするために使用できます。

@samp{--squash} を使用すると、 @samp{--commit} は許可されず、失敗します。

マージする場合にのみ役立ちます。

@item  @samp{--[no-]verify} 
デフォルトでは、 pre-merge フックと commit-msg フックが実行されます。 @samp{--no-verify} が指定されている場合、これらはバイパスされます。 githooks(5) も参照してください。
マージする場合にのみ役立ちます。

@item  @samp{-s <strategy>} 
@itemx  @samp{--strategy=<strategy>} 
指定されたマージ戦略を使用します。 試行する順序を指定するために、複数回指定できます。 @samp{-s} オプションがない場合は、代わりに組み込みの戦略リストが使用されます(単一のヘッドをマージする場合は @samp{ort}、それ以外の場合は @samp{octopus})。

@item  @samp{-X <option>} 
@itemx  @samp{--strategy-option=<option>} 
マージ戦略固有のオプションをマージ戦略に渡します。

@item  @samp{--verify-signatures} 
@itemx  @samp{--no-verify-signatures} 
マージされるサイドブランチの先端コミットが有効なキー、つまり有効なuidを持つキーで署名されていることを確認します。デフォルトの信頼モデルでは、これは署名キーが信頼できるキーによって署名されていることを意味します。サイドブランチの先端コミットが有効なキーで署名されていない場合、マージは中止されます。

マージする場合にのみ役立ちます。

@item  @samp{--summary} 
@itemx  @samp{--no-summary} 
@samp{--stat} および @samp{--no-stat} の同義語。 これらは非推奨であり、将来削除される予定です。

@item  @samp{--autostash} 
@itemx  @samp{--no-autostash} 
操作を開始する前に一時的なスタッシュエントリを自動的に作成し、それを特別なref @samp{MERGE_AUTOSTASH} に記録し、操作の終了後にapplyします。 これは、ダーティワークツリーで操作を実行できることを意味します。 ただし、注意して使用してください。マージが成功した後の最後のstashアプリケーションは、深刻な競合を引き起こす可能性があります。

@item  @samp{--allow-unrelated-histories} 
デフォルトでは、 @samp{git merge} コマンドは、共通の祖先を共有しない履歴のマージを拒否します。 このオプションは、独立して産まれた2つのプロジェクトの履歴をマージするときにこのセーフティを無効にするために使用できます。 これは非常にまれなケースであるため、これをデフォルトで有効にする構成変数は存在せず、今後も追加されません。

マージする場合にのみ役立ちます。

@item  @samp{-r} 
@itemx  @samp{--rebase[=false|true|merges|interactive]} 
trueの場合、フェッチ後に現在のブランチをアップストリームブランチの上にリベースします。 アップストリームブランチに対応するリモートトラッキングブランチがあり、アップストリームブランチが最後にフェッチされてからリベースされた場合、リベースはその情報を使用して、非ローカル変更のリベースを回避します。

@samp{merges} に設定すると、 @samp{git rebase --rebase-merges} を使用してリベースし、ローカルマージコミットがリベースに含まれるようにします(詳細については、 git-rebase(1) を参照してください)。

falseの場合、アップストリームブランチを現在のブランチにマージします。

@samp{interactive} の場合、リベースの対話モードを有効にします。

@samp{git pull} がマージする代わりに、常に @samp{--rebase} を使用するようにしたいなら、 git-config(1) の @samp{pull.rebase} と @samp{branch.<name>.rebase} と @samp{branch.autoSetupRebase} を参照してください。

@quotation

@strong{Note}

これは潜在的に「危険」な操作モードです。 それは履歴を塗り替えてしまいます。その履歴はすでに公開されているのですから、良くない兆候です。 git-rebase(1) を注意深く読んでいない限り、このオプションを使用しないでください。
@end quotation

@item  @samp{--no-rebase} 
これは @samp{--rebase=false} の省略形です。
@end table

@noindent

@heading Options related to fetching

@table @asis

@item  @samp{--all} 
すべてのリモートをフェッチします。

@item  @samp{-a} 
@itemx  @samp{--append} 
フェッチされた参照の参照名とオブジェクト名を @samp{.git/FETCH_HEAD} の既存のコンテンツに追加します。 このオプションがないと、 @samp{.git/FETCH_HEAD} の古いデータが上書きされます。

@item  @samp{--atomic} 
アトミックトランザクションを使用して、ローカル参照を更新します。 すべての参照が更新されるか、あるいは、エラーが発生してすべての参照が新されないか、のいずれかです。

@item  @samp{--depth=<depth>} 
各リモートブランチ履歴の先端からの指定されたコミット数にフェッチを制限します。 @samp{--depth=<depth>} オプションを指定して @samp{git clone} によって作成された浅いリポジトリ(shallow repository)からフェッチする場合(git-clone(1) 参照)、指定されたコミット数まで履歴を深くするか浅くするかします。

@item  @samp{--deepen=<depth>} 
@samp{--depth} に似ていますが、各リモートブランチ履歴の先端からではなく、現在の浅い境界(shallow boundary)からのコミット数を指定する点が異なります。

@item  @samp{--shallow-since=<date>} 
浅い(shallow)リポジトリの履歴を深くしたり浅くしたりして、<date>以降の到達可能なすべてのコミットを含めます。

@item  @samp{--shallow-exclude=<revision>} 
浅いリ(shallow)ポジトリの履歴を深くするか浅くするかして、指定されたリモートブランチまたはタグから到達可能なコミットを除外します。 このオプションは複数回指定できます。

@item  @samp{--unshallow} 
ソースリポジトリが完全な場合は、浅いリ(shallow)ポジトリを完全なリポジトリに変換し、浅い(shallow)リポジトリによって課せられるすべての制限を取り除きます。

ソースリポジトリが浅い(shallow)場合は、現在のリポジトリがソースリポジトリと同じ履歴を持つように、可能な限りフェッチします。

@item  @samp{--update-shallow} 
デフォルトでは、浅い(shallow)リポジトリからフェッチする場合、 @samp{git fetch} は @samp{.git/shallow} の更新が必要なrefを拒否します。 このオプションは @samp{.git/should} を更新し、そのようなrefを受け入れます。

@item  @samp{--negotiation-tip=<commit|glob>} 
デフォルトでは、Gitは、受信するパックファイルのサイズを縮小するために、すべてのローカルrefから到達可能なコミットをサーバーに報告して、共通のコミットを見つけます。 指定した場合、Gitは指定された先端から到達可能なコミットのみを報告します。 これは、フェッチされるアップストリームrefと共通のコミットを持つ可能性のあるローカルrefがユーザーにわかっている場合に、フェッチを高速化するのに役立ちます。

このオプションは複数回指定できます。 その場合、Gitは指定されたコミットのいずれかから到達可能なコミットを報告します。

このオプションの引数は、ref名またはrefまたはコミットの(おそらく省略された)SHA-1のグロブである可能性があります。グロブを指定することは、一致するref名ごとに1つずつ、このオプションを複数回指定することと同じです。

git-config(1) に記載されている @samp{fetch.negotiationAlgorithm} と @samp{push.negotiate} 構成変数、および、以下の @samp{--negotiate-only} オプションも参照してください。

@item  @samp{--negotiate-only} 
サーバーから何もフェッチせず、代わりに、サーバーと共通している、提供された @samp{--negotiation-tip=*} 引数の祖先を出力します。

これは @samp{--recurse-submodules=[yes|on-demand]} と互換性がありません。 内部的には、これは @samp{push.negotiate} オプションを実装するために使用されます。 git-config(1) を参照してください。

@item  @samp{--dry-run} 
変更を加えずに、何が行われるかを示します。

@item  @samp{--porcelain} 
Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch(1) for details.

This is incompatible with @samp{--recurse-submodules=[yes|on-demand]} and takes precedence over the @samp{fetch.output} config option.

@item  @samp{-f} 
@itemx  @samp{--force} 
@samp{git fetch} を @samp{<src>:<dst>} refspecと一緒に使用すると、既に説明したようにローカルブランチの更新を拒否する場合があります
git-fetch(1) ドキュメントの
@samp{<refspec>} の部分にあります。
このオプションは、そのチェックをオーバーライドします。

@item  @samp{-k} 
@itemx  @samp{--keep} 
ダウンロードしたパックを保持してください。

@item  @samp{--prefetch} 
構成されたrefspecを変更して、すべてのrefを @samp{refs/prefetch/} 名前空間に配置します。 git-maintenance(1)の @samp{prefetch} タスクを参照してください。

@item  @samp{-p} 
@itemx  @samp{--prune} 
フェッチする前に、リモートに存在しなくなったリモート追跡参照を削除します。 タグは、デフォルトのタグの自動追跡または @samp{--tags} オプションのためにのみフェッチされた場合(コマンドラインまたはリモート構成のいずれかで、たとえば、リモートが @samp{--mirror} オプションでcloneされた場合)、刈り込み(pruning)の対象にはなりません。 ただし、明示的なrefspecが原因でタグがフェッチされた場合、それらも刈り込み(pruning)の対象になります。 @samp{--prune-tags} を指定することは、タグrefspecを提供するための省略形です。

@item  @samp{--no-tags} 
デフォルトでは、リモートリポジトリからダウンロードされたオブジェクトを指すタグがフェッチされ、ローカルに保存されます。このオプションは、この自動タグ追跡を無効にします。 リモートのデフォルトの動作は、 @samp{remote.<name>.tagOpt} 設定で指定できます。 git-config(1) を参照してください。

@item  @samp{--refmap=<refspec>} 
コマンドラインにリストされているrefをフェッチするときは、リモートリポジトリの @samp{remote.*.fetch} 構成変数の値の代わりに、指定されたrefspec(複数回指定可能)を使用してrefをリモート追跡ブランチにマップします。 空の @samp{<refspec>} を @samp{--refmap} オプションに指定すると、Gitは構成されたrefspecsを無視し、コマンドライン引数として提供されたrefspecsに完全に依存します。 詳細については、「Configured Remote-tracking Branches」のセクションを参照してください。

@item  @samp{-t} 
@itemx  @samp{--tags} 
他の方法でフェッチされるものに加えて、リモートからすべてのタグをフェッチします(つまり、リモートタグ @samp{refs/tags/*} を同じ名前のローカルタグにフェッチします)。 このオプションを単独で使用しても、 @samp{--prune} が使用されている場合でも、タグは刈り込み(pruning)の対象にはなりません(ただし、タグが明示的なrefspecの宛先でもある場合は、タグは刈り込み(pruning)される可能性があります。 @samp{--prune} を参照してください)。

@item  @samp{-j} 
@itemx  @samp{--jobs=<n>} 
すべての形式のフェッチに使用されるparallel childrenの数。

@samp{--multiple} オプションが指定された場合、異なるリモートが並行してフェッチされます。 複数のサブモジュールがフェッチされる場合、それらは並行してフェッチされます。 それらを個別に制御するには、構成設定 @samp{fetch.parallel} と @samp{submodule.fetchJobs} を使用します(git-config(1) 参照)。

通常、並列再帰フェッチとマルチリモートフェッチの方が高速です。デフォルトでは、フェッチは並列ではなく順次実行されます。

@item  @samp{--set-upstream} 
リモートが正常にフェッチされた場合は、引数のない git-pull(1) およびその他のコマンドで使用されるアップストリーム(追跡)参照を追加します。 詳細については、 git-config(1) の @samp{branch.<name>.merge} および @samp{branch.<name>.remote} を参照してください。

@item  @samp{--upload-pack <upload-pack>} 
指定され、フェッチ元のリポジトリが @samp{git fetch-pack} によって処理されると、 @samp{--exec=<upload-pack>} がコマンドに渡され、もう一方の端で実行されるコマンドのデフォルト以外のパスが指定されます。

@item  @samp{--progress} 
@samp{-q} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{-o <option>} 
@itemx  @samp{--server-option=<option>} 
プロトコルバージョン2を使用して通信する場合は、指定された文字列をサーバーに送信します。 指定された文字列には、NUL文字またはLF文字を含めることはできません。 不明なオプションを含むサーバーオプションのサーバー処理は、サーバー固有です。 複数の @samp{--server-option=<option>} が指定されている場合、それらはすべてコマンドラインにリストされている順序で相手側に送信されます。

@item  @samp{--show-forced-updates} 
デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 これは @samp{fetch.showForcedUpdates} を介して無効にすることができますが、 @samp{--show-forced-updates} オプションはこのチェックが行われることを保証します。 git-config(1) を参照してください。

@item  @samp{--no-show-forced-updates} 
デフォルトでは、gitはフェッチ中にブランチが強制的に更新されるかどうかをチェックします。 @samp{--no-show-forced-updates} を渡すか、 @samp{fetch.showForcedUpdates} を @samp{false} に設定して、パフォーマンス上の理由からこのチェックをスキップします。 @samp{git-pull} 処理中に使用された場合、 @samp{--ff-only} オプションは、早送り(fast-forward)更新を試行する前に、強制更新をチェックします。 git-config(1) を参照してください。

@item  @samp{-4} 
@itemx  @samp{--ipv4} 
IPv6アドレスを無視して、IPv4アドレスのみを使用します。

@item  @samp{-6} 
@itemx  @samp{--ipv6} 
IPv4アドレスを無視して、IPv6アドレスのみを使用します。

@item  <repository> 
フェッチまたはプル操作のソースである「リモート」リポジトリ。このパラメーターは、URL(以下の GIT URLS  セクションを参照)またはリモートの名前(以下の REMOTES (@pxref{[REMOTES]}) セクションを参照)のいずれかです。

@item  <refspec> 
フェッチするrefと更新するローカルrefを指定します。コマンドラインに <refspec> がない場合、フェッチするrefは代わりに @samp{remote.<repository>.fetch} 変数から読み取られます。
(git-fetch(1) の
「CONFIGURED REMOTE-TRACKING BRANCHES」セクション参照)

<refspec> パラメータの組織は、オプションのプラス @samp{+} に続いて ソースの <src> 、コロン @samp{:} 宛先refの <dst> の順です。 <dst> が空の場合、コロン(@samp{:})は省略できます。 <src> は通常、refですが、フルスペルの16進オブジェクト名にすることもできます。

<refspec> の <src> には、単純なパターン一致を示すための @samp{*} が含まれている場合があります。このようなrefspecは、同じプレフィックスを持つ任意のrefに一致するglobのように機能します。パターン<refspec>では、 <src> と <dst> の両方に @samp{*} が含まれている必要があります。 @samp{*} をソースから一致したコンテンツに置き換えることにより、refを宛先にマッピングします。

refspecの前に @samp{^} が付いている場合、それはネガティブのrefspecとして解釈されます。このようなrefspecは、フェッチするrefや更新するローカルrefを指定するのではなく、除外するrefを指定します。 refは、少なくとも1つのポジティブ(通常)のrefspecと一致し、ネガティブのrefspecと一致しない場合、一致すると見なされます。ネガティブのrefspecは、特定のrefが含まれないように、パターンrefspecのスコープを制限するのに役立ちます。ネガティブのrefspecは、それ自体がパターンrefspecである可能性があります。 ただし、 <src> のみを含めることができ、 <dst> を指定することはできません。 フルスペルの16進オブジェクト名もサポートされていません。

@samp{tag <tag>} は、 @samp{refs/tags/<tag>:refs/tags/<tag>} と同じ意味です。指定されたタグまでのすべてをフェッチするように要求します。

<src> に一致するリモートrefがフェッチされ、 <dst> が空の文字列でない場合は、それに一致するローカルrefを更新しようとします。

その更新が @samp{--force} なしで許可されるかどうかは、フェッチ先のref名前空間、フェッチされるオブジェクトのタイプ、および更新がfast-forwardであると見なされるかどうかによって異なります。一般に、プッシュする場合と同じルールがフェッチに適用されます。それらが何であるかについては、 git-push(1)の @samp{<refspec>...} セクションを参照してください。 @emph{git fetch} に固有の例外ルールを以下に示します。

Gitバージョン2.20までは、 git-push(1) でプッシュする場合とは異なり、 @samp{refs/tags/*} の更新は、 refspec に @samp{+} がなくても(または @samp{--force} 指定が無くても)受け入れられます。フェッチするとき、リモートからのすべてのタグ更新を強制フェッチとしていました。Gitバージョン2.20以降では、 @samp{refs/tags/*} を更新するためのフェッチは、プッシュする場合と同じように機能します。 つまり refspecに @samp{+} が無い場合(または @samp{--force} が無い場合)、更新は拒否されます。

git-push(1) でプッシュするときとは異なり、 @samp{refs/@{tags,heads@}/*} 以外の更新は、 refspecに @samp{+} がなくても(あるいは @samp{--force} 指定が無くても)受け付けられます。例えば、ツリーオブジェクトとブロブを交換したり、あるコミットを、祖先を持たない別のコミットと交換したりできます。

git-push(1) でプッシュする場合とは異なり、これらのルールを修正する構成はなく、 @samp{pre-receive} フックに類似した @samp{pre-fetch} フックのようなものはありません。

git-push(1) を使用したプッシュと同様に、更新として許可されないものに関する上記のすべてのルールは、refspec先頭にオプションで @samp{+} をに追加する(または @samp{--force} コマンドラインオプションを使用する)ことでオーバーライドできます。これに対する唯一の例外は、 @samp{refs/heads/*} 名前空間が非コミットオブジェクトを受け入れるように強制することはないということです。

@quotation

@strong{Note}

フェッチするリモートブランチが定期的に巻き戻されてリベースされることがわかっている場合、その新しい先端は(最後にフェッチしたときにリモートトラッキングブランチに保存された)以前の先端の子孫ではないことが予想されます。あなたは @samp{+} 記号を使用して、そのようなブランチにnon-fast-forwardの更新が必要であることを指示します。この操作でブランチがリポジトリで使用可能になることを決定または宣言する方法はありません。プルするユーザーは、これがブランチの予想される使用パターンであることを知っている必要があります。
@end quotation

@quotation

@strong{Note}

@emph{git pull} コマンドラインに直接複数の <refspec> をリストすることと、 <repository> の構成に複数の @samp{remote.<repository>.fetch} エントリを含めることと、明示的な <refspec> パラメーターなしで @emph{git pull} コマンドを実行することには違いがあります。コマンドラインに明示的にリストされている <refspec> は、フェッチ後に常に現在のブランチにマージされます。いいかえると、複数のリモートrefをリストする場合 @samp{git pull} はOctopusマージを作成します。一方、コマンドラインに明示的な <refspec> パラメータをリストしない場合 @emph{git pull} は @samp{remote.<repository>.fetch} 構成で見つかったすべての <refspec> をフェッチし、最初に見つかった <refspec> のみを現在のブランチにマージします。これはリモートrefからOctopusを作成することはめったに行われない為ですが、複数のリモートヘッドを追跡するために複数のリモートヘッドを一度にフェッチすると便利なことがよくあります。
@end quotation
@end table

@noindent

@chapheading GIT URLS

一般に、URLには、トランスポートプロトコル、リモートサーバーのアドレス、およびリポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、一部の情報が欠落している場合があります。

Gitはsshとgitとhttpとhttpsプロトコルをサポートします(さらにftpとftpsをフェッチに使用できますが、これは非効率的で非推奨です。使用しないでください)。

ネイティブトランスポート(つまり、 git:// URL)は認証を行わないため、セキュリティで保護されていないネットワークでは注意して使用する必要があります。

以下の構文を使用できます:

@itemize 

@item
ssh://[user@@]host.xz[:port]/path/to/repo.git/

@item
git://host.xz[:port]/path/to/repo.git/

@item
http[s]://host.xz[:port]/path/to/repo.git/

@item
ftp[s]://host.xz[:port]/path/to/repo.git/
@end itemize

代替のscpのような構文をsshプロトコルで使用することもできます:

@itemize 

@item
[user@@]host.xz:path/to/repo.git/
@end itemize

この構文は、最初のコロン(:)の前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス @samp{foo:bar} を、絶対パスまたは @samp{./foo:bar} として指定して、 ssh url として誤って解釈されないようにすることができます。

sshおよびgitプロトコルは、さらに ~username 拡張をサポートします:

@itemize 

@item
ssh://[user@@]host.xz[:port]/~[user]/path/to/repo.git/

@item
git://host.xz[:port]/~[user]/path/to/repo.git/

@item
[user@@]host.xz:/~[user]/path/to/repo.git/
@end itemize

Gitでもネイティブにサポートされているローカルリポジトリの場合、以下の構文を使用できます:

@itemize 

@item
/path/to/repo.git/

@item
file:///path/to/repo.git/
@end itemize

これらの2つの構文は、前者が @samp{--local} オプションの機能を含むクローン作成の場合を除いて、ほとんど同等です。 詳細については、 git-clone(1) を参照してください。

「git clone」と「git fetch」と「git pull」は、「git push」と違って適切なバンドルファイルを受け入れます。 git-bundle(1) を参照してください。

Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、Gitは @emph{remote-<transport>} リモートヘルパー(存在する場合)を使用しようとします。リモートヘルパーを明示的に要求するには、以下の構文を使用できます:

@itemize 

@item
<transport>::<address>
@end itemize

ここで、 <address> は、パス、サーバーとパス、または呼び出されている特定のリモートヘルパーによって認識される任意のURLのような文字列です。詳細については、 gitremote-helpers(7) を参照してください。

同じ名前のリモートリポジトリが多数あり、それらに異なる形式を使用する場合(あなたの使用するURLが機能するURLに書き換えられるように)、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                insteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:
@end example


"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、任意のコンテキストで、"git://git.host.xz/repo.git" に書き換えられます。

プッシュ専用のURLを書き換えたい場合は、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                pushInsteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/
@end example


"git://example.org/path/to/repo.git" のようなURLは、プッシュの場合は "ssh://example.org/path/to/repo.git" に書き換えられますが、プルは引き続き元のURLのままです。

@noindent

@chapheading REMOTES

@samp{<repository>} 引数として、URLの代わりに以下のいずれかの名前を使用できます:

@itemize 

@item
Git構成ファイル(configuration file)内のリモート(remote)として、 @samp{$GIT_DIR/config} または

@item
@samp{$GIT_DIR/remotes} ディレクトリ内のファイル または

@item
@samp{$GIT_DIR/branches} ディレクトリ内のファイル
@end itemize

これらはすべて、gitがデフォルトで使用するrefspecをそれぞれ含んでいるため、コマンドラインからrefspecを省略できます。

@noindent

@heading Named remote in configuration file

あなたは、 git-remote(1) を使うか、または git-config(1) を使うか、または @samp{$GIT_DIR/config} ファイルを手動で編集して、これ以前に構成したリモートの名前から選択できます。このリモートのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このリモートのrefspecがデフォルトで使用されます。構成ファイルのエントリは以下のようになります:

@example
        [remote "<name>"]
                url = <URL>
                pushurl = <pushurl>
                push = <refspec>
                fetch = <refspec>
@end example


The @samp{<pushurl>} is used for pushes only. It is optional and defaults to @samp{<URL>}. Pushing to a remote affects all defined pushurls or to all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.

@noindent

@heading Named file in $GIT_DIR/remotes

あなたは、 @samp{$GIT_DIR/remotes} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このファイルのrefspecがデフォルトとして使用されます。このファイルの形式は以下のとおりです:

@example
        URL: one of the above URL format
        Push: <refspec>
        Pull: <refspec>
@end example


@samp{Push:} 行は @samp{git push} で使用され、 @samp{Pull:} 行は @samp{git pull} と @samp{git fetch} で使用されます。追加のブランチマッピングのために、複数の @samp{Push:} および @samp{Pull:} 行を指定できます。

@noindent

@heading Named file in $GIT_DIR/branches

@samp{$GIT_DIR/branches} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。 このファイルの形式は以下のとおりです:

@example
        <URL>#<head>
@end example


@samp{<URL>} は必須です。 @samp{#<head>} はオプションです。

コマンドラインで指定しない場合、操作に応じて、gitは以下のrefspecのいずれかを使用します。 @samp{<branch>} は @samp{$GIT_DIR/branchs} 内のこのファイルの名前であり、 @samp{<head>`はデフォルトで `master} になります。

git fetch は以下を使用します:

@example
        refs/heads/<head>:refs/heads/<branch>
@end example


git push は以下を使用します:

@example
        HEAD:refs/heads/<head>
@end example


@noindent

@chapheading MERGE STRATEGIES

マージ機構(@samp{git merge} と @samp{git pull} コマンド)では、バックエンドの「マージ戦略」を @samp{-s} オプションで選択することができます。 いくつかの戦略では、独自のオプションを指定することができます。これは、 @samp{git merge} や @samp{git pull} に @samp{-X<option>} 引数として渡すことができます。

@table @asis

@item  ort 
これは、1つのブランチをプルまたはマージするときのデフォルトのマージ戦略です。この戦略では、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。さらに、この戦略では、名前の変更を伴うマージを検出して処理できます。検出されたコピーは使用しません。このアルゴリズムの名前は "Ostensibly Recursive’s Twin" (表面上は再帰の双子)の頭文字を取ったものであり、以前のデフォルトのアルゴリズムである「recursive」の代わりとして作成されたという事実に由来しています。

@samp{ort} 戦略は、以下のオプションを取ることができます:

@table @asis

@item  ours 
このオプションは、「our」バージョンを優先することにより、競合するハンクをクリーンに自動解決するように強制します。 our側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリファイルの場合、内容全体がour側から取得されます。

これを「ours」マージ戦略と混同しないでください。この戦略では、他のツリーに何が含まれているのかさえまったく調べません。それは他のツリーが行ったすべてを破棄し、「our」履歴にはその中で起こったすべてが含まれていると宣言します。

@item  theirs 
これは「ours」の反対です。 「ours」とは異なり、このmergeオプションを混同する「theirs」マージ戦略はないことに注意してください。

@item  ignore-space-change 
@itemx  ignore-all-space 
@itemx  ignore-space-at-eol 
@itemx  ignore-cr-at-eol 
指示されたタイプの空白(whitespace)の変更を含む行を、3方向マージのために変更されていないものとして扱います。行に対する、他の変更と空白(whitespace)の変更との混合は、無視されません。 git-diff(1) の @samp{-b} と @samp{-w} と @samp{--ignore-space-at-eol} と @samp{--ignore-cr-at-eol} も参照してください。

@itemize 

@item
「their」バージョンが行に空白の変更のみを導入する場合、「our」バージョンが使用されます。

@item
「our」バージョンで空白の変更が導入されたが、「their」バージョンに大幅な変更が含まれている場合は、「their」バージョンが使用されます。

@item
それ以外の場合、マージは通常の方法で進行します。
@end itemize

@item  renormalize 
これにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインが実行されます。このオプションは、ブランチをさまざまなクリーンフィルターまたは行末正規化ルールとマージするときに使用することを目的としています。詳細については、 gitattributes(5) の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)を参照してください。

@item  no-renormalize 
@samp{renormalize} オプションを無効にします。 これは、 @samp{merge.renormalize} 構成変数をオーバーライドします。

@item  find-renames[=<n>] 
名前変更(rename)の検出をオンにし、オプションで類似性のしきい値(similarity threshold)を設定します。これがデフォルトです。 これは、 @samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--find-renames} も参照してください。

@item  rename-threshold=<n> 
@samp{find-renames=<n>} の非推奨の同義語。

@item  subtree[=<path>] 
このオプションは「subtree」戦略をさらに発展させたもので、2つの木をマージする際に、どのようにずらせば互いにマッチするかを推測するものである。その代わり、指定されたパスは、2つの木の形が一致するように前置される(または、最初から取り除かれる)。
@end table

@item  recursive 
これは、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。 これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。 さらに、これにより、名前変更を含むマージを検出して処理できます。 検出されたコピーは使用しません。 これは、Git v0.99.9k 〜 v2.33.0 まで、2つのヘッドを解決するためのデフォルトの戦略でした。

「recursive」(再帰的)戦略は「ort」と同じオプションを取る。 しかし、「ort」が無視する3つのオプション(上記には書かれていない)があり、 「recursive」戦略で有用となる可能性がある:

@table @asis

@item  patience 
@samp{diff-algorithm=patience} の非推奨の同義語。

@item  diff-algorithm=[patience|minimal|histogram|myers] 
マージ中に別の差分アルゴリズムを使用すると、重要でない一致行(異なる関数の中括弧など)が原因で発生するミスマージを回避できます。 git-diff(1) @samp{--diff-algorithm} も参照してください。注意: 特に、「ort」は @samp{diff-algorithm=histogram} を使用しますが、「recursive」はデフォルトで 「diff.algorithm」 設定を使う事に注意して下さい。

@item  no-renames 
名前変更(rename)の検出をオフにします。 これは、@samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--no-renames} も参照してください。
@end table

@item  resolve 
これは、3方向マージアルゴリズムを使用して、2つのヘッド（つまり、現在のブランチとプルした別のブランチ）のみを解決できます。 交差マージ(criss-cross merge)のあいまいさを注意深く検出しようとします。 名前の変更は処理しません。

@item  octopus 
これにより、3つ以上のヘッドを持つケースが解決されますが、手動解決が必要な複雑なマージの実行は拒否されます。これは主に、トピックの分岐ヘッドを纏めるために使用されることを意図しています。これは、複数のブランチをプルまたはマージする場合のデフォルトのマージ戦略です。

@item  ours 
これにより、任意の数のヘッドが解決されますが、結果として得られるマージのツリーは常に現在のブランチヘッドのツリーであり、他のすべてのブランチからのすべての変更を事実上無視します。 これは、サイドブランチの古い開発履歴に取って代わるために使用されることを意図しています。 これは、「recursive」マージ戦略の @samp{-Xours} オプションとは異なることに注意してください。

@item  subtree 
これは改造された「ort」戦略です。 ツリーAとBをマージするとき、BがAのサブツリーに対応する場合、同じレベルのツリーを読み取るのではなく、Bは最初にAのツリー構造に一致するように調整されます。 この調整は、共通の祖先ツリーに対しても行われます。
@end table

3方向マージ(デフォルトの「ort」を含む)を使用する戦略では、両方のブランチで変更が行われたが、後で一方のブランチで元に戻された場合、その変更はマージされた結果に表示されます。一部の人々は、この振る舞いを混乱させると感じています。これは、個々のコミットではなく、ヘッドとマージベースのみがマージの実行時に考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンに置き換えます。

@noindent

@chapheading DEFAULT BEHAVIOUR

@samp{git pull} は多くの場合パラメータを指定せずに使われます。伝統的にこれは @samp{git pull origin} と言うのと同じです。 ただし、ブランチ @samp{<name>} に設定 @samp{branch.<name>.remote} が存在する場合は、 @samp{origin} の代わりにその値が使用されます。

フェッチに使用するURLを決定するために、構成 @samp{remote.<origin>.url} の値が参照され、そのような変数がない場合は、 @samp{$GIT_DIR/remotes/<origin>} の @samp{URL:} 行の値が使用されます。

コマンドラインにrefspecパラメーターを指定せずにコマンドを実行したときにフェッチする(およびオプションでリモート追跡ブランチに格納する)リモートブランチを決定するには、構成変数 @samp{remote.<origin>.fetch} の値を参照します。 構成変数 @samp{remote.<origin>.fetch} が存在しない場合は、 @samp{$GIT_DIR/remotes/<origin>} が参照され、その @samp{Pull:} 行が使用されます。 「OPTIONS」セクションで説明されているrefspec形式に加えて、以下のようなrefspecグロブを作成できます:

@example
refs/heads/*:refs/remotes/origin/*
@end example


グロブのrefspecには空でないRHSが必要であり(つまり、リモート追跡ブランチでフェッチされたものを格納する必要があります)、そのLHSとRHSは @samp{/*} で終わる必要があります。 上記では、すべてのリモートブランチが、同じ名前の @samp{refs/remotes/origin/} 階層のリモート追跡ブランチを使用して追跡されることを指定しています。

下位互換性を損なわないために、フェッチ後にマージするリモートブランチを決定するルールは少し複雑です。

@samp{git pull} のコマンドラインで明示的なrefspecが指定されている場合、それらはすべてマージされます。

コマンドラインでrefspecが指定されていない場合、 @samp{git pull} は 構成 または @samp{$GIT_DIR/remotes/<origin>} からのrefspecを使用します。このような場合、以下のルールが適用されます:

@enumerate 

@item
現在のブランチ @samp{<name>} の @samp{branch.<name>.merge} 構成が存在する場合、それはマージされるリモートサイトのブランチの名前です。

@item
refspecがグロブのものである場合、何もマージされません。

@item
それ以外の場合は、最初のrefspecのリモートブランチがマージされます。
@end enumerate

@noindent

@chapheading EXAMPLES

@itemize 

@item
クローンを作成したリポジトリのリモート追跡ブランチを更新し、そのうちの1つを現在のブランチにマージします:

@example
$ git pull
$ git pull origin
@end example


通常、マージされるブランチはリモートリポジトリのHEADですが、選択は branch.<name>.remote および branch.<name>.merge オプションによって決定されます。 詳細については、 git-config(1) を参照してください。

@item
現在のブランチにリモートブランチ @samp{next} をマージします:

@example
$ git pull origin next
@end example


これにより、 @samp{next} のコピーが一時的にFETCH_HEADに残され、リモート追跡ブランチの @samp{origin/next} が更新されます。 フェッチとマージを呼び出すことで同じことができます:

@example
$ git fetch origin
$ git merge origin/next
@end example

@end itemize

あなたがプルを試みた結果、複雑な競合が発生し、最初からやり直したい場合は、 @samp{git reset} で回復できます。

@noindent

@chapheading SECURITY

フェッチおよびプッシュプロトコルは、共有することを意図していない一方の側が他方のリポジトリからデータを盗むのを防ぐようには設計されていません。悪意のある者から保護する必要のあるプライベートデータがある場合、最善のオプションはそれを別のリポジトリに保存することです。これは、クライアントとサーバーの両方に適用されます。特に、サーバー上の名前空間は、読み取りアクセス制御には効果的ではありません。リポジトリ全体への読み取りアクセスで信頼できるクライアントにのみ、名前空間への読み取りアクセスを許可する必要があります。

既知の攻撃ベクトル(attack vectors)は以下のとおりです:

@enumerate 

@item
被害者は、明示的に共有することを意図していないオブジェクトのIDをアドバタイズする "have" 行を送信しますが、他にもIDを持っている者が居る場合は、転送を最適化するために使用できます。攻撃者はオブジェクトID Xを選択して盗み、refをXに送信しますが、被害者はすでにXのコンテンツを持っているため、Xのコンテンツを送信する必要はありません。 これで、被害者は攻撃者がXを持っていると信じ、Xのコンテンツを後で攻撃者に送り返します。 (この攻撃は、クライアントがアクセスできる名前空間にXへのrefを作成してフェッチすることにより、クライアントがサーバー上で実行するのが最も簡単です。サーバーがクライアント上で実行する最も可能性の高い方法は、Xをパブリックブランチにマージし、ユーザーがこのブランチで追加の作業を行い、マージに気付かずにサーバーにプッシュバックすることを期待します。)

@item
#1 と同様に、攻撃者は盗むオブジェクトID Xを選択します。被害者は、攻撃者がすでに持っているオブジェクトYを送信し、攻撃者はYではなくXを持っていると誤って主張するため、被害者はYをXに対するデルタとして送信します。デルタは、攻撃者にYに類似したXの領域を明らかにします。
@end enumerate

@noindent

@chapheading BUGS

@samp{--recurse-submodules} を使用すると、現在、すでにチェックアウトされているサブモジュールでのみ新しいコミットをフェッチできます。 例えば、スーパープロジェクトのフェッチされたばかりのコミットにアップストリームが新しいサブモジュールを追加すると、サブモジュール自体をフェッチできなくなり、後で再度フェッチを実行せずにそのサブモジュールをチェックアウトすることができなくなります。 これは、将来のGitバージョンで修正される予定です。

@noindent

@chapheading SEE ALSO

git-fetch(1), git-merge(1), git-config(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-push,,,Top
@chapheading Name

git-push — 関連するオブジェクトとともにリモートrefを更新します

@noindent

@chapheading Synopsis

@display
git push [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
           [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
           [-u | --set-upstream] [-o <string> | --push-option=<string>]
           [--[no-]signed|--signed=(true|false|if-asked)]
           [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
           [--no-verify] [<repository> [<refspec>…]]
@end display


@noindent

@chapheading DESCRIPTION

指定のrefを完全にするために必要なオブジェクトを送信により、ローカルrefを使用してリモートrefを更新します。

リポジトリに「フック」を設定することで、あなたがリポジトリにプッシュするたびに興味深いことが起こります。 git-receive-pack(1) のドキュメントを参照してください。

コマンドラインで @samp{<repository>} 引数を使用してプッシュする場所が指定されてい無い場合、現在のブランチの @samp{branch.*.remote} 構成を参照して、プッシュする場所を決定します。 @samp{branch.*.remote} 構成が無い場合、デフォルトは @samp{origin} になります。

コマンドラインで @samp{<refspec>...} 引数や @samp{--all}, @samp{--mirror}, @samp{--tags} オプションを使って何をプッシュするか指定し無かった場合、コマンドは @samp{remote.*.push} 構成を参照してデフォルトの @samp{<refspec>} を探し、それで見つからなかった場合は @samp{push.default} 構成に準拠して何をプッシュするか決定します(@samp{push.default} の意味は git-config(1) を参照ください)。

コマンドラインと構成のどちらもプッシュする対象を指定しない場合、デフォルトの振る舞いが使用されます。それは、 @samp{push.default} の @samp{simple} 値に対応します。 現在のブランチは対応する上流ブランチにプッシュされますが、安全対策として、上流ブランチがローカルブランチと同じ名前でない場合はプッシュが中断(abort)されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  <repository> 
「リモート」(remote)リポジトリはプッシュ操作の宛先です。 このパラメーターは、URL(下記セクション GIT URLS  参照)、または、リモートの名前(下記セクション REMOTES (@pxref{[REMOTES]}) 参照)のどちらかです。

@item  <refspec>… 
どの宛先refをどのソースオブジェクトで更新するかを指定します。 <refspec> パラメータの形式は、オプションのプラス @samp{+} 、ソースオブジェクト <src> 、コロン @samp{:} 、宛先ref <dst> の順です。

<src> は、プッシュするブランチの名前であることがよくありますが、 @samp{master~4} とか @samp{HEAD} などの任意の「SHA-1式」にすることができます(gitrevisions(7) 参照)。

<dst>は、このプッシュでリモート側のどのrefが更新されるかを示します。 ここでは任意の式を使用できません。実際のrefには名前を付ける必要があります。 @samp{git push [<repository>]} に @samp{<refspec>} 引数を指定せず、 @samp{remote.<repository>.push} 構成変数で @samp{<src>} を指定して同一のrefを更新する場合、 @samp{:<dst>} の部分を省略することができるようになりました — このようなプッシュは、コマンドラインで @samp{<refspec>} を指定しなくても、 @samp{<src>} が通常更新するrefを更新することになります。 それ以外の場合、 @samp{:<dst>} がないということは、@samp{<src>} と同一のrefを更新することを意味します。

<dst> が @samp{refs/}(例: @samp{refs/heads/master})で始まらない場合、プッシュされる <src> の種類と <dst> があいまいかどうかから、それが @samp{refs/*} 上のどこに属するか推測しようとします。

@itemize 

@item
<dst> が <repository> リモートのrefを明確に参照している場合は、そのrefにプッシュします。

@item
<src>が @samp{refs/heads/} または @samp{refs/tags/} で始まるrefに解決される場合は、その解決されたrefを <dst> の前に追加します。

@item
将来、他のあいまいさの解決策が追加される可能性がありますが、今のところ、他の場合では、試行した内容を示すエラー出力し、そして @samp{advice.pushUnqualifiedRefname} 構成に応じて、あなたがプッシュしたい @samp{refs/} 名前空間を提案します。
@end itemize

<src>によって参照されるオブジェクトは、リモート側の<dst>参照を更新するために使用されます。 これが許可されるかどうかは、以下で詳細に説明するように、 @samp{refs/*} のどこに<dst>参照が存在するかによって異なります。これらのセクションでは、「更新」(update)とは、削除以外の変更を意味します。

@samp{refs/heads/*} 名前空間はcommitオブジェクトのみを受け入れ、早送り(fast-forward)できる場合にのみ更新します。

@samp{refs/tags/*} 名前空間は(コミット、ツリー、ブロブにタグを付けることができるため、)あらゆる種類のオブジェクトを受け入れ、それらへの更新は拒否(reject)されます。

@samp{refs/@{tags,heads@}/*} の外側の任意の名前空間に任意のタイプのオブジェクトをプッシュすることが可能です。 タグとコミットの場合、更新が許可されるかどうかの判断のために、これらは @samp{refs/heads/*} 内のコミットであるかのように扱われます。

つまり、@samp{refs/@{tags,heads@}/*} の外部でのコミットやタグの早送りは、早送りされるものがコミットではなく、たまたま置き換えられる最後のタグ(またはコミット)の早送りである新しいコミットを指しているタグオブジェクトであっても、許可されます。 タグを全く別のタグに置き換えることも、同一のコミットを指していれば可能です。また、剥かれたタグ(peeled tag)をプッシュすることもできます。つまり、既存のタグオブジェクトが指しているコミット、または既存のコミットが指している新しいタグオブジェクトをプッシュします。

@samp{refs/@{tags,heads@}/*} の外側にあるツリーオブジェクトとブロブオブジェクトは、 @samp{refs/tags/*} の内側にある場合と同一の扱いであり、更新は拒否されます。

更新が許可されていないものに関する上記のすべてのルールは、オプションの先頭の @samp{+} をrefspecに追加する(または @samp{--force} コマンドラインオプションを使用する)ことでオーバーライドできます。 これに対する唯一の例外は、 @samp{refs/heads/*} 名前空間が非コミットオブジェクトを受け入れるように強制することはないということです。 フックと構成は、これらのルールをオーバーライドまたは修正することもできます。たとえば、 git-config(1) の @samp{receive.denyNonFastForwards} と、 githooks(5) の @samp{pre-receive} や @samp{update} を参照してください。

空の <src> をプッシュすると、リモートリポジトリから <dst> ref を削除できます。 構成またはフックによって禁止されている場合を除き、削除は常に refspec の先頭に @samp{+} を付けずに受け入れられます(または @samp{--force})。 git-config(1) の @samp{receive.denyDeletes} と、 githooks(5) の @samp{pre-receive} や @samp{update} を参照してください。

特別なrefspec @samp{:} (または非早送り更新を許可する場合は @samp{+:})は、Gitに、「一致する」ブランチをプッシュするように指示します。 ローカル側に存在するすべてのブランチについて、同じ名前のブランチがリモート側にすでに存在する場合、リモート側が更新されます。

@samp{tag <tag>} は、 @samp{refs/tags/<tag>:refs/tags/<tag>} と同じ意味です。

@item  @samp{--all} 
@itemx  @samp{--branches} 
すべてのブランチ(つまり、 @samp{refs/heads/} の下のrefs)をプッシュします。 他の<refspec>と一緒に使用することはできません。

@item  @samp{--prune} 
ローカルに対応するものがないリモートブランチを削除します。 たとえば、同じ名前のローカルブランチがもう存在しない場合、リモートブランチ @samp{tmp} は削除されます。 これは refspecs も尊重し、 @samp{git push --prune remote refs/heads/*:refs/tmp/*} は、リモートの @samp{refs/tmp/foo} が @samp{refs/heads/foo} が存在しない場合に削除されることを確認するものです。

@item  @samp{--mirror} 
プッシュする各refに名前を付ける代わりに、 @samp{refs/} の下のすべての参照(@samp{refs/heads/} と @samp{refs/remotes/} と @samp{refs/tags/} を含むがこれらに限定されない)がリモートリポジトリへミラーリングされるように指定します。 新しく作成されたローカルrefはリモートエンドにプッシュされ、ローカルで更新されたrefはリモートエンドで強制的に更新され、削除されたrefはリモートエンドから削除されます。 これは、構成オプション @samp{remote.<remote>.mirror} が設定されている場合のデフォルトです。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際に更新を送信する以外はすべて行います。

@item  @samp{--porcelain} 
機械可読出力を生成します。 各refの出力ステータス行はタブで区切られ、stderrではなくstdoutに送信されます。 refの完全な記号名が表示されます。

@item  @samp{-d} 
@itemx  @samp{--delete} 
リストされているすべてのrefがリモートリポジトリから削除されます。 これは、すべてのrefの前にコロン(@samp{:})を付けるのと同一です。

@item  @samp{--tags} 
コマンドラインに明示的にリストされているrefspecsに加えて、 @samp{refs/tags} の下にあるすべてのrefがプッシュされます。

@item  @samp{--follow-tags} 
このオプションがなければプッシュされるであろうすべてのrefをプッシュし、さらに @samp{refs/tags} にある、リモートからは見つからないがプッシュされるrefから到達可能なコミットっぽい何かを指す注釈付きタグをプッシュします。 これは、設定変数 @samp{push.followTags} で指定することもできます。 詳しくは git-config(1) にある @samp{push.followTags} を参照してください。

@item  @samp{--[no-]signed} 
@itemx  @samp{--signed=(true|false|if-asked)} 
プッシュ要求をGPG署名して、受信側のrefを更新し、フックでチェックしたり、ログに記録したりできるようにします。 @samp{false} または @samp{--no-signed} の場合、署名は試行されません。 @samp{true} または @samp{--signed} の場合、サーバーが署名付きプッシュをサポートしていないと、プッシュは失敗します。 @samp{if-asked} に設定されている場合、サーバーが署名されたプッシュをサポートしている場合にのみ署名します。 @samp{gpg --sign} の実際の呼び出しが失敗した場合も、プッシュは失敗します。 受信側の詳細については、 git-receive-pack(1) を参照してください。

@item  @samp{--[no-]atomic} 
可能な場合は、リモート側でアトミック取引(atomic transaction)を使用します。 すべてのrefが更新されるか、エラーが発生した場合、refは更新されません。 サーバーがアトミックプッシュをサポートしていない場合、プッシュは失敗します。

@item  @samp{-o <option>} 
@itemx  @samp{--push-option=<option>} 
指定の文字列をサーバーに送信します。サーバーは、それらを受信前(pre-receive)フックと受信後(post-receive)フックに渡します。 指定の文字列には、NUL文字またはLF文字を含めることはできません。 複数の @samp{--push-option=<option>} が指定されている場合、それらはすべてコマンドラインにリストされている順序で相手側に送信されます。 コマンドラインで @samp{--push-option=<option>} が指定されていない場合は、代わりに構成変数 @samp{push.pushOption} の値が使用されます。

@item  @samp{--receive-pack=<git-receive-pack>} 
@itemx  @samp{--exec=<git-receive-pack>} 
リモート側の @samp{git-receive-pack} プログラムへのパス。 sshを介してリモートリポジトリにプッシュするときや、デフォルトの$PATHのディレクトリに当該プログラムが無いときに便利です。

@item  @samp{--[no-]force-with-lease} 
@itemx  @samp{--force-with-lease=<refname>} 
@itemx  @samp{--force-with-lease=<refname>:<expect>} 
通常、「git push」は、上書きに使用されたローカルrefの祖先ではないリモートrefの更新を拒絶(refuse)します。

リモートrefの現在の値が期待の(expect)値である場合、このオプションはこの制限をオーバーライドします。 それ以外の場合、「git push」は失敗します。

あなたが、すでに公開しているものをリベースする必要があると想像してください。 最初に公開した履歴をリベースされた履歴に置き換えるには、「早送りしなければならない」ルールをバイパスする必要があります。 あなたのリベース作業中に他の誰かがあなたの元の履歴の上に構築した場合、リモートのブランチの先端は彼らのコミットで前進するかもしれません、そして、あなたが @samp{--force} を伴って盲目的にプッシュすると彼らの作業内容は失われてしまいます。

このオプションを使用すると、更新している履歴がリベースされ、置き換えたいものであると期待していると言う事ができます。 リモートrefがまだあなたが指定したコミットを指している場合は、誰もrefに対して何もしなかったことの確認になります。 これは、参照を明示的にロックせずに「リース」(lease;賃借権期間)を取得するようなものであり、リモートrefは「リース」がまだ有効な場合にのみ更新されます。

@samp{--force-with-lease} 単独では、詳細を指定しないため、現在の値がリモート追跡ブランチと同じである必要があり、更新されるすべてのリモートrefを保護します。

@samp{--force-with-lease=<refname>} では、期待する値(expected value)を指定しないので、名前付きrefを(単独で)保護します。更新される場合は、現在の値をリモート追跡ブランチと同じにする必要があります。

@samp{--force-with-lease=<refname>:<expect>} は、現在の値が指定の値 @samp{<expect>} と同じである必要があることで、指定のref(単独)を保護します(これは、refnameに対して持っているリモート追跡ブランチとは異なることが許可されています。または、この形式を使用する場合は、そのようなリモート追跡ブランチを持つ必要はありません)。 @samp{<expect>} が空の文字列である場合、指定のrefはまだ存在していてはなりません。

注意: refの期待される現在の値を明示的に指定する @samp{--force-with-lease=<refname>:<expect>} 以外のすべての形式はまだ実験的であり、この機能の経験を積むにつれてセマンティクスが変わる可能性があることに注意してください。

@samp{--no-force-with-lease} は、コマンドラインでそれ以前に指定した全ての @samp{--force-with-lease} をキャンセルします。

安全性に関する一般的な注意: このオプションを期待値(expected value)なしに指定すると、たとえば cronjob でリポジトリの @samp{git fetch origin} のように、プッシュ先のリモートで暗黙的に @samp{git fetch} を実行するものと非常に悪い相互作用が発生します。

@samp{--force} に対して提供される保護は、作業の基になっていない後続の変更が破壊されないようにすることですが、バックグラウンドプロセスがバックグラウンドでrefを更新している場合、これは簡単に無効になります。 私達は、あなたには既に分かっているはずの参照をやっつけるヒューリスティックとして使用することができるリモートトラッキング情報以外何も持っていません。

あなたのエディターまたは他のシステムがバックグラウンドで @samp{git fetch} を実行している場合、これを軽減する方法は、単に別のリモートをセットアップすることです:

@example
git remote add origin-push $(git config remote.origin.url)
git fetch origin-push
@end example

これで、バックグラウンドプロセスが @samp{git fetch origin} を実行するときは、 @samp{origin-push} の参照は更新されないため、以下のようにコマンドを実行します:

@example
git push --force-with-lease origin-push
@end example

これは、あなたが手動で @samp{git fetch origin-push} を実行しない限り、失敗するでしょう。 もちろん、この方法は @samp{git fetch --all} の実行によって完全に破綻します。この場合、あなたはそれを無効にするか、以下のようになもっと退屈なことをする必要があります:

@example
git fetch              # update 'master' from remote
git tag base master    # mark our base point
git rebase -i master   # rewrite some commits
git push --force-with-lease=master:base master:master
@end example

つまり、上流のコードを見て、上書きしても良いと思ったバージョンの @samp{base} タグを作成し、履歴を書き換え、最後にリモートバージョンがまだ @samp{base} にあれば、ローカルの @samp{remotes/origin/master} がバックグラウンドで何を更新したかに関わらず、変更を @samp{master} に強制的にプッシュします。

あるいは、 @samp{--force-with-lease[=<refname>]} と共に補助オプションとして @samp{--force-if-includes} を指定すると(つまり、リモート側の ref が正確にどのコミットを指す必要があるか、あるいはリモート側のどの ref を保護しているのかを明示せずに)、 プッシュ時に、バックグラウンドで暗黙的に更新されていたかもしれないリモート追跡 ref からの更新がローカルで統合されているかを、強制更新ができる前に確認することができるようになります。

@item  @samp{-f} 
@itemx  @samp{--force} 
通常、コマンドは、上書きに使用されたローカルrefの祖先ではないリモートrefの更新を拒否します。 また、 @samp{--force-with-lease} オプションを使用すると、コマンドは、現在(current)値が期待(expect)値と一致しないリモートrefの更新を拒否します。

このフラグはこれらのチェックを無効にし、リモートリポジトリがコミットを失う原因となる可能性があります。 注意して使用してください。

注意: @samp{--force`は、プッシュされるすべてのrefに適用されることに注意してください。 したがって、 `push.default} を @samp{matching} に設定したり、 @samp{remote.*.push} で構成された複数のプッシュ先で使用すると、現在のブランチ以外のref(リモートの対応物の背後にあるローカル参照を含む)が上書きされる可能性があります。 1つのブランチのみにプッシュを強制するには、 refspecの前に @samp{+} を使用してプッシュします(例: @samp{git push origin +master} を使用して、 @samp{master} ブランチにプッシュを強制します)。 詳細については、上記「<refspec>…」セクションを参照してください。

@item  @samp{--[no-]force-if-includes} 
リモート追跡refの先端がローカルに統合されている場合にのみ、更新を強制します。

このオプションを使用すると、リモートトラッキング参照の先端が、書き換えのためにそれに基づいているローカルブランチの「ref log」エントリの1つから到達可能かどうかを確認(verify)するチェックが有効になります。 このチェックでは、リモートからの更新がローカルに取り込まれていない場合、強制更新を拒否することで、更新がローカルに取り込まれていることを確認します。

オプションが @samp{--force-with-lease} を指定せずに渡された場合、または @samp{--force-with-lease=<refname>:<expect>} と一緒に指定された場合、それは「何もしません」(no-op)。

@samp{--no-force-if-includes} を指定すると、この振る舞いが無効になります。

@item  @samp{--repo=<repository>} 
このオプションは、<repository> 引数と同等です。 両方を指定すると、このオプションではなくコマンドライン引数が優先されます。

@item  @samp{-u} 
@itemx  @samp{--set-upstream} 
最新の、または正常にプッシュされたすべてのブランチについて、引数のない git-pull(1) および その他のコマンドで使用されるアップストリーム(追跡)参照を追加します。 詳細については git-config(1) の @samp{branch.<name>.merge} を参照してください。

@item  @samp{--[no-]thin} 
これらのオプションは git-send-pack(1) に渡されます。 送信側と受信側が同一オブジェクトを多く共有している場合、thin転送は送信データの量を大幅に削減します。 デフォルトは @samp{--thin} です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
エラーが発生しない限り、更新されたrefのリストを含むすべての出力を抑制します。 進行状況を標準エラーストリームに報告しません。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
おしゃべりな実行を行います。

@item  @samp{--progress} 
@samp{-q} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{--no-recurse-submodules} 
@itemx  @samp{--recurse-submodules=check|on-demand|only|no} 
May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If @emph{check} is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If @emph{on-demand} is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If @emph{only} is used all submodules will be pushed while the superproject is left unpushed. A value of @emph{no} or using @samp{--no-recurse-submodules} can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.

When using @emph{on-demand} or @emph{only}, if a submodule has a "push.recurseSubmodules=@{on-demand,only@}" or "submodule.recurse" configuration, further recursion will occur. In this case, "only" is treated as "on-demand".

@item  @samp{--[no-]verify} 
pre-push フックをON/OFFします(githooks(5) 参照)。 デフォルトは @samp{--verify｀ で、フックにプッシュを防ぐ機会を与えます。 `--no-verify} を使用すると、フックは完全にバイパスされます。

@item  @samp{-4} 
@itemx  @samp{--ipv4} 
IPv6アドレスを無視して、IPv4アドレスのみを使用します。

@item  @samp{-6} 
@itemx  @samp{--ipv6} 
IPv4アドレスを無視して、IPv6アドレスのみを使用します。
@end table

@noindent

@chapheading GIT URLS

一般に、URLには、トランスポートプロトコル、リモートサーバーのアドレス、およびリポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、一部の情報が欠落している場合があります。

Gitはsshとgitとhttpとhttpsプロトコルをサポートします(さらにftpとftpsをフェッチに使用できますが、これは非効率的で非推奨です。使用しないでください)。

ネイティブトランスポート(つまり、 git:// URL)は認証を行わないため、セキュリティで保護されていないネットワークでは注意して使用する必要があります。

以下の構文を使用できます:

@itemize 

@item
ssh://[user@@]host.xz[:port]/path/to/repo.git/

@item
git://host.xz[:port]/path/to/repo.git/

@item
http[s]://host.xz[:port]/path/to/repo.git/

@item
ftp[s]://host.xz[:port]/path/to/repo.git/
@end itemize

代替のscpのような構文をsshプロトコルで使用することもできます:

@itemize 

@item
[user@@]host.xz:path/to/repo.git/
@end itemize

この構文は、最初のコロン(:)の前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス @samp{foo:bar} を、絶対パスまたは @samp{./foo:bar} として指定して、 ssh url として誤って解釈されないようにすることができます。

sshおよびgitプロトコルは、さらに ~username 拡張をサポートします:

@itemize 

@item
ssh://[user@@]host.xz[:port]/~[user]/path/to/repo.git/

@item
git://host.xz[:port]/~[user]/path/to/repo.git/

@item
[user@@]host.xz:/~[user]/path/to/repo.git/
@end itemize

Gitでもネイティブにサポートされているローカルリポジトリの場合、以下の構文を使用できます:

@itemize 

@item
/path/to/repo.git/

@item
file:///path/to/repo.git/
@end itemize

これらの2つの構文は、前者が @samp{--local} オプションの機能を含むクローン作成の場合を除いて、ほとんど同等です。 詳細については、 git-clone(1) を参照してください。

「git clone」と「git fetch」と「git pull」は、「git push」と違って適切なバンドルファイルを受け入れます。 git-bundle(1) を参照してください。

Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、Gitは @emph{remote-<transport>} リモートヘルパー(存在する場合)を使用しようとします。リモートヘルパーを明示的に要求するには、以下の構文を使用できます:

@itemize 

@item
<transport>::<address>
@end itemize

ここで、 <address> は、パス、サーバーとパス、または呼び出されている特定のリモートヘルパーによって認識される任意のURLのような文字列です。詳細については、 gitremote-helpers(7) を参照してください。

同じ名前のリモートリポジトリが多数あり、それらに異なる形式を使用する場合(あなたの使用するURLが機能するURLに書き換えられるように)、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                insteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:
@end example


"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、任意のコンテキストで、"git://git.host.xz/repo.git" に書き換えられます。

プッシュ専用のURLを書き換えたい場合は、以下の形式の構成セクションを作成できます:

@example
        [url "<actual url base>"]
                pushInsteadOf = <other url base>
@end example


例えば、以下のようになります:

@example
        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/
@end example


"git://example.org/path/to/repo.git" のようなURLは、プッシュの場合は "ssh://example.org/path/to/repo.git" に書き換えられますが、プルは引き続き元のURLのままです。

@noindent

@chapheading REMOTES

@samp{<repository>} 引数として、URLの代わりに以下のいずれかの名前を使用できます:

@itemize 

@item
Git構成ファイル(configuration file)内のリモート(remote)として、 @samp{$GIT_DIR/config} または

@item
@samp{$GIT_DIR/remotes} ディレクトリ内のファイル または

@item
@samp{$GIT_DIR/branches} ディレクトリ内のファイル
@end itemize

これらはすべて、gitがデフォルトで使用するrefspecをそれぞれ含んでいるため、コマンドラインからrefspecを省略できます。

@noindent

@heading Named remote in configuration file

あなたは、 git-remote(1) を使うか、または git-config(1) を使うか、または @samp{$GIT_DIR/config} ファイルを手動で編集して、これ以前に構成したリモートの名前から選択できます。このリモートのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このリモートのrefspecがデフォルトで使用されます。構成ファイルのエントリは以下のようになります:

@example
        [remote "<name>"]
                url = <URL>
                pushurl = <pushurl>
                push = <refspec>
                fetch = <refspec>
@end example


The @samp{<pushurl>} is used for pushes only. It is optional and defaults to @samp{<URL>}. Pushing to a remote affects all defined pushurls or to all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.

@noindent

@heading Named file in $GIT_DIR/remotes

あなたは、 @samp{$GIT_DIR/remotes} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このファイルのrefspecがデフォルトとして使用されます。このファイルの形式は以下のとおりです:

@example
        URL: one of the above URL format
        Push: <refspec>
        Pull: <refspec>
@end example


@samp{Push:} 行は @samp{git push} で使用され、 @samp{Pull:} 行は @samp{git pull} と @samp{git fetch} で使用されます。追加のブランチマッピングのために、複数の @samp{Push:} および @samp{Pull:} 行を指定できます。

@noindent

@heading Named file in $GIT_DIR/branches

@samp{$GIT_DIR/branches} でファイル名を指定できます。このファイルのURLは、リポジトリへのアクセスに使用されます。 このファイルの形式は以下のとおりです:

@example
        <URL>#<head>
@end example


@samp{<URL>} は必須です。 @samp{#<head>} はオプションです。

コマンドラインで指定しない場合、操作に応じて、gitは以下のrefspecのいずれかを使用します。 @samp{<branch>} は @samp{$GIT_DIR/branchs} 内のこのファイルの名前であり、 @samp{<head>`はデフォルトで `master} になります。

git fetch は以下を使用します:

@example
        refs/heads/<head>:refs/heads/<branch>
@end example


git push は以下を使用します:

@example
        HEAD:refs/heads/<head>
@end example


@noindent

@chapheading OUTPUT

@samp{git push} の出力は、使用する転送方法によって異なります。 このセクションでは、Gitプロトコルで(ローカルまたはssh経由で)プッシュするときの出力について説明します。

プッシュのステータスは表形式で出力され、各行は単一のrefのステータスを表します。 各行の形式は以下のとおりです:

@example
 <flag> <summary> <from> -> <to> (<reason>)
@end example


@samp{--porcelain} が使用されている場合、出力の各行は以下の形式になります:

@example
 <flag> \t <from>:<to> \t <summary> (<reason>)
@end example


最新のrefのステータスは、 @samp{--porcelain} または @samp{--verbose} オプションが使用されている場合にのみ表示されます。

@table @asis

@item  flag 
refのステータスを示す単一の文字:

@table @asis

@item  (space) 
早送り(fast-forward)プッシュに成功した

@item  @samp{+} 
強制更新に成功した

@item  @samp{-} 
refの削除に成功した

@item  @samp{*} 
新しいrefのプッシュに成功した

@item  @samp{!} 
プッシュが拒否された、またはプッシュに失敗したref

@item  @samp{=} 
すでに最新でプッシュする必要がなかったref
@end table

@item  summary 
正常にプッシュされたrefの場合、概要には、refの古い値と新しい値が @samp{git log} の引数として使用するのに適した形式で表示されます(ほとんどの場合は @samp{<old>..<new>} で、強制的な非早送り更新の場合は @samp{<old>...<new>} です)。

失敗した更新については、以下の詳細が示されます:

@table @asis

@item  rejected 
Gitはrefをまったく送信しようと試みませんでした。これは通常、それが早送り(fast-forward)では無く、かつ、あなたが更新を強制しなかったためです。

@item  remote rejected 
リモートエンドが更新を拒否しました。 通常、リモート側のフックが原因で発生するか、リモートリポジトリで次の安全オプションのいずれかが有効になっていることが原因です: @samp{receive.denyCurrentBranch} (チェックアウトされたブランチへのプッシュ用) または @samp{receive.denyNonFastForwards} (強制的な非早送り更新用) または @samp{receive.denyDeletes} または @samp{receive.denyDeleteCurrent} です。 git-config(1) を参照してください。

@item  remote failure 
リモート側は、おそらくリモート側での一時的なエラー、または、ネットワーク接続の切断、または、その他の一時的なエラーのために、refの正常な更新を報告しませんでした。
@end table

@item  from 
プッシュされるローカルrefの名前から、その @samp{refs/<type>/} プレフィックスを取り除いたもの。 削除の場合、ローカルrefの名前は省略されます。

@item  to 
更新されるリモートrefの名前から、 @samp{refs/<type>/} プレフィックスを取り除いたもの。

@item  reason 
人間が読める説明。 正常にプッシュされたrefの場合、説明は必要ありません。 失敗したrefについては、失敗の理由が説明されています。
@end table

@noindent

@chapheading NOTE ABOUT FAST-FORWARDS

更新によって、コミットAをポイントしていたブランチ(またはより一般的にはref)が別のコミットBをポイントするように変更された場合、BがAの子孫である場合に限り、早送り(fast-forward)更新と呼ばれます。

AからBへの早送り(fast-forward)更新では、元のコミットA上に構築されたコミットのセットは、新しいコミットB上に構築されたコミットのサブセットです。 したがって、履歴が失われることはありません。

対照的に、非早送り更新は履歴を失います。 たとえば、あなたと他の誰かが同じコミットXで開始し、あなたがコミットBにつながる履歴を作成し、他の人がコミットAにつながる履歴を作成したとします。そうすると履歴は以下のようになります:

@example
      B
     /
 ---X---A
@end example


さらに、もう一人が既に A につながる変更を元のリポジトリにプッシュしており、そこからあなたたち二人が元のコミット X を取得したとします。

他の人が行ったプッシュにより、コミットXをポイントしていたブランチがコミットAをポイントするように更新されました。これは早送りです。

しかし、あなたがプッシュしようとすると、コミットBでブランチ(現在はAを指している)を更新しようとします。これは早送りにはなりません。 そうすると、コミットAによって導入された変更は失われます。なぜなら、全員がB上に構築を開始するためです。

このコマンドは、デフォルトでは、このような履歴の損失を防ぐための早送り(fast-forward)ではない更新を許可していません。

自分の作業(XからBへの履歴)または他の人の作業(XからAへの履歴)を失いたくない場合は、最初にリポジトリから履歴をフェッチし、行われた変更を含む履歴を作成する必要があり、両方の当事者によって行われた変更を含む履歴を作成し、結果をプッシュバックします。

あなたは @samp{git pull} を実行し、潜在的な競合を解決して、結果を @samp{git push} することができます。 @samp{git pull} は、コミットAとBの間にマージコミットCを作成します。

@example
      B---C
     /   /
 ---X---A
@end example


結果のマージコミットでAを更新すると、早送り(fast-forward)され、そして、プッシュが受け入れられます。

または、あなたは @samp{git pull --rebase} を使用して、A上のXとBの間のあなたの変更をリベースし、結果をプッシュバックすることもできます。 リベースは、A上のXとBの間の変更を構築する新しいコミットDを作成します。

@example
      B   D
     /   /
 ---X---A
@end example


繰り返しになりますが、このコミットでAを更新すると早送り(fast-forward)され、プッシュが受け入れられます。

プッシュしようとしたときに非早送拒否(non-fast-forward rejection)が発生する可能性がある別の一般的な状況があります。これは、他の誰もプッシュしていないリポジトリにプッシュしている場合でも発生する可能性があります。 自分でコミットAをプッシュした後(このセクションの最初の図)、コミットBを生成するために「git commit --amend」に置き換え、すでにAをプッシュしたことを忘れたため、プッシュしようとします。 このような場合、その間に誰も以前のコミットAをフェッチしなかった(そしてその上にビルドを開始した)ことが確実な場合にのみ、「git push --force」を実行して上書きできます。 言い換えれば、「git push --force」は、履歴を失うことを意味する場合のために予約されているメソッドです。

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git push} 
@samp{git push <remote>} のように機能します。ここで、<remote>は現在のブランチのリモート(または、現在のブランチにリモートが構成されていない場合は @samp{origin})です。

@item  @samp{git push origin} 
追加の構成がない場合、現在のブランチが、構成されたアップストリームの現在のブランチと同一の名前の場合は、現在のブランチを構成されたアップストリーム(@samp{branch.<name>.merge} 構成値)にプッシュし、それ以外の場合はプッシュせずにエラーになります。

<refspec>が指定されていない場合のこのコマンドのデフォルトの動作は、リモートの @samp{push} オプション、または @samp{push.default} 構成変数を設定することで構成できます。

たとえば、デフォルトで現在のブランチのみを @samp{origin} にプッシュするには、 @samp{git config remote.origin.push HEAD} を使用します。 有効な <refspec> (以下の例のような)を @samp{git push origin} のデフォルトとして設定できます。

@item  @samp{git push origin :} 
「マッチする」ブランチを @samp{origin} にプッシュします。 「マッチする」ブランチの説明については、上記 OPTIONS (@pxref{[OPTIONS]}) セクションの <refspec> を参照してください。

@item  @samp{git push origin master} 
ソースリポジトリで @samp{master} に一致するrefを探し(ほとんどの場合 @samp{refs/heads/master} を探し)、 @samp{origin} リポジトリで同一ref(例: @samp{refs/heads/master})を更新します。 @samp{master} がリモートに存在しなかった場合は作成されます。

@item  @samp{git push origin HEAD} 
現在のブランチをリモートの同一の名前にプッシュする便利な方法。

@item  @samp{git push mothership master:satellite/master dev:satellite/dev} 
@samp{master} と一致するソースref(例: @samp{refs/heads/master})を使用して、 @samp{mothership} リポジトリ内の @samp{satellite/master}(おそらく @samp{refs/remotes/satellite/master})と一致するrefを更新します。 @samp{dev} と @samp{satellite/dev} についても同様にします。

マッチングのセマンティクスの説明については、 上記「<refspec>…」について説明しているセクションを参照してください。

これは、 @samp{mothership} で実行される @samp{git fetch} を、 @samp{satellite} での作業を統合するために逆方向に実行される @samp{git push} でエミュレートするもので、一方通行でしか接続できないときによく必要になります(つまり、 @samp{satellite} はsshで @samp{mothership} に入ることができますが、 @samp{satellite} がファイアウォールの背後にあるか、sshdを実行していないため、 @samp{mothership} は `satellite`への接続を開始できません)。

この @samp{git push} を @samp{satellite} のマシンで実行した後、 @samp{mothership} に ssh して @samp{git merge} を実行すれば、@samp{satellite} で行われた変更を @samp{git pull} でプルするエミュレーションが完成します。

@item  @samp{git push origin HEAD:master} 
現在のブランチを、 @samp{origin} リポジトリ内の @samp{master} に一致するリモートrefにプッシュします。 この形式は、ローカル名を気にせずに現在のブランチをプッシュするのに便利です。

@item  @samp{git push origin master:refs/heads/experimental} 
現在の @samp{master} ブランチをコピーして、 @samp{origin} リポジトリにブランチ @samp{experimental} を作成します。 これは、ローカル名とリモート名が異なる場合に、リモートリポジトリに新しいブランチまたはタグを作成する時のみ必要な形式です。 それ以外の場合は、ref名自体で機能します。

@item  @samp{git push origin :experimental} 
@samp{origin} リポジトリで @samp{experimental} に一致するref(たとえば @samp{refs/heads/experimental})を見つけて削除します。

@item  @samp{git push origin +dev:master} 
origin リポジトリのmasterブランチをdevブランチで更新し、早送り以外の更新(non-fast-forward updates)を可能にします。「これにより、参照されていないコミットがoriginリポジトリにぶら下がる可能性があります。」 早送りが(fast-forward)不可能な以下の状況を考慮してください:

@example
            o---o---o---A---B  origin/master
                     \
                      X---Y---Z  dev
@end example


上記コマンドは、originリポジトリを以下のように変更します

@example
                      A---B  (unnamed branch)
                     /
            o---o---o---X---Y---Z  master
@end example


コミットAとBは、もはやシンボリック名のブランチに属さなくなるため、到達不能になります。 そのため、これらのコミットは、originリポジトリの @samp{git gc} コマンドによって削除されます。
@end table

@noindent

@chapheading SECURITY

フェッチおよびプッシュプロトコルは、共有することを意図していない一方の側が他方のリポジトリからデータを盗むのを防ぐようには設計されていません。悪意のある者から保護する必要のあるプライベートデータがある場合、最善のオプションはそれを別のリポジトリに保存することです。これは、クライアントとサーバーの両方に適用されます。特に、サーバー上の名前空間は、読み取りアクセス制御には効果的ではありません。リポジトリ全体への読み取りアクセスで信頼できるクライアントにのみ、名前空間への読み取りアクセスを許可する必要があります。

既知の攻撃ベクトル(attack vectors)は以下のとおりです:

@enumerate 

@item
被害者は、明示的に共有することを意図していないオブジェクトのIDをアドバタイズする "have" 行を送信しますが、他にもIDを持っている者が居る場合は、転送を最適化するために使用できます。攻撃者はオブジェクトID Xを選択して盗み、refをXに送信しますが、被害者はすでにXのコンテンツを持っているため、Xのコンテンツを送信する必要はありません。 これで、被害者は攻撃者がXを持っていると信じ、Xのコンテンツを後で攻撃者に送り返します。 (この攻撃は、クライアントがアクセスできる名前空間にXへのrefを作成してフェッチすることにより、クライアントがサーバー上で実行するのが最も簡単です。サーバーがクライアント上で実行する最も可能性の高い方法は、Xをパブリックブランチにマージし、ユーザーがこのブランチで追加の作業を行い、マージに気付かずにサーバーにプッシュバックすることを期待します。)

@item
#1 と同様に、攻撃者は盗むオブジェクトID Xを選択します。被害者は、攻撃者がすでに持っているオブジェクトYを送信し、攻撃者はYではなくXを持っていると誤って主張するため、被害者はYをXに対するデルタとして送信します。デルタは、攻撃者にYに類似したXの領域を明らかにします。
@end enumerate

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  push.autoSetupRemote 
@samp{true} に設定すると、現在のブランチの上流追跡(upstream tracking)が存在しない場合、デフォルトのpushで @samp{--set-upstream} を想定します。 このオプションは、 push.default オプションの @samp{simple} や @samp{upstream} や @samp{current} で有効になります。 (@samp{push.default=current} の振る舞いのように、)デフォルトで新しいブランチをデフォルトのremoteにプッシュしたい場合に便利で、これは、あなたが上流追跡(upstream tracking)も設定したい場合にも便利です。 このオプションの恩恵を受ける可能性が最も高いワークフローは、すべてのブランチがremoteで同じ名前を持つことが期待される「単純な」中央ワークフローです。

@item  push.default 
(コマンドライン、構成、またはその他の場所で、)refspecが指定されていない場合に @samp{git push} が実行するアクションを定義します。 特定の作業フローに適するさまざまな値があります。 たとえば、純粋に中央のワークフロー(つまり、フェッチ元がプッシュ先と等しい)では、 @samp{upstream} がおそらく必要なものです。 可能な値は以下のとおりです:

@itemize 

@item
@samp{nothing} - refspecが指定されていない限り、何もプッシュ(エラー出力)しないでください。 これは主に、常に明示的にすることで間違いを避けたい人を対象としています。

@item
@samp{current} - 現在のブランチをプッシュして、受信側で同一の名前のブランチを更新します。 中央作業フローと非中央作業フローの両方で機能します。

@item
@samp{upstream} - 現在のブランチを、通常その変更が現在のブランチに統合されるブランチにプッシュバックします(これを @samp{@@@{upstream@}} と呼びます)。 このモードは、通常プルするのと同じリポジトリ(つまり中央ワークフロー)にプッシュする場合にのみ意味があります。

@item
@samp{tracking} - これは @samp{upstream} の非推奨の同義語です。

@item
@samp{simple} - リモートで同一の名前の現在のブランチをプッシュします。

あなたが一元化された作業フロー(あなたのプル元の同一のリポジトリにプッシュする、通常は @samp{origin} )で作業している場合は、あなたは同一の名前でアップストリームブランチを構成する必要があります。

このモードはGit2.0以降のデフォルトであり、初心者に適した最も安全なオプションです。

@item
@samp{matching} - 送信側受信側両方で同一の名前のすべてのブランチをプッシュします。 これにより、プッシュするリポジトリは、プッシュされるブランチのセットを記憶するようになります(たとえば、常に「maint」と「master」をプッシュし、他のブランチがない場合、プッシュするリポジトリには、これら2つのブランチがあり、ローカルの「maint」と「master」がそこにプッシュされます)。

このモードを効果的に使用するには、 @samp{git push} を実行する前に、あなたがプッシュしたい「すべてのブランチ」がプッシュされる準備ができていることを確認する必要があります。このモードの要点は、すべてのブランチを一度にプッシュできるようにすることです。通常、1つのブランチのみで作業を終了して結果をプッシュする場合、他のブランチは未完了ですので、このモードは適していません。 また、このモードは、共有中央リポジトリにプッシュするのには適していません。他の人がそこに新しいブランチを追加したり、コントロール外の既存のブランチの先端を更新したりする可能性があるためです。

これは以前はデフォルトでしたが、Git 2.0以降ではそうではありません(@samp{simple} が新しいデフォルトです)。
@end itemize

@item  push.followTags 
trueに設定されている場合、デフォルトで @samp{--follow-tags} オプションを有効にします。 @samp{--no-follow-tags} を指定することにより、プッシュ時にこの構成をオーバーライドできます。

@item  push.gpgSign 
ブール値、または文字列 @samp{if-asked} に設定できます。 true値を指定すると、 @samp{--signed} linkgit:git-push [1]に渡されたかのように、すべてのプッシュがGPG署名されます。 文字列 @samp{if-asked} を指定し、サーバーがサポートしている場合は、 @samp{--signed=if-asked} が @samp{git push} に渡されたかのように、プッシュで署名されます。 誤った値は、優先度の低い構成ファイルの値を上書きする可能性があります。 明示的なコマンドラインオプションは、常にこの設定オプションを上書きします。

@item  push.pushOption 
コマンドラインから @samp{--push-option=<option>} 引数が指定されていない場合、 @samp{git push} はこの変数の各<value> が @samp{--push-option=<value>} として指定されているかのように動作します。

これは複数値の変数であり、優先度の高い構成ファイル(リポジトリ内の @samp{.git/config} など)で空の値を使用して、優先度の低い構成ファイル(@samp{$HOME/.gitconfig} など)から継承された値をクリアできます。

@example
Example:

/etc/gitconfig
  push.pushoption = a
  push.pushoption = b

~/.gitconfig
  push.pushoption = c

repo/.git/config
  push.pushoption =
  push.pushoption = b

This will result in only b (a and c are cleared).
@end example


@item  push.recurseSubmodules 
May be "check", "on-demand", "only", or "no", with the same behavior as that of "push --recurse-submodules". If not set, @emph{no} is used by default, unless @emph{submodule.recurse} is set (in which case a @emph{true} value means @emph{on-demand}).

@item  push.useForceIfIncludes 
「true」に設定すると、コマンドラインで git-push(1) のオプションとして @samp{--force-if-includes} を指定するのと同じです。 プッシュ時に @samp{--no-force-if-includes} を追加すると、この構成設定が上書きされます。

@item  push.negotiate 
「true」に設定されている場合は、クライアントとサーバーが共通のコミットを見つけようとするネゴシエーションの段階で送信されるパックファイルのサイズを縮小してみます。 「false」の場合、Gitはサーバーのref広告のみに依存して、共通のコミットを検索します。

@item  push.useBitmaps 
@samp{false} に設定すると、 @samp{pack.useBitmaps} が @samp{true} であっても @samp{git push} のビットマップの使用が無効になり、他の git 操作でのビットマップの使用が妨げられません。 デフォルトは @samp{true} です。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-quiltimport,,,Top
@chapheading Name

git-quiltimport — quilt(キルト)パッチセットを現在のブランチに適用します

@noindent

@chapheading Synopsis

@display
git quiltimport [--dry-run | -n] [--author <author>] [--patches <dir>]
                [--series <file>] [--keep-non-patch]
@end display


@noindent

@chapheading DESCRIPTION

quiltパッチセットを現在のGitブランチに適用し、quiltパッチセットに存在するパッチ境界、パッチ順序、およびパッチの説明を保持します。

パッチごとに、コードはパッチの説明から作者を抽出しようとします。それが失敗した場合は、 @samp{--author} で指定された作者にフォールバックします。 @samp{--author} フラグが指定されていない場合、パッチの説明が表示され、ユーザーはパッチの作者をインタラクティブに入力するように求められます。

パッチの説明に件名が見つからない場合、パッチ名はGitの説明の1行の件名として保持されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
一連(series)のパッチをウォークスルーし、パッチをコミットするために必要なすべての情報が見つからない場合は警告します。この記事の執筆時点では、欠落している作者情報のみを警告します。

@item  @samp{--author Author Name <Author Email>} 
パッチの説明に作者情報が見つからない場合に使用する作者名と電子メールアドレス。

@item  @samp{--patches <dir>} 
quiltパッチを見つけるためのディレクトリ。

パッチディレクトリのデフォルトは、 patches または @samp{$QUILT_PATCHES} 環境変数の値です。

@item  @samp{--series <file>} 
キルトシリーズファイル(quilt series file)。

シリーズファイルのデフォルトは、 <patches>/series または @samp{$QUILT_SERIES} 環境変数の値です。

@item  @samp{--keep-non-patch} 
@samp{-b} フラグを @emph{git mailinfo} に渡します(git-mailinfo(1) 参照)。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-range-diff,,,Top
@chapheading Name

git-range-diff — 2つのコミット範囲(例: ブランチの2つのバージョン)を比較します

@noindent

@chapheading Synopsis

@display
git range-diff [--color=[<when>]] [--no-color] [<diff-options>]
        [--no-dual-color] [--creation-factor=<factor>]
        [--left-only | --right-only]
        ( <range1> <range2> | <rev1>…<rev2> | <base> <rev1> <rev2> )
        [[--] <path>…]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、パッチシリーズの2つのバージョン、またはより一般的には2つのコミット範囲(マージコミットは無視)の違いを表示します。

@samp{<path>} 引数が存在する場合、これらのコミット範囲はそれに応じて制限されます。

そのために、最初に、互いに対応する両方のコミット範囲からコミットのペアを見つけます。 2つのコミットは、パッチ間の差分(つまり、作者情報、コミットメッセージ、およびコミット差分)がパッチのサイズと比較して適度に小さい場合に一致していると言われます。 詳細については、下記「Algorithm」を参照してください。

最後に、一致するコミットのリストが2番目のコミット範囲の順序で表示され、すべての祖先が表示された直後に一致しないコミットが挿入されます。

コミット範囲を指定するには、以下の3つの方法があります:

@itemize 

@item
@samp{<range1> <range2>} : どちらのコミット範囲も @samp{<base>..<rev>} または @samp{<rev>^!} または @samp{<rev>^-<n>} 形式にすることができます。 詳細については、 gitrevisions(7)の「SPECIFYING RANGES」を参照してください。

@item
@samp{<rev1>...<rev2>} : これは、 @samp{<rev2>..<rev1> <rev1>..<rev2>} と同じです。

@item
@samp{<base> <rev1> <rev2>} : これは @samp{<base>..<rev1> <base>..<rev2>} と同じです。
@end itemize

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--no-dual-color} 
コミットdiffが異なる場合、 @samp{git range-diff} は元の差分の色付けを再現し、例えば、追加された正確な行に変更があったとき、背景が 赤/緑 である外側の -/+ 差分マーカーを追加して見やすくします。

さらに、最初のコミット範囲にのみ存在するコミット差分行は「薄暗く」(dimmed)表示され(これは、 @samp{color.diff.<slot>} 構成設定を使用してオーバーライドできます。ここで、 @samp{<slot>} は @samp{contextDimmed} と @samp{oldDimmed} と @samp{newDimmed} のうちの1つです)、2番目のコミット範囲にのみ存在するコミット差分行は太字(bold)で示されています(これは、構成設定 @samp{color.diff.<slot>} を使用してオーバーライドできます。@samp{<slot>} は @samp{contextBold} または @samp{oldBold} または @samp{newBold} のいずれかです)。

これは @samp{range-diff} のための「dual coloring」として知られています。 @samp{--no-dual-color} を使用すると、外側のdiffマーカーに従ってすべての行の色を反転します(色に関しては内側のdiffを完全に無視します)。

@item  @samp{--creation-factor=<percent>} 
作成/削除 コストのファッジ係数を @samp{<percent>} に設定します。 デフォルトは60です。 @samp{git range-diff} が誤って大きな変更を全体の書き換え(1つのコミットの削除と別のコミットの追加)と見なす場合は大きな値を試し、逆の場合は小さな値を試してください。 これが必要な理由の説明については、下記「Algorithm」セクションを参照してください。

@item  @samp{--left-only} 
最初に指定された範囲(または @samp{<rev1>...<rev2>} 形式を使用する場合は「左範囲」(left range)）から欠落しているコミットを隠し(suppress)ます。

@item  @samp{--right-only} 
2番目に指定された範囲(または @samp{<rev1>...<rev2>} 形式を使用する場合は「右範囲」(right range)）から欠落しているコミットを隠し(supprss)ます。

@item  @samp{--[no-]notes[=<ref>]} 
このフラグは、パッチを生成する @samp{git log} プログラム(git-log(1) 参照)に渡されます。

@item  <range1> <range2> 
2つの範囲で指定されたコミットを比較します。ここで、 @samp{<range1>} は @samp{<range2>} の古いバージョンと見なされます。

@item  <rev1>…<rev2> 
@samp{<rev2>..<rev1>} と @samp{<rev1>..<rev2>} を渡すのと同じです。

@item  <base> <rev1> <rev2> 
@samp{<base>..<rev1>} と @samp{<base>..<rev2>} を渡すのと同じです。 @samp{<base>} は分岐の正確な分岐点である必要はないことに注意してください。 例: ブランチ @samp{my-topic} をリベースした後、 @samp{git range-diff my-topic@@@{u@} my-topic@@@{1@} my-topic} は、リベースによって導入された違いを示します。
@end table

@samp{git range-diff} は、通常のdiffオプション(git-diff(1) 参照)、特に @samp{--color=[<when>]} および @samp{--no-color} オプションも受け入れます。 これらのオプションは、「パッチ間の差分」を生成するときに使用されます。つまり、作者、コミットメッセージ、および対応する 古い/新しい コミットの差分を比較します。 現在、これらのパッチを生成するときに @samp{git log} に渡されるdiffオプションのほとんどは微調整する手段がありません。

@noindent

@chapheading OUTPUT STABILITY

@samp{range-diff} コマンドの出力は変更される可能性があります。 これは人間が読める磁器コマンドの出力であり、Gitのバージョン間でテキスト的に安定した @samp{range-diff} を取得するために使用できるものではありません(git-patch-id(1) の @samp{--stable} オプションのようなものとは対照的です)。 @samp{range-diff} には git-apply(1) に相当するものもありません。出力は、プログラムで読み取ること(machine-readable)は意図されていません。

これは特に diff オプションを渡すときに当てはまります。現在、 @samp{--stat} のようないくつかのオプションは、 @samp{range-diff} のコンテキストでは全く役に立たない出力を生成することがあります。将来のバージョンの @samp{range-diff} では、このようなオプションを @samp{range-diff} 固有の方法で解釈するようになるかもしれません (例えば、 @samp{--stat} は diffstat がどのように変化したかをまとめた、人間が読めるような出力を生成します)。

@noindent

@chapheading CONFIGURATION

このコマンドは、 @samp{diff.color.*} および @samp{pager.range-diff} 設定を使用します(後者はデフォルトでオンになっています)。 git-config(1) を参照してください。

@noindent

@chapheading EXAMPLES

リベースでマージの競合を解決する必要がある場合は、以下のコマンドを使用して、リベースによって導入された変更をその直後に比較します:

@example
$ git range-diff @@@{u@} @@@{1@} @@
@end example


@samp{git range-diff} の典型的な出力は以下のようになります:

@example
-:  ------- > 1:  0ddba11 Prepare for the inevitable!
1:  c0debee = 2:  cab005e Add a helpful message at the start
2:  f00dbal ! 3:  decafe1 Describe a bug
    @@@@ -1,3 +1,3 @@@@
     Author: A U Thor <author@@example.com>

    -TODO: Describe a bug
    +Describe a bug
    @@@@ -324,5 +324,6
      This is expected.

    -+What is unexpected is that it will also crash.
    ++Unexpectedly, it also crashes. This is a bug, and the jury is
    ++still out there how to fix it best. See ticket #314 for details.

      Contact
3:  bedead < -:  ------- TO-UNDO
@end example


この例では、3つの古いコミットと3つの新しいコミットがあり、開発者は3番目を削除し、最初の2つの前に新しいコミットを追加し、2番目のコミットのコミットメッセージとその差分を変更しました。

出力が端末に送られるとき、通常の @samp{git diff} の出力と同じように、デフォルトで色分けされています。 さらに、最初の行(コミットの追加)は緑、最後の行(コミットの削除)は赤、2番目の行(完全一致)は @samp{git show} の出力のコミットヘッダーのように黄色で、 3行目は、古いコミットを赤、新しいコミットを緑、残りを @samp{git show} のコミットヘッダーのように色付けします。

ただし、単純な色分けされた「diffのdiff」は、行全体を赤または緑に色付けするため、実際には少し読みにくいです。 たとえば、古いコミットで「予期しないもの」を追加した行は、古いコミットの目的が何かを追加することであったとしても、完全に赤くなります。

これを助けるために、 @samp{range} はデフォルトで @samp{--dual-color} モードを使用します。 このモードでは、「diffのdiff」は元のdiffの色を保持し、行の前に「背景」が赤または緑の -/+ マーカーを付けて、diff自体がどのように変化したかをより明確にします。

@noindent

@chapheading Algorithm

一般的な考え方は次のとおりです: 両方のコミット範囲のコミット間にコストマトリックスを生成してから、最小コストの割り当てを解決します。

コストマトリックスはこのように入力されます: コミットのペアごとに、両方のdiffが生成され、3つのコンテキスト行で「diffのdiff」が生成され、そのdiffの行数がコストとして使用されます。

誤検知(たとえば、パッチが削除され、同じパッチシリーズの2つの反復の間に無関係のパッチが追加された場合)を回避するために、一括 削除/追加 の固定費エントリを追加することにより、コストマトリックスが拡張されて誤検知の回避が可能になります。

例: コミット @samp{1--2} をパッチシリーズの最初の反復とし、 @samp{A--C} を2番目の反復とします。 @samp{A} は @samp{2} のチェリーピックであり、 @samp{C} は @samp{1} のチェリーピックですが、わずかな変更(たとえば、タイプミス修正)があると仮定します。 コミットを二部グラフ(bipartite graph)として視覚化する:

@example
    1            A

    2            B

                 C
@end example


私たちは、新しい系列を古い系列の観点から「最適」に「説明」(explanation)することを求めています。「説明」はグラフの辺として表現することができます:

@example
    1            A
               /
    2 --------'  B

                 C
@end example


この「説明」(explanation)は、変更がなかったため、「無料」で提供されます。 同様に、 @samp{C} は @samp{1} を使用して「説明」できますが、変更のために「c>0」のコストがかかります:

@example
    1 ----.      A
          |    /
    2 ----+---'  B
          |
          `----- C
          c>0
@end example


数学的に言えば、私たちが探しているのは、ある種の最小コストの二部マッチング(bipartite matching)です。 @samp{1} は、いくらかのコストで @samp{C} と一致します。基礎となるグラフは、実際には完全2部グラフです。 すべてのエッジに関連するコストは、2つのコミットのパッチ間の差分のサイズです。 新しいコミットについても説明するために、両側にダミーノードを導入します:

@example
    1 ----.      A
          |    /
    2 ----+---'  B
          |
    o     `----- C
          c>0
    o            o

    o            o
@end example


エッジ @samp{o--C} のコストは、 @samp{C} の差分のサイズであり、100％未満である必要があるファッジ係数(fudge factor)によって変更されます。 エッジ @samp{o--o} のコストは無料です。 ファッジ係数が必要なのは、たとえ @samp{1} と @samp{C} に共通点がなくても、空行などがいくつか共有され、 @samp{1--C} 、 @samp{o--o} の代入が @samp{1--o} 、 @samp{o--C} よりもわずかにコストが安くなる可能性があるためです。ファッジ係数を使用すると、パッチを対応するものと見なすためには、はるかに大きな共通部分が必要になります。

このアルゴリズムの計算に必要な全体の時間は、パッチの、n+mコミットdiff と n*m diff の計算に必要な時間に加えて、nとmのdiff間の最小コストの割り当ての計算に必要な時間です。 Gitは、Jonker-Volgenantアルゴリズムの実装を使用して、実行時の複雑さが3次である割り当ての問題を解決します。 この場合に見つかった一致は以下のようになります:

@example
    1 ----.      A
          |    /
    2 ----+---'  B
       .--+-----'
    o -'  `----- C
          c>0
    o ---------- o

    o ---------- o
@end example


@noindent

@chapheading SEE ALSO

git-log(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-read-tree,,,Top
@chapheading Name

git-read-tree — ツリー情報をインデックスに読み込みます

@noindent

@chapheading Synopsis

@display
git read-tree [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)
                [-u | -i]] [--index-output=<file>] [--no-sparse-checkout]
                (--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])
@end display


@noindent

@chapheading DESCRIPTION

<tree-ish> によって指定されたツリー情報をインデックスに読み込みますが、「キャッシュする」ファイルは実際には「更新」されません。 (git-checkout-index(1) 参照)

オプションで、ツリーをインデックスにマージしたり、早送り(fast-forward)(つまり、2方向)マージを実行したり、 @samp{-m} フラグを使用して3方向マージを実行したりできます。 @samp{-u} フラグを @samp{-m} と一緒に使用すると、マージの結果で作業ツリー内のファイルも更新されます。

trivial(些細な)マージは、 @samp{git read-tree} 自体によって行われます。 @samp{git read-tree} から戻ると、競合するパスのみがマージされていない状態になります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-m} 
読み取りだけでなく、マージを実行します。インデックスファイルにマージされていないエントリがある場合、コマンドは実行を拒否します。これは、以前に開始したマージが完了していないことを示します。

@item  @samp{--reset} 
@samp{-m} と同じですが、マージされていないエントリが失敗する代わりに破棄される点が異なります。 @samp{-u} と一緒に使うと、作業ツリーの変更が失われる原因になる更新によって、または、追跡されていないファイルやディレクトリが失われる原因になる更新によって、操作を中止(abort)されることはありません。

@item  @samp{-u} 
マージが成功したら、マージの結果で作業ツリーのファイルを更新します。

@item  @samp{-i} 
通常、マージでは、ローカルの変更が失われないように、インデックスファイルと作業ツリー内のファイルが現在のヘッドコミットで最新である必要があります。 このフラグは、作業ツリーでのチェックを無効にし、現在の作業ツリーのステータスに直接関係しないツリーを一時的なインデックスファイルにマージするときに使用することを目的としています。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
作業ツリー内のインデックスまたはファイルを実際に更新せずに、コマンドがエラーになるかどうかを確認します。

@item  @samp{-v} 
ファイルのチェックアウトの進行状況を表示します。

@item  @samp{--trivial} 
trivial(些細な)ケースでマージ解決作業し、競合するファイルをインデックスに未解決のままにする代わりに、 @samp{git read-tree} による3方向マージを、ファイルレベルのマージが必要ない場合にのみ発生するように制限します。

@item  @samp{--aggressive} 
通常、 @samp{git read-tree} による3方向のマージは、本当にtrivial(些細な)ケースのマージを解決し、他のケースはインデックスに未解決のままにして、磁器コマンドがさまざまなマージポリシーを実装できるようにします。このフラグにより、コマンドはさらにいくつかのケースを内部的に解決します:

@itemize 

@item
一方の側がパスを削除し、もう一方の側がパスを変更しないままにする場合。 解決策は、そのパスを削除することです。

@item
両側でパスを削除したとき。 解決策は、そのパスを削除することです。

@item
両側で同じようにパスを追加する場合。 解決策は、そのパスを追加することです。
@end itemize

@item  @samp{--prefix=<prefix>} 
現在のインデックスの内容を保持し、 @samp{<prefix>} のディレクトリの下にある名前付きtree-ishの内容を読み取ります。このコマンドは、元のインデックスファイルにすでに存在しているエントリの上書きを拒否します。

@item  @samp{--index-output=<file>} 
結果を @samp{$GIT_INDEX_FILE} に書き出す代わりに、結果のインデックスを名前付きファイルに書き込みます。コマンドの動作中は、元のインデックスファイルが通常と同じメカニズムでロックされます。ファイルは、通常のインデックスファイルの隣に作成される一時ファイルから名前を変更できるようにする必要があります(rename(2))。通常、これは、インデックスファイル自体と同じファイルシステム上にある必要があり、インデックスファイルとインデックス出力ファイルが配置されているディレクトリへの書き込み権限が必要であることを意味します。

@item  @samp{--[no-]recurse-submodules} 
@samp{--recurse-submodules} を使用すると、スーパープロジェクトに記録されたコミットに従ってすべてのアクティブなサブモジュールのコンテンツが更新され、read-treeが再帰的に呼び出され、そのコミット時にサブモジュールのHEADが切り離される(detach)ように設定されます。

@item  @samp{--no-sparse-checkout} 
`core.sparseCheckout`がtrueの場合でも、スパースチェックアウト(sparse checkout)のサポートを無効にします。

@item  @samp{--empty} 
ツリーオブジェクトをインデックスに読み込む代わりに、空にします。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにし、フィードバックメッセージを抑制します。

@item  <tree-ish#> 
読み取られる/マージされる ツリーオブジェクトのID。
@end table

@noindent

@chapheading MERGING

@samp{-m} が指定されている場合、 @samp{git read-tree} は3種類のマージを提供します。1つのツリーのみが指定されている場合は単一のツリーマージ(single tree merge)、2つのツリーとの早送り(fast-forward)マージ(two tree merge)、3つ以上のツリーが指定されている3方向マージです(3-way merge)。

@noindent

@heading Single Tree Merge

ツリーが 1 つだけ指定されている場合、 @samp{git read-tree} はユーザーが @samp{-m} を指定しなかったかのように動作しますが、 元のインデックスに特定のパス名のエントリがあり、パスの内容が読み取られるツリーと一致する場合、インデックスの統計情報が使用されます。(言い換えれば、インデックスの stat() はマージされたツリーのものよりも優先されます)。

つまり、 @samp{git read-tree -m <newtree>} の後に @samp{git checkout-index -f -u -a} を実行すると、 @samp{git checkout-index} は本当に変更されたものだけをチェックアウトします。

これは、 @samp{git read-tree} の後に @samp{git diff-files} を実行したときに不要な誤検出を避けるために使用します。

@noindent

@heading Two Tree Merge

通常、これは @samp{git read-tree -m $H $M} として呼び出されます。ここで、$H は現在のリポジトリのヘッドコミットであり、$M は $H の前にある外部ツリーのヘッドです(つまり、早送り(fast-forward)の状況にあります)。

2つのツリーが指定されている場合、ユーザーは @samp{git read-tree} に以下のように指示している事になります:

@enumerate 

@item
現在のインデックスと作業ツリーは$Hから派生していますが、
ユーザーは$H以降にローカルで変更を加えている可能性があります。

@item
ユーザーは$Mに早送り(fast-forward)したいと考えています。
@end enumerate

この場合、 @samp{git read-tree -m $H $M} コマンドは、この「マージ」の結果としてローカルの変更が失われないことを確認します。 「繰越」(carry forward)ルールは次のとおりです。「I」はインデックスを示し、「clean」はインデックスと作業ツリーが一致することを意味し、「exists」/「nothing」 は指定されたコミットにパスが存在することを示します:

@example
        I                   H        M        Result
       -------------------------------------------------------
     0  nothing             nothing  nothing  (does not happen)
     1  nothing             nothing  exists   use M
     2  nothing             exists   nothing  remove path from index
     3  nothing             exists   exists,  use M if "initial checkout",
                                     H == M   keep index otherwise
                                     exists,  fail
                                     H != M

        clean I==H  I==M
       ------------------
     4  yes   N/A   N/A     nothing  nothing  keep index
     5  no    N/A   N/A     nothing  nothing  keep index

     6  yes   N/A   yes     nothing  exists   keep index
     7  no    N/A   yes     nothing  exists   keep index
     8  yes   N/A   no      nothing  exists   fail
     9  no    N/A   no      nothing  exists   fail

     10 yes   yes   N/A     exists   nothing  remove path from index
     11 no    yes   N/A     exists   nothing  fail
     12 yes   no    N/A     exists   nothing  fail
     13 no    no    N/A     exists   nothing  fail

        clean (H==M)
       ------
     14 yes                 exists   exists   keep index
     15 no                  exists   exists   keep index

        clean I==H  I==M (H!=M)
       ------------------
     16 yes   no    no      exists   exists   fail
     17 no    no    no      exists   exists   fail
     18 yes   no    yes     exists   exists   keep index
     19 no    no    yes     exists   exists   keep index
     20 yes   yes   no      exists   exists   use M
     21 no    yes   no      exists   exists   fail
@end example

すべての「インデックスを保持する」場合、インデックスエントリは元のインデックスファイルと同じままです。 エントリが最新でない場合、 @samp{git read-tree} は @samp{-u} フラグの下で動作しているときに作業ツリー内のコピーをそのまま保持します。

When this form of @emph{git read-tree} returns successfully, you can see which of the "local changes" that you made were carried forward by running @samp{git diff-index --cached $M}. Note that this does not necessarily match what @samp{git diff-index --cached $H} would have produced before such a two tree merge. This is because of cases 18 and 19 — if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), @samp{git diff-index --cached $H} would have told you about the change before this merge, but it would not show in @samp{git diff-index --cached $M} output after the two-tree merge.

上記ケース3は少しトリッキーで、説明が必要です。 このルールの結果は、論理的には、ユーザーがパスの削除をステージングしてから新しいブランチに切り替えた場合に、パスを削除することです。 ただし、これにより最初のチェックアウトが行われないため、インデックスの内容が空の場合にのみM(新しいツリー)を使用するようにルールが変更されます。 それ以外の場合、パスの削除は、$Hと$Mが同じである限り保持されます。

@noindent

@heading 3-Way Merge

各「インデックス」エントリには、2ビット相当の「ステージ」状態があります。ステージ0は通常のステージであり、通常の使用で見られる唯一のステージです。

しかしながら、あなたが3つのツリーで @samp{git read-tree} を実行すると、「ステージ」は1から始まります。

これはあなたが以下のようにできることを意味します

@example
$ git read-tree -m <tree1> <tree2> <tree3>
@end example


そうすると、「stage1」にすべての<tree1>エントリ、「stage2」にすべての<tree2>エントリ、「stage3」にすべての<tree3>エントリを持つインデックスが作成されます。 別のブランチを現在のブランチにマージする場合、共通の祖先ツリーを<tree1>として、現在のブランチヘッドを<tree2>として、他のブランチヘッドを<tree3>として使用します。

さらに、 @samp{git read-tree} には、以下のような特殊なケースのロジックがあります。以下の状態ですべての点で一致するファイルを見つけると、「折りたたみ」(collapse)して @samp{stage0} に戻します:

@itemize 

@item
ステージ2と3は同一です。 どちらか一方を取ります(違いはありません。ステージ2のブランチとステージ3のブランチで同じ作業が行われました)

@item
ステージ1とステージ2は同じで、ステージ3は異なります。ステージ3を取得します（ステージ2のブランチは、ステージ3のブランチが作業している間、ステージ1の祖先以降何もしませんでした）

@item
ステージ1とステージ3は同じで、ステージ2は異なります。ステージ2を使用します(私達は何もしなかったのに何かをしました)
@end itemize

@samp{git write-tree} コマンドは、無意味なツリーの書き込みを拒否し、ステージ0ではない単一のエントリを検出すると、マージされていないエントリについて文句を言います。

ええ、これはすべてまったく無意味なルールのコレクションのように聞こえますが、実際には、高速マージを実行するために必要なものです。 異なるステージは、「結果ツリー」(result tree)(ステージ0、別名「merged」)、元のツリー(original tree)(ステージ1、別名「orig」）、およびマージしようとしている2つのツリー（それぞれステージ2と3）を表します。

すでに入力されているインデックスファイルを使用して3方向マージを開始する場合、ステージ1、2、および3の順序(つまり、3つの<tree-ish>コマンドライン引数の順序)は重要です。アルゴリズムの仕組みの概要は以下のとおりです:

@itemize 

@item
ファイルが3つのツリーすべてに同じ形式で存在する場合、ファイルは @samp{git read-tree} によって自動的に「マージされた」状態(merged state)に折りたたまれ(collapse)ます。

@item
3つのツリーに違いがあるファイルは、インデックス内の別々のエントリとして残ります。0以外のステージを削除し、マージされたバージョンを挿入する方法を決定するのは、「磁器ポリシー」(porcelain policy)次第です。

@item
インデックスファイルはこれらすべての情報を保存および復元するため、段階的にマージできますが、ステージ 1/2/3 のエントリ(つまり、「マージされていないエントリ」)がある限り、結果を書き込むことはできません。したがって、マージアルゴリズムは非常に単純になります:

@itemize 

@item
あなたはインデックスを順番に歩きます。ステージ0のすべてのエントリはすでに完了しているため、無視します。

@item
「stage1」が見つかったが、一致する「stage2」または「stage3」がない場合は、両方のツリーから削除されたことがわかり(元のツリーにのみ存在した)、そのエントリを削除します。

@item
一致する「stage2」および「stage3」ツリーが見つかった場合は、それらの1つを削除し、もう1つを「stage0」エントリに変換します。 一致する「stage1」エントリも存在する場合は削除します。 .. すべての通常のtrivial(些細な)ルール ..
@end itemize
@end itemize

この最後のステップを実行するには、通常、提供された @samp{git merge-one-file} とともに @samp{git merge-index} を使用します。 スクリプトは、各パスをマージし、マージが正常に終了すると、作業ツリー内のファイルを更新します。

すでに入力されているインデックスファイルを使用して3方向マージを開始すると、それが作業ツリー内のファイルの状態を表していると見なされ、変更がインデックスファイルに記録されていないファイルを作成することもできます。 さらに、この状態はステージ2ツリーから「派生」していると想定されます。 元のインデックスファイルでステージ2と一致しないエントリが見つかった場合、3方向マージは実行を拒否します。

これは、進行中の変更が失われたり、無関係なマージコミットでランダムな変更が混在したりするのを防ぐために行われます。ここでは説明のために、あなたのリポジトリに最後にコミットされたものから開始するとします:

@example
$ JC=`git rev-parse --verify "HEAD^0"`
$ git checkout-index -f -u -a $JC
@end example


あなたは @samp{git update-index} を実行せずに、ランダムに編集します。 そして、あなたは彼(him)からpullしてからあなたの「上流」のツリーの先端が進んだことに気づきます:

@example
$ git fetch git://.... linus
$ LT=`git rev-parse FETCH_HEAD`
@end example


作業ツリーはまだHEAD($JC)に基づいていますが、あなたはそれ以降、いくつか編集しています。3方向マージは、 $JC 以降にインデックスエントリを追加または変更していないことを確認し、追加していない場合は、正しいことを行います。 したがって、以下のシーケンス:

@example
$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT
$ git merge-index git-merge-one-file -a
$ echo "Merge with Linus" | \
  git commit-tree `git write-tree` -p $JC -p $LT
@end example


これは、コミットするのは、進行中の作業を変更せずに$JCと$LTを純粋にマージすることであり、作業ツリーはマージの結果に更新されます。

ただし、このマージによって上書きされる作業ツリーにローカルの変更がある場合、変更が失われるのを防ぐために、 @samp{git read-tree} は実行を拒否します。

つまり、作業ツリーにのみ存在するものについて心配する必要はありません。 マージに関係しないプロジェクトの一部にローカルの変更がある場合、変更はマージに干渉せず、そのまま保持されます。 それらが干渉する場合、マージは開始されません(@samp{git read-tree} は大声で文句を言い、何も変更せずに失敗します)。 このような場合は、実行中の作業を続行し、作業ツリーの準備ができたら(つまり、進行中の作業が終了したら)、マージを再試行します。

@noindent

@chapheading SPARSE CHECKOUT

注意: git-update-index(1) と @samp{read-tree} の skip-worktree 機能は、git-sparse-checkout(1) の導入以前の機能です。 ユーザーは、 sparse-checkout/skip-worktree 関連の需要に対して、 これらの配管コマンドよりも優先して @samp{sparse-checkout} コマンドを使用することをお勧めします。 ただし、以下の情報は、@samp{sparse-checkout} コマンドの非円錐(non-cone)モードで使用されるパターン・スタイルを理解しようとしているユーザーにとって役立つ場合があります。

「スパースチェックアウト」(Sparse checkout)を使用すると、作業ディレクトリにまばらに(sparsely)データを入力できます。 skip-worktreeビット(git-update-index(1) 参照)を使用して、作業ディレクトリ内のファイルを確認する価値があるかどうかをGitに通知します。

@samp{git read-tree} およびその他のマージベースコマンド(@samp{git merge} 、 @samp{git checkout} …)は、skip-worktreeビットマップと作業ディレクトリの更新を維持するのに役立ちます。@samp{$GIT_DIR/info/sparse-checkout} は、skip-worktree参照ビットマップを定義するために使用されます。 @samp{git read-tree} が作業ディレクトリを更新する必要がある場合、このファイルに基づいてインデックスのskip-worktreeビットをリセットします。これは、 @samp{.gitignore} ファイルと同じ構文を使用します。 エントリがこのファイルのパターンとマッチする場合、または、エントリが作業ツリーに存在するファイルに対応する場合、 skip-worktree はそのエントリに設定されません。 それ以外の場合は、skip-worktree が設定されます。

次に、新しいskip-worktree値を前の値と比較します。 skip-worktreeがsetからunsetに変わると、対応するファイルが追加されます。 unsetからsetに変わると、そのファイルは削除されます。

通常、 @samp{$GIT_DIR/info/sparse-checkout} はどのファイルが含まれているかを指定するために使用されますが、否定パターンを使用して、どのファイルが含まれていないかを指定することもできます。 たとえば、ファイル @samp{unwanted} を削除するには以下のようにします:

@example
/*
!unwanted
@end example


もう1つの注意が必要なのは、スパースチェックアウトが不要になったときに作業ディレクトリを完全に再設定することです。 skip-worktreeビットはまだインデックスにあり、作業ディレクトリはまだまばらに(sparsely)配置されているため、「スパースチェックアウト」を無効にすることはできません。 以下のように、作業ディレクトリに @samp{$GIT_DIR/info/sparse-checkout} ファイルの内容を再入力する必要があります:

@example
/*
@end example


その後、スパースチェックアウトを無効にできます。 @samp{git read-tree} および同様のコマンドでのスパースチェックアウトのサポートはデフォルトで無効になっています。 スパースチェックアウトをサポートするには、 @samp{core.sparseCheckout} をオンにする必要があります。

@noindent

@chapheading SEE ALSO

git-write-tree(1), git-ls-files(1), gitignore(5), git-sparse-checkout(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-rebase,,,Top
@chapheading Name

git-rebase — 別のベース先端の上にコミットを再適用します

@noindent

@chapheading Synopsis

@display
git rebase [-i | --interactive] [<options>] [--exec <cmd>]
        [--onto <newbase> | --keep-base] [<upstream> [<branch>]]
git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]
        --root [<branch>]
git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)
@end display


@noindent

@chapheading DESCRIPTION

@samp{<branch>} が指定されている場合、 「git rebase」は他の処理を行う前に自動で @samp{git switch <branch>} を実行します。それ以外の場合は、引き続き現在のブランチに滞在しています。

@samp{<upstream>} が指定されていない場合、 @samp{branch.<name>.remote} と @samp{branch.<name>.mergebranch} オプションで構成されたアップストリーム(詳細はgit-config(1) 参照) および @samp{--fork-point} オプションが想定されています。あなたが現在ブランチを一切使用していない場合、または、現在のブランチにアップストリームが構成されていない場合、リベースは中止(abort)されます。

現在のブランチでコミットによって行われたが、 @samp{<upstream>} に無いすべての変更は、一時領域(temporary area)に保存されます。 これは @samp{git log <upstream>..HEAD} で表示されるのと同じコミットのセットで、または @samp{--fork-point} がアクティブな場合 @samp{git log 'fork_point'..HEAD} で表示されるのと同じコミットのセットで、または @samp{--root} オプションが指定されている場合 @samp{git log HEAD} で表示されるのと同じコミットのセットです。

現在のブランチは @samp{<upstream>} にリセットされます。 または @samp{--onto} オプションが指定されている場合は @samp{<newbase>} にリセットされます。 これは、 @samp{git reset --hard <upstream>} (または @samp{<newbase>} )とまったく同じ効果があります。 @samp{ORIG_HEAD} は、リセット前にブランチの先端を指すように設定されています。

@quotation

@strong{Note}

@samp{ORIG_HEAD} is not guaranteed to still point to the previous branch tip at the end of the rebase if other commands that write that pseudo-ref (e.g. @samp{git reset}) are used during the rebase. The previous branch tip, however, is accessible using the reflog of the current branch (i.e. @samp{@@@{1@}}, see gitrevisions(7)).
@end quotation

以前に一時領域に保存されたコミットは、現在のブランチに1つずつ順番に再適用されます。注意: @samp{HEAD..<upstream>} でのコミットと同一のテキスト変更を導入する @samp{HEAD} でのコミットは省略されることに注意してください(つまり、異なるコミットメッセージまたはタイムスタンプで、アップストリームで既に受け入れ済のパッチはスキップされます)。

マージに失敗すると、このプロセスが完全には自動で行われなくなる事があります。あなたは、このようなマージの失敗を解決し、そして @samp{git rebase --continue} を実行する必要があります。 別のオプションとしては、 @samp{git rebase --skip} でマージの失敗を引き起こしたコミットをバイパスすることです。そして、元の @samp{<branch>} をチェックアウトし、@samp{.git/rebase-apply} 作業ファイルを削除するには、代わりにコマンド @samp{git rebase --abort} を使用します。

以下の履歴が存在し、現在のブランチが @samp{topic} であるとします:

@example
          A---B---C topic
         /
    D---E---F---G master
@end example


この時点で、以下のコマンドのいずれかを実行します:

@example
git rebase master
git rebase master topic
@end example

そうすると以下のようになります:

@example
                  A'--B'--C' topic
                 /
    D---E---F---G master
@end example


@strong{注意} : 後者の形式は、
@samp{git checkout topic} の後に @samp{git rebase master} が続く省略形です。
リベースが終了すると、チェックアウトされたブランチ(@samp{topic})のままになります。

(たとえば、アップストリームに適用されたパッチをメールで送信したため)アップストリームブランチにすでに行った変更が含まれている場合、そのコミットはスキップされ、警告が発行されます(@samp{merge} バックエンドが使用されている場合)。たとえば、以下の履歴で @samp{git rebase master} を実行します(@samp{A'} と @samp{A} は同じ変更セットを導入しますが、コミッター情報は異なります):

@example
          A---B---C topic
         /
    D---E---A'---F master
@end example


これの結果は以下のようになります:

@example
                   B'---C' topic
                  /
    D---E---A'---F master
@end example


これは、あるブランチに基づいてトピックブランチを別のブランチに移植し、 @samp{rebase --onto} を使用して、トピックブランチを後者のブランチからフォークしたふりをする方法です。

まず、「topic」がブランチ「next」に基づいているとしましょう。 たとえば「topic」で開発された機能は、「next」にあるいくつかの機能に依存しています。

@example
    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic
@end example


我々は @emph{topic} をブランチ @emph{master} からフォークさせたいのです。たとえば「topic」が依存する機能が、より安定した「master」ブランチにマージされたためです。 ツリーを以下のようにしたいわけです:

@example
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next
@end example


これは、以下のコマンドを使用して取得できます:

@example
git rebase --onto master next topic
@end example

@samp{--onto} オプションの別の例は、ブランチの一部をリベースすることです。 以下のような状況の場合:

@example
                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master
@end example


そして、以下のコマンドを実行します

@example
git rebase --onto master topicA topicB
@end example

そうすると結果は以下のようになります:

@example
                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master
@end example


これは、topicBがtopicAに依存していない場合に役立ちます。

コミットの範囲は、リベースで削除することもできます。以下の状況の場合:

@example
    E---F---G---H---I---J  topicA
@end example


そして、以下のコマンドを実行します

@example
git rebase --onto topicA~5 topicA~3 topicA
@end example

上記を実行すると、以下のようにコミットFとGが削除されます:

@example
    E---H'---I'---J'  topicA
@end example


これは、 F と G に何らかの欠陥がある場合、または、topicA の一部であってはならない場合に役立ちます。注意: @samp{--onto} と @samp{<upstream>} パラメーターの引数は、任意の有効なコミットっぽい何か(commit-ish)にすることができることに注意してください。

競合が発生した場合、 @samp{git rebase} は最初の問題のあるコミットで停止し、ツリーに競合マーカーを残します。 あなたは @samp{git diff} を使用して、マーカー(@samp{<<<<<<})を見つけ、編集して競合を解決できます。編集するファイルごとに、競合が解決されたことをGitに通知する必要があります。通常、これは以下の方法で行います

@example
git add <filename>
@end example

競合を手動で解決し、あなたが望んだ解決策でインデックスを更新した後、以下のコマンドでリベースプロセスを続行できます

@example
git rebase --continue
@end example

あるいは、以下のように @samp{git rebase} を元に戻す(undo)こともできます

@example
git rebase --abort
@end example

@noindent

@chapheading MODE OPTIONS

The options in this section cannot be used with any other option, including not with each other:

@table @asis

@item  @samp{--continue} 
マージの競合を解決した後、リベースプロセスを再開します。

@item  @samp{--skip} 
現在のパッチをスキップして、リベースプロセスを再開します。

@item  @samp{--abort} 
リベース操作を中止(abort)し、 @samp{HEAD} を元のブランチにリセットします。リベース操作の開始時に @samp{<branch>} が指定された場合、@samp{HEAD} は @samp{<branch>} にリセットされます。それ以外の場合、 @samp{HEAD} はリベース操作が開始されたときの位置にリセットされます。

@item  @samp{--quit} 
リベース操作を中止(abort)しますが、HEADは元のブランチにリセットされません。その結果、インデックスと作業ツリーも変更されません。 @samp{--autostash} を使用して一時的なstashエントリが作成された場合、それはstashリストに保存されます。

@item  @samp{--edit-todo} 
対話リベース中にToDoリストを編集します。

@item  @samp{--show-current-patch} 
対話的なリベース、または、競合のためにリベースが停止されたときに、現在のパッチを表示します。 これは @samp{git show REBASE_HEAD} と同等です。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--onto <newbase>} 
新しいコミットを作成する開始点を指定します。 @samp{--onto} オプションが指定されていない場合、開始点は @samp{<upstream>} です。これは、既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。

特別な場合として、マージベースが1つしかない場合は、あなたはAとBのマージベースのショートカットとして "A...B" を使用できます。最大でAとBのいずれかを省略できます。その場合、デフォルトでHEADになります。

@item  @samp{--keep-base} 
Set the starting point at which to create the new commits to the merge base of @samp{<upstream>} and @samp{<branch>}. Running @samp{git rebase --keep-base <upstream> <branch>} is equivalent to running @samp{git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>}.

This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is. As the base commit is unchanged this option implies @samp{--reapply-cherry-picks} to avoid losing commits.

このオプションと @samp{--fork-point} はどちらも @samp{<upstream>} と @samp{<branch>} の間のマージベースを検索します。しかし、このオプションは新しいコミットが作成される「開始点」としてマージベースを使用します。一方 @samp{--fork-point} はマージベースを使用して、リベースされる「コミットのセット」を決定します。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  <upstream> 
比較するアップストリームブランチ。既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。デフォルトは、現在のブランチ用に構成されたアップストリームです。

@item  <branch> 
作業するブランチ。デフォルトはHEADです。

@item  @samp{--apply} 
適用戦略(applying strategies)を使用してリベースします(内部で @samp{git-am} を呼び出します)。このオプションは、マージバックエンドがapplyのすべてを処理すると、将来的には動作しなくなる可能性があります。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--empty=@{drop,keep,ask@}} 
任意のアップストリームコミットの、開始時は空ではなく、かつ、クリーンでは無いチェリーピックであるが、(すでにアップストリームの変更のサブセットが含まれているため、)リベース後に空になるコミットを処理する方法。dropを使用すると、空になるコミットはドロップされます(これがデフォルトです)。keepを使用すると、そのようなコミットは保持されます。 ask を使用すると、空のコミットが適用されるとリベースが停止し、ドロップするか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます(@samp{--interactive} の指定を含んでいます)。@samp{--exec} などの他のオプションでは、 @samp{-i}/@samp{--interactive} が明示的に指定されていない限り、デフォルトのドロップが使用されます。

Note that commits which start empty are kept (unless @samp{--no-keep-empty} is specified), and commits which are clean cherry-picks (as determined by @samp{git log --cherry-mark ...}) are detected and dropped as a preliminary step (unless @samp{--reapply-cherry-picks} or @samp{--keep-base} is passed).

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--no-keep-empty} 
@itemx  @samp{--keep-empty} 
リベースの前に空で始まるコミット(つまり、親から何も変更していないコミット)を結果に残さないようにします。 なぜなら、そのようなコミットを作成するには @samp{git commit} に @samp{--allow-empty} というオーバーライドするフラグを渡す必要があり、これはユーザーが意図的にそのようなコミットを作成し、それを保持したいことを意味しているからです。

対話的なリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などの為の便利なショートカットとして存在します。

開始時は空でないが、リベース後に空になるコミットについては、 @samp{--empty} フラグを参照してください。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--reapply-cherry-picks} 
@itemx  @samp{--no-reapply-cherry-picks} 
我先にドロップしてしまうのではなく、アップストリームコミットのすべてのクリーンなチェリーピックを再適用します。 （これらのコミットがリベース後に空になった場合、それらにはすでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は `--empty`フラグによって制御されます。）

In the absence of @samp{--keep-base} (or if @samp{--no-reapply-cherry-picks} is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repositories with a large number of upstream commits that need to be read. When using the @emph{merge} backend, warnings will be issued for each dropped commit (unless @samp{--quiet} is given). Advice will also be issued unless @samp{advice.skippedCherryPicks} is set to false (see git-config(1)).

@samp{--reapply-cherry-picks} を使用すると、リベースはすべてのアップストリームコミットの読み取りを放棄できるため、パフォーマンスが向上する可能性があります。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--allow-empty-message} 
何も操作しません。空のメッセージでコミットをリベースすると失敗(fail)しますが、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできます。つまり、空のメッセージでコミットしても、リベースは停止(halt)しません。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{-m} 
@itemx  @samp{--merge} 
マージ戦略(merging strategies)を使用してリベースします(デフォルト)。

リベースマージは、<upstream>ブランチの上にある作業ブランチからの各コミットをリプレイすることによって機能することに注意してください。このため、マージの競合が発生した場合、 @samp{ours} として報告される側は、<upstream>で始まるこれまでのリベースされたシリーズであり、 @samp{theirs} は作業ブランチです。 つまり、サイドが入れ替わっています。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{-s <strategy>} 
@itemx  @samp{--strategy=<strategy>} 
デフォルトの @samp{ort} の代わりに、指定のマージ戦略を使用します。 このオプションは @samp{--merge} の指定を含んでいます。

@samp{git rebase} は、指定された戦略を使用して<upstream>ブランチの上にある作業ブランチからの各コミットをリプレイするため、 @samp{ours} 戦略を使用すると、<branch>からすべてのパッチが空になります。これはほとんど意味がありません。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{-X <strategy-option>} 
@itemx  @samp{--strategy-option=<strategy-option>} 
<strategy-option>をマージ戦略に渡します。 これは @samp{--merge} の指定を含んでいて、戦略が指定されていない場合は @samp{-s ort} を意味します。 @samp{-m} オプションにて上記で述べたように、「ours」と「theirs」が逆になっていることに注意してください。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--rerere-autoupdate} 
@itemx  @samp{--no-rerere-autoupdate} 
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 @samp{--no-rerere-autoupdate} は、別の @samp{git add} で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミットです。 @samp{keyid} 引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに串刺しする必要があります。 @samp{--no-gpg-sign} は、@samp{commit.gpgSign} 構成変数と、それより前で指定した @samp{--gpg-sign} オプションの、その両方を打ち消すのに役立ちます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。@samp{--no-stat} の指定を含みます。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
おしゃべりにします。 @samp{--stat} の指定を含みます。

@item  @samp{--stat} 
最後のリベース以降にアップストリームで変更されたもののdiffstatを表示します。 diffstatは、構成オプション rebase.stat によっても制御されます。

@item  @samp{-n} 
@itemx  @samp{--no-stat} 
リベース処理の一部としてdiffstatを表示しないでください。

@item  @samp{--no-verify} 
このオプションは、リベース前のフック(pre-rebase hook)をバイパスします。 githooks(5) も参照してください。

@item  @samp{--verify} 
リベース前フック(pre-rebase hook)の実行を許可します。これがデフォルトです。このオプションは、 @samp{--no-verify} をオーバーライドするために使用できます。 githooks(5) も参照してください。

@item  @samp{-C<n>} 
各変更の前後で、少なくとも <n> 行の周囲のコンテキストが一致することを確認する。 周囲の文脈の行数が少ない場合は、すべて一致させなければならない。 デフォルトでは、コンテキストは無視されます。 @samp{--apply} の指定を含んでいます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--no-ff} 
@itemx  @samp{--force-rebase} 
@itemx  @samp{-f} 
変更されていないコミットを早送りす(fast-forward)るのではなく、リベースされたすべてのコミットを個別にリプレイします。これにより、リベースされたブランチの履歴全体が新しいコミットで構成されることが保証されます。

トピックブランチのマージを取り消した後にこのオプションを使うと便利です。このオプションはトピックブランチを新しいコミットで再作成するので、「戻しを戻す」(revert the reversion)必要はありません (詳細は @uref{howto/revert-a-faulty-merge.html,revert-a-faulty-merge How-To} をご覧ください)。

@item  @samp{--fork-point} 
@itemx  @samp{--no-fork-point} 
<branch>によって導入されたコミットを計算するときに、reflogを使用して、<upstream>と<branch>の間の、より一般的な祖先を見つけます。

@samp{--fork-point} がアクティブな場合、<upstream>の代わりに @samp{fork_point} を使用して、リベースするコミットのセットを計算します。ここで、 @samp{fork_point} は、 @samp{git merge-base --fork-point <upstream> <branch>} コマンドの結果です（git-merge-base(1) 参照）。 @samp{fork_point} が空になると、<upstream>がフォールバックとして使用されます。

If @samp{<upstream>} or @samp{--keep-base} is given on the command line, then the default is @samp{--no-fork-point}, otherwise the default is @samp{--fork-point}. See also @samp{rebase.forkpoint} in git-config(1).

あなたのブランチが<upstream>に基づいていたが、<upstream>が巻き戻され、あなたのブランチにドロップされたコミットが含まれている場合、あなたのブランチからそれらのコミットをドロップするために、このオプションを @samp{--keep-base} とともに使用できます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--ignore-whitespace} 
差分を調整しようとするときは、空白の違いを無視してください。現在、各バックエンドはこの振る舞いの近似を実装しています:

@table @asis

@item  apply backend 
パッチを適用するときは、コンテキスト行の空白(whitespace)の変更を無視してください。残念ながら、これは、パッチによって置き換えられる「古い」行が既存のファイルと空白(whitespace)のみが異なる場合、パッチアプリケーションが成功する代わりに、マージの競合が発生することを意味します。

@item  merge backend 
空白(whitespace)のみが変更された行は、マージ時に変更されていないものとして扱います。残念ながら、これは、反対側に競合する変更がなかったとしても、空白(whitespace)を変更することを目的としたパッチハンクがドロップされることを意味します。
@end table

@item  @samp{--whitespace=<option>} 
このフラグは、パッチを適用する @samp{git apply} プログラム(git-apply(1) 参照)に渡されます。 @samp{--apply} の指定を含んでいます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--committer-date-is-author-date} 
現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。このオプションは、 @samp{--force-rebase} の指定を含んでいます。

@item  @samp{--ignore-date} 
@itemx  @samp{--reset-author-date} 
元のコミットの作成者の日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者の日付として使用します。 このオプションは、 @samp{--force-rebase} の指定を含んでいます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--signoff} 
すべてのリベースされたコミットに @samp{Signed-off-by} トレーラーを追加します。注意: @samp{--interactive} が指定されている場合、pick または edit または reword のマークが付けられたコミットのみにトレーラーが追加されることに注意してください。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{-i} 
@itemx  @samp{--interactive} 
リベースされようとしているコミットのリストを作成します。リベースする前に、ユーザーにそのリストを編集させます。このモードは、コミットの分割にも使用できます（以下の「SPLITTING COMMITS」を参照）。

コミットリストの書式は、構成オプション rebase.instructionFormat を設定することで変更できます。カスタマイズされた命令書式では、書式の前に長いコミットハッシュが自動的に追加されます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{-r} 
@itemx  @samp{--rebase-merges[=(rebase-cousins|no-rebase-cousins)]} 
@itemx  @samp{--no-rebase-merges} 
By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With @samp{--rebase-merges}, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually. @samp{--no-rebase-merges} can be used to countermand both the @samp{rebase.rebaseMerges} config option and a previous @samp{--rebase-merges}.

When rebasing merges, there are two modes: @samp{rebase-cousins} and @samp{no-rebase-cousins}. If the mode is not specified, it defaults to @samp{no-rebase-cousins}. In @samp{no-rebase-cousins} mode, commits which do not have @samp{<upstream>} as direct ancestor will keep their original branch point, i.e. commits that would be excluded by git-log(1)'s @samp{--ancestry-path} option will keep their original ancestry by default. In @samp{rebase-cousins} mode, such commits are instead rebased onto @samp{<upstream>} (or @samp{<onto>}, if specified).

現在、 @samp{ort} マージ戦略を使用してのみマージコミットを再作成することが可能です。異なるマージ戦略は、明示的な @samp{exec git merge -s <strategy> [...]} コマンドを介してのみ使用できます。

下記の「REBASING MERGES」と「INCOMPATIBLE OPTIONS」も参照してください。

@item  @samp{-x <cmd>} 
@itemx  @samp{--exec <cmd>} 
最終履歴にコミットを作成する各行の後に @samp{exec <cmd>} を追加します。 @samp{<cmd>} は、1つ以上のシェルコマンドとして解釈されます。 失敗したコマンドは、exit code 1でリベースを中断(interrupt)します。

@samp{--exec} の1つのインスタンスを複数のコマンドで使用することにより、複数のコマンドを実行できます:

@example
git rebase -i --exec "cmd1 && cmd2 && ..."
@end example

または、複数の @samp{--exec} を指定します:

@example
git rebase -i --exec "cmd1" --exec "cmd2" --exec ...
@end example

@samp{--autosquash} が使用されている場合、 @samp{exec} 行は中間コミットに追加されず、各 squash/fixup シリーズの最後にのみ現れます。

これは内部で @samp{--interactive} 機構を使用しますが、明示的な @samp{--interactive} の指定なしで実行できます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--root} 
Rebase all commits reachable from @samp{<branch>}, instead of limiting them with an @samp{<upstream>}. This allows you to rebase the root commit(s) on a branch.

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--autosquash} 
@itemx  @samp{--no-autosquash} 
コミットログメッセージが「squash! …」または「fixup! …」または「amend! …」で始まり、同一の @samp{...} に一致するコミットがすでにtodoリストにある場合、 @samp{rebase -i} のtodoリストを自動的に変更して、squashするようにマークされたコミットが、変更するコミットの直後に来るようにし、移動したコミットのアクションをそれぞれ @samp{pick} から、 @samp{squash} または @samp{fixup} または @samp{fixup-C} に変更します。 コミットの件名が一致する場合、または @samp{...} がコミットのハッシュを参照する場合、コミットは @samp{...} と一致します。フォールバックとして、コミットサブジェクトの部分一致も機能します。 fixup/amend/squash コミットを作成するための推奨される方法は、 git-commit(1) のそれぞれ @samp{--fixup} または @samp{--fixup=amend:} または @samp{--fixup=reword:} と、@samp{--squash} オプションを使用することです。

構成変数 @samp{rebase.autoSquash} を使用して @samp{--autosquash} オプションがデフォルトで有効になっている場合、このオプションを使用して、この設定をオーバーライドおよび無効にすることができます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。

@item  @samp{--autostash} 
@itemx  @samp{--no-autostash} 
操作を開始する前に一時的なスタッシュエントリを自動的に作成し、操作の終了後に適用します。これは、汚れたワークツリー(dirty worktree)でリベースを実行できることを意味します。ただし、注意して使用してください。リベース成功後のスタッシュ適用の際、重要な競合を引き起こす可能性があります。

@item  @samp{--reschedule-failed-exec} 
@itemx  @samp{--no-reschedule-failed-exec} 
失敗した @samp{exec} コマンドを自動的に再スケジュールします。 これは、対話モード(または @samp{--exec} オプションが提供された場合)でのみ意味があります。

このオプションは、リベースが開始されると適用されますが、これは、 @samp{rebase.rescheduleFailedExec} 構成(git-config(1) または 下記「CONFIGURATION」参照)、またはこのオプションが提供されているかどうかに基づいて、最初にリベース全体に設定されます。でなければ、開始時の明示的な @samp{--no-reschedule-failed-exec} が、 @samp{rebase.rescheduleFailedExec=true} 構成の存在によって上書きされます。

@item  @samp{--update-refs} 
@itemx  @samp{--no-update-refs} 
リベースされているコミットを指すブランチを自動的に強制更新します。 ワークツリーでチェックアウトされたブランチは、この方法では更新されません。

構成変数 @samp{rebase.updateRefs} が設定されている場合、このオプションを使用して、この設定をオーバーライドして無効にすることができます。

下記の「INCOMPATIBLE OPTIONS」(互換性のないオプション)も参照してください。
@end table

@noindent

@chapheading INCOMPATIBLE OPTIONS(互換性の無いオプション)

これらのオプション:

@itemize 

@item
@samp{--apply}

@item
@samp{--whitespace}

@item
@samp{-C}
@end itemize

は、以下のオプションと互換性がありません:

@itemize 

@item
@samp{--merge}

@item
@samp{--strategy}

@item
@samp{--strategy-option}

@item
@samp{--autosquash}

@item
@samp{--rebase-merges}

@item
@samp{--interactive}

@item
@samp{--exec}

@item
@samp{--no-keep-empty}

@item
@samp{--empty=}

@item
@samp{--[no-]reapply-cherry-picks} when used without @samp{--keep-base}

@item
@samp{--update-refs}

@item
@samp{--root} when used without @samp{--onto}
@end itemize

さらに、以下のオプションの組み合わせには互換性がありません:

@itemize 

@item
@samp{--keep-base} と @samp{--onto}

@item
@samp{--keep-base} と @samp{--root}

@item
@samp{--fork-point} と @samp{--root}
@end itemize

@noindent

@chapheading BEHAVIORAL DIFFERENCES(振る舞いの違い)

git rebaseには、 @samp{apply} と @samp{merge} の2つの主要バックエンドがあります。 (@samp{apply} バックエンドは以前は @samp{am} バックエンド と呼ばれていましたが、名詞ではなく動詞のように見えるため混乱を招きました。また、 @samp{merge} バックエンドは以前は @samp{interactive} バックエンドと呼ばれていましたが、現在は 非対話型の場合にも使用されます。どちらも、それぞれを支える低レベルの機能に基づいて名前が変更されました。）これら2つのバックエンドの振る舞いには微妙な違いがあります:

@noindent

@heading 空のコミット

@samp{apply} バックエンドは、残念ながら意図的に空のコミット、つまり空で開始されたコミットを削除しますが、これらは実際にはまれです。また、空になるコミットを削除したり、その振る舞いを制御するオプションがありません。

@samp{merge} バックエンドは、デフォルトで意図的に空のコミットを保持します(ただし、 @samp{-i} を使用すると、todoリストエディタでemptyとしてマークされます。または、 @samp{--no-keep-empty} を使用して自動的に削除できます)。

適用バックエンドと同様に、デフォルトでは、mergeバックエンドは、 @samp{-i}/@samp{--interactive} が指定されていない限り、空になるコミットをドロップします(この場合、mergeバックエンドは停止(stop)し、ユーザーに何をすべきかを尋ねます)。mergeバックエンドには、空になったコミットの処理動作を変更するための @samp{--empty=@{drop,keep,ask@}} オプションもあります。

@noindent

@heading ディレクトリ名変更の検知

正確なツリー情報が不足している(パッチで利用可能な限られた情報で偽の祖先を構築するために生じる)ため、 @samp{apply} バックエンドでディレクトリ名変更の検出が無効になっています。 ディレクトリ名前変更の検出が無効になっているということは、 履歴の一方がディレクトリの名前を変更し、 もう一方が古いディレクトリに新しいファイルを追加した場合に、 リベース時にこれらのファイルを新しいディレクトリに移動したいという警告なしに、 新しいファイルが古いディレクトリに残されます。

ディレクトリ名変更の検出は、 @samp{merge} バックエンドと連携して、このような場合に警告を出します。

@noindent

@heading Context

適用バックエンドは、（内部で @samp{format-patch} を呼び出すことにより、）パッチのシーケンスを作成し、次にパッチを順番に適用することにより（内部で @samp{am} を呼び出すことにより）機能します。パッチは複数のハンクで構成されており、それぞれに行番号、コンテキストリージョン、および実際の変更が含まれています。反対側がファイルの前に行を挿入または削除した可能性があるため、行番号はある程度曖昧にする必要があります。コンテキスト領域(context region)は、正しい行に変更を適用するために行番号を調整する方法を見つけるのに役立つことを目的としています。ただし、コードの複数の領域に同じ周囲のコンテキスト行がある場合、間違った領域が選択される可能性があります。これにより、競合が報告されずにコミットが誤って再適用される実際のケースがあります。 @samp{diff.context} をより大きな値に設定すると、このようなタイプの問題を防ぐことができますが、誤った競合の可能性が高くなります（適用するには、一致するコンテキストの行がより多く必要になるため）。

@samp{merge} バックエンドは、関連する各ファイルの完全なコピーを使って動作し、これらの種類の問題からファイルを保護します。

@noindent

@heading Labelling of conflicts markers

コンテンツの競合がある場合、マージ機構は、コンテンツが由来するコミットでそれぞれの側の競合マーカーに注釈を付けようとします。 @samp{apply} バックエンドは、リベースされたコミットとその親に関する元の情報を削除するため(代わりに、生成されたパッチの限られた情報に基づいて新しい偽のコミットを生成します)、それらのコミットを識別できません。 代わりに、コミットの要約にフォールバックする必要があります。また、 merge.conflictStyle が @samp{diff3} または @samp{zdiff3} に設定されている場合、 @samp{apply} バックエンドは「構築されたマージベース」を使用してマージベースのコンテンツにラベルを付けるため、マージベースのコミットに関する情報は一切提供されません。

@samp{merge} バックエンドは、履歴の両側で完全なコミットで動作するため、そのような制限はありません。

@noindent

@heading フック

@samp{apply} バックエンドは従来、コミット後フック(post-commit hook)を呼び出していませんでしたが、 @samp{merge} バックエンドは呼び出していました。 @samp{merge} バックエンドはその出力を黙らせましたが、いまだ両方ともチェックアウト後フック(post-checkout hook)を呼び出します。さらに、両方のバックエンドは、中間コミットや最終コミットではなく、リベースの開始点コミットでのみチェックアウト後フック(post-checkout hook)を呼び出します。いずれの場合も、これらのフックの呼び出しは、そう設計したのではなく、実装の偶然によるものでした(両方のバックエンドは元々シェルスクリプトとして実装されており、フックを呼び出す @samp{git checkout ` や `git commit} などの他のコマンドをたまたま呼び出していました)。どちらが正しいかは完全には明らかではありませんが、両方のバックエンドの動作は同じであるべきです。将来的には、リベースがこれらのフックのいずれかを呼び出すのを停止する可能性があります。

@noindent

@heading Interruptability(割り込み可能性)

@samp{apply} バックエンドには、タイミングの悪い割り込みによる安全上の問題があります。ユーザーが間違ったタイミングで Ctrl-C を押してリベースを中止しようとすると、リベースは、後続の @samp{git rebase --abort} で中止できない状態になる可能性があります。 @samp{merge} バックエンドには、同様の欠点は見られません。(詳細については、 @uref{https://lore.kernel.org/git/20200207132152.GC2868@@szeder.dev/,https://lore.kernel.org/git/20200207132152.GC2868@@szeder.dev/} を参照してください。)

@noindent

@heading Commit Rewording

リベース中に競合が発生すると、リベースが停止(stop)し、ユーザーに解決を求めます。 ユーザーは競合の解決中に注目すべき変更を加える必要がある場合があるため、競合が解決され、ユーザーが @samp{git rebase --continue} を実行した後、リベースはエディターを開き、ユーザーにコミットメッセージを更新するように依頼する必要があります。 @samp{merge} バックエンドはこれを行いますが、 @samp{apply} バックエンドは元のコミットメッセージを盲目的に適用します。

@noindent

@heading Miscellaneous differences

ほとんどの人がおそらく取るに足らないと考えるであろうが、完全性のために言及されているいくつかの振る舞いの違いがあります:

@itemize 

@item
Reflog: 2つのバックエンドは、reflogで行われた変更を説明するときに異なる表現を使用しますが、どちらも「リベース」という単語を使用します。

@item
進行状況、情報、エラーメッセージ について: 2つのバックエンドは、わずかに異なる進行状況と情報メッセージを提供します。また、applyバックエンドはエラーメッセージ（「Your files would be overwritten…」など）をstdoutに書き込み、mergeバックエンドはそれらをstderrに書き込みます。

@itemize 

@item
状態ディレクトリ: 2つのバックエンドは、 @samp{.git/} の下の異なるディレクトリに状態を保持します
@end itemize
@end itemize

@noindent

@chapheading MERGE STRATEGIES

マージ機構(@samp{git merge} と @samp{git pull} コマンド)では、バックエンドの「マージ戦略」を @samp{-s} オプションで選択することができます。 いくつかの戦略では、独自のオプションを指定することができます。これは、 @samp{git merge} や @samp{git pull} に @samp{-X<option>} 引数として渡すことができます。

@table @asis

@item  ort 
これは、1つのブランチをプルまたはマージするときのデフォルトのマージ戦略です。この戦略では、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。さらに、この戦略では、名前の変更を伴うマージを検出して処理できます。検出されたコピーは使用しません。このアルゴリズムの名前は "Ostensibly Recursive’s Twin" (表面上は再帰の双子)の頭文字を取ったものであり、以前のデフォルトのアルゴリズムである「recursive」の代わりとして作成されたという事実に由来しています。

@samp{ort} 戦略は、以下のオプションを取ることができます:

@table @asis

@item  ours 
このオプションは、「our」バージョンを優先することにより、競合するハンクをクリーンに自動解決するように強制します。 our側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリファイルの場合、内容全体がour側から取得されます。

これを「ours」マージ戦略と混同しないでください。この戦略では、他のツリーに何が含まれているのかさえまったく調べません。それは他のツリーが行ったすべてを破棄し、「our」履歴にはその中で起こったすべてが含まれていると宣言します。

@item  theirs 
これは「ours」の反対です。 「ours」とは異なり、このmergeオプションを混同する「theirs」マージ戦略はないことに注意してください。

@item  ignore-space-change 
@itemx  ignore-all-space 
@itemx  ignore-space-at-eol 
@itemx  ignore-cr-at-eol 
指示されたタイプの空白(whitespace)の変更を含む行を、3方向マージのために変更されていないものとして扱います。行に対する、他の変更と空白(whitespace)の変更との混合は、無視されません。 git-diff(1) の @samp{-b} と @samp{-w} と @samp{--ignore-space-at-eol} と @samp{--ignore-cr-at-eol} も参照してください。

@itemize 

@item
「their」バージョンが行に空白の変更のみを導入する場合、「our」バージョンが使用されます。

@item
「our」バージョンで空白の変更が導入されたが、「their」バージョンに大幅な変更が含まれている場合は、「their」バージョンが使用されます。

@item
それ以外の場合、マージは通常の方法で進行します。
@end itemize

@item  renormalize 
これにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインが実行されます。このオプションは、ブランチをさまざまなクリーンフィルターまたは行末正規化ルールとマージするときに使用することを目的としています。詳細については、 gitattributes(5) の「Merging branches with differing checkin/checkout attributes」(チェックイン/チェックアウト属性が異なるブランチのマージ)を参照してください。

@item  no-renormalize 
@samp{renormalize} オプションを無効にします。 これは、 @samp{merge.renormalize} 構成変数をオーバーライドします。

@item  find-renames[=<n>] 
名前変更(rename)の検出をオンにし、オプションで類似性のしきい値(similarity threshold)を設定します。これがデフォルトです。 これは、 @samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--find-renames} も参照してください。

@item  rename-threshold=<n> 
@samp{find-renames=<n>} の非推奨の同義語。

@item  subtree[=<path>] 
このオプションは「subtree」戦略をさらに発展させたもので、2つの木をマージする際に、どのようにずらせば互いにマッチするかを推測するものである。その代わり、指定されたパスは、2つの木の形が一致するように前置される(または、最初から取り除かれる)。
@end table

@item  recursive 
これは、3方向マージアルゴリズムを使用して2つのヘッドのみを解決できます。3方向マージに使用できる共通の祖先が複数ある場合は、共通の祖先のマージされたツリーを作成し、それを3方向のマージの参照ツリーとして使用します。 これにより、Linux 2.6カーネルの開発履歴から取得した実際のマージコミットで実行されたテストによって、誤ったマージを引き起こすことなく、マージの競合が少なくなることが報告されています。 さらに、これにより、名前変更を含むマージを検出して処理できます。 検出されたコピーは使用しません。 これは、Git v0.99.9k 〜 v2.33.0 まで、2つのヘッドを解決するためのデフォルトの戦略でした。

「recursive」(再帰的)戦略は「ort」と同じオプションを取る。 しかし、「ort」が無視する3つのオプション(上記には書かれていない)があり、 「recursive」戦略で有用となる可能性がある:

@table @asis

@item  patience 
@samp{diff-algorithm=patience} の非推奨の同義語。

@item  diff-algorithm=[patience|minimal|histogram|myers] 
マージ中に別の差分アルゴリズムを使用すると、重要でない一致行(異なる関数の中括弧など)が原因で発生するミスマージを回避できます。 git-diff(1) @samp{--diff-algorithm} も参照してください。注意: 特に、「ort」は @samp{diff-algorithm=histogram} を使用しますが、「recursive」はデフォルトで 「diff.algorithm」 設定を使う事に注意して下さい。

@item  no-renames 
名前変更(rename)の検出をオフにします。 これは、@samp{merge.renames} 構成変数をオーバーライドします。 git-diff(1) の @samp{--no-renames} も参照してください。
@end table

@item  resolve 
これは、3方向マージアルゴリズムを使用して、2つのヘッド（つまり、現在のブランチとプルした別のブランチ）のみを解決できます。 交差マージ(criss-cross merge)のあいまいさを注意深く検出しようとします。 名前の変更は処理しません。

@item  octopus 
これにより、3つ以上のヘッドを持つケースが解決されますが、手動解決が必要な複雑なマージの実行は拒否されます。これは主に、トピックの分岐ヘッドを纏めるために使用されることを意図しています。これは、複数のブランチをプルまたはマージする場合のデフォルトのマージ戦略です。

@item  ours 
これにより、任意の数のヘッドが解決されますが、結果として得られるマージのツリーは常に現在のブランチヘッドのツリーであり、他のすべてのブランチからのすべての変更を事実上無視します。 これは、サイドブランチの古い開発履歴に取って代わるために使用されることを意図しています。 これは、「recursive」マージ戦略の @samp{-Xours} オプションとは異なることに注意してください。

@item  subtree 
これは改造された「ort」戦略です。 ツリーAとBをマージするとき、BがAのサブツリーに対応する場合、同じレベルのツリーを読み取るのではなく、Bは最初にAのツリー構造に一致するように調整されます。 この調整は、共通の祖先ツリーに対しても行われます。
@end table

3方向マージ(デフォルトの「ort」を含む)を使用する戦略では、両方のブランチで変更が行われたが、後で一方のブランチで元に戻された場合、その変更はマージされた結果に表示されます。一部の人々は、この振る舞いを混乱させると感じています。これは、個々のコミットではなく、ヘッドとマージベースのみがマージの実行時に考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンに置き換えます。

@noindent

@chapheading NOTES

あなたは共有リポジトリで @samp{git rebase} を使用することの意味を理解する必要があります。下記「RECOVERING FROM UPSTREAM REBASE」も参照してください。

リベースを実行すると、最初にpre-rebaseフックが存在する場合はそれが実行されます。このフックを使用して、健全性チェックを実行し、適切でない場合はリベースを拒否できます。例については、テンプレートの pre-rebase hook スクリプトを参照してください。

完了すると、<branch>が現在のブランチになります。

@noindent

@chapheading INTERACTIVE MODE

対話的にリベースするということは、あなたがリベースされるコミットを編集する機会があることを意味します。コミットを並べ替えたり、削除したりできます(不良パッチやその他の不要なパッチを削除します)。

対話モードは、以下のタイプの作業フローを対象としています:

@enumerate 

@item
素晴らしいアイデアを思いついた

@item
コードをハックハック

@item
提出用のシリーズを準備

@item
送信
@end enumerate

ここで、 (2) は以下のいくつかの作業で構成されています

a) 普段

@enumerate 

@item
コミットに値する何かを終える

@item
コミットする
@end enumerate

b) 独立した修正

@enumerate 

@item
何かが機能しないことに気付く

@item
そいつを修正

@item
それをコミットする
@end enumerate

bの(2) で修正したコミットがパッチシリーズの中に深く埋もれているために、完全ではないコミットに戻せない(amend)ことがあります。これこそが対話型リベースの目的です。たくさんの "a" と "b" の後に、コミットを並べ替えたり編集したり、複数のコミットをひとつにまとめたりするために使用します。

そのまま保持したい最後のコミットから開始します:

@example
git rebase -i <after-this-commit>
@end example

エディターは、あなたの現在のブランチのすべてのコミット(マージコミットは無視)で起動されます。これは、指定のコミットの後に発生します。あなたは、このリストのコミットを心ゆくまで並べ替えたり、削除したりできます。そして、リストは多かれ少なかれ以下のようになります:

@example
pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...
@end example


1行説明は、純粋にあなたの備忘のためです。 @samp{git rebase} はそれらを参照せず、コミット名（この例では "deadbee" と "fa1afe1" ）を参照するため、名前を削除または編集しないでください。

コマンド「pick」をコマンド「edit」に置き換えることで、 @samp{git rebase} にそのコミットを適用した後に停止(stop)するように指示できます。これにより、あなたはファイルやコミットメッセージを編集し、コミットを修正(amend)して、リベースを続行できます。

リベースを中断するには(@samp{edit} コマンドと同様、ただし最初にコミットを選択せずに)、 @samp{break} コマンドを使用します。

あなたがコミットのコミットメッセージを編集したいだけの場合は、コマンド @samp{pick} をコマンド @samp{reword} に置き換えます。

コミットを削除するには、コマンド @samp{pick} を @samp{drop} に置き換えるか、あるいはマッチする行を削除します。

2つ以上のコミットを1つにまとめる場合は、2番目以降のコミットのコマンド pick を squash または fixup に置き換えます。コミットに異なる作者がいた場合、折りたたまれたコミットは最初のコミットの作者に帰属します。折りたたまれたコミットに対して推奨されるコミットメッセージは、最初のコミットのメッセージと squash コマンドで識別されるメッセージを連結したもので、 @samp{fixup -c} が使用されていない限り、fixupコマンドで識別されるコミットのメッセージは省略されます。@samp{fixup -c} が使用された場合、提案されたコミットメッセージは @samp{fixup -c} コミットのメッセージのみであり、エディタが開いてメッセージを編集できます。 @samp{fixup -c} コミットの内容(パッチ)は、折りたたまれたコミットに引き続き組み込まれます。 @samp{fixup -c} コミットが複数ある場合は、最後のコミットからのメッセージが使用されます。あなたは @samp{fixup -C} を使用して、エディターを開かないことを除いて @samp{fixup -c} と同じ動作をさせることもできます。

「git rebase」は、 pick が edit に置き換えられたとき、またはマージエラーのためにコマンドが失敗したときに停止(stop)します。 競合の編集や解決が完了したら、 あなたは @samp{git rebase --continue} で続行できます。

たとえば、最後の5つのコミットを並べ替えて、 HEAD~4 であったものが新しいHEADになるようにします。これを実現するには、以下のように「git rebase」を呼び出します:

@example
$ git rebase -i HEAD~5
@end example


そして、最初のパッチをリストの最後に移動します。

たとえば、あなたが以下のような履歴を持っているなら、マージコミットを再作成することをお勧めします:

@example
           X
            \
         A---M---B
        /
---o---O---P---Q
@end example


あなたは A から Q までのブランチをリベースしたいとします。現在のHEADが B であることを確認して、以下を実行します

@example
$ git rebase -i -r --onto Q O
@end example


コミットの並べ替えと編集は通常、テストされていない中間ステップを作成します。テストを実行するか、少なくとも「exec」コマンド(ショートカット「x」)を使用して履歴の中間ポイントで再コンパイルすることにより、履歴の編集で何も壊れていないことを確認することをお勧めします。これを行うには、以下のようなToDoリストを作成します:

@example
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...
@end example


コマンドが失敗すると（つまり、0以外のステータスで終了すると）、対話的リベースが停止(stop)し、あなたには問題を修正する機会が与えられます。あなたは @samp{git rebase --continue} で続行できます。

「exec」コマンドは、シェル(@samp{$SHELL} で指定されたもの、または @samp{$SHELL} が設定されていない場合はデフォルトのシェル)でコマンドを起動するため、シェル機能("cd"、">"、";" など)を使用できます。コマンドは、作業ツリーのルートから実行されます。

@example
$ git rebase -i --exec "make test"
@end example


このコマンドを使用すると、あなたは中間コミット(intermediate commits)がコンパイル可能であることを確認できます。ToDoリストは以下のようになります:

@example
pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test
@end example


@noindent

@chapheading SPLITTING COMMITS

対話モードでは、アクション「edit」でコミットをマークできます。 ただし、これは必ずしも「git rebase」がこの編集の結果が正確に1つのコミットであることを期待していることを意味するわけではありません。 実際、あなたはコミットを元に戻す(undo)ことも、他のコミットを追加することもできます。そしてこれは、コミットを2つに分割するために使用できます:

@itemize 

@item
@samp{git rebase -i <commit> ^} を使用して対話的リベースを開始します。ここで、<commit> はあなたが分割したいコミットです。 実際、そのコミットが含まれている限り、どんなコミット範囲でもかまいません。

@item
あなたが分割したいコミットを、 アクション @samp{edit} でマークします。

@item
そのコミットを編集する場合は、 @samp{git reset HEAD^} を実行します。 その効果は、HEADが1つ巻き戻され、インデックスがそれに追随することです。 ただし、作業ツリーは同じままです。

@item
次に、最初のコミットで必要な変更をインデックスに追加します。 これを行うには、 （おそらく対話的に）@samp{git add} を使うかまたは @emph{git gui} を使うか（、またはこの両方を使うか)できます。

@item
最新の適切なコミットメッセージを使用して、最新の「現在のインデックス」をコミットします。

@item
作業ツリーがクリーンになるまで、最後の2つの手順を繰り返します。

@item
@samp{git rebase --continue} でリベースを続行します。
@end itemize

あなたが中間リビジョンの一貫性(コンパイル、テストスイートの合格など)が完全には分からない場合は、「git stash」を使用して、各コミット後にまだコミットされていない変更を隠し、修正が必要な場合はコミットをテストして修正する必要があります。

@noindent

@chapheading RECOVERING FROM UPSTREAM REBASE

他の人がベースにしているブランチをリベースする (あるいは他の形で書き換える) のは悪い考えです。そのブランチの下流の人は、自分の履歴を手動で修正することを余儀なくされます。 このセクションでは、下流側の視点から見た修正の方法を説明します。 しかし、本当の意味での修正は、そもそも上流のリベースを行わないことです。

説明のために、誰かが「subsystem」ブランチを開発し、この「subsystem」に依存する「topic」に取り組んでいる状況にあると仮定します。たぶん以下のような履歴です:

@example
    o---o---o---o---o---o---o---o  master
         \
          o---o---o---o---o  subsystem
                           \
                            *---*---*  topic
@end example


@samp{subsystem} が @samp{master} に対してリベースされる場合、以下が発生します:

@example
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                           \
                            *---*---*  topic
@end example


これで、あなたは通常どおり開発を続行し、最終的に @samp{topic} を @samp{subsystem} にマージすると、 以下のように、 @samp{subsystem} からのコミットは永久に複製されたままになります:

@example
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                           \                         /
                            *---*---*-..........-*--*  topic
@end example


このような重複は、履歴が乱雑になり、追跡が困難になるため、一般的に眉をひそめられる行為です。これをクリーンアップするには、「topic」のコミットを新しい「subsystem」の先端に移植する必要があります。つまり、「topic」をリベースする必要があります。これは影響が波及します。「topic」の下流にいる人もリベースを余儀なくされます！

2種類の修正パターン(簡単な場合と難しい場合)があります。以下のサブセクションで議論します:

@table @asis

@item  簡単な場合: 変更は文字通り同じ(same) 
これは、 @samp{subsystem} のリベースが単純なリベースであり、競合がなかった場合に発生します。

@item  難しい場合: 変更は同じではありません 
これは、「subsystem」のリベースで競合が発生した場合、または @samp{--interactive} を使用してコミットを省略(omit)、edit、squash、fixupした場合に発生します。または、アップストリームで @samp{commit --amend} や、 @samp{reset} や、 @uref{https://github.com/newren/git-filter-repo,@samp{filter-repo}} のような完全な履歴書き換えコマンドのいずれかを使用した場合に発生します。
@end table

@noindent

@heading 簡単な場合

@samp{subsystem} の変更点(diffの内容に基づくパッチID)がリベース @samp{subsystem} の前と後で文字通り同じである場合にのみ動作します。

その場合、 @samp{git rebase} は新しいアップストリームにすでに存在する変更をスキップすることを知っているため、修正は簡単です(@samp{--reapply-cherry-picks} が指定されていない場合)。 だから(あなたが「topic」にいると仮定して、)あなたが以下のようにすれば、

@example
    $ git rebase subsystem
@end example


あなたは修正された履歴で終わります。

@example
    o---o---o---o---o---o---o---o  master
                                 \
                                  o'--o'--o'--o'--o'  subsystem
                                                   \
                                                    *---*---*  topic
@end example


@noindent

@heading 難しい場合

@samp{subsystem} の変更がリベース前の変更に正確に対応していない場合、事態はさらに複雑になります。

@quotation

@strong{Note}

「簡単な場合の回復」は、難しい場合でも成功するように見えることがありますが、
意図しない結果をもたらす可能性があります。
たとえば、 @samp{git rebase --interactive}
を介して削除されたコミットが「復活」します！
@end quotation

考え方としては、「git rebase」に「古いsubsystemが終了し、あなたのtopicを開始した場所」、つまり、それらの間の古いマージベースが何であったかを手動で伝えることです。 あなたは古いsubsystemの最後のコミットに名前を付ける方法を見つける必要があります。以下に例を示します:

@itemize 

@item
@samp{subsystem} reflogの場合: @samp{git fetch} 後、@samp{subsystem} の古い先端は @samp{subsystem@@@{1@}} にあります。それ以降にフェッチすると、その数は増えます。 (git-reflog(1) を参照してください)。

@item
@samp{topic} の先端に関連して: @samp{topic} に3つのコミットがあることを知っているので、 @samp{subsystem} の古い先端は @samp{topic~3} でなければなりません。
@end itemize

次に、あなたは以下のように言って、古い @samp{subsystem..topic} を新しい先端に移植できます(reflogの場合、すでに @samp{topic} にいると仮定します):

@example
    $ git rebase --onto subsystem subsystem@@@{1@}
@end example


「悪い場合」のリカバリの波及効果は特に悪いです。「topic」の下流にある「全て」で「悪い場合」のリカバリを実行する必要があります。

@noindent

@chapheading REBASING MERGES

対話的リベースコマンドは、元々、個々のパッチシリーズを処理するために設計されました。そのため、開発者がブランチの作業中にその時点で最新の「master」をマージした可能性があり、最終的にすべてのコミットを「master」にリベースする(マージコミットをスキップする)ため、マージコミットをtodoリストから除外することは理にかなっています。

ただし、開発者がマージコミットを再作成する正当な理由があります。それは複数の相互に関連するブランチで作業するときに、ブランチ構造(または「コミットトポロジ」）を維持するためです。

次の例では、開発者はボタンの定義方法をリファクタリングするトピックブランチと、そのリファクタリングを使用して[バグの報告]ボタンを実装する別のトピックブランチで作業します。 @samp{git log --graph --format=%s -5} の出力は以下のようになります:

@example
*   Merge branch 'report-a-bug'
|\
| * Add the feedback button
* | Merge branch 'refactor-button'
|\ \
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one
@end example


開発者は、ブランチトポロジを維持しながら、これらのコミットを新しい @samp{master} にリベースしたい場合があります。たとえば、最初のトピックブランチが2番目のブランチよりもはるかに早く @samp{master} に統合されると予想される場合、たとえば、マージの競合を解決して、 @samp{master} にしたDownloadButtonクラスへの変更を解決します。

このリベースは、 @samp{--rebase-merges} オプションを使用して実行できます。 以下のようなToDoリストが生成されます:

@example
label onto

# Branch: refactor-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor-button

# Branch: report-a-bug
reset refactor-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report-a-bug

reset onto
merge -C a1b2c3 refactor-button # Merge 'refactor-button'
merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'
@end example


通常の対話的リベースとは対照的に、 @samp{pick} コマンドに加えて @samp{label} と @samp{reset} と`merge` コマンドがあります。

@samp{label} コマンドは、そのコマンドが実行されるときに、ラベルを現在のHEADに関連付けます。これらのラベルは、ワークツリーローカル参照(@samp{refs/rewritten/<label>})として作成され、リベースが終了すると削除されます。こうすれば、同じリポジトリにリンクされている複数のワークツリーでのリベース操作が相互に干渉することはありません。 @samp{label} コマンドが失敗した場合、すぐに再スケジュールされ、続行する方法について役立つメッセージが表示されます。

@samp{reset} コマンドは、HEADとインデックスとワークツリーを指定されたリビジョンにリセットします。 これは @samp{exec git reset --hard <label>} に似ていますが、追跡していないファイルの上書きを拒否します。 @samp{reset} コマンドが失敗すると、すぐに再スケジュールされ、todoリストを編集する方法がわかりやすく表示されます(これは通常、 @samp{reset} コマンドがtodoリストに手動で挿入され、タイプミスが含まれている場合に発生します)。

@samp{merge} コマンドは、指定されたリビジョンをその時点でHEADであるものにマージします。 @samp{-C <original-commit>`を使用すると、指定されたマージコミットのコミットメッセージが使用されます。 `-C} が小文字の @samp{-c} に変更されると、ユーザーがメッセージを編集できるように、マージが成功した後にメッセージがエディターで開かれます。

マージの競合以外の理由で @samp{merge} コマンドが失敗した場合(つまり、マージ操作が開始されなかった場合)、コマンドは直ちに再スケジュールされます。

デフォルトでは、「merge」コマンドは通常のマージには「ort」マージ戦略を使用し、タコマージ(octopus merges)には「octopus」マージ戦略を使用します。リベースを呼び出すときに @samp{--strategy} 引数を使用して、すべてのマージのデフォルト戦略を指定できます。または、 @samp{exec} コマンドを使用して明示的に @samp{--strategy} 引数を伴った @samp{git merge} を呼び出すことにより、コマンドの対話リスト内の特定のマージをオーバーライドできます。注意:このように明示的に @samp{git merge} を呼び出す場合、マージするブランチを参照するために、ラベルがワークツリーローカル参照であるという事実(たとえば、 ref @samp{refs/rewritten/onto} はラベル @samp{onto} に対応します)を利用できることに注意してください。

注意: 最初のコマンド(@samp{label onto})は、コミットがリベースされるリビジョンにラベルを付けます。 @samp{onto`という名前は単なる慣例で、 `--onto} オプションにちなんでいます。

@samp{merge <merge-head>} の形式のコマンドを追加することにより、完全に新しいマージコミットを最初から導入することもできます。この形式は、暫定的なコミットメッセージを生成し、常にエディターを開いてユーザーが編集できるようにします。これは便利です。例えば、トピックブランチが複数の懸念事項に対処していることが判明し、2つ以上のトピックブランチに分割したい場合です。以下のToDoリストを検討してみてください:

@example
pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1.3
pick fdbaec Fix detection of cURL in CMake on Windows
@end example


CMakeに関連しないこのリストの1つのコミットは、CMakeに切り替えることによって発生したすべてのバグの修正に取り組むことによって動機付けられた可能性がありますが、しかし、それは別の懸念に対処します。このブランチを2つのトピックブランチに分割するには、ToDoリストを以下のように編集できます:

@example
label onto

pick afbecd http: add support for TLS v1.3
label tlsv1.3

reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake

reset onto
merge tlsv1.3
merge cmake
@end example


@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  rebase.backend 
リベースに使用するデフォルトのバックエンド。 可能な選択肢は、「apply」または「merge」です。 将来、mergeバックエンドがapplyバックエンドの残りのすべての機能を取得した場合、この設定は使用されなくなる可能性があります。

@item  rebase.stat 
最後のリベース以降にアップストリームで変更されたもののdiffstatを表示するかどうか。デフォルトではFalseです。

@item  rebase.autoSquash 
trueに設定されている場合、デフォルトで @samp{--autosquash} オプションを有効にします。

@item  rebase.autoStash 
trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。これは、ダーティワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、 git-rebase(1) の @samp{--no-autostash} および @samp{--autostash} オプションでオーバーライドできます。 デフォルトはfalseです。

@item  rebase.updateRefs 
trueに設定されている場合、デフォルトで @samp{--update-refs} オプションを有効にします。

@item  rebase.missingCommitsCheck 
「warn」に設定すると、 @samp{git rebase -i} は、一部のコミットが削除された場合(たとえば、行が削除された場合)に警告を出力しますが、リベースは続行されます。 「error」に設定すると、前記の警告が出力され、リベースが停止(stop)します。 @samp{git rebase --edit-todo} を使用して、エラーを修正できます。 「ignore」に設定すると、チェックは行われません。 警告やエラーなしにコミットをドロップするには、todoリストの @samp{drop} コマンドを使用します。 デフォルトは「ignore」です。

@item  rebase.instructionFormat 
git-log(1) で指定されている、対話的リベース中にToDoリストに使用される書式文字列。書式では、自動的に長いコミットハッシュが書式の前に付加されます。

@item  rebase.abbreviateCommands 
trueに設定すると、 @samp{git rebase} はtodoリストで省略コマンド名を使用し、以下のようになります:

@example
        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        ...
@end example


上記は以下の省略形です:

@example
        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        ...
@end example


デフォルトではfalseです。

@item  rebase.rescheduleFailedExec 
失敗した @samp{exec} コマンドを自動的に再スケジュールします。 これは、対話モード (または @samp{--exec} オプションが指定されている場合)でのみ意味があります。これは @samp{--reschedule-failed-exec} オプションを指定するのと同じです。

@item  rebase.forkPoint 
falseに設定されている場合、デフォルトで @samp{--no-fork-point} オプションを設定します。

@item  rebase.rebaseMerges 
Whether and how to set the @samp{--rebase-merges} option by default. Can be @samp{rebase-cousins}, @samp{no-rebase-cousins}, or a boolean. Setting to true or to @samp{no-rebase-cousins} is equivalent to @samp{--rebase-merges=no-rebase-cousins}, setting to @samp{rebase-cousins} is equivalent to @samp{--rebase-merges=rebase-cousins}, and setting to false is equivalent to @samp{--no-rebase-merges}. Passing @samp{--rebase-merges} on the command line, with or without an argument, overrides any @samp{rebase.rebaseMerges} configuration.

@item  sequence.editor 
リベース命令ファイル(rebase instruction file)を編集するために @samp{git rebase -i} によって使用されるテキストエディタ。この値は、使用時にシェルによって解釈されることを意図しています。 これは、 @samp{GIT_SEQUENCE_EDITOR} 環境変数によってオーバーライドできます。構成されていない場合は、代わりにデフォルトのコミットメッセージエディタが使用されます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-receive-pack,,,Top
@chapheading Name

git-receive-pack — リポジトリにプッシュされたものを受信します

@noindent

@chapheading Synopsis

@display
git receive-pack <git-dir>
@end display


@noindent

@chapheading DESCRIPTION

@samp{git send-pack} によって呼び出され、リモート側からもたらされた情報でリポジトリを更新します。

このコマンドは通常、エンドユーザーによって直接呼び出されることはありません。 プロトコルのUIは @samp{git send-pack} 側にあり、プログラムペアは更新をリモートリポジトリにプッシュするために使用されることを目的としています。 プル操作については、 git-fetch-pack(1) を参照してください。

このコマンドを使用すると、リモート側で sha1 ref (ヘッド/タグ)を作成して早送りできます(厳密に言えば、ローカル側では @samp{git-receive-pack} が実行されますが、send-pack側に居るユーザにとってはリモートの更新をしている事になります。混乱しないでね？)

Documentation/howtoディレクトリには、更新フック(update hook)と更新後フック(post-update hook)を使用した実例が他にもあります。

@emph{git-receive-pack} は、 receive.denyNonFastForwards 構成オプションを尊重します。このオプションは、refの更新が早送りでない場合に拒否する必要があるかどうかを通知します。

他の多くの @samp{receive.*} 構成オプションを使用して、その動作を微調整できます。 git-config(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  <git-dir> 
同期するリポジトリ。

@item  @samp{--http-backend-info-refs} 
git-http-backend(1) が、 @samp{$GIT_URL/info/refs?service=git-receive-pack} リクエストを処理するために使用します。 git-upload-pack(1) の @samp{--http-backend-info-refs} を参照してください。
@end table

@noindent

@chapheading PRE-RECEIVE HOOK

refが更新される前に、 $GIT_DIR/hooks/pre-receive ファイルが存在し、実行可能である場合、パラメーターなしで1回呼び出されます。 フックの標準入力は、更新される参照ごとに1行になります:

@example
sha1-old SP sha1-new SP refname LF
@end example

refnameの値は$GIT_DIRを基準にしています。 例えば masterヘッドの場合、これは @samp{refs/heads/master} です。 各refnameの前の2つのsha1値は、更新前後のrefnameのオブジェクト名です。 作成されるrefのsha1-oldは 0@{40@} に等しく、削除されるrefのsha1-newは 0@{40@} になります。それ以外の場合、sha1-oldとsha1-newはリポジトリ内の有効なオブジェクトである必要があります。

署名されたプッシュを受け入れる場合(git-push(1) 参照)、署名されたプッシュ証明書はブロブに格納され、環境変数 @samp{GIT_PUSH_CERT} でオブジェクト名を調べることができます。 例については、 @samp{post-receive} フックの説明を参照してください。 さらに、証明書はGPGを使用して検証され、結果は以下の環境変数とともにエクスポートされます:

@table @asis

@item  @samp{GIT_PUSH_CERT_SIGNER} 
プッシュ証明書に署名したキーの所有者の、名前(name)と電子メールアドレス(e-mail address)。

@item  @samp{GIT_PUSH_CERT_KEY} 
プッシュ証明書に署名したキーのGPGキーID。

@item  @samp{GIT_PUSH_CERT_STATUS} 
コマンドの @samp{git log} ファミリーの @samp{%G?} 形式で使用されるのと同一のニーモニックを使用した、プッシュ証明書のGPG検証のステータス(git-log(1) を参照)。

@item  @samp{GIT_PUSH_CERT_NONCE} 
プロセスが署名者にプッシュ証明書に含めるように要求したノンス(nonce;その場限りの)文字列。これがプッシュ証明書の「nonce」ヘッダーに記録されている値と一致しない場合は、証明書が別の @samp{git push} セッションから再実行されている有効な証明書であることを示している可能性があります。

@item  @samp{GIT_PUSH_CERT_NONCE_STATUS} 
@table @asis

@item  @samp{UNSOLICITED} 
@samp{git push --signed} は、私達が送信を問い合わせなかったときにノンス(nonce)を送信しました。

@item  @samp{MISSING} 
@samp{git push --signed} はノンスヘッダーを送信しませんでした。

@item  @samp{BAD} 
@samp{git push --signed} は偽のノンスを送信しました。

@item  @samp{OK} 
@samp{git push --signed} は、私達が送信を要求したノンスを送信しました。

@item  @samp{SLOP} 
@samp{git push --signed} は、前回のセッションで送信するように要求したものとは異なるノンスを送信しました。 @samp{GIT_PUSH_CERT_NONCE_SLOP} 環境変数を参照してください。
@end table

@item  @samp{GIT_PUSH_CERT_NONCE_SLOP} 
@samp{git push --signed} は、現在送信するように要求したものとは異なるノンスを送信しました。開始時刻が現在のセッションとは何秒も違う別のセッションで送信されました。 @samp{GIT_PUSH_CERT_NONCE_STATUS} が @samp{SLOP} と言った場合にのみ意味があります。 git-config(1) の @samp{receive.certNonceSlop} 変数についてもお読みください。
@end table

このフックは、refnameが更新される前、および早送りチェックが実行される前に呼び出されます。

受信前(pre-receive)フックがゼロ以外の終了ステータスで終了した場合、更新は実行されず、更新(update)フックや受信後フック(post-receive)や更新後(post-update)フックも呼び出されません。 これは、更新がサポートされない場合に迅速に救済するのに役立ちます。

以下の検疫環境(quarantine environment)に関する注記を参照してください。

@noindent

@chapheading UPDATE HOOK

各refが更新される前に、 $GIT_DIR/hooks/update ファイルが存在し、実行可能である場合、3つのパラメーターを使用してrefごとに1回呼び出されます:

@example
$GIT_DIR/hooks/update refname sha1-old sha1-new
@end example

refnameパラメーターは$GIT_DIRに関連しています。 例えば masterヘッドの場合、これは @samp{refs/heads/master} です。 2つのsha1引数は、更新前後のrefnameのオブジェクト名です。 refnameが更新される前にフックが呼び出されるため、sha1-oldが 0@{40@} (そのようなrefがまだないことを意味します)であるか、refnameに記録されているものと一致する必要があることに注意してください。

名前付きrefの更新を禁止する場合、フックはゼロ以外のステータスで終了する必要があります。 それ以外の場合は、ゼロで終了する必要があります。

このフックの正常な実行(ゼロ終了ステータス)は、refが実際に更新されることを保証するものではなく、前提条件にすぎません。 そのため、このフックから通知(電子メールなど)を送信することはお勧めできません。 代わりに、受信後(post-receive)フックの使用を検討してください。

@noindent

@chapheading POST-RECEIVE HOOK

すべてのrefが更新された後(または更新が試みられた後)、refの更新が成功した場合、および $GIT_DIR/hooks/post-receive ファイルが存在し、実行可能である場合、パラメーターなしで1回呼び出されます。 フックの標準入力は、正常に更新された参照ごとに1行になります。

@example
sha1-old SP sha1-new SP refname LF
@end example

refnameの値は$GIT_DIRを基準にしています。 例えば masterヘッドの場合、これは @samp{refs/heads/master} です。 各refnameの前の2つのsha1値は、更新前後のrefnameのオブジェクト名です。 作成された参照はsha1-oldが 0@{40@} に等しくなり、削除された参照はsha1-newが 0@{40@} に等しくなります。それ以外の場合、sha1-oldとsha1-newはリポジトリ内の有効なオブジェクトである必要があります。

署名されたプッシュを受け入れた後、 @samp{pre-receive} フックの場合と同様に、 @samp{GIT_PUSH_CERT*} 環境変数を検査できます。

このフックを使用すると、リポジトリの更新を説明するメールを簡単に生成できます。 このサンプルスクリプトは、リポジトリにプッシュされたコミットを一覧表示するrefごとに1つのメールメッセージを送信し、適切な署名を持つ署名付きプッシュのプッシュ証明書をログ取りサービス(logger service)に記録します:

@example
#!/bin/sh
# mail out commit update information.
while read oval nval ref
do
        if expr "$oval" : '0*$' >/dev/null
        then
                echo "Created a new ref, with the following commits:"
                git rev-list --pretty "$nval"
        else
                echo "New commits:"
                git rev-list --pretty "$nval" "^$oval"
        fi |
        mail -s "Changes to ref $ref" commit-list@@mydomain
done
# log signed push certificate, if any
if test -n "$@{GIT_PUSH_CERT-@}" && test $@{GIT_PUSH_CERT_STATUS@} = G
then
        (
                echo expected nonce is $@{GIT_PUSH_NONCE@}
                git cat-file blob $@{GIT_PUSH_CERT@}
        ) | mail -s "push certificate from $GIT_PUSH_CERT_SIGNER" push-log@@mydomain
fi
exit 0
@end example


このフック呼び出しからの終了コードは無視されますが、ゼロ以外の終了コードはエラーメッセージを生成します。

このフックが実行されると、refnameにsha1-newがない可能性があることに注意してください。 これは、 @samp{git-receive-pack} によって更新された後、フックがそれを評価できるようになる前に、別のユーザーが参照を変更した場合に簡単に発生する可能性があります。 フックは、refnameの現在の値ではなく、sha1-newに依存することをお勧めします。

@noindent

@chapheading POST-UPDATE HOOK

他のすべての処理の後、少なくとも1つのrefが更新され、 $GIT_DIR/hooks/post-update ファイルが存在し、実行可能である場合、更新されたrefのリストを使用してpost-updateが呼び出されます。 これは、リポジトリ全体のクリーンアップタスクを実装するために使用できます。

このフック呼び出しからの終了コードは無視されます。 その時点で @samp{git-receive-pack} に残されているのは、とにかく自分自身を終了することだけです。

このフックは、たとえば、リポジトリがパックされてバカ転送(dumb transport)を介して提供される場合に @samp{git update-server-info} を実行するために使用できます。

@example
#!/bin/sh
exec git update-server-info
@end example


@noindent

@chapheading QUARANTINE ENVIRONMENT

@samp{receive-pack} がオブジェクトを取り込むと、それらは @samp{$GIT_DIR/objects} ディレクトリ内の一時的な「隔離」(quarantine)ディレクトリに配置され、 @samp{pre-receive} フックが完了した後にのみメインオブジェクトストアに移行されます。 それ以前にプッシュが失敗した場合、一時ディレクトリは完全に削除されます。

これには、ユーザーからも見えるいくつかの影響と注意事項があります:

@enumerate 

@item
着信パックの問題、またはオブジェクトの欠落、または @samp{pre-receive} フックが原因で失敗したプッシュは、ディスク上のデータを残しません。 これは通常、繰り返し失敗したプッシュがディスクをいっぱいにするのを防ぐのに役立ちますが、デバッグがより困難になる可能性があります。

@item
@samp{pre-receive} フックによって作成されたオブジェクトはすべて、隔離(quarantine)ディレクトリに作成されます(成功した場合にのみ移行されます)。

@item
@samp{pre-receive} フックは、隔離(quarantined)されたオブジェクトを指すように参照を更新してはなりません。 リポジトリにアクセスする他のプログラムはオブジェクトを見ることができません(そして、受信前(pre-receive)フックが失敗した場合、それらのrefは破損します)。 安全のため、 @samp{pre-receive} 内からのrefの更新は自動的に拒否されます。
@end enumerate

@noindent

@chapheading SEE ALSO

git-send-pack(1), gitnamespaces(7)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-reflog,,,Top
@chapheading Name

git-reflog — reflog情報を管理します

@noindent

@chapheading Synopsis

@display
git reflog [show] [<log-options>] [<ref>]
git reflog expire [--expire=<time>] [--expire-unreachable=<time>]
        [--rewrite] [--updateref] [--stale-fix]
        [--dry-run | -n] [--verbose] [--all [--single-worktree] | <refs>…]
git reflog delete [--rewrite] [--updateref]
        [--dry-run | -n] [--verbose] <ref>@@@{<specifier>@}…
git reflog exists <ref>
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、reflogに記録された情報を管理します。

参照ログ(reference logs)、または "reflogs" は、ブランチのヒントやその他の参照がローカルリポジトリで更新された時期を記録します。reflogは、参照の古い値を指定するために、さまざまなGitコマンドで役立ちます。 たとえば、 @samp{HEAD@@@{2@}} は「HEADが2移動前にあった位置」を意味し、 @samp{master@@@{one.week.ago@}} は「masterがこのローカルリポジトリで1週間前を指していた位置」を意味する等々。詳細については gitrevisions(7) を参照してください。

このコマンドは、さまざまなサブコマンドと、サブコマンドに応じて異なるオプションを取ります:

「show」サブコマンド(サブコマンドの指定がない場合のデフォルトでもあります)は、コマンドライン(またはデフォルトでは「HEAD」)で指定される参照のログを表示します。 reflogは最近のすべてのアクションをカバーし、さらに @samp{HEAD} reflogはブランチの切り替えを記録します。 @samp{git reflog show} は @samp{git log -g --abbrev-commit --pretty=oneline} のエイリアスです。詳細については git-log(1) を参照してください。

「expire」サブコマンドは、古いreflogエントリを刈り取ります。「expire」時間より古いエントリ、または「expire-unreachable」時間より古く、現在の先端から到達できないエントリがreflogから削除されます。これは通常、エンドユーザーが直接使用することはありません。代わりに、 git-gc(1) を参照してください。

「delete」サブコマンドは、reflogから単一のエントリを削除します。 その引数は「正確な」エントリである必要があります(例: @samp{git reflog delete master@@@{2@}} )。 このサブコマンドは、通常、エンドユーザーが直接使用することもありません。

「exists」サブコマンドは、refにreflogがあるかどうかをチェックします。reflogが存在する場合はゼロのステータスで終了し、存在しない場合はゼロ以外のステータスで終了します。

@noindent

@chapheading OPTIONS

@noindent

@heading showサブコマンド用オプション

@samp{git reflog show} は、 @samp{git log} で受け入れられるすべてのオプションを受け入れます。

@noindent

@heading expireサブコマンド用オプション

@table @asis

@item  @samp{--all} 
すべての参照のreflogを処理します。

@item  @samp{--single-worktree} 
デフォルトでは、 @samp{--all} が指定されている場合、すべての作業ツリーからのreflogが処理されます。 このオプションは、処理を現在の作業ツリーからのreflogのみに制限します。

@item  @samp{--expire=<time>} 
指定された時間より古いエントリを刈り取ります。このオプションが指定されていない場合、有効期限は構成設定 @samp{gc.reflogExpire} から取得され、デフォルトで90日になります。 @samp{--expire=all} は、年齢に関係なくエントリを削除します。 @samp{--expire=never} は、到達可能なエントリの刈り取りをオフにします(しかし、 @samp{--expire-unreachable} を参照してください)。

@item  @samp{--expire-unreachable=<time>} 
ブランチの現在の先端から到達できない @samp{<time>} より古いエントリを刈り取ります。このオプションが指定されていない場合、有効期限は構成設定 @samp{gc.reflogExpireUnreachable} から取得され、デフォルトで30日になります。 @samp{--expire-unreachable=all} は、年齢に関係なく、到達不能なエントリを刈り取ります。 @samp{--expire-unreachable=never} は、到達不能なエントリの早期刈り取りをオフにします(しかし、 @samp{--expire} を参照してください)。

@item  @samp{--updateref} 
以前の最上位エントリが刈り取りされた場合は、最上位のreflogエントリの値(つまり、 <ref>@@@{0@} )への参照を更新します。(このオプションは、シンボリック参照では無視されます。)

@item  @samp{--rewrite} 
reflogエントリーの前任者が刈り込まれてしまった場合、その「古い」SHA-1を、現在の前任者にあるエントリーの「新しい」SHA-1フィールドと等しくなるように調整します。

@item  @samp{--stale-fix} 
「壊れたコミット」(broken commits)を指すreflogエントリを削除します。壊れたコミットとは、どのリファレンスヒントからも到達できず、直接または間接的に、欠落しているコミットまたはツリーまたはブロブオブジェクトを参照するコミットです。

これの計算では、到達可能なすべてのオブジェクトのトラバースが含まれます。つまり、 @samp{git prune} と同じコストがかかります。これは主に、reflogによって参照されるオブジェクトを保護しなかった古いバージョンのGitを使用したガベージコレクションによって引き起こされた破損を修正することを目的としています。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際にエントリの刈り取りは行いません。何が刈り取られるかを表示するだけです。

@item  @samp{--verbose} 
画面に追加情報を出力します。
@end table

@noindent

@heading deleteサブコマンド用オプション

@samp{git reflog delete} は、オプション @samp{--updateref} と @samp{-rewrite} と @samp{-n} と @samp{--dry-run} と` --verbose` を受け入れます。これらは、 @samp{expire} で使用される場合と同じ意味です。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-remote-ext,,,Top
@chapheading Name

git-remote-ext — スマートトランスポートを外部コマンドにブリッジします。

@noindent

@chapheading Synopsis

@display
git remote add <nick> "ext::<command>[ <arguments>…]"
@end display


@noindent

@chapheading DESCRIPTION

このリモートヘルパーは、指定の @samp{<command>} を使用してリモートGitサーバーに接続します。

指定の @samp{<command>} のstdinに書き込んだデータは、git:// サーバーまたは git-upload-pack または git-receive-pack または (状況に応じて)git-upload-archive に送信されるものと見なし、かつ、 <command> のstdoutからの読み取りは、同一のサービスから受信されたものと見なされます。

コマンドと引数は、エスケープされていない空白で区切られます。

以下のシーケンスには特別な意味があります:

@table @asis

@item  `% ` 
コマンドまたは引数のリテラル空白

@item  @samp{%%} 
リテラルのパーセント文字

@item  @samp{%s} 
Gitが呼び出したいサービスの名前(receive-pack または upload-pack または upload-archive)に置き換えられます。

@item  @samp{%S} 
Gitが呼び出したいサービスの長い名前(long name)(git-receive-pack または git-upload-pack または git-upload-archive)に置き換えられます。

@item  @samp{%G} (引数の最初の文字列である必要があります) 
この引数は @samp{<command>} には渡されません。その代わりにヘルパーは、サービスフィールドが適切な値に設定され、かつ、リポジトリフィールドが引数の残りの部分に設定された状態でリモート側に git:// サービス要求(request)を送信することから開始します。デフォルトでは、そのような要求は送信されません。

これはリモート側の git:// サーバーへトンネルを介してアクセスする場合に便利です。

@item  @samp{%V} (引数の最初の文字列である必要があります) 
この引数は @samp{<command>} には渡されません。その代わりに git:// サービス要求でvhostフィールドを(引数の残りの部分に)設定します。デフォルトでは、(送信の場合)そのような要求でvhostを送信しません。
@end table

@noindent

@chapheading ENVIRONMENT VARIABLES

@table @asis

@item  GIT_TRANSLOOP_DEBUG 
設定されている場合、さまざまな読み取り/書き込みに関するデバッグ情報を出力します。
@end table

@noindent

@chapheading ENVIRONMENT VARIABLES PASSED TO COMMAND

@table @asis

@item  GIT_EXT_SERVICE 
サービスヘルパーが呼び出す必要のある長い名前(git-upload-pack など)を設定します。

@item  GIT_EXT_SERVICE_NOPREFIX 
サービスヘルパーが呼び出す必要のある名前(upload-pack など)を設定します。
@end table

@noindent

@chapheading EXAMPLES

このリモートヘルパーは、 @samp{git fetch <URL>} 、 @samp{git clone <URL>} 、 @samp{git push <URL>} 、 @samp{git remote add <nick> <URL>} などのコマンドを使用するときに、Gitによって透過的に使用され、 <URL>は @samp{ext::} で始まります。 例:

@table @asis

@item  "ext::ssh -i /home/foo/.ssh/somekey user@@host.example %S @emph{foo/repo}" 
host.example:foo/repo と同様ですが、キーペアとして /home/foo/.ssh/somekey を使用し、リモート側のユーザーとしてuserを使用します。 これにより、 .ssh/config を編集する必要がなくなります。

@item  "ext::socat -t3600 - ABSTRACT-CONNECT:/git-server %G/somerepo" 
抽象名前空間アドレス(abstract namespace address) /git-server でgitプロトコルを介してアクセス可能なパス /somerepo を持つリポジトリを表します。

@item  "ext::git-server-alias foo %G/repo" 
ヘルパープログラム @samp{git-server-alias foo} を使用してアクセスされるパス /repo を持つリポジトリを表します。リポジトリへのパスとリクエストのタイプは、コマンドラインではなく、通常の git:// プロトコルのようにプロトコルストリームの一部として渡されます。

@item  "ext::git-server-alias foo %G/repo %Vfoo" 
ヘルパープログラム @samp{git-server-alias foo} を使用してアクセスされるパス /repo を持つリポジトリを表します。プロトコルストリームで渡されるリモートサーバーのホスト名は「foo」になります(これにより、複数の仮想Gitサーバーがリンクレベルのアドレスを共有できるようになります)。

@item  "ext::git-server-alias foo %G/repo% with% spaces %Vfoo" 
ヘルパープログラム @samp{git-server-alias foo} を使用してアクセスされるパス @samp{/repo with spaces} のリポジトリを表します。プロトコルストリームで渡されるリモートサーバーのホスト名は「foo」になります(これにより、複数の仮想Gitサーバーがリンクレベルのアドレスを共有できるようになります)。

@item  "ext::git-ssl foo.example /bar" 
ヘルパープログラム @samp{git-ssl foo.example /bar} を使用してアクセスされるリポジトリを表します。リクエストのタイプは、ヘルパーが環境変数を使用して決定できます(上記参照)。
@end table

@noindent

@chapheading SEE ALSO

gitremote-helpers(7)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-remote-fd,,,Top
@chapheading Name

git-remote-fd — スマートトランスポートストリームを呼び出し元に反映します(Reflect smart transport stream back to caller)

@noindent

@chapheading Synopsis

"fd::<infd>[,<outfd>][/<anything>]" (as URL)

@noindent

@chapheading DESCRIPTION

このヘルパーは、指定のファイルデスクリプタを使用してリモートGitサーバーに接続します。これはエンドユーザー向けではなく、git fetch、pushまたはarchiveを呼び出すプログラムとスクリプトを対象としています。

<infd> のみが指定されている場合は、リモートGitサーバー(git-upload-pack、git-receive-pack または git-upload-archive)に接続されている双方向ソケットであると見なされます。 <infd> と <outfd> の両方が指定されている場合、それらはリモートGitサーバーに接続されているパイプであると見なされます( <infd> は入力パイプ、 <outfd> は出力パイプです)。

このヘルパーが開始される前に、ハンドシェイク手順(git:// のサービスリクエストの送信など)がすでに完了していることを前提としています。

<anything> は任意の文字列にすることができます。それは無視されます。これは、URLが何らかのコンテキストで表示される場合に、URLでユーザーに情報を提供するためのものです。

@noindent

@chapheading ENVIRONMENT VARIABLES

@table @asis

@item  GIT_TRANSLOOP_DEBUG 
設定されている場合、さまざまな 読み取り/書き込み に関するデバッグ情報を出力します。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git fetch fd::17 master} 
ファイルデスクリプタ #17 使用して master を Fetch し、 git-upload-pack と通信します。

@item  @samp{git fetch fd::17/foo master} 
同上。

@item  @samp{git push fd::7,8 master (as URL)} 
master を push し、ファイルデスクリプタ #7 を使用して git-receive-pack からデータを読み取り、ファイルデスクリプタ #8 を使用して同じサービスにデータを書き込みます。

@item  @samp{git push fd::7,8/bar master} 
同上。
@end table

@noindent

@chapheading SEE ALSO

gitremote-helpers(7)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-remote,,,Top
@chapheading Name

git-remote — 追跡中のリポジトリの組を管理します

@noindent

@chapheading Synopsis

@display
git remote [-v | --verbose]
git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <URL>
git remote rename [--[no-]progress] <old> <new>
git remote remove <name>
git remote set-head <name> (-a | --auto | -d | --delete | <branch>)
git remote set-branches [--add] <name> <branch>…
git remote get-url [--push] [--all] <name>
git remote set-url [--push] <name> <newurl> [<oldurl>]
git remote set-url --add [--push] <name> <newurl>
git remote set-url --delete [--push] <name> <URL>
git remote [-v | --verbose] show [-n] <name>…
git remote prune [-n | --dry-run] <name>…
git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)…]
@end display


@noindent

@chapheading DESCRIPTION

ブランチを追跡するリポジトリの組(「remotes」)を管理します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
@itemx  @samp{--verbose} 
もう少しおしゃべりにして、名前の後にリモートURLを表示します。 プロミサー・リモートの場合は、構成されているフィルター(@samp{blob:none} など)も表示します。 注意: これは、@samp{remote} とサブコマンドの間に配置する必要があります。
@end table

@noindent

@chapheading COMMANDS

引数なしだと、既存のリモートのリストを表示します。 「リモート」に操作を実行するために、いくつかのサブコマンドを使用できます。

@table @asis

@item  @samp{add} 
<URL>のリポジトリに<name>という名前の「リモート」を追加します。 次に、コマンド @samp{git fetch <name>} を使用して、リモート追跡ブランチ <name>/<branch> を作成および更新できます。

@samp{-f} オプションと使用すると、「リモート」情報が設定された直後に @samp{git fetch <name>} が実行されます。

@samp{--tags} オプションと使用すると、 @samp{git fetch <name>} はリモートリポジトリからすべてのタグをインポートします。

@samp{--no-tags} オプションと使用すると、 `git fetch <name> ` はリモートリポジトリからタグをインポートしません。

デフォルトでは、フェッチされたブランチのタグのみがインポートされます(git-fetch(1) 参照)。

@samp{-t <branch>} オプションと使用すると、「リモート」のデフォルトのグロブrefspecが @samp{refs/remotes/<name>/} 名前空間の下のすべてのブランチを追跡する代わりに、 @samp{<branch>} のみを追跡するrefspecが作成されます。 複数の @samp{-t <branch>} を指定して、すべてのブランチを取得せずに複数のブランチを追跡できます。

@samp{-m <master>} オプションと使用すると、シンボリックref @samp{refs/remotes/<name>/HEAD} がリモートの @samp{<master>} ブランチを指すように設定されます。 set-head コマンドも参照してください。

フェッチミラーが @samp{--mirror=fetch} で作成される場合、refは @samp{refs/remotes/} 名前空間に保存されませんが、リモートの @samp{refs/} 内のすべてがローカルリポジトリ内の @samp{refs/} に直接ミラーリングされます。フェッチはローカルコミットを上書きするため、このオプションはベアリポジトリでのみ意味があります。

プッシュミラーが @samp{--mirror=push} で作成されると、 @samp{git push} は常に @samp{--mirror} が渡されたかのように動作します。

@item  @samp{rename} 
<old>という名前の「リモート」の名前を<new>に変更します。 「リモート」のすべてのリモート追跡ブランチと構成設定が更新されます。

<old>と<new>が同一で、<old>が @samp{$GIT_DIR/remotes} または @samp{$GIT_DIR/branchs} の下のファイルである場合、「リモート」は構成ファイル形式に変換されます。

@item  @samp{remove} 
@itemx  @samp{rm} 
<name>という名前の「リモート」を削除します。 「リモート」のすべてのリモート追跡ブランチと構成設定が削除されます。

@item  @samp{set-head} 
名前付き「リモート」のデフォルトブランチ(つまり、シンボリックref @samp{refs/remotes/<name>/HEAD} のターゲット)を設定または削除します。 リモートのデフォルトブランチを持つ必要はありませんが、特定のブランチの代わりにリモートの名前を指定できます。 たとえば、@samp{origin} のデフォルトブランチが @samp{master} に設定されている場合、通常は @samp{origin/master} を指定する場所であればどこでも @samp{origin} を指定できます。

@samp{-d} または @samp{--delete} と使用すると、シンボリックref @samp{refs/remotes/<name>/HEAD} が削除されます。

@samp{-a} または @samp{--auto} と使用すると、リモートはその @samp{HEAD} を決定するために照会され、シンボリックref @samp{refs/remotes/<name>/HEAD} が同じブランチに設定されます。 たとえば、リモートの @samp{HEAD} が @samp{next} を指している場合、 @samp{git remote set-head origin -a} はシンボリックref @samp{refs/remotes/origin/HEAD} を @samp{refs/remotes/origin/next} に設定します。 これは、 @samp{refs/remotes/origin/next} がすでに存在する場合にのみ機能します。 そうでない場合は、最初にフェッチする必要があります。

@samp{<branch>} を使用して、シンボリックref @samp{refs/remotes/<name>/HEAD} を明示的に設定します。 たとえば、 @samp{git remote set-head origin master} はシンボリックref @samp{refs/remotes/origin/HEAD} を @samp{refs/remotes/origin/master} に設定します。 これは、 @samp{refs/remotes/origin/master} がすでに存在する場合にのみ機能します。 そうでない場合は、最初にフェッチする必要があります。

@item  @samp{set-branches} 
指定された「リモート」によって追跡されるブランチのリストを変更します。 これは、「リモート」の初期セットアップ後に、使用可能なリモートブランチのサブセットを追跡するために使用できます。

名前付きブランチは、 @samp{git remote add} コマンドラインで @samp{-t} オプションを指定した場合と同じように解釈されます。

@samp{--add} と使用すると、現在追跡されているブランチのリストを置き換える代わりに、そのリストに追加します。

@item  @samp{get-url} 
「リモート」のURLを取得します。 @samp{insteadOf} と @samp{pushInsteadOf} の設定はここで展開されます。デフォルトでは、最初のURLのみがリストされます。

@samp{--push} と使用すると、URLをフェッチするのではなく、プッシュURLが照会されます。

@samp{--all} と使用すると、リモート(remote)のすべてのURLが一覧表示されます。

@item  @samp{set-url} 
「リモート」のURLを変更します。 正規表現 <oldurl> (<oldurl> が指定されていない場合は最初のURL)に一致するリモート<name>の最初のURLを<newurl>に設定します。 <oldurl>がどのURLとも一致しない場合、エラーが発生し、何も変更されません。

@samp{--push} と使用すると、フェッチURLの代わりにプッシュURLが操作されます。

@samp{--add} と使用すると、既存のURLを変更する代わりに、新しいURLが追加されます。

@samp{--delete} と使用すると、既存のURLを変更する代わりに、リモート<name>の 正規表現<URL> に一致するすべてのURLが削除されます。プッシュされていないURLをすべて削除しようとするとエラーになります。

注意: プッシュURLとフェッチURLは、設定を変えても、同じ場所を参照する必要があることに注意してください。 プッシュURLにプッシュしたものは、フェッチURLからすぐにフェッチした場合に表示されるものになります。 ある場所(アップストリームなど)からフェッチして別の場所(パブリッシングリポジトリなど)にプッシュしようとしている場合は、2つの別々の「リモート」を使用します。

@item  @samp{show} 
リモートの<name>に関する情報を提供します。

@samp{-n} オプションと使用すると、リモートヘッドは最初に @samp{git ls-remote <name>} でクエリされません。 代わりに、キャッシュされた情報が使用されます。

@item  @samp{prune} 
<name>に関連付けられている古い参照を削除します。 デフォルトでは、<name>の下の古いリモート追跡ブランチは削除されますが、グローバル構成とリモートの構成によっては、そこにプッシュされていないローカルタグを削除することもあります。 新しい参照がフェッチされないことを除いて、 @samp{git fetch --prune <name>} と同等です。

さまざまな構成に応じて刈り込みする内容については、 git-fetch(1) の「PRUNING」セクションを参照してください。

@samp{--dry-run} オプションと使用して、どのブランチが刈り込まれるかを報告しますが、実際にはそれらを刈り込みしません。

@item  @samp{update} 
@samp{remotes.<group>} で定義されているように、リポジトリ内のリモートまたはリモートグループの更新を取得します。 コマンドラインでgroupもremoteも指定されていない場合は、構成パラメーター remotes.default が使用されます。 remotes.defaultが定義されていない場合、構成パラメーター @samp{remote.<name>.skipDefaultUpdate} がtrueに設定されていないすべてのリモートが更新されます。 (git-config(1) 参照)。

@samp{--prune} オプションと使用して、更新されたすべてのリモートに対して刈り込みを実行します。
@end table

@noindent

@chapheading DISCUSSION

「リモート」構成は、 @samp{remote.origin.url} および @samp{remote.origin.fetch} 構成変数を使用して実現されます。 (git-config(1) 参照)。

@noindent

@chapheading EXIT STATUS

成功ならば、終了ステータスは @samp{0} です。

add や rename や remove などのサブコマンドが問題のリモートを見つけることができない場合、終了ステータスは @samp{2} です。 リモートがすでに存在する場合、終了ステータスは @samp{3} です。

その他のエラーの場合、終了ステータスはその他ゼロ以外の値になるでしょう。

@noindent

@chapheading EXAMPLES

@itemize 

@item
新しいリモートを追加し、フェッチして、そこからブランチをチェックアウトします

@example
$ git remote
origin
$ git branch -r
  origin/HEAD -> origin/master
  origin/master
$ git remote add staging git://git.kernel.org/.../gregkh/staging.git
$ git remote
origin
staging
$ git fetch staging
...
From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
 * [new branch]      master     -> staging/master
 * [new branch]      staging-linus -> staging/staging-linus
 * [new branch]      staging-next -> staging/staging-next
$ git branch -r
  origin/HEAD -> origin/master
  origin/master
  staging/master
  staging/staging-linus
  staging/staging-next
$ git switch -c staging staging/master
...
@end example


@item
@samp{git clone} を模倣しますが、選択したブランチのみを追跡します

@example
$ mkdir project.git
$ cd project.git
$ git init
$ git remote add -f -t master -m master origin git://example.com/git.git/
$ git merge origin
@end example

@end itemize

@noindent

@chapheading SEE ALSO

git-fetch(1) git-branch(1) git-config(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-repack,,,Top
@chapheading Name

git-repack — リポジトリ内のアンパックオブジェクトをパックする

@noindent

@chapheading Synopsis

@display
git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>] [--write-midx]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、現在パック内に存在しないすべてのオブジェクトを1つのパックに結合するために使用されます。また、既存のパックを単一のより効率的なパックに再編成するために使用することもできます。

パックは、個別に圧縮され、デルタ圧縮が適用され、関連付けられたインデックスファイルとともに単一のファイルに格納されたオブジェクトのコレクションです。

パックは、ミラーシステム、バックアップエンジン、ディスクストレージなどの負荷を軽減するために使用されます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
パックされていないオブジェクトを段階的にパックする代わりに、参照されるすべてのものを1つのパックにパックします。プライベート開発に使用されるリポジトリをパックする場合に特に便利です。 @samp{-d} と一緒に使用します。 これにより、 @samp{git prune} が残したオブジェクトがクリーンアップされますが、 @samp{git fsck --full --dangling} ではぶら下がりを表示します。

馬鹿プロトコル(dumb protocol)を介してフェッチするユーザーは、含まれているオブジェクトを取得するために、そのパック内にすでにローカルにある他のオブジェクトの数に関係なく、まったく新しいパックをフェッチする必要があることに注意してください。

promisorパックファイルは個別に再パックされます。 @samp{.promisor} ファイルに関連付けられているパックファイルがある場合、これらのパックファイルは別の個別パックに再パックされ、新しい個別パックに対応する、空の @samp{.promisor} ファイルが書き込まれます。

@item  @samp{-A} 
@samp{-d} を使用しない限り @samp{-a} と同じです。 それから、前のパックの到達不能なオブジェクトは、古いパックに残されるのではなく、looseになって、パックされていないオブジェクトになります。再パックする場合でも、到達不能なオブジェクトが意図的にパックに追加されることはありません。このオプションは、到達不能なオブジェクトが古いパックに残されて、古いパックごと削除されることによって、すぐに削除されてしまうのを防ぎます。代わりに、loose到達不能オブジェクトは、以下の 「git gc」呼び出しで通常の有効期限ルールに従って剪定されます。 git-gc(1) を参照してください。

@item  @samp{-d} 
パック後、新しく作成されたパックによって既存のパックの一部が冗長になる場合は、冗長パックを削除してください。 また、「git prune-packed」を実行して、冗長なルーズオブジェクトファイルを削除します。

@item  @samp{--cruft} 
@samp{-d} が使用されない限り、 @samp{-a} と同一です。 そして、到達不能なオブジェクトは別のクラフト・パックにパックされます。 到達不能なオブジェクトは、次回の @samp{git gc} の呼び出しで通常の有効期限ルールを使用して刈り込み(prune)できます(git-gc(1) 参照)。 @samp{-k} とは互換性がありません。

@item  @samp{--cruft-expiration=<approxidate>} 
次回の @samp{git gc} の呼び出しを待つ代わりに、 @samp{<approxidate>} よりも古い到達不能オブジェクトをすぐに期限切れにします。 @samp{--cruft -d} でのみ有用です。

@item  @samp{--expire-to=<dir>} 
Write a cruft pack containing pruned objects (if any) to the directory @samp{<dir>}. This option is useful for keeping a copy of any pruned objects in a separate directory as a backup. Only useful with @samp{--cruft -d}.

@item  @samp{-l} 
@samp{--local} オプションを @samp{git pack-objects} に渡します。 git-pack-objects(1) を参照してください。

@item  @samp{-f} 
@samp{--no-reuse-delta} オプションを @samp{git-pack-objects} に渡します。 git-pack-objects(1) を参照してください。

@item  @samp{-F} 
@samp{--no-reuse-object} オプションを @samp{git-pack-objects} に渡します。 git-pack-objects(1) を参照してください。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
標準エラー・ストリームの進行状況を表示せず、かつ、 @samp{-q} オプションを @samp{git pack-objects} に渡します。 git-pack-objects(1) を参照してください。

@item  @samp{-n} 
@samp{git update-server-info} でサーバー情報を更新しないでください。このオプションは、HTTPまたはFTPを介してこのリポジトリ(またはその直接のコピー)を公開するために必要なローカルカタログファイルの更新をスキップします。 git-update-server-info(1) を参照してください。

@item  @samp{--window=<n>} 
@itemx  @samp{--depth=<n>} 
これらの2つのオプションは、パックに含まれるオブジェクトがデルタ圧縮を使用して格納される方法に影響します。オブジェクトは最初にタイプ、サイズ、およびオプションで名前で内部的にソートされ、 @samp{--window} 内の他のオブジェクトと比較されて、デルタ圧縮を使用することでスペースが節約されるかどうかが確認されます。 @samp{--depth} は最大デルタ深度を制限します。深くしすぎると、必要なオブジェクトに到達するためにデルタデータを何度も適用する必要があるため、アンパッカー側(unpacker side)のパフォーマンスに影響します。

@samp{--window} のデフォルト値は10で、 @samp{--depth} は50です。最大深度(maximum depth)は4095です。

@item  @samp{--threads=<n>} 
このオプションは @samp{git pack-objects} に渡されます。

@item  @samp{--window-memory=<n>} 
このオプションは、 @samp{--window} に加えて追加の制限を提供します。ウィンドウサイズは、メモリ内で @samp{<n>} バイトを超えないように動的に縮小されます。これは、大きなウィンドウと小さなオブジェクトが混在するリポジトリで、大きなウィンドウでメモリが不足しないようにするのに役立ちますが、小さなオブジェクトは大きなウィンドウを利用できます。 サイズには、「k」または「m」または「g」の接尾辞を付けることができます。 @samp{--window-memory=0} は、メモリ使用量を無制限にします。 デフォルトは、 @samp{pack.windowMemory} 構成変数から取得されます。 実際のメモリ使用量は、制限に git-pack-objects(1) で使用されるスレッド数を掛けたものになることに注意してください。

@item  @samp{--max-pack-size=<n>} 
各出力パックファイルの最大サイズ。 サイズには、「k」または「m」または「g」の接尾辞を付けることができます。許可される最小サイズは1MiBに制限されています。 指定した場合、複数のパックファイルが作成される可能性があります。これにより、ビットマップインデックスの作成も妨げられます。構成変数 @samp{pack.packSizeLimit} が設定されていない限り、デフォルトは無制限です。このオプションを使用すると、リポジトリが大きくなり、速度が低下する可能性があることに注意してください。 @samp{pack.packSizeLimit} の説明を参照してください。

@item  @samp{-b} 
@itemx  @samp{--write-bitmap-index} 
再パックの一部として到達可能性ビットマップインデックスを書き込みます。ビットマップは到達可能なすべてのオブジェクトを参照できる必要があるため、これは @samp{-a} または @samp{-A} または @samp{-m} とともに使用する場合にのみ意味があります。このオプションは、 @samp{repack.writeBitmaps} の設定を上書きします。 このオプションは、複数のパックファイルが作成された場合、 MIDX を書き込まない限り効果がありません(この場合、マルチパック・ビットマップが作成されます)。

@item  @samp{--pack-kept-objects} 
再パックするときは @samp{.keep} ファイルにオブジェクトを含めます。 @samp{pack-objects} が終了した後も @samp{.keep} パックを削除しないことに注意してください。これは、オブジェクトを複製する可能性があることを意味しますが、これにより、プッシュまたはフェッチが同時に発生する場合にオプションを安全に使用できます。このオプションを指定すると、ビットマップ化されたパックファイルに必要なオブジェクトが確実に含まれるため、通常、 @samp{-b} または @samp{repack.writeBitmaps} を使用してビットマップを書き込む場合にのみ役立ちます。

@item  @samp{--keep-pack=<pack-name>} 
指定されたパックを再パックから除外します。 これは、パックに @samp{.keep} ファイルがあるのと同じです。 @samp{<pack-name>} は、先頭にディレクトリがないパックファイル名です(例: @samp{pack-123.pack})。このオプションは、複数のパックを保持するために複数回指定できます。

@item  @samp{--unpack-unreachable=<when>} 
到達不能なオブジェクトのパックをほどく(loose)ときは、 @samp{<when>} より古いオブジェクトをわざわざほどきません。これは、フォローアップで行う @samp{git prune} によってすぐに剪定されるオブジェクトの書き込みを最適化するために使用できます。

@item  @samp{-k} 
@itemx  @samp{--keep-unreachable} 
@samp{-ad} と一緒に使用すると、既存のパックから到達できないオブジェクトは、削除されるのではなく、パックファイルの最後に追加されます。さらに、到達不能なlooseオブジェクトはパックされます(そしてそれらのlooseオブジェクトは削除されます)。

@item  @samp{-i} 
@itemx  @samp{--delta-islands} 
@samp{--delta-islands} オプションを @samp{git-pack-objects} に渡します。 git-pack-objects(1) を参照してください。

@item  @samp{-g=<factor>} 
@itemx  @samp{--geometric=<factor>} 
結果のパック構造を、連続する各パックに、次に大きいパックのオブジェクト数の少なくとも @samp{<factor>} 倍が含まれるように配置します。

@samp{git repack} が、等比数列を確実にするために1つに再パックする必要があるパックファイルの「切り分け」を決断することによってこれを保証します。 大きいパックファイルの多く(そのパックに含まれるオブジェクトの数による)がそのまま残るように、パックファイルの最小セットを選択します。

他の再パックモードとは異なり、梱包するオブジェクトのセットは、「ロールアップ」(rolled-up)されるパックのセットによって一意に決定されます。言い換えれば、等比数列を復元するために組み合わせる必要があると判断されたパックです。

@samp{--unpacked} が指定されている場合、ルーズオブジェクトは、到達可能性に関係なく、この「ロールアップ」に暗黙的に含まれます。 これは将来変更される可能性があります。このオプション(大幅に異なる再パックモードを意味する)は、 @samp{git repack} の他のすべてのオプションの組み合わせで機能することが保証されていません。

マルチパック・ビットマップを書き込む場合、 @samp{git repack} は結果として最大のパックを MIDX によるオブジェクト選択の優先パックとして選択します(git-multi-pack-index(1) 参照)。

@item  @samp{-m} 
@itemx  @samp{--write-midx} 
非冗長(non-redundant)パックを含むマルチパック・インデックス (git-multi-pack-index(1) 参照) を作成します。
@end table

@noindent

@chapheading CONFIGURATION

さまざまな構成変数がパッキングに影響します。 git-config(1) を参照してください(「pack」と「delta」を検索してください)。

デフォルトでは、コマンドは @samp{--delta-base-offset} オプションを @samp{git pack-objects} に渡します。これにより、通常、パックはわずかに小さくなりますが、生成されたパックは、バージョン1.4.4より古いバージョンのGitと互換性がありません。直接またはダムhttpプロトコルを介して、このような古いバージョンのGitとリポジトリを共有する必要がある場合は、構成変数 @samp{repack.UseDeltaBaseOffset} を @samp{false} に設定して再パックする必要があります。この場合、必要に応じて変換がオンザフライで実行されるため、ネイティブプロトコルを介した古いGitバージョンからのアクセスではこのオプションの影響を受けません。

デルタ圧縮は、 @samp{core.bigFileThreshold} 構成変数より大きいオブジェクト、および属性 @samp{delta} がfalseに設定されているファイルでは使用されません。

@noindent

@chapheading SEE ALSO

git-pack-objects(1) git-prune-packed(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-replace,,,Top
@chapheading Name

git-replace — オブジェクトを置き換えるためのrefsの作成、一覧表示、削除

@noindent

@chapheading Synopsis

@display
git replace [-f] <object> <replacement>
git replace [-f] --edit <object>
git replace [-f] --graft <commit> [<parent>…]
git replace [-f] --convert-graft-file
git replace -d <object>…
git replace [--format=<format>] [-l [<pattern>]]
@end display


@noindent

@chapheading DESCRIPTION

@samp{refs/replace/} 名前空間に @samp{replace} 参照を追加します。

@samp{replace} 参照の名前は、置き換えられるオブジェクトのSHA-1です。 @samp{replace} 参照の内容は、置き換えるオブジェクトのSHA-1です。

置き換えられるオブジェクトと置き換えるオブジェクトは同じタイプである必要があります。 この制限は、 @samp{-f} を使用して迂回(bypass)できます。

@samp{-f} が指定されていない限り、 @samp{replace} 参照はまだ存在していてはなりません。

置換されるオブジェクトと置換するオブジェクトに他の制限はありません。マージコミットは非マージコミットに置き換えることができ、その逆も可能です。

置換する参照は、デフォルトでは、到達可能性トラバーサル(剪定(prune)とパックと転送とfsck)実行するコマンドを除くすべてのGitコマンドで使用されます。

@samp{git} の直後に @samp{--no-replace-objects} オプションを使用すると、任意のコマンドでの置換参照の使用を無効にすることができます。

たとえば、 コミット @samp{foo} がコミット @samp{bar} に置き換えられた場合:

@example
$ git --no-replace-objects cat-file commit foo
@end example


上記は、コミット @samp{foo} に関する情報を表示します。

@example
$ git cat-file commit foo
@end example


これはコミット @samp{bar} に関する情報を表示します。

@samp{GIT_NO_REPLACE_OBJECTS} 環境変数は、 @samp{--no-replace-objects} オプションと同じ効果を達成するように設定できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-f} 
@itemx  @samp{--force} 
同じオブジェクトの既存の置換refが存在する場合、(失敗するのではなく)上書きされます。

@item  @samp{-d} 
@itemx  @samp{--delete} 
指定されたオブジェクトの既存の置換refsを削除します。

@item  @samp{--edit <object>} 
オブジェクトのコンテンツを対話的に編集します。 <object> の既存のコンテンツは一時ファイルにきれいに表示(pretty-printed)され、そのファイルでエディタが起動され、エディタの編集結果がパースされて <object> と同じタイプの新しいオブジェクトが作成されます。続いて、置換refが作成され、 <object> が新しく作成されたオブジェクトに置き換えられます。エディタの選択方法の詳細については git-var(1) を参照してください。

@item  @samp{--raw} 
編集するときにきれいに出力されたものではなく、生のオブジェクトの内容を提供します。現在、これはツリーにのみ影響し、バイナリ形式で表示されます。これは扱いが難しいですが、きれいに出力できないほど破損しているツリーを修復するときに役立ちます。バイナリデータをきれいに読み書きできるようにエディタを設定する必要がある場合があることに注意してください。

@item  @samp{--graft <commit> [<parent>...]} 
graftコミットを作成します。 <commit> と同じ内容で新しいコミットが作成されますが、その親は <commit> の親ではなく [<parent>…] になります。続けて、置換refが作成され、 <commit> が新しく作成されたコミットに置き換えられます。 @samp{--convert-graft-file} を使用して @samp{$GIT_DIR/info/grafts} ファイルを変換し、代わりに置換refsを使用します。

@item  @samp{--convert-graft-file} 
@samp{$GIT_DIR/info/grafts} のすべてのエントリに対してgraftコミットを作成し、成功するとそのファイルを削除します。目的は、現在非推奨のgraftファイルからの移行の為にユーザーを支援することです。

@item  @samp{-l <pattern>} 
@itemx  @samp{--list <pattern>} 
指定されたパターンに一致する(またはパターンが指定されていない場合はすべての)オブジェクトの置換refをリストします。引数なしで「git replace」と入力すると、すべての置換refが一覧表示されます。

@item  @samp{--format=<format>} 
リストするときに、指定の <format> を使用します。これには、「short」および「medium」および「long」のいずれかになります。 省略した場合、フォーマットはデフォルトで「short」になります。
@end table

@noindent

@chapheading FORMATS

以下の形式を使用できます:

@itemize 

@item
@samp{short}:
<置換された sha1>

@item
@samp{medium}:
<置換された sha1> → <置換する sha1>

@item
@samp{long}:
<置換された sha1> (<置換された sha1 のタイプ>) → <置換する sha1> (<置換する sha1 のタイプ>)
@end itemize

@noindent

@chapheading CREATING REPLACEMENT OBJECTS

git-hash-object(1) と git-rebase(1) と @uref{https://github.com/newren/git-filter-repo,git-filter-repo} は、他のgitコマンドの中でも特に 既存のオブジェクトから置換オブジェクトを作成するために使用されます。 @samp{--edit} オプションを @emph{git replace} と一緒に使用して、既存のオブジェクトを編集することで置換オブジェクトを作成することもできます。

コミットの文字列の一部である多くの、ブロブまたはツリーまたはコミットを置き換える場合は、コミットの置換文字列を作成してから、コミットのターゲット文字列の先端にあるコミットのみを、コミットの置換文字列の先端にあるコミットに置き換えることができます。

@noindent

@chapheading BUGS

置き換えられたブロブまたはツリーをそれらを置き換えるものと比較すると、正しく機能しません。 また、 @samp{git reset --hard} を使用して置換されたコミットに戻ると、ブランチは置換されたコミットではなく置換されたコミットに移動します。

保留中のオブジェクトに関連する「git rev-list」を使用すると、他の問題が発生する可能性があります。

@noindent

@chapheading SEE ALSO

git-hash-object(1) git-rebase(1) git-tag(1) git-branch(1) git-commit(1) git-var(1) git(1) @uref{https://github.com/newren/git-filter-repo,git-filter-repo}

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-request-pull,,,Top
@chapheading Name

git-request-pull — 保留中の変更の概要を生成します

@noindent

@chapheading Synopsis

@display
git request-pull [-p] <start> <URL> [<end>]
@end display


@noindent

@chapheading DESCRIPTION

アップストリームプロジェクトに変更をツリーにプルするように要求するリクエストを生成します。標準出力に出力される要求は、ブランチの説明で始まり、変更を要約し、どこからプルできるかを示します。

アップストリームプロジェクトには @samp{<start>} という名前のコミットがあると予想され、出力では、そのコミット以降に行った変更を @samp{<URL>`という名前のリポジトリの、}<end>` という名前のコミットまで統合するように求められます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-p} 
出力にパッチテキストを含めます。

@item  <start> 
開始コミット。これは、すでにアップストリーム履歴に存在するコミットを指定します。

@item  <URL> 
プル元のリポジトリURL。

@item  <end> 
終了コミット(省略時デフォルトはHEAD)。プルを要求している履歴の先端にあるコミットを指定します。

@samp{<URL>} で指定されたリポジトリの、ローカルにあるrefとは異なるrefの先端にコミットがある場合、「ローカル名 コロン(:) リモート名」である、 @samp{<local>:<remote>} 構文を使用することができます。
@end table

@noindent

@chapheading EXAMPLES

@samp{v1.0} リリースの上にある @samp{master} ブランチで作業を構築し、それをプロジェクトに統合したいとします。 まず、他の人が見ることができるように、その変更をパブリックリポジトリにプッシュします:

@example
git push https://git.ko.xz/project master
@end example

それから、あなたは以下のコマンドを実行します:

@example
git request-pull v1.0 https://git.ko.xz/project master
@end example

これにより、アップストリームへのリクエストが生成され、 @samp{v1.0} リリースと @samp{master} の間の変更が要約されて、パブリックリポジトリからプルされます。

ローカルにあるブランチとは名前が異なるブランチに変更をプッシュする場合、例えば、

@example
git push https://git.ko.xz/project master:for-linus
@end example

それからあなたはそれをプルするように頼むことができます

@example
git request-pull v1.0 https://git.ko.xz/project master:for-linus
@end example

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-rerere,,,Top
@chapheading Name

git-rerere — 競合するマージの記録された競合解決決定を再利用する

@noindent

@chapheading Synopsis

@display
git rerere [clear | forget <pathspec>… | diff | status | remaining | gc]
@end display


@noindent

@chapheading DESCRIPTION

比較的長期間存続するトピックブランチを使用するワークフローでは、開発者は、トピックブランチが完了するまで(「リリース」ブランチにマージされるか、アップストリームに送信されて受け入れられるまで)、同じ競合を何度も解決する必要がある場合があります。

このコマンドは、最初の手動マージにて、自動マージ結果の競合とそれに対応した手動解決結果を記録しておいて、以後の自動マージ結果の競合に、その記録した手動競合解決決定を適用することにより、この処理において開発者を支援します。

@quotation

@strong{Note}

あなたがこのコマンドを有効にするには、構成変数 @samp{rerere.enabled} を設定する必要があります。
@end quotation

@noindent

@chapheading COMMANDS

通常、「git rerere」は、引数やユーザーの介入なしで実行されます。 ただし、動作状態との対話を可能にするいくつかのコマンドがあります。

@table @asis

@item  @emph{clear} 
マージ競合解決決定を中止する場合は、rerereが使用するメタデータをリセットします。 @samp{git am [--skip|--abort]} または @samp{git rebase [--skip|--abort]} を呼び出すと、このコマンドが自動的に呼び出されます。

@item  @emph{forget} <pathspec> 
<pathspec> の現在の競合について rerere が記録した競合解決決定をリセットします。

@item  @emph{diff} 
競合解決決定の現在の状態の差分を表示します。これは、ユーザーが競合を解決している間に何が変更されたかを追跡するのに役立ちます。追加の引数は、PATHにインストールされているシステムの「diff」コマンドに直接渡されます。

@item  @emph{status} 
マージ競合解決決定がrerereで記録される競合のあるパスをプリントする。

@item  @emph{remaining} 
rerereによって自動解決されていない競合のあるパスをプリントする。これには、競合するサブモジュールなど、rerereで競合解決決定を追跡できないパスが含まれます。

@item  @emph{gc} 
ずっと前に発生した競合するマージのレコードを剪定(prune)します。デフォルトでは、15日より古い未解決の競合と、60日より古い解決済みの競合は剪定されます。これらのデフォルトは、それぞれ @samp{gc.rerereUnresolved} および @samp{gc.rerereResolved} 構成変数を介して制御されます。
@end table

@noindent

@chapheading DISCUSSION

トピックブランチが分岐してからマスターブランチ(またはアップストリーム)が触れた重複領域をトピックブランチが変更する場合、トピックブランチをアップストリームにプッシュする準備ができる前であっても、最新のマスターでテストすることをお勧めします:

@example
              o---*---o topic
             /
    o---o---o---*---o---o master
@end example


このようなテストでは、マスターとトピックを何らかの方法でマージする必要があります。これを行う1つの方法は、マスターをトピックブランチにプルすることです:

@example
        $ git switch topic
        $ git merge master

              o---*---o---+ topic
             /           /
    o---o---o---*---o---o master
@end example


@samp{*} でマークされたコミットは、同じファイルの同じ領域にアクセスします。 @samp{+} でマークされたコミットを作成するときに競合を解決する必要があります。次に、結果をテストして、進行中の作業が最新のマスターにあるもので引き続き機能することを確認できます。

このテストマージの後、トピックの作業を続行するには2つの方法があります。最も簡単なのは、テストマージコミット @samp{+} の上に構築することです。トピックブランチでの作業の準備ができたら、トピックブランチをマスターにプルするか、アップストリームにプルするように依頼します。ただし、その時点で、テストマージ @samp{+} 以降、マスターまたはアップストリームが進んでいる可能性があります。その場合、最終的なコミットグラフは以下のようになります:

@example
        $ git switch topic
        $ git merge master
        $ ... work on both topic and master branches
        $ git switch master
        $ git merge topic

              o---*---o---+---o---o topic
             /           /         \
    o---o---o---*---o---o---o---o---+ master
@end example


けれども、トピックブランチの存続期間が長い場合、トピックブランチにはそのような「マスターからのマージ」コミットが多数含まれることになり、開発履歴が不必要に乱雑になります。Linuxカーネルメーリングリストの読者は、サブシステムのメンテナが「役に立たないマージ」でいっぱいのブランチからプルするように要求したときに、Linusがテストマージの頻度が高すぎると不平を言ったことを覚えているかもしれません。

別の方法として、トピックブランチでテストマージをクリーンに保つために、テストマージを吹き飛ばし、テストマージの前に、先端の先に構築し続けることができます:

@example
        $ git switch topic
        $ git merge master
        $ git reset --hard HEAD^ ;# rewind the test merge
        $ ... work on both topic and master branches
        $ git switch master
        $ git merge topic

              o---*---o-------o---o topic
             /                     \
    o---o---o---*---o---o---o---o---+ master
@end example


これにより、トピックブランチの準備が整い、マスターブランチにマージされたときに、マージコミットが1つだけ残ります。 このマージでは、 @samp{*} でマークされたコミットによって導入された競合を解決する必要があります。ただし、この競合は、多くの場合、吹き飛ばしたテストマージを作成したときに解決した競合と同じです。 @emph{git rerere} は、以前の手動解決からの情報を使用して、この最後の競合するマージを解決するのに役立ちます。

競合する自動マージの直後に「git rerere」コマンドを実行すると、それらの中の、通常の競合マーカー @samp{<<<<<<<} と @samp{=======} と @samp{>>>>>>>} を使用して、競合する作業ツリーファイルが記録されます。後で、競合の解決が完了した後、「git rerere」を再度実行すると、これらのファイルの解決された状態が記録されます。 masterのトピックブランチへのテストマージを作成したときにこれを行ったとします。

次回、同じ競合する自動マージを確認した後、「git rerere」を実行すると、以前の競合する自動マージ、以前の手動解決、および現在の競合する自動マージの間で3方向のマージが実行されます。この3方向マージが正常に解決される場合、結果は作業ツリーファイルに書き出されるため、手動で解決する必要はありません。注意: @emph{git rerere} はインデックスファイルをそのままにしておくので、結果に満足のいく場合は、 @samp{git diff} (または @samp{git diff -c})を使用して最終的な健全性チェックを行い、そして、 @emph{git add} する必要があることに注意してください。

より便利な方法として、「git merge」は、失敗した自動マージで終了すると自動的に「git rerere」を呼び出し、「git rerere」は、新しい競合の場合は手動解決を記録し、そうでない場合は以前の手動解決を再利用します。「git commit」は、マージ結果をコミットするときに「git rerere」も呼び出します。 これが意味することは、（rerere.enabled構成変数を有効にする以外に）自分で特別なことをする必要がないということです。

この例では、テストマージを実行すると、手動の競合解決決定が記録され、記録された競合解決決定が引き続き適用可能である限り、後で更新されたマスターブランチとトピックブランチを使用して実際のマージを実行するときに再利用されます。

「git rerere」レコードの情報は、「git rebase」を実行するときにも使用されます。 テストマージを吹き飛ばし、トピックブランチで開発を続けた後:

@example
              o---*---o-------o---o topic
             /
    o---o---o---*---o---o---o---o   master

        $ git rebase master topic

                                  o---*---o-------o---o topic
                                 /
    o---o---o---*---o---o---o---o   master
@end example


@samp{git rebase master topic} を実行して、トピックをアップストリームに送信する準備ができる前に最新の状態にすることができます。これにより、3方向マージにフォールバックし、前に解決したテストマージと同じように競合します。 「git rerere」は「git rebase」によって実行され、この競合を解決するのに役立ちます。

[注] @emph{git rerere} は、ファイル内の競合マーカーに依存して競合を検出します。ファイルに競合マーカーのある行と同じように見える行がすでに含まれている場合、「git rerere」は競合解決の記録に失敗する可能性があります。これを回避するには、 gitattributes(5) の @samp{conflict-marker-size} 設定を使用できます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-reset,,,Top
@chapheading Name

git-reset — 現在のHEADを指定の状態にリセットします

@noindent

@chapheading Synopsis

@display
git reset [-q] [<tree-ish>] [--] <pathspec>…
git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>…]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]
@end display


@noindent

@chapheading DESCRIPTION

最初の3つの形式は、エントリを`<tree-ish>` からインデックスにコピーします。 最後の形式では、現在のブランチヘッド(@samp{HEAD}) を @samp{<commit>} に設定し、オプションでインデックスと作業ツリーを一致するように変更します。 @samp{<tree-ish>}/@samp{<commit>} は、すべての形式でデフォルトで @samp{HEAD} になります。

@table @asis

@item  @samp{git reset' [-q] [<tree-ish>] [--] <pathspec>...} 
@itemx  @samp{git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]} 
これらの形式は、 @samp{<pathspec>} を @samp{<tree-ish>} の状態に一致させるすべてのパスのインデックスエントリをリセットします。 (作業ツリーや現在のブランチには影響しません。)

これは、 @samp{git reset <pathspec>} が @samp{git add <pathspec>} の反対であることを意味します。 このコマンドは、 @samp{git restore [--source=<tree-ish>] --staged <pathspec>...} と同等です。

@samp{git reset <pathspec>} を実行してインデックスエントリを更新した後、 git-restore(1) を使用して、インデックスの内容を作業ツリーにチェックアウトできます。 または、 git-restore(1) を使用し、 @samp{--source} でコミットを指定すると、コミットからインデックスと作業ツリーへのパスの内容を一度にコピーできます。

@item  @samp{git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>...]} 
インデックスと @samp{<tree-ish>} (デフォルトは @samp{HEAD})の違いでハンクを対話的に選択します。 選択したハンクは、インデックスから適用を外します(apply in reverse)。

これは、 @samp{git reset -p} が @samp{git add -p} の反対であることを意味します。つまり、これを使用してハンクを選択的にリセットできます。 @samp{--patch} モードの操作方法については、 git-add(1) の「Interactive Mode」セクションを参照してください。

@item  @samp{git reset [<mode>] [<commit>]} 
This form resets the current branch head to @samp{<commit>} and possibly updates the index (resetting it to the tree of @samp{<commit>}) and the working tree depending on @samp{<mode>}. Before the operation, @samp{ORIG_HEAD} is set to the tip of the current branch. If @samp{<mode>} is omitted, defaults to @samp{--mixed}. The @samp{<mode>} must be one of the following:

@table @asis

@item  @samp{--soft} 
インデックスファイルまたは作業ツリーにはまったく触りません(しかし、すべてのモードと同様に、ヘッドを @samp{<commit>} にリセットします)。 これにより、 @samp{git status} が示すように、変更されたすべてのファイルが「コミットされる変更」(Changes to be committed)のままになります。

@item  @samp{--mixed} 
インデックスをリセットしますが、作業ツリーはリセットしません(つまり、変更されたファイルは保持されますが、コミットのマークは付けられません)。更新されていないものを報告します。 これがデフォルトのアクションです。

@samp{-N} が指定されている場合、削除されたパスはadd対象(intent-to-add)としてマークされます(git-add(1) 参照)。

@item  @samp{--hard} 
インデックスと作業ツリーをリセットします。 @samp{<commit>} 以降の作業ツリー内の追跡中のファイルへの変更はすべて破棄されます。追跡中のファイルの書き込み時に邪魔になる、追跡されていないファイルまたはディレクトリは、単に削除されます。

@item  @samp{--merge} 
インデックスをリセットし、作業ツリー内の @samp{<commit>} と @samp{HEAD} の間で異なるファイルを更新しますが、インデックスと作業ツリーの間で異なるファイル（つまり、まだ追加されていない変更があるもの）は保持します。 もし @samp{<commit>} とインデックスの間で異なるファイルに、ステージされていない変更がある場合、リセットは中断(abort)されます。

つまり、 @samp{--merge} は @samp{git read-tree -u -m <commit>} のようなことをしますが、アンマージインデックスエントリは引き継ぎます。

@item  @samp{--keep} 
インデックスエントリをリセットし、 @samp{<commit>} と @samp{HEAD} で異なる作業ツリー内のファイルを更新します。 @samp{<commit>} と @samp{HEAD} で異なるファイルにローカル変更がある場合、リセットは中止(abort)されます。

@item  @samp{--[no-]recurse-submodules} 
作業ツリーが更新される時、 @samp{--recurse-submodules} を使用すると、スーパープロジェクトに記録されたコミットに従ってすべてのアクティブなサブモジュールの作業ツリーが再帰的にリセットされ、そのコミット時にサブモジュールのHEADが切り離されるよう(detach)に設定されます。
@end table
@end table

3つのコマンドの違いについては、 git(1) の「Reset, restore and revert」を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにして、エラーのみを報告してください。

@item  @samp{--refresh} 
@itemx  @samp{--no-refresh} 
混合リセット(mixed reset)後にインデックスを更新します。 デフォルトで有効になっています。

@item  @samp{--pathspec-from-file=<file>} 
パススペックは、コマンドライン引数の代わりに @samp{<file>} で渡されます。 @samp{<file>} が正確に @samp{-} の場合、標準入力が使用されます。 Pathspec要素は、LFまたはCR/LFで区切られます。 パススペック要素は、構成変数 @samp{core.quotePath} で説明されているようにクォートできます(git-config(1) 参照)。 @samp{--pathspec-file-nul} および グローバルの @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
@samp{--pathspec-from-file} 指定時のみ意味があります。 パススペック要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <pathspec>… 
操作の影響を受けるパスを制限します。

詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  addを取り消し(undo add) 
@example
$ edit                                     (1)
$ git add frotz.c filfre.c
$ mailx                                    (2)
$ git reset                                (3)
$ git pull git://info.example.com/ nitfol  (4)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
あなたは喜んで何かに取り組んでおり、これらのファイルの変更が適切に行われていることがわかります。 あなたが @samp{git diff} を実行するときにそれらを表示したくないのは、他のファイルで作業することを計画していて、これらのファイルでの変更が気を散らすためです。

@item @pxref{CO1-2,,(2)}
誰かがあなたにプルを要求し、その変更がマージに値すると思われる場合。

@item @pxref{CO1-3,,(3)}
しかしながら、あなたはすでにインデックスをダーティにしています(つまり、インデックスが @samp{HEAD} コミットと一致していません)。 ただし、これから行うプルは @samp{frotz.c} または @samp{filfre.c} には影響しないため、これら2つのファイルのインデックスの変更を元に戻します。 作業ツリーのあなたの変更はそのまま残ります。

@item @pxref{CO1-4,,(4)}
それから、あなたは @samp{frotz.c} と @samp{filfre.c} の変更を作業ツリーに残したまま、プルしてマージできます。
@end table

@item  コミットを取り消し、再度行う(undo a commit and redo) 
@example
$ git commit ...
$ git reset --soft HEAD^      (1)
$ edit                        (2)
$ git commit -a -c ORIG_HEAD  (3)
@end example


@table @asis

@item @pxref{CO2-1,,(1)}
これは、コミットした内容が不完全であることを思い出した場合、コミットメッセージのスペルを間違えた場合、またはその両方の場合に最もよく行われます。 「リセット」前の状態で作業ツリーを残します。

@item @pxref{CO2-2,,(2)}
作業ツリーファイルを修正します。

@item @pxref{CO2-3,,(3)}
「リセット」は古いヘッドを @samp{.git/ORIG_HEAD} にコピーします。 ログメッセージから始めて、コミットをやり直します。 メッセージをさらに編集する必要がない場合は、代わりに @samp{-C} オプションを指定できます。

git-commit(1) の @samp{--amend} オプションも参照してください。
@end table

@item  コミットを取り消し(undo)、トピックブランチにします 
@example
$ git branch topic/wip          (1)
$ git reset --hard HEAD~3       (2)
$ git switch topic/wip          (3)
@end example


@table @asis

@item @pxref{CO3-1,,(1)}
あなたはいくつかのコミットをしましたが、それらが @samp{master} ブランチに入るのは時期尚早であることに気づきました。 あなたはトピックブランチでそれらを磨き続けたいので、現在の @samp{HEAD} から @samp{topic/wip} ブランチを作成します。

@item @pxref{CO3-2,,(2)}
masterブランチを巻き戻して、これら3つのコミットを取り除きます。

@item @pxref{CO3-3,,(3)}
@samp{topic/wip} ブランチに切り替えて、作業を続けます。
@end table

@item  コミットを永久に取り消す(undo commits permanently) 
@example
$ git commit ...
$ git reset --hard HEAD~3   (1)
@end example


@table @asis

@item @pxref{CO4-1,,(1)}
最後の3コミット(@samp{HEAD} と @samp{HEAD^} と @samp{HEAD~2})は悪かったので、二度と見たくありません。 あなたがこれらのコミットを他の誰かにすでに与えている場合は、これを行ってはいけません。 (そうすることの意味については、 git-rebase(1) の「RECOVERING FROM UPSTREAM REBASE」セクションを参照してください。)
@end table

@item  マージまたはプルを取り消す(undo a merge or pull) 
@example
$ git pull                         (1)
Auto-merging nitfol
CONFLICT (content): Merge conflict in nitfol
Automatic merge failed; fix conflicts and then commit the result.
$ git reset --hard                 (2)
$ git pull . topic/branch          (3)
Updating from 41223... to 13134...
Fast-forward
$ git reset --hard ORIG_HEAD       (4)
@end example


@table @asis

@item @pxref{CO5-1,,(1)}
アップストリームから更新しようとすると、多くの競合が発生しました。 あなたは現在、マージに多くの時間を費やす準備ができていなかったため、後でマージすることにしました。

@item @pxref{CO5-2,,(2)}
「プル」はマージコミットを行っていないため、 @samp{git reset--hard HEAD} の同義語である @samp{git reset --hard} は、インデックスファイルと作業ツリーから混乱を取り除きます。

@item @pxref{CO5-3,,(3)}
トピックブランチを現在のブランチにマージします。これにより、早送り(fast-forward)が行われました。

@item @pxref{CO5-4,,(4)}
しかし、あなたはそのトピックブランチがまだ一般公開の準備ができていないと判断しました。 「pull」または「merge」は常に現在のブランチの元の先端を @samp{ORIG_HEAD} に残すため、ハードにリセットするとインデックスファイルと作業ツリーがその状態に戻り、ブランチの先端がそのコミットにリセットされます。
@end table

@item  ダーティな作業ツリー内でマージまたはプルを取り消し(undo) 
@example
$ git pull                         (1)
Auto-merging nitfol
Merge made by recursive.
 nitfol                |   20 +++++----
 ...
$ git reset --merge ORIG_HEAD      (2)
@end example


@table @asis

@item @pxref{CO6-1,,(1)}
作業ツリーにローカルの変更がある場合でも、他のブランチの変更がそれらと重複していないことがわかっている場合は、「git pull」と安全に言うことができます。

@item @pxref{CO6-2,,(2)}
マージの結果を調べた後、他のブランチでの変更が不十分であることがわかる場合があります。 @samp{git reset --hard ORIG_HEAD} を実行すると、元の場所に戻ることができますが、不要なローカルの変更は破棄されます。 @samp{git reset --merge} は、ローカルの変更を保持します。
@end table

@item  Interrupted workflow 
あなたが大規模な変更をしている最中に、緊急の修正リクエストによって中断されたとします。 作業ツリー内のファイルはまだコミットできる形ではありませんが、バグをすばやく修正するには、他のブランチにアクセスする必要があります。

@example
$ git switch feature  ;# you were working in "feature" branch and
$ work work work      ;# got interrupted
$ git commit -a -m "snapshot WIP"                 (1)
$ git switch master
$ fix fix fix
$ git commit ;# commit with real log
$ git switch feature
$ git reset --soft HEAD^ ;# go back to WIP state  (2)
$ git reset                                       (3)
@end example


@table @asis

@item @pxref{CO7-1,,(1)}
このコミットは吹き飛ばされちゃうので、投げやりなログメッセージでOKです。

@item @pxref{CO7-2,,(2)}
これにより、コミット履歴から「WIP」コミットが削除され、作業ツリーがスナップショットを作成する直前の状態に設定されます。

@item @pxref{CO7-3,,(3)}
この時点で、インデックスファイルには「スナップショットWIP」としてコミットしたすべてのWIP変更がまだ含まれています。 これにより、インデックスが更新され、WIPファイルがコミットされていないものとして表示されます。

git-stash(1) も参照して下さい。
@end table

@item  Reset a single file in the index 
インデックスにファイルを追加したが、後でそれをコミットに追加したくないと判断したとします。 git resetを使用して変更を保持しながら、ファイルをインデックスから削除できます。

@example
$ git reset -- frotz.c                      (1)
$ git commit -m "Commit files in index"     (2)
$ git add frotz.c                           (3)
@end example


@table @asis

@item @pxref{CO8-1,,(1)}
これにより、ファイルは作業ディレクトリに保持されたまま、インデックスから削除されます。

@item @pxref{CO8-2,,(2)}
これにより、インデックス内の他のすべての変更がコミットされます。

@item @pxref{CO8-3,,(3)}
そのファイルをインデックスに再度追加します。
@end table

@item  以前のコミットを破棄しつつ作業ツリーの変更を保持する 
何かに取り組んでいて、それをコミットしてから、もう少し作業を続けたとして、作業ツリーにあるものは、以前にコミットしたものとは関係のない別のブランチにあるはずだと思います。 作業ツリーに変更を加えたまま、新しいブランチを開始してリセットできます。

@example
$ git tag start
$ git switch -c branch1
$ edit
$ git commit ...                            (1)
$ edit
$ git switch -c branch2                     (2)
$ git reset --keep start                    (3)
@end example


@table @asis

@item @pxref{CO9-1,,(1)}
これにより、@samp{branch1} にあなたの最初の編集がコミットされます。

@item @pxref{CO9-2,,(2)}
理想的な世界では、 あなたが @samp{branch2} (つまり、 @samp{git switch -c branch2 start})を作成して切り替えたときに、以前のコミットが新しいトピックに属していないことに気付くかもしれませんが、完璧な人は誰もいません。

@item @pxref{CO9-3,,(3)}
しかし、 あなたが @samp{branch2} に切り替えた後は、 @samp{reset --keep} を使用して不要なコミットを削除できます。
@end table

@item  コミット(a commit)を一連のコミット(a sequence of commits)に分割 
論理的に別々の変更をたくさん作成し、それらを一緒にコミットしたとします。 次に、後で、各論理チャンクを独自のコミットに関連付ける方がよい場合があると判断したとします。 あなたが git reset を使用すると、ローカルファイルの内容を変更せずに履歴を巻き戻すことができます。その後、@samp{git add -p} を使用して各コミットに含めるハンクを対話的に選択し、 @samp{git commit -c} でコミットメッセージをあらかじめ入力しておくことができます。

@example
$ git reset -N HEAD^                        (1)
$ git add -p                                (2)
$ git diff --cached                         (3)
$ git commit -c HEAD@@@{1@}                    (4)
...                                         (5)
$ git add ...                               (6)
$ git diff --cached                         (7)
$ git commit ...                            (8)
@end example


@table @asis

@item @pxref{CO10-1,,(1)}
まず、履歴をあるコミットにリセットして、元のコミットを削除しますが、すべての変更を作業ツリーに残します。 @samp{-N} を使用すると、 @samp{HEAD} で追加された新しいファイルにマークが付けられ、 @samp{git add -p} がそれらを検出できるようになります。

@item @pxref{CO10-2,,(2)}
次に、 私達は @samp{git add -p} 機能を使用して、追加するdiffハンクを対話的に選択します。 これにより、各diffハンクについて順番に尋ねられ、「はい、これを含める」、「いいえ、これを含めない」、または非常に強力な「編集」機能などの簡単なコマンドを使用できます。

@item @pxref{CO10-3,,(3)}
あなたが含めたいハンクに満足したら、 @samp{git diff --cached} を使用して、最初のコミットのために何が準備されているかを確認する必要があります。 これは、インデックスに移動され、コミットされようとしているすべての変更を示しています。

@item @pxref{CO10-4,,(4)}
次に、インデックスに保存されている変更をコミットします。 @samp{-c} オプションは、最初のコミットで開始した元のメッセージからコミットメッセージを事前入力することを指定します。 これは、再入力を避けるのに役立ちます。 @samp{HEAD@@@{1@}} は、元のリセットコミット(1変更前)の前に @samp{HEAD} が使用されていたコミットの特別な表記です。 詳細については、 git-reflog(1) を参照してください。 他の有効なコミット参照を使用することもできます。

@item @pxref{CO10-5,,(5)}
あなたは手順2〜4を複数回繰り返して、元のコードを任意の数のコミットに分割できます。

@item @pxref{CO10-6,,(6)}
さて、あなたは多くの変更をそれぞれのコミットに分割したので、残りの未コミットの変更をすべて選択するために、もはや @samp{git add} のパッチモードは使用しないかもしれません。

@item @pxref{CO10-7,,(7)}
もう一度、必要なものが含まれていることを確認してください。 また、git diffにて後でコミットする残りの変更が表示されないことを確認することもできます。

@item @pxref{CO10-8,,(8)}
そして最後に最終コミットを作成します。
@end table
@end table

@noindent

@chapheading DISCUSSION

以下の表は、実行時に何が起こるかを示しています:

@example
git reset --option target
@end example


ファイルの状態に応じて異なるリセットオプションを使用して、 @samp{HEAD} を別のコミット(@samp{target})にリセットします。

これらの表で、 @samp{A} 、@samp{B} 、@samp{C} 、@samp{D} はファイルのいくつかの異なる状態を表しています。例えば、最初のテーブルの1行目は、あるファイルが作業ツリーの状態 @samp{A} 、インデックスの状態 @samp{B} 、HEADの状態 @samp{C}、ターゲットの状態 @samp{D} にある場合、 @samp{git reset --soft target} は作業ツリーの状態 @samp{A} とインデックスの状態 @samp{B} を残したままにすることを意味しています。 これは、@samp{HEAD} (つまり、現在のブランチの先端)を @samp{target} (状態 @samp{D} のファイルがある)にリセット(つまり移動)するものです。

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 A       B     C    D     --soft   A       B     D
                          --mixed  A       D     D
                          --hard   D       D     D
                          --merge (disallowed)
                          --keep  (disallowed)
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 A       B     C    C     --soft   A       B     C
                          --mixed  A       C     C
                          --hard   C       C     C
                          --merge (disallowed)
                          --keep   A       C     C
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 B       B     C    D     --soft   B       B     D
                          --mixed  B       D     D
                          --hard   D       D     D
                          --merge  D       D     D
                          --keep  (disallowed)
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 B       B     C    C     --soft   B       B     C
                          --mixed  B       C     C
                          --hard   C       C     C
                          --merge  C       C     C
                          --keep   B       C     C
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 B       C     C    D     --soft   B       C     D
                          --mixed  B       D     D
                          --hard   D       D     D
                          --merge (disallowed)
                          --keep  (disallowed)
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 B       C     C    C     --soft   B       C     C
                          --mixed  B       C     C
                          --hard   C       C     C
                          --merge  B       C     C
                          --keep   B       C     C
@end example

@samp{reset --merge} は、競合するマージからリセットするときに使用することを目的としています。 マージ操作は、マージに関係する作業ツリーファイルが、開始前にインデックスに対してローカルな変更がないこと、そしてその結果を作業ツリーに書き出すことを保証しています。 したがって、インデックスとターゲットの間、およびインデックスと作業ツリーの間に何らかの違いが見られる場合、それは、マージ中の操作が競合で失敗した後に残した状態からリセットされていないことを意味します。 そのため、この場合は @samp{--merge} オプションを使用を許可しません。

@samp{reset --keep} は、作業ツリーの変更を維持しながら、現在のブランチの最後のコミットの一部を削除するときに使用することを目的としています。 削除するコミットの変更と保持する作業ツリーの変更の間に競合が発生する可能性がある場合、リセットは許可されません。 そのため、作業ツリーと @samp{HEAD} の間、および @samp{HEAD} とターゲットの間の両方に変更がある場合、リセットは許可されません。 安全のため、アンマージエントリがある場合もリセットは許可されません。

以下の表は、アンマージエントリがある場合に何が起こるかを示しています:

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 X       U     A    B     --soft  (disallowed)
                          --mixed  X       B     B
                          --hard   B       B     B
                          --merge  B       B     B
                          --keep  (disallowed)
@end example

@example
working index HEAD target         working index HEAD
----------------------------------------------------
 X       U     A    A     --soft  (disallowed)
                          --mixed  X       A     A
                          --hard   A       A     A
                          --merge  A       A     A
                          --keep  (disallowed)
@end example

@samp{X} は任意の状態を意味し、 @samp{U} はアンマージインデックスを意味します。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-restore,,,Top
@chapheading Name

git-restore — 作業ツリーファイルを復元します

@noindent

@chapheading Synopsis

@display
git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>…
git restore [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]
git restore (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

復元ソースからのコンテンツを使用して、作業ツリー内の指定されたパスを復元します。パスが追跡されているが、復元ソースに存在しない場合、復元ソースと一致するように削除されます。

このコマンドを使用して、 @samp{--staged} を使用してインデックスのコンテンツを復元したり、 @samp{--staged--worktree} を使用して作業ツリーとインデックスの両方を復元したりすることもできます。

デフォルトでは、 @samp{--staged} が指定されている場合、コンテンツは @samp{HEAD} から復元され、そうでない場合はインデックスから復元されます。別のコミットから復元するには、 @samp{--source} を使用します。

3つのコマンドの違いについては、 git(1) の "Reset, restore and revert" を参照してください。

!!このコマンドは実験的なものです。 動作が変わる可能性があります!!

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-s <tree>} 
@itemx  @samp{--source=<tree>} 
指定のツリーのコンテンツを使用して、作業ツリーファイルを復元します。ソースツリーに関連付けられているコミット、ブランチ、またはタグに名前を付けてソースツリーを指定するのが一般的です。

このオプションを指定しない場合で、 @samp{--staged} が指定されている場合は @samp{HEAD} から、それ以外の場合はインデックスから内容が復元されます。

特別な場合として、マージベースが1つしかない場合は、 @samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 @samp{A} と @samp{B} の片方を省略できます。その場合、省略した方はデフォルトで @samp{HEAD} になります。

@item  @samp{-p} 
@itemx  @samp{--patch} 
復元ソースと復元場所の違いでハンクを対話的に選択します。 @samp{--patch} モードの操作方法については、 git-add(1) の「Interactive Mode」セクションを参照してください。

注意: @samp{--patch} はpathspecを受け入れることができず、変更されたすべてのパスを復元するように求められることに注意してください。

@item  @samp{-W} 
@itemx  @samp{--worktree} 
@itemx  @samp{-S} 
@itemx  @samp{--staged} 
復元場所を指定します。どちらのオプションも指定されていない場合、デフォルトで作業ツリーが復元されます。 @samp{--staged} を指定すると、インデックスのみが復元されます。両方を指定すると、両方が復元されます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。フィードバックメッセージを抑制します。 @samp{--no-progress} を含んでいます。

@item  @samp{--progress} 
@itemx  @samp{--no-progress} 
@samp{--quiet} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、 @samp{--quiet} に関係なく、端末に接続されていない場合でも進行状況のレポートを有効にします。

@item  @samp{--ours} 
@itemx  @samp{--theirs} 
作業ツリー内のファイルをインデックスから復元する場合は、マージされていないパスにステージ#2(@samp{ours})または#3(@samp{theirs})を使用します。

注意: @samp{git rebase`と `git pull --rebase} での作業中、「ours」と「theirs」が入れ替わっているように見える場合があることに注意してください。 詳細については、 git-checkout(1) の同じオプションの説明を参照してください。

@item  @samp{-m} 
@itemx  @samp{--merge} 
作業ツリー上のファイルをインデックスから復元する場合は、マージされていないパスで競合するマージを再作成してください。

@item  @samp{--conflict=<style>} 
上記の @samp{--merge} オプションと同じですが、競合するハンクの表示方法を変更し、 @samp{merge.conflictStyle} 構成変数をオーバーライドします。 可能な値は、@samp{merge}(デフォルト) と @samp{diff3} と @samp{zdiff3} です。

@item  @samp{--ignore-unmerged} 
作業ツリー上のファイルをインデックスから復元するときに、マージされていないエントリがあり、 @samp{--ours} 、@samp{--theirs} 、 @samp{--merge} または @samp{--conflict} のいずれも指定されていない場合は、操作を中止しないでください。作業ツリー上のマージされていないパスはそのままになります。

@item  @samp{--ignore-skip-worktree-bits} 
スパースチェックアウトモード(sparse checkout mode)では、デフォルトでは、 @samp{<pathspec>} に一致するエントリと、 $GIT_DIR/info/sparse-checkout のスパースパターンのみが更新されます。このオプションは、スパースパターンを無視し、 @samp{<pathspec>} 内のすべてのファイルを無条件に復元します。

@item  @samp{--recurse-submodules} 
@itemx  @samp{--no-recurse-submodules} 
@samp{<pathspec>} がアクティブなサブモジュールを指定し、復元場所に作業ツリーが含まれている場合、このオプションが指定されている場合にのみサブモジュールが更新されます。この場合、その作業ツリーはスーパープロジェクトに記録されたコミットに復元されます。ローカルの変更は上書きされます。何も使用されていない場合(または @samp{--no-recurse-submodules} の場合)、サブモジュールの作業ツリーは更新されません。 git-checkout(1) と同様に、これはサブモジュールの @samp{HEAD} を切り離します(detach)。

@item  @samp{--overlay} 
@itemx  @samp{--no-overlay} 
オーバーレイモード(overlay mode)では、コマンドは復元時にファイルを削除しません。オーバーレイなしモード(no-overlay mode)では、 @samp{--source} ツリーに表示されない追跡ファイルが削除され、 @samp{<tree>} と完全に一致するようになります。 デフォルトはオーバーレイなしモード(no-overlay mode)です。

@item  @samp{--pathspec-from-file=<file>} 
pathspecは、コマンドライン引数の代わりに @samp{<file>} で渡されます。 @samp{<file>} が正確に @samp{-} の場合、標準入力が使用されます。pathspec要素はLFまたはCR/LFで区切られます。pathspec要素は、構成変数 @samp{core.quotePath} で説明されているように引用できます(git-config(1) 参照)。 @samp{--pathspec-file-nul} およびグローバルの @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
@samp{--pathspec-from-file} でのみ意味があります。pathspec要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  @samp{--} 
これより後ろの引数をオプションとして解釈しないでください。

@item  <pathspec>… 
操作の影響を受けるパスを制限します。

詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading EXAMPLES

以下のシーケンスは、 @samp{master} ブランチに切り替え、@samp{Makefile} を2つ前のリビジョンに戻し、誤って hello.c を削除して、インデックスから戻します。

@example
$ git switch master
$ git restore --source master~2 Makefile  (1)
$ rm -f hello.c
$ git restore hello.c                     (2)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
別のコミットからファイルを取り出します

@item @pxref{CO1-2,,(2)}
インデックスから hello.c を復元します。
@end table

あなたが、インデックス内のバージョンと一致するように「すべての」Cソースファイルを復元する場合は、以下のように書くことができます。

@example
$ git restore '*.c'
@end example


注意: @samp{*.c} を囲む引用符に注意してください。 ファイル @samp{hello.c} は、作業ツリーに存在しなくなった場合でも復元されます。これは、ファイルグロブがインデックス内のエントリを照合するために使用されるためです(シェルによる作業ツリー内ではありません)。

現在のディレクトリ内のすべてのファイルを復元するには

@example
$ git restore .
@end example


または、@samp{top} pathspec魔法を使用してすべての作業ツリーファイルを復元します(gitglossary(7) 参照)。

@example
$ git restore :/
@end example


@samp{HEAD} のバージョンと一致するようにインデックス内のファイルを復元するには(これは git-reset(1) を使用するのと同じです)

@example
$ git restore --staged hello.c
@end example


または、インデックスと作業ツリーの両方を復元できます(これは、 git-checkout(1) を使用する場合と同じです)。

@example
$ git restore --source=HEAD --staged --worktree hello.c
@end example


または、より実用的で読みにくい短い形式:

@example
$ git restore -s@@ -SW hello.c
@end example


@noindent

@chapheading SEE ALSO

git-checkout(1), git-reset(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-rev-list,,,Top
@chapheading Name

git-rev-list — コミットオブジェクトを新しい順に一覧表示します

@noindent

@chapheading Synopsis

@display
git rev-list [<options>] <commit>… [--] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

指定されたコミットから「親」リンクをたどることによって到達可能なコミットをリストしますが、その前に ^ が付いているコミットから到達可能なコミットは除外します。デフォルトでは、出力は時系列の逆順で表示されます。

これは集合演算と考えることができます。 コマンドラインで指定されたコミットのいずれかから到達可能なコミットのセットを形成し、 ^ が前に付いたコミットのいずれかから到達可能なコミットがそのセットから差し引かれます。差し引かれた残りのコミットは、コマンドの出力に出力されるものです。他のさまざまなオプションとパスパラメータ(pats parameters)を使用して、結果をさらに制限できます。

したがって、以下のコマンド:

@example
$ git rev-list foo bar ^baz
@end example


は、「foo または bar から到達可能であるが、 baz からは到達できないすべてのコミットをリストする」を意味します。

特別な表記 @samp{<commit1>..<commit2>} は、 @samp{^<commit1> <commit2>} の省略形として使用できます。たとえば、以下のどちらかを同じ意味で使用できます:

@example
$ git rev-list origin..HEAD
$ git rev-list HEAD ^origin
@end example


もう1つの特別な表記法は、マージに役立つ @samp{<commit1>...<commit2>} です。結果として得られるコミットのセットは、2つのオペランド間の対称差(symmetric difference)です。以下の2つのコマンドは同等です:

@example
$ git rev-list A B --not $(git merge-base --all A B)
$ git rev-list A...B
@end example


'rev-list’は、コミットの祖先グラフ作成およびトラバースする機能を提供するため、非常に重要なGitコマンドです。 このため、'git bisect’や'git repack’などのさまざまなコマンドで使用できるようにするさまざまなオプションがあります。

@noindent

@chapheading OPTIONS

@noindent

@heading Commit Limiting

ここで説明されている特別な表記法を使用してリストする必要があるコミットの範囲を指定することに加えて、追加のコミット制限が適用される場合があります。

より多くのオプションを使用すると、通常、出力がさらに制限されます(たとえば、 @samp{--since=<date1>} は @samp{<date1>} より新しいコミットに制限され、 @samp{--grep=<pattern>} と一緒に使用すると、ログメッセージに @samp{<pattern>} と一致する行があるコミットにさらに制限されます)。

注意: これらは、 @samp{--reverse} などのコミット順序およびフォーマットオプションの前に適用されることに注意してください。

@table @asis

@item  @samp{-<number>} 
@itemx  @samp{-n <number>} 
@itemx  @samp{--max-count=<number>} 
出力するコミットの数を制限します。

@item  @samp{--skip=<number>} 
コミット出力の表示を開始する前に、number 個のコミットをスキップします。

@item  --since=<date> 
@itemx  @samp{--after=<date>} 
指定の日付よりも新しいコミットを表示します。

@item  @samp{--since-as-filter=<date>} 
特定の日付より新しいすべてのコミットを表示します。 これは、特定の日付より古い最初のコミットで停止するのではなく、範囲内のすべてのコミットを訪問します。

@item  @samp{--until=<date>} 
@itemx  @samp{--before=<date>} 
指定の日付より古いコミットを表示します。

@item  @samp{--max-age=<timestamp>} 
@itemx  @samp{--min-age=<timestamp>} 
コミット出力を指定された時間範囲に制限します。

@item  @samp{--author=<pattern>} 
@itemx  @samp{--committer=<pattern>} 
コミット出力を、指定されたパターン(正規表現)に一致する作者(author)/コミッター(committer)ヘッダー行を持つものに制限します。複数の @samp{--author=<pattern>} がある場合、作者が指定されたパターンのいずれかに一致するコミットが選択されます(複数の @samp{--committer=<pattern>} の場合も同様)。

@item  @samp{--grep-reflog=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するreflogエントリを持つものに制限します。 複数の @samp{--grep-reflog} を使用すると、 指定されたパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。 @samp{--walk-reflogs} が使用されていない限り、 このオプションを使用するとエラーになります。

@item  @samp{--grep=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するログメッセージを持つものに制限します。 複数の @samp{--grep=<pattern>} を使用すると、 指定されたパターンのいずれかにメッセージが一致するコミットが選択されます(全てに一致するコミットだけを選択したい場合、@samp{--all-match} を参照してください)。

@item  @samp{--all-match} 
コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての @samp{--grep} に一致するものに制限します。

@item  @samp{--invert-grep} 
コミット出力を、 @samp{--grep=<pattern>} で指定されたパターンと一致しないログメッセージを持つものに制限します。

@item  @samp{-i} 
@itemx  @samp{--regexp-ignore-case} 
大文字小文字に関係なく、正規表現の制限パターンに一致します。

@item  @samp{--basic-regexp} 
制限パターンを基本正規表現として扱います。これがデフォルトです。

@item  @samp{-E} 
@itemx  @samp{--extended-regexp} 
制限パターンを、デフォルトの基本正規表現の代わりに拡張正規表現として扱います。

@item  @samp{-F} 
@itemx  @samp{--fixed-strings} 
制限パターンを固定文字列として扱います(パターンを正規表現として解釈しないでください)。

@item  @samp{-P} 
@itemx  @samp{--perl-regexp} 
制限パターンをPerl互換の正規表現として扱います。

これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。Gitが当該のサポート付きでコンパイルされていない場合、このオプションを提供すると、Gitが死にます(die)。

@item  @samp{--remove-empty} 
指定されたパスがツリーから見えなくなったら停止(stop)します。

@item  @samp{--merges} 
マージコミットのみを印刷します。これは @samp{--min-parents=2} とまったく同じです。

@item  @samp{--no-merges} 
複数の親を持つコミットを出力しない。これは @samp{--max-parents=1} とまったく同じです。

@item  @samp{--min-parents=<number>} 
@itemx  @samp{--max-parents=<number>} 
@itemx  @samp{--no-min-parents} 
@itemx  @samp{--no-max-parents} 
量の多少に関わらず、 とにかく複数の親コミットがあるコミットのみを表示します。特に、 @samp{--max-parents=1} は @samp{--no-merges} と同じであり、 @samp{--min-parents=2} は @samp{--merges} と同じです。 @samp{--max-parents=0} はすべてのルートコミットを提供し、 @samp{--min-parents=3} はすべてのタコ足マージ(octopus merges)を示します。

@samp{--no-min-parents} と @samp{--no-max-parents} は、これらの制限を(制限なしに)再度リセットします。同等の形式は、 @samp{--min-parents=0} (すべてのコミットに0個以上の親があります)および @samp{--max-parents=-1} (マイナスの数は上限がないことを示します)です。

@item  @samp{--first-parent} 
インクルードするコミットを探すとき、マージ・コミットの最初の親コミットのみをたどります。 このオプションは、特定のトピックブランチの進化を表示するときに、より良い概要を提供できます。トピックブランチへのマージは、時々更新されるアップストリームに調整することだけである傾向があり、このオプションを使用すると、そのようなマージによって履歴に取り込まれた個々のコミットを無視できます。

@item  @samp{--exclude-first-parent-only} 
( @samp{^} を使用して)除外するコミットを見つけるときは、 判明したマージ・コミットの最初の親コミットのみに従います。 任意のマージが有効なトピック・ブランチの変更になる可能性がある場合、 これを使用して、 リモート・ブランチから分岐したポイントからトピック・ブランチ内の一連の変更を見つけることができます。

@item  @samp{--not} 
次に現れる @samp{--not} までの間、後続のすべてのリビジョン指定子の @samp{^}(カレット)接頭辞(またはその欠如)の意味を逆にします。

@item  @samp{--all} 
@samp{refs/} 内のすべてのrefが HEAD とともに、コマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--branches[=<pattern>]} 
@samp{refs/heads} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--tags[=<pattern>]} 
@samp{refs/tags} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合は、指定されたシェルグロブ(shell glob)に一致するタグにタグを制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--remotes[=<pattern>]} 
@samp{refs/remotes} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、リモート追跡ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--glob=<glob-pattern>} 
シェルグロブ <glob-pattern> に一致するすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。先頭の @samp{refs/} は、欠落している場合は自動的に先頭に追加されます。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--exclude=<glob-pattern>} 
次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} が別の方法で考慮する <glob-pattern> に一致するrefを含めないでください。このオプションを繰り返すと、次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} オプションまで除外パターンが蓄積されます(他のオプションまたは引数は、蓄積されたパターンをクリアしません)。

与えられたパターンは、それぞれ @samp{--branches} または @samp{--tags} または @samp{--remotes} に適用される場合、 @samp{refs/heads} または @samp{refs/tags} または @samp{refs/remotes} で始まるべきではありません。 @samp{--glob} または @samp{--all} に適用する場合は、 @samp{refs/} で始める必要があります。末尾の "/*" を意図している場合は、明示的に指定する必要があります。

@item  @samp{--exclude-hidden=[fetch|receive|uploadpack]} 
Do not include refs that would be hidden by @samp{git-fetch}, @samp{git-receive-pack} or @samp{git-upload-pack} by consulting the appropriate @samp{fetch.hideRefs}, @samp{receive.hideRefs} or @samp{uploadpack.hideRefs} configuration along with @samp{transfer.hideRefs} (see git-config(1)). This option affects the next pseudo-ref option @samp{--all} or @samp{--glob} and is cleared after processing them.

@item  @samp{--reflog} 
reflogsで言及されているすべてのオブジェクトがコマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--alternate-refs} 
代替リポジトリのref先端として言及されているすべてのオブジェクトがコマンドラインにリストされているかのように見せかけます。 代替リポジトリは、 オブジェクトディレクトリが @samp{objects/info/alternates} で指定されているリポジトリです。 インクルードされたオブジェクトのセットは、 @samp{core.alternateRefsCommand} などによって変更できます。 git-config(1)を参照してください。

@item  @samp{--single-worktree} 
デフォルトでは、 作業ツリーが複数ある場合、 @samp{--all} と @samp{-reflog} と @samp{--indexed-objects} では、 すべての作業ツリーが検査されます(git-worktree(1)を参照)。 このオプションは、 現在の作業ツリーのみを調べるように強制します。

@item  @samp{--ignore-missing} 
入力に無効なオブジェクト名が含まれている場合、そもそもその不正な入力が行われていないかのように見せかけます。

@item  @samp{--stdin} 
In addition to getting arguments from the command line, read them for standard input as well. This accepts commits and pseudo-options like @samp{--all} and @samp{--glob=}. When a @samp{--} separator is seen, the following input is treated as paths and used to limit the result.

@item  @samp{--quiet} 
標準出力には何も出力しないでください。この形式は主に、呼び出し元が終了ステータスをテストして、オブジェクトの範囲が完全に接続されているかどうかを確認できるようにすることを目的としています。出力をフォーマットする必要がないため、stdoutを`/dev/null`にリダイレクトするよりも高速です。

@item  @samp{--disk-usage} 
@itemx  @samp{--disk-usage=human} 
通常の出力を抑制します。代わりに、選択したコミットまたはオブジェクトによってディスク上のストレージに使用されたバイトの合計を出力します。これは、出力が(特に @samp{--use-bitmap-index} を伴った場合)はるかに高速に実行されることを除いて、出力を @samp{git cat-file --batch-check='%(objectsize:disk)'} にパイプすることと同じです。 "on-disk storage" の意味する制限については、 git-cat-file(1) の「CAVEATS」を参照してください。 オプションの値 @samp{human} を使用すると、ディスク上のストレージ・サイズが人間が読み取れる文字列で表示されます(例: 12.24 Kib、3.50 Mib など)。

@item  @samp{--cherry-mark} 
@samp{--cherry-pick}（以下を参照）と同様ですが、同等のコミットを省略せずに @samp{=} と印し、同等でないコミットを @samp{+} と印します。

@item  @samp{--cherry-pick} 
コミットの組を対称差(symmetric difference)に制限する場合、「反対側」の別のコミットと同じ変更を導入するコミットを省略します。

たとえば、@samp{A} と @samp{B} の2つのブランチがある場合、それらの片側だけですべてのコミットを一覧表示する通常の方法は、 @samp{--left-right} を使用することです(@samp{--left-right} オプションの説明の以下の例を参照してください)。ただし、他のブランチからは(ブランチAと重複しない)厳選されたコミットが表示されます(たとえば、「3rd onb」はブランチAからチェリーピックされる可能性があります)。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。

@item  @samp{--left-only} 
@itemx  @samp{--right-only} 
リストは、 対称差のそれぞれの側でのみコミットします。 つまり、 @samp{--left-right} で @samp{<} と印されるのだけか、あるいは @samp{--left-right} で @samp{>} と印されるものだけです。

たとえば、 @samp{--cherry-pick --right-only A...B} は、 @samp{A} にある、 または @samp{A} のコミットとパッチと同等のコミットを @samp{B} から省略します。 つまり、 これは @samp{git cherry A B} からの @samp{+} コミットをリストします。 より正確に書くと、 @samp{--cherry-pick --right-only --no-merges} により正確なリストを提供します。

@item  @samp{--cherry} 
@samp{--right-only --cherry-mark --no-merges} の同義語です。 出力を私たちの側のコミットに制限し、 フォークされた履歴の反対の側に適用されたものを、 @samp{git cherry upstream mybranch} と同様に @samp{git log --cherry upstream...mybranch} でマークするのに役立ちます。

@item  @samp{-g} 
@itemx  @samp{--walk-reflogs} 
コミットの祖先チェーンをたどる代わりに、 reflogエントリを最新のものから古いものに移動します。 このオプションを使用する場合、 除外するコミットを指定することはできません(つまり、 @samp{^commit} や @samp{commit1..commit2} や @samp{commit1...commit2} 表記は使用できません)。

(明らかな理由で、)@samp{oneline} と @samp{reference} 以外の @samp{--pretty} 形式では、 これにより、 出力にreflogから取得された2行の追加情報が含まれます。 出力のreflog指定子は、 @samp{ref@@@{Nth@}} (@samp{Nth} はreflogの逆時系列インデックス(reverse-chronological index))または @samp{ref@@@{timestamp@}} (そのエントリのタイムスタンプ付き)として表示されます。表示は下記のいくつかのルールに依存します:

@enumerate 

@item
開始点が @samp{ref@@@{Nth@}} として指定されている場合は、インデックス形式を表示します。

@item
開始点が @samp{ref@@@{now@}} として指定されている場合は、タイムスタンプ形式を表示します。

@item
上記のどちらも使用されていないが、コマンドラインで @samp{--date} が指定されている場合は、 @samp{--date} で要求された形式でタイムスタンプを表示します。

@item
それ以外の場合は、インデックス形式を表示します。
@end enumerate

@samp{--pretty = oneline} では、コミットメッセージの前にこの情報が同じ行に付けられます。このオプションを @samp{--reverse} と組み合わせることはできません。 git-reflog(1)も参照してください。

@samp{--pretty=reference} では、この情報はまったく表示されません。

@item  @samp{--merge} 
マージが失敗した後、競合があり、マージするすべてのheadに存在しないファイルに関連(touch)するrefを表示します。

@item  @samp{--boundary} 
除外された境界コミットを出力します。 境界コミットの前には @samp{-} が付いています。

@item  @samp{--use-bitmap-index} 
(使用可能な場合は、)パックビットマップインデックスを使用して、トラバーサルを高速化しようと試みます。 @samp{--objects} でトラバースする場合、ツリーとブロブには関連するパスが出力されないことに注意してください。

@item  @samp{--progress=<header>} 
オブジェクトが対称になるときに、stderrに進捗レポートを表示します。 @samp{<header>} テキストは、進行状況が更新されるたびに印刷されます。
@end table

@noindent

@heading History Simplification

特定の<path>を変更するコミットなど、履歴の一部のみに関心がある場合があります。ただし、「履歴の簡略化」(History Simplification)は2つの部分から成ります。履歴を簡略化するためにはさまざまな戦略があるためです。その1つはコミットの選択であり、もう1つはそれを行う方法です。

以下のオプションは、表示するコミットを選択します:

@table @asis

@item  <paths> 
指定された<パス>を変更するコミットが選択されます。

@item  @samp{--simplify-by-decoration} 
いくつかのブランチまたはタグによって参照されるコミットが選択されます。
@end table

注意: 意味のある重要な履歴のために、追加のコミットを表示できることに注意してください。

以下のオプションは、簡略化の実行方法に影響します。

@table @asis

@item  Default mode 
履歴を、ツリーの最終状態を説明する最も単純な履歴に単純化します。最終結果が同じである場合(つまり、同じコンテンツのブランチをマージする場合)、いくつかの傍流ブランチ(side branches)を削除するため、最も単純です。

@item  @samp{--show-pulls} 
デフォルトモードからのすべてのコミットを含めますが、最初の親へのTREESAMEではなく、後の親へのTREESAMEであるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに役立ちます。(訳注:TREESAME=pathspecが全く同一であるツリー)

@item  @samp{--full-history} 
デフォルトモードと同じですが、一部の履歴を削除しません。

@item  @samp{--dense} 
選択したコミットのみが表示され、重大で意味のある履歴を持つコミットもいくつか表示されます。

@item  @samp{--sparse} 
簡略化された履歴内のすべてのコミットが表示されます。

@item  @samp{--simplify-merges} 
このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除するための`--full-history`への追加オプション。

@item  @samp{--ancestry-path[=<commit>]} 
表示するコミットの範囲を指定すると(例: @samp{commit1..commit2} または @samp{commit2 ^commit1})、その範囲内で <commit> の祖先、<commit> の子孫、または <commit> 自身であるコミットのみを表示します。 コミットが指定されていない場合は、@samp{commit1} (範囲の除外部分) を <commit> として使用します。 複数回渡すことができます。 その場合、あるコミットが指定されたコミットのいずれかであるか、それらのいずれかの祖先または子孫である場合、そのコミットは含まれます。
@end table

より詳細な説明は以下のとおりです。

<paths> として @samp{foo} を指定したとします。 @samp{foo} !TREESAME を変更するコミットを呼び出し、残りをTREESAMEと呼びます。( @samp{foo} のためにフィルタリングされた差分では、それぞれ異なって見えたりたり等しく見えたりします。）

以下、簡略化設定の違いを説明するために、同じ履歴例を使います。このコミットグラフでは、ファイル @samp{foo} をフィルタリングしていると想定しています:

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \   /   /   /   /   /
          `-------------'   X
@end example


履歴 A---Q の水平線は、各マージの最初の親と見なされます。その各コミットは以下のとおりです:

@itemize 

@item
@samp{I} は最初のコミットであり、ファイル foo が内容 “asdf” で存在し、ファイル quux は内容 “quux” で存在します。最初のコミットは空のツリーと比較されるため、@samp{I} は !TREESAME です。

@item
@samp{A} では、 foo には “foo” だけが含まれています。

@item
@samp{B} には @samp{A} と同じ変更が含まれています。そのマージ @samp{M} は些細なことであり、したがってすべての親にとって TREESAME です。

@item
@samp{C} は @samp{foo} を変更しませんが、そのマージ @samp{N} はそれを “foobar” に変更するので、どの親にとっても TREESAME ではありません。

@item
@samp{D} は @samp{foo} を “baz” に設定します。そのマージ @samp{O} は、 @samp{N} と @samp{D} から “foobarbaz” への文字列を結合します。つまり、どの親にとっても TREESAME ではありません。

@item
@samp{E} は @samp{quux} を “xyzzy” に変更し、そのマージ @samp{P} は文字列を “quuxxyzzy” に結合します。 @samp{P} は @samp{O} に対して TREESAME ですが、 @samp{E} に対してはそうではありません。

@item
@samp{X} は、新ファイル @samp{side} を追加し、 @samp{Y} がそれを変更した独立したルートコミットです。 @samp{Y} は @samp{X} へのTREESAMEです。そのマージ @samp{Q} は @samp{P} に @samp{side} を追加し、 @samp{Q} は @samp{P} にはTREESAMEですが、@samp{Y} に対してはそうではありません。
@end itemize

@samp{rev-list} は、 @samp{--full-history} および/または、( @samp{--parents} または @samp{--children} を介して)親の書き換えが使用されているかどうかに基づいて、コミットを含めたり除外したりして、履歴を逆方向にウォークスルーします。以下の設定が可能です。

@table @asis

@item  Default mode 
コミットは、どの親に対してもTREESAMEでない場合に含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。コミットがマージであり、一方の親に対するTREESAMEであった場合は、その親のみをフォローします。(TREESAMEの親が複数ある場合でも、そのうちの1つだけをフォローします)。それ以外の場合は、すべての親をフォローします。

これにより、以下のようになります:

@example
          .-A---N---O
         /     /   /
        I---------D
@end example


TREESAMEの親のみに従うルールが利用可能な場合は、 @samp{B} を検討対象から完全に削除したことに注意してください。 @samp{C} は @samp{N} を介して考慮されましたが、しかしそれはTREESAMEです。ルートコミットは空のツリーと比較されるため、 @samp{I} は !TREESAME です。

親子関係は @samp{--parents} でのみ表示されますが、デフォルトモードで選択されたコミットには影響しないため、親の行を示しました。

@item  @samp{--full-history without parent rewriting} 
このモードは、デフォルトとはある一点で異なります。つまり、いずれかの親に対してTREESAMEであっても、常にマージのすべての親に従います。マージの複数の側にコミットが含まれている場合でも、これはマージ自体が含まれていることを意味するものではありません！ 例では以下のようになります。

@example
        I  A  B  N  D  O  P  Q
@end example


@samp{M} は、両方の親にとってTREESAMEであるため、除外されました。 @samp{E} と @samp{C} と @samp{B} をすべて巡りましたが、 @samp{B} だけが !TREESAME だったので、他は表示されません。

注意: 親の書き換え(rewrite)がないと、コミット間の親子関係について話す(talk)ことは実際には不可能であるため、それらが切断されている(disconnected)ことを示していることに注意してください。

@item  @samp{--full-history with parent rewriting} 
通常のコミットは !TREESAME の場合にのみ含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。

マージは常に含まれます。ただし、親リストは書き直されます。各親に沿って、自分自身に含まれていないコミットを削除します。 これにより以下のようになります。

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /
        I     B   /   D   /
         \   /   /   /   /
          `-------------'
@end example


上記を書き直さずに @samp{--full-history} と比較してください。 @samp{E} はTREESAMEであるため削除されましたが、Pの親リストは @samp{E} の親 @samp{I} を含むように書き直されていることに注意してください。 @samp{C} と @samp{N} および @samp{X} と @samp{Y} と @samp{Q} についても同じことが起こりました。
@end table

上記の設定に加えて、あなたはTREESAMEが包含に影響を与えるかどうかを変更できます:

@table @asis

@item  @samp{--dense} 
巡ったコミットは、親にとってTREESAMEでない場合に含まれます。

@item  @samp{--sparse} 
巡ったすべてのコミットが含まれます。

@samp{--full-history} がなくても、これによりマージが単純化されることに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側を巡ることはありません。

@item  @samp{--simplify-merges} 
最初に、親を書き換えた @samp{--full-history} と同じ方法で履歴グラフを作成します(上記を参照)。

それから、以下のルールに従って、各コミット @samp{C} を最終履歴内の置換 @samp{C'} に単純化します:

@itemize 

@item
@samp{C'} を @samp{C} にセットします。

@item
@samp{C'} の各親 @samp{P} をその簡略化された @samp{P'} に置き換えます。その過程で、他の親の祖先であるか、ルートである親を削除すると、TREESAMEが空のツリーにコミットされ、重複が削除されますが、TREESAMEであるすべての親を削除しないように注意してください。

@item
この親の書き換え後、 @samp{C'} がルートまたはマージコミット(0または >1 の親を持つ)、境界コミット、または !TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。
@end itemize

この効果は、親の書き換えを使用した @samp{--full-history} と比較することで最もよく示されます。例は以下のようになります:

@example
          .-A---M---N---O
         /     /       /
        I     B       D
         \   /       /
          `---------'
@end example


注意: @samp{--full-history} に対する @samp{N} と @samp{P} と @samp{Q} の主な違いに注意してください:

@itemize 

@item
@samp{N} の親リストは、他の親 @samp{M} の祖先であるため、 @samp{I} が削除されました。それでも、 !TREESAME なので @samp{N} が残りました。

@item
@samp{P} の親リストも同様に @samp{I} が削除されました。 @samp{P} は、親が1つで TREESAMEであるため、完全に削除されました。

@item
@samp{Q} の親リストでは、 @samp{Y} が @samp{X} に簡略化されていました。その後、 @samp{X} はTREESAMEルートであったため、削除されました。 @samp{Q} は、親が1つで TREESAMEであるため、完全に削除されました。
@end itemize
@end table

利用可能な別の簡略化モードがあります:

@table @asis

@item  @samp{--ancestry-path[=<commit>]} 
表示されるコミットを <commit> の祖先、または <commit> の子孫、または <commit> 自身に制限します。

ユースケースの例として、以下のコミット履歴について考えます:

@example
            D---E-------F
           /     \       \
          B---C---G---H---I---J
         /                     \
        A-------K---------------L--M
@end example


通常の @samp{D..M} は、 @samp{M} の祖先であるコミットのセットを計算しますが、 @samp{D} の祖先であるコミットは除外します。 これは、「 @samp{M} には @samp{D} には存在しなかったものがある」という意味で、 @samp{D} 以降の @samp{M} に至るまでの歴史に何が起こったのかを知るのに役立ちます。この例の結果は、 @samp{A} と @samp{B} (そしてもちろん @samp{D} 自体)を除くすべてのコミットになります。

ただし、 @samp{M} のコミットが @samp{D} で入ったバグで汚染されており、修正が必要な場合は、実際には @samp{D} の子孫である @samp{D..M} のサブセットのみを表示する必要があります。つまり、 @samp{C} と @samp{K} を除外します。これはまさに @samp{--ancestry-path} オプションが行うことです。これを @samp{D..M} 範囲に適用すると、以下のようになります:

@example
                E-------F
                 \       \
                  G---H---I---J
                               \
                                L--M
@end example


@samp{--ancestry-path} の代わりに @samp{--ancestry-path=D} を使用することもできます。これは、@samp{D..M} 範囲に適用された場合と同じことを意味しますが、より明示的です。

代わりに、この範囲内の特定のトピックに関心があり、そのトピックによって影響を受けるすべてのコミットに関心がある場合、祖先パスにそのトピックを含む @samp{D..M} のサブセットのみを表示したい場合があります。 たとえば、@samp{--ancestry-path=H D..M} を使用すると、以下のようになります:

@example
                E
                 \
                  G---H---I---J
                               \
                                L--M
@end example


一方、@samp{--ancestry-path=K D..M} は以下のようになります

@example
                K---------------L--M
@end example

@end table

別のオプション @samp{--show-pulls} について説明する前に、新しいサンプル履歴を作成する必要があります。

簡略化された履歴を見るときにユーザーが直面する一般的な問題は、ファイルを変更したことがわかっているコミットが、ファイルの簡略化された履歴に表示されないことです。そこで、新しい例を示し、その場合に @samp{--full-history} や @samp{--simplify-merges} などのオプションがどのように機能するかを示しましょう。

@example
          .-A---M-----C--N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`-Z'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `---Y--'
@end example


この例では、 @samp{I} が @samp{file.txt} を作成し、それが @samp{A} と`B` と @samp{X} にてさまざまな方法で変更されたとします。ひとり親のコミット @samp{C} と @samp{Z} と @samp{Y} は @samp{file.txt} を変更していません。マージコミット @samp{M} は、マージの競合を解決して、 @samp{A} と @samp{B} の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。ただし、マージコミット @samp{R} は、 @samp{M} の @samp{file.txt`の内容を無視し、 `X} の @samp{file.txt} の内容のみを取得することによって作成されました。 したがって、 @samp{R} は @samp{X} へのTREESAMEですが、 @samp{M} はそうではありません。最後に、 @samp{N} を作成するための自然なマージ解決は、 @samp{R} で @samp{file.txt} の内容を取得することです。したがって、 @samp{N} は @samp{C} ではなく @samp{R} へのTREESAMEです。マージコミット @samp{O} と @samp{P} は、最初の親にはTREESAMEですが、2番目の親である @samp{Z} と @samp{Y} にはついてはそうではありません。

デフォルトモードを使用する場合、 @samp{N} と @samp{R} は両方ともTREESAMEの親を持っているため、これらのエッジはウォークされ、他のエッジは無視されます。結果の履歴グラフは以下のとおりです:

@example
        I---X
@end example


@samp{--full-history} を使用する場合、Gitはすべてのエッジを巡ります。これにより、コミット @samp{A} と @samp{B} と マージ @samp{M} が検出されますが、マージコミット @samp{O} と @samp{P} も明らかになります。 親を書き換えると、結果のグラフは以下のようになります:

@example
          .-A---M--------N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`--'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `------'
@end example


ここで、マージコミット @samp{O} と @samp{P} は、実際には @samp{file.txt} への変更を提供しなかったため、余分なノイズを提供します。古いバージョンの @samp{file.txt} に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です。 @samp{--full-history} の結果には、関連のない多くのマージが表示されます。

@samp{--simplify-merges} オプションを使用すると、コミット @samp{O} と @samp{P} が結果から消えます。 これは、 @samp{O} と @samp{P} の書き直された2番目の親が、最初の親から到達可能であるためです。これらのエッジが削除されると、コミットは、親にとってTREESAMEである単一の親のコミットのように見えます。これはコミット @samp{N} にも発生し、以下のような履歴ビューが表示されます:

@example
          .-A---M--.
         /     /    \
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


このビューでは、 @samp{A} と @samp{B} と @samp{X} からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ @samp{M} とそれほど慎重に解決されていないマージ @samp{R} も表示されます。これは通常、コミット @samp{A} と @samp{B} がデフォルトのビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。

最初の問題はパフォーマンスです。以前のオプションとは異なり、 @samp{--simplify-merges} オプションでは、単一の結果を返す前にコミット履歴全体をウォークする必要があります。これにより、非常に大規模なリポジトリでこのオプションを使用するのが難しくなる可能性があります。

2番目の問題は監査の1つです。多くの寄稿者が同じリポジトリで作業している場合、どのマージコミットが重要なブランチに変更を導入したかが重要です。上記の問題のあるマージ @samp{R} は、重要なブランチにマージするために使用されたマージコミットではない可能性があります。 代わりに、マージ @samp{N} を使用して @samp{R} と @samp{X} を重要なブランチにマージしました。このコミットには、変更 @samp{X} がコミットメッセージの @samp{A} と @samp{B} からの変更を上書きするようになった理由に関する情報が含まれている可能性があります。

@table @asis

@item  @samp{--show-pulls} 
デフォルトの履歴に表示されるコミットに加えて、最初の親にはTREESAMEではなく、後の親にはTREESAMEである各マージコミットを表示します。

マージコミットが @samp{--show-pulls} に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で @samp{--show-pulls} を使用すると(他のオプションは使用しない場合、)結果のグラフは行かのようになります:

@example
        I---X---R---N
@end example


ここで、コミット @samp{X} と @samp{R} をそれぞれベースブランチにプルしたため、マージコミット @samp{R} と @samp{N} が含まれています。これらのマージは、コミット @samp{A} と @samp{B} がデフォルトの履歴に表示されない理由です。

@samp{--show-pulls} が @samp{--simplify-merges} とペアになっている場合、グラフには必要なすべての情報が含まれます:

@example
          .-A---M--.   N
         /     /    \ /
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


@samp{M} は @samp{R} から到達可能であるため、 @samp{N} から @samp{M} へのエッジが単純化されていることに注意してください。ただし、 @samp{N} は、変更 @samp{R} をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。
@end table

@samp{--simplify-by-decoration} オプションを使用すると、タグで参照されていないコミットを省略して、履歴のトポロジの全体像のみを表示できます。コミットは、(1)タグによって参照されている場合、または (2)コマンドラインで指定されたパスの内容を変更した場合に、!TREESAMEとしてマークされます(つまり、上記の履歴簡略化ルールの後に保持されます)。他のすべてのコミットはTREESAMEとしてマークされます(簡略化される可能性があります)。

@noindent

@heading Bisection Helpers

@table @asis

@item  @samp{--bisect} 
含まれるコミットと除外されるコミットのほぼ中間にある1つのコミットオブジェクトに出力を制限します。(存在する場合)bad bisection ref @samp{refs/bisect/bad} が含まれるコミットに追加され、（存在する場合)good bisection ref @samp{refs/bisect/good-*} が除外されるコミットに追加されることに注意してください。したがって、 @samp{refs/bisect/} にrefsがないと仮定すると、

@example
        $ git rev-list --bisect foo ^bar ^baz
@end example


は、2つのコマンドの出力である中間点(midpoint)を出力します

@example
        $ git rev-list foo ^midpoint
        $ git rev-list midpoint ^bar ^baz
@end example


上記は、ほぼ同じ長さになります。 したがって、回帰を導入する変更を見つけることは、バイナリ検索(binary search)に還元されます。コミットチェーンの長さが1になるまで、新しい中間点(midpoint)を繰り返し生成してテストします。

@item  @samp{--bisect-vars} 
これは、 @samp{refs/bisect/} 内のrefが使用されないこと、およびシェルによって評価される準備ができているテキストを出力することを除いて、 @samp{--bisect} と同じように計算されます。これらの行は、中間点リビジョンの名前を変数 @samp{bisect_rev} に割り当て、 @samp{bisect_rev} が @samp{bisect_nr} にテストされた後にテストされるコミットの予想数、 @samp{bisect_rev} が @samp{bisect_good`に適していることが判明した場合にテストされるコミットの予想数、 `bisect_rev} が @samp{bisect_bad} に不適切であることが判明した場合にテストされるコミットの予想数、および現在 @samp{bisect_all} に二等分しているコミットの数です。

@item  @samp{--bisect-all} 
これにより、含まれるコミットと除外されるコミットの間のすべてのコミットオブジェクトが、含まれるコミットと除外されるコミットまでの距離順に出力されます。 @samp{refs/bisect/} のrefは使用されません。それらから最も遠いものが最初に表示されます。(これは @samp{--bisect} によって表示される唯一のものです。)

これは、何らかの理由(たとえば、コンパイルできない場合など)でそれらの一部をテストすることを避けたい場合に、テストするための適切なコミットを簡単に選択できるため便利です。

このオプションは @samp{--bisect-vars} と一緒に使用できます。この場合、ソートされたすべてのコミットオブジェクトの後に、 @samp{--bisect-vars} が単独で使用された場合と同じテキストが表示されます。
@end table

@noindent

@heading Commit Ordering

デフォルトでは、コミットは新しい順に表示されます。

@table @asis

@item  @samp{--date-order} 
すべての子が表示されるまで親を表示しませんが、それ以外の場合はコミットタイムスタンプの順序でコミットを表示します。

@item  @samp{--author-date-order} 
すべての子が表示されるまで親を表示しませんが、それ以外の場合は、作者(author)のタイムスタンプ順にコミットを表示します。

@item  @samp{--topo-order} 
すべての子が表示されるまで親を表示せず、複数の履歴行が混在するコミットを表示しないようにします。

たとえば、以下のようなコミット履歴があります:

@example
    ---1----2----4----7
        \              \
         3----5----6----8---
@end example


ここで、数字はコミットタイムスタンプの順序を示し、 @samp{gitrev-list} と @samp{--date-order} のある友達は、タイムスタンプの順序でコミットを示します。つまり、8 7 6 5 4 3 2 1

@samp{--topo-order} を使用すると、8 6 5 3 7 4 2 1（または8 7 4 2 6 5 3 1）が表示されます。2つの並列開発トラックからのコミットが混在して表示されないようにするために、いくつかの古いコミットが新しいコミットの前に表示されます。

@item  @samp{--reverse} 
表示するように選択したコミットを逆の順序で出力します(上記の Commit Limiting 節を参照)。 @samp{--walk-reflogs} と組み合わせることはできません。
@end table

@noindent

@heading Object Traversal

これらのオプションは、主にGitリポジトリのパッキングを対象としています。

@table @asis

@item  @samp{--objects} 
Print the object IDs of any object referenced by the listed commits. @samp{--objects foo ^bar} thus means “send me all object IDs which I need to download if I have the commit object @emph{bar} but not @emph{foo}”. See also @samp{--object-names} below.

@item  @samp{--in-commit-order} 
ツリーIDとブロブのIDをコミット順に出力します。 ツリーIDとブロブのIDは、コミットによって最初に参照された後に出力されます。

@item  @samp{--objects-edge} 
@samp{--objects} に似ていますが、接頭辞 “-” 文字が付いた除外されたコミットのIDも出力します。これは git-pack-objects(1) によって使用され、ネットワークトラフィックを削減するために、これらの除外されたコミットに含まれるオブジェクトに基づいてオブジェクトを削除された形式で記録する「薄い」パック(thin pack)を構築します。

@item  @samp{--objects-edge-aggressive} 
@samp{--objects-edge} に似ていますが、時間がかかるという犠牲を払って、除外されたコミットを見つけためにもっともっと頑張ります。これは、@samp{--objects-edge} の代わりに使用されて浅いリポジトリ(shallow repositories)用の「薄い」パック(thin pack)を構築します。

@item  @samp{--indexed-objects} 
インデックスで使用されるすべてのツリーとブロブがコマンドラインにリストされているかのように見せかけます。 注意: たぶんあなたは一緒に @samp{--objects} も使用したいと思うでしょう。

@item  @samp{--unpacked} 
@samp{--objects} と一緒の時のみ役立ちます。パックに含まれていないオブジェクトIDを出力します。

@item  @samp{--object-names} 
Only useful with @samp{--objects}; print the names of the object IDs that are found. This is the default behavior. Note that the "name" of each object is ambiguous, and mostly intended as a hint for packing objects. In particular: no distinction is made between the names of tags, trees, and blobs; path names may be modified to remove newlines; and if an object would appear multiple times with different names, only one name is shown.

@item  @samp{--no-object-names} 
@samp{--objects} と一緒の時のみ役立ちます。見つかったオブジェクトIDの名前は出力されません。これにより、 @samp{--object-names} が反転します。 このフラグを使用すると、 git-cat-file(1) などのコマンドで出力をより簡単に解析できます。

@item  @samp{--filter=<filter-spec>} 
@samp{--objectsほげほげ} のどれかと一緒の時のみ役立ちます。印刷されたオブジェクトのリストからオブジェクト(通常はブロブ)を省略します。 <filter-spec> は、以下のいずれかになります:

@samp{--filter=blob:none} の形式では、すべてのブロブが省略されます。

@samp{--filter=blob:limit=<n>[kmg]} の形式では、nバイトまたは指定の単位より大きいブロブが省略されます。nはゼロの場合があります。 接尾辞kとmとgを使用して、KiBまたはMiBまたはGiBの単位にすることができます。 たとえば、 @samp{blob:limit=1k} は @samp{blob:limit=1024} と同じです。

@samp{--filter=object:type=(tag|commit|tree|blob)} の形式では、要求されたタイプではないすべてのオブジェクトが省略されます。

@samp{--filter=sparse:oid=<blob-ish>} の形式は、ブロブ(またはブロブ式) <blob-ish> に含まれるsparse-checkout仕様を使用して、 要求されたrefsでsparse checkoutに必要のないブロブを省略します。

@samp{--filter=tree:<depth>} の形式は、ルートツリーからの深さが @samp{>= <depth>} (オブジェクトがトラバースされたコミットの複数の深さにある場合の最小深さ)であるすべてのブロブとツリーを省略します。 <depth>=0 は、コマンドライン(または --stdin が使用されている場合は標準入力)に明示的に含まれていない限り、ツリーやブロブを含みません。 <depth>=1 は、 <commit> から到達可能なコミットまたは明示的に指定されたオブジェクトによって直接参照されるツリーとブロブのみが含まれます。 <depth>=2 は <depth>=1 に似ていますが、明示的に指定されたコミットまたはツリーから削除されたもう1つのレベルのツリーとブロブも含まれます。

注意: ファイルシステム上の任意のパスから読み取れる形式である @samp{--filter=sparse:path=<path>} は、セキュリティ上の理由から削除されたことに注意してください。

複数の @samp{--filter=} フラグを指定して、フィルターを組み合わせることができます。指定の全てのフィルターで受け入れられるオブジェクトのみが含まれます。

@samp{--filter=combine:<filter1>+<filter2>+...<filterN>} の形式を使用して、複数のフィルターを組み合わせることができますが、これは @samp{--filter} フラグを繰り返すよりもずっとずっと難しく、通常は必要はありません。フィルタは @samp{+} で結合され、個々のフィルタは @samp{%} エンコードされます(つまり、URLエンコードされます)。 @samp{+} と @samp{%} 文字に加えて、次の文字は予約されており、エンコードする必要があります: @samp{~!@@#$^&*()[]@{@}\;",<>?}@samp{'`} およびASCIコード @samp{0x20} 以下の全ての文字(空白(space)と改行(newline)を含む)。

他の任意の文字もエンコードできます。 たとえば、 @samp{combine:tree:3+blob:none} と @samp{combine:tree%3A3+blob%3Anone} は同等です。

@item  @samp{--no-filter} 
以前の @samp{--filter=} 引数をすべてオフにします。

@item  @samp{--filter-provided-objects} 
明示的に提供されたオブジェクトのリストをフィルタリングします。そうしないと、どのフィルターとも一致しなくても常に出力されます。 @samp{--filter=} と一緒に使った時のみ役に立ちます。

@item  @samp{--filter-print-omitted} 
@samp{--filter=} と一緒の時のみ役立ちます。フィルタによって省略されたオブジェクトのリストを出力します。オブジェクトIDの前には “~” 文字が付いています。

@item  @samp{--missing=<missing-action>} 
将来の「部分クローン」(partial clone)開発に役立つデバッグオプション。このオプションは、欠落しているオブジェクトの処理方法を指定します。

@samp{--missing=error} の形式は、欠落しているオブジェクトが検出された場合に、rev-list がエラーで停止することを要求します。これがデフォルトのアクションです。

@samp{--missing=allow-any} の形式を使用すると、欠落しているオブジェクトが検出された場合でも、オブジェクトの走査を続行できます。欠落しているオブジェクトは、結果から黙って省略されます。

@samp{--missing=allow-promisor} の形式は allow-any に似ていますが、オブジェクトのトラバーサルは、 EXPECTED promisor が欠落しているオブジェクトに対してのみ続行できます。予期しない欠落したオブジェクトはエラーを発生させます。

@samp{--missing=print} の形式は allow-any に似ていますが、欠落しているオブジェクトのリストも出力します。オブジェクトIDの前には “?” 文字が付いています。

@item  @samp{--exclude-promisor-objects} 
(内部使用のみ。) promisor境界でのオブジェクトトラバーサルをプレフィルターします。これは部分クローン(partial clone)で使用されます。これは、欠落しているオブジェクトに関するエラーを単に黙らせるのではなく、トラバーサルを制限するため、 @samp{--missing=allow-promisor} よりも強力です。

@item  @samp{--no-walk[=(sorted|unsorted)]} 
指定されたコミットのみを表示し、祖先をトラバースしない。範囲が指定されている場合、これは効果がありません。引数 @samp{unsorted} が指定されている場合、コミットはコマンドラインで指定された順序で表示されます。それ以外の場合( @samp{sorted} または引数が指定されていない場合)、コミットはコミット時間の逆順に表示されます。 @samp{--graph} と組み合わせることはできません。

@item  @samp{--do-walk} 
以前の @samp{--no-walk} を上書きします。
@end table

@noindent

@heading Commit Formatting

これらのオプションを使用すると、 git-rev-list(1) より専門的なコミットログツールのファミリーである git-log(1) や git-show(1) や git-whatchanged(1) と同様に機能します。

@table @asis

@item  @samp{--pretty[=<format>]} 
@itemx  @samp{--format=<format>} 
コミットログの内容を指定された形式できれいに印刷(pretty-print)します。 <format> は oneline、short、medium、full、fuller、reference、email、raw、format:<string>、tformat:<string> のいずれかになります。 <format> が上記のいずれでもなく、「%プレースホルダー」が含まれている場合、 @samp{--pretty=tformat:<format>} が指定されたかのように動作します。

各フォーマットの詳細については、「PRETTY FORMATS」セクションを参照してください。 @samp{=<format>} の部分を省略すると、デフォルトで medium になります。

注意: リポジトリー構成でデフォルトのpretty formatを指定できます(git-config(1) 参照)。

@item  @samp{--abbrev-commit} 
40バイトの16進コミットオブジェクト名全体を表示する代わりに、オブジェクトに一意の名前を付けるプレフィックスを表示します。 "--abbrev=<n>" (表示されている場合はdiff出力も変更します)オプションを使用して、プレフィックスの最小長を指定できます。

これにより、80桁幅の端末を使用している人にとって "--pretty=oneline" がずっと読みやすくなるはずです。

@item  @samp{--no-abbrev-commit} 
完全な40バイトの16進コミットオブジェクト名を表示します。 これにより、明示的または "--oneline" などの他のオプションによって暗黙的に示される @samp{--abbrev-commit} が無効になります。また、 @samp{log.abbrevCommit} 変数をオーバーライドします。

@item  @samp{--oneline} 
これは、 "--pretty=oneline --abbrev-commit" を一緒に使用するための省略形です。

@item  @samp{--encoding=<encoding>} 
コミットオブジェクトは、ログメッセージに使用される文字エンコードをエンコードヘッダーに記録します。このオプションを使用して、ユーザーが好むエンコーディングでコミットログメッセージを再コーディングするようにコマンドに指示できます。配管以外のコマンドの場合、これはデフォルトでUTF-8になります。オブジェクトが @samp{X} でエンコードされていると主張し、 @samp{X} で出力している場合、オブジェクトをそのまま出力することに注意してください。これは、元のコミットの無効なシーケンスが出力にコピーされる可能性があることを意味します。 同様に、 iconv(3) がコミットの変換に失敗した場合、 元のオブジェクトをそのまま黙って出力します。

@item  @samp{--expand-tabs=<n>} 
@itemx  @samp{--expand-tabs} 
@itemx  @samp{--no-expand-tabs} 
出力に表示する前に、ログメッセージでタブ展開を実行します(タブ幅を <n> とみなして <n> 境界に揃うように空白で調整する)。 @samp{--expand-tabs} は @samp{--expand-tabs=8} の省略形であり、 @samp{--no-expand-tabs} は @samp{--expand-tabs=0} の省略形です。タブの展開を無効にします。

デフォルトでは、タブはログメッセージを4つのスペースでインデントするきれいな形式(pretty formats)で展開されます(つまり、medium (これがデフォルト) と full と fuller)。

@item  @samp{--show-signature} 
署名を @samp{gpg --verify} に渡して、署名されたコミットオブジェクトの有効性を確認し、出力を表示します。

@item  @samp{--relative-date} 
@samp{--date=relative} と同じ。

@item  @samp{--date=<format>} 
@samp{--pretty} を使用する場合など、人間が読める形式で表示される日付に対してのみ有効になります。 @samp{log.date} 構成変数(config variable)は、logコマンドの @samp{--date} オプションのデフォルト値を設定します。デフォルトでは、日付は元のタイムゾーン(コミッターの、または作者のいずれか)で表示されます。フォーマットに @samp{-local} が追加されている場合(例: @samp{iso-local} )、代わりにユーザーのローカルタイムゾーンが使用されます。

@samp{--date=relative} は、現在の時刻を基準にした日付を示します。例: “2 hours ago” 。 @samp{-local} オプションは @samp{--date = relative} には効果がありません。

@samp{--date=local} は @samp{--date=default-local} のエイリアスです。

@samp{--date=iso} (または @samp{--date=iso8601} )は、タイムスタンプをISO 8601のような形式で表示します。厳密なISO 8601形式との違いは以下のとおりです:

@itemize 

@item
@samp{T} 日付/時刻区切り文字の代わりにスペース

@item
時間とタイムゾーンの間のスペース

@item
タイムゾーンの時間と分の間にコロンがありません
@end itemize

@samp{--date=iso-strict} (または @samp{--date=iso8601-strict} )は、タイムスタンプを厳密なISO 8601形式で表示します。

@samp{--date=rfc} (または @samp{--date=rfc2822} )は、RFC 2822形式のタイムスタンプを示します。これは、電子メールメッセージでよく見られます。

@samp{--date=short} は、日付のみを表示し、時刻は表示せず、 @samp{YYYY-MM-DD} 形式で表示します。

@samp{--date=raw} は、エポック(1970-01-01 00:00:00 UTC)からの秒数、スペース、UTCからのオフセット(@samp{+} または @samp{-} の付いた4桁数字で、最初の2つは時間、次の2つは分です)。つまり、タイムスタンプが @samp{strftime("%s %z")} でフォーマットされているかのようになります。 @samp{-local} オプションは、seconds-since-epoch値(常にUTCで測定されます)には影響しませんが、付随するタイムゾーン値を切り替えることに注意してください。

@samp{--date=human} は、タイムゾーンが現在のタイムゾーンと一致しない場合はタイムゾーンを表示し、一致する場合は日付全体を印刷しません(つまり、「今年」の日付の場合は年の印刷をスキップしますが、何があったか覚えてるような過去数日については日付自体もスキップします)。 古い日付の場合、時と分も省略されます。

@samp{--date=unix} は、日付をUnixエポックタイムスタンプ(1970年からの秒数)として表示します。 @samp{--raw} と同様に、これは常にUTCであるため、 ` -local` は効果がありません。

@samp{--date=format:...} は、内部で処理される%sと%zと%Zを除いて、フォーマット @samp{...} をあなたのシステムの @samp{strftime} に送ります。 @samp{--date=format:%c} を使用して、システムロケールの推奨形式で日付を表示します。フォーマットプレースホルダーの完全なリストについては、 @samp{strftime} マニュアルを参照してください。 @samp{-local} を使用する場合、正しい構文は @samp{--date=format-local:...} です。

@samp{--date=default} is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in "HH:MM:SS" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. @samp{Thu Jan 1 00:00:00 1970 +0000}.

@item  @samp{--header} 
コミットの内容をraw形式で出力します。各レコードはNUL文字で区切られます。

@item  @samp{--no-commit-header} 
"commit" を含むヘッダー行と、指定された形式の前に出力されたオブジェクトIDを抑制します。これは組み込みフォーマットには影響しません。 カスタムフォーマットのみが影響を受けます。

@item  @samp{--commit-header} 
以前の @samp{--no-commit-header} を上書きします。

@item  @samp{--parents} 
コミットの親も出力します( "commit parent…" の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。

@item  @samp{--children} 
コミットの子も出力します( "commit child…" の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。

@item  @samp{--timestamp} 
生のコミットタイムスタンプを出力します。

@item  @samp{--left-right} 
対称差のどちら側からコミットに到達できるかをマークします。左側からのコミットには @samp{<} が付けられ、右側からのコミットには @samp{>} が付けられます。 @samp{--boundary} と組み合わせると、それらのコミットの前に @samp{-} が付きます。

たとえば、以下のトポロジーの場合:

@example
             y---b---b  branch B
            / \ /
           /   .
          /   / \
         o---x---a---a  branch A
@end example


以下のような出力が得られます:

@example
        $ git rev-list --left-right --boundary --pretty=oneline A...B

        >bbbbbbb... 3rd on b
        >bbbbbbb... 2nd on b
        <aaaaaaa... 3rd on a
        <aaaaaaa... 2nd on a
        -yyyyyyy... 1st on b
        -xxxxxxx... 1st on a
@end example


@item  @samp{--graph} 
出力の左側に、コミット履歴のテキストベースのグラフィック表現を描画します。グラフ履歴を適切に描画するために、コミットの間に余分な行が出力される可能性があります。 @samp{--no-walk} と組み合わせることはできません。

これにより、親の書き換えが可能になります。上記「History Simplification」を参照してください。

これは、デフォルトで @samp{--topo-order} オプションを意味しますが、 @samp{--date-order} オプションも指定できます。

@item  @samp{--show-linear-break[=<barrier>]} 
--graph を使用しない場合、すべての履歴ブランチがフラット化されるため、2つの連続するコミットが線形ブランチに属していないことがわかりにくくなる可能性があります。このオプションは、その場合、それらの間に障壁を置きます。 @samp{<barrier>} が指定されている場合、デフォルトの障壁文字列の代わりに @samp{<barrier>} が表示されます。

@item  @samp{--count} 
リストされたコミットの数を示す数値を出力し、他のすべての出力を抑制します。 @samp{--left-right} と一緒に使用する場合は、代わりに、タブで区切って、左右のコミットのカウントを出力します。 @samp{--cherry-mark} と一緒に使用する場合は、これらのカウントからパッチの同等のコミットを省略し、タブで区切られた同等のコミットのカウントを出力します。
@end table

@noindent

@chapheading PRETTY FORMATS

コミットがマージであり、 pretty-format が @samp{oneline} または @samp{email} または @samp{raw} で無い場合、 @samp{Author:} 行の前に追加の行が挿入されます。この行は "Merge: " で始まり、先祖のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合、リストされたコミットは必ずしも @strong{直接} の親コミットのリストではない可能性があることに注意してください。

いくつかの組み込みフォーマットがあります。そして以下で説明するように、 pretty.<name> 構成オプション(config option)を別のフォーマット名または @samp{format:} 文字列に設定することで、追加のフォーマットを定義できます(git-config(1) 参照)。組み込みフォーマットの詳細は以下のとおりです:

@itemize 

@item
@samp{oneline}

@example
<hash> <title-line>
@end example

これは、可能な限りコンパクトになるように設計されています。

@item
@samp{short}

@example
commit <hash>
Author: <author>
@end example

@example
<title-line>
@end example

@item
@samp{medium}

@example
commit <hash>
Author: <author>
Date:   <author-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{full}

@example
commit <hash>
Author: <author>
Commit: <committer>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{fuller}

@example
commit <hash>
Author:     <author>
AuthorDate: <author-date>
Commit:     <committer>
CommitDate: <committer-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{reference}

@example
<abbrev-hash> (<title-line>, <short-author-date>)
@end example

この形式は、コミットメッセージ内の別のコミットを参照するために使用され、 @samp{--pretty='format:%C(auto)%h (%s, %ad)'} と同じです。 デフォルトでは、別の @samp{--date} オプションが明示的に指定されていない限り、日付は @samp{--date=short} でフォーマットされます。formatプレースホルダーを使用する他の @samp{format:} と同様に、その出力は、 @samp{--decorate} や @samp{--walk-reflogs} などの他のオプションの影響を受けません。

@item
@samp{email}

@example
From <hash> <date>
From: <author>
Date: <author-date>
Subject: [PATCH] <title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{mboxrd}

@samp{email} と同様ですが、コミットメッセージの "From " で始まる行(前に0個以上の @samp{>} が付いている)は @samp{>} でクォートされているため、新しいコミットの開始と混同されることはありません。

@item
@samp{raw}

@samp{raw} 形式は、コミットオブジェクトに格納されているとおりにコミット全体を正確に表示します。とりわけ @samp{--abbrev} または @samp{--no-abbrev} のどちらが使用されているかに関係なく、ハッシュは完全に表示され、「親」(parents)情報は、移植や履歴の単純化を考慮せずに、真の親のコミットを示します。この形式は、コミットの表示方法に影響しますが、いわゆる @samp{git log --raw} の差分の表示方法ではありません。生のdiff形式で完全なオブジェクト名を取得するには、 @samp{--no-abbrev} を使用します。

@item
@samp{format:<format-string>}

@samp{format:<format-string>} 形式を使用すると、表示する情報を指定できます。注意: これはprintf書式に少し似ていますが、 @samp{\n} の代わりに @samp{%n} を使用して改行を取得するという例外に注意してください。

例: @samp{format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"} は以下のように表示されます:

@example
The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<
@end example


さて、以下がプレースホルダー達です:

@itemize 

@item
単一のリテラル文字に展開されるプレースホルダー:

@table @asis

@item  @samp{%n} 
改行(newline)

@item  @samp{%%} 
`%`そのもの

@item  @samp{%x00} 
16進数のバイト値を出力
@end table

@item
これより後ろのプレースホルダーのフォーマッティングに影響を与えるプレースホルダー:

@table @asis

@item  @samp{%Cred} 
赤色に切り替える

@item  @samp{%Cgreen} 
緑色に切り替える

@item  @samp{%Cblue} 
青色に切り替える。

@item  @samp{%Creset} 
色をリセットする

@item  @samp{%C(...)} 
git-config(1) の「CONFIGURATION FILE」の Values で説明されている色の指定。 デフォルトでは、色はログ出力が有効になっている場合にのみ表示されます(@samp{color.diff} または @samp{color.ui} または @samp{--color} によって、ターミナルに出す場合は前者の @samp{auto} 設定を尊重します)。 @samp{%C(auto,...)} は、 default の歴史的同義語として受け入れられます(例: @samp{%C(auto,red)})。 @samp{%C(always,...)} を指定すると、色が有効になっていない場合でも色が表示されます(この形式やgitが色付けする可能性のある他のすべてのものを含め、出力全体の色を有効にするために @samp{--color=always} の使用を検討してください)。 @samp{auto} のみ(つまり、 @samp{%C(auto)})は、色が再び切り替えられるまで、これに続くプレースホルダーで自動色付けをオンにします。

@item  @samp{%m} 
左(@samp{<}) または 右(@samp{>}) または 境界 (@samp{-}) の印

@item  @samp{%w([<w>[,<i1>[,<i2>]]])} 
git-shortlog(1) の -w オプションのように、行の折返しを切り替えます。

@item  @samp{%<( <N> [,trunc|ltrunc|mtrunc])} 
これの次のプレースホルダーが少なくとも N 列幅になるようにし、必要に応じて右側にスペースを詰めます。出力が N 列より長い場合は、オプションで、左側 (ltrunc) @samp{..ft} 切り捨て、または 中央 (mtrunc) @samp{mi..le} 切り捨て、または末尾切り捨て (trunc) @samp{rig..} ます (@emph{..} は省略符号)。 注意1: 切り捨ては N >= 2 の場合にのみ正しく機能します。 注意2: N および M (以下参照) 値の前後の空白はオプションです。 注意3: 絵文字やその他のワイド・キャラクタは表示桁を2つ必要とするため、桁の境界を超える可能性があります。 注意4: 複合文字マーク(character combining marks)が詰物境界で誤って分割配置される可能性があります。

@item  @samp{%<|( <M> )} 
これの次のプレースホルダーが少なくとも M 桁目の表示桁までを占めるようにし、必要に応じて右側に空白を詰めます。 端末ウィンドウの右端から測定した桁位置には、負の M 値を使用して下さい。

@item  @samp{%>( <N> )}, @samp{%>|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、左側に空白が埋め込まれます

@item  @samp{%>>( <N> )}, @samp{%>>|( <M> )} 
それぞれ @samp{%>( <N> )}, @samp{%>|( <M> )} に似ていますが、 これに続くプレースホルダーが指定よりも多くの空白を使用し、その左側に空白がある場合は、それらの空白を使用します

@item  @samp{%><( <N> )}, @samp{%><|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、 両側にパディングがあります(つまり、 テキストが中央に配置されます)
@end table

@item
コミットから抽出された情報に展開するプレースホルダー:

@table @asis

@item  @samp{%H} 
コミットハッシュ

@item  @samp{%h} 
省略されたコミットハッシュ

@item  @samp{%T} 
ツリーハッシュ

@item  @samp{%t} 
省略されたツリーハッシュ

@item  @samp{%P} 
親のハッシュ達

@item  @samp{%p} 
省略された親のハッシュ達

@item  @samp{%an} 
作者名

@item  @samp{%aN} 
作者名( .mailmap に関しては、 git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ae} 
作者電子メールアドレス

@item  @samp{%aE} 
作者電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%al} 
作者電子メールアドレスアカウント名(local-part)(@samp{@@} の前の部分)

@item  @samp{%aL} 
作者電子メールアカウント名(@samp{%al} 参照)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ad} 
作成日(フォーマットに関しては --date= オプション参照)

@item  @samp{%aD} 
作成日 RFC2822形式

@item  @samp{%ar} 
作成日 相対(relative)形式

@item  @samp{%at} 
作成日 UNIXタイムスタンプ形式

@item  @samp{%ai} 
作成日 ISO 8601風形式

@item  @samp{%aI} 
作成日 厳密なISO 8601形式

@item  @samp{%as} 
作成日 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ah} 
作者作成日(author date)の人間が読める形式(human style)(git-rev-list(1) の ‘--date=human’ に似ている)

@item  @samp{%cn} 
コミッター名

@item  @samp{%cN} 
コミッター名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ce} 
コミッター電子メールアドレス

@item  @samp{%cE} 
コミッター電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cl} 
コミッター電子メールアドレスアカウント名(local-part)( @samp{@@} の前の部分)

@item  @samp{%cL} 
コミッター電子メールアカウント名(local-part)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cd} 
コミッター日付(フォーマットに関しては @samp{--date=} オプション参照)

@item  @samp{%cD} 
コミッター日付 RFC2822形式

@item  @samp{%cr} 
コミッター日付 相対(relative)形式

@item  @samp{%ct} 
コミッター日付 UNIXタイムスタンプ形式

@item  @samp{%ci} 
コミッター日付 ISO 8601風形式

@item  @samp{%cI} 
コミッター日付 厳密なISO 8601形式

@item  @samp{%cs} 
コミッター日付 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ch} 
コミッター日付 人間が読める形式(git-rev-list(1) の @samp{--date=human} に似ている)

@item  @samp{%d} 
ref名 git-log(1) の --decorate オプションみたいなの

@item  @samp{%D} 
" (", ")" で囲ってないref名

@item  @samp{%(describe[:options])} 
git-describe(1) のような人間が読める名前。説明できないコミットの場合は空の文字列。 @samp{describe} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。タグの追加や削除を同時に行うと、説明に一貫性がなくなる可能性があります。

@itemize 

@item
@samp{tags[=<bool-value>]}: 注釈付きタグ(annotated tags)だけを考慮するのではなく、軽量タグ(lightweight tags)も考慮してください。

@item
@samp{abbrev=<number>}: 短縮ブジェクト名のデフォルトの 16 進数の桁数 (デフォルトは 7 で、リポジトリ内のオブジェクトの数によって異なります) を使用する代わりに、 <number> 桁数を指定するか、または 一意のオブジェクト名を形成するために必要な桁数。

@item
@samp{match=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグのみを考慮します。

@item
@samp{exclude=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグを対象にしません。
@end itemize

@item  @samp{%S} 
(@samp{git log --source} のような、)コマンドラインで指定した、コミットに到達したref名で、 @samp{git log} でのみ機能します。

@item  @samp{%e} 
エンコーディング

@item  @samp{%s} 
件名(subject)

@item  @samp{%f} 
ファイル名に適した、サニタイズされた件名

@item  @samp{%b} 
本文(body)

@item  @samp{%B} 
生本文(raw body)(行折り曲げされてない件名と本文)

@item  @samp{%GG} 
署名されたコミットの為のGPGからの生の検証メッセージ

@item  @samp{%G?} 
@table @asis

@item  G 
良い(good)な(有効な)署名の場合はこの文字に置換されます。

@item  B 
悪い署名(bad signature)の場合はこの文字に置換されます。

@item  U 
有効性が不明(unknown validity)な良い署名の場合はこの文字に置換されます。

@item  X 
期限切れ(eXpired)の良い署名の場合はこの文字に置換されます。

@item  Y 
期限切れのキーで作成された良い署名の場合はこの文字に置換されます。

@item  R 
取り消されたキーによって作成された良い署名の場合はこの文字に置換されます。

@item  E 
署名を確認できない場合(キーの欠落など)の場合はこの文字に置換されます。

@item  N 
署名がない場合の場合はこの文字に置換されます。
@end table

@item  @samp{%GS} 
署名されたコミットの署名者の名前を表示する

@item  @samp{%GK} 
署名されたコミットに署名するために使用されるキーを表示する

@item  @samp{%GF} 
署名されたコミットに署名するために使用されるキーのフィンガープリントを表示する

@item  @samp{%GP} 
署名付きコミットの署名に使用されたサブキー(subkey)の主キー(primary key)のフィンガープリントを表示します

@item  @samp{%GT} 
署名されたコミットに署名するために使用されるキーの信頼レベル(trust level)を表示します

@item  @samp{%gD} 
reflog セレクター(例えば @samp{refs/stash@@@{1@}} とか @samp{refs/stash@@@{2 minutes ago@}})。 この形式は、 @samp{-g} オプションで説明されている規則に従います。 @samp{@@} の前の部分は、コマンドラインで指定されたrefnameです(したがって、 @samp{git log -g refs/heads/master} は @samp{refs/heads/master@@@{0@}} を生成します)。

@item  @samp{%gd} 
短縮 reflog セレクター。 @samp{%gD} と同一ですが、人間が読みやすい形式でrefname部分が短縮されています(したがって、 @samp{refs/heads/master} は単に @samp{master} になります)。

@item  @samp{%gn} 
reflog ID名

@item  @samp{%gN} 
reflog ID名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ge} 
reflog ID 電子メールアドレス

@item  @samp{%gE} 
reflog ID 電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%gs} 
reflog 件名

@item  @samp{%(trailers[:options])} 
git-interpret-trailers(1) によって解釈されるようにボディのトレーラーを表示します。 @samp{trailers} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。いずれかのオプションが複数回提供された場合、それぞれ最後のものが優先されます。

@itemize 

@item
@samp{key=<key>}: 指定された <key> を持つトレーラーのみを表示します。マッチングは大文字と小文字を区別せずに行われ、末尾のコロンはオプションです。オプションが複数回指定されている場合、いずれかのキーに一致するトレーラー行が表示されます。このオプションは自動的に @samp{only} オプションを有効にして、トレーラーブロック内の非トレーラー行が非表示になるようにします。それが望ましくない場合は、 @samp{only=false} で無効にすることができます。 たとえば、 @samp{%(trailers:key=Reviewed-by)} は、キーが `Reviewed-by`のトレーラー行を表示します。

@item
@samp{only[=<bool>]}: トレーラーブロックに非トレーラー行を含めるかどうかを選択します。

@item
@samp{separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラー行は改行文字で終了します。文字列 <sep> には、上記のリテラルフォーマットコードが含まれる場合があります。区切り文字としてコンマを使用するには、次のオプションとして解析されないよう @samp{%x2C} を使用する必要があります。 たとえば、 @samp{%(trailers:key=Ticket,separator=%x2C )} は、キーが @samp{Ticket} であるすべてのトレーラー行をカンマとスペースで区切って表示します。

@item
@samp{unfold[=<bool>]}: interpret-trailer の @samp{--unfold} オプションが指定されたかのように動作させます。たとえば、 @samp{%(trailers:only,unfold=true)} が展開され、すべてのトレーラー行が表示されます。

@item
@samp{keyonly[=<bool>]}: トレーラーのキー部分のみを表示。

@item
@samp{valueonly[=<bool>]}: トレーラーの値部分のみ表示。

@item
@samp{key_value_separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラーのキーと値のペアは ": " で区切られます。 それ以外の場合は、上記の @samp{separator=<sep>} と同じセマンティクスを共有します。
@end itemize
@end table
@end itemize
@end itemize

@quotation

@strong{Note}

一部のプレースホルダーは、リビジョントラバーサルエンジンに指定された他のオプションに依存する場合があります。 たとえば、 @samp{%g*} reflogオプションは、reflogエントリをトラバースしない限り(たとえば、 @samp{git log -g} によって)空の文字列を挿入します。コマンドラインで @samp{--decorate} がまだ指定されていない場合、 @samp{%d} と @samp{%D} プレースホルダーは「短い」(short)装飾形式を使用します。
@end quotation

ブール値オプションは、オプションの値 @samp{[=<bool-value>]} を受け入れます。 値 @samp{true} 、@samp{false} 、 @samp{on} 、@samp{off} などはすべて受け入れられます。 git-config(1) の "EXAMPLES" の "boolean" サブセクションを参照してください。ブール値オプションが値なしで指定された場合、それは有効を指定した事になります。

プレースホルダーの @samp{%} の後に @samp{+} (プラス記号)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。

プレースホルダーの @samp{%} の後に @samp{-} (マイナス記号)を追加すると、プレースホルダーが空の文字列に展開された場合にのみ、展開の直前の連続するすべての改行が削除されます。

プレースホルダーの @samp{%} の後に " " (スペース)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前にスペースが挿入されます。

@itemize 

@item
@samp{tformat:}

@samp{tformat:} 形式は、 "separator" セマンティクスの代わりに "terminator" セマンティクスを提供することを除いて、 @samp{format:} とまったく同じように機能します。 つまり、各コミットには、エントリ間に区切り文字を配置するのではなく、メッセージターミネータ文字(通常は改行)が追加されます。 これは、「1行」形式と同様に、1行形式の最終エントリが新しい行で適切に終了することを意味します。 例えば以下のようになります:

@example
$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973
@end example


加えて、 @samp{%} が含まれている認識されない文字列は、その前に @samp{tformat:} があるかのように解釈(interpret)されます。 たとえば、以下の2つは同等です:

@example
$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef
@end example

@end itemize

@noindent

@chapheading EXAMPLES

@itemize 

@item
現在のブランチから到達可能なコミットのリストを出力します。

@example
git rev-list HEAD
@end example


@item
このブランチのコミットのリストを出力しますが、アップストリームブランチのは表示しません。

@example
git rev-list @@@{upstream@}..HEAD
@end example


@item
作者(author)とコミットメッセージを使用してコミットをフォーマットします(磁器コマンドのgit-log(1)も参照)。

@example
git rev-list --format=medium HEAD
@end example


@item
コミットとその差分をフォーマットします(これを単一のプロセスで実行できる磁器コマンドのgit-log(1)も参照してください)。

@example
git rev-list HEAD |
git diff-tree --stdin --format=medium -p
@end example


@item
現在のブランチで、`Documentation`ディレクトリ内のファイルに関連(touch)したコミットのリストを出力します。

@example
git rev-list HEAD -- Documentation/
@end example


@item
任意のブランチ・タグ・@uref{mailto:他のrefから過去1年間に作者you@@example.comが作成したコミットのリストを出力します,他のrefから過去1年間に作者you@@example.comが作成したコミットのリストを出力します}。

@example
git rev-list --author=you@@example.com --since=1.year.ago --all
@end example


@item
現在のブランチから到達可能なオブジェクトのリストを出力します(つまり、すべてのコミットと、それらに含まれるブロブとツリー)。

@example
git rev-list --objects HEAD
@end example


@item
到達可能なすべてのオブジェクトのディスクサイズ、reflogから到達可能なオブジェクト、およびパックされた合計サイズを比較します。これにより、`git repack -ad`を実行すると(到達不能なオブジェクトを削除することで)リポジトリのサイズが減少するかどうか、およびreflogの有効期限が切れる(expire)ことによってリポジトリのサイズ減少に役立つかどうかがわかります。

@example
# reachable objects
git rev-list --disk-usage --objects --all
# plus reflogs
git rev-list --disk-usage --objects --all --reflog
# total disk size used
du -c .git/objects/pack/*.pack .git/objects/??/*
# alternative to du: add up "size" and "size-pack" fields
git count-objects -v
@end example


@item
現在のブランチで使用されているオブジェクトを除いて、各ブランチのディスクサイズを報告します。 これにより、リポジトリサイズの肥大化の原因となっているイレギュラー値を見つけることができます(たとえば、誰かが誤って大きなビルドアーティファクトをコミットしたためとか)。

@example
git for-each-ref --format='%(refname)' |
while read branch
do
        size=$(git rev-list --disk-usage --objects HEAD..$branch)
        echo "$size $branch"
done |
sort -n
@end example


@item
(別のグループを除いた)refsの単一のグループのブランチのディスク上のサイズを比較します。1つのリポジトリに複数のリモートからのオブジェクトを混在させる場合、これにより、リポジトリ内で、どのリモートがどれだけ占めているかを示すことができます(`origin`のサイズを基準値として使用)。

@example
git rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin
@end example

@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-rev-parse,,,Top
@chapheading Name

git-rev-parse — パラメータを選択してもみもみします。

@noindent

@chapheading Synopsis

@display
git rev-parse [<options>] <args>…
@end display


@noindent

@chapheading DESCRIPTION

多くのGit磁器コマンドは、内部で使用されベースとなる @samp{git rev-list} コマンド用のフラグとパラメーターの組み合わせと、 @samp{git rev-list} の下流で使用する他のコマンドのフラグとパラメーターの組み合わせを使用します。このコマンドは、それらを識別するために使用されます。

@noindent

@chapheading OPTIONS

@noindent

@heading Operation Modes

これらの各オプションは、コマンドラインの最初にある必要があります。

@table @asis

@item  @samp{--parseopt} 
オプション解析モードで @samp{git rev-parse} を使用します(以下の PARSEOPT セクションを参照)。

@item  @samp{--sq-quote} 
シェルクォートモードで @emph{git rev-parse} を使用します(以下の SQ-QUOTE セクションを参照)。以下の @samp{--sq} オプションとは対照的に、このモードはクォートのみを実行します。コマンド入力に対して他に何も行われません。
@end table

@noindent

@heading Options for --parseopt

@table @asis

@item  @samp{--keep-dashdash} 
@samp{--parseopt} モードでのみ意味があります。 オプションパーサーに、最初に出会った @samp{--} をスキップするのではなく、エコー出力(echo out)するように指示します。

@item  @samp{--stop-at-non-option} 
@samp{--parseopt} モードでのみ意味があります。オプションパーサーを最初の非オプション引数で停止させます。これは、オプション自体を受け取るサブコマンドを解析するために使用できます。

@item  @samp{--stuck-long} 
@samp{--parseopt} モードでのみ意味があります。可能な場合は長い形式でオプションを出力し、それらの引数を固定(stick)します。
@end table

@noindent

@heading Options for Filtering

@table @asis

@item  @samp{--revs-only} 
@samp{git rev-list} コマンド用ではないフラグやパラメーターを出力しないでください。

@item  @samp{--no-revs} 
@samp{git rev-list} コマンド用のフラグとパラメーターを出力しないでください。

@item  @samp{--flags} 
非フラグパラメータを出力しないでください。

@item  @samp{--no-flags} 
フラグパラメータを出力しないでください。
@end table

@noindent

@heading Options for Output

@table @asis

@item  @samp{--default <arg>} 
ユーザーが指定したパラメーターがない場合は、代わりに @samp{<arg>} を使用してください。

@item  @samp{--prefix <arg>} 
@samp{git rev-parse} が作業ツリーの @samp{<arg>} サブディレクトリから呼び出されたかのように動作します。相対ファイル名は、接頭辞が @samp{<arg>} であるかのように解決され、その形式で出力されます。

これを使用して、引数をサブディレクトリで実行されるコマンドに変換し、リポジトリの最上位に移動した後も使用できるようにすることができます。 例えば:

@example
prefix=$(git rev-parse --show-prefix)
cd "$(git rev-parse --show-toplevel)"
# rev-parse provides the -- needed for 'set'
eval "set $(git rev-parse --sq --prefix "$prefix" -- "$@@")"
@end example


@item  @samp{--verify} 
正確に1つのパラメーターが提供されていること、およびそれがオブジェクト・データベースへのアクセスに使用できる生の20バイトのSHA-1に変換できることを検証します。もしそうなら、それを標準出力に出力します。それ以外の場合は、エラー出力になります。

出力が実際にオブジェクトデータベース内のオブジェクトに名前を付けていること、および/または必要な特定のタイプのオブジェクトとして使用できることを確認したい場合は、パラメータに @samp{^@{type@}} 皮むき演算子(peeling operator)を追加できます。 たとえば、 @samp{git rev-parse "$VAR^@{commit@}"} は、 @samp{$VAR} がコミットっぽい既存のオブジェクト(つまりコミット、またはコミットを指す注釈付きタグ)に名前を付けることを確認します。 @samp{$VAR} が任意のタイプの既存のオブジェクトに名前を付けるようにするには、 @samp{git rev-parse "$VAR^@{object@}"} を使用できます。

注意: 信頼できないソースからの名前を検証(verify)する場合は、name引数が別のオプションと間違えられないように、 @samp{--end-of-options} の使用が賢明です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{--verify} モードでのみ意味があります。最初の引数が有効なオブジェクト名でない場合は、エラーメッセージを出力しないでください。代わりに、ゼロ以外のステータスで黙って終了(exit)します。有効なオブジェクト名のSHA-1は、成功するとstdoutに出力されます。

@item  @samp{--sq} 
通常、出力はフラグとパラメータごとに1行になります。このオプションは、シェルによって消費されるための適切に引用された1行の出力を作成します。パラメータに空白と改行が含まれていると予想される場合に便利です(たとえば、 pickaxe @samp{-S} with @emph{git diff-*} )。 @samp{--sq-quote} オプションとは対照的に、コマンド入力は通常どおり解釈されます。

@item  @samp{--short[=length]} 
@samp{--verify} と同じですが、オブジェクト名を少なくとも @samp{length} 文字の一意のプレフィックスに短縮します。最小の長さは4で、デフォルトは @samp{core.abbrev} 構成変数の有効な値です(git-config(1)を参照)。

@item  @samp{--not} 
オブジェクト名を表示するときは、それらに @samp{@{caret@}} というプレフィックスを付け、逆に既に、 @samp{@{caret@}} プレフィックスを持っているオブジェクト名からは @samp{@{caret@}} プレフィックスを削除します。

@item  @samp{--abbrev-ref[=(strict|loose)]} 
オブジェクト名のあいまいでない短い名前。オプション core.warnAmbiguousRefs は、厳密な省略形モードを選択するために使用されます。

@item  @samp{--symbolic} 
通常、オブジェクト名はSHA-1形式で出力されます(可能な場合は @samp{@{caret@}} プレフィックス付き)。このオプションを使用すると、入力されたオリジナルにできるだけ近い形式で出力されます。

@item  @samp{--symbolic-full-name} 
これは @samp{--symbolic} に似ていますが、ref(つまり、ブランチ名とタグ名。または、残念ながら @samp{master} と名付けられたタグがあるとき @samp{master} ブランチに名前を付けたい場合はより明確な @samp{heads/master} 形式である)ではない入力を省略し、完全なrefname(例: "refs/heads/master")として表示します。
@end table

@noindent

@heading Options for Objects

@table @asis

@item  @samp{--all} 
@samp{refs/} で見つかったすべての参照を表示します。

@item  @samp{--branches[=pattern]} 
@itemx  @samp{--tags[=pattern]} 
@itemx  @samp{--remotes[=pattern]} 
すべてのブランチまたはタグまたはリモートトラッキングブランチをそれぞれ表示します(つまり、それぞれ @samp{refs/heads} または @samp{refs/tags} または @samp{refs/remotes} で見つかったref)。

@samp{pattern} が指定されている場合、指定されたシェルグロブに一致するrefのみが表示されます。パターンにグロビング文字(@samp{?} または @samp{*} または @samp{[})が含まれていない場合は、 @samp{/*} を追加することでプレフィックス一致に変換されます。

@item  @samp{--glob=pattern} 
シェルグロブパターン @samp{pattern} に一致するすべてのrefを表示します。 パターンが @samp{refs/} で始まらない場合、自動的に先頭に追加されます。パターンにグロビング文字(@samp{?} または @samp{*} または @samp{[})が含まれていない場合は、 @samp{/*} を追加することでプレフィックス一致に変換されます。

@item  @samp{--exclude=<glob-pattern>} 
このオプションに続く @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} がそれぞれ考慮する @emph{<glob-pattern>} に一致するrefを含めないでください。このオプションを繰り返すと、次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} オプションまで除外パターンが蓄積されます(他のオプションや引数は蓄積されたパターンをクリアしませんされません)。

与えられたパターンは、それぞれ @samp{--branches} または @samp{--tags} または @samp{--remotes} に適用される場合、それぞれ @samp{refs/heads} 、 @samp{refs/tags} 、@samp{refs/remotes} で始まるべきではありません。 @samp{--glob} または @samp{--all} に適用する場合は、 @samp{refs/} で始める必要があります。末尾の @emph{/*} を意図している場合は、それを明示的に指定する必要があります。

@item  @samp{--exclude-hidden=[fetch|receive|uploadpack]} 
Do not include refs that would be hidden by @samp{git-fetch}, @samp{git-receive-pack} or @samp{git-upload-pack} by consulting the appropriate @samp{fetch.hideRefs}, @samp{receive.hideRefs} or @samp{uploadpack.hideRefs} configuration along with @samp{transfer.hideRefs} (see git-config(1)). This option affects the next pseudo-ref option @samp{--all} or @samp{--glob} and is cleared after processing them.

@item  @samp{--disambiguate=<prefix>} 
名前が、指定されたプレフィックスで始まるすべてのオブジェクトを表示します。 <prefix> は、リポジトリ内のすべてのオブジェクトを誤ってリストしないように、少なくとも4桁の16進数である必要があります。
@end table

@noindent

@heading Options for Files

@table @asis

@item  @samp{--local-env-vars} 
リポジトリローカルな GIT_* 環境変数を一覧表示します(例: GIT_DIRまたはGIT_WORK_TREE、ただしGIT_EDITORは除く)。 変数が設定されている場合でも、変数の名前のみがリストされ、値はリストされません。

@item  @samp{--path-format=(absolute|relative)} 
他の特定のオプションの動作を制御します。absolute(絶対)を指定すると、これらのオプションによって出力されるパスは絶対パスかつ正規化されます。relative(相対)を指定すると、可能であれば、パスは現在の作業ディレクトリからの相対パスになります。デフォルトは対象の、他の特定のオプションそれぞれ固有です。

このオプションは複数回指定でき、コマンドラインの最後か、またはこのオプションの次のインスタンスかの、いずれかに続くコマンドラインの引数にのみ影響します。
@end table

以下のオプションは @samp{--path-format} による変更対象です:

@table @asis

@item  @samp{--git-dir} 
定義されている場合は @samp{$GIT_DIR} を表示します。それ以外の場合は、 @samp{.git} ディレクトリへのパスを表示します。表示されているパスは、相対の場合、現在の作業ディレクトリからの相対パスです。

@samp{$GIT_DIR} が定義されておらず、現在のディレクトリがGitリポジトリまたは作業ツリーにあることが検出されない場合は、標準エラー出力にメッセージを出力し、ゼロ以外のステータスで終了(exit)します。

@item  @samp{--git-common-dir} 
定義されている場合は @samp{$GIT_COMMON_DIR} を表示し、そうでない場合は @samp{$GIT_DIR} を表示します。

@item  @samp{--resolve-git-dir <path>} 
<path> が有効なリポジトリまたは有効なリポジトリを指す gitfile であるかどうかを確認し、リポジトリの場所を出力します。 <path> が gitfile の場合、実際のリポジトリへの解決されたパス(resoluved path)が出力されます。

@item  @samp{--git-path <path>} 
@samp{$GIT_DIR/<path>} を解決し、 $GIT_OBJECT_DIRECTORY、$GIT_INDEX_FILE…などの他のパス再配置変数を考慮に入れます。 たとえば、 $GIT_OBJECT_DIRECTORY が @samp{/foo/bar} に設定されている場合、 @samp{git rev-parse --git-path objects/abc} は @samp{/foo/bar/abc} を返します。

@item  @samp{--show-toplevel} 
作業ツリーの最上位ディレクトリの(デフォルトでは絶対)パスを表示します。作業ツリーがない場合は、エラーを報告します。

@item  @samp{--show-superproject-working-tree} 
現在のリポジトリをサブモジュールとして使用するスーパープロジェクトの作業ツリー(存在する場合)のルート(root)の絶対パスを表示します。現在のリポジトリがどのプロジェクトでもサブモジュールとして使用されていない場合は、何も出力しません。

@item  @samp{--shared-index-path} 
共有インデックスファイル(shared index file)へのパスを分割インデックスモード(split index mode)で表示します。分割インデックスモードで無い場合は空です。
@end table

以下のオプションは、 @samp{--path-format} の影響を受けません:

@table @asis

@item  @samp{--absolute-git-dir} 
@samp{--git-dir} に似ていますが、その出力は常に正規化された絶対パスです。

@item  @samp{--is-inside-git-dir} 
現在の作業ディレクトリがリポジトリディレクトリ(訳注: 通常 @samp{.git} ディレクトリ)の下にある場合は @samp{true} 、それ以外の場合は @samp{false} と出力します。

@item  @samp{--is-inside-work-tree} 
現在の作業ディレクトリがリポジトリの作業ツリー内にある場合は @samp{true} 、それ以外の場合は @samp{false} と出力します。(訳注 @samp{.git} ディレクトリ内では @samp{false})

@item  @samp{--is-bare-repository} 
ベアリポジトリの場合は @samp{true} 、それ以外の場合は @samp{false} を出力。

@item  @samp{--is-shallow-repository} 
shallowリポジトリの場合は @samp{true} 、そうでない場合は @samp{false} を出力します。

@item  @samp{--show-cdup} 
コマンドがサブディレクトリから呼び出された場合は、現在のディレクトリを基準にした最上位ディレクトリのパスを表示します(通常は @samp{../} のシーケンスまたは空の文字列)。(訳注:作業ディレクトリ内じゃない時はエラー)

@item  @samp{--show-prefix} 
コマンドがサブディレクトリから呼び出された場合は、最上位ディレクトリを基準にした現在のディレクトリのパスを表示します。(訳注:作業ディレクトリ内じゃない時はエラー)

@item  @samp{--show-object-format[=(storage|input|output)]} 
@samp{.git} ディレクトリ内でリポジトリのために使われるストレージ(storage)、または入力(input)、または出力(output)に使われるオブジェクト形式(ハッシュアルゴリズム)を表示します。入力(input)の場合、複数のアルゴリズムがスペースで区切られて出力される場合があります。形式を指定しない場合、デフォルトは @samp{storage} です。
@end table

@noindent

@heading Other Options

@table @asis

@item  @samp{--since=datestring} 
@itemx  @samp{--after=datestring} 
日付文字列をパースし、 @samp{git rev-list} に対応する @samp{-max-age=} パラメーターを出力します。

@item  @samp{--until=datestring} 
@itemx  @samp{--before=datestring} 
日付文字列をパースし、 @samp{git rev-list} に対応する @samp{--min-age=} パラメーターを出力します。

@item  <args>… 
パースされるフラグとパラメーター。
@end table

@noindent

@chapheading SPECIFYING REVISIONS

リビジョンパラメータ @samp{<rev>} は必ずしもそうとは限りませんが、通常はコミットオブジェクトに名前を付けます。これは、いわゆる「拡張SHA-1」構文を使用します。 オブジェクト名を綴るにはさまざまな方法があります。このリストの終わり近くにリストされているものは、コミットに含まれているツリーとブロブに名前を付けています。

@quotation

@strong{Note}

この文書は、gitで見られる「生の」構文を示しています。シェルおよびその他のUIでは、特殊文字を保護し、単語の分割を回避するために、追加の引用符が必要になる場合があります。
@end quotation

@table @asis

@item  @samp{<sha1>} 例: @samp{dae86e1950b1277e545cee180551750029cfe735}, @samp{dae86e} 
完全なSHA-1オブジェクト名(40バイトの16進文字列)、またはリポジトリ内で一意の先頭のsubstring。例えば dae86e1950b1277e545cee180551750029cfe735 と dae86e はどちらも、リポジトリ内にオブジェクト名が dae86e で始まる他のオブジェクトがない場合、全く同じコミットオブジェクトに名前を付けます。

@item  @samp{<describeOutput>} 例: @samp{v1.7.4.2-679-g3bee7fb} 
@samp{git describe} からの出力。つまり、現在のコミットから最も近いタグ。オプションで、ダッシュ(-)とそのタグ以降現在のコミットが何番目になるかの数が続き、その後にダッシュ(-)、「g」、および省略されたオブジェクト名が続きます。

@item  @samp{<refname>} 例: @samp{master}, @samp{heads/master}, @samp{refs/heads/master} 
シンボリックref名。例えば @samp{master} は通常、 @samp{refs/heads/master} によって参照されるコミットオブジェクトを意味します。 @samp{heads/master} と @samp{tags/master} の両方がある場合は、あなたは @samp{heads/master} と明示的に指定して、どちらを意味するかをGitに伝えることができます。 あいまいな場合、 @samp{<refname>} は、以下のルールに従い最初の一致を採用ことで明確になります:

@enumerate 

@item
If @emph{$GIT_DIR/<refname>} exists, that is what you mean (this is usually useful only for @samp{HEAD}, @samp{FETCH_HEAD}, @samp{ORIG_HEAD}, @samp{MERGE_HEAD}, @samp{REBASE_HEAD}, @samp{REVERT_HEAD}, @samp{CHERRY_PICK_HEAD}, @samp{BISECT_HEAD} and @samp{AUTO_MERGE});

@item
でなければ @samp{refs/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/tags/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/heads/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/remotes/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/remotes/<refname>/HEAD} が存在すればそれを採用します。
@end enumerate

@table @asis

@item  @samp{HEAD} 
names the commit on which you based the changes in the working tree.

@item  @samp{FETCH_HEAD} 
records the branch which you fetched from a remote repository with
your last @samp{git fetch} invocation.

@item  @samp{ORIG_HEAD} 
is created by commands that move your @samp{HEAD} in a drastic way (@samp{git
am}, @samp{git merge}, @samp{git rebase}, @samp{git reset}), to record the position
of the @samp{HEAD} before their operation, so that you can easily change
the tip of the branch back to the state before you ran them.

@item  @samp{MERGE_HEAD} 
records the commit(s) which you are merging into your branch when you
run @samp{git merge}.

@item  @samp{REBASE_HEAD} 
during a rebase, records the commit at which the operation is
currently stopped, either because of conflicts or an @samp{edit} command in
an interactive rebase.

@item  @samp{REVERT_HEAD} 
records the commit which you are reverting when you run @samp{git revert}.

@item  @samp{CHERRY_PICK_HEAD} 
records the commit which you are cherry-picking when you run @samp{git
cherry-pick}.

@item  @samp{BISECT_HEAD} 
records the current commit to be tested when you run @samp{git bisect
--no-checkout}.

@item  @samp{AUTO_MERGE} 
records a tree object corresponding to the state the
@emph{ort} merge strategy wrote to the working tree when a merge operation
resulted in conflicts.
@end table

注意: 上記の @samp{refs/*} の場合、 @samp{$GIT_DIR/refs} ディレクトリまたは @samp{$GIT_DIR/packed-refs} ファイルのいずれかから発生する可能性があることに注意してください。ref名のエンコードは指定されていませんが、一部の出力処理ではUTF-8でref名を想定する場合があるため、UTF-8が推奨されます。

@item  @samp{@@} 
@samp{@@} 単独では @samp{HEAD} のショートカットを意味します。

@item  @samp{[<refname>]@@@{<date>@}} 例: @samp{master@@@{yesterday@}}, @samp{HEAD@@@{5 minutes ago@}} 
refの後に接尾辞 @samp{@@} が続き、日付指定が中括弧のペアで囲まれています(例: @samp{@{yesterday@}} 、 @samp{@{1 month 2 weeks 3 days 1 hour 1 second ago@}} 、@samp{@{1979-02-26 18:30:00@}} )。これは以前の時点でのrefの値を指定します。この接尾辞は、ref名の直後にのみ使用でき、refには既存のログ( @samp{$GIT_DIR/logs/<ref>} )が必要です。これは、特定の時点での @strong{ローカル} refの状態を検索することに注意してください。たとえば、先週ローカルの @samp{master} ブランチに何があったか、です。特定の時間に行われたコミットを確認する場合は、 @samp{--since} と @samp{--until} を参照してください。

@item  @samp{<refname>@@@{<n>@}} 例: @samp{master@@@{1@}} 
refの後に接尾辞 @samp{@@} が続き、数の指定が中括弧のペアで囲まれている場合(たとえば @samp{@{1@}}, @samp{@{15@}})、そのrefのn個前の値を指定します。たとえば @samp{master@@@{1@}} は @samp{master} の直前の値であり、 @samp{master@@@{5@}} は @samp{master} の5個前の値です。この接頭辞は、ref名の直後にのみ使用でき、refには既存のログ( @samp{$GIT_DIR/logs/<refname>} )が必要です。

@item  @samp{@@@{<n>@}} 例: @samp{@@@{1@}} 
空のref部分で @samp{@@} コンストラクトを使用して、現在のブランチのreflogエントリを取得できます。たとえば、あなたがブランチ @samp{blabla} を使用している場合、 @samp{@@@{1@}} は @samp{blabla@@@{1@}} と同じ意味になります。

@item  @samp{@@@{-<n>@}} 例: @samp{@@@{-1@}} 
構成 @samp{@@@{-<n>@}} は、現在のブランチ/コミットの前にチェックアウトされた<n>番目のブランチ/コミットを意味します。

@item  @samp{[<branchname>]@@@{upstream@}} 例: @samp{master@@@{upstream@}}, @samp{@@@{u@}} 
ブランチ B は、 リモート R (@samp{branch.<name>.remote} で構成)で、ブランチ X (@samp{branch.<name>.merge} で構成)の上に構築するようにセットアップできます。 @samp{B@@@{u@}} は、リモート R から取られたブランチ X のリモート追跡ブランチを参照し、 通常は @samp{refs/remotes/R/X} にあります。

@item  @samp{[<branchname>]@@@{push@}} 例: @samp{master@@@{push@}}, @samp{@@@{push@}} 
接尾辞 @samp{@@\@{push@}} は、 @samp{branchname} がチェックアウトされているときに @samp{git push} が実行された場合(またはブランチ名が指定されていない場合は現在の @samp{HEAD} )、「プッシュ先」のブランチを報告します。 @samp{@@\@{upstream\@}} の場合と同様に、リモートのブランチに対応するリモート・トラッキング・ブランチを報告します。

ここで、よりはっきり分かる例を以下に示します:

@example
$ git config push.default current
$ git config remote.pushdefault myfork
$ git switch -c mybranch origin/master

$ git rev-parse --symbolic-full-name @@@{upstream@}
refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @@@{push@}
refs/remotes/myfork/mybranch
@end example


注意: この例では、ある場所からプルして別の場所にプッシュする三角形のワークフローを設定していることに注意してください。非三角形のワークフローでは、 @samp{@@\@{push@}} は @samp{@@\@{upstream@}} と同じであり、このようなことをする必要はありません。

この接尾辞は大文字で綴る場合にも受け入れられ、大文字と小文字を問わず同じことを意味します。

@item  @samp{<rev>^[<n>]} 例: @samp{HEAD^, v1.5.1^0} 
リビジョンパラメータの接尾辞 @samp{^} は、そのコミットオブジェクトの最初の親を意味します。 @samp{^<n>} は <n> 番目の親を意味します(つまり、 @samp{<rev>^} は @samp{<rev>^1} と同じです)。特別ルールとして、 @samp{<rev>^0} はコミット自体を意味し、 @samp{<rev>} がコミットオブジェクトを参照するタグオブジェクトのオブジェクト名である場合に使用されます。

@item  @samp{<rev>~[<n>]} 例: @samp{HEAD~, master~3} 
リビジョンパラメータの接尾辞 @samp{~} は、そのコミットオブジェクトの最初の親を意味します。リビジョンパラメータの接尾辞 @samp{~<n>} は、最初の親のみに続く、指定されたコミットオブジェクトの <n> 世代の祖先であるコミットオブジェクトを意味します。つまり、 @samp{<rev>~3} は @samp{<rev>^^^} と同じで、するってぇと @samp{<rev>^1^1^1} と同じということです。この形式については以下の図を参照してください。

@item  @samp{<rev>^@{<type>@}} 例: @samp{v0.99.8^@{commit@}} 
接尾辞 @samp{^} の後に中括弧のペアで囲まれたオブジェクトタイプ名が続くということは、タイプ @samp{<type>} のオブジェクトが見つかるか、オブジェクトを逆参照できなくなるまで、 @samp{<rev>} でオブジェクトを再帰的に逆参照する(この場合は、いろいろ一旦飲み込んでしまったのを吐きもどすような感じだぬ)ことを意味します。 たとえば、 @samp{<rev>} がコミットっぽい場合、 @samp{<rev>^@{commit@}} は対応するコミットオブジェクトを記述します。同様に、 @samp{<rev>} がツリーっぽい場合、 @samp{<rev>^@{tree@}} は対応するツリーオブジェクトを記述します。 @samp{<rev>^0} は @samp{<rev>^@{commit@}} の省略形です。

@samp{<rev>^@{object@}} を使用すると、 @samp{<rev>} がタグである必要がなく、 @samp{<rev>} を逆参照することなく、 @samp{<rev>} が存在するオブジェクトに名前を付けることができます。なお、タグはすでにオブジェクトであるため、オブジェクトに到達するために一度も逆参照する必要はありません。

@samp{<rev>^@{tag@}} を使用して、 @samp{<rev>} が既存のタグオブジェクトを確実に識別することができます。

@item  @samp{<rev>^@{@}} 例: @samp{v0.99.8^@{@}} 
接尾辞 @samp{^} の後に空のブレースペアが続くということは、オブジェクトがタグである可能性があることを意味し、タグ以外のオブジェクトが見つかるまでタグを再帰的に逆参照します。

@item  @samp{<rev>^@{/<text>@}} 例: @samp{HEAD^@{/fix nasty bug@}} 
リビジョンパラメータの接尾辞 @samp{^} と、それに続くスラッシュで始まるテキストを含む中括弧のペアは、以下の @samp{:/fix nasty bug} 構文と同じですが、 @samp{^} の前の @samp{<rev>} から到達可能な一致する最も若いコミットを返す点が異なります。

@item  @samp{:/<text>} 例: @samp{:/fix nasty bug} 
コロンに続いてスラッシュそしてそれに続くテキストは、コミットメッセージが指定された正規表現と一致するコミットを示します。この名前は、HEADを含む任意のrefから到達可能な最も若い一致するコミットを返します。正規表現は、コミットメッセージの任意の部分に一致できます。文字列で始まるメッセージを照合するには、たとえば、 @samp{:/^foo} とします。特別なシーケンス @samp{:/!} はマッチングの修飾子用に予約されています。ます。 @samp{:/!-foo} は一致の否定を実行し、 @samp{:/!!foo} はリテラル @samp{!} 後に @samp{foo} が続く文字列とマッチします。 @samp{:/!} で始まるその他のシーケンスは今のところ予約されています。指定されたテキストによっては、シェルにより追加の引用符が必要になる場合があります。

@item  @samp{<rev>:<path>} 例: @samp{HEAD:README}, @samp{master:./README} 
接尾辞 @samp{:} の後にパス(path)を続けると、コロンの前の部分によって名前が付けられたツリー風のオブジェクト内の、指定されたパスにあるブロブまたはツリーに名前が付けられます。 @samp{./} または @samp{../} で始まるパスは、現在の作業ディレクトリからの相対パスです。指定のパスは、作業ツリーのルートディレクトリからの相対パスに変換されます。これは、作業ツリーと同じツリー構造を持つコミットまたはツリーからブロブまたはツリーをアドレス指定するのに最も役立ちます。

@item  @samp{:[<n>:]<path>} 例: @samp{:0:README}, @samp{:README} 
コロンに、オプションでステージ番号(0〜3)とコロンが続き、それにパスが続くと、指定されたパスのインデックス内のブロブオブジェクトに名前を付けます。ステージ番号省略(およびそれに続くコロン)は、ステージ0エントリーを示します。マージ作業中、ステージ1は共通の祖先、ステージ2はターゲットブランチのバージョン(通常は現在のブランチ)、ステージ3はマージされるブランチのバージョンです。
@end table

以下はJon Loeligerによる図解です。コミットノードBとCはどちらもコミットノードAの親です。親コミットは左から右に順序付けられます。

@example
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
@end example

@example
A =      = A^0
B = A^   = A^1     = A~1
C =      = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
@end example

@noindent

@chapheading SPECIFYING RANGES

@samp{git log} などの履歴トラバースコマンドは、単一のコミットだけでなく、一連のコミットで動作します。

これらのコマンドの場合、前のセクションで説明した表記法を使用して単一のリビジョンを指定することは、指定のコミットから「到達可能」なコミットの組を意味します。

複数のリビジョンを指定するということは、指定のコミットのいずれかから到達可能なコミットの組を意味します。

コミットの到達可能な組は、コミット自体とその祖先チェーン内のコミットです。

以下に示すように、接続されたコミット(connected commits)の組(「リビジョン範囲」(revision range)と呼ばれる)を指定するためのいくつかの表記法があります。

@noindent

@heading Commit Exclusions

@table @asis

@item  @samp{^<rev>} (カレット)記法 
とある到達可能なコミットをコミット達から除外するには、接頭辞 @samp{^} 表記を使用します。 例えば @samp{^r1 r2} は @samp{r2} から到達可能なコミットだけども、 @samp{r1} から到達可能なコミット(つまり @samp{r1} とその祖先)は除外する事を意味します。
@end table

@noindent

@heading Dotted Range Notations

@table @asis

@item  @samp{..} (2ドット)範囲記法 
@samp{^r1 r2} 操作は頻繁に表示されるため、省略形があります。(上記の SPECIFYING REVISIONS で説明されている構文に従って名前が付けられている)2つのコミット @samp{r1} と @samp{r2} がある場合、あなたは @samp{^r1 r2} によってr1から到達可能なコミットを取り除き、r2から到達可能なコミットを要求できます。そしてこれは @samp{r1..r2} と書くことができます。

@item  @samp{...} (3ドット)対称差記法 
似た表記 @samp{r1...r2} は @samp{r1} と @samp{r2} の対称差と呼ばれ、 @samp{r1 r2 --not $(git merge-base --all r1 r2)} として定義されます。 これは、 @samp{r1} (左側)または @samp{r2} (右側)のいずれかから到達可能であるが、両方からは到達できないコミットの組です。
@end table

これらの2つの省略表記では、一方の端を省略して、デフォルトでHEADにすることができます。たとえば、 @samp{origin..} は @samp{origin..HEAD} の省略形であり、「originブランチから分岐(fork)してから何をしましたか？」と尋ねます。 同様に、 @samp{..origin} は @samp{HEAD..origin} の省略形であり、「私がそれらから分岐してから、originは何をしましたか？」と尋ねます。 @samp{..} は @samp{HEAD..HEAD} を意味することに注意してください。これは、HEADから到達可能および到達不能の両方の空の範囲です。

2つの異なる範囲を取るように特別に設計されたコマンド(たとえば、2つの範囲を比較するための "git range-diff R1 R2" ) は存在しますが、それらは例外です。特に明記されていない限り、一連のコミットを操作するすべての "git" コマンドは、単一のリビジョン範囲で機能します。言い換えると、2つの「2ドット範囲表記」を隣り合わせに記述します。

@example
$ git log A..B C..D
@end example

ほとんどのコマンドでは2つのリビジョン範囲を指定しません。代わりに、接続された単一のコミットの組、つまりBまたはDのいずれかから到達可能であるが、AまたはCのどちらからも到達可能でないコミットの組に名前を付けます。線形履歴では、以下のようになります:

@example
---A---B---o---o---C---D
@end example

AとBはCから到達可能であるため、これら2つの2ドット範囲記法で指定されたリビジョン範囲は単一のコミットDです。

@noindent

@heading Other <rev>^ Parent Shorthand Notations

コミットとその親コミットによって形成される組に名前を付けるために、マージコミットに特に役立つ他の3つの省略形が存在します。

@samp{r1^@@} 表記は、 @samp{r1} のすべての親を意味します。

@samp{r1^!} 表記には コミット @samp{r1} が含まれますが、そのすべての親は除外されます。この表記自体は、単一のコミット @samp{r1} を示します。

@samp{<rev>^-[<n>]} 表記には @samp{<rev>} が含まれますが、 <n> 番目の親(つまり、 @samp{<rev>^<n>..<rev>} の省略形)は除外されます。 <n> が指定されていない場合は @samp{<n>} = 1 とみなします。これは通常、 @samp{<commit>^-} を渡すだけで、マージコミット @samp{<commit>}(@samp{<commit>} 自体を含む)でマージされたブランチ内のすべてのコミットを取得できるマージコミットに役立ちます。

@samp{<rev>^<n>} は単一のコミット親を指定することに関するものでしたが、これらの3つの表記はその親も考慮します。たとえば、 @samp{HEAD^2^@@} と言うことはできますが、 @samp{HEAD^@@^2} と言うことはできません。

@noindent

@chapheading Revision Range Summary

@table @asis

@item  @samp{<rev>} 
<rev> から到達可能なコミット(つまり <rev> とその祖先)を含めます。

@item  @samp{^<rev>} 
<rev> から到達可能なコミット(つまり <rev> とその祖先)を除外します。

@item  @samp{<rev1>..<rev2>} 
<rev2> から到達可能なコミットを含めますが、 <rev1> から到達可能なコミットは除外します。 <rev1> または <rev2> のいずれかを省略すると、それらはそれぞれデフォルトで @samp{HEAD} になります。

@item  @samp{<rev1>...<rev2>} 
<rev1> または <rev2> のいずれかから到達可能なコミットを含めますが、両方から到達可能なコミットは除外します。 <rev1> または <rev2> のいずれかを省略すると、それらはそれぞれデフォルトで @samp{HEAD} になります。

@item  @samp{<rev>^@@} 例: @samp{HEAD^@@} 
接尾辞 @samp{^} の後にアットマーク(@samp{@@})を付けることは、 @samp{<rev>} のすべての親をリストすることと同じです(つまり、親から到達可能なものはすべて含まれますが、コミット自体は含まれません)。

@item  @samp{<rev>^!} 例: @samp{HEAD^!} 
A suffix @emph{^} followed by an exclamation mark is the same as giving commit @emph{<rev>} and all its parents prefixed with @emph{^} to exclude them (and their ancestors).

@item  @samp{<rev>^-<n>} 例: @samp{HEAD^-, HEAD^-2} 
@samp{<rev>^<n>..<rev>} と同等であり、 @samp{<n>} が指定されていない場合は @samp{<n>} = 1 です。
@end table

上記のLoeliger図解を使用したいくつかの例を以下に示します。表記の拡張と選択は、それぞれ段階が分かるようステップを踏んで説明してあります:

@example
   Args   Expanded arguments    Selected commits
   D                            G H D
   D F                          G H I J D F
   ^G D                         H D
   ^D B                         E I J F B
   ^D B C                       E I J F B C
   C                            I J F C
   B..C   = ^B C                C
   B...C  = B ^F C              G H D E B C
   B^-    = B^..B
          = ^B^1 B              E I J F B
   C^@@    = C^1
          = F                   I J F
   B^@@    = B^1 B^2 B^3
          = D E F               D G H E F I J
   C^!    = C ^C^@@
          = C ^C^1
          = C ^F                C
   B^!    = B ^B^@@
          = B ^B^1 ^B^2 ^B^3
          = B ^D ^E ^F          B
   F^! D  = F ^I ^J D           G H D F
@end example

@noindent

@chapheading PARSEOPT

@samp{--parseopt} モードでは、 @samp{git rev-parse} は、オプションをもみもみして、Cビルトインと同じ機能をシェルスクリプトにもたらすのに役立ちます。これは、 @samp{getopt(1)} と少し似た、オプションの正規化機能です(たとえば、単一のスイッチの集合を分割します)。

パースおよび理解できるオプションの仕様を標準入力で受け取り、引数を正規化されたものに置き換えるために、@samp{sh(1)} @samp{eval} に適した文字列をエコーします。エラーが発生した場合は、標準エラーストリームで使用状況を出力し、コード129で終了します。

注: 結果を @samp{eval} に渡すときは、必ず引用符で囲んでください。例については、以下を参照してください。

@noindent

@heading Input Format

@samp{git rev-parse --parseopt} 入力形式は完全にテキストベースです。 @samp{--} のみを含む行で区切られた2つの部分から構成されます。セパレーターの前の行(1つ以上である必要があります)が使用例に使用されます。区切り文字の後の行は、オプションを示しています。

オプションの各行の形式はいかのとおりです:

@example
<opt-spec><flags>*<arg-hint>? SP+ help LF
@end example


@table @asis

@item  @samp{<opt-spec>} 
この形式は、短いオプション1文字で、続いてコンマ(@emph{,})で区切り、そして長いオプション名があります。少なくとも短長のうち1つは必要ですが、両方揃ってなくてもいいです。 @samp{<flags>} 文字を含めることはできません。 @samp{h,help} や @samp{dry-run} や @samp{f} は正しい @samp{<opt-spec>} の例です。

@item  @samp{<flags>} 
@samp{<flags>} とは @samp{*} または @samp{=} または @samp{?} または @samp{!} です。

@itemize 

@item
オプションが引数を取る場合は、 @samp{=} を使用します。

@item
@samp{?} の使用は、オプションがオプションの引数を取ることを意味します。オプションの引数を明確に解析できるようにするには、おそらく @samp{--stuck-long} モードを使用する必要があります。

@item
@samp{*} を使用すると、このオプションが @samp{-h} 引数に対して生成された使用法にリストされてはならないことを意味します。 gitcli(7) に記載されているように、 @samp{--help-all} には表示されます。

@item
@samp{！} を使用すると、対応する否定されたlongオプションを使用可能にしません。
@end itemize

@item  @samp{<arg-hint>} 
@samp{<arg-hint>} は、指定された場合、引数を取るオプションのヘルプ出力で引数の名前として使用されます。 @samp{<arg-hint>} は最初の空白で終了します。複数単語の引数ヒントで単語を区切りたい時は、ダッシュを使う通例です。
@end table

スペースを取り除いた後の行の残りの部分は、オプションに関連付けられたヘルプとして使用されます。

空白行は無視され、この仕様に一致しない行はオプショングループヘッダーとして使用されます(意図的にそのような行を作成するためにはスペースで行を開始します)。

@noindent

@heading Example

@example
OPTS_SPEC="\
some-command [<options>] <args>...

some-command does foo and bar!
--
h,help    show the help

foo       some nifty option --foo
bar=      some cool option --bar with an argument
baz=arg   another cool option --baz with a named argument
qux?path  qux may take a path argument but has meaning by itself

  An option group Header
C?        option C with an optional argument"

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@@" || echo exit $?)"
@end example


@noindent

@heading Usage text

上記の例で @samp{"$@@"} が @samp{-h} または @samp{--help} の場合、以下の使用法テキストが表示されます:

@example
usage: some-command [<options>] <args>...

    some-command does foo and bar!

    -h, --help            show the help
    --foo                 some nifty option --foo
    --bar ...             some cool option --bar with an argument
    --baz <arg>           another cool option --baz with a named argument
    --qux[=<path>]        qux may take a path argument but has meaning by itself

An option group Header
    -C[...]               option C with an optional argument
@end example


@noindent

@chapheading SQ-QUOTE

@samp{--sq-quote} モードでは、 @samp{git rev-parse} は、 @samp{sh(1)} @samp{eval} に適した1行を標準出力にエコーします。この行は、 @samp{--sq-quote} に続く引数を正規化することによって作成されます。引数をクォートする以外に何も行いません。

出力がシェル引用符で囲まれる前に、コマンド入力を @samp{git rev-parse} によって通常どおりに解釈するには @samp{--sq} オプションを参照してください。

@noindent

@heading Example

@example
$ cat >your-git-script.sh <<\EOF
#!/bin/sh
args=$(git rev-parse --sq-quote "$@@")   # quote user-supplied arguments
command="git frotz -n24 $args"          # and use it inside a handcrafted
                                        # command line
eval "$command"
EOF

$ sh your-git-script.sh "a b'c"
@end example


@noindent

@chapheading EXAMPLES

@itemize 

@item
現在のコミットのオブジェクト名を出力します:

@example
$ git rev-parse --verify HEAD
@end example


@item
$REV シェル変数のリビジョンからコミットオブジェクト名を出力します:

@example
$ git rev-parse --verify --end-of-options $REV^@{commit@}
@end example


$REV が空であるか、有効なリビジョンでない場合エラーになります。

@item
上記と同様ですが…:

@example
$ git rev-parse --default master --verify --end-of-options $REV
@end example


これは、 $REV が空の場合、masterからのコミットオブジェクト名が出力されます。
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-revert,,,Top
@chapheading Name

git-revert — いくつかの既存のコミットを元に戻します

@noindent

@chapheading Synopsis

@display
git revert [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] <commit>…
git revert (--continue | --skip | --abort | --quit)
@end display


@noindent

@chapheading DESCRIPTION

1つ以上の既存のコミットが与えられた場合、関連するパッチによって導入された変更を元に戻し、それらを記録するいくつかの新しいコミットを記録します。これには、作業ツリーがクリーンである必要があります(HEADコミットからの変更はありません)。

注意: @samp{git revert} は、いくつかの新しいコミットを記録して、以前のコミットの効果を元に戻すために使用されます(多くの場合、障害のあるコミットのみ)。あなたが作業ディレクトリ内のコミットされていないすべての変更を破棄したい場合は、 git-reset(1) 、特に @samp{--hard} オプションについて参照すべきです。あなたが別のコミットから特定のファイルを抽出したい場合は、 git-restore(1) 、特に @samp{--source} オプションについて参照すべきです。これらは作業ディレクトリ内のコミットされていない変更を破棄するため、これらの選択肢には注意してください。

3つのコマンドの違いについては、 git(1) の「Reset, restore and revert」を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  <commit>… 
元に戻すためのコミットを指定。コミット名を綴る方法のより完全なリストについては、 gitrevisions(7) を参照してください。コミットのセットを指定することもできますが、デフォルトではトラバーサルは実行されません。 git-rev-list(1) と、その @samp{--no-walk} オプションを参照してください。

@item  @samp{-e} 
@itemx  @samp{--edit} 
このオプションを使用すると、 @samp{git revert} は「戻し」(the revert)をコミットする前にあなたにコミットメッセージを編集させます。これは、端末からコマンドを実行する場合のデフォルトです。

@item  @samp{-m parent-number} 
@itemx  @samp{--mainline parent-number} 
通常、マージのどの筋を本線(mainline)と見なすかわからないため、マージを元に戻すことはできません。 このオプションは、本線とする親番号(1から始まる)を指定し、指定された親を基準にして変更を元に戻すことができます。

マージコミットを戻す(revert)と、そのマージによってもたらされたツリーの変更が不要になることが宣言されます。その結果、その後に行われるマージでは、先に戻されたマージの先祖ではないコミットによってもたらされたツリーの変更のみが適用されます。これはあなたの望むところかもしれませんし、そうでないかもしれません。

詳細については、 @uref{howto/revert-a-faulty-merge.html,revert-a-faulty-merge How-To} (誤ったマージの取り消し方法)を参照してください。

@item  @samp{--no-edit} 
このオプションを使うと、 @emph{git revert} はコミットメッセージエディタを起動しません。

@item  @samp{--cleanup=<mode>} 
このオプションは、コミットメッセージがコミット機構に渡される前にどのようにクリーンアップされるかを決定します。詳細については、git-commit(1) を参照してください。 特に、競合が発生した場合、 <mode> に値 @samp{scissors} が指定されていると、渡される前に、MERGE_MSG に切り取り線が追加されます。

@item  @samp{-n} 
@itemx  @samp{--no-commit} 
通常、コマンドは、どのコミットが元に戻されたかを示すコミットログメッセージを含むいくつかのコミットを自動的に作成します。このフラグは、名前付きコミットを作業ツリーとインデックスに戻すために必要な変更を適用(apply)しますが、コミットは行いません。さらに、このオプションを使用する場合、インデックスはHEADコミットと一致する必要はありません。 revertは、あなたのインデックスの開始状態に対して行われます。

これは、複数のコミットの効果を連続してインデックスにrevertする場合に役立ちます。

@item  @samp{-S[<keyid>]} 
@itemx  @samp{--gpg-sign[=<keyid>]} 
@itemx  @samp{--no-gpg-sign} 
GPG署名コミット。 @samp{keyid} 引数はオプションであり、デフォルトはコミッターIDになります。指定する場合は、スペースなしでオプションに指定する必要があります。 @samp{--no-gpg-sign} は、 @samp{commit.gpgSign} 構成変数と、 それより前で指定された @samp{--gpg-sign} の両方を打ち消すのに役立ちます。

@item  @samp{-s} 
@itemx  @samp{--signoff} 
コミットメッセージの最後に @samp{Signed-off-by} トレーラーを追加します。 詳細については、 git-commit(1) の signoff オプションを参照してください。

@item  @samp{--strategy=<strategy>} 
指定されたマージ戦略を使用します。指定できるのは一度だけです。詳細については、 git-merge(1) の「MERGE STRATEGIES」セクションを参照してください。

@item  @samp{-X<option>} 
@itemx  @samp{--strategy-option=<option>} 
マージ戦略固有のオプションをマージ戦略に渡します。詳細については、 git-merge(1) を参照してください。

@item  @samp{--rerere-autoupdate} 
@itemx  @samp{--no-rerere-autoupdate} 
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 @samp{--no-rerere-autoupdate} は、別の @samp{git add} で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。

@item  @samp{--reference} 
ログ・メッセージの本文を "This reverts <full object name of the commit being reverted>." で始める代わりに、 @samp{--pretty=reference} 形式を使用してコミットを参照します(git-log(1) 参照)。 @samp{revert.reference} 構成変数を使用して、このオプションをデフォルトで有効にすることができます。
@end table

@noindent

@chapheading SEQUENCER SUBCOMMANDS

@table @asis

@item  @samp{--continue} 
@samp{.git/sequencer} の情報を使用して、進行中の操作の続行を行います。失敗したcherry-pickまたはrevertの競合を解決した後、続行するために使用できます。

@item  @samp{--skip} 
現在のコミットをスキップして、残りのシーケンスを続行します。

@item  @samp{--quit} 
進行中の今回の操作を忘れてください。チェリーピックまたはrevertに失敗した後、シーケンサーの状態をクリアするために使用できます。

@item  @samp{--abort} 
操作をキャンセルして、シーケンス操作前の状態に戻ります。
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git revert HEAD~3} 
HEADの最後から4番目のコミットで指定された変更を元に戻し、元に戻した変更を使用して新しいコミットを作成します。

@item  @samp{git revert -n master~5..master~2} 
コミットによって行われた変更を、masterの最後から5番目のコミット(それ自身を含む)から、masterの最後から3番目のコミット(それ自身を含む)に戻しますが、元に戻した変更でコミットを作成しないでください。元に戻すと、作業ツリーとインデックスのみが変更されます。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  revert.reference 
この変数を true に設定すると、 @samp{git revert} は @samp{--reference} オプションが指定されているかのように振る舞います。
@end table

@noindent

@chapheading SEE ALSO

git-cherry-pick(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-rm,,,Top
@chapheading Name

git-rm — 作業ツリーとインデックスからファイルを削除します

@noindent

@chapheading Synopsis

@display
git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
          [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

pathspecに一致するファイルをインデックスから、または作業ツリーとインデックスから削除します。 @samp{git rm} は、作業ディレクトリだけからファイルを削除することはありません。 (作業ツリーからのみファイルを削除し、それをインデックスに保持するオプションはありません。必要に応じて、 @samp{/bin/rm} を使用してください。) 削除されるファイルはブランチの先端と同一である必要があり、その内容の更新をインデックスにステージングすることはできませんが、そのデフォルトの動作は @samp{-f} オプションでオーバーライドできます。 @samp{--cached} が指定されている場合、ステージングされたコンテンツはブランチの先端またはディスク上のファイルのいずれかに一致する必要があり、ファイルをインデックスからのみ削除できます。 スパースチェックアウトが使用されている場合(git-sparse-checkout(1) を参照)、 @samp{git rm} はスパースチェックアウトパターン内のパスのみを削除します。

@noindent

@chapheading OPTIONS

@table @asis

@item  <pathspec>… 
削除するファイル。先頭のディレクトリ名(たとえば、削除する @samp{dir/file1} や @samp{dir/file2} の @samp{dir})を指定して、ディレクトリ内のすべてのファイル削除でき、そして、 @samp{-r} オプションを明示的に指定する必要がありますが、再帰的にすべてのサブディレクトリを削除できます。

このコマンドは、Gitに認識されているパスのみを削除します。

ファイルグロブはディレクトリの境界を越えて一致します。 したがって、2つのディレクトリ @samp{d} と @samp{d2} が与えられた場合、 @samp{git rm 'd*'} と @samp{git rm 'd/*'} は異なります。前者はディレクトリ @samp{d2} もすべて削除するからです。

詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。

@item  @samp{-f} 
@itemx  @samp{--force} 
更新チェックをオーバーライドします。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
実際にファイルを削除することはありません。代わりに、インデックスに存在するか、でなければコマンドによって削除されるかを示すだけです。

@item  @samp{-r} 
先頭のディレクトリ名が指定されている場合は、再帰的な削除を許可します。

@item  @samp{--} 
このオプションは、コマンドラインオプションをファイルのリストから分離するために使用できます(ファイル名がコマンドラインオプションと間違えられる可能性がある場合に便利です)。

@item  @samp{--cached} 
このオプションを使用して、インデックス分のみパスをステージング解除して削除します。作業ツリーファイルは、変更されているかどうかに関係なく、そのまま残されます。

@item  @samp{--ignore-unmatch} 
一致するファイルがない場合にも、ステータスがゼロで終了(exit)します。

@item  @samp{--sparse} 
スパース・チェックアウト・コーンの外側でインデックス・エントリを更新できるようにします。 通常、 @samp{git rm} は、パスがスパース・チェックアウト・コーン内に収まらないインデックス・ エントリの更新を拒否します。 詳細については、git-sparse-checkout(1) を参照してください。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{git rm} は通常、削除されたファイルごとに1行(@samp{rm} コマンドの形式で)を出力します。 このオプションは、その出力を抑制します。

@item  @samp{--pathspec-from-file=<file>} 
パススペックは、コマンドライン引数の代わりに <file> で渡されます。 <file> が正確に @samp{-} の場合、標準入力が使用されます。 パススペック要素は、LFまたはCR/LFで区切られます。 パススペック要素は、構成変数 @samp{core.quotePath} で説明されているようにクォートできます(git-config(1)を参照)。 @samp{--pathspec-file-nul} および グローバルの @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
@samp{--pathspec-from-file} でのみ意味があります。 パススペック要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。
@end table

@noindent

@chapheading ファイルシステムから消えたファイルの削除

@samp{git rm} には、ファイルシステムから消えたパスのみをインデックスから削除するオプションはありません。 ただし、ユースケースに応じて、実行できる方法がいくつかあります。

@noindent

@heading git commit -a の使用

次回のコミットで、作業ツリー内の追跡対象ファイルのすべての変更を記録し、作業ツリーから削除されたファイルのすべての削除を(@samp{git rm} ではなく、) @samp{rm} で記録する場合は、すべての削除を自動的に通知して記録するため、 @samp{git commit -a} を使用します。 @samp{git add -u} を使用してコミットせずに同様の効果を得ることもできます。

@noindent

@heading git add -A の使用

ベンダーブランチの新しいコードドロップを受け入れる場合は、パスの削除と新しいパスの追加、および既存のパスの変更の両方を記録する必要があります。

通常、最初に以下のコマンドを使用して、追跡中のすべてのファイルを作業ツリーから削除します:

@example
git ls-files -z | xargs -0 rm -f
@end example


次に、作業ツリーで新しいコードを解凍(untar)します。または、変更を作業ツリーに「rsync」することもできます。

その後、作業ツリーのすべての削除、追加、および変更を記録する最も簡単な方法は以下のとおりです:

@example
git add -A
@end example


git-add(1) 参照。

@noindent

@heading Other ways

あなたが本当にやりたいのは作業ツリーに存在しなくなったファイルをインデックスから削除することだけである場合(おそらく、作業ツリーが汚れているために @samp{git commit -a} を使用できない)、以下のコマンドを使用します:

@example
git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached
@end example


@noindent

@chapheading SUBMODULES

リポジトリはスーパープロジェクトの @samp{.git} ディレクトリ内にあるため、gitfileを使用するサブモジュール(つまり、Gitバージョン1.7.8以降で複製されたもの)のみが作業ツリーから削除されます。 サブモジュール(またはその中にネストされているものの1つ)がまだ @samp{.git} ディレクトリを使用している場合、 @samp{git rm} はサブモジュールの履歴を保護するためにサブモジュールのgitディレクトリをスーパープロジェクトのgitディレクトリに移動します。 存在する場合は、 gitmodules(5) ファイルの submodule.<name> セクションも削除され、そのファイルがステージングされます(@samp{--cached} または @samp{-n} が使用されている場合を除く)。

HEADがインデックスに記録されているものと同じであり、追跡中のファイルが変更されておらず、無視されない追跡中でないファイルがサブモジュールの作業ツリーに存在しない場合、サブモジュールは最新であると見なされます。 無視されたファイルは消耗品と見なされ、サブモジュールの作業ツリーの削除を停止しません。

あなたが削除をコミットせずにサブモジュールのローカルチェックアウトのみを作業ツリーから削除する場合は、代わりに git-submodule(1) の @samp{deinit} を使用してください。 サブモジュールの削除の詳細については、 gitsubmodules(7) も参照してください。

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git rm Documentation/\*.txt} 
@samp{Documentation} ディレクトリとそのサブディレクトリの下にあるすべての @samp{*.txt} ファイルをインデックスから削除します。

注意: この例では、アスタリスク(@samp{*})がシェルからクォートされていることに注意してください。これにより、シェルではなくGitが、@samp{Documentation/} ディレクトリの下にあるファイルとサブディレクトリのパス名を展開できるようになります。

@item  @samp{git rm -f git-*.sh} 
この例では、シェルでアスタリスクを展開できるため(つまり、あなたはファイルを明示的にリストしているため)、 @samp{subdir/git-foo.sh} は削除されません。
@end table

@noindent

@chapheading BUGS

スーパープロジェクトの更新により、入力されたサブモジュールが削除されるたびに(たとえば、削除の前後でコミットを切り替える場合)、古いサブモジュールのチェックアウトは古い場所に残ります。古いディレクトリの削除は、gitfileを使用している場合にのみ安全です。そうしないと、サブモジュールの履歴も削除されます。 この手順は、サブモジュールの再帰的な更新が実装されている場合は廃止されます。

@noindent

@chapheading SEE ALSO

git-add(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-send-email,,,Top
@chapheading Name

git-send-email — パッチの集まりを電子メールとして送信します

@noindent

@chapheading Synopsis

@display
git send-email [<options>] <file|directory>…
git send-email [<options>] <format-patch options>
git send-email --dump-aliases
@end display


@noindent

@chapheading DESCRIPTION

コマンドラインで指定されたパッチを取得し、電子メールで送信します。 パッチは、ファイルまたは、ディレクトリ(ディレクトリ内のすべてのファイルを送信します)または、リビジョンリストとして直接指定できます。 SYNOPSISの最後のケースでは、git-format-patch(1) によって受け入れられる任意のフォーマットと、git-format-patch(1) によって理解されるオプションを「git send-email」に渡すことができます。

電子メールのヘッダーは、コマンドラインオプションを使用して構成できます。 コマンドラインで指定されていない場合、ReadLine対応のインターフェイスでユーザーが必要な情報を提供するためのプロンプトが表示されます。

パッチファイルに使用できる形式は2つあります:

@enumerate 

@item
mbox形式ファイル

これは、 git-format-patch(1) が生成するものです。 ほとんどのヘッダーとMIMEフォーマットは無視されます。

@item
Greg Kroah-Hartman の @samp{send_lots_of_email.pl} スクリプトで使用されたオリジナル形式

この形式では、ファイルの1行目に「Cc:」値が含まれ、2行目としてメッセージの「Subject:」が含まれている必要があります。
@end enumerate

@noindent

@chapheading OPTIONS

@noindent

@heading 電子メール作成

@table @asis

@item  @samp{--annotate} 
送信しようとしている各パッチを確認して編集します。 デフォルトは @samp{sendemail.annotate} の値です。 `sendemail.multiEdit`の「CONFIGURATION」セクションを参照してください。

@item  @samp{--bcc=<address>,...} 
メールごとに「Bcc:」の値を指定します。 デフォルトは @samp{sendemail.bcc} の値です。

このオプションは複数回指定できます。

@item  @samp{--cc=<address>,...} 
各電子メールの開始「Cc:」値(starting "Cc:" value)を指定します。 デフォルトは @samp{sendemail.cc} の値です。

このオプションは複数回指定できます。

@item  @samp{--compose} 
テキストエディタ(git-var(1)の GIT_EDITOR 参照)を呼び出して、パッチシリーズの紹介メッセージ(introductory message)を編集します。

@samp{--compose} が使用されている場合、 @samp{git send-email} は、メッセージで指定されているFromとSubjectとIn-Reply-Toヘッダーを使用します。 メッセージの本文(ヘッダーと空行の後に入力するもの)に空行(または Git: プレフィックス)のみが含まれている場合、要約は送信されませんが、FromとSubjectとIn-Reply-Toヘッダーは削除されない限り使用されます。

From ヘッダー または In-Reply-To ヘッダーが無い時はプロンプトが表示されます。

@samp{sendemail.multiEdit} の「CONFIGURATION」セクションを参照してください。

@item  @samp{--from=<address>} 
電子メールの送信者(sender)を指定します。 コマンドラインで指定されていない場合は、@samp{sendemail.from} 構成オプションの値が使用されます。 コマンドラインオプションも @samp{sendemail.from} も設定されていない場合、ユーザーは値の入力を求められます。 そのプロンプトのデフォルトは、 @samp{git var -l} によって返される、GIT_AUTHOR_IDENTの値、または、GIT_AUTHOR_IDENTが設定されていない場合はGIT_COMMITTER_IDENTの値になります。

@item  @samp{--reply-to=<address>} 
受信者からの返信先(reply)のアドレスを指定します。 メッセージへの応答(reply)が @samp{--from} パラメーターで指定されたものとは別のアドレスに送信される必要がある場合は、これを使用します。

@item  @samp{--in-reply-to=<identifier>} 
Make the first mail (or all the mails with @samp{--no-thread}) appear as a reply to the given Message-ID, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the @samp{--[no-]chain-reply-to} setting.

そのため、例えば @samp{--thread} と @samp{--no-chain-reply-to} を指定すると、以下のように @samp{[PATCH v2 0/3]} が @samp{[PATCH 0/2]} に対する返信になるように、2番目以降のパッチは最初のパッチへの返信になります:

@example
[PATCH 0/2] Here is what I did...
  [PATCH 1/2] Clean up and tests
  [PATCH 2/2] Implementation
  [PATCH v2 0/3] Here is a reroll
    [PATCH v2 1/3] Clean up
    [PATCH v2 2/3] New tests
    [PATCH v2 3/3] Implementation
@end example

@samp{--compose} も設定されている場合のみ必要です。 @samp{--compose} が設定されていない場合は、プロンプトが表示されます。

@item  @samp{--subject=<string>} 
メールスレッドの最初の件名を指定します。 @samp{--compose} も設定されている場合にのみ必要です。 @samp{--compose} が設定されていない場合、これはプロンプトが表示されます。

@item  @samp{--to=<address>,...} 
生成された電子メールの主な受信者(primary recipient)を指定します。 通常、これは関連するプロジェクトの上流のメンテナになります。 デフォルトは、 @samp{sendemail.to} 構成値の値です。 それが指定されておらず、 @samp{--to-cmd} が指定されていない場合、プロンプトが表示されます。

このオプションは複数回指定できます。

@item  @samp{--8bit-encoding=<encoding>} 
エンコードを宣言していない非ASCIIメッセージまたは件名に遭遇した場合は、 ヘッダー/引用符 を追加して、<encoding>でエンコードされていることを示します。 デフォルトは @samp{sendemail.assume8bitEncoding} の値です。 それが指定されていない場合に非ASCIIファイルが検出された場合はプロンプトが表示されます。

注意:エンコーディングを検証する試みは一切行われないことに注意してください。

@item  @samp{--compose-encoding=<encoding>} 
作成するッセージのエンコードを指定します。 デフォルトは @samp{sendemail.composeencoding} の値です。 それが指定されていない場合は、UTF-8 を想定されます。

@item  @samp{--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)} 
SMTP経由でメッセージを送信するために使用する転送エンコーディングを指定します。 非ASCIIメッセージに遭遇すると、 @samp{7bit} は失敗します。 @samp{quoted-printable} は、リポジトリにキャリッジリターンを含むファイルが含まれている場合に役立ちますが、生のパッチ電子メールファイル(MUAで保存されたもの)を手動で検査するのがとても難しくなります。 @samp{base64} はさらに確実ですが、さらに不透明です。 @samp{auto} は、可能な場合は8ビットを使用し、それ以外の場合は @samp{quoted-printable} を使用します。

デフォルトは、@samp{sendemail.transferEncoding} 構成値です。 それが指定されていない場合、デフォルトは @samp{auto} です。

@item  @samp{--xmailer} 
@itemx  @samp{--no-xmailer} 
@samp{X-Mailer:} ヘッダーを追加(または追加を防止)します。 デフォルトでは追加されますが、 @samp{sendemail.xmailer} 構成変数を @samp{false} に設定することでオフにできます。
@end table

@noindent

@heading 電子メール送信

@table @asis

@item  @samp{--envelope-sender=<address>} 
メールの送信に使用するエンベロープ(envelope)の送信者を指定します。 これは、デフォルトのメールアドレスがメーリングリストに申し込まれているメールアドレスではない場合に役立ちます。 @samp{From} アドレスを使用するには、値を @samp{auto} 」に設定します。 sendmailバイナリを使用する場合は、 @samp{-f} パラメータに適切な権限が必要です。 デフォルトは、 @samp{sendemail.envelopeSender} 構成変数の値です。 それが指定されていない場合、エンベロープ送信者の選択はMTAに任されています。

@item  @samp{--sendmail-cmd=<command>} 
電子メールを送信するために実行するコマンドを指定します。 コマンドはsendmailのようなものでなければなりません。 具体的には、 @samp{-i} オプションをサポートする必要があります。 コマンドは、必要に応じてシェルで実行されます。 デフォルトは @samp{sendemail.sendmailcmd} 構成の値です。 @samp{sendemail.sendmailcmd} 構成の値が指定されていない場合、かつ、 @samp{--smtp-server} も指定されていない場合、 @samp{git-send-email} は @samp{/usr/sbin} と @samp{/usr/lib} と $PATH で @samp{sendmail} を検索します。

@item  @samp{--smtp-encryption=<encryption>} 
Specify in what way encrypting begins for the SMTP connection. Valid values are @emph{ssl} and @emph{tls}. Any other value reverts to plain (unencrypted) SMTP, which defaults to port 25. Despite the names, both values will use the same newer version of TLS, but for historic reasons have these names. @emph{ssl} refers to "implicit" encryption (sometimes called SMTPS), that uses port 465 by default. @emph{tls} refers to "explicit" encryption (often known as STARTTLS), that uses port 25 by default. Other ports might be used by the SMTP server, which are not the default. Commonly found alternative port for @emph{tls} and unencrypted is 587. You need to check your provider’s documentation or your server configuration to make sure for your own case. Default is the value of @samp{sendemail.smtpEncryption}.

@item  @samp{--smtp-domain=<FQDN>} 
SMTPサーバーへの HELO/EHLO コマンドで使用される完全修飾ドメイン名(FQDN)を指定します。 一部のサーバーでは、FQDNがIPアドレスと一致する必要があります。 設定されていない場合、 @samp{git send-email} はFQDNを自動的に判別しようとします。 デフォルトは @samp{sendemail.smtpDomain} の値です。

@item  @samp{--smtp-auth=<mechanisms>} 
許可されたSMTP-AUTHメカニズムの空白で区切られた(Whitespace-separated)リスト。 この設定は、リストされたメカニズムのみを使用するように強制します。 例:

@example
$ git send-email --smtp-auth="PLAIN LOGIN GSSAPI" ...
@end example


指定されたメカニズムの少なくとも1つがSMTPサーバによって宣伝(advertise)されたメカニズムと一致し、利用されるSASLライブラリによってサポートされている場合、そのメカニズムが認証に使用されます。 @samp{sendemail.smtpAuth} と @samp{--smtp-auth} のどちらも指定されない場合、SASL ライブラリでサポートされているすべてのメカニズムが使用される可能性があります。 特別な値として @samp{none} を指定すると、 @samp{--smtp-user} と独立して認証を完全に無効にすることができます。

@item  @samp{--smtp-pass[=<password>]} 
SMTP-AUTHのパスワード。 引数はオプションです。引数が指定されていない場合は、空の文字列がパスワードとして使用されます。 デフォルトは @samp{sendemail.smtpPass} の値ですが、 @samp{--smtp-pass} は常に @samp{sendemail.smtpPass} の値を上書きします。

さらに、パスワードを構成ファイルまたはコマンドラインで指定する必要はありません。 ユーザー名が指定されている(@samp{--smtp-user} または @samp{sendemail.smtpUser} を使用)が、パスワードが指定されていない(@samp{--smtp-pass} または @samp{sendemail.smtpPass} を使用)場合、パスワード @samp{git-credential} を使用して取得されます。

@item  @samp{--no-smtp-auth} 
SMTP認証を無効にします。 @samp{--smtp-auth=none} の省略形

@item  @samp{--smtp-server=<host>} 
設定されている場合、使用する送信SMTPサーバを指定します(例: @samp{smtp.example.com} または生のIPアドレス)。 これが未指定の場合で、かつ、 @samp{--sendmail-cmd} も未指定の場合、デフォルトでは @samp{/usr/sbin} と @samp{/usr/lib} と $PATH にある @samp{sendmail} を探します。それが存在しなければ @samp{localhost} にフォールバックされます。

下位互換性のために、このオプションでは、代わりにsendmailのようなプログラムの絶対パス名を指定することもできます。 プログラムは @samp{-i} オプションをサポートする必要があります。 このメソッドは、引数の受け渡しや平文コマンド名の使用をサポートしていません。 これらの場合には、代わりに @samp{--sendmail-cmd} の使用を検討してください。

@item  @samp{--smtp-server-port=<port>} 
デフォルトのポートとは異なるポートを指定します(SMTPサーバーは通常smtpポート25をリッスンしますが、送信ポート587または共通のSSL smtpポート465もリッスンする場合があります)。 シンボリックポート名(たとえば、587ではなく "submission")も受け入れられます。 ポートは、 @samp{sendemail.smtpServerPort} 構成変数を使用して設定することもできます。

@item  @samp{--smtp-server-option=<option>} 
設定されている場合、使用する送信SMTPサーバーオプションを指定します。 デフォルト値は、 @samp{sendemail.smtpServerOption} 構成オプションで指定できます。

@samp{--smtp-server-option} オプションは、サーバーに渡すオプションごとに繰り返す必要があります。 同様に、構成ファイルではオプションごとに異なる行を使用する必要があります。

@item  @samp{--smtp-ssl} 
@samp{--smtp-encryptionssl} の、大昔からのエイリアス。

@item  @samp{--smtp-ssl-cert-path} 
SMTP SSL/TLS 証明書検証用の信頼できるCA証明書のストアへのパス(@samp{c_rehash} によって処理されたディレクトリ、または1つ以上のPEM形式の証明書が連結された単一のファイル: これらの詳細については、 verify(1) の @samp{-CAfile} と @samp{-CApath} を参照してください)。 証明書の検証を無効にするには、空の文字列に設定します。 デフォルトは、設定されている場合は @samp{sendemail.smtpsslcertpath} 構成変数の値、それ以外の場合はバッキングSSLライブラリのコンパイル済みデフォルト(ほとんどのプラットフォームで最良の選択)です。

@item  @samp{--smtp-user=<user>} 
SMTP-AUTHのユーザー名。 デフォルトは @samp{sendemail.smtpUser} の値です。 (@samp{--smtp-user} または @samp{sendemail.smtpUser} で)ユーザー名が指定されていない場合、認証は試行されません。

@item  @samp{--smtp-debug=0|1} 
デバッグ出力を有効(1)または無効(0)にします。 有効にすると、SMTPコマンドとその応答が出力されます。 TLS接続と認証の問題をデバッグするのに役立ちます。

@item  @samp{--batch-size=<num>} 
一部の電子メールサーバー(たとえば smtp.163.com)では、セッション(または接続)ごとに送信される電子メールの数が制限されているため、多くのメッセージを送信すると失敗します。 このオプションを使用すると、@samp{send-email} は <num> メッセージの送信後に切断され、数秒待って(@samp{--relogin-delay} 参照)、再接続して、このような制限を回避します。 これが発生するたびにパスワードを再入力する必要がないように、何らかの形式のクレデンシャルヘルパーを使用することをお勧めします。 デフォルトは @samp{sendemail.smtpBatchSize} 構成変数です。

@item  @samp{--relogin-delay=<int>} 
SMTPサーバーに再接続する前に <int> 秒待機します。 @samp{--batch-size} オプションと一緒に使用します。 デフォルトは @samp{sendemail.smtpReloginDelay} 構成変数です。
@end table

@noindent

@heading 自動化

@table @asis

@item  @samp{--no-[to|cc|bcc]} 
configで以前に設定した "To:" と "Cc:" と "Bcc:" アドレスのリストをすべてクリアします。

@item  @samp{--no-identity} 
configで設定された @samp{sendemail.identity} から読み取られた値があるならば、その値をクリアします。

@item  @samp{--to-cmd=<command>} 
パッチファイルごとに1回実行するコマンドを指定し、パッチファイル固有の @samp{To:} エントリーを生成するようにします。 このコマンドの出力は、1行に1つの電子メールアドレスでなければなりません。 デフォルトは、設定値 @samp{sendemail.tocmd} の値です。

@item  @samp{--cc-cmd=<command>} 
パッチファイルごとに1回実行するコマンドを指定し、パッチファイル固有の @samp{Cc:} エントリを生成するようにします。 このコマンドの出力は、1行に1つの電子メールアドレスでなければなりません。 デフォルトは @samp{sendemail.ccCmd} 設定値の値です。

@item  @samp{--header-cmd=<command>} 
Specify a command that is executed once per outgoing message and output RFC 2822 style header lines to be inserted into them. When the @samp{sendemail.headerCmd} configuration variable is set, its value is always used. When --header-cmd is provided at the command line, its value takes precedence over the @samp{sendemail.headerCmd} configuration variable.

@item  @samp{--no-header-cmd} 
Disable any header command in use.

@item  @samp{--[no-]chain-reply-to} 
これが設定されている場合、各メールは前に送信されたメールへの返信として送信されます。 @samp{--no-chain-reply-to} で無効にすると、最初の電子メール以降のすべての電子メールが、最初に送信された電子メールへの返信として送信されます。 これを使用する場合、最初のファイルはパッチシリーズ全体の概要であることが推奨されます。 デフォルトでは無効になっていますが、 @samp{sendemail.chainReplyTo} 構成変数を使用して有効にすることができます。

@item  @samp{--identity=<identity>} 
構成ID。 指定すると、 @samp{sendemail.<identity>} サブセクションの値が @samp{sendemail} セクションの値よりも優先されます。 デフォルトのIDは、 `sendemail.identity`の値です。

@item  @samp{--[no-]signed-off-by-cc} 
これが設定されている場合は、 @samp{Signed-off-by} トレーラーまたは @samp{Cc:} 行にある電子メールアドレスをccリストに追加します。 デフォルトは @samp{sendemail.signedoffbycc} 構成変数の値です。 @samp{sendemail.signedoffbycc} 構成変数が指定されていない場合、デフォルトは @samp{--signed-off-by-cc} です。

@item  @samp{--[no-]cc-cover} 
これが設定されている場合、シリーズの最初のパッチ(通常はカバーレター)の @samp{Cc:} ヘッダー達で見つかった電子メールアドレスが、各電子メールアドレスのセットのccリストに追加されます。 デフォルトは、 @samp{sendemail.cccover} 構成の値です。 @samp{sendemail.cccover} 構成が指定されていない場合、デフォルトは @samp{--no-cc-cover} です。

@item  @samp{--[no-]to-cover} 
これが設定されている場合、シリーズの最初のパッチ(通常はカバーレター)の @samp{To:} ヘッダー達で見つかった電子メールアドレスが、各電子メールアドレスのセットのtoリストに追加されます。 デフォルトは、 @samp{sendemail.tocover} 構成の値です。 @samp{sendemail.tocover} 構成の値が指定されていない場合、デフォルトで @samp{--no-to-cover} になります。

@item  @samp{--suppress-cc=<category>} 
自動CC(auto-cc)を抑制するために、以下の追加受信者カテゴリを指定します:

@itemize 

@item
@samp{author} は、パッチの作者を含めないようにします。

@item
@samp{self} は送信者を含めないようにします。

@item
@samp{cc} は、 @samp{self} を指定した場合を除き、Cc行で言及されている人をパッチヘッダーに含めないようにします(含めたいなら @samp{self} を使用します)。

@item
@samp{bodycc} は、 @samp{self} を指定した場合を除き、 パッチ本体(コミットメッセージ)にCc行で言及されている人を含めないようにします(含めたい場合は @samp{self} を使います)。

@item
@samp{sob} は、 @samp{self} を指定している場合を除き、 Signed-off-by に記載されている人を含めないようにします(含めたい場合は @samp{self} を使用します)。

@item
@samp{misc-by} は、 @samp{Signed-off-by} (@samp{sob} を使用)を除いて、パッチ本体に Acked-byや、Reviewed-byや、Tested-byや、その他の @samp{-by} 行で言及されているのを含めないようにします。

@item
@samp{cccmd} は、 @samp{--cc-cmd} の実行を回避します。

@item
@samp{body} は @samp{sob} + @samp{bodycc} + @samp{misc-by} と同じです。

@item
@samp{all} は、すべての自動cc値を抑制します。
@end itemize

デフォルトは @samp{sendemail.suppresscc} 構成の値です。 @samp{sendemail.suppresscc} 構成が指定されていない場合に、 @samp{--suppress-from} が指定されている場合はデフォルトで @samp{self} になり、 @samp{--no-signed-off-cc} が指定されている場合は @samp{body} になります。

@item  @samp{--[no-]suppress-from} 
これが設定されている場合は、 @samp{From:} アドレス を @samp{cc:} リストに追加しないでください。 デフォルトは @samp{sendemail.suppressFrom} 構成の値です。 @samp{sendemail.suppressFrom} 構成が指定されていない場合、デフォルトは @samp{--no-suppress-from} です。

@item  @samp{--[no-]thread} 
これが設定されている場合、In-Reply-To と References ヘッダー達は送信される各メールアドレスに追加されます。 各メールが前のメールを参照するのか(@samp{git format-patch} の文言に従った「深い」(deep)スレッディング)、最初のメールを参照するのか(「浅い」(shallow)スレッディング)については @samp{--[no-]chain-reply-to} で制御されます。

@samp{--no-thread} で無効にすると、それらのヘッダーは追加されません(@samp{--in-reply-to} で指定されていない限り)。 デフォルトは、 @samp{sendemail.thread} 構成の値です。 @samp{sendemail.thread} 構成が指定されていない場合、デフォルトは @samp{--thread} です。

@samp{git send-email} が In-Reply-To ヘッダを追加するように要求したときに、すでにそのヘッダが存在しないことを確認するのはユーザー側です((特に @samp{git format-patch} がスレッド化するように設定されている場合は注意が必要です)。 これを怠ると、受信者の MUA で期待通りの結果が得られないことがあります。
@end table

@noindent

@heading 管理

@table @asis

@item  @samp{--confirm=<mode>} 
送信する直前に確認(confirm)します:

@itemize 

@item
@samp{always} は送信前に常に確認します

@item
@samp{never} は送信する前に確認すること決してありません

@item
@samp{cc} は、send-emailがパッチからCcリストにアドレスを自動的に追加したときは、送信前に確認します

@item
@samp{compose} は、 @samp{--compose} を使用した時に、最初のメッセージを送信する前に確認します。

@item
@samp{auto} は @samp{cc}+ @samp{compose} と同じです
@end itemize

デフォルトは @samp{sendemail.confirm} 構成の値です。 @samp{sendemail.confirm} 構成が指定されていない場合、抑制オプション(suppress options)のいずれかが指定されていない限り、デフォルトは @samp{auto} になります。抑制オプションのいずれかが指定されている場合は、デフォルトで `compose`になります。

@item  @samp{--dry-run} 
実際にメールを送信する以外はすべて行います。

@item  @samp{--[no-]format-patch} 
引数が参照またはファイル名として理解される場合は、それをformat-patch引数(@samp{--format-patch})またはファイル名(@samp{--no-format-patch})として理解することを選択します。 デフォルトでは、このような競合が発生すると、 @samp{git send-email} は失敗します。

@item  @samp{--quiet} 
git-send-emailのおしゃべりを減らします。 電子メール１通につき1行出力するだけにします。

@item  @samp{--[no-]validate} 
パッチの健全性チェックを実行します。 現状、検証(validation)とは以下のことを意味します:

@itemize 

@item
sendemail-validate フックが存在する場合はそれを呼び出します(githooks(5) 参照)。

@item
適切な転送エンコーディング(@samp{auto} または @samp{base64} または @samp{quoted-printable})が使用されていない時は、998文字より長い行を含むパッチについて警告します。 これは、 @uref{http://www.ietf.org/rfc/rfc5322.txt,http://www.ietf.org/rfc/rfc5322.txt} で説明されているSMTPの制限によるものです。
@end itemize

デフォルトは @samp{sendemail.validate} の値です。 これが設定されていない場合、デフォルトは @samp{--validate} になります。

@item  @samp{--force} 
安全チェックで防止できる場合でも、電子メールを送信してください。
@end table

@noindent

@heading 情報

@table @asis

@item  @samp{--dump-aliases} 
通常の操作の代わりに、構成されたエイリアスファイルからアルファベット順に1行に1つずつ短縮エイリアス名をダンプします。 これにはエイリアス名のみが含まれ、拡張された電子メールアドレスは含まれないことに注意してください。 エイリアスの詳細については、 @samp{sendemail.aliasesfile} を参照してください。
@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  sendemail.identity 
構成ID。 指定すると、 @samp{sendemail.<identity>} サブセクションの値が @samp{sendemail} セクションの値よりも優先されます。 デフォルトのIDは、 `sendemail.identity`の値です。

@item  sendemail.smtpEncryption 
説明については、 git-send-email(1) を参照してください。 注意: この設定は @samp{identity} メカニズムの対象ではないことに注意してください。

@item  sendemail.smtpsslcertpath 
ca-certificatesへのパス(ディレクトリまたは単一ファイルのどちらか)。 証明書の検証を無効にするには、空の文字列に設定します。

@item  sendemail.<identity>.* 
以下の @samp{sendemail.*} パラメータのID固有のバージョン。コマンドラインまたは @samp{sendemail.identity} のいずれかを使用して、このIDが選択された場合のパラメータよりも優先されます。

@item  sendemail.multiEdit 
true (デフォルト) の場合、編集する必要があるファイルを編集するために単一のエディター・インスタンスが生成されます(@samp{--annotate} が使用されている場合はパッチ、 @samp{--compose} が使用されている場合は要約)。 false の場合、ファイルは次々に編集され、そのたびに新しいエディター・インスタンスが生成されます。

@item  sendemail.confirm 
送信前に確認するかどうかのデフォルトを設定します。 @samp{always} または @samp{never} または @samp{cc} または @samp{compose} または @samp{auto} のいずれかでなければなりません。 これらの値の意味については、 git-send-email(1) ドキュメントの @samp{--confirm} を参照してください。

@item  sendemail.aliasesFile 
長い電子メール・アドレスのタイピングを回避するには、1 つまたは複数の電子メール・エイリアス・ファイルを指定します。 @samp{sendemail.aliasFileType} も指定する必要があります。

@item  sendemail.aliasFileType 
@samp{sendemail.aliasesFile} で指定されたファイルの形式。 @samp{mutt}, @samp{mailrc}, @samp{pine}, @samp{elm}, @samp{gnus}, @samp{sendmail} のいずれかでなければなりません。

各形式のエイリアス・ファイルがどのようなものかは、同名の電子メール・プログラムのドキュメントに記載されています。 標準フォーマットとの相違点と制限事項は以下のとおりです:

@table @asis

@item  sendmail 
@itemize 

@item
引用エイリアス(quoted aliases)と引用アドレス(quoted addresses)はサポートされていません。 @samp{"} 記号を含む行は無視されます。

@item
ファイル(@samp{/path/name})またはパイプ(@samp{|command})へのリダイレクトはサポートされていません。

@item
ファイル・インクルード(@samp{:include: /path/name})はサポートされていません。

@item
明示的にサポートされていない構造(constructs)、およびパーサーによって認識されないその他の行については、警告が標準エラー出力に出力されます。
@end itemize
@end table

@item  sendemail.annotate 
@itemx  sendemail.bcc 
@itemx  sendemail.cc 
@itemx  sendemail.ccCmd 
@itemx  sendemail.chainReplyTo 
@itemx  sendemail.envelopeSender 
@itemx  sendemail.from 
@itemx  sendemail.headerCmd 
@itemx  sendemail.signedoffbycc 
@itemx  sendemail.smtpPass 
@itemx  sendemail.suppresscc 
@itemx  sendemail.suppressFrom 
@itemx  sendemail.to 
@itemx  sendemail.tocmd 
@itemx  sendemail.smtpDomain 
@itemx  sendemail.smtpServer 
@itemx  sendemail.smtpServerPort 
@itemx  sendemail.smtpServerOption 
@itemx  sendemail.smtpUser 
@itemx  sendemail.thread 
@itemx  sendemail.transferEncoding 
@itemx  sendemail.validate 
@itemx  sendemail.xmailer 
これらの構成変数はすべて、git-send-email(1) コマンドライン・オプションのデフォルトを提供します。 詳細については、そのドキュメントを参照してください。

@item  sendemail.signedoffcc (非推奨) 
@samp{sendemail.signedoffbycc} の非推奨のエイリアス。

@item  sendemail.smtpBatchSize 
接続ごとに送信されるメッセージの数。その後、再ログインが発生します。 値が0または未定義の場合、すべてのメッセージを1つの接続で送信します。 git-send-email(1) の @samp{--batch-size} オプションも参照してください。

@item  sendemail.smtpReloginDelay 
SMTPサーバーに再接続する前に指定の秒数待機します。 git-send-email(1)の @samp{--relogin-delay} オプションも参照してください。

@item  sendemail.forbidSendmailVariables 
一般的な設定ミスを回避するために、 git-send-email(1) は、 @samp{sendmail} の設定オプションが存在する場合、警告とともに中止します。 チェックをバイパスするには、この変数を設定します。
@end table

@noindent

@chapheading EXAMPLES

@noindent

@heading Use gmail as the smtp server

@samp{git send-email} を使用してGMail SMTPサーバーを介してパッチを送信するには、 @samp{~/.gitconfig} を編集してあなたのアカウント設定を指定します:

@example
[sendemail]
        smtpEncryption = tls
        smtpServer = smtp.gmail.com
        smtpUser = yourname@@gmail.com
        smtpServerPort = 587
@end example


If you have multi-factor authentication set up on your Gmail account, you can generate an app-specific password for use with @emph{git send-email}. Visit @uref{https://security.google.com/settings/security/apppasswords,https://security.google.com/settings/security/apppasswords} to create it.

あなたのコミットをメーリングリストに送信する準備ができたら、以下のコマンドを実行します:

@example
$ git format-patch --cover-letter -M origin/master -o outgoing/
$ edit outgoing/0000-*
$ git send-email outgoing/*
@end example

初めて実行すると、資格情報の入力を求められます。 必要に応じて、アプリ固有のパスワードまたは通常のパスワードを入力します。 クレデンシャルヘルパーを構成している場合(git-credential(1) 参照)、パスワードはクレデンシャルストアに保存されるため、次回入力する必要はありません。

注意: Perlのディストリビューションとともにインストールできる次のコアPerlモジュールが必要です: @samp{MIME::Base64} と @samp{MIME::QuotedPrint} と @samp{Net::Domain} と @samp{Net::SMTP} 。 また、次の追加のPerlモジュールも必要です: @samp{Authen::SASL} と @samp{Mail::Address} 。

@noindent

@chapheading SEE ALSO

git-format-patch(1), git-imap-send(1), mbox(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-send-pack,,,Top
@chapheading Name

git-send-pack — Gitプロトコルを介してオブジェクトを別のリポジトリにプッシュする

@noindent

@chapheading Synopsis

@display
git send-pack [--mirror] [--dry-run] [--force]
                [--receive-pack=<git-receive-pack>]
                [--verbose] [--thin] [--atomic]
                [--[no-]signed | --signed=(true|false|if-asked)]
                [<host>:]<directory> (--all | <ref>…)
@end display


@noindent

@chapheading DESCRIPTION

通常は、代わりに、このコマンドの上位レベルのラッパーである「git push」を使用することをお勧めします。 git-push(1) を参照してください。

おそらくリモートリポジトリで @samp{git-receive-pack} を呼び出し、現在のリポジトリから更新して、名前付きrefsを送信します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--receive-pack=<git-receive-pack>} 
リモート側の 「git-receive-pack」プログラムへのパス。 sshを介してリモートリポジトリにプッシュするとき、デフォルトの $PATH のディレクトリにプログラムが無い場合に便利です。

@item  @samp{--exec=<git-receive-pack>} 
@samp{--receive-pack=<git-receive-pack>} と同じ。

@item  @samp{--all} 
更新するrefを明示的に指定する代わりに、ローカルに存在するすべてのヘッドを更新します。

@item  @samp{--stdin} 
stdinからrefのリストを1行に1つずつ取得します。 このオプションに加えてコマンドラインでrefが指定されている場合、stdinからのrefはコマンドラインでのrefの後に処理されます。

@samp{--stateless-rpc} がこのオプションと一緒に指定されている場合、refのリストはパケット形式(pkt-line)である必要があります。各refは個別のパケットに含まれている必要があり、リストはフラッシュパケットで終了している必要があります。

@item  @samp{--dry-run} 
実際に更新を送信する以外はすべて行います。

@item  @samp{--force} 
通常、このコマンドは、上書きに使用されたローカル ref の祖先ではないリモート ref の更新を拒否します。 このフラグは、このチェックを無効にします。 これが意味することは、リモートリポジトリがコミットを失う可能性があるということです。注意して使用してください。

@item  @samp{--verbose} 
おしゃべりに実行します。

@item  @samp{--thin} 
ネットワークトラフィックを削減するために、パックに含まれていないオブジェクトに基づいてオブジェクトを削除された形式で記録する薄いパック(thin pack)を送信します。

@item  @samp{--atomic} 
参照を更新するためにアトミック取引(atomic transaction)を使用します。いずれかのrefが更新に失敗した場合、refを変更せずにプッシュ全体が失敗します。

@item  @samp{--[no-]signed} 
@itemx  @samp{--signed=(true|false|if-asked)} 
プッシュリクエストをGPG署名して、受信側のrefを更新し、フックでチェックしたり、ログに記録したりできるようにします。 @samp{false} または @samp{--no-signed} の場合、署名は試行されません。 @samp{true} または @samp{--signed} の場合、サーバーが署名付きプッシュをサポートしていないと、プッシュは失敗します。 @samp{if-asked} に設定されている場合、サーバーが署名されたプッシュをサポートしている場合にのみ署名します。 @samp{gpg --sign} の実際の呼び出しが失敗した場合も、プッシュは失敗します。 受信側の詳細については、 git-receive-pack(1) を参照してください。

@item  @samp{--push-option=<string>} 
サーバー側のフックで使用するためのプッシュオプションとして、指定された文字列を渡します。 サーバーがプッシュオプションをサポートしていない場合は、エラーになります。 詳細については、 git-push(1) と githooks(5) を参照してください。

@item  <host> 
リポジトリを収容するリモートホスト。 この部分を指定すると、sshを介して「git-receive-pack」が呼び出されます。

@item  <directory> 
更新するリポジトリ。

@item  <ref>… 
更新するリモートref。
@end table

@noindent

@chapheading SPECIFYING THE REFS

リモート側で更新するrefを指定するには、3つの方法があります。

@samp{--all} フラグを使用すると、ローカルに存在するすべての参照がリモート側に転送されます。 このフラグを使用する場合、 <ref> を指定することはできません。

@samp{--all} がなく、 @samp{<ref>} がない場合、ローカル側とリモート側の両方に存在するヘッドが更新されます。

(コマンドラインまたは @samp{--stdin} を介して、)1つ以上の @samp{<ref>} が明示的に指定されている場合、単一のパターン、またはコロン(@samp{:})で区切られたそのようなパターンのペアのいずれかです(これはref名にコロンを含めることはできないことを意味します)。単一のパターン @samp{<name>} は、@samp{<name>:<name>} の省略形です。

各パターンペアは、ソース側(コロンの前)と、宛先側(コロンの後)で構成されます。プッシュされるrefは、ソース側にマッチするモノを見つけることによって決定され、プッシュされる場所は、宛先側を使用して決定されます。refの照合に使用されるルールは、シンボリックref名を解決するために「git rev-parse」で使用されるルールと同じです。 git-rev-parse(1) を参照してください。

@itemize 

@item
<src> がローカル参照の1つと正確に一致しない場合はエラーとなります。

@item
<dst> が複数のリモート参照と一致する場合はエラーになります。

@item
<dst> がどのリモート参照とも一致しない場合は以下のいずれかです。

@itemize 

@item
「refs/」で始まる必要があります。 この場合、文字通り <dst> が宛先として使用されます。

@item
<src> == <dst> および、 <src> に一致するrefは、リモートrefのセットに存在してはなりません。 ローカルで一致する参照 <src> が、宛先の名前として使用されます。
@end itemize
@end itemize

@samp{--force} がない場合、<src> refは、<dst>が存在しない場合、または<dst>が<src>の適切なサブセット(つまり、祖先)である場合にのみリモートに保存されます。 「早送りチェック」(fast-forward check)と呼ばれるこのチェックは、リモートrefを誤って上書きして、そこから他の人のコミットを失うことを回避するために行われます。

@samp{--force} を使用すると、すべてのrefに対して早送りチェック(fast-forward check)が無効になります。

オプションで、<ref>パラメーターの前にプラスの「+」記号を付けて、そのrefでのみ早送りチェック(fast-forward check)を無効にすることができます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-sh-i18n--envsubst,,,Top
@chapheading Name

git-sh-i18n--envsubst — i18nフォールバック用のGit独自のenvsubst(1)

@noindent

@chapheading Synopsis

@display
eval_gettext () @{
        printf "%s" "$1" | (
                export PATH $(git sh-i18n--envsubst --variables "$1");
                git sh-i18n--envsubst "$1"
        )
@}
@end display


@noindent

@chapheading DESCRIPTION

これは、全くもってエンドユーザーが実行するコマンドではありません。この文書は、配管スクリプトを研究している、および/または新しいスクリプトを作成している人々を対象としています。

@emph{git sh-i18n--envsubst} は、GNU gettextパッケージに付属するGNU @samp{envsubst(1)} プログラムのGit用簡略版です。これは、 git-sh-i18n(1) によって内部的に使用され、 @samp{eval_gettext} 関数に渡された変数を差し込みます。

インターフェイスについては何も約束されていません。また、このプログラムが次のバージョンのGitで警告なしに消えることはありません。使用しないでください。(No promises are made about the interface, or that this program won’t disappear without warning in the next version of Git. Don’t use it.)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-sh-i18n,,,Top
@chapheading Name

git-sh-i18n — シェルスクリプトのためのGit用i18nセットアップコード

@noindent

@chapheading Synopsis

@display
. "$(git --exec-path)/git-sh-i18n"
@end display


@noindent

@chapheading DESCRIPTION

これは、全くもってエンドユーザーが実行するコマンドではありません。この文書は、磁器風のスクリプトを研究している、および/または新しいスクリプトを書いている人々を対象としています。

'git sh-i18n スクリプトレットは、シェルスクリプト内に実装されたGitの磁器プログラムによって、(@samp{.`を使用してsourceコマンドで)実行されるように設計されています。 これは、 `gettext.sh} スクリプトを介してアクセス可能なGNU @samp{gettext} および @samp{eval_gettext} 関数のラッパーを提供し、GNU gettextのないシステムではこれらが自動的に使われます(pass-through fallbacks)。

@noindent

@chapheading FUNCTIONS

@table @asis

@item  gettext 
現在、 @samp{printf(1)} のラッパーとして実装されているダミーのフォールスルー関数。今後のバージョンでは、実際のgettext実装に置き換えられる事でしょう。

@item  eval_gettext 
現在、 @samp{printf(1)} のラッパーとして実装されているダミーのフォールスルー関数で、その変数達は git-sh-i18n--envsubst(1) ヘルパーによって展開されます。今後のバージョンでは、実際のgettext実装に置き換えられる事でしょう。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-sh-setup,,,Top
@chapheading Name

git-sh-setup — 一般的なGitシェルスクリプトのセットアップコード

@noindent

@chapheading Synopsis

@display
. "$(git --exec-path)/git-sh-setup"
@end display


@noindent

@chapheading DESCRIPTION

これは、エンドユーザーが実行するコマンドではありません。この文書は、磁器風のスクリプトを研究している、および/または 新しいスクリプトを書いている人々を対象としています。

@emph{git sh-setup} スクリプトレットは、他のシェルスクリプトから( @samp{.} を使用して)実行(source)され、通常のGitディレクトリと、いくつかのヘルパーシェル関数を指す、いくつかの環境変数を設定するように設計されています。

実行(source)前に、スクリプトでいくつかの環境変数を設定する必要があります。@samp{USAGE} (および存在する場合は @samp{LONG_USAGE} )は、 @samp{usage()} シェル関数によって与えられるメッセージを定義するために使用されます。スクリプトが作業ツリーのサブディレクトリから実行できる場合は、 @samp{SUBDIRECTORY_OK} を設定できます(一部のコマンドは実行できません)。

スクリプトレットは @samp{GIT_DIR} と @samp{GIT_OBJECT_DIRECTORY} シェル変数を設定しますが、それらを環境にエクスポートしません。

@noindent

@chapheading FUNCTIONS

@table @asis

@item  die 
提供されたエラーメッセージを標準エラーストリームに出力した後に終了します。

@item  usage 
使用法メッセージで die します。

@item  set_reflog_action 
すでに設定されていない限り、 @samp{GIT_REFLOG_ACTION} 環境変数を指定の文字列(通常はプログラムの名前)に設定します。スクリプトが、refを更新する @samp{git} コマンドを実行するたびに、この文字列の値を使用してreflogエントリが作成され、どのコマンドがrefを更新したかの記録が残されます。

@item  git_editor 
特定のファイルに対してユーザーが選択したエディター(GIT_EDITOR または core.editor または VISUAL または EDITOR)を実行しますが、エディターが指定されておらず、端末がダムの場合はエラーになります。

@item  is_bare_repository 
@samp{true} または @samp{false} を標準出力ストリームに出力して、リポジトリがベアリポジトリであるかどうか(つまり、関連する作業ツリーがないかどうか)を示します。

@item  cd_to_toplevel 
作業ツリーのトップレベルまでchdirを実行します。

@item  require_work_tree 
現在のディレクトリがリポジトリの作業ツリー内にあるかどうかを確認し、そうでない場合は停止(die)します。

@item  require_work_tree_exists 
リポジトリに関連付けられている作業ツリーが存在するかどうかを確認し、存在しない場合は停止(die)します。多くの場合、cd_to_toplevelを呼び出す前に実行されますが、作業ツリーがない場合は実行できません。

@item  require_clean_work_tree <action> [<hint>] 
リポジトリに関連付けられている作業ツリーとインデックスに、追跡されたファイルへのコミットされていない変更がないことを確認します。それ以外の場合は、 @samp{Cannot <action>: <reason>. <hint>} の形式のエラーメッセージを出力し、dieします。 例:

@example
require_clean_work_tree rebase "Please commit or stash them."
@end example


@item  get_author_ident_from_commit 
特定のコミットの GIT_AUTHOR_NAME と GIT_AUTHOR_EMAIL と GIT_AUTHOR_DATE 変数を設定するためにevalで使用するコードを出力します。

@item  create_virtual_base 
最初のファイルを変更して、2番目のファイルと共通の行だけが残るようにします。共通の資料が不十分な場合、最初のファイルは空のままになります。 結果は、3方向マージの仮想ベース入力として適しています。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-shell,,,Top
@chapheading Name

git-shell — GitのみのSSHアクセス用の制限付きログインシェル

@noindent

@chapheading Synopsis

@display
chsh -s $(command -v git-shell) <user>
git clone <user>@@localhost:/path/to/repo.git
ssh <user>@@localhost
@end display


@noindent

@chapheading DESCRIPTION

これは、制限されたGitアクセスを提供するためのSSHアカウントのログインシェルです。プル/プッシュ機能を実装するサーバー側のGitコマンドと、ユーザーのホームディレクトリの @samp{git-shell-commands} という名前のサブディレクトリにあるカスタムコマンドの実行のみを許可します。

@noindent

@chapheading COMMANDS

@emph{git shell} は、 @samp{-c} オプションの後に以下のコマンドを受け入れます:

@table @asis

@item  @emph{git receive-pack <argument>} 
@itemx  @emph{git upload-pack <argument>} 
@itemx  @emph{git upload-archive <argument>} 
対応するサーバー側コマンドを呼び出して、クライアントの「git push」または「git fetch」または「git archive --remote」リクエストをサポートします。

@item  @emph{cvs server} 
CVSサーバーを模倣します。 git-cvsserver(1) 参照。
@end table

@samp{~/git-shell-commands} ディレクトリが存在する場合、 @emph{git shell} は、ユーザーのホームディレクトリから "@samp{git-shell-commands/<command> <arguments>}" を実行することにより他のカスタムコマンドも処理します。

@noindent

@chapheading INTERACTIVE USE

デフォルトでは、上記のコマンドは @samp{-c} オプションでのみ実行できます。シェルはインタラクティブではありません。

@samp{~/git-shell-commands} ディレクトリが存在する場合、 @emph{git shell} をインタラクティブに実行することもできます(引数なしで)。 @samp{help} コマンドが @samp{git-shell-commands} ディレクトリにある場合、許可されたアクションの概要をユーザーに提供するために実行されます。次に、 `git> ` プロンプトが表示され、「git-shell-commands」ディレクトリから任意のコマンドを入力することができます。「exit」を使用すれば接続を閉じることができます。

通常、このモードは、ユーザーがアクセスできるリポジトリの一覧表示、リポジトリの作成、削除、名前変更、またはリポジトリの説明と権限の変更を可能にする管理インターフェイスとして使用されます。

@samp{no-interactive-login} コマンドが存在する場合、それが実行され、対話型シェルが中止(abort)されます。

@noindent

@chapheading EXAMPLES

インタラクティブログインを無効にするには、代わりにgreeting(挨拶)を表示します:

@example
$ chsh -s /usr/bin/git-shell
$ mkdir $HOME/git-shell-commands
$ cat >$HOME/git-shell-commands/no-interactive-login <<\EOF
#!/bin/sh
printf '%s\n' "Hi $USER! You've successfully authenticated, but I do not"
printf '%s\n' "provide interactive shell access."
exit 128
EOF
$ chmod +x $HOME/git-shell-commands/no-interactive-login
@end example


git-cvsserverアクセスを有効にするには(なお、git-shell-commandsディレクトリを作成するとインタラクティブログインが可能になるため、通常、上記の「no-interactive-login」の例が前提条件として必要です):

@example
$ cat >$HOME/git-shell-commands/cvs <<\EOF
if ! test $# = 1 && test "$1" = "server"
then
        echo >&2 "git-cvsserver only handles \"server\""
        exit 1
fi
exec git cvsserver server
EOF
$ chmod +x $HOME/git-shell-commands/cvs
@end example


@noindent

@chapheading SEE ALSO

ssh(1), git-daemon(1), contrib/git-shell-commands/README

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-shortlog,,,Top
@chapheading Name

git-shortlog — 「git log」の出力を要約します。

@noindent

@chapheading Synopsis

@display
git shortlog [<options>] [<revision-range>] [[--] <path>…]
git log --pretty=short | git shortlog [<options>]
@end display


@noindent

@chapheading DESCRIPTION

「git log」の出力を、リリースアナウンスに含めるのに適した形式で要約します。各コミットは、作者とタイトルごとにグループ化されます。

加えて、「[PATCH]」はコミットの説明から削除されます。

コマンドラインでリビジョンが渡されず、かつ、標準入力が端末ではないかまたは現在のブランチがない場合、「git shortlog」は、現在のリポジトリを参照せずに、標準入力から読み取られたログの概要を出力します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-n} 
@itemx  @samp{--numbered} 
作者のアルファベット順ではなく、作者のコミット数に従って出力を並べ替えます。

@item  @samp{-s} 
@itemx  @samp{--summary} 
コミットの説明を抑制し、コミット数の要約のみを提供します。

@item  @samp{-e} 
@itemx  @samp{--email} 
各作者のメールアドレスを表示します。

@item  @samp{--format[=<format>]} 
コミットの件名の代わりに、他の情報を使用して各コミットを説明します。 @samp{<format>} は、 @samp{* [%h] %s} など 、 @samp{git log} の @samp{--format} オプションで受け入れられる任意の文字列にすることができます。 (git-log(1) の「PRETTY FORMATS」セクションを参照してください。)

@example
pretty-printされた各コミットは、表示される前に再ラップ(rewrapp)されます。
@end example

@item  @samp{--date=<format>} 
Show dates formatted according to the given date string. (See the @samp{--date} option in the "Commit Formatting" section of git-log(1)). Useful with @samp{--group=format:<format>}.

@item  @samp{--group=<type>} 
グループは @samp{<type>} に基づいてコミットします。 @samp{--group} オプションが指定されていない場合、デフォルトは @samp{author} です。 @samp{<type>} は以下のいずれかです:

@itemize 

@item
@samp{author} : コミットは作成者ごとにグループ化されます

@item
@samp{committer} : コミットはコミッターによってグループ化されます( @samp{-c} と同じ)

@item
@samp{trailer:<field>} : @samp{<field>} は大文字と小文字を区別しないコミットメッセージトレーラーとして解釈されます(git-interpret-trailers(1) 参照)。たとえば、プロジェクトで @samp{Reviewed-by} のトレーラーを使用している場合、 @samp{git shortlog -ns --group=trailer:reviewed-by} を使用して誰がレビューしているかを確認できます。

@item
@samp{format:<format>}, any string accepted by the @samp{--format} option of @emph{git log}. (See the "PRETTY FORMATS" section of git-log(1).)

注意: トレーラーを含まないコミットはカウントされないことに注意してください。同様に、複数のトレーラーを使用したコミット(複数のサインオフなど)は、複数回カウントされる場合があります(ただし、そのコミットの一意のトレーラー値ごとに1回のみです)。

shortlog は、各トレーラー値を @samp{name <email>} ID としてパースしようとします。成功すると、mailmapが適用され、 @samp{--email} オプションが指定されていない限りemailは省略されます。値をIDとして解析できない場合は、その文言通りに取得されます。
@end itemize

@samp{--group} が複数回指定されている場合、コミットは各値でカウントされます(ただし、そのコミットの一意の値ごとに1回だけカウントされます)。 たとえば、 @samp{git shortlog --group=author --group=trailer:co-authored-by} は、authorとco-authorの両方をカウントします。

@item  @samp{-c} 
@itemx  @samp{--committer} 
@samp{--group=committer} のエイリアスです。

@item  @samp{-w[<width>[,<indent1>[,<indent2>]]]} 
各行を @samp{width} で折り返すことにより、出力を行折り返します。各エントリの最初の行は @samp{indent1} スペースでインデントされ、2行目以降は @samp{indent2} スペースでインデントされます。 @samp{width} と @samp{indent1} と @samp{indent2} のデフォルトは、それぞれ76と6と9です。

widthが @samp{0} (ゼロ)の場合、出力の行を折り返すことなくインデントします。

@item  <revision-range> 
指定のリビジョン範囲のコミットのみを表示します。 <revision-range> が指定されていない場合、デフォルトで @samp{HEAD} (つまり、現在のコミットにつながる履歴全体)になります。 @samp{origin..HEAD} は、現在のコミット(つまり、 @samp{HEAD} )から到達可能なすべてのコミットを指定しますが、 @samp{origin} からは指定しません。 <revision-range> のスペルの完全なリストについては、 gitrevisions(7) の「Specifying Ranges」セクションを参照してください。

@item  [--] <path>… 
指定されたパスに一致するファイルがどのように作成されたかを説明するのに十分なコミットのみを検討してください。

混乱が生じた場合、パスをオプションまたはリビジョン範囲から分離するために、パスの前に @samp{--} を付ける必要がある場合があります。
@end table

@noindent

@heading Commit Limiting

ここで説明されている特別な表記法を使用してリストする必要があるコミットの範囲を指定することに加えて、追加のコミット制限が適用される場合があります。

より多くのオプションを使用すると、通常、出力がさらに制限されます(たとえば、 @samp{--since=<date1>} は @samp{<date1>} より新しいコミットに制限され、 @samp{--grep=<pattern>} と一緒に使用すると、ログメッセージに @samp{<pattern>} と一致する行があるコミットにさらに制限されます)。

注意: これらは、 @samp{--reverse} などのコミット順序およびフォーマットオプションの前に適用されることに注意してください。

@table @asis

@item  @samp{-<number>} 
@itemx  @samp{-n <number>} 
@itemx  @samp{--max-count=<number>} 
出力するコミットの数を制限します。

@item  @samp{--skip=<number>} 
コミット出力の表示を開始する前に、number 個のコミットをスキップします。

@item  --since=<date> 
@itemx  @samp{--after=<date>} 
指定の日付よりも新しいコミットを表示します。

@item  @samp{--since-as-filter=<date>} 
特定の日付より新しいすべてのコミットを表示します。 これは、特定の日付より古い最初のコミットで停止するのではなく、範囲内のすべてのコミットを訪問します。

@item  @samp{--until=<date>} 
@itemx  @samp{--before=<date>} 
指定の日付より古いコミットを表示します。

@item  @samp{--author=<pattern>} 
@itemx  @samp{--committer=<pattern>} 
コミット出力を、指定されたパターン(正規表現)に一致する作者(author)/コミッター(committer)ヘッダー行を持つものに制限します。複数の @samp{--author=<pattern>} がある場合、作者が指定されたパターンのいずれかに一致するコミットが選択されます(複数の @samp{--committer=<pattern>} の場合も同様)。

@item  @samp{--grep-reflog=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するreflogエントリを持つものに制限します。 複数の @samp{--grep-reflog} を使用すると、 指定されたパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。 @samp{--walk-reflogs} が使用されていない限り、 このオプションを使用するとエラーになります。

@item  @samp{--grep=<pattern>} 
コミット出力を、 指定されたパターン(正規表現)に一致するログメッセージを持つものに制限します。 複数の @samp{--grep=<pattern>} を使用すると、 指定されたパターンのいずれかにメッセージが一致するコミットが選択されます(全てに一致するコミットだけを選択したい場合、@samp{--all-match} を参照してください)。

@samp{--notes} が有効な場合、ノートからのメッセージは、ログメッセージの一部であるかのようにマッチングされます。

@item  @samp{--all-match} 
コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての @samp{--grep} に一致するものに制限します。

@item  @samp{--invert-grep} 
コミット出力を、 @samp{--grep=<pattern>} で指定されたパターンと一致しないログメッセージを持つものに制限します。

@item  @samp{-i} 
@itemx  @samp{--regexp-ignore-case} 
大文字小文字に関係なく、正規表現の制限パターンに一致します。

@item  @samp{--basic-regexp} 
制限パターンを基本正規表現として扱います。これがデフォルトです。

@item  @samp{-E} 
@itemx  @samp{--extended-regexp} 
制限パターンを、デフォルトの基本正規表現の代わりに拡張正規表現として扱います。

@item  @samp{-F} 
@itemx  @samp{--fixed-strings} 
制限パターンを固定文字列として扱います(パターンを正規表現として解釈しないでください)。

@item  @samp{-P} 
@itemx  @samp{--perl-regexp} 
制限パターンをPerl互換の正規表現として扱います。

これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。Gitが当該のサポート付きでコンパイルされていない場合、このオプションを提供すると、Gitが死にます(die)。

@item  @samp{--remove-empty} 
指定されたパスがツリーから見えなくなったら停止(stop)します。

@item  @samp{--merges} 
マージコミットのみを印刷します。これは @samp{--min-parents=2} とまったく同じです。

@item  @samp{--no-merges} 
複数の親を持つコミットを出力しない。これは @samp{--max-parents=1} とまったく同じです。

@item  @samp{--min-parents=<number>} 
@itemx  @samp{--max-parents=<number>} 
@itemx  @samp{--no-min-parents} 
@itemx  @samp{--no-max-parents} 
量の多少に関わらず、 とにかく複数の親コミットがあるコミットのみを表示します。特に、 @samp{--max-parents=1} は @samp{--no-merges} と同じであり、 @samp{--min-parents=2} は @samp{--merges} と同じです。 @samp{--max-parents=0} はすべてのルートコミットを提供し、 @samp{--min-parents=3} はすべてのタコ足マージ(octopus merges)を示します。

@samp{--no-min-parents} と @samp{--no-max-parents} は、これらの制限を(制限なしに)再度リセットします。同等の形式は、 @samp{--min-parents=0} (すべてのコミットに0個以上の親があります)および @samp{--max-parents=-1} (マイナスの数は上限がないことを示します)です。

@item  @samp{--first-parent} 
インクルードするコミットを探すとき、マージ・コミットの最初の親コミットのみをたどります。 このオプションは、特定のトピックブランチの進化を表示するときに、より良い概要を提供できます。トピックブランチへのマージは、時々更新されるアップストリームに調整することだけである傾向があり、このオプションを使用すると、そのようなマージによって履歴に取り込まれた個々のコミットを無視できます。

@item  @samp{--exclude-first-parent-only} 
( @samp{^} を使用して)除外するコミットを見つけるときは、 判明したマージ・コミットの最初の親コミットのみに従います。 任意のマージが有効なトピック・ブランチの変更になる可能性がある場合、 これを使用して、 リモート・ブランチから分岐したポイントからトピック・ブランチ内の一連の変更を見つけることができます。

@item  @samp{--not} 
次に現れる @samp{--not} までの間、後続のすべてのリビジョン指定子の @samp{^}(カレット)接頭辞(またはその欠如)の意味を逆にします。

@item  @samp{--all} 
@samp{refs/} 内のすべてのrefが HEAD とともに、コマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--branches[=<pattern>]} 
@samp{refs/heads} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--tags[=<pattern>]} 
@samp{refs/tags} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合は、指定されたシェルグロブ(shell glob)に一致するタグにタグを制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--remotes[=<pattern>]} 
@samp{refs/remotes} 内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、リモート追跡ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--glob=<glob-pattern>} 
シェルグロブ <glob-pattern> に一致するすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。先頭の @samp{refs/} は、欠落している場合は自動的に先頭に追加されます。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。

@item  @samp{--exclude=<glob-pattern>} 
次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} が別の方法で考慮する <glob-pattern> に一致するrefを含めないでください。このオプションを繰り返すと、次の @samp{--all} または @samp{--branches} または @samp{--tags} または @samp{--remotes} または @samp{--glob} オプションまで除外パターンが蓄積されます(他のオプションまたは引数は、蓄積されたパターンをクリアしません)。

与えられたパターンは、それぞれ @samp{--branches} または @samp{--tags} または @samp{--remotes} に適用される場合、 @samp{refs/heads} または @samp{refs/tags} または @samp{refs/remotes} で始まるべきではありません。 @samp{--glob} または @samp{--all} に適用する場合は、 @samp{refs/} で始める必要があります。末尾の "/*" を意図している場合は、明示的に指定する必要があります。

@item  @samp{--exclude-hidden=[fetch|receive|uploadpack]} 
Do not include refs that would be hidden by @samp{git-fetch}, @samp{git-receive-pack} or @samp{git-upload-pack} by consulting the appropriate @samp{fetch.hideRefs}, @samp{receive.hideRefs} or @samp{uploadpack.hideRefs} configuration along with @samp{transfer.hideRefs} (see git-config(1)). This option affects the next pseudo-ref option @samp{--all} or @samp{--glob} and is cleared after processing them.

@item  @samp{--reflog} 
reflogsで言及されているすべてのオブジェクトがコマンドラインに <commit> としてリストされているかのように見せかけます。

@item  @samp{--alternate-refs} 
代替リポジトリのref先端として言及されているすべてのオブジェクトがコマンドラインにリストされているかのように見せかけます。 代替リポジトリは、 オブジェクトディレクトリが @samp{objects/info/alternates} で指定されているリポジトリです。 インクルードされたオブジェクトのセットは、 @samp{core.alternateRefsCommand} などによって変更できます。 git-config(1)を参照してください。

@item  @samp{--single-worktree} 
デフォルトでは、 作業ツリーが複数ある場合、 @samp{--all} と @samp{-reflog} と @samp{--indexed-objects} では、 すべての作業ツリーが検査されます(git-worktree(1)を参照)。 このオプションは、 現在の作業ツリーのみを調べるように強制します。

@item  @samp{--ignore-missing} 
入力に無効なオブジェクト名が含まれている場合、そもそもその不正な入力が行われていないかのように見せかけます。

@item  @samp{--bisect} 
コマンドラインで、bad bisection ref @samp{refs/bisect/bad} がリストされ、その後に @samp{--not} と good bisection ref @samp{refs/bisect/good-*} が続くかのように見せかけます。

@item  @samp{--stdin} 
In addition to getting arguments from the command line, read them for standard input as well. This accepts commits and pseudo-options like @samp{--all} and @samp{--glob=}. When a @samp{--} separator is seen, the following input is treated as paths and used to limit the result.

@item  @samp{--cherry-mark} 
@samp{--cherry-pick}（以下を参照）と同様ですが、同等のコミットを省略せずに @samp{=} と印し、同等でないコミットを @samp{+} と印します。

@item  @samp{--cherry-pick} 
コミットの組を対称差(symmetric difference)に制限する場合、「反対側」の別のコミットと同じ変更を導入するコミットを省略します。

たとえば、@samp{A} と @samp{B} の2つのブランチがある場合、それらの片側だけですべてのコミットを一覧表示する通常の方法は、 @samp{--left-right} を使用することです(@samp{--left-right} オプションの説明の以下の例を参照してください)。ただし、他のブランチからは(ブランチAと重複しない)厳選されたコミットが表示されます(たとえば、「3rd onb」はブランチAからチェリーピックされる可能性があります)。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。

@item  @samp{--left-only} 
@itemx  @samp{--right-only} 
リストは、 対称差のそれぞれの側でのみコミットします。 つまり、 @samp{--left-right} で @samp{<} と印されるのだけか、あるいは @samp{--left-right} で @samp{>} と印されるものだけです。

たとえば、 @samp{--cherry-pick --right-only A...B} は、 @samp{A} にある、 または @samp{A} のコミットとパッチと同等のコミットを @samp{B} から省略します。 つまり、 これは @samp{git cherry A B} からの @samp{+} コミットをリストします。 より正確に書くと、 @samp{--cherry-pick --right-only --no-merges} により正確なリストを提供します。

@item  @samp{--cherry} 
@samp{--right-only --cherry-mark --no-merges} の同義語です。 出力を私たちの側のコミットに制限し、 フォークされた履歴の反対の側に適用されたものを、 @samp{git cherry upstream mybranch} と同様に @samp{git log --cherry upstream...mybranch} でマークするのに役立ちます。

@item  @samp{-g} 
@itemx  @samp{--walk-reflogs} 
コミットの祖先チェーンをたどる代わりに、 reflogエントリを最新のものから古いものに移動します。 このオプションを使用する場合、 除外するコミットを指定することはできません(つまり、 @samp{^commit} や @samp{commit1..commit2} や @samp{commit1...commit2} 表記は使用できません)。

(明らかな理由で、)@samp{oneline} と @samp{reference} 以外の @samp{--pretty} 形式では、 これにより、 出力にreflogから取得された2行の追加情報が含まれます。 出力のreflog指定子は、 @samp{ref@@@{Nth@}} (@samp{Nth} はreflogの逆時系列インデックス(reverse-chronological index))または @samp{ref@@@{timestamp@}} (そのエントリのタイムスタンプ付き)として表示されます。表示は下記のいくつかのルールに依存します:

@enumerate 

@item
開始点が @samp{ref@@@{Nth@}} として指定されている場合は、インデックス形式を表示します。

@item
開始点が @samp{ref@@@{now@}} として指定されている場合は、タイムスタンプ形式を表示します。

@item
上記のどちらも使用されていないが、コマンドラインで @samp{--date} が指定されている場合は、 @samp{--date} で要求された形式でタイムスタンプを表示します。

@item
それ以外の場合は、インデックス形式を表示します。
@end enumerate

@samp{--pretty = oneline} では、コミットメッセージの前にこの情報が同じ行に付けられます。このオプションを @samp{--reverse} と組み合わせることはできません。 git-reflog(1)も参照してください。

@samp{--pretty=reference} では、この情報はまったく表示されません。

@item  @samp{--merge} 
マージが失敗した後、競合があり、マージするすべてのheadに存在しないファイルに関連(touch)するrefを表示します。

@item  @samp{--boundary} 
除外された境界コミットを出力します。 境界コミットの前には @samp{-} が付いています。
@end table

@noindent

@heading History Simplification

特定の<path>を変更するコミットなど、履歴の一部のみに関心がある場合があります。ただし、「履歴の簡略化」(History Simplification)は2つの部分から成ります。履歴を簡略化するためにはさまざまな戦略があるためです。その1つはコミットの選択であり、もう1つはそれを行う方法です。

以下のオプションは、表示するコミットを選択します:

@table @asis

@item  <paths> 
指定された<パス>を変更するコミットが選択されます。

@item  @samp{--simplify-by-decoration} 
いくつかのブランチまたはタグによって参照されるコミットが選択されます。
@end table

注意: 意味のある重要な履歴のために、追加のコミットを表示できることに注意してください。

以下のオプションは、簡略化の実行方法に影響します。

@table @asis

@item  Default mode 
履歴を、ツリーの最終状態を説明する最も単純な履歴に単純化します。最終結果が同じである場合(つまり、同じコンテンツのブランチをマージする場合)、いくつかの傍流ブランチ(side branches)を削除するため、最も単純です。

@item  @samp{--show-pulls} 
デフォルトモードからのすべてのコミットを含めますが、最初の親へのTREESAMEではなく、後の親へのTREESAMEであるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに役立ちます。(訳注:TREESAME=pathspecが全く同一であるツリー)

@item  @samp{--full-history} 
デフォルトモードと同じですが、一部の履歴を削除しません。

@item  @samp{--dense} 
選択したコミットのみが表示され、重大で意味のある履歴を持つコミットもいくつか表示されます。

@item  @samp{--sparse} 
簡略化された履歴内のすべてのコミットが表示されます。

@item  @samp{--simplify-merges} 
このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除するための`--full-history`への追加オプション。

@item  @samp{--ancestry-path[=<commit>]} 
表示するコミットの範囲を指定すると(例: @samp{commit1..commit2} または @samp{commit2 ^commit1})、その範囲内で <commit> の祖先、<commit> の子孫、または <commit> 自身であるコミットのみを表示します。 コミットが指定されていない場合は、@samp{commit1} (範囲の除外部分) を <commit> として使用します。 複数回渡すことができます。 その場合、あるコミットが指定されたコミットのいずれかであるか、それらのいずれかの祖先または子孫である場合、そのコミットは含まれます。
@end table

より詳細な説明は以下のとおりです。

<paths> として @samp{foo} を指定したとします。 @samp{foo} !TREESAME を変更するコミットを呼び出し、残りをTREESAMEと呼びます。( @samp{foo} のためにフィルタリングされた差分では、それぞれ異なって見えたりたり等しく見えたりします。）

以下、簡略化設定の違いを説明するために、同じ履歴例を使います。このコミットグラフでは、ファイル @samp{foo} をフィルタリングしていると想定しています:

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \   /   /   /   /   /
          `-------------'   X
@end example


履歴 A---Q の水平線は、各マージの最初の親と見なされます。その各コミットは以下のとおりです:

@itemize 

@item
@samp{I} は最初のコミットであり、ファイル foo が内容 “asdf” で存在し、ファイル quux は内容 “quux” で存在します。最初のコミットは空のツリーと比較されるため、@samp{I} は !TREESAME です。

@item
@samp{A} では、 foo には “foo” だけが含まれています。

@item
@samp{B} には @samp{A} と同じ変更が含まれています。そのマージ @samp{M} は些細なことであり、したがってすべての親にとって TREESAME です。

@item
@samp{C} は @samp{foo} を変更しませんが、そのマージ @samp{N} はそれを “foobar” に変更するので、どの親にとっても TREESAME ではありません。

@item
@samp{D} は @samp{foo} を “baz” に設定します。そのマージ @samp{O} は、 @samp{N} と @samp{D} から “foobarbaz” への文字列を結合します。つまり、どの親にとっても TREESAME ではありません。

@item
@samp{E} は @samp{quux} を “xyzzy” に変更し、そのマージ @samp{P} は文字列を “quuxxyzzy” に結合します。 @samp{P} は @samp{O} に対して TREESAME ですが、 @samp{E} に対してはそうではありません。

@item
@samp{X} は、新ファイル @samp{side} を追加し、 @samp{Y} がそれを変更した独立したルートコミットです。 @samp{Y} は @samp{X} へのTREESAMEです。そのマージ @samp{Q} は @samp{P} に @samp{side} を追加し、 @samp{Q} は @samp{P} にはTREESAMEですが、@samp{Y} に対してはそうではありません。
@end itemize

@samp{rev-list} は、 @samp{--full-history} および/または、( @samp{--parents} または @samp{--children} を介して)親の書き換えが使用されているかどうかに基づいて、コミットを含めたり除外したりして、履歴を逆方向にウォークスルーします。以下の設定が可能です。

@table @asis

@item  Default mode 
コミットは、どの親に対してもTREESAMEでない場合に含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。コミットがマージであり、一方の親に対するTREESAMEであった場合は、その親のみをフォローします。(TREESAMEの親が複数ある場合でも、そのうちの1つだけをフォローします)。それ以外の場合は、すべての親をフォローします。

これにより、以下のようになります:

@example
          .-A---N---O
         /     /   /
        I---------D
@end example


TREESAMEの親のみに従うルールが利用可能な場合は、 @samp{B} を検討対象から完全に削除したことに注意してください。 @samp{C} は @samp{N} を介して考慮されましたが、しかしそれはTREESAMEです。ルートコミットは空のツリーと比較されるため、 @samp{I} は !TREESAME です。

親子関係は @samp{--parents} でのみ表示されますが、デフォルトモードで選択されたコミットには影響しないため、親の行を示しました。

@item  @samp{--full-history without parent rewriting} 
このモードは、デフォルトとはある一点で異なります。つまり、いずれかの親に対してTREESAMEであっても、常にマージのすべての親に従います。マージの複数の側にコミットが含まれている場合でも、これはマージ自体が含まれていることを意味するものではありません！ 例では以下のようになります。

@example
        I  A  B  N  D  O  P  Q
@end example


@samp{M} は、両方の親にとってTREESAMEであるため、除外されました。 @samp{E} と @samp{C} と @samp{B} をすべて巡りましたが、 @samp{B} だけが !TREESAME だったので、他は表示されません。

注意: 親の書き換え(rewrite)がないと、コミット間の親子関係について話す(talk)ことは実際には不可能であるため、それらが切断されている(disconnected)ことを示していることに注意してください。

@item  @samp{--full-history with parent rewriting} 
通常のコミットは !TREESAME の場合にのみ含まれます(これは変更できますが、以下の @samp{--sparse} を参照してください)。

マージは常に含まれます。ただし、親リストは書き直されます。各親に沿って、自分自身に含まれていないコミットを削除します。 これにより以下のようになります。

@example
          .-A---M---N---O---P---Q
         /     /   /   /   /
        I     B   /   D   /
         \   /   /   /   /
          `-------------'
@end example


上記を書き直さずに @samp{--full-history} と比較してください。 @samp{E} はTREESAMEであるため削除されましたが、Pの親リストは @samp{E} の親 @samp{I} を含むように書き直されていることに注意してください。 @samp{C} と @samp{N} および @samp{X} と @samp{Y} と @samp{Q} についても同じことが起こりました。
@end table

上記の設定に加えて、あなたはTREESAMEが包含に影響を与えるかどうかを変更できます:

@table @asis

@item  @samp{--dense} 
巡ったコミットは、親にとってTREESAMEでない場合に含まれます。

@item  @samp{--sparse} 
巡ったすべてのコミットが含まれます。

@samp{--full-history} がなくても、これによりマージが単純化されることに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側を巡ることはありません。

@item  @samp{--simplify-merges} 
最初に、親を書き換えた @samp{--full-history} と同じ方法で履歴グラフを作成します(上記を参照)。

それから、以下のルールに従って、各コミット @samp{C} を最終履歴内の置換 @samp{C'} に単純化します:

@itemize 

@item
@samp{C'} を @samp{C} にセットします。

@item
@samp{C'} の各親 @samp{P} をその簡略化された @samp{P'} に置き換えます。その過程で、他の親の祖先であるか、ルートである親を削除すると、TREESAMEが空のツリーにコミットされ、重複が削除されますが、TREESAMEであるすべての親を削除しないように注意してください。

@item
この親の書き換え後、 @samp{C'} がルートまたはマージコミット(0または >1 の親を持つ)、境界コミット、または !TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。
@end itemize

この効果は、親の書き換えを使用した @samp{--full-history} と比較することで最もよく示されます。例は以下のようになります:

@example
          .-A---M---N---O
         /     /       /
        I     B       D
         \   /       /
          `---------'
@end example


注意: @samp{--full-history} に対する @samp{N} と @samp{P} と @samp{Q} の主な違いに注意してください:

@itemize 

@item
@samp{N} の親リストは、他の親 @samp{M} の祖先であるため、 @samp{I} が削除されました。それでも、 !TREESAME なので @samp{N} が残りました。

@item
@samp{P} の親リストも同様に @samp{I} が削除されました。 @samp{P} は、親が1つで TREESAMEであるため、完全に削除されました。

@item
@samp{Q} の親リストでは、 @samp{Y} が @samp{X} に簡略化されていました。その後、 @samp{X} はTREESAMEルートであったため、削除されました。 @samp{Q} は、親が1つで TREESAMEであるため、完全に削除されました。
@end itemize
@end table

利用可能な別の簡略化モードがあります:

@table @asis

@item  @samp{--ancestry-path[=<commit>]} 
表示されるコミットを <commit> の祖先、または <commit> の子孫、または <commit> 自身に制限します。

ユースケースの例として、以下のコミット履歴について考えます:

@example
            D---E-------F
           /     \       \
          B---C---G---H---I---J
         /                     \
        A-------K---------------L--M
@end example


通常の @samp{D..M} は、 @samp{M} の祖先であるコミットのセットを計算しますが、 @samp{D} の祖先であるコミットは除外します。 これは、「 @samp{M} には @samp{D} には存在しなかったものがある」という意味で、 @samp{D} 以降の @samp{M} に至るまでの歴史に何が起こったのかを知るのに役立ちます。この例の結果は、 @samp{A} と @samp{B} (そしてもちろん @samp{D} 自体)を除くすべてのコミットになります。

ただし、 @samp{M} のコミットが @samp{D} で入ったバグで汚染されており、修正が必要な場合は、実際には @samp{D} の子孫である @samp{D..M} のサブセットのみを表示する必要があります。つまり、 @samp{C} と @samp{K} を除外します。これはまさに @samp{--ancestry-path} オプションが行うことです。これを @samp{D..M} 範囲に適用すると、以下のようになります:

@example
                E-------F
                 \       \
                  G---H---I---J
                               \
                                L--M
@end example


@samp{--ancestry-path} の代わりに @samp{--ancestry-path=D} を使用することもできます。これは、@samp{D..M} 範囲に適用された場合と同じことを意味しますが、より明示的です。

代わりに、この範囲内の特定のトピックに関心があり、そのトピックによって影響を受けるすべてのコミットに関心がある場合、祖先パスにそのトピックを含む @samp{D..M} のサブセットのみを表示したい場合があります。 たとえば、@samp{--ancestry-path=H D..M} を使用すると、以下のようになります:

@example
                E
                 \
                  G---H---I---J
                               \
                                L--M
@end example


一方、@samp{--ancestry-path=K D..M} は以下のようになります

@example
                K---------------L--M
@end example

@end table

別のオプション @samp{--show-pulls} について説明する前に、新しいサンプル履歴を作成する必要があります。

簡略化された履歴を見るときにユーザーが直面する一般的な問題は、ファイルを変更したことがわかっているコミットが、ファイルの簡略化された履歴に表示されないことです。そこで、新しい例を示し、その場合に @samp{--full-history} や @samp{--simplify-merges} などのオプションがどのように機能するかを示しましょう。

@example
          .-A---M-----C--N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`-Z'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `---Y--'
@end example


この例では、 @samp{I} が @samp{file.txt} を作成し、それが @samp{A} と`B` と @samp{X} にてさまざまな方法で変更されたとします。ひとり親のコミット @samp{C} と @samp{Z} と @samp{Y} は @samp{file.txt} を変更していません。マージコミット @samp{M} は、マージの競合を解決して、 @samp{A} と @samp{B} の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。ただし、マージコミット @samp{R} は、 @samp{M} の @samp{file.txt`の内容を無視し、 `X} の @samp{file.txt} の内容のみを取得することによって作成されました。 したがって、 @samp{R} は @samp{X} へのTREESAMEですが、 @samp{M} はそうではありません。最後に、 @samp{N} を作成するための自然なマージ解決は、 @samp{R} で @samp{file.txt} の内容を取得することです。したがって、 @samp{N} は @samp{C} ではなく @samp{R} へのTREESAMEです。マージコミット @samp{O} と @samp{P} は、最初の親にはTREESAMEですが、2番目の親である @samp{Z} と @samp{Y} にはついてはそうではありません。

デフォルトモードを使用する場合、 @samp{N} と @samp{R} は両方ともTREESAMEの親を持っているため、これらのエッジはウォークされ、他のエッジは無視されます。結果の履歴グラフは以下のとおりです:

@example
        I---X
@end example


@samp{--full-history} を使用する場合、Gitはすべてのエッジを巡ります。これにより、コミット @samp{A} と @samp{B} と マージ @samp{M} が検出されますが、マージコミット @samp{O} と @samp{P} も明らかになります。 親を書き換えると、結果のグラフは以下のようになります:

@example
          .-A---M--------N---O---P
         /     / \  \  \/   /   /
        I     B   \  R-'`--'   /
         \   /     \/         /
          \ /      /\        /
           `---X--'  `------'
@end example


ここで、マージコミット @samp{O} と @samp{P} は、実際には @samp{file.txt} への変更を提供しなかったため、余分なノイズを提供します。古いバージョンの @samp{file.txt} に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です。 @samp{--full-history} の結果には、関連のない多くのマージが表示されます。

@samp{--simplify-merges} オプションを使用すると、コミット @samp{O} と @samp{P} が結果から消えます。 これは、 @samp{O} と @samp{P} の書き直された2番目の親が、最初の親から到達可能であるためです。これらのエッジが削除されると、コミットは、親にとってTREESAMEである単一の親のコミットのように見えます。これはコミット @samp{N} にも発生し、以下のような履歴ビューが表示されます:

@example
          .-A---M--.
         /     /    \
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


このビューでは、 @samp{A} と @samp{B} と @samp{X} からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ @samp{M} とそれほど慎重に解決されていないマージ @samp{R} も表示されます。これは通常、コミット @samp{A} と @samp{B} がデフォルトのビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。

最初の問題はパフォーマンスです。以前のオプションとは異なり、 @samp{--simplify-merges} オプションでは、単一の結果を返す前にコミット履歴全体をウォークする必要があります。これにより、非常に大規模なリポジトリでこのオプションを使用するのが難しくなる可能性があります。

2番目の問題は監査の1つです。多くの寄稿者が同じリポジトリで作業している場合、どのマージコミットが重要なブランチに変更を導入したかが重要です。上記の問題のあるマージ @samp{R} は、重要なブランチにマージするために使用されたマージコミットではない可能性があります。 代わりに、マージ @samp{N} を使用して @samp{R} と @samp{X} を重要なブランチにマージしました。このコミットには、変更 @samp{X} がコミットメッセージの @samp{A} と @samp{B} からの変更を上書きするようになった理由に関する情報が含まれている可能性があります。

@table @asis

@item  @samp{--show-pulls} 
デフォルトの履歴に表示されるコミットに加えて、最初の親にはTREESAMEではなく、後の親にはTREESAMEである各マージコミットを表示します。

マージコミットが @samp{--show-pulls} に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で @samp{--show-pulls} を使用すると(他のオプションは使用しない場合、)結果のグラフは行かのようになります:

@example
        I---X---R---N
@end example


ここで、コミット @samp{X} と @samp{R} をそれぞれベースブランチにプルしたため、マージコミット @samp{R} と @samp{N} が含まれています。これらのマージは、コミット @samp{A} と @samp{B} がデフォルトの履歴に表示されない理由です。

@samp{--show-pulls} が @samp{--simplify-merges} とペアになっている場合、グラフには必要なすべての情報が含まれます:

@example
          .-A---M--.   N
         /     /    \ /
        I     B      R
         \   /      /
          \ /      /
           `---X--'
@end example


@samp{M} は @samp{R} から到達可能であるため、 @samp{N} から @samp{M} へのエッジが単純化されていることに注意してください。ただし、 @samp{N} は、変更 @samp{R} をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。
@end table

@samp{--simplify-by-decoration} オプションを使用すると、タグで参照されていないコミットを省略して、履歴のトポロジの全体像のみを表示できます。コミットは、(1)タグによって参照されている場合、または (2)コマンドラインで指定されたパスの内容を変更した場合に、!TREESAMEとしてマークされます(つまり、上記の履歴簡略化ルールの後に保持されます)。他のすべてのコミットはTREESAMEとしてマークされます(簡略化される可能性があります)。

@noindent

@chapheading MAPPING AUTHORS

See gitmailmap(5).

注意: (標準入力でログの内容を処理するため) @samp{git shortlog} がリポジトリの外部で実行される場合、現在のディレクトリで @samp{.mailmap} ファイルが検索されることに注意してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-show-branch,,,Top
@chapheading Name

git-show-branch — ブランチとそのコミットを表示します

@noindent

@chapheading Synopsis

@display
git show-branch [-a | --all] [-r | --remotes] [--topo-order | --date-order]
                [--current] [--color[=<when>] | --no-color] [--sparse]
                [--more=<n> | --list | --independent | --merge-base]
                [--no-name | --sha1-name] [--topics]
                [(<rev> | <glob>)…]
git show-branch (-g | --reflog)[=<n>[,<base>]] [--list] [<ref>]
@end display


@noindent

@chapheading DESCRIPTION

<rev> または <glob> (または、 refs/heads および/または refs/tags の下のすべてのref)で名前が付けられたコミットから始まるコミットの祖先グラフを半視覚的に表示します。

一度に29を超えるブランチとコミットを表示することはできません。

コマンドラインで <rev> または <glob> が指定されていない場合は、 @samp{showbranch.default} の複数値(multi-valued)の構成アイテムを使用します。

@noindent

@chapheading OPTIONS

@table @asis

@item  <rev> 
通常はブランチヘッドまたはタグに名前を付ける任意の拡張SHA-1式 (gitrevisions(7) 参照)。

@item  <glob> 
refs/ の下のブランチ名またはタグ名に一致するグロブパターン。 たとえば、 refs/heads/topic の下に多くのトピックブランチがある場合、 @samp{topic/*} を指定するとそれらすべてが表示されます。

@item  @samp{-r} 
@itemx  @samp{--remotes} 
リモート追跡ブランチを表示します。

@item  @samp{-a} 
@itemx  @samp{--all} 
リモート追跡ブランチとローカルブランチの両方を表示します。

@item  @samp{--current} 
このオプションを使用すると、コマンドラインに指定されていない場合に表示されるrevのリストに現在のブランチが含まれます。

@item  @samp{--topo-order} 
デフォルトでは、ブランチとそのコミットは新しい順に表示されます。このオプションを使用すると、トポロジカル順に表示されます(つまり、子孫のコミットは親の前に表示されます)。

@item  @samp{--date-order} 
このオプションは、すべての子の前に親が来ないという意味で @samp{--topo-order} に似ていますが、それ以外の場合、コミットはコミット日に従って順序付けられます。

@item  @samp{--sparse} 
デフォルトでは、出力には、表示されている1つの先端からのみ到達可能なマージが省略されています。このオプションにより、それらが表示されます。

@item  @samp{--more=<n>} 
Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go <n> more common commits beyond that. When <n> is negative, display only the <ref>s given, without showing the commit ancestry tree.

@item  @samp{--list} 
@samp{--more=-1} と同義です。

@item  @samp{--merge-base} 
コミットリストを表示する代わりに、指定されたコミットの可能なマージベースを決定します。すべてのマージベースは、指定されたすべてのコミットに含まれます。 これは、 git-merge-base(1) が3つ以上のコミットの場合を処理する方法とは異なります。

@item  @samp{--independent} 
Among the <ref>s given, display only the ones that cannot be reached from any other <ref>.

@item  @samp{--no-name} 
各コミットの名前付け文字列(naming strings)を表示しません。

@item  @samp{--sha1-name} 
ヘッドからコミットに到達するためのパスを使用してコミットに名前を付ける代わりに(たとえば、「master」の祖父母を意味する「master~2」)、オブジェクト名の一意のプレフィックスを使用してコミットに名前を付けます。

@item  @samp{--topics} 
指定された最初のブランチにないコミットのみを表示します。これは、すでに開発のメインラインにあるコミットを非表示にすることで、トピックブランチを追跡するのに役立ちます。 @samp{git show-branch --topics master topic1 topic2} を指定すると、 @samp{git rev-list @{caret@}master topic1 topic2} で指定されたリビジョンが表示されます。

@item  @samp{-g} 
@itemx  @samp{--reflog[=<n>[,<base>]] [<ref>]} 
指定された参照の最新の参照ログエントリを<n>個表示します。<base>が指定されている場合、<n>エントリはそのエントリから戻ります。 <base>は、カウントまたは日付として指定できます。 明示的な<ref>パラメータが指定されていない場合、デフォルトで現在のブランチ(またはデタッチされている場合は @samp{HEAD} )になります。

@item  @samp{--color[=<when>]} 
所属するブランチに対応する各コミットのステータス記号(@samp{*} @samp{！} @samp{+} @samp{-} )に色を付けます。値は always (デフォルト) または never または auto である必要があります。

@item  @samp{--no-color} 
構成ファイルでデフォルトのカラー出力が指定されている場合でも、カラー出力をオフにします。 @samp{--color=never} と同じです。
@end table

@samp{--more@@ と `-list} と @samp{-independent} と @samp{--merge-base} オプションは相互に排他的であることに注意してください。

@noindent

@chapheading OUTPUT

Given N <ref>s, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk @samp{*} character while other heads are prefixed with a @samp{!} character.

これらのN行に続いて、コミットごとに1行のログが表示され、N桁インデントされます。 コミットがI番目のブランチにある場合、I番目のインデント文字は @samp{+} 記号を示します。それ以外の場合は、スペースが表示されます。 マージコミットは @samp{-} 記号で示されます。各コミットは、そのコミットに名前を付けるための拡張SHA-1として使用できる短い名前が表示されます。

以下の例は、「master」と「fixes」と「mhf」の3つのブランチを示しています:

@example
$ git show-branch master fixes mhf
* [master] Add 'git show-branch'.
 ! [fixes] Introduce "reset type" flag to "git reset"
  ! [mhf] Allow "+remote:local" refspec to cause --force when fetching.
---
  + [mhf] Allow "+remote:local" refspec to cause --force when fetching.
  + [mhf~1] Use git-octopus when pulling more than one heads.
 +  [fixes] Introduce "reset type" flag to "git reset"
  + [mhf~2] "git fetch --force".
  + [mhf~3] Use .git/remote/origin, not .git/branches/origin.
  + [mhf~4] Make "git pull" and "git fetch" default to origin
  + [mhf~5] Infamous 'octopus merge'
  + [mhf~6] Retire git-parse-remote.
  + [mhf~7] Multi-head fetch.
  + [mhf~8] Start adding the $GIT_DIR/remotes/ support.
*++ [master] Add 'git show-branch'.
@end example


これらの3つのブランチはすべて、共通のコミット[master]から分岐し、そのコミットメッセージは "Add 'git show-branch'" です。 @samp{fixes} ブランチは、 @samp{git reset} に @samp{reset type} フラグを導入するコミットを1つ追加します。 @samp{mhf} ブランチは、他の多くのコミットを追加します。 現在のブランチは @samp{master} です。

@noindent

@chapheading EXAMPLES

プライマリブランチを @samp{refs/heads} のすぐ下に置き、トピックブランチをそのサブディレクトリに保持する場合は、構成ファイルに以下の情報を含めると役立つ場合があります:

@example
[showbranch]
        default = --topo-order
        default = heads/*
@end example


これにより、追加のパラメータがない @samp{git show-branch} は、プライマリブランチのみを表示します。さらに、トピックブランチにいる場合は、それも表示されます。

@example
$ git show-branch --reflog="10,1 hour ago" --list master
@end example


これは、1時間前の時点で先端から戻った10個のreflogエントリを示しています。 @samp{--list} がない場合、出力には、これらのヒントがトポロジ的に相互にどのように関連しているかも示されます。

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  showBranch.default 
git-show-branch(1) のデフォルトのブランチセット。 git-show-branch(1) を参照してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-show-index,,,Top
@chapheading Name

git-show-index — パックされたアーカイブインデックスを表示する

@noindent

@chapheading Synopsis

@display
git show-index [--object-format=<hash-algorithm>]
@end display


@noindent

@chapheading DESCRIPTION

標準入力から、(git-pack-objects(1) または git-index-pack(1) で作成の)Gitパックファイルの、 @samp{.idx} ファイルを読み取り、その内容をダンプします。 出力は、行ごとに1つのオブジェクトで構成され、各行には2つまたは3つのスペースで区切られた複数列が含まれます:

@itemize 

@item
最初の列は、対応するパックファイル内のオブジェクトのバイト単位のオフセットです。

@item
2番目の列はオブジェクトのオブジェクトIDです

@item
インデックスバージョンが2以上の場合、3番目の列にはオブジェクトデータのCRC32が含まれます
@end itemize

オブジェクトは、インデックスファイルで見つかった順序で出力されます。(正しく作成されたファイルであれば、)インデックスファイルはオブジェクトIDソートされていなければなりません。

注意: あなたは git-verify-pack(1) を呼び出すと、パックファイルに関する情報をよりたくさん取得できます。けれども、このコマンド(show-index)はインデックスファイル自体のみを考慮するため、より高速で柔軟性があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--object-format=<hash-algorithm>} 
インデックスファイルのためのオブジェクト形式(ハッシュアルゴリズム)を指定します。有効な値は @emph{sha1} および (有効な場合) @emph{sha256} です。 デフォルトは、現在のリポジトリのアルゴリズム(@samp{extensions.objectFormat} で設定)、または値が設定されていないかリポジトリの外部にある場合は @emph{sha1} です。

このオプションは実験的なものです！ SHA-256のサポートは実験的なものであり、まだ初期段階です。 SHA-256リポジトリは、通常、「通常の」SHA-1リポジトリと作業を共有できません。 たとえば、SHA-256リポジトリに関連するGit内部ファイル形式は、下位互換性のない方法で変更される可能性があると想定する必要があります。テスト目的でのみ @samp{--object-format=sha256} を使用してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-show-ref,,,Top
@chapheading Name

git-show-ref — ローカルリポジトリ内の参照を一覧表示します

@noindent

@chapheading Synopsis

@display
git show-ref [-q | --quiet] [--verify] [--head] [-d | --dereference]
             [-s | --hash[=<n>]] [--abbrev[=<n>]] [--tags]
             [--heads] [--] [<pattern>…]
git show-ref --exclude-existing[=<pattern>]
@end display


@noindent

@chapheading DESCRIPTION

ローカルリポジトリで使用可能な参照を、関連するコミットIDとともに表示します。結果はパターンを使用してフィルタリングでき、タグはオブジェクトIDに逆参照できます。さらに、特定のrefが存在するかどうかをテストするために使用できます。

デフォルトでは、タグとヘッドとリモートrefを表示します。

The @samp{--exclude-existing} form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don’t exist in the local repository.

@samp{.git} ディレクトリの下のファイルに直接アクセスするために、このユーティリティの使用をお勧めします。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--head} 
通常は検索除外される場合でも、HEAD参照を表示します。

@item  @samp{--heads} 
@itemx  @samp{--tags} 
それぞれ「refs/heads」と「refs/tags」に制限します。これらのオプションは相互に排他的ではありません。 両方を指定すると、「refs/heads」と「refs/tags」に保存されている参照が表示されます。

@item  @samp{-d} 
@itemx  @samp{--dereference} 
Dereference tags into object IDs as well. They will be shown with @samp{@{caret@}@{@}} appended.

@item  @samp{-s} 
@itemx  @samp{--hash[=<n>]} 
Only show the OID, not the reference name. When combined with @samp{--dereference}, the dereferenced tag will still be shown after the OID.

@item  @samp{--verify} 
正確な参照パスを要求することにより、より厳密な参照チェックを有効にします。エラーコード1を返す以外に、 @samp{--quiet} が指定されていない場合はエラーメッセージも出力します。

@item  @samp{--abbrev[=<n>]} 
オブジェクト名を省略します。 @samp{--hash} を使用する場合は @samp{--hash --abbrev} と言う必要はなく、 @samp{--hash=n} で十分です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
Do not print any results to stdout. When combined with @samp{--verify}, this can be used to silently check if a reference exists.

@item  @samp{--exclude-existing[=<pattern>]} 
Make @samp{git show-ref} act as a filter that reads refs from stdin of the form @samp{^(?:<anything>\s)?<refname>(?:\^@{@})?$} and performs the following actions on each:
(1) strip @samp{@{caret@}@{@}} at the end of line if any;
(2) パターンが指定されていて、refnameとヘッドが一致(head-match)しない場合は無視
(3) refnameが整形式(well-formed)のrefnameでない場合は警告し、スキップします
(4) refnameがローカルリポジトリに存在するrefである場合は無視
(5) それ以外の場合は、行を出力します。

@item  <pattern>… 
1つ以上のパターンに一致する参照を表示します。パターンはフルネームの末尾から一致し、完全な部品のみが一致します。 「master」は「refs/heads/master」や「refs/remotes/origin/master」や「refs/tags/jedi/master」と一致しますが、「refs/heads/mymaster」とか「refs/remotes/master/jedi」とは一致しません 。
@end table

@noindent

@chapheading OUTPUT

The output is in the format:

@example
<oid> SP <ref> LF
@end example


For example,

@example
$ git show-ref --head --dereference
832e76a9899f560a90ffd62ae2ce83bbeff58f54 HEAD
832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/master
832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/origin
3521017556c5de4159da4615a39fa4d5d2c279b5 refs/tags/v0.99.9c
6ddc0964034342519a87fe013781abf31c6db6ad refs/tags/v0.99.9c^@{@}
055e4ae3ae6eb344cbabf2a5256a49ea66040131 refs/tags/v1.0rc4
423325a2d24638ddcc82ce47be5e40be550f4507 refs/tags/v1.0rc4^@{@}
...
@end example


When using @samp{--hash} (and not @samp{--dereference}), the output is in the format:

@example
<oid> LF
@end example


For example,

@example
$ git show-ref --heads --hash
2e3ba0114a1f52b47df29743d6915d056be13278
185008ae97960c8d551adcd9e23565194651b5d1
03adf42c988195b50e1a1935ba5fcbc39b2b029b
...
@end example


@noindent

@chapheading EXAMPLES

タグやヘッドなど、「master」と呼ばれるすべての参照を表示するには、参照の名前付け階層の深さに関係なく、以下を使用します:

@example
        git show-ref master
@end example


これには、「refs/heads/master」だけでなく、「refs/remote/other-repo/master」も表示されます(そのような参照が存在する場合)。

@samp{--verify} フラグを使用する場合、コマンドには正確なパスが必要です:

@example
        git show-ref --verify refs/heads/master
@end example


これは「master」と呼ばれる正確なブランチにのみ一致します。

If nothing matches, @samp{git show-ref} will return an error code of 1, and in the case of verification, it will show an error message.

For scripting, you can ask it to be quiet with the @samp{--quiet} flag, which allows you to do things like

@example
        git show-ref --quiet --verify -- "refs/heads/$headname" ||
                echo "$headname is not a valid branch"
@end example


これは、特定のブランチが存在するかどうかを確認します(実際には結果を表示したくないので、あいまいな部分一致で問題が発生しないように、完全なrefnameを使用します)。

To show only tags, or only proper branch heads, use @samp{--tags} and/or @samp{--heads} respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).

To do automatic tag object dereferencing, use the @samp{-d} or @samp{--dereference} flag, so you can do

@example
        git show-ref --tags --dereference
@end example


これは、すべてのタグのリストを、それらが逆参照するものと一緒に取得します。

@noindent

@chapheading FILES

@samp{.git/refs/*}, @samp{.git/packed-refs}

@noindent

@chapheading SEE ALSO

git-for-each-ref(1), git-ls-remote(1), git-update-ref(1), gitrepository-layout(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-show,,,Top
@chapheading Name

git-show — さまざまなタイプのオブジェクトを表示

@noindent

@chapheading Synopsis

@display
git show [<options>] [<object>…]
@end display


@noindent

@chapheading DESCRIPTION

1つまたはそれ以上のオブジェクト(ブロブ・ツリー・タグ・コミット)を表示します。

コミットの場合、ログメッセージとテキストの差分が表示されます。 また、 @emph{git diff-tree --cc} によって生成された特別な形式でマージコミットを示します。

タグの場合、タグメッセージと参照オブジェクトが表示されます。

ツリーの場合は、名前が表示されます(@samp{--name-only} オプション付きの @emph{git ls-tree} 相当)。

プレーンブロブの場合は、プレーンコンテンツが表示されます。

このコマンドは、「git diff-tree」コマンドに適用可能なオプションを使用して、コミットによって導入された変更の表示方法を制御します。

このマニュアルページでは、最も頻繁に使用されるオプションについてのみ説明します。

@noindent

@chapheading OPTIONS

@table @asis

@item  <object>… 
表示するオブジェクトの名前(デフォルトは「HEAD」)。オブジェクト名を綴る方法のより完全なリストについては、 gitrevisions(7) の「SPECIFYING REVISIONS」セクションを参照してください。

@item  @samp{--pretty[=<format>]} 
@itemx  @samp{--format=<format>} 
コミットログの内容を指定された形式できれいに印刷(pretty-print)します。 <format> は oneline、short、medium、full、fuller、reference、email、raw、format:<string>、tformat:<string> のいずれかになります。 <format> が上記のいずれでもなく、「%プレースホルダー」が含まれている場合、 @samp{--pretty=tformat:<format>} が指定されたかのように動作します。

各フォーマットの詳細については、「PRETTY FORMATS」セクションを参照してください。 @samp{=<format>} の部分を省略すると、デフォルトで medium になります。

注意: リポジトリー構成でデフォルトのpretty formatを指定できます(git-config(1) 参照)。

@item  @samp{--abbrev-commit} 
40バイトの16進コミットオブジェクト名全体を表示する代わりに、オブジェクトに一意の名前を付けるプレフィックスを表示します。 "--abbrev=<n>" (表示されている場合はdiff出力も変更します)オプションを使用して、プレフィックスの最小長を指定できます。

これにより、80桁幅の端末を使用している人にとって "--pretty=oneline" がずっと読みやすくなるはずです。

@item  @samp{--no-abbrev-commit} 
完全な40バイトの16進コミットオブジェクト名を表示します。 これにより、明示的または "--oneline" などの他のオプションによって暗黙的に示される @samp{--abbrev-commit} が無効になります。また、 @samp{log.abbrevCommit} 変数をオーバーライドします。

@item  @samp{--oneline} 
これは、 "--pretty=oneline --abbrev-commit" を一緒に使用するための省略形です。

@item  @samp{--encoding=<encoding>} 
コミットオブジェクトは、ログメッセージに使用される文字エンコードをエンコードヘッダーに記録します。このオプションを使用して、ユーザーが好むエンコーディングでコミットログメッセージを再コーディングするようにコマンドに指示できます。配管以外のコマンドの場合、これはデフォルトでUTF-8になります。オブジェクトが @samp{X} でエンコードされていると主張し、 @samp{X} で出力している場合、オブジェクトをそのまま出力することに注意してください。これは、元のコミットの無効なシーケンスが出力にコピーされる可能性があることを意味します。 同様に、 iconv(3) がコミットの変換に失敗した場合、 元のオブジェクトをそのまま黙って出力します。

@item  @samp{--expand-tabs=<n>} 
@itemx  @samp{--expand-tabs} 
@itemx  @samp{--no-expand-tabs} 
出力に表示する前に、ログメッセージでタブ展開を実行します(タブ幅を <n> とみなして <n> 境界に揃うように空白で調整する)。 @samp{--expand-tabs} は @samp{--expand-tabs=8} の省略形であり、 @samp{--no-expand-tabs} は @samp{--expand-tabs=0} の省略形です。タブの展開を無効にします。

デフォルトでは、タブはログメッセージを4つのスペースでインデントするきれいな形式(pretty formats)で展開されます(つまり、medium (これがデフォルト) と full と fuller)。

@item  @samp{--notes[=<ref>]} 
コミットログメッセージを表示するときに、コミットに注釈を付けるnotes(git-notes(1) 参照)を表示します。これは、コマンドラインに @samp{--pretty} 、@samp{--format} または @samp{--oneline} オプションが指定されていない場合の、 @samp{git log} と @samp{git show} と ` git whatchanged` コマンドのデフォルトです。

デフォルトでは、表示されるnotesは、 @samp{core.notesRef} および @samp{notes.displayRef} 変数(または対応する環境変数オーバーライド)にリストされているnote refからのものです。詳細については git-config(1) を参照してください。

オプションの <ref> 引数を使用して、refを使用して表示するnotesを検索します。 refは、 @samp{refs/notes/} で始まる完全なrefnameを指定できます。 @samp{notes/} で始まるか、 @samp{refs/} で始まるか、それ以外で始まる場合、 @samp{refs/notes/} が接頭辞として付けられ、refのフルネームを形成します。

複数の --notes オプションを組み合わせて、表示するノートを制御できます。 例: "--notes=foo" は "refs/notes/foo" からのnotesのみを表示します。 "--notes=foo --notes" は、 "refs/notes/foo" とデフォルトのnotes ref(s) の両方のnotesを表示します。

@item  @samp{--no-notes} 
notesを表示しないでください。 これは、notesが表示されるnotes refのリストをリセットすることにより、上記の @samp{--notes} オプションを無効にします。 オプションは、コマンドラインで指定された順序で解析されます。 "--notes --notes=foo --no-notes --notes=bar" は、 "refs/notes/bar" からのnotesのみを表示します。

@item  @samp{--show-notes[=<ref>]} 
@itemx  @samp{--[no-]standard-notes} 
これらのオプションは非推奨です。 代わりに、上記の --notes/--no-notes オプションを使用してください。

@item  @samp{--show-signature} 
署名を @samp{gpg --verify} に渡して、署名されたコミットオブジェクトの有効性を確認し、出力を表示します。
@end table

@noindent

@chapheading PRETTY FORMATS

コミットがマージであり、 pretty-format が @samp{oneline} または @samp{email} または @samp{raw} で無い場合、 @samp{Author:} 行の前に追加の行が挿入されます。この行は "Merge: " で始まり、先祖のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合、リストされたコミットは必ずしも @strong{直接} の親コミットのリストではない可能性があることに注意してください。

いくつかの組み込みフォーマットがあります。そして以下で説明するように、 pretty.<name> 構成オプション(config option)を別のフォーマット名または @samp{format:} 文字列に設定することで、追加のフォーマットを定義できます(git-config(1) 参照)。組み込みフォーマットの詳細は以下のとおりです:

@itemize 

@item
@samp{oneline}

@example
<hash> <title-line>
@end example

これは、可能な限りコンパクトになるように設計されています。

@item
@samp{short}

@example
commit <hash>
Author: <author>
@end example

@example
<title-line>
@end example

@item
@samp{medium}

@example
commit <hash>
Author: <author>
Date:   <author-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{full}

@example
commit <hash>
Author: <author>
Commit: <committer>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{fuller}

@example
commit <hash>
Author:     <author>
AuthorDate: <author-date>
Commit:     <committer>
CommitDate: <committer-date>
@end example

@example
<title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{reference}

@example
<abbrev-hash> (<title-line>, <short-author-date>)
@end example

この形式は、コミットメッセージ内の別のコミットを参照するために使用され、 @samp{--pretty='format:%C(auto)%h (%s, %ad)'} と同じです。 デフォルトでは、別の @samp{--date} オプションが明示的に指定されていない限り、日付は @samp{--date=short} でフォーマットされます。formatプレースホルダーを使用する他の @samp{format:} と同様に、その出力は、 @samp{--decorate} や @samp{--walk-reflogs} などの他のオプションの影響を受けません。

@item
@samp{email}

@example
From <hash> <date>
From: <author>
Date: <author-date>
Subject: [PATCH] <title-line>
@end example

@example
<full-commit-message>
@end example

@item
@samp{mboxrd}

@samp{email} と同様ですが、コミットメッセージの "From " で始まる行(前に0個以上の @samp{>} が付いている)は @samp{>} でクォートされているため、新しいコミットの開始と混同されることはありません。

@item
@samp{raw}

@samp{raw} 形式は、コミットオブジェクトに格納されているとおりにコミット全体を正確に表示します。とりわけ @samp{--abbrev} または @samp{--no-abbrev} のどちらが使用されているかに関係なく、ハッシュは完全に表示され、「親」(parents)情報は、移植や履歴の単純化を考慮せずに、真の親のコミットを示します。この形式は、コミットの表示方法に影響しますが、いわゆる @samp{git log --raw} の差分の表示方法ではありません。生のdiff形式で完全なオブジェクト名を取得するには、 @samp{--no-abbrev} を使用します。

@item
@samp{format:<format-string>}

@samp{format:<format-string>} 形式を使用すると、表示する情報を指定できます。注意: これはprintf書式に少し似ていますが、 @samp{\n} の代わりに @samp{%n} を使用して改行を取得するという例外に注意してください。

例: @samp{format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"} は以下のように表示されます:

@example
The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<
@end example


さて、以下がプレースホルダー達です:

@itemize 

@item
単一のリテラル文字に展開されるプレースホルダー:

@table @asis

@item  @samp{%n} 
改行(newline)

@item  @samp{%%} 
`%`そのもの

@item  @samp{%x00} 
16進数のバイト値を出力
@end table

@item
これより後ろのプレースホルダーのフォーマッティングに影響を与えるプレースホルダー:

@table @asis

@item  @samp{%Cred} 
赤色に切り替える

@item  @samp{%Cgreen} 
緑色に切り替える

@item  @samp{%Cblue} 
青色に切り替える。

@item  @samp{%Creset} 
色をリセットする

@item  @samp{%C(...)} 
git-config(1) の「CONFIGURATION FILE」の Values で説明されている色の指定。 デフォルトでは、色はログ出力が有効になっている場合にのみ表示されます(@samp{color.diff} または @samp{color.ui} または @samp{--color} によって、ターミナルに出す場合は前者の @samp{auto} 設定を尊重します)。 @samp{%C(auto,...)} は、 default の歴史的同義語として受け入れられます(例: @samp{%C(auto,red)})。 @samp{%C(always,...)} を指定すると、色が有効になっていない場合でも色が表示されます(この形式やgitが色付けする可能性のある他のすべてのものを含め、出力全体の色を有効にするために @samp{--color=always} の使用を検討してください)。 @samp{auto} のみ(つまり、 @samp{%C(auto)})は、色が再び切り替えられるまで、これに続くプレースホルダーで自動色付けをオンにします。

@item  @samp{%m} 
左(@samp{<}) または 右(@samp{>}) または 境界 (@samp{-}) の印

@item  @samp{%w([<w>[,<i1>[,<i2>]]])} 
git-shortlog(1) の -w オプションのように、行の折返しを切り替えます。

@item  @samp{%<( <N> [,trunc|ltrunc|mtrunc])} 
これの次のプレースホルダーが少なくとも N 列幅になるようにし、必要に応じて右側にスペースを詰めます。出力が N 列より長い場合は、オプションで、左側 (ltrunc) @samp{..ft} 切り捨て、または 中央 (mtrunc) @samp{mi..le} 切り捨て、または末尾切り捨て (trunc) @samp{rig..} ます (@emph{..} は省略符号)。 注意1: 切り捨ては N >= 2 の場合にのみ正しく機能します。 注意2: N および M (以下参照) 値の前後の空白はオプションです。 注意3: 絵文字やその他のワイド・キャラクタは表示桁を2つ必要とするため、桁の境界を超える可能性があります。 注意4: 複合文字マーク(character combining marks)が詰物境界で誤って分割配置される可能性があります。

@item  @samp{%<|( <M> )} 
これの次のプレースホルダーが少なくとも M 桁目の表示桁までを占めるようにし、必要に応じて右側に空白を詰めます。 端末ウィンドウの右端から測定した桁位置には、負の M 値を使用して下さい。

@item  @samp{%>( <N> )}, @samp{%>|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、左側に空白が埋め込まれます

@item  @samp{%>>( <N> )}, @samp{%>>|( <M> )} 
それぞれ @samp{%>( <N> )}, @samp{%>|( <M> )} に似ていますが、 これに続くプレースホルダーが指定よりも多くの空白を使用し、その左側に空白がある場合は、それらの空白を使用します

@item  @samp{%><( <N> )}, @samp{%><|( <M> )} 
それぞれ @samp{%<( <N> )}, @samp{%<|( <M> )} に似ていますが、 両側にパディングがあります(つまり、 テキストが中央に配置されます)
@end table

@item
コミットから抽出された情報に展開するプレースホルダー:

@table @asis

@item  @samp{%H} 
コミットハッシュ

@item  @samp{%h} 
省略されたコミットハッシュ

@item  @samp{%T} 
ツリーハッシュ

@item  @samp{%t} 
省略されたツリーハッシュ

@item  @samp{%P} 
親のハッシュ達

@item  @samp{%p} 
省略された親のハッシュ達

@item  @samp{%an} 
作者名

@item  @samp{%aN} 
作者名( .mailmap に関しては、 git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ae} 
作者電子メールアドレス

@item  @samp{%aE} 
作者電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%al} 
作者電子メールアドレスアカウント名(local-part)(@samp{@@} の前の部分)

@item  @samp{%aL} 
作者電子メールアカウント名(@samp{%al} 参照)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ad} 
作成日(フォーマットに関しては --date= オプション参照)

@item  @samp{%aD} 
作成日 RFC2822形式

@item  @samp{%ar} 
作成日 相対(relative)形式

@item  @samp{%at} 
作成日 UNIXタイムスタンプ形式

@item  @samp{%ai} 
作成日 ISO 8601風形式

@item  @samp{%aI} 
作成日 厳密なISO 8601形式

@item  @samp{%as} 
作成日 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ah} 
作者作成日(author date)の人間が読める形式(human style)(git-rev-list(1) の ‘--date=human’ に似ている)

@item  @samp{%cn} 
コミッター名

@item  @samp{%cN} 
コミッター名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ce} 
コミッター電子メールアドレス

@item  @samp{%cE} 
コミッター電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cl} 
コミッター電子メールアドレスアカウント名(local-part)( @samp{@@} の前の部分)

@item  @samp{%cL} 
コミッター電子メールアカウント名(local-part)( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%cd} 
コミッター日付(フォーマットに関しては @samp{--date=} オプション参照)

@item  @samp{%cD} 
コミッター日付 RFC2822形式

@item  @samp{%cr} 
コミッター日付 相対(relative)形式

@item  @samp{%ct} 
コミッター日付 UNIXタイムスタンプ形式

@item  @samp{%ci} 
コミッター日付 ISO 8601風形式

@item  @samp{%cI} 
コミッター日付 厳密なISO 8601形式

@item  @samp{%cs} 
コミッター日付 短い形式(@samp{YYYY-MM-DD})

@item  @samp{%ch} 
コミッター日付 人間が読める形式(git-rev-list(1) の @samp{--date=human} に似ている)

@item  @samp{%d} 
ref名 git-log(1) の --decorate オプションみたいなの

@item  @samp{%D} 
" (", ")" で囲ってないref名

@item  @samp{%(describe[:options])} 
git-describe(1) のような人間が読める名前。説明できないコミットの場合は空の文字列。 @samp{describe} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。タグの追加や削除を同時に行うと、説明に一貫性がなくなる可能性があります。

@itemize 

@item
@samp{tags[=<bool-value>]}: 注釈付きタグ(annotated tags)だけを考慮するのではなく、軽量タグ(lightweight tags)も考慮してください。

@item
@samp{abbrev=<number>}: 短縮ブジェクト名のデフォルトの 16 進数の桁数 (デフォルトは 7 で、リポジトリ内のオブジェクトの数によって異なります) を使用する代わりに、 <number> 桁数を指定するか、または 一意のオブジェクト名を形成するために必要な桁数。

@item
@samp{match=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグのみを考慮します。

@item
@samp{exclude=<pattern>}: @samp{refs/tags/} プレフィックスを除いて、指定された @samp{glob(7)} パターンに一致するタグを対象にしません。
@end itemize

@item  @samp{%S} 
(@samp{git log --source} のような、)コマンドラインで指定した、コミットに到達したref名で、 @samp{git log} でのみ機能します。

@item  @samp{%e} 
エンコーディング

@item  @samp{%s} 
件名(subject)

@item  @samp{%f} 
ファイル名に適した、サニタイズされた件名

@item  @samp{%b} 
本文(body)

@item  @samp{%B} 
生本文(raw body)(行折り曲げされてない件名と本文)

@item  @samp{%N} 
コミットノート(commit notes)

@item  @samp{%GG} 
署名されたコミットの為のGPGからの生の検証メッセージ

@item  @samp{%G?} 
@table @asis

@item  G 
良い(good)な(有効な)署名の場合はこの文字に置換されます。

@item  B 
悪い署名(bad signature)の場合はこの文字に置換されます。

@item  U 
有効性が不明(unknown validity)な良い署名の場合はこの文字に置換されます。

@item  X 
期限切れ(eXpired)の良い署名の場合はこの文字に置換されます。

@item  Y 
期限切れのキーで作成された良い署名の場合はこの文字に置換されます。

@item  R 
取り消されたキーによって作成された良い署名の場合はこの文字に置換されます。

@item  E 
署名を確認できない場合(キーの欠落など)の場合はこの文字に置換されます。

@item  N 
署名がない場合の場合はこの文字に置換されます。
@end table

@item  @samp{%GS} 
署名されたコミットの署名者の名前を表示する

@item  @samp{%GK} 
署名されたコミットに署名するために使用されるキーを表示する

@item  @samp{%GF} 
署名されたコミットに署名するために使用されるキーのフィンガープリントを表示する

@item  @samp{%GP} 
署名付きコミットの署名に使用されたサブキー(subkey)の主キー(primary key)のフィンガープリントを表示します

@item  @samp{%GT} 
署名されたコミットに署名するために使用されるキーの信頼レベル(trust level)を表示します

@item  @samp{%gD} 
reflog セレクター(例えば @samp{refs/stash@@@{1@}} とか @samp{refs/stash@@@{2 minutes ago@}})。 この形式は、 @samp{-g} オプションで説明されている規則に従います。 @samp{@@} の前の部分は、コマンドラインで指定されたrefnameです(したがって、 @samp{git log -g refs/heads/master} は @samp{refs/heads/master@@@{0@}} を生成します)。

@item  @samp{%gd} 
短縮 reflog セレクター。 @samp{%gD} と同一ですが、人間が読みやすい形式でrefname部分が短縮されています(したがって、 @samp{refs/heads/master} は単に @samp{master} になります)。

@item  @samp{%gn} 
reflog ID名

@item  @samp{%gN} 
reflog ID名( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%ge} 
reflog ID 電子メールアドレス

@item  @samp{%gE} 
reflog ID 電子メールアドレス( .mailmap に関しては、git-shortlog(1) または git-blame(1) 参照)

@item  @samp{%gs} 
reflog 件名

@item  @samp{%(trailers[:options])} 
git-interpret-trailers(1) によって解釈されるようにボディのトレーラーを表示します。 @samp{trailers} 文字列の後には、コロンと、0個以上のカンマで区切られたオプションを続けることができます。いずれかのオプションが複数回提供された場合、それぞれ最後のものが優先されます。

@itemize 

@item
@samp{key=<key>}: 指定された <key> を持つトレーラーのみを表示します。マッチングは大文字と小文字を区別せずに行われ、末尾のコロンはオプションです。オプションが複数回指定されている場合、いずれかのキーに一致するトレーラー行が表示されます。このオプションは自動的に @samp{only} オプションを有効にして、トレーラーブロック内の非トレーラー行が非表示になるようにします。それが望ましくない場合は、 @samp{only=false} で無効にすることができます。 たとえば、 @samp{%(trailers:key=Reviewed-by)} は、キーが `Reviewed-by`のトレーラー行を表示します。

@item
@samp{only[=<bool>]}: トレーラーブロックに非トレーラー行を含めるかどうかを選択します。

@item
@samp{separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラー行は改行文字で終了します。文字列 <sep> には、上記のリテラルフォーマットコードが含まれる場合があります。区切り文字としてコンマを使用するには、次のオプションとして解析されないよう @samp{%x2C} を使用する必要があります。 たとえば、 @samp{%(trailers:key=Ticket,separator=%x2C )} は、キーが @samp{Ticket} であるすべてのトレーラー行をカンマとスペースで区切って表示します。

@item
@samp{unfold[=<bool>]}: interpret-trailer の @samp{--unfold} オプションが指定されたかのように動作させます。たとえば、 @samp{%(trailers:only,unfold=true)} が展開され、すべてのトレーラー行が表示されます。

@item
@samp{keyonly[=<bool>]}: トレーラーのキー部分のみを表示。

@item
@samp{valueonly[=<bool>]}: トレーラーの値部分のみ表示。

@item
@samp{key_value_separator=<sep>}: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラーのキーと値のペアは ": " で区切られます。 それ以外の場合は、上記の @samp{separator=<sep>} と同じセマンティクスを共有します。
@end itemize
@end table
@end itemize
@end itemize

@quotation

@strong{Note}

一部のプレースホルダーは、リビジョントラバーサルエンジンに指定された他のオプションに依存する場合があります。 たとえば、 @samp{%g*} reflogオプションは、reflogエントリをトラバースしない限り(たとえば、 @samp{git log -g} によって)空の文字列を挿入します。コマンドラインで @samp{--decorate} がまだ指定されていない場合、 @samp{%d} と @samp{%D} プレースホルダーは「短い」(short)装飾形式を使用します。
@end quotation

ブール値オプションは、オプションの値 @samp{[=<bool-value>]} を受け入れます。 値 @samp{true} 、@samp{false} 、 @samp{on} 、@samp{off} などはすべて受け入れられます。 git-config(1) の "EXAMPLES" の "boolean" サブセクションを参照してください。ブール値オプションが値なしで指定された場合、それは有効を指定した事になります。

プレースホルダーの @samp{%} の後に @samp{+} (プラス記号)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。

プレースホルダーの @samp{%} の後に @samp{-} (マイナス記号)を追加すると、プレースホルダーが空の文字列に展開された場合にのみ、展開の直前の連続するすべての改行が削除されます。

プレースホルダーの @samp{%} の後に " " (スペース)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前にスペースが挿入されます。

@itemize 

@item
@samp{tformat:}

@samp{tformat:} 形式は、 "separator" セマンティクスの代わりに "terminator" セマンティクスを提供することを除いて、 @samp{format:} とまったく同じように機能します。 つまり、各コミットには、エントリ間に区切り文字を配置するのではなく、メッセージターミネータ文字(通常は改行)が追加されます。 これは、「1行」形式と同様に、1行形式の最終エントリが新しい行で適切に終了することを意味します。 例えば以下のようになります:

@example
$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973
@end example


加えて、 @samp{%} が含まれている認識されない文字列は、その前に @samp{tformat:} があるかのように解釈(interpret)されます。 たとえば、以下の2つは同等です:

@example
$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef
@end example

@end itemize

@noindent

@chapheading DIFF FORMATTING

以下のオプションを使用して、 @samp{git show} がdiff出力を生成する方法を変更できます。

@table @asis

@item  @samp{-p} 
@itemx  @samp{-u} 
@itemx  @samp{--patch} 
Generate patch (see section titled
"Generating patch text with -p" (@pxref{Generating patch text with -p})).

@item  @samp{-s} 
@itemx  @samp{--no-patch} 
Suppress all output from the diff machinery. Useful for commands like @samp{git show} that show the patch by default to squelch their output, or to cancel the effect of options like @samp{--patch}, @samp{--stat} earlier on the command line in an alias.

@item  @samp{--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)} 
@itemx  @samp{--no-diff-merges} 
マージコミットに使用するdiff形式を指定します。 @samp{--first-parent} が使用されている場合を除き、デフォルトは @samp{dense-combined} です。使用されている場合は、 @samp{first-parent} がデフォルトです。

@table @asis

@item  @samp{--diff-merges=(off|none)} 
@itemx  @samp{--no-diff-merges} 
マージコミットのdiffの出力を無効にします。暗黙の値を上書きするのに便利です。

@item  @samp{--diff-merges=on} 
@itemx  @samp{--diff-merges=m} 
@itemx  @samp{-m} 
このオプションにより、マージコミットのdiff出力がデフォルトの形式で表示されます。 @samp{-m} は、 @samp{-p} も指定されている場合にのみ出力を生成します。デフォルトの形式は、 @samp{log.diffMerges} 構成パラメーター(configuration parameter)を使用して変更できます。デフォルト値は @samp{separate} です。

@item  @samp{--diff-merges=first-parent} 
@itemx  @samp{--diff-merges=1} 
このオプションにより、マージコミットは最初の親に関してのみ完全なdiffを表示します。

@item  @samp{--diff-merges=separate} 
これにより、マージコミットは各親に関して完全なdiffを表示します。親ごとに個別のログエントリとdiffが生成されます。

@item  @samp{--diff-merges=remerge} 
@itemx  @samp{--diff-merges=r} 
@itemx  @samp{--remerge-diff} 
このオプションを使用すると、2 つの親マージ・コミットが再マージされて、一時的なツリー・オブジェクトが作成されます。 — これには、競合マーカーなどを含むファイルが含まれる可能性があります。 次に、その一時ツリーと実際のマージ・コミットの間の差分が表示されます。

このオプションが使用されたときの出力は変更される可能性があり、他のオプションとの相互作用も変更される可能性があります (明示的に文書化されていない限り)。

@item  @samp{--diff-merges=combined} 
@itemx  @samp{--diff-merges=c} 
@itemx  @samp{-c} 
このオプションを使用すると、マージコミットのdiff出力は、親と結果のペアごとの差分を一度に1つずつ表示するのではなく、各親からの差分をマージ結果に同時に表示します。さらに、すべての親から変更されたファイルのみが一覧表示されます。 @samp{-c} は @samp{-p} の機能を含んでいます。

@item  @samp{--diff-merges=dense-combined} 
@itemx  @samp{--diff-merges=cc} 
@itemx  @samp{--cc} 
このオプションを使用すると、 @samp{--diff-merges=Combined} によって生成される出力は、親のコンテンツに2つの派生(variants)しかない、興味のないハンクを省略してさらに圧縮され、マージ結果は変更なしでそのうちの1つを選択します。 @samp{--cc} は @samp{-p} の機能を含んでいます。
@end table

@item  @samp{--combined-all-paths} 
このフラグにより、結合された差分(マージコミットに使用)にすべての親からのファイルの名前が一覧表示されます。したがって、これは @samp{--diff-merges=[dense-]combined} が使用されている場合にのみ有効であり、ファイル名の変更が検出された場合(つまり、名前の変更またはコピーの検出が要求された場合)にのみ役立つ可能性があります。

@item  @samp{-U<n>} 
@itemx  @samp{--unified=<n>} 
通常の3行ではなく、<n> 行の内容でdiffを生成します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--output=<file>} 
stdout ではなく指定のファイルに出力します。

@item  @samp{--output-indicator-new=<char>} 
@itemx  @samp{--output-indicator-old=<char>} 
@itemx  @samp{--output-indicator-context=<char>} 
生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。 通常、それらはそれぞれ "+"、 "-"、 " " です。

@item  @samp{--raw} 
コミットごとに、生の差分形式を使用して変更の概要を表示します。
git-diff(1) の "RAW OUTPUT FORMAT" セクションを参照してください。
これは、ログ自体をraw形式で表示することとは異なります。
これは @samp{--format=raw} で
実現できます。

@item  @samp{--patch-with-raw} 
@samp{-p --raw} の同義語。

@item  @samp{-t} 
diff出力にツリーオブジェクトを表示します。

@item  @samp{--indent-heuristic} 
diffハンクの境界をずらす(shift)ヒューリスティックを有効にして、パッチを読みやすくします。 これがデフォルトです。

@item  @samp{--no-indent-heuristic} 
インデントヒューリスティック(indent heuristic)を無効にします。

@item  @samp{--minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{--patience} 
"patience diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--histogram} 
"histogram diff" アルゴリズムを使用してdiffを生成します。

@item  @samp{--anchored=<text>} 
"anchored diff" アルゴリズムを使用してdiffを生成します。

このオプションは複数回指定できます。

行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で "patience diff" アルゴリズムを使用します。

@item  @samp{--diff-algorithm=@{patience|minimal|histogram|myers@}} 
diffアルゴリズムを選択します。その派生(variants)は以下のとおりです:

@table @asis

@item  @samp{default}, @samp{myers} 
基本的な貪欲な差分アルゴリズム(greedy diff algorithm)。現在、これがデフォルトです。

@item  @samp{minimal} 
より多くの時間を費やして、可能な限り最小のdiffが生成されるようにします。

@item  @samp{patience} 
パッチを生成する時に "patience diff" アルゴリズムを使います。

@item  @samp{histogram} 
このアルゴリズムは、忍耐アルゴリズム(patience algorithm)を拡張して、「発生率の低い共通要素をサポート」(support low-occurrence common elements)します。
@end table

たとえば、 あなたが @samp{diff.algorithm} 変数をデフォルト以外の値に設定した上で、それでもデフォルト値を使用する場合は、@samp{--diff-algorithm=default} オプションを使用する必要があります。

@item  @samp{--stat[=<width>[,<name-width>[,<count>]]]} 
diffstatを生成します。 デフォルトでは、必要なだけのスペースがファイル名部分に使用され、残りはグラフ部分に使用されます。最大幅はデフォルトで端末幅、または端末に接続されていない場合は80桁であり、 @samp{<width>} で上書きできます。ファイル名部分の幅は、コンマの後に別の幅 @samp{<name-width>} を指定することで制限できます。グラフ部分の幅は、 @samp{--stat-graph-width=<width>} (統計グラフを生成するすべてのコマンドに影響します)を使用するか、 @samp{diff.statGraphWidth=<width>} ( @samp{git format-patch} に影響しません)を設定することによって制限できます。3番目のパラメータ @samp{<count>} を指定することにより、出力を最初の @samp{<count>} 行に制限し、それに @samp{...} が続く形にできます。

これらのパラメータは、 @samp{--stat-width=<width>} と @samp{--stat-name-width=<name-width>} と @samp{--stat-count=<count>} を使用して個別に設定することもできます。

@item  @samp{--compact-summary} 
ファイルの作成や削除( "new" または "gone" 。オプションでシンボリックリンクの場合は "+l" )、diffstatのモード変更(実行可能ビットを追加または削除する場合は、それぞれ "+x" または "-x" )など、拡張ヘッダー情報の要約を出力します。情報はファイル名部分とグラフ部分の間に置かれます。本機能は @samp{--stat} の機能を含んでいます。

@item  @samp{--numstat} 
@samp{--stat} に似ていますが、プログラムで処理しやすい(machine friendly)ように、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、 @samp{0 0} の代わりに2つの @samp{-} を出力します。

@item  @samp{--shortstat} 
変更されたファイルの総数と、追加および削除された行の数を含む @samp{--stat} 形式の最後の行のみを出力します。

@item  @samp{-X[<param1,param2,...>]} 
@itemx  @samp{--dirstat[=<param1,param2,...>]} 
各サブディレクトリの相対的な変更量の分布を出力します。 @samp{--dirstat} の動作は、パラメータのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 @samp{diff.dirstat} 構成変数によって制御されます(git-config(1) 参照)。以下のパラメータを使用できます:

@table @asis

@item  @samp{changes} 
ソースから削除された、または宛先に追加された行をカウントして、dirstat数を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

@item  @samp{lines} 
通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat数を計算します。 (バイナリファイルの場合、バイナリファイルには行の概念がないため、代わりに64バイトのチャンクをカウントします)。 これは @samp{changes} 動作よりも高価な @samp{--dirstat} 動作ですが、他の変更と同じようにファイル内の再配置された行をカウントします。結果の出力は、他の @samp{--*stat} オプションから得られるものと一致しています。

@item  @samp{files} 
変更されたファイルの数を数えて、dirstat数を計算します。変更された各ファイルは、dirstat分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算コストが最もかからない @samp{--dirstat} の動作です。

@item  @samp{cumulative} 
親ディレクトリの子ディレクトリの変更も同様にカウントします。 @samp{cumulative}(累積的) を使用する場合、報告されるパーセンテージの合計が100%を超える場合があることに注意してください。デフォルトの(非累積的な)動作は、@samp{noncumulative} パラメーターで指定できます。

@item  <limit> 
整数パラメーターは、カットオフパーセント(デフォルトでは3%)を指定します。指定の割合より少ないディレクトリは、出力に表示されません。
@end table

例: 変更されたファイルの総数の10%未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウント: @samp{--dirstat=files,10,cumulative}

@item  @samp{--cumulative} 
@samp{--dirstat=cumulative} と同義語

@item  @samp{--dirstat-by-file[=<param1,param2>...]} 
@samp{--dirstat=files,param1,param2...} と同義語

@item  @samp{--summary} 
作成、名前変更、モード変更などの拡張ヘッダー情報の短い要約(condensed summary)を出力します。

@item  @samp{--patch-with-stat} 
@samp{-p --stat} と同義語。

@item  @samp{-z} 
改行(newline)ではなく、NULでコミットを区切ります。

また、 @samp{--raw} または @samp{--numstat} を指定した場合は、パス名を難読化(munge)したり、出力フィールドターミネータとしてNULを使用したりしないでください。

このオプションがないと、構成変数 @samp{core.quotePath} で説明されているように、 通常の文字以外(unusual characters)を含むパス名が引用符で囲まれます(git-config(1) 参照)。

@item  @samp{--name-only} 
変更されたファイルの名前のみを表示します。 多くの場合、ファイル名はUTF-8でエンコードされます。 詳細については、 git-log(1) のマニュアルページにあるエンコーディングに関する議論(the discussion about encoding)を参照してください。

@item  @samp{--name-status} 
変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、 @samp{--diff-filter} オプションの説明を参照してください。 @samp{--name-only} と同じように、ファイル名はしばしばUTF-8でエンコードされます。

@item  @samp{--submodule[=<format>]} 
サブモジュールの違いをどのように表示するかを指定します。 @samp{--submodule=short} を指定する場合、 short形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。 @samp{--submodule} または @samp{--submodule=log} が指定されている場合、 log形式が使用されます。この形式では、 git-submodule(1) @samp{summary} のように範囲内のコミットが一覧表示されます。 @samp{--submodule=diff} が指定されている場合、 diff形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインラインdiffを示します。configオプションが設定されていない場合、デフォルトは @samp{diff.submodule} または @samp{short} 形式です。

@item  @samp{--color[=<when>]} 
色付きのdiffを表示します。 @samp{--color} (つまり、 @samp{=<when>} 無し) は @samp{--color=always} と同じです。 <when> は、 always または never または auto のいずれかになります。

@item  @samp{--no-color} 
カラーdiffをオフにします。
@samp{--color=never} と同じです。

@item  @samp{--color-moved[=<mode>]} 
ソースコードの移動した行を別の色にします。
<mode>は、オプションが指定されていない場合はデフォルトで no になり、
モードが指定されていないオプションが指定されている場合は zebra になります。
モードは以下のいずれかでなければなりません:

@table @asis

@item  no 
移動行をハイライトしません。

@item  default 
zebra の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

@item  plain 
ある場所で追加され、別の場所で削除された行は、 @samp{color.diff.newMoved} で色付けされます。 同様に、 @samp{color.diff.oldMoved} は、差分の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

@item  blocks 
少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、 @samp{color.diff.@{old,new@}Moved} 色のいずれかを使用して色付けされます。隣接するブロックを区別することはできません。

@item  zebra 
移動されたテキストのブロックは、 @samp{blocks} モードの場合と同様に検出されます。 ブロックは、 @samp{color.diff.@{old,new@}Moved} 色または @samp{color.diff.@{old,new@}MovedAlternative} 色のいずれかを使用して色付けされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

@item  dimmed-zebra 
@samp{zebra} に似ていますが、移動されたコードの重要でない部分の追加の調光(dimmed)が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。 @samp{dimmed_zebra} は非推奨の同義語です。
@end table

@item  @samp{--no-color-moved} 
移動検出をオフにします。 これは、構成設定を上書きするために使用できます。 @samp{--color-moved=no} と同じです。

@item  @samp{--color-moved-ws=<modes>} 
これは、 @samp{--color-moved} の移動検出を実行するときに空白を無視する方法を設定します。
これらのモードは、コンマ区切りのリストとして指定できます:

@table @asis

@item  no 
移動行検出を実行するときに、空白(whitespace)を無視しない。

@item  ignore-space-at-eol 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  ignore-space-change 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  ignore-all-space 
行を比較するときは空白(whitespace)を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  allow-indentation-change 
最初に移動検出で空白(whitespace)を無視し、空白(whitespace)の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。 これは他のモードと互換性がありません。
@end table

@item  @samp{--no-color-moved-ws} 
移動検出を実行するときは、空白(whitespace)を無視しないでください。これは、構成設定を上書きするために使用できます。 @samp{--color-moved-ws=no} と同じです。

@item  @samp{--word-diff[=<mode>]} 
<mode> を使用して変更された単語を区切ることにより、単語のdiffを表示します。デフォルトでは、単語は空白で区切られます。 以下の @samp{--word-diff-regex} を参照してください。 <mode> のデフォルトは @samp{plain} です。 <mode> は以下のいずれかである必要があります:

@table @asis

@item  color 
変更された単語(word)を色のみを使用して強調表示します。 @samp{--color} を意味します。

@item  plain 
単語を @samp{[-removed-]} および @samp{@{+added+@}} として表示します。 区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

@item  porcelain 
スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/無変更については、通常の統一されたdiff形式で印刷され、行の先頭の @samp{+}/@samp{-}/` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ @samp{~} で表されます。

@item  none 
単語(word)のdiffを再度無効にします。
@end table

注意: 最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

@item  @samp{--word-diff-regex=<regex>} 
空白以外を単語と見なす代わりに、 <regex> を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、この機能は @samp{--word-diff} の機能を含んでいます。

<regex> の重複しないマッチはすべて、単語と見なされます。これらのマッチの間のすべては空白と見なされ、違いを見つけるためとしては無視されます！ 正規表現に @samp{|[^[:space:]]} を追加して、空白以外のすべての文字とマッチすることを確認することをお勧めします。改行を含むマッチは、改行で黙って切り捨てられます！

たとえば、 @samp{--word-diff-regex=.} は各文字を単語として扱い、それに応じて文字ごとの違いを表示します。

正規表現は、diffドライバーまたは構成オプション(configuration option)を介して設定することもできます。 gitattributes(5) または git-config(1) を参照してください。これを指定すると、diffドライバーまたは構成設定(configuration settings)が明示的にオーバーライドされます。diffドライバーは構成設定を上書きします。

@item  @samp{--color-words[=<regex>]} 
@samp{--word-diff=color} に @samp{--word-diff-regex=<regex>} を加えたものに相当します(正規表現が指定されている場合)。

@item  @samp{--no-renames} 
構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

@item  @samp{--[no-]rename-empty} 
名前変更ソースとして空のブロブを使用するかどうか。

@item  @samp{--check} 
変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 @samp{core.whitespace} 構成によって制御されます。 デフォルトでは、末尾の空白(空白のみで構成される行を含む)と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。なお、 --exit-code とは互換性がありません。

@item  @samp{--ws-error-highlight=<kind>} 
diffの @samp{context} または @samp{old} または @samp{new} 行の空白エラーを強調表示します。複数の値はコンマで区切られ、 @samp{none} は前の値をリセットし、 @samp{default} はリストを @samp{new} にリセットし、 @samp{all} は old、new、context の省略形です。このオプションが指定されておらず、構成変数 @samp{diff.wsErrorHighlight} が設定されていない場合、 @samp{new} 行の空白エラーのみが強調表示されます。空白エラーは @samp{color.diff.whitespace} で色分けされています。

@item  @samp{--full-index} 
パッチ形式の出力を生成するときは、最初の一握りの文字(first handful of characters)の代わりに、「インデックス」行にイメージ前およびイメージ後の完全ブロブオブジェクト名を表示します。

@item  @samp{--binary} 
@samp{--full-index} に加えて、 @samp{git-apply} で適用できるバイナリ差分を出力します。
@samp{--patch} の機能を含んでいます。

@item  @samp{--abbrev[=<n>]} 
完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも <n> 桁の16進数の長さの最短のプレフィックスを表示します。diffパッチ出力形式では、 @samp{--full-index} が優先されます。つまり、 @samp{--full-index} が指定されている場合、 @samp{--abbrev} に関係なく、完全なブロブ名が表示されます。デフォルト以外の桁数は、 @samp{--abbrev=<n>} で指定できます。

@item  @samp{-B[<n>][/<m>]} 
@itemx  @samp{--break-rewrites[=[<n>][/<m>]]} 
完全な書き換えの変更を削除と作成のペアに分割します。これには以下の2つの目的があります:

これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続く すべての新しいものを1回挿入し、数値 @samp{m} が -B オプションのこの側面を制御します(デフォルトは60%)。 @samp{-B/70%} は、Gitがそれを完全な書き換えと見なすために、元の30%未満が結果に残る必要があることを指定します(つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります)。

-M と一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ(通常、 -M は、消えたファイルのみを名前変更のソースと見なします)、数 @samp{n} が -Bオプションのこの側面を制御します(デフォルトは50%)。 @samp{-B20%} は、ファイルのサイズの20%以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

@item  @samp{-M[<n>]} 
@itemx  @samp{--find-renames[=<n>]} 
diffを生成する場合は、コミットごとに名前の変更を検出して報告します。
履歴をトラバースしながら名前を変更してファイルをフォローする方法については、
@samp{--follow} を参照してください。
@samp{n} が指定されている場合、それは類似性インデックスのしきい値です
(つまり、ファイルのサイズと比較した追加/削除の量)。
たとえば、 @samp{-M90%} は、ファイルの90%以上が変更されていない場合、
Gitが削除/追加のペアを名前変更と見なす必要があることを意味します。
@samp{%} 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。
つまり、 @samp{-M5} は0.5になるため、@samp{-M50%} と同じになります。
同様に、 @samp{-M05} は @samp{-M5%} と同じです。
検出を正確な名前変更に制限するには、 @samp{-M100%} を使用します。
デフォルトの類似性インデックスは50%です。

@item  @samp{-C[<n>]} 
@itemx  @samp{--find-copies[=<n>]} 
名前と同様コピーを検出します。 @samp{--find-copies-harder} @samp{も参照してください。 `n} を指定すると、 @samp{-M<n>} と同じ意味になります。

@item  @samp{--find-copies-harder} 
パフォーマンス上の理由から、デフォルトでは、 @samp{-C} オプションは、コピーの元のファイルが同じ変更組(changeset)で変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。 複数の @samp{-C} オプションを指定しても同じ効果があります。

@item  @samp{-D} 
@itemx  @samp{--irreversible-delete} 
削除するプレイメージ(preimage)を省略します。つまり、ヘッダーのみを出力し、プレイメージと @samp{/dev/null} の差分は出力しません。結果のパッチは、 @samp{patch} または @samp{git apply} で適用されることを意図していません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

@samp{-B} と併用する場合は、削除/作成ペアの削除部分のプリイメージ(preimage)も省略してください。

@item  @samp{-l<num>} 
@samp{-M} および @samp{-C} オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。(名前の変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します)。Nのソースと宛先の場合、この徹底的なチェックのコストは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは diff.renameLimit です。 値0は無制限として扱われることに注意してください。

@item  @samp{--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]} 
追加(Add)・コピー(Copy)・削除(Delete)・変更(Modify)・名前変更(Rename)されたファイル、タイプが変更されたファイル(T)、マージされていないファイル(U)、不明なファイル(X)、またはペアリングが壊れているファイル(B)のみを選択します。フィルタ文字(無しも含む)の任意の組み合わせを使用できます。 組み合わせに @samp{*} (全てまたは無し)が追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。 他の基準に一致するファイルがない場合、何も選択されません。

また、逆に、除外したい時はこれらの各大文字指定を小文字にして指定します。例えば @samp{--diff-filter=ad} は、追加および削除されたパスを除外します。

注意:すべてのdiffがすべてのタイプを特徴とするわけではないことに注意してください。 たとえば、これらのタイプの検出(detection)が無効になっている場合、コピーされたエントリと名前変更されたエントリは表示されません。

@item  @samp{-S<string>} 
ファイル内の指定の文字列(つまり、 addition 、deletion)の出現回数の差分を調べます。スクリプターが使用することを目的としています。

(構造体など)コードの正確なブロックを探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ(preimage)内の興味深いブロックを @samp{-S} にフィードバックし、そしてあなたはそれをブロックの最初のバージョンを取得するまで続けます。

バイナリファイルも検索されます。

@item  @samp{-G<regex>} 
パッチテキストに <regex> にマッチする 追加/削除 された行が含まれている差分を探します。

@samp{-S<regex> --pickaxe-regex} と @samp{-G<regex>} の違いを説明するために、同じファイル内で以下のdiffを使用してコミットすることを検討してください:

@example
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
@end example


@samp{git log -G"frotz\(nitfol"} はこのコミットを表示しますが、 @samp{git log -S"frotz\(nitfol" --pickaxe-regex} は表示しません(その文字列の出現回数が変更されなかったため)。

@samp{--text} が提供されていない限り、 textconv フィルターのないバイナリファイルのパッチは無視されます。

詳細については gitdiffcore(7) の「pickaxe」エントリを参照してください。

@item  @samp{--find-object=<object-id>} 
指定されたオブジェクトの出現回数を変更する違いを探します。 @samp{-S} と同様に、引数だけが異なり、特定の文字列ではなく特定のオブジェクトIDを検索します。

オブジェクトは、ブロブまたはサブモジュールのコミットにすることができます。 これは、 @samp{git-log} の @samp{-t} オプションがツリーも探すことを意味します。

@item  @samp{--pickaxe-all} 
@samp{-S} または @samp{-G} が変更を見つけたら、 <string> の変更を含むファイルだけでなく、その変更セット(changeset)のすべての変更を表示します。

@item  @samp{--pickaxe-regex} 
@samp{-S} に指定した <string> を拡張POSIX正規表現として扱います。

@item  @samp{-O<orderfile>} 
ファイルが出力に表示される順序を制御します。これは @samp{diff.orderFile} 構成変数をオーバーライドします(git-config(1) 参照)。 @samp{diff.orderFile} をキャンセルするには、 @samp{-O/dev/null} を使用します。

出力順序は、 <orderfile> 内のglobパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する(ただし最初のパターンには一致しない)パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合(同じパターンに一致するが、以前のパターンには一致しない)、相互の出力順序は通常の順序です。

<orderfile> は以下のとおりパースされます:

@itemize 

@item
空白行は無視されるため、読みやすくするための区切りとして使用できます。

@item
ハッシュ ("@samp{#}") で始まる行は無視されるため、コメントに使用できます。 パターンがハッシュで始まる場合は、パターンの先頭にバックスラッシュ(訳注:日本では環境により円記号)("@samp{\}") を追加します。

@item
他の各行には、単一のパターンが含まれています。
@end itemize

パターンは、 FNM_PATHNAME フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。 たとえば、パターン "@samp{foo*bar}" は、 "@samp{fooasdfbar}" および "@samp{foo/bar/baz/asdf}" と一致しますが、 "@samp{foobarx}" とは一致しません。

@item  @samp{--skip-to=<file>} 
@itemx  @samp{--rotate-to=<file>} 
名前付き <file> の前のファイルを出力から破棄するか(スキップして)、出力の最後に移動させます(ローテーションさせます)。 これらは主に @samp{git difftool} コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

@item  @samp{-R} 
2つの入力を交換します。 つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを表示します。

@item  @samp{--relative[=<path>]} 
@itemx  @samp{--no-relative} 
プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ(ベアリポジトリなど)にいない場合は、引数として <path> を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 @samp{--no-relative`は、 `diff.relative} 設定オプションと以前の @samp{--relative} の両方を打ち消すために使用できます。

@item  @samp{-a} 
@itemx  @samp{--text} 
すべてのファイルをテキストとして扱います。

@item  @samp{--ignore-cr-at-eol} 
比較を行うときは、行末のキャリッジリターン(carriage-return)を無視します。

@item  @samp{--ignore-space-at-eol} 
行末(EOL)での空白(whitespace)の変更を無視します。

@item  @samp{-b} 
@itemx  @samp{--ignore-space-change} 
空白(whitespace)の数の変更は無視してください。これは、行末の空白(whitespace)を無視し、1つ以上の空白文字(whitespace characters)の他のすべてのシーケンスを同等と見なします。

@item  @samp{-w} 
@itemx  @samp{--ignore-all-space} 
行を比較するときは空白を無視します。 これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

@item  @samp{--ignore-blank-lines} 
全て空白の行の変更は無視します。

@item  @samp{-I<regex>} 
@itemx  @samp{--ignore-matching-lines=<regex>} 
すべての行が <regex> にマッチする変更を無視します。このオプションは複数回指定できます。

@item  @samp{--inter-hunk-context=<lines>} 
指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは @samp{diff.interHunkContext} で、設定オプションが設定されていない場合は0です。

@item  @samp{-W} 
@itemx  @samp{--function-context} 
関数全体を各変更のコンテキスト行として表示します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  @samp{--ext-diff} 
外部diffヘルパーの実行を許可します。 gitattributes(5) を使用して外部diffドライバーを設定する場合は、 git-log(1) およびその仲間と一緒にこのオプションを使用する必要があります。

@item  @samp{--no-ext-diff} 
外部diffドライバーを禁止します。

@item  @samp{--textconv} 
@itemx  @samp{--no-textconv} 
バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可(または禁止)します。 詳細については、 gitattributes(5) を参照してください。textconvフィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用(apply)することはできません。このため、textconvフィルターは、 git-diff(1) および git-log(1) に対してのみデフォルトで有効になりますが、 git-format-patch(1) またはdiff配管コマンドに対しては有効になりません。

@item  @samp{--ignore-submodules[=<when>]} 
diff生成のサブモジュールへの変更を無視します。 <when> は、 none・untracked・dirty・allのいずれかになります。これがデフォルトです。noneを使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の ignoreオプションの設定をオーバーライドするために使用できます。untrackedが使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0までの動作でした)。「all」を使用すると、サブモジュールへのすべての変更が非表示になります。

@item  @samp{--src-prefix=<prefix>} 
"a/" の代わりに、与えられたソースプレフィックス(source prefix)を表示します。

@item  @samp{--dst-prefix=<prefix>} 
"b/" の代わりに、指定された宛先プレフィックス(destination prefix)を表示します。

@item  @samp{--no-prefix} 
送信元(source)または宛先(destination)のプレフィックスを表示しません。

@item  @samp{--default-prefix} 
Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as @samp{diff.noprefix}.

@item  @samp{--line-prefix=<prefix>} 
出力のすべての行に追加のプレフィックスを付加します。

@item  @samp{--ita-invisible-in-index} 
デフォルトでは、 "git add -N" によって追加されたエントリは、 "git diff" に既存の空のファイルとして表示され、 "git diff --cached" に新しいファイルとして表示されます。このオプションを使用すると、エントリは "git diff" では新しいファイルとして表示され、 "git diff --cached" では存在しません。このオプションは、 @samp{--ita-visible-in-index} で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。
@end table

これらの一般的なオプションの詳細については、 gitdiffcore(7) も参照してください。

@noindent

@chapheading Generating patch text with -p

git-diff(1) 、 git-log(1) 、 git-show(1) 、 git-diff-index(1) 、 git-diff-tree(1) 、 git-diff-files(1) に @samp{-p} オプションを付けて実行するとパッチテキストを生成します。パッチテキストの作成は、 @samp{GIT_EXTERNAL_DIFF} と @samp{GIT_DIFF_OPTS} 環境変数( git(1) 参照)、および @samp{diff} 属性( gitattributes(5) 参照)を介してカスタマイズできます。

-pオプションが生成するものは、従来のdiff形式とは少々異なります:

@enumerate 

@item
先行して、以下のような "git diff" ヘッダーがあります:

@example
diff --git a/file1 b/file2
@end example

名前の変更/コピーが含まれない限り、 @samp{a/} と @samp{b/} のファイル名は同じです。 特に、作成または削除の場合でも、 @samp{a/} または @samp{b/} ファイル名の代わりに @samp{/dev/ null} が使用されることはありません。

名前変更/コピーが含まれる場合、 @samp{file1} と`file2` は、それぞれ名前変更/コピーのソースファイルの名前と、名前変更/コピーが生成するファイルの名前を示します。

@item
その後に、1つ以上の拡張ヘッダー行達が続きます:

@example
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy to <path>
rename from <path>
rename to <path>
similarity index <number>
dissimilarity index <number>
index <hash>..<hash> <mode>
@end example

ファイルモードは、ファイルタイプとファイル許可ビットを含む6桁の8進数として出力されます。

拡張ヘッダーのパス名には、 @samp{a/} および @samp{b/} プレフィックスは含まれません。

類似インデックス(similarity index)は変更されていない行のパーセンテージであり、非類似インデックス(dissimilarity index)は変更された行のパーセンテージです。これは切り捨てられた整数であり、その後にパーセント記号が続きます。したがって、100％の類似インデックス値は2つの等しいファイルを表し、100％の非類似性は古いファイルから新しいファイルに移行された行がないことを意味します。

インデックス行には、変更前後のブロブオブジェクト名が含まれます。 <mode> は、ファイルモードが変更されない場合に含まれます。それ以外の場合、別々の行は古いモードと新しいモードを示します。

@item
通常の文字でないキャラクタ(\"unusual\" characters)を含むパス名は、構成変数 @samp{core.quotePath} で説明されているように引用符で囲まれています( git-config(1)参照)。

@item
出力内のすべての @samp{file1} ファイルはコミット前のファイルを参照し、すべての @samp{file2} ファイルはコミット後のファイルを参照します。各変更を各ファイルに順番に適用するのは誤りです。たとえば、以下のパッチはaとbを交換します:

@example
diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a
@end example

@item
ハンクのヘッダーには、ハンクが適用される関数の名前が記載されています。特定の言語に合わせてこれを調整する方法の詳細については、 gitattributes(5) の "Defining a custom hunk-header" を参照してください。
@end enumerate

@noindent

@chapheading Combined diff format

diffを生成するコマンドは、マージを表示するときに @samp{-c} または @samp{--cc} オプションを使用して「合成diff」(combined diff)を生成できます。これは git-diff(1) または git-show(1) でのマージを表示するときのデフォルトの形式です。 注意: これらのコマンドのいずれかに適切な @samp{--diff-merges} オプションを指定して、特定の形式で差分を強制的に生成できることにも注意してください。

合成diff形式は以下のようになります:

@example
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@@@@ -98,20 -98,12 +98,20 @@@@@@
        return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  @}

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  @{
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) @{
                initialized = 1;
                for_each_ref(get_name);
@end example


@enumerate 

@item
まず "git diff" ヘッダーがあり、以下のようになります( @samp{-c} オプションが使用されている場合):

@example
diff --combined file
@end example

または、以下のようになります( @samp{--cc} オプションが使用されている場合):

@example
diff --cc file
@end example

@item
その後に1つ以上の拡張ヘッダー行が続きます(以下の例は、2つの親とのマージを示しています):

@example
index <hash>,<hash>..<hash>
mode <mode>,<mode>..<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
@end example

@samp{mode <mode>,<mode>..<mode>} 行は、<mode> の少なくとも1つが他の <mode> と異なる場合にのみ表示されます。検出されたコンテンツの移動(名前の変更とコピーの検出)に関する情報を含む拡張ヘッダーは、2つの <tree-ish> のdiffで機能するように設計されており、合成diff形式では使用されません。

@item
その後に2行の from-file/to-file ヘッダーが続きます

@example
--- a/file
+++ b/file
@end example

従来の統一diff形式の2行ヘッダーと同様に、 @samp{/dev/null} は、作成または削除されたファイルを通知するために使用されます。

ただし、 --combined-all-paths オプションが指定されている場合、2行の from-file/to-file の代わりに、 N+1 行の from-file/to-file ヘッダーが取得されます。ここで、 N はマージコミットの親の数です。

@example
--- a/file
--- a/file
--- a/file
+++ b/file
@end example

この拡張形式は、名前変更またはコピー検出がアクティブな場合に役立ち、別の親のファイルの元の名前を確認できます。

@item
チャンクヘッダーの形式が変更され、誤って @samp{patch-p1} にフィードされるのを防ぎます。合成差分形式は、マージコミットの変更を確認するために作成されたものであり、適用されることを意図したものではありません。この変更は、拡張された「インデックス」ヘッダーの変更に似ています:

@example
@@@@@@ <from-file-range> <from-file-range> <to-file-range> @@@@@@
@end example

合成diff形式のチャンクヘッダーには親の数+1の @samp{@@} 文字があります。
@end enumerate

従来の統一diff形式とは異なり、2つのファイルAとBが、 @samp{-} (マイナスはAに表示されますが、Bでは削除されます) または @samp{+} (プラスはAにはありませんが、Bには追加されます)、または @samp{" "}（スペースは変更なし) プレフィックスを持つ単一の列で表示される場合、この形式は2つ以上のファイル file1, file2,… を1つのファイルXと比較し、Xが各 fileN とどのように異なるかを示します。ファイルNごとに1つの列が出力行の前に追加され、Xの行が出力行とどのように異なるかを示します。

列Nの @samp{-} 文字は、その行が fileN に表示されているが、結果には表示されていないことを意味します。 列Nの @samp{+} 文字は、結果に行が表示され、 fileN にその行がないことを意味します(つまり、その親の観点から見て行が追加されたことを示す)。

上記の出力例では、関数のシグネチャが両方のファイルから見て変更されています(したがって、 file1 と file2 の両方から2つの @samp{-} が削除され、さらに @samp{++} が追加されたため、 file1 と file2 のどちらにも表示されません)。また、他の8行は file1 と同じですが、 file2 には表示されません(したがって、接頭辞として @samp{+} が付けられます)。

@samp{git diff-tree -c} で表示される場合、マージコミットの親をマージ結果と比較します(つまり、 file1..fileN が親です)。 @samp{git diff-files -c} で表示される場合、2つの未解決のマージ親を作業ツリーファイルと比較します(つまり、 file1 はステージ2、別名「私たちのバージョン」、 file2 はステージ3、別名「彼らのバージョン」です)。

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git show v1.0.0} 
タグ @samp{v1.0.0} と、タグが指すオブジェクトを表示します。

@item  @samp{git show v1.0.0^@{tree@}} 
タグ @samp{v1.0.0} が指すツリーを表示します。

@item  @samp{git show -s --format=%s v1.0.0^@{commit@}} 
タグ @samp{v1.0.0} が指すコミットの件名を表示します。

@item  @samp{git show next~10:Documentation/README} 
ブランチ @samp{next} の最後から10番目のコミットで最新であったファイル @samp{Documentation/README} の内容を表示します。

@item  @samp{git show master:Makefile master:t/Makefile} 
ブランチ @samp{master} の先頭にあるMakefileの内容を連結して表示します。
@end table

@noindent

@chapheading DISCUSSION

Gitは、ある程度までは文字エンコードに依存しません。

@itemize 

@item
ブロブオブジェクトの内容は、解釈されていないバイトのシーケンスです。コアレベルでのエンコーディング変換はありません。

@item
パス名はUTF-8正規化形式C(UTF-8 normalization form C)でエンコードされます。これは、ツリーオブジェクト、インデックスファイル、ref名、およびコマンドライン引数、環境変数、構成ファイル( @samp{.git/config} (git-config(1) 参照) と gitignore(5) と gitattributes(5) と gitmodules(5)) のパス名に適用されます。

コアレベルのGitは、パス名を単に非NULバイトのシーケンスとして扱い、パス名をエンコードする変換はありません(MacとWindowsを除く)。したがって、非ASCIIパス名の使用は、レガシー拡張ASCIIエンコーディングを使用するプラットフォームやファイルシステムでもほとんど機能します。ただし、そのようなシステムで作成されたリポジトリは、UTF-8ベースのシステム(Linux、Mac、Windowsなど)では正しく機能しません。その逆も同様です。さらに、多くのGitベースのツールは、パス名がUTF-8であると単純に想定しており、他のエンコーディングを正しく表示できません。

@item
コミットログメッセージは通常UTF-8でエンコードされますが、他の拡張ASCIIエンコードもサポートされています。これには、ISO-8859-x、CP125xなどが含まれますが、UTF-16/32、EBCDIC、およびCJKマルチバイトエンコーディング(GBK、Shift-JIS、Big5、EUC-x、CP9xxなど)は含まれません。
@end itemize

我々はコミットログメッセージをUTF-8でエンコードすることをお勧めしますが、コアとGit Porcelainはどちらも、プロジェクトでUTF-8を強制しないように設計されています。特定のプロジェクトのすべての参加者がレガシーエンコーディングを使用する方が便利だと感じた場合、Gitはそれを禁止しません。 ただし、覚えておくべきことがいくつかあります。

@enumerate 

@item
@samp{git commit} と @samp{git commit-tree} は、プロジェクトがレガシーエンコーディングを使用していることを明示的に指定しない限り、与えられたコミットログメッセージが有効なUTF-8文字列のように見えない場合に警告を発します。明示的に指定する方法は、以下のように、 @samp{.git/config} ファイルに @samp{i18n.commitEncoding} を含めることです。

@example
[i18n]
        commitEncoding = ISO-8859-1
@end example


上記の設定で作成されたコミットオブジェクトは、 @samp{encoding} ヘッダーに @samp{i18n.commitEncoding} の値を記録します。 これは、後でそれらを見る他の人々を助けるためです。このヘッダーがないということは、コミットログメッセージがUTF-8でエンコードされていることを意味します。

@item
@samp{git log} や @samp{git show} や @samp{git blame} とその仲間たちは、コミットオブジェクトの @samp{encoding} ヘッダーを見て、特に指定がない限り、ログメッセージをUTF-8に再コーディングしようとします。あなたは以下のように、 @samp{.git/config} ファイルの @samp{i18n.logOutputEncoding} を使用して目的の出力エンコーディングを指定できます。

@example
[i18n]
        logOutputEncoding = ISO-8859-1
@end example


この構成変数がない場合は、代わりに @samp{i18n.commitEncoding} の値が使用されます。
@end enumerate

UTF-8への再コーディングは必ずしも可逆的な操作ではないため、我々はコミットが行われたときにコミットログメッセージを再コーディングしないことを意図的に選択したことに注意してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-sparse-checkout,,,Top
@chapheading Name

git-sparse-checkout — あなたの作業ツリーを追跡ファイルのサブセットのために縮小します

@noindent

@chapheading Synopsis

@display
git sparse-checkout (init | list | set | add | reapply | disable | check-rules) [<options>]
@end display


@noindent

@chapheading DESCRIPTION

このコマンドは、すべての追跡ファイルが存在する状態から、それらのファイルのサブセットのみが存在する状態に作業ツリーを変更するスパース・チェックアウトを作成するために使用されます。 また、存在するファイルのサブセットを切り替えるか、または、元に戻してすべての追跡ファイルが作業コピーに存在するように戻すこともできます。

ファイルのサブセットは、コーン・モード(デフォルト)でディレクトリのリストを提供するか、非コーン・モードでパターンのリストを提供することによって選択されます。

スパース・チェックアウト中は、他の Git コマンドの動作が少し異なります。 たとえば、ブランチを切り替えても、スパース・チェックアウト・ディレクトリ外やスパース・チェックアウト・ディレクトリ外のパスは更新されず、 @samp{git commit -a} はスパース・チェックアウト・ディレクトリ外や/スパース・チェックアウト・パターン外のパスを削除済みとして記録しません。

警告: このコマンドは実験的なものです。 その動作、およびスパースチェックアウトの存在下での他のコマンドの動作は、将来変更される可能性があります。

@noindent

@chapheading COMMANDS

@table @asis

@item  list 
スパース・チェックアウト・ファイルにディレクトリ達またはパターン達を記述します。

@item  set 
必要なスパース・チェックアウト構成設定(@samp{core.sparseCheckout} と @samp{core.sparseCheckoutCone} と`index.sparse`)がまだ目的の値に設定されていない場合は有効にし、 @samp{set} サブコマンドに続く引数のリストからスパース・チェックアウト・ファイルに入力し、それにマッチするよう作業ディレクトリを更新します。

ワークツリー内のスパース・チェックアウト設定を調整しても、他のワークツリーのスパース・チェックアウト設定が変更されないようにするために、 @samp{set} サブコマンドは、ワークツリー固有の設定がまだ存在しない場合は、それを使用するようにあなたのリポジトリ設定をアップグレードします。 @samp{set} サブコマンドへの引数によって定義されたスパース性は、ワークツリー固有のスパース・チェックアウト・ファイル(worktree-specific sparse-checkout file)に格納されます。 詳細については、git-worktree(1) および git-config(1) の @samp{extensions.worktreeConfig} のドキュメントを参照してください。

@samp{--stdin} オプションを指定すると、ディレクトリ達またはパターン達は引数からではなく、改行で区切られたリストとして標準入力から読み込まれます。

デフォルトでは、入力リストはディレクトリのリストと見なされ、 @samp{git ls-tree -d --name-only} の出力と一致します。 これには、二重引用符(@samp{"})で始まるパス名を C スタイルのクォートされた文字列として解釈することが含まれます。 注意: 指定されたディレクトリの(任意の深さの)下にあるすべてのファイル、および指定されたディレクトリまたはその祖先のいずれかの兄弟であるファイルがスパース・チェックアウトに含まれることに注意してください(詳細については、下記「CONE PATTERN SET」を参照してください)。 以前はこれがデフォルトではなく、 @samp{--cone} を指定するか、@samp{core.sparseCheckoutCone} を有効にする必要がありました。

@samp{--no-cone} が渡されると、入力リストはパターンのリストと見なされます。 このモードでは、@samp{--sparse-index} などの一部のオプションが機能し無い等、多くの欠点があります。 下記「Non-cone Problems」セクションで説明されているように、使用はお勧めしません。

@samp{--[no-]sparse-index} オプションを使用して、 スパース・インデックスを使用します(デフォルトでは使用しません)。 スパース・インデックスは、 インデックスのサイズを縮小して、スパース・チェックアウトの定義により近づけます。 これにより、 @samp{git status} や @samp{git add} などのコマンドのパフォーマンスが大幅に向上します。 この機能はまだ実験段階です。 一部のコマンドは、機能に適切に統合されるまで、 スパース・インデックスを使用すると遅くなる可能性があります。

@quotation

@strong{Warning}

スパースインデックスを使用するには、外部ツールでは完全には理解できない方法でインデックスを変更する必要があります。 この互換性に問題がある場合は、 @samp{git sparse-checkout init --no-sparse-index} を実行して、インデックスがまばらにならないように書き換えます。 古いバージョンのGitは、スパースディレクトリエントリのインデックス拡張機能を理解せず、それが無効になるまでリポジトリとのやり取りに失敗する可能性があります。
@end quotation

@item  add 
スパース・チェックアウト・ファイルを更新して、 追加のディレクトリ(コーン・モードの場合)またはパターン(非コーン・モードの場合)を含めます。 デフォルトでは、これらのディレクトリまたはパターンはコマンドライン引数から読み取られますが、 @samp{--stdin} オプションを使用して stdin から読み取ることができます。

@item  reapply 
作業ツリーのパスにスパースパターンルールを再適用します。 マージやリベースなどのコマンドは、作業を行うためのパスを具体化でき(たとえば、競合を表示するため)ますが、他のスパースチェックアウトコマンドは、個々のファイルをスパース化できない場合があります(たとえば、ステージングされていない変更や競合があるため)。 このような場合、影響を受けるパスをクリーンアップした後、(たとえば、競合の解決、変更の取り消しまたはコミットなどの)後で @samp{git sparse-checkout reapply} を実行するのが理にかなっています。

@samp{reapply} コマンドは @samp{--[no-]cone} や @samp{--[no-]sparse-index} フラグも使用できます。これは、 @samp{set} コマンドのフラグと同一の意味で、 これにより、あなたは全てのスパース・パス(sparsity paths)を再指定すること無く、スパース・モードを変更できます。

@item  disable 
@samp{core.sparseCheckout} 構成設定を無効にし、すべてのファイルを含めるように作業ディレクトリを復元(restore)します。

@item  init 
パスが指定されていない「set」のように動作する非推奨のコマンド。 将来削除される可能性があります。

かつて @samp{set} は必要なすべての構成設定を処理していませんでした。 つまり、 @samp{init} と @samp{set} の両方を呼び出す必要がありました。 両方を呼び出すと、最初に @samp{init} ステップでほぼすべての追跡ファイルが削除され(コーン・モードでは無視されたファイル(ignored files)も含めて)、 次に @samp{set} ステップで追跡ファイルの多くが追加されます(ただし、無視されたファイル(ignored files)は含まれません)。 ファイルが失われるだけでなく、この組み合わせのパフォーマンスと UI も貧弱でした。

また、かつては、 スパース・チェックアウト・ファイルが既に存在する場合、 @samp{init} は実際にはそれを初期化しませんでした。 これは、後続の @samp{set} または @samp{add} コマンドに渡すパスを覚えていなくても、 スパース・チェックアウトに戻ることができることを意味していました。 ただし、 @samp{--cone} オプションと @samp{--sparse-index} オプションは、 @samp{disable} コマンドまでまたがって記憶される訳では無いため、 単純な @samp{init} を呼び出す簡単な復元の有用性が低下しました。

@item  @emph{check-rules} 
Check whether sparsity rules match one or more paths.

By default @samp{check-rules} reads a list of paths from stdin and outputs only the ones that match the current sparsity rules. The input is expected to consist of one path per line, matching the output of @samp{git ls-tree --name-only} including that pathnames that begin with a double quote (") are interpreted as C-style quoted strings.

When called with the @samp{--rules-file <file>} flag the input files are matched against the sparse checkout rules found in @samp{<file>} instead of the current ones. The rules in the files are expected to be in the same form as accepted by @samp{git sparse-checkout set --stdin} (in particular, they must be newline-delimited).

By default, the rules passed to the @samp{--rules-file} option are interpreted as cone mode directories. To pass non-cone mode patterns with @samp{--rules-file}, combine the option with the @samp{--no-cone} option.

When called with the @samp{-z} flag, the format of the paths input on stdin as well as the output paths are \0 terminated and not quoted. Note that this does not apply to the format of the rules passed with the @samp{--rules-file} option.
@end table

@noindent

@chapheading EXAMPLES

@table @asis

@item  @samp{git sparse-checkout set MY/DIR1 SUB/DIR2} 
作業コピーに存在する MY/DIR1/ および SUB/DIR2/ の下のすべてのファイル(任意の深さ)(加えて @samp{MY/} や @samp{SUB/} 直下と、トップレベル・ディレクトリのすべてのファイル)を使用して、スパース チェックアウトに変更します。 すでにスパース・チェックアウトである場合は、作業コピーに存在するファイルをこの新しい選択に変更します。 注意: このコマンドは、追跡中のファイルまたは、無視されていない追跡されていない(non-ignored-untracked)ファイルが存在しなくなったディレクトリ内のすべての無視されたファイル(ignored files)も削除することに注意してください。

@item  @samp{git sparse-checkout disable} 
スパース・チェックアウトを無効にして、 作業ディレクトリにすべてのファイルを再入力します。

@item  @samp{git sparse-checkout add SOME/DIR/ECTORY} 
@samp{SOME/DIR/ECTORY/} の下(任意の深さ)にあるすべてのファイルをスパース・チェックアウトに追加し、 @samp{SOME/DIR/} の直下と @samp{SOME/} の直下にあるすべてのファイルも追加します。 このコマンドを使用する前に、スパース・チェックアウトにしておく必要があります。

@item  @samp{git sparse-checkout reapply} 
コマンドが、 選択されたスパース・ディレクトリを尊重しない方法で作業ツリーを更新する可能性があります。 これは、Git の外部のツールがファイルを書き込むことで発生したり、 また、(マージ/リベース時に競合が発生するなどの)特殊なケースや一部のコマンドがスパース・チェックアウトを完全にサポートしていないために Git コマンドに影響を与えるたりする可能性があります(たとえば、古い「recursive」(再帰的)マージ・バックエンドのサポートは限定的でした)。 このコマンドは、既存のスパース・ディレクトリの指定を再適用して、作業ディレクトリを一致させます。
@end table

@noindent

@chapheading INTERNALS — SPARSE CHECKOUT

「スパース・チェックアウト」(sparse checkout;疎らなチェックアウト)を使用すると、 作業ディレクトリを疎らに設定できます。 これは、skip-worktree ビット (git-update-index(1) を参照) を使用して、作業ディレクトリ内のファイルを調べる価値があるかどうかを Git に伝えます。 skip-worktree ビットが設定されていて、 ファイルが作業ツリーに存在しない場合、その不在は無視されます。 Git はこれらのファイルの内容を作業ディレクトリに入力することを回避します。これにより、多くのファイルを含むリポジトリで作業する場合にはスパース・チェックアウトが役に立ちますが、現在のユーザーにとってほとんど重要では無いものです。

@samp{$GIT_DIR/info/sparse-checkout} ファイルは、スキップワークツリー参照ビットマップを定義するために使用されます。 Gitが作業ディレクトリを更新すると、このファイルに基づいてインデックスのスキップワークツリービットが更新されます。 ファイル内のパターンに一致するファイルは作業ディレクトリに表示され、残りは表示されません。

@noindent

@chapheading INTERNALS — NON-CONE PROBLEMS

@samp{set} や @samp{add} サブコマンドによって入力される @samp{$GIT_DIR/info/sparse-checkout} ファイルは、 @samp{.gitignore} ファイルと同じ構文を使用して(1行に1つの)一連のパターンとして定義されます。 コーン・モードでは、 これらのパターンは一致するディレクトリに制限されます(ユーザーはディレクトリ名を指定または表示するだけで済みます)。一方、非コーン・モードでは、任意の gitignore スタイルのパターンが許可されます。 非コーン・モードで完全な gitignore スタイルのパターンを使用すると、 以下のようないくつかの欠点があります:

@itemize 

@item
基本的に、さまざまなワークツリー更新プロセス(pull, merge, rebase, switch, reset, checkout, 等)で O(N*M) 回のパターン・マッチングが必要になります。ここで、N はパターンの数、M はインデックス内のパスの数です。これはスケーリングが不十分です。

@item
スケーリングの問題を回避するには、先頭のディレクトリ名またはグロブを指定してパターンの数を制限する必要があります。

@item
コマンドラインでグロブを渡すとエラーが発生しやすくなります。ユーザーがグロブをクォートするのを忘れる可能性があるため、シェルがそれをすべての一致するファイルに展開し、それらすべてを個別にスパース・チェックアウト set/add に渡す原因となります。 これは、例えば @samp{git grep -- *.c} でも問題になる可能性がありますが、 grep/log/status での間違いは即座に出力が得られます。 スパース・チェックアウトでは、間違いはスパース・チェックアウト・コマンドの実行時に記録され、後でユーザーがブランチ切り替えまたはリベースまたはマージを行うまで問題にならない可能性があるため、ユーザーのエラーと、ユーザーがそれをキャッチする機会、またはユーザにそれを通知する機会、までに遅延が生じます。

@item
先の項目に関連して、スパース・チェックアウトには @samp{add} サブコマンドがありますが、 @samp{remove} サブコマンドはありません。 @samp{remove} サブコマンドが追加された場合、クォートされていない偶発的なグロブを元に戻すと、偶発的な追加の前に含まれていたエントリが削除される可能性があるため、「削除しすぎ」のリスクがあります。

@item
非コーン・モード(non-cone mode)では gitignore スタイルのパターンを使用して「含める」(否定パターンを除く)ものを選択しますが、 @samp{.gitignore} ファイルは gitignore スタイルのパターンを使用して「除外するもの」(否定パターンを除く)を選択します。 gitignore スタイルのパターンに関するドキュメントは通常、 一致または不一致の観点からではなく、 ユーザーが何を「除外」したいかについて述べています。 これは、 スパース・チェックアウト・パターンを指定して目的の動作を取得する方法を学習しようとしているユーザーにとっては混乱を招く可能性があります。

@item
ある種の「特別なパス・パターン・マッチング」を提供したい他のすべての git サブコマンドは pathspecs を使用しますが、 スパース・チェックアウトの非コーン・モードは gitignore パターンを使用するため、一貫性がありません。

@item
「正しい」動作が不明確な境界ギリギリのケース(edge cases)があります。 以下に例を2つ挙げます:
@end itemize

First, two users are in a subdirectory, and the first runs
@samp{git sparse-checkout set '/toplevel-dir/*.c'}
while the second runs
@samp{git sparse-checkout set relative-dir}
Should those arguments be transliterated into
@samp{current/subdirectory/toplevel-dir/*.c}
and
@samp{current/subdirectory/relative-dir}
before inserting into the sparse-checkout file?  The user who typed
the first command is probably aware that arguments to set/add are
supposed to be patterns in non-cone mode, and probably would not be
happy with such a transliteration.  However, many gitignore-style
patterns are just paths, which might be what the user who typed the
second command was thinking, and they’d be upset if their argument
wasn’t transliterated.

@example
Second, what should bash-completion complete on for set/add commands for non-cone users? If it suggests paths, is it exacerbating the problem above? Also, if it suggests paths, what if the user has a file or directory that begins with either a '!' or '#' or has a '*', '\', '?', '[', or ']' in its name? And if it suggests paths, will it complete "/pro" to "/proc" (in the root filesystem) rather than to "/progress.txt" in the current directory? (Note that users are likely to want to start paths with a leading '/' in non-cone mode, for the same reason that .gitignore files often have one.) Completing on files or directories might give nasty surprises in all these cases.
@end example

@itemize 

@item
過度の柔軟性により、他の拡張機能は本質的に実用的ではなくなりました。 @samp{--sparse-index} 機能は非コーン・モードではおそらく不可能です。 たとえそれが何らかの形で実行可能であったとしても、 実装するにははるかに多くの作業が必要であり、かつ、実際に動かすと遅すぎる可能性があります。 部分(partial)クローンとスパース・チェックアウトの間の結合を追加するためのいくつかのアイデアは、パスのセットがより制限されている場合にのみ実用的です。
@end itemize

これらすべての理由から、 非コーン・モードは推奨されません。 コーン・モードを使用するように切り替えてください。

@noindent

@chapheading INTERNALS — CONE MODE HANDLING

デフォルトの「コーン・モード」では、含めるディレクトリのみを指定できます。 指定されたディレクトリについては、そのディレクトリの下のすべてのパスが含まれ、先頭のディレクトリ (最上位ディレクトリを含む) のすぐ下のパスも含まれます。 したがって、ディレクトリ @samp{Documentation/technical/} を指定した場合、スパース・チェックアウトには以下が含まれます:

@itemize 

@item
最上位ディレクトリ内のすべてのファイル

@item
@samp{Documentation/} 直下のすべてのファイル

@item
@samp{Documentation/technical/} の下の任意の深さのすべてのファイル
@end itemize

また、コーン・モードでは、ディレクトリが指定されていない場合でも、最上位ディレクトリ内のファイルが含まれます。

円錐(cone)モードでスパースチェックアウトパターンを変更すると、Gitはスパースチェックアウト円錐(cone)内にない追跡中の各ディレクトリを検査して、追跡されていないファイルが含まれているかどうかを確認します。 @samp{.gitignore} パターンが原因でこれらのファイルがすべて無視された場合、ディレクトリは削除されます。 そのディレクトリ内の追跡されていないファイルのいずれかが無視されない場合、そのディレクトリ内で削除は発生せず、警告メッセージが表示されます。 これらのファイルが重要な場合は、スパースチェックアウト定義をリセットして含まれるようにし、 @samp{git add} と @samp{git commit} を使用してファイルを保存し、残りのファイルを手動で削除して、Gitが最適に動作できるようにします。

ディレクトリがフード(hood)の下でスパース・チェックアウトのフル・パターン・セットのサブセットに変換される方法については、「Internals — Cone Pattern Set」セクションも参照してください。

@noindent

@chapheading INTERNALS — FULL PATTERN SET

フルパターンセットにより、任意のパターンの一致と複雑な包含/除外ルールが可能になります。 これらにより、インデックスを更新するときに O(オー;N*M)パターンが一致する可能性があります。ここで、Nはパターンの数、Mはインデックス内のパスの数です。 このパフォーマンスの問題に対処するために、 @samp{core.sparseCheckoutCone} が有効になっている場合は、より制限されたパターンセットが許可されます。

スパース・チェックアウト・ファイルは @samp{.gitignore} ファイルと同じ構文を使用します。 その詳細については、gitignore(5) を参照してください。 ただし、ここでは通常、どのファイルを除外するかではなく、どのファイルを含めるかを選択するためにパターンが使用されています。 (ただし、gitignore スタイルのパターンでは @samp{!} で始まるパターンによって否定が定義されているため、「含めない」ファイルを選択することもでき、少々混乱することがあります。 )

たとえば、(@samp{unwanted} という名前のファイルを除くすべてのファイルが作業ツリーに表示されるように)、すべてを選択してからファイル @samp{unwanted} を削除するには以下のようにします:

@example
git sparse-checkout set --no-cone '/*' '!unwanted'
@end example

これらのパターンはそのまま @samp{$GIT_DIR/info/sparse-checkout} というファイルに配置されるため、この時点での、このファイルの内容は以下のようになります

@example
/*
!unwanted
@end example


スパース・チェックアウトで使用される gitignore スタイルのパターンの詳細については、 git-read-tree(1) の「Sparse Checkout」セクションも参照してください。

@noindent

@chapheading INTERNALS — CONE PATTERN SET

コーン・モードでは、ディレクトリのみが受け入れられますが、完全なパターン・セットで使用されるのと同じ gitignore スタイルのパターンに変換されます。 私達はその際に使用される特殊なパターンを2つのタイプに分類しています:

@enumerate 

@item
@strong{再帰}: (recursive)ディレクトリ内のすべてのパスが含まれます

@item
@strong{親}: (parent)ディレクトリ直下のすべてのファイルが含まれます。
@end enumerate

コーン・モードでは常にトップレベルにファイルが含まれるため、 ディレクトリを指定せずに @samp{git sparse-checkout set} を実行すると、 トップレベル・ディレクトリが親パターンとして追加されます。 この時点で、スパース・チェック・ファイルには以下のパターンが含まれています:

@example
/*
!/*/
@end example


これは、「最上位ディレクトリの直下のすべてを含めますが、それより下のレベルのは何も含めない」という意味です。

コーン・モードの場合、 @samp{git sparse-checkout set} サブコマンドはディレクトリのリストを受け取ります。 コマンド @samp{git sparse-checkout set A/B/C} はディレクトリ @samp{A/B/C} を再帰パターンとして設定し、 ディレクトリ @samp{A} と @samp{A/B} が親パターンとして追加されます。 結果として得られるスパース・チェックアウト・ファイルは以下のようになります

@example
/*
!/*/
/A/
!/A/*/
/A/B/
!/A/B/*/
/A/B/C/
@end example


ここでは順番が重要なので、ネガティブなパターンはファイルの下位に表示されるポジティブなパターンに上書きされます。

@samp{core.sparseCheckoutCone} が明示的に @samp{false} に設定されていない限り、Git はこれらのタイプのパターンを想定してスパース・チェックアウト・ファイルをパースします。 パターンが一致しない場合、Git は警告します。 パターンが予想される形式と一致する場合、Git はより高速なハッシュベースのアルゴリズムを使用して、スパース・チェックアウトへの包含を計算します。 一致しない場合、設定に関係なく、 git は @samp{core.sparseCheckoutCone} が @samp{false} であるかのように動作します。

コーン・モードの場合、 完全なパターンが @samp{$GIT_DIR/info/sparse-checkout} ファイルに書き込まれるという事実にもかかわらず、 @samp{git sparse-checkout list} サブコマンドは、再帰パターンを定義するディレクトリを一覧表示します。 上記のスパース・チェックアウト・ファイルの例では、出力は以下のようになります:

@example
$ git sparse-checkout list
A/B/C
@end example


@samp{core.ignoreCase=true} の場合、パターンマッチングアルゴリズムは大文字と小文字を区別しないチェックを使用します。 これにより、 @samp{git sparse-checkout set} コマンドのファイル名が一致しない状況が修正され、作業ディレクトリに期待される円錐(cone)が反映されます。

@noindent

@chapheading INTERNALS — SUBMODULES

あなたのリポジトリに1つ以上のサブモジュールが含まれている場合、サブモジュールは @samp{git submodule} コマンドとの相互作用に基づいて入力されます。 具体的には、 @samp{git submodule init -- <path>} は @samp{<path>} のサブモジュールが存在することを確認し、 @samp{git submodule deinit [-f] -- <path>} は @samp{<path>} のサブモジュールのファイルを削除します(追跡されていないファイル、コミットされていない変更、プッシュされていない履歴を含む)。sparse-checkoutが作業ツリーからファイルを削除するが、インデックスにエントリを残す方法と同様に、初期化されていないサブモジュールは作業ディレクトリから削除されますが、インデックスにはエントリがあります。

サブモジュールにはプッシュされていない変更または追跡されていないファイルがある可能性があるため、それらを削除するとデータが失われる可能性があります。 したがって、スパース 包含/除外 ルールを変更しても、すでにチェックアウトされているサブモジュールが作業コピーから削除されることはありません。 別の言い方をすれば、サブモジュールを削除または追加するブランチを切り替えても、 @samp{checkout} によってサブモジュールが自動的に削除または初期化されないのと同様に、 @samp{sparse-checkout} を使用して「興味深い」ファイルの範囲を縮小または拡大してもサブモジュールの自動的な非初期化または初期化は発生しません。

さらに、上記の事実は、「追跡された」ファイルが作業コピーに存在しない可能性に複数の理由があることを意味します。スパースチェックアウトからのスパースパターンアプリケーション、およびサブモジュールの初期化状態です。 したがって、作業コピー内の追跡されたファイルで機能する @samp{git grep} のようなコマンドは、これらの制限のいずれかまたは両方によって制限される結果を返す可能性があります。

@noindent

@chapheading SEE ALSO

git-read-tree(1) gitignore(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-stage,,,Top
@chapheading Name

git-stage — ファイルの内容をステージング領域に追加

@noindent

@chapheading Synopsis

@display
git stage <arg>…
@end display


@noindent

@chapheading DESCRIPTION

これは git-add(1) の同義語です。 git-add(1) の文書を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-stash,,,Top
@chapheading Name

git-stash — 汚い作業ディレクトリの変更を隠します

@noindent

@chapheading Synopsis

@display
git stash list [<log-options>]
git stash show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]
git stash drop [-q | --quiet] [<stash>]
git stash pop [--index] [-q | --quiet] [<stash>]
git stash apply [--index] [-q | --quiet] [<stash>]
git stash branch <branchname> [<stash>]
git stash [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]
             [-u | --include-untracked] [-a | --all] [(-m | --message) <message>]
             [--pathspec-from-file=<file> [--pathspec-file-nul]]
             [--] [<pathspec>…]]
git stash save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]
             [-u | --include-untracked] [-a | --all] [<message>]
git stash clear
git stash create [<message>]
git stash store [(-m | --message) <message>] [-q | --quiet] <commit>
@end display


@noindent

@chapheading DESCRIPTION

作業ディレクトリとインデックスの現在の状態を記録したいが、クリーンな作業ディレクトリに戻りたい場合は、@samp{git stash} を使用します。 このコマンドは、ローカルの変更を保存し、作業ディレクトリを元に戻して(revert)、@samp{HEAD} コミットに一致させます。

このコマンドによってスタッシュされた変更は、 @samp{git stash list} で一覧表示され、 @samp{git stash show} で調査され、 @samp{git stash apply} で復元されます(それは別のコミットの上にある可能性があります)。 引数なしで @samp{git stash} を呼び出すことは、 @samp{git stash push} と同等です。 スタッシュはデフォルトで @samp{WIP on 'branchname' ...} としてリストされますが、作成するときにコマンドラインでより説明的なメッセージを与える事ができます。

作成した 最新のスタッシュ は @samp{refs/stash} に保存されます。 古いスタッシュはこのリファレンスのreflogにあり、通常のreflog構文を使用して名前を付けることができます(たとえば、 @samp{stash@@@{0@}} は最後に作成されたスタッシュで、 @samp{stash@@@{1@}} はその前のスタッシュです。 @samp{stash@@@{2.hours.ago@}} も可能です)。 スタッシュは、スタッシュインデックスのみを指定することによって参照することもできます(たとえば、整数 @samp{n} は @samp{stash@@@{n@}} と同等です)。

@noindent

@chapheading COMMANDS

@table @asis

@item  push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>…] 
あなたのローカルの変更を新しい「スタッシュエントリ」に保存し、それらをHEADに巻き戻します(作業ツリー内とインデックス内で)。 <message> の部分はオプションであり、スタッシュ状態と共に説明を提供します。

スナップショットをすばやく作成するために、「push」を省略できます。 このモードでは、サブコマンドのスペルミスで不要なスタッシュエントリを作成するのを防ぐための非オプション引数は許可されていません。 これに対する2つの例外は、 @samp{stash push -p} のエイリアスとして機能する @samp{stash -p} と、曖昧さ解消のために二重ハイフン @samp{--} の後ろで許可されるpathspec要素です。

@item  save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<message>] 
このオプションは廃止され、 @samp{git stash push} が採用されました。 pathspecをとることができないという点で「stash push」とは異なります。 代わりに、オプション以外のすべての引数が連結されて、スタッシュメッセージが形成されます。

@item  list [<log-options>] 
現在持っているスタッシュエントリを一覧表示します。 各「スタッシュエントリ」は、その名前(たとえば、 @samp{stash@@@{0@}} は最新のエントリ、 @samp{stash@@@{1@}} はその前のエントリ、など)と、 エントリが作成されたときの現在のブランチの名前と、エントリが基づいていたコミットの簡単な説明と、ともに一覧表示されます。

@example
stash@@@{0@}: WIP on submit: 6ebd0e2... Update git-stash documentation
stash@@@{1@}: On master: 9cc0589... Add git-stash
@end example


このコマンドは、 @samp{git log} コマンドに適用可能なオプションを使用して、表示内容と方法を制御します。 git-log(1) を参照してください。

@item  @samp{show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]} 
スタッシュエントリに記録された変更を、スタッシュされたコンテンツとスタッシュエントリが最初に作成されたときのコミットとの差分として表示します。 デフォルトでは、コマンドはdiffstatを表示しますが、 @samp{git diff} として認識される任意の形式を受け入れます(たとえば、パッチ形式で2番目に新しいエントリを表示するには @samp{git stash show -p stash@@@{1@}})。 @samp{<diff-option>} が指定されていない場合、デフォルトの動作は @samp{stash.showStat} および @samp{stash.showPatch} 構成変数によって与えられます。 @samp{stash.showIncludeUntracked} を使用して、 @samp{--include-untracked} がデフォルトで有効になっているかどうかを設定することもできます。

@item  @samp{pop [--index] [-q|--quiet] [<stash>]} 
スタッシュリストから単一のスタッシュ状態を削除し、現在の作業ツリー状態の上に適用します。つまり、 @samp{git stash push} の逆の操作を実行します。 作業ディレクトリはインデックスと一致している必要があります。

状態の適用は、競合で失敗する可能性があります。 この場合、スタッシュリストからは削除されません。 競合を手動で解決し、後で手動で @samp{git stash drop} を呼び出す必要があります。

@item  @samp{apply [--index] [-q|--quiet] [<stash>]} 
@samp{pop} と同様ですが、スタッシュリストから状態を削除しないでください。 @samp{pop} とは異なり 、@samp{<stash>} は、@samp{stash push} または @samp{stash create} によって作成されたコミットのように見える任意のコミットです。

@item  branch <branchname> [<stash>] 
@samp{<stash>} が元々作成された時のコミットから @samp{<branchname>} という名前の新しいブランチを作成してチェックアウトし、 @samp{<stash>} に記録された変更を新しい作業ツリーとインデックスに適用します。 それが成功し、 @samp{<stash>} が @samp{stash@@@{<revision>@}} 形式の参照である場合、 @samp{<stash>} を削除します。

これは、あなたが @samp{git stash push} を実行したブランチがとても変更されていて、@samp{git stash apply} が競合のために失敗した場合に便利です。 スタッシュエントリは、 @samp{git stash} が実行されたときにHEADであったコミットの上に適用(apply)されるため、競合することなく元のスタッシュされた状態を復元します。

@item  clear 
すべてのスタッシュエントリを削除します。 これらのエントリは刈り込みの対象となり、回復できない可能性があることに注意してください(可能な戦略については、下記「Examples」を参照してください)。

@item  @samp{drop [-q|--quiet] [<stash>]} 
スタッシュエントリリストからスタッシュエントリを1つ削除します。

@item  create 
ref名前空間のどこにも保存せずに、スタッシュエントリ(通常のコミットオブジェクト)を作成し、そのオブジェクト名を返します。 これは、スクリプトで役立つことを目的としています。 おそらくあなたがこのコマンドを使用することはありません。 上記「push」を参照してください。

@item  store 
@samp{git stash create} を介して作成された特定のスタッシュ(これは宙ぶらりんマージコミット(dangling merge commit)です)をスタッシュrefに格納し、スタッシュreflogを更新します。 これは、スクリプトで役立つことを目的としています。 おそらく、あなたはこのコマンドを使用することはありません。 上記「push」を参照してください。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
@itemx  @samp{--all} 
このオプションは、 @samp{push} および @samp{save} コマンドでのみ有効です。

無視され追跡されていないすべてのファイルもスタッシュしてから、 @samp{git clean} でクリーンアップします。

@item  @samp{-u} 
@itemx  @samp{--include-untracked} 
@itemx  @samp{--no-include-untracked} 
@samp{push} および @samp{save} コマンドと一緒に使用すると、追跡されていないすべてのファイルもスタッシュし、 @samp{git clean} でクリーンアップします。

@samp{show} コマンドと一緒に使用すると、diffの一部としてスタッシュエントリの追跡されていないファイルを表示します。

@item  @samp{--only-untracked} 
このオプションは、 @samp{show} コマンドでのみ有効です。

diffの一部として、スタッシュエントリ内の、追跡されていないファイル(untracked files)のみを表示します。

@item  @samp{--index} 
このオプションは、 @samp{pop} および @samp{apply} コマンドにのみ有効です。

作業ツリーの変更だけでなく、インデックスの変更も復元しようと試みます。 ただし、競合がある場合(競合がインデックスに保存されているため、元の変更を適用できなくなる)、これは失敗する可能性があります。

@item  @samp{-k} 
@itemx  @samp{--keep-index} 
@itemx  @samp{--no-keep-index} 
このオプションは、 @samp{push} および @samp{save} コマンドでのみ有効です。

インデックスにすでに追加されているすべての変更はそのまま残ります。

@item  @samp{-p} 
@itemx  @samp{--patch} 
このオプションは、 @samp{push} および @samp{save} コマンドでのみ有効です。

HEADと作業ツリー間のdiffから、スタッシュするハンクを対話的に選択します。 スタッシュエントリは、リポジトリのインデックス状態と同じになるように構築され、そのワークツリーには、対話的に選択した変更点のみが含まれます。 そして、選択した変更はワークツリーから巻き戻されます。 @samp{--patch} モードの操作方法については、 git-add(1) の「Interactive Mode」セクションを参照してください。

@samp{--patch} オプションは @samp{--keep-index} の指定を含んでいます。あなたは @samp{--no-keep-index} を使用してこれを上書きできます。

@item  @samp{-S} 
@itemx  @samp{--staged} 
このオプションは、 @samp{push} および @samp{save} コマンドでのみ有効です。

現在ステージングされている変更のみをスタッシュします。 これは、状態が現在のブランチではなくスタッシュにコミットされることを除いて、基本的な @samp{git commit} に似ています。

@samp{--patch} オプションはこれよりも優先されます。

@item  @samp{--pathspec-from-file=<file>} 
このオプションは、 @samp{push} コマンドにのみ有効です。

pathspecは、コマンドライン引数の代わりに @samp{<file>} で渡されます。 @samp{<file>} が正確に @samp{-} の場合、標準入力が使用されます。 pathspec要素はLFまたはCR/LFで区切られます。 pathspec要素は、構成変数 @samp{core.quotePath} にて説明されているようにクォートできます(git-config(1) 参照)。 @samp{--pathspec-file-nul} および グローバルの @samp{--literal-pathspecs} も参照してください。

@item  @samp{--pathspec-file-nul} 
このオプションは、 @samp{push} コマンドにのみ有効です。

このオプションは @samp{--pathspec-from-file} でのみ意味があります。 pathspec要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます(改行と引用符を含む)。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
このオプションは、 @samp{apply}, @samp{drop}, @samp{pop}, @samp{push}, @samp{save}, @samp{store} コマンドにのみ有効です。

静かにして、フィードバックメッセージを抑制します。

@item  @samp{--} 
このオプションは、 @samp{push} コマンドにのみ有効です。

曖昧さ解消の目的のために pathspec をオプションから分離します。

@item  <pathspec>… 
このオプションは、 @samp{push} コマンドにのみ有効です。

新しいスタッシュエントリは、pathspecに一致するファイルについてのみ変更された状態を記録します。 次に、インデックスエントリと作業ツリーファイルは、これらのファイルについてのみHEADの状態に巻き戻されされ、pathspecに一致しないファイルはそのまま残ります。

詳細については、 gitglossary(7) の「pathspec」エントリを参照してください。

@item  <stash> 
このオプションは、 @samp{apply}, @samp{branch}, @samp{drop}, @samp{pop}, @samp{show} コマンドにのみ有効です。

@samp{stash@@@{<revision>@}} 形式の参照。 @samp{<stash>} が指定されていない場合、最新のスタッシュ(@samp{stash@@@{0@}})を想定します。
@end table

@noindent

@chapheading DISCUSSION

スタッシュエントリーは、作業ディレクトリの状態を記録するツリーを持つコミットとして表現され、その最初の親はエントリーが作成された @samp{HEAD} でのコミットとなります。 2番目の親のツリーは、エントリーが作成されたときのインデックスの状態を記録しており、@samp{HEAD} コミットの子として作られます。 祖先のグラフは以下のようになります:

@example
       .----W
      /    /
-----H----I
@end example

ここで、 @samp{H} は @samp{HEAD} コミット、 @samp{I} はインデックスの状態を記録するコミット、 @samp{W} は作業ツリーの状態を記録するコミットです。

@noindent

@chapheading EXAMPLES

@table @asis

@item  Pulling into a dirty tree 
あなたが何かしている最中、あなたがしていることにおそらく関連しているかもしれないアップストリームの変更があったことを知りました。 あなたのローカルの変更がアップストリームの変更と競合しない場合は、単純に `git pull `で先に進むことができます。

しかしながら、あなたのローカルの変更がアップストリームの変更と競合し、 @samp{git pull} が変更の上書きを拒否する場合があります。 このような場合、以下のように、変更をスタッシュし、プルしてから、スタッシュ解除できます:

@example
$ git pull
 ...
file foobar not up to date, cannot merge.
$ git stash
$ git pull
$ git stash pop
@end example


@item  Interrupted workflow 
あなたが何かやってる真っ最中に、上司がやって来て、あなたにすぐに何かを直すように要求します。 従来は、一時的なブランチにコミットして変更を保存し、元のブランチに戻って以下のように緊急修正を行っていました:

@example
# ... hack hack hack ...
$ git switch -c my_wip
$ git commit -a -m "WIP"
$ git switch master
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"
$ git switch my_wip
$ git reset --soft HEAD^
# ... continue hacking ...
@end example


@samp{git stash} を使用することで上記を以下のように簡略化できます:

@example
# ... hack hack hack ...
$ git stash
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"
$ git stash pop
# ... continue hacking ...
@end example


@item  Testing partial commits 
ワークツリーの変更から2つ以上のコミットを行い、コミットする前に各変更をテストする場合は、 @samp{git stash push --keep-index} を使用できます:

@example
# ... hack hack hack ...
$ git add --patch foo            # add just first part to the index
$ git stash push --keep-index    # save all other changes to the stash
$ edit/build/test first part
$ git commit -m 'First part'     # commit fully tested change
$ git stash pop                  # prepare to work on all other changes
# ... repeat above five steps until one commit remains ...
$ edit/build/test remaining parts
$ git commit foo -m 'Remaining parts'
@end example


@item  将来の使用のために無関係な変更を保存 
大規模な変更の最中に、 修正を忘れたくない無関係な問題を見つけた場合、 変更を行い、それらをステージングし、 @samp{git stash push --staged} を使用して将来の使用のためにスタッシュしておくことができます。 これは、ステージングされた変更をコミットするのと似ていますが、コミットのみが現在のブランチではなくスタッシュに配置されます。

@example
# ... hack hack hack ...
$ git add --patch foo           # add unrelated changes to the index
$ git stash push --staged       # save these changes to the stash
# ... hack hack hack, finish current changes ...
$ git commit -m 'Massive'       # commit fully tested changes
$ git switch fixup-branch       # switch to another branch
$ git stash pop                 # to finish work on the saved changes
@end example


@item  誤ってクリアまたはドロップされたスタッシュエントリの回復 
誤ってスタッシュエントリをドロップまたはクリアした場合、通常の安全メカニズムでは回復できません。 ただし、以下の呪文を試して、リポジトリに残っているが到達できなくなったスタッシュエントリのリストを取得できます:

@example
git fsck --unreachable |
grep commit | cut -d\  -f3 |
xargs git log --merges --no-walk --grep=WIP
@end example

@end table

@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  stash.showIncludeUntracked 
これがtrueに設定されている場合、 @samp{git stash show} コマンドはstashエントリの追跡されていないファイルを表示します。 デフォルトはfalseです。 git-stash(1) の showコマンドの説明を参照してください。

@item  stash.showPatch 
これがtrueに設定されている場合、オプションのない @samp{git stash show} コマンドは、パッチ形式でstashエントリを表示します。 デフォルトはfalseです。 git-stash(1)の showコマンドの説明を参照してください。

@item  stash.showStat 
これがtrueに設定されている場合、オプションのない @samp{git stash show} コマンドは、stashエントリのdiffstatを表示します。 デフォルトはtrueです。 git-stash(1) の showコマンドの説明を参照してください。
@end table

@noindent

@chapheading SEE ALSO

git-checkout(1), git-commit(1), git-reflog(1), git-reset(1), git-switch(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-status,,,Top
@chapheading Name

git-status — 作業ツリーの状態を表示します

@noindent

@chapheading Synopsis

@display
git status [<options>] [--] [<pathspec>…]
@end display


@noindent

@chapheading DESCRIPTION

インデックスファイルと現在のHEADコミットの間に違いがあるパスや、作業ツリーとインデックスファイルの間に違いがあるパスや、Gitによって追跡されない(かつ gitignore(5) によって無視されない)作業ツリー内のパスを表示します。1つ目は、 @samp{git commit} を実行してコミットすることになるものです。 2番目と3番目は、 @samp{git commit} を実行する前に @samp{git add} を実行することでコミット可能になるものです。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-s} 
@itemx  @samp{--short} 
短い形式で出力を提供します。

@item  @samp{-b} 
@itemx  @samp{--branch} 
短い形式でもブランチと追跡情報を表示します。

@item  @samp{--show-stash} 
現在スタッシュされているエントリの数を表示します。

@item  @samp{--porcelain[=<version>]} 
スクリプトの出力を解析しやすい形式(easy-to-parse)で提供します。 これは短い出力に似ていますが、Gitのバージョン間で、ユーザー構成に関係なく安定しています。 詳細下記。

versionパラメーターは、フォーマットバージョンを指定するために使用されます。 これはオプションであり、デフォルトでオリジナルバージョンの「v1」形式になります。

@item  @samp{--long} 
長い形式で出力します。 これがデフォルトです。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
変更されたファイルの名前に加えて、コミットされるようにステージングされたテキストの変更も表示します(つまり、 @samp{git diff --cached} の出力風です)。 @samp{-v} が2回指定されている場合は、まだステージングされていない作業ツリーの変更も表示します(つまり、 @samp{git diff} の出力風です)。

@item  @samp{-u[<mode>]} 
@itemx  @samp{--untracked-files[=<mode>]} 
追跡されていないファイル(untracked files)を表示します。

modeパラメーターは、追跡されていないファイルの処理を指定するために使用されます。 これはオプションです。デフォルトは @samp{all} であり、指定する場合は、オプションに串刺しする必要があります(たとえば、 @samp{-u no} ではなく @samp{-uno})。

@table @asis

@item  可能なオプションは以下のとおりです 
@table @asis

@item  @emph{no} 
追跡されていないファイル(untracked files)を表示します。

@item  @emph{normal} 
追跡されていないファイルとディレクトリを表示します。

@item  @emph{all} 
追跡されていないディレクトリ内の個々のファイルも表示します。
@end table
@end table

@samp{-u} オプションを使用しない場合、追跡されていないファイルとディレクトリが表示され(つまり、 @samp{normal} を指定するのと同じ)、新しく作成されたファイルを追加するのを忘れないようにします。 ファイルシステムで、追跡されていないファイルを見つけるには余分な作業が必要なため、このモードは大きな作業ツリーでは時間がかかる場合があります。 サポートされている場合は、追跡されていないキャッシュと分割インデックスを有効にすることを検討してください(@samp{git update-index --untracked-cache} と @samp{git update-index --split-index} を参照)。そうでない場合は、 @samp{no} を使用して、追跡されていないファイルを表示せずに @samp{git status} からより迅速に返ることができます。

デフォルトは、 git-config(1) に記載されている status.showUntrackedFiles 構成変数を使用して変更できます。

@item  @samp{--ignore-submodules[=<when>]} 
変更を探すときは、サブモジュールへの変更を無視します。 <when> は、「none」、「untracked」、「dirty」、「all」のいずれかになります。「all」がデフォルトです。 「none」を使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、 git-config(1) または gitmodules(5) の「ignore」オプションの設定をオーバーライドするために使用できます。 「untracked」が使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません(ただし、変更されたコンテンツはスキャンされます)。 「dirty」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます(これは1.7.0より前の振る舞いでした)。 「all」を使用すると、サブモジュールへのすべての変更が非表示になります(また、構成オプション @samp{status.submoduleSummary} が設定されている場合、サブモジュールの要約の出力が抑制されます)。

@item  @samp{--ignored[=<mode>]} 
無視されたファイル(ignored files)も表示します。

modeパラメーターは、無視されたファイル(ignored files)の処理を指定するために使用されます。 これはオプションです。デフォルトは @samp{traditional} です。

@table @asis

@item  可能なオプションは以下のとおりです 
@table @asis

@item  @emph{traditional} 
@samp{--untracked-files=all} が指定されていない限り、無視されたファイルとディレクトリを表示します。指定されている場合、無視されたディレクトリ内の個々のファイルが表示されます。

@item  @emph{no} 
無視されたファイル(ignored files)を表示しません。

@item  @emph{matching} 
無視パターンにマッチする、無視されたファイルとディレクトリを表示します。
@end table
@end table

@samp{matching} モードが指定されている場合、無視されたパターンに明示的にマッチするパスが表示されます。 ディレクトリが無視パターンにマッチする場合、それは表示されますが、無視されたディレクトリに含まれるパスは表示されません。 ディレクトリが無視パターンにマッチしないが、すべてのコンテンツが無視される場合、ディレクトリは表示されませんが、すべてのコンテンツが表示されます。

@item  @samp{-z} 
LFではなくNULでエントリを終了します。 これは、他の形式が指定されていない場合、 @samp{--porcelain=v1} 出力形式の指定を含んでいます。

@item  @samp{--column[=<options>]} 
@itemx  @samp{--no-column} 
追跡されていないファイルを列(columns)に表示します。 オプションの構文については、構成変数 @samp{column.status} を参照してください。 オプションのない @samp{--column} と @samp{--no-column} は、それぞれ @samp{always} と @samp{never} と同等です。

@item  @samp{--ahead-behind} 
@itemx  @samp{--no-ahead-behind} 
アップストリームブランチに関連するブランチの詳細な 先行(ahead)/遅延(behind) カウントを、表示するか、または、表示しない。 デフォルトはtrueです。

@item  @samp{--renames} 
@itemx  @samp{--no-renames} 
ユーザー構成に関係なく、名前変更検出の オン/オフ を切り替えます。 git-diff(1) の @samp{--no-renames} も参照してください。

@item  @samp{--find-renames[=<n>]} 
名前変更の検出をオンにし、オプションで類似性のしきい値を設定します。 git-diff(1) の @samp{--find-renames} も参照してください。

@item  <pathspec>… 
gitglossary(7) の「pathspec」エントリを参照してください。
@end table

@noindent

@chapheading OUTPUT

このコマンドの出力は、コミットテンプレートのコメントとして使用するように設計されています。 デフォルトの長い形式は、人間が読める形式で、冗長で説明的なものになるように設計されています。 その内容と形式は予告なく変更される事があります。

他の多くのGitコマンドとは異なり、出力に記載されているパスは、サブディレクトリで作業している場合、現在のディレクトリを基準にして作成されます(これは、カット＆ペーストを支援するための意図的なものです)。 下記 status.relativePaths 構成オプションを参照してください。

@noindent

@heading Short Format

短い形式では、各パスのステータスがこれらの形式の1つとして表示されます

@example
XY PATH
XY ORIG_PATH -> PATH
@end example

ここで、 @samp{ORIG_PATH} は、名前が 変更/コピー されたコンテンツの出所です。 @samp{ORIG_PATH} は、エントリの名前が変更またはコピーされた場合にのみ表示されます。 @samp{XY} は2文字のステータスコードです。

フィールド(@samp{->} を含む)は、単一のスペースで互いに区切られています。 ファイル名に空白またはその他の印刷不可能な文字が含まれている場合、そのフィールドはC文字列リテラルの方法でクォートされます。ASCII二重引用符(34)キャラクタ(@samp{"})で囲まれ、内部の特殊文字はバックスラッシュ(@samp{\})でエスケープされます。

この形式を使用して表示される状態には3つの異なるタイプがあり、それぞれが「XY」構文を異なる方法で使用します:

@itemize 

@item
マージが発生していてマージが成功した場合、またはマージ状況以外の場合、 @samp{X} はインデックスのステータスを示し、@samp{Y} は作業ツリーのステータスを示します。

@item
マージの競合が発生し、まだ解決されていない場合、 @samp{X} と @samp{Y} は、共通の祖先と比較して、マージの各ヘッドによって導入された状態を示します。 これらのパスは「unmerged」と言われます。

@item
パスが追跡されていない場合、 @samp{X} と @samp{Y} はインデックスで不明(unknown)であるため、常に同一です。 @samp{??} は追跡されていないパスに使用されます。 @samp{--ignored} が使用されない限り、無視されたファイルはリストされません。 @samp{--ignored} が使用された場合、無視されたファイルは @samp{!!} で示されます。
@end itemize

ここでのマージという用語には、デフォルトの `--merge`戦略を使用したリベースや、チェリーピックや、マージ機構を使用したその他のものも含まれることに注意してください。

以下の表では、これら3つのクラスが別々のセクションに示されています。これらの文字は、追跡されたパスを示す最初の2つのセクションの @samp{X} フィールドと @samp{Y} フィールドに使用されます。

@itemize 

@item
" " = 変更されていない

@item
@samp{M} = 変更された

@item
@samp{T} = ファイル・タイプが変更された(通常ファイル(regular file)またはシンボリック・リンク(symbolic link)またはサブモジュール(submodule))

@item
@samp{A} = 追加された

@item
@samp{D} = 削除された

@item
@samp{R} = 名前変更された

@item
@samp{C} = コピーされた (構成オプション @samp{status.renames} が @samp{copies} に設定されている場合)

@item
@samp{U} = 更新されたがマージされていない
@end itemize

@example
X          Y     Meaning
-------------------------------------------------
         [AMD]   not updated
M        [ MTD]  updated in index
T        [ MTD]  type changed in index
A        [ MTD]  added to index
D                deleted from index
R        [ MTD]  renamed in index
C        [ MTD]  copied in index
[MTARC]          index and work tree matches
[ MTARC]    M    work tree changed since index
[ MTARC]    T    type changed in work tree since index
[ MTARC]    D    deleted in work tree
            R    renamed in work tree
            C    copied in work tree
-------------------------------------------------
D           D    unmerged, both deleted
A           U    unmerged, added by us
U           D    unmerged, deleted by them
U           A    unmerged, added by them
D           U    unmerged, deleted by us
A           A    unmerged, both added
U           U    unmerged, both modified
-------------------------------------------------
?           ?    untracked
!           !    ignored
-------------------------------------------------
@end example

@table @asis

@item  サブモジュールにはより多くの状態があり、代わりのレポートがあります 
@table @asis

@item  M 
サブモジュールには、インデックスに記録されているものとは異なるHEADがあります

@item  m 
サブモジュールに変更されたコンテンツがあります

@item  ? 
サブモジュールに追跡されていないファイル(untracked files)があります
@end table
@end table

これは、サブモジュール内の、変更されたコンテンツ、または、追跡されていないファイルは、コミットを準備するためにスーパープロジェクトの @samp{git add} を介して追加できないためです。

@samp{m} と @samp{?} は再帰的に適用されます。 たとえば、サブモジュール内のネストされたサブモジュールに、追跡されていないファイルが含まれている場合、これは同様に @samp{?} として報告されます。

@samp{-b} が使用されている場合、短い形式のステータスの前に行が表示されます

@example
## branchname tracking info
@end example

@noindent

@heading Porcelain Format Version 1

バージョン 1 の磁器形式(porcelain format)は短い形式に似ていますが、Gitバージョン間またはユーザー構成に基づいて後方互換性のない方法で変更されないことが保証されています。 これにより、スクリプトによる解析に最適です。 上記の短い形式の説明では、いくつかの例外を除いて、磁器形式についても説明しています:

@enumerate 

@item
ユーザーの color.status 構成は尊重されません。 色は常にオフになります。

@item
ユーザーの status.relativePaths 構成は尊重されません。 表示されるパスは、常にリポジトリルートを基準にしています。
@end enumerate

機械的パースで推奨される 代替 @samp{-z} 形式もあります。 この形式では、ステータスフィールドは同じですが、他のいくつかの点が異なります。 まず、名前変更エントリから @samp{->} が省略され、フィールドの順序が逆になります(たとえば、@samp{from -> to} は @samp{to from} になります)。 次に、 NUL(ASCII 0)が各ファイル名の後に続き、スペースをフィールド区切り文字として置き換え、改行で終了します(ただし、スペースはステータスフィールドを最初のファイル名から分離します)。 第三に、特殊文字を含むファイル名は特別にフォーマットされません。 クォートや、バックスラッシュのエスケープは実行されません。

サブモジュールの変更は、 @samp{m} または 単一の @samp{?} ではなく、変更された @samp{M} として報告されます。

@noindent

@heading Porcelain Format Version 2

バージョン2形式では、ワークツリーの状態と変更されたアイテムに関するより詳細な情報が追加されます。 バージョン2では、パースが容易なオプションのヘッダーの拡張可能なセットも定義されています。

ヘッダー行は @samp{#} で始まり、特定のコマンドライン引数に応じて追加されます。 パーサーは、認識できないヘッダーを無視する必要があります。

@noindent

@subheading Branch Headers

@samp{--branch} を指定すると、一連のヘッダー行に現在のブランチに関する情報が出力されます。

@example
Line                                     Notes
------------------------------------------------------------
# branch.oid <commit> | (initial)        Current commit.
# branch.head <branch> | (detached)      Current branch.
# branch.upstream <upstream_branch>      If upstream is set.
# branch.ab +<ahead> -<behind>           If upstream is set and
                                         the commit is present.
------------------------------------------------------------
@end example

@noindent

@subheading Stash Information

@samp{--show-stash} が指定された場合に、スタッシュエントリの数が非ゼロの場合、スタッシュ・エントリの数を示す 1 行が出力されます:

@example
# stash <N>
@end example

@noindent

@subheading Changed Tracked Entries

ヘッダーに続いて、追跡されたエントリの一連の行が印刷されます。 変更の種類に応じて、3つの異なる行形式のいずれかを使用してエントリを記述することができます。 追跡されたエントリは、未定義の順序で印刷されます。 パーサーは、3つの行タイプを任意の順序で混合できるようにする必要があります。

通常の、変更されたエントリの形式は以下のとおりです:

@example
1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>
@end example

名前変更またはコピーされたエントリの形式は以下のとおりです:

@example
2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>
@end example

@example
Field       Meaning
--------------------------------------------------------
<XY>        short formatで記述されたステージされたXY値と
            ステージされていないXY値を含む2文字のフィー
            ルドで、変更されていない場合は空白
            ではなく "." で示されます。
<sub>       サブモジュールの状態説明の4文字フィールド。
            "N..." when the entry is not a submodule.
            "S<c><m><u>" when the entry is a submodule.
            <c> is "C" if the commit changed; それ以外 ".".
            <m> is "M" if it has tracked changes; それ以外 ".".
            <u> is "U" if there are untracked changes; それ以外 ".".
<mH>        The octal file mode in HEAD.
<mI>        The octal file mode in the index.
<mW>        The octal file mode in the worktree.
<hH>        The object name in HEAD.
<hI>        The object name in the index.
<X><score>  The rename or copy score (移動またはコピーのソースと
            ターゲット間の類似性のパーセンテージを示します)
            例 "R100" or "C75".
<path>      The pathname.  In a renamed/copied entry, this
            is the target path.
<sep>       When the `-z` option is used, the 2 pathnames are separated
            with a NUL (ASCII 0x00) byte; otherwise, a tab (ASCII 0x09)
            byte separates them.
<origPath>  HEADでのコミットまたはインデックス内のパス名。
            これは、名前が 変更された/コピーされた エントリに
            のみ存在し、名前が変更された/コピーされた
            コンテンツがどこから来たかを示します。
--------------------------------------------------------
@end example

アンマージエントリの形式は以下のとおりです。 最初の文字は、通常の変更されたエントリと区別するための「u」です。

@example
u <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>
@end example

@example
Field       Meaning
--------------------------------------------------------
<XY>        A 2 character field describing the conflict type
            as described in the short format.
<sub>       A 4 character field describing the submodule state
            as described above.
<m1>        The octal file mode in stage 1.
<m2>        The octal file mode in stage 2.
<m3>        The octal file mode in stage 3.
<mW>        The octal file mode in the worktree.
<h1>        The object name in stage 1.
<h2>        The object name in stage 2.
<h3>        The object name in stage 3.
<path>      The pathname.
--------------------------------------------------------
@end example

@noindent

@subheading Other Items

追跡されたエントリに続いて(そして要求された場合)、ワークツリーで見つかった追跡されてない項目と無視される項目に対して、一連の行を出力します。

追跡されていないアイテムの形式は以下のとおりです:

@example
? <path>
@end example

無視されるアイテムの形式は以下のとおりです:

@example
! <path>
@end example

@noindent

@subheading パス名の形式に関する注意と -z

@samp{-z} オプションを指定すると、パス名はクォートされずにそのまま出力され、行はNUL(ASCII 0x00)バイトで終了します。

@samp{-z} オプションを指定しない場合、構成変数 @samp{core.quotePath} で説明されているように、「異常な」文字を含むパス名がクォートされます(git-config(1) を参照)。

@noindent

@chapheading CONFIGURATION

このコマンドは、 @samp{color.status} (または @samp{status.color} — 同じことを意味し、@samp{status.color} は下位互換性のために保持されます)と @samp{color.status.<slot>} 構成変数を尊重して出力を色付けします。

構成変数 @samp{status.relativePaths} がfalseに設定されている場合、表示されるすべてのパスは、現在のディレクトリではなく、リポジトリルートを基準にしています。

@samp{status.submoduleSummary} がゼロ以外の数値またはtrue(それぞれ -1 または 無制限の数値 と同じ)に設定されている場合、サブモジュールの概要が長い形式で有効になり、変更されたサブモジュールのコミットの概要が表示されます(git-submodule(1) の @samp{--summary-limit} 参照)。 @samp{diff.ignoreSubmodules} が @samp{all} に設定されている場合、または @samp{submodule.<name>.ignore=all} であるサブモジュールに対してのみ、statusコマンドからの要約出力が抑制されることに注意してください。 無視されたサブモジュールの概要も表示するには、 @samp{--ignore-submodules=dirty} マンドラインオプションまたは @samp{git submodule summary} コマンドを使用できます。これは同様の出力を表示しますが、これらの設定を尊重しません。

@noindent

@chapheading BACKGROUND REFRESH

デフォルトでは、 @samp{git status} は自動的にインデックスを更新し、作業ツリーからキャッシュされた統計情報を更新し、結果を書き出します。 更新されたインデックスを書き出すことは、厳密には必要ではない最適化です(@samp{status} はそれ自体の値を計算しますが、それらを書き出すことは、後続のプログラムが計算を繰り返さないようにするためだけです)。 @samp{status} がバックグラウンドで実行されると、書き込み中に保持されたロックが他の同時プロセスと競合し、それらが失敗する可能性があります。 バックグラウンドで @samp{status} を実行しているスクリプトは、 @samp{git --no-optional-locks status} の使用を検討する必要があります(詳細については、 git(1) を参照してください)。

@noindent

@chapheading UNTRACKED FILES AND PERFORMANCE

@samp{git status} can be very slow in large worktrees if/when it needs to search for untracked files and directories. There are many configuration options available to speed this up by either avoiding the work or making use of cached results from previous Git commands. There is no single optimum set of settings right for everyone. We’ll list a summary of the relevant options to help you, but before going into the list, you may want to run @samp{git status} again, because your configuration may already be caching @samp{git status} results, so it could be faster on subsequent runs.

@itemize 

@item
The @samp{--untracked-files=no} flag or the
@samp{status.showUntrackedfiles=false} config (see above for both): indicate that @samp{git status} should not report untracked files. This is the fastest option. @samp{git status} will not list the untracked files, so you need to be careful to remember if you create any new files and manually @samp{git add} them.

@item
@samp{advice.statusUoption=false} (see git-config(1)):
setting this variable to @samp{false} disables the warning message given when enumerating untracked files takes more than 2 seconds. In a large project, it may take longer and the user may have already accepted the trade off (e.g. using "-uno" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best.

@item
@samp{core.untrackedCache=true} (see git-update-index(1)):
enable the untracked cache feature and only search directories that have been modified since the previous @samp{git status} command. Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed. This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the @samp{.git/index} file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size.

@item
@samp{core.untrackedCache=true} and @samp{core.fsmonitor=true} or
@samp{core.fsmonitor=<hook_command_pathname>} (see git-update-index(1)): enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous @samp{git status} command. This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories. Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case.
@end itemize

Note that after you turn on the untracked cache and/or FSMonitor features it may take a few @samp{git status} commands for the various caches to warm up before you see improved command times. This is normal.

@noindent

@chapheading SEE ALSO

gitignore(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-stripspace,,,Top
@chapheading Name

git-stripspace — 不要な空白(whitespace)を削除します

@noindent

@chapheading Synopsis

@display
git stripspace [-s | --strip-comments]
git stripspace [-c | --comment-lines]
@end display


@noindent

@chapheading DESCRIPTION

コミットメッセージ・メモ・タグ・ブランチの説明などのテキストを標準の入力から読み取り、Gitで使用されている作法でクリーンアップします。

引数なしの場合、この作法は以下のようになります:

@itemize 

@item
全ての行の末尾の空白(whitespace)を取り除く

@item
複数の連続する空行を1つの空行に折りたたむ

@item
入力の最初と最後から空行を削除

@item
必要に応じて、欠落している @emph{\n} を最後の行に追加します。
@end itemize

入力がすべて空白文字(whitespace characters)で構成されている場合、出力は生成されません。

@strong{注意} これはメタデータのクリーニングを目的としています。リポジトリ内のパッチまたは
ファイルの空白を修正するには、 git-apply(1) の @samp{--whitespace=fix}
モードをお勧めします。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-s} 
@itemx  @samp{--strip-comments} 
コメント文字で始まるすべての行をスキップして削除します(デフォルトは @emph{#} )。

@item  @samp{-c} 
@itemx  @samp{--comment-lines} 
各行の前にコメント文字と空白を付けます。行は自動的に改行で終了します。 空行では、コメント文字のみが先頭に追加されます。
@end table

@noindent

@chapheading EXAMPLES

以下のようなノイズの多い入力があるとします。 @emph{$} は行の終わりを示しています:

@example
|A brief introduction   $
|   $
|$
|A new paragraph$
|# with a commented-out line    $
|explaining lots of stuff.$
|$
|# An old paragraph, also commented-out. $
|      $
|The end.$
|  $
@end example


@emph{git stripspace} を引数無しで実行すると以下のようになります:

@example
|A brief introduction$
|$
|A new paragraph$
|# with a commented-out line$
|explaining lots of stuff.$
|$
|# An old paragraph, also commented-out.$
|$
|The end.$
@end example


@emph{git stripspace --strip-comments} を使うと以下のようになります:

@example
|A brief introduction$
|$
|A new paragraph$
|explaining lots of stuff.$
|$
|The end.$
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node git-submodule,,,Top
@chapheading Name

git-submodule — サブモジュールを初期化、更新、または検査します

@noindent

@chapheading Synopsis

@display
git submodule [--quiet] [--cached]
git submodule [--quiet] add [<options>] [--] <repository> [<path>]
git submodule [--quiet] status [--cached] [--recursive] [--] [<path>…]
git submodule [--quiet] init [--] [<path>…]
git submodule [--quiet] deinit [-f|--force] (--all|[--] <path>…)
git submodule [--quiet] update [<options>] [--] [<path>…]
git submodule [--quiet] set-branch [<options>] [--] <path>
git submodule [--quiet] set-url [--] <path> <newurl>
git submodule [--quiet] summary [<options>] [--] [<path>…]
git submodule [--quiet] foreach [--recursive] <command>
git submodule [--quiet] sync [--recursive] [--] [<path>…]
git submodule [--quiet] absorbgitdirs [--] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

サブモジュールを検査、更新、管理します。

サブモジュールの詳細については、 gitsubmodules(7) を参照してください。

@noindent

@chapheading COMMANDS

引数なしで、既存のサブモジュールのステータスを示します。 サブモジュールで操作を実行するために、いくつかのサブコマンドを使用できます。

@table @asis

@item  add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--depth <depth>] [--] <repository> [<path>] 
現在のプロジェクトの次にコミットされるチェンジセットへの指定のパスで、指定のポジトリをサブモジュールとして追加します。現在のプロジェクトは「スーパープロジェクト」と呼ばれます。

<repository> は、新しいサブモジュールの元リポジトリのURLです。これは、絶対URLまたは、( @samp{./} または @samp{../} で始まる場合、)スーパープロジェクトのデフォルトのリモートリポジトリに相対的な場所のいずれかです(スーパープロジェクト @samp{bar.git} のすぐ隣にあるリポジトリ @samp{foo.git} を指定するには、 @samp{./foo.git} の代わりに @samp{../foo.git} を使用する必要があることに注意してください — 相対 URL の規則に従っていれば、期待通りになるでしょう — Git における相対 URL の評価は相対ディレクトリの場合と同じだからです)。

デフォルトのリモートは、現在のブランチのリモート追跡ブランチのリモートです。そのようなリモート追跡ブランチが存在しないか、または、HEADが切り離されている場合、「origin」がデフォルトのリモートであると見なされます。 スーパープロジェクトにデフォルトのリモートが構成されていない場合、スーパープロジェクトはそれ自身に権限のあるアップストリームであり、代わりに現在の作業ディレクトリが使用されます。

オプションの引数 <path> は、複製されたサブモジュールがスーパープロジェクト内で存在するための相対的な場所です。 <path> が指定されていない場合、ソースリポジトリの正規部分(canonical part)が使用されます(@samp{/path/to/repo.git} の場合は「repo」、 @samp{host.xz:foo/.git} の場合は「foo」)。 <path> が存在し、すでに有効なGitリポジトリである場合、クローンを作成せずにコミット用にステージングされます。 <path> は、 @samp{--name} を使用して論理名を指定しない限り、構成エントリでサブモジュールの論理名としても使用されます。

指定のURLは、スーパープロジェクトのクローンを作成する後続のユーザーが使用できるように @samp{.gitmodules} に記録されます。 URLがスーパープロジェクトのリポジトリに関連して指定されている場合、スーパープロジェクトとサブモジュールのリポジトリは同じ相対位置にまとめられ、スーパープロジェクトのURLのみを指定する必要があると想定します。 git-submoduleは、 @samp{.gitmodules} の相対URLを使用してサブモジュールを正しく検索します。

@item  status [--cached] [--recursive] [--] [<path>…] 
サブモジュールの状態を表示します。これにより、各サブモジュールの現在チェックアウトされているコミットの SHA-1 が、サブモジュールのパスと SHA-1 の @samp{git describe} の出力と共に出力されます。各 SHA-1 には、サブモジュールが初期化されていない場合は @samp{-} 、現在チェックアウトされているサブモジュールコミットが、含まれているリポジトリのインデックスにある SHA-1 と一致しない場合は @samp{+} 、サブモジュールにマージ競合がある場合は @samp{U} 、 という接頭辞が付く可能性があります。

@samp{--cached} が指定されている場合、このコマンドは代わりに、各サブモジュールのスーパープロジェクトに記録されたSHA-1を出力します。

@samp{--recursive} が指定されている場合、このコマンドはネストされたサブモジュールに再帰し、それらのステータスも表示します。

あなたがインデックスまたはHEADに記録されたコミットに関して、現在初期化されているサブモジュールの変更のみに関心がある場合は、 git-status(1) および git-diff(1) もその情報を提供します(サブモジュールの作業ツリーへの変更も報告します)。

@item  init [--] [<path>…] 
インデックスに記録されたサブモジュール(他の場所で追加およびコミットされたサブモジュール)を初期化するには、 @samp{.git/config} に @samp{submodule.$name.url} を設定します。テンプレートとして @samp{.gitmodules} と同じ設定を使用します。URLが相対的な場合は、デフォルトのリモートを使用して解決されます。デフォルトのリモートがない場合、現在のリポジトリはアップストリームであると見なされます。

オプションの <path> 引数は、初期化されるサブモジュールを制限します。パスが指定されておらず、 submodule.active が構成されている場合、アクティブになるように構成されたサブモジュールが初期化されます。そうでない場合、すべてのサブモジュールが初期化されます。

存在する場合は、 @samp{submodule.$name.update} の値もコピーします。このコマンドは、 @samp{.git/config} の既存の情報を変更しません。あなたは次に、ローカル設定用に @samp{.git/config} のサブモジュールクローンURLをカスタマイズして、 @samp{git submodule update} に進むことができます。サブモジュールの場所をカスタマイズする予定がない場合は、明示的な「init」ステップなしで @samp{git submodule update --init} を使用することもできます。

デフォルトのリモートの定義については、add サブコマンドを参照してください。

@item  deinit [-f|--force] (--all|[--] <path>…) 
指定のサブモジュールの登録を解除します。つまり、@samp{.git/config} から @samp{submodule.$name} セクション全体をその作業ツリーとともに削除します。さらに @samp{git submodule update} と @samp{git submodule foreach} と @samp{git submodule sync} を呼び出すと、 未登録のサブモジュールが再び初期化されるまでスキップされるので、作業ツリーにあるサブモジュールのローカルチェックアウトをもうこれ以上やりたくない場合は、このコマンドを使用してください。

コマンドをpathspecなしで実行すると、間違いを防ぐために、すべてを無効にするのではなく、エラーが発生します。

@samp{--force} が指定されている場合、サブモジュールの作業ツリーは、ローカルの変更が含まれていても削除されます。

あなたが本当にリポジトリからサブモジュールを削除してコミットしたい場合は、代わりに git-rm(1) を使用してください。削除オプションについては、 gitsubmodules(7) を参照してください。

@item  update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <repository>] [--depth <depth>] [--recursive] [--jobs <n>] [--[no-]single-branch] [--filter <filter spec>] [--] [<path>…] 
登録されたサブモジュールを更新して、欠落しているサブモジュールのクローンを作成し、サブモジュールで欠落しているコミットをフェッチし、サブモジュールの作業ツリーを更新して、スーパープロジェクトが期待するものと一致させます。「更新」は、コマンドラインオプションと @samp{submodule.<name>.update} 構成変数の値に応じていくつかの方法で実行できます。 コマンドラインオプションは、構成変数よりも優先されます。 どちらも指定されていない場合、「checkout」が実行されます。 コマンドラインと @samp{submodule.<name>.update} 構成の両方でサポートされる「update」手順は以下のとおりです:

@table @asis

@item  checkout 
the commit recorded in the superproject will be
checked out in the submodule on a detached HEAD.
@end table

+
@samp{--force} が指定された場合、サブモジュールは(@samp{git checkout --force} を使って)チェックアウトされます。たとえ含んでいるリポジトリのインデックスで指定されたコミットが、すでにサブモジュールでチェックアウトしたコミットに一致していてもです。

@table @asis

@item  rebase 
サブモジュールの現在のブランチは、
スーパープロジェクトに記録されたコミットに基づいてリベースされます。

@item  merge 
スーパープロジェクトに記録されたコミットは、
サブモジュールの現在のブランチにマージされます。
@end table

以下の「update」手順は、 @samp{submodule.<name>.update} 構成変数を介してのみ使用できます:

@table @asis

@item  custom command 
単一の引数
(スーパープロジェクトに記録されたコミットのsha1)をとる
任意のシェルコマンドが実行されます。
@samp{submodule.<name>.update} が @samp{!command} に設定されている場合、
感嘆符(@samp{!})の後の残りはカスタムコマンドです。

@item  none 
サブモジュールは更新されません。
@end table

サブモジュールがまだ初期化されておらず、 @samp{.gitmodules} に格納されている設定を使用するだけの場合、 あなたは @samp{--init} オプションを使用してサブモジュールを自動的に初期化できます。

@samp{--recursive} が指定されている場合、このコマンドは登録されたサブモジュールに再帰し、その中でネストされたサブモジュールを更新します。

@samp{--filter <filter spec>} が指定されている場合、 指定の部分(partial)クローン・フィルタがサブモジュールに適用されます。 フィルター仕様の詳細については、 git-rev-list(1) を参照してください。

@item  set-branch (-b|--branch) <branch> [--] <path> 
@itemx  set-branch (-d|--default) [--] <path> 
サブモジュールのデフォルトのリモート追跡ブランチを設定します。 @samp{--branch} オプションを使用すると、リモートブランチを指定できます。 @samp{--default} オプションを使用すると、 submodule.<name>.branch 構成キーを削除し、これにより、追跡ブランチはデフォルトでリモートの「HEAD」になります。

@item  set-url [--] <path> <newurl> 
指定されたサブモジュールのURLを <newurl> に設定します。そしてその次に、サブモジュールの新しいリモートURL構成を自動的に同期します。

@item  summary [--cached|--files] [(-n|--summary-limit) <n>] [commit] [--] [<path>…] 
指定のコミット(デフォルトはHEAD)と 作業ツリー/インデックス の間のコミットの概要を表示します。問い合わせがサブモジュールの場合、指定のスーパープロジェクトコミットと、インデックスまたは作業ツリー(@samp{--cached} によって切り替えられる)の間のサブモジュール内の一連のコミットが表示されます。オプション @samp{--files} が指定されている場合は、スーパープロジェクトのインデックスとサブモジュールの作業ツリーの間の、サブモジュールでの一連のコミットを表示します(このオプションでは、 @samp{--cached} オプションを使用したり、明示的なコミットを提供したりすることはできません)。

git-diff(1) で @samp{--submodule=log} オプションを使用すると、その情報も提供されます。

@item  foreach [--recursive] <command> 
チェックアウトされた各サブモジュールで任意のシェルコマンドを評価します。このコマンドは、変数 $name と $sm_path と $displaypath と $sha1 と$toplevel にアクセスできます。$name は、 @samp{.gitmodules} の関連するサブモジュールセクションの名前で、 $sm_path は、直接のスーパープロジェクト(immediate superproject)に記録されているサブモジュールのパスで、 $displaypath には、現在の作業ディレクトリからサブモジュールのルートディレクトリへの相対パスが含まれ、 $sha1 は、直接のスーパープロジェクト(immediate superproject)に記録されているコミットで、 $toplevel は、直接のスーパープロジェクト(immediate superproject)のトップレベルへの絶対パスです。Windowsでの @samp{$PATH} との競合を避けるために、 @samp{$path} 変数は @samp{$sm_path} 変数の非推奨の同義語になっていることに注意してください。スーパープロジェクトで定義されているがチェックアウトされていないサブモジュールは、このコマンドでは無視されます。@samp{--quiet} が指定されていない限り、foreachはコマンドを評価する前に各サブモジュールの名前を出力します。 @samp{--recursive} が指定されている場合、サブモジュールは再帰的にトラバースされます(つまり、指定のシェルコマンドはネストされたサブモジュールでも評価されます)。 サブモジュールのコマンドからゼロ以外の値が返されると、処理が終了(terminate)します。これは、コマンドの最後に @samp{|| :} を追加することでオーバーライドできます。

例として、以下のコマンドは、各サブモジュールのパスと現在チェックアウトされているコミットを表示します:

@example
git submodule foreach 'echo $sm_path `git rev-parse HEAD`'
@end example


@item  sync [--recursive] [--] [<path>…] 
サブモジュールのリモートURL構成設定を @samp{.gitmodules} で指定された値に同期します。 これは、@samp{.git/config} にすでにURLエントリがあるサブモジュールにのみ影響します(これは、初期化されたとき、または新しく追加されたときの場合です)。これは、サブモジュールのURLがアップストリームで変更され、それに応じてローカルリポジトリを更新する必要がある場合に役立ちます。

@samp{git submodule sync} はすべてのサブモジュールを同期しますが、 @samp{git submodule sync -- A} はサブモジュール "A" のみを同期します。

@samp{--recursive} が指定されている場合、このコマンドは登録されたサブモジュールに再帰し、その中でネストされたサブモジュールを同期します。

@item  absorbgitdirs 
サブモジュールのgitディレクトリがサブモジュール内にある場合、サブモジュールのgitディレクトリをそのスーパープロジェクトの @samp{$GIT_DIR/modules} パスに移動し、次に、 @samp{core.worktree} を設定して、gitディレクトリとその作業ディレクトリを接続し、そして、スーパープロジェクトのgitディレクトリに埋め込んだサブモジュールのgitディレクトリを指す .git ファイルを追加します。

独立して複製され、後でサブモジュールまたは古いセットアップとして追加されたリポジトリでは、スーパープロジェクトのgitディレクトリに埋め込まれるのではなく、サブモジュール内にサブモジュールのgitディレクトリがあります。

このコマンドはデフォルトで再帰的に実行されます。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-q} 
@itemx  @samp{--quiet} 
エラーメッセージのみを出力します。

@item  @samp{--progress} 
このオプションは、addおよびupdateコマンドにのみ有効です。 @samp{-q} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、標準エラーストリームが端末に送信されていない場合でも、進行状況を強制します。

@item  @samp{--all} 
このオプションは、deinitコマンドに対してのみ有効です。 作業ツリーのすべてのサブモジュールの登録を解除します。

@item  @samp{-b <branch>} 
@itemx  @samp{--branch <branch>} 
サブモジュールとして追加するリポジトリのブランチ。ブランチの名前は、@samp{update --remote} の @samp{.gitmodules} に @samp{submodule.<name>.branch} として記録されます。 特別な値 @samp{.} は、サブモジュール内のブランチの名前が現在のリポジトリ内の現在のブランチと同じ名前でなければならないことを示すために使用されます。オプションが指定されていない場合、デフォルトでリモートの「HEAD」になります。

@item  @samp{-f} 
@itemx  @samp{--force} 
このオプションは、addとdeinitとupdateコマンドにのみ有効です。addを実行するときは、無視されるサブモジュールパスの追加を許可します。 deinitを実行するときは、ローカルの変更が含まれている場合でも、サブモジュールの作業ツリーが削除されます。 updateを実行するときは(checkout手順でのみ有効)、別のコミットに切り替えるときにサブモジュールのローカル変更を破棄し、そして、含まれているリポジトリのインデックスにリストされているコミットがサブモジュールでチェックアウトされたコミットと一致する場合でも、常にサブモジュールでチェックアウト操作を実行します。

@item  @samp{--cached} 
このオプションは、statusコマンドとsummaryコマンドにのみ有効です。これらのコマンドは通常、サブモジュールHEADにあるコミットを使用しますが、このオプションを使用すると、代わりにインデックスに格納されているコミットが使用されます。

@item  @samp{--files} 
このオプションは、summaryコマンドにのみ有効です。 このコマンドを使用すると、インデックス内のコミットと、サブモジュールHEAD内のコミットが比較されます。

@item  @samp{-n} 
@itemx  @samp{--summary-limit} 
このオプションは、summaryコマンドにのみ有効です。 サマリーサイズ(合計で表示されるコミットの数)を制限します。 0を指定すると、要約が無効になります。 負の数は無制限(デフォルト)を意味します。この制限は、変更されたサブモジュールにのみ適用されます。 追加/削除/タイプ変更された サブモジュールのサイズは常に1に制限されます。

@item  @samp{--remote} 
このオプションは、updateコマンドに対してのみ有効です。 スーパープロジェクトの記録されたSHA-1を使用してサブモジュールを更新する代わりに、サブモジュールのリモート追跡ブランチのステータスを使用します。 使用されるリモートはブランチのリモート(@samp{branch.<name>.remote})で、デフォルトは @samp{origin} です。 使用されるリモートブランチのデフォルトはリモートの @samp{HEAD} ですが、ブランチ名は、 @samp{.git / config} または @samp{.gitmodules} のいずれかで @samp{submodule.<name>.branch} オプションを設定することでオーバーライドできます(@samp{.git / config} が優先されます)。

これは、サポートされている更新手順(@samp{--checkout} 、@samp{--rebase} など)のいずれでも機能します。唯一の変更は、ターゲットSHA-1のソースです。 たとえば、 @samp{submodule update --remote --merge} はアップストリームのサブモジュールの変更をサブモジュールにマージし、 @samp{submodule update --merge} はスーパープロジェクトのgitlinkの変更をサブモジュールにマージします。

現在の追跡ブランチの状態を確認するために、 @samp{update --remote} はSHA-1を計算する前にサブモジュールのリモートリポジトリをフェッチします。フェッチしたくない場合は、 @samp{submodule update --remote --no-fetch} を使用する必要があります。

このオプションを使用して、アップストリームサブプロジェクトからの変更をサブモジュールの現在のHEADと統合します。または、サブモジュールから @samp{git pull} を実行することもできます。これは、リモートブランチ名を除いて同等です。@samp{update --remote} はデフォルトのアップストリームリポジトリと @samp{submodule.<name>.branch} を使用し、 @samp{git pull} はサブモジュールの @samp{branch.<name>.merge} を使用します。スーパープロジェクトでデフォルトのアップストリームブランチを配布する場合は @samp{submodule.<name>.branch} を、サブモジュール自体で作業しているときによりネイティブな感じが必要な場合は @samp{branch.<name>.merge} を使用してください。

@item  @samp{-N} 
@itemx  @samp{--no-fetch} 
このオプションは、updateコマンドに対してのみ有効です。リモートサイトから新しいオブジェクトをフェッチしません。

@item  @samp{--checkout} 
このオプションは、updateコマンドに対してのみ有効です。サブモジュールの切り離されたHEAD(detached HEAD)のスーパープロジェクトに記録されたコミットをチェックアウトします。これはデフォルトの動作です。このオプションの主な用途は、 @samp{checkout} 以外の値に設定されたときに @samp{submodule.$name.update} をオーバーライドすることです。 キー @samp{submodule.$name.update} が明示的に設定されていないか、 @samp{checkout} に設定されている場合、このオプションが暗黙に指定されています。

@item  @samp{--merge} 
このオプションは、updateコマンドに対してのみ有効です。 スーパープロジェクトに記録されたコミットをサブモジュールの現在のブランチにマージします。 このオプションを指定すると、サブモジュールのHEADは切り離されません。 マージの失敗によりこの処理が妨げられる場合は、通常の競合解決ツールを使用して、サブモジュール内で発生する競合を解決する必要があります。 キー @samp{submodule.$name.update} が @samp{merge} に設定されている場合、このオプションが暗黙に指定されます。

@item  @samp{--rebase} 
このオプションは、updateコマンドに対してのみ有効です。 現在のブランチをスーパープロジェクトに記録されたコミットにリベースします。 このオプションを指定すると、サブモジュールのHEADは切り離されません。 マージの失敗によりこのプロセスが妨げられる場合は、 git-rebase(1) を使用してこれらの失敗を解決する必要があります。 キー @samp{submodule.$name.update} が @samp{rebase} に設定されている場合、このオプションが暗黙に指定されます。

@item  @samp{--init} 
このオプションは、updateコマンドに対してのみ有効です。更新する前に、これまで @samp{git submodule init} が呼び出されていないすべてのサブモジュールを初期化します。

@item  @samp{--name} 
このオプションは、addコマンドに対してのみ有効です。 サブモジュールの名前を、デフォルトのパスではなく、指定の文字列に設定します。 名前はディレクトリ名として有効である必要があり、 @samp{/} で終わらせることはできません。

@item  @samp{--reference <repository>} 
このオプションは、addとupdateコマンドにのみ有効です。これらのコマンドでは、リモートリポジトリのクローンを作成する必要がある場合があります。その場合、このオプションを git-clone(1) コマンドに渡します。

@strong{注意}: git-clone(1) の @samp{--reference} と @samp{--shared} と @samp{--dissociate}
オプションに関するNOTEを注意深く読んでいない限り、
このオプションを使用しないでください。

@item  @samp{--dissociate} 
このオプションは、addとupdateコマンドにのみ有効です。これらのコマンドでは、リモートリポジトリのクローンを作成する必要がある場合があります。その場合、このオプションを git-clone(1) コマンドに渡します。

@strong{注意}: @samp{--reference} オプションについては NOTE を参照してください。

@item  @samp{--recursive} 
このオプションは、foreachとupdateとstatusとsyncコマンドにのみ有効です。サブモジュールを再帰的にトラバースします。この操作は、現在のリポジトリのサブモジュールだけでなく、それらのサブモジュール内のネストされたサブモジュール(など)でも実行されます。

@item  @samp{--depth} 
このオプションは、addとupdateコマンドに有効です。 指定のリビジョン数に切り捨てられた履歴を持つ「浅い」クローン(shallow clone)を作成します。 git-clone(1) を参照してください。

@item  @samp{--[no-]recommend-shallow} 
このオプションは、updateコマンドに対してのみ有効です。サブモジュールの初期クローンは、デフォルトで @samp{.gitmodules} ファイルによって提供される推奨される @samp{submodule.<name>.shallow} を使用します。 提案を無視するには、@samp{--no-recommend-shallow} を使用します。

@item  @samp{-j <n>} 
@itemx  @samp{--jobs <n>} 
このオプションは、updateコマンドに対してのみ有効です。多くのジョブと並行して新しいサブモジュールのクローンを作成します。デフォルトは @samp{submodule.fetchJobs} オプションです。

@item  @samp{--[no-]single-branch} 
このオプションは、updateコマンドに対してのみ有効です。 HEAD または、 @samp{--branch} で指定されたブランチは、更新中に1つのブランチのみを複製します

@item  <path>… 
サブモジュールへのパス。これを指定すると、指定したパスで見つかったサブモジュールでのみ動作するようにコマンドが制限されます。(この引数はaddでは必須です)。
@end table

@noindent

@chapheading FILES

サブモジュールを初期化するとき、含まれているリポジトリの最上位ディレクトリにある @samp{.gitmodules} ファイルを使用して、各サブモジュールのURLを検索します。 このファイルは、 @samp{$GIT_DIR/config} と同じ方法でフォーマットする必要があります。各サブモジュールURLのキーは、「submodule.$name.url」です。 詳細については、 gitmodules(5) を参照してください。

@noindent

@chapheading SEE ALSO

gitsubmodules(7), gitmodules(5).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-svn,,,Top
@chapheading Name

git-svn — SubversionリポジトリとGit間の双方向操作

@noindent

@chapheading Synopsis

@display
git svn <command> [<options>] [<arguments>]
@end display


@noindent

@chapheading DESCRIPTION

@samp{git svn} は、SubversionとGitの間のチェンジセットのための単純な水道管です。 SubversionとGitリポジトリ間の双方向の変更フローを提供します。

@samp{git svn} は、 @samp{--stdlayout} オプションを使用して、一般的な「trunk/branches/tags」レイアウトに従って、標準のSubversionリポジトリを追跡できます。 また、 @samp{-T}/@samp{-t}/@samp{-b} オプションを使用して、任意のレイアウトのブランチとタグを追跡することもできます(以下の「initコマンド」のオプションおよび「cloneコマンド」も参照してください)。

(上記の方法のいずれかを使用して)Subversionリポジトリを追跡すると、Gitリポジトリは「fetch」コマンドによってSubversionから更新され、Subversionは「dcommit」コマンドによってGitから更新されます。

@noindent

@chapheading COMMANDS

@table @asis

@item  @samp{init} 
@samp{git svn} の追加のメタデータディレクトリを使用して空のGitリポジトリを初期化します。 Subversion URLは、コマンドライン引数として、または @samp{-T}/@samp{-t}/@samp{-b} への完全なURL引数として指定できます。 オプションで、操作するターゲットディレクトリを2番目の引数として指定できます。 通常、このコマンドは現在のディレクトリを初期化します。

@table @asis

@item  @samp{-T<trunk_subdir>} 
@itemx  @samp{--trunk=<trunk_subdir>} 
@itemx  @samp{-t<tags_subdir>} 
@itemx  @samp{--tags=<tags_subdir>} 
@itemx  @samp{-b<branches_subdir>} 
@itemx  @samp{--branches=<branches_subdir>} 
@itemx  @samp{-s} 
@itemx  @samp{--stdlayout} 
これらは、initのコマンドラインオプションです。 これらの各フラグは、相対リポジトリパス(@samp{-tags=project/tags})または完全なURL(@samp{--tags=https://foo.org/project/tags})を指すことができます。 Subversionリポジトリがタグまたはブランチを複数のパスの下に配置する場合は、複数の @samp{--tags} および/または @samp{--branches} オプションを指定できます。 オプション @samp{--stdlayout} は、トランク、タグ、ブランチを相対パスとして設定する簡単な方法です。これは、Subversionのデフォルトです。 他のオプションのいずれかが同様に指定されている場合、それらが優先されます。

@item  @samp{--no-metadata} 
[svn-remote] 設定で @samp{noMetadata} オプションを設定します。 このオプションはお勧めしません。このオプションを使用する前に、このマンページの「svn.noMetadata」セクションをお読みください。

@item  @samp{--use-svm-props} 
[svn-remote]設定で @samp{useSvmProps} オプションを設定します。

@item  @samp{--use-svnsync-props} 
[svn-remote] 設定で @samp{useSvnsyncProps} オプションを設定します。

@item  @samp{--rewrite-root=<URL>} 
[svn-remote]設定で @samp{rewriteRoot} オプションを設定します。

@item  @samp{--rewrite-uuid=<UUID>} 
[svn-remote]設定で @samp{rewriteUUID} オプションを設定します。

@item  @samp{--username=<user>} 
SVNが認証を処理する転送(http や https やプレーンsvn)の場合に、ユーザー名を指定します。 他の転送(例: @samp{svn+ssh://})の場合、URLにユーザー名を含める必要があります。例： @samp{svn+ssh://foo@@svn.bar.com/project}

@item  @samp{--prefix=<prefix>} 
これにより、トランク/ブランチ/タグ が指定されている場合に、リモートの名前の前に付加される接頭辞を指定できます。 接頭辞(prefix)には自動的に末尾のスラッシュが含まれ無いため、必要に応じて引数に必ず末尾のスラッシュを含めてください。 @samp{--branches}/@samp{-b} を指定する場合、接頭辞には末尾のスラッシュを含める必要があります。 SVN追跡refは @samp{refs/remotes/$prefix/*} に配置されるため、(末尾にスラッシュを付けた)接頭辞を設定することを強くお勧めします。これは、Git独自のリモート追跡refレイアウトと互換性があります(@samp{refs/remotes/$remote/*})。 接頭辞の設定は、共通のリポジトリを共有する複数のプロジェクトを追跡する場合にも役立ちます。 デフォルトでは、接頭辞は @samp{origin/} に設定されています。

@quotation

@strong{Note}

Git v2.0 より前は、デフォルトの接頭辞は "" (接頭辞無し)でした。 これは、SVN追跡refが @samp{refs/remotes/*} に配置されたことを意味します。これは、Git自体のリモート追跡refの編成方法と互換性がありません。 それでも古いデフォルトが必要な場合は、コマンドラインで @samp{--prefix ""} を渡すことで取得できます(Perlの Getopt::Long is < v2.37 の場合、 @samp{--prefix=""} は機能しない可能性があります)。
@end quotation

@item  @samp{--ignore-refs=<regex>} 
@samp{init} または @samp{clone} に渡されると、この正規表現は構成キー(config key)として保持されます。 @samp{--ignore-refs} の説明については、「fetch」コマンドを参照してください。

@item  @samp{--ignore-paths=<regex>} 
@samp{init} または` clone` に渡されると、この正規表現は構成キー(config key)として保持されます。 @samp{--ignore-paths} の説明については、「fetch」コマンドを参照してください。

@item  @samp{--include-paths=<regex>} 
@samp{init} または @samp{clone} に渡されると、この正規表現は構成キー(config key)として保持されます。 @samp{--include-paths} の説明については、「fetch」コマンドを参照してください。

@item  @samp{--no-minimize-url} 
(@samp{--stdlayout} または @samp{--branches} または @samp{--tags} オプションを使用して、)複数のディレクトリを追跡する場合、git svnはSubversionリポジトリのルート(または許可されている最高レベル)への接続を試みます。 このデフォルトでは、プロジェクト全体がリポジトリ内で移動された場合に履歴をより適切に追跡できますが、読み取りアクセス制限が設定されているリポジトリで問題が発生する可能性があります。 @samp{--no-minimize-url} を渡すと、git svnは、上位レベルのディレクトリに接続しようとせずに、URLをそのまま受け入れることができます。 このオプションは、1つの URL/ブランチ のみが追跡される場合はデフォルトでオフになっています(ほとんど効果ありません)。
@end table

@item  @samp{fetch} 
私達が追跡しているSubversionリモートからフェッチされていないリビジョンを取得します。 $GIT_DIR/config ファイルの [svn-remote "…"] セクションの名前は、オプションのコマンドライン引数として指定できます。

これにより、必要に応じてrev_mapが自動的に更新されます(詳細については、以下の「FILES」セクションの @samp{$GIT_DIR/svn/\**/.rev_map.*} を参照してください)。

@table @asis

@item  @samp{--localtime} 
Gitのコミット時間をUTCではなくローカルタイムゾーンで保存します。 これにより、「git log」は(`--date=local`がなくても)、「svn log」がローカルタイムゾーンで表示されるのと同じ時間を表示します。

これは、クローンを作成したSubversionリポジトリとの相互運用を妨げることはありませんが、ローカルGitリポジトリを他の誰かのローカルGitリポジトリと相互運用できるようにする場合は、このオプションを使用しないか、両方で同一のローカルタイムゾーンを使用する必要があります。

@item  @samp{--parent} 
現在のHEADのSVNの親からのみフェッチします。

@item  @samp{--ignore-refs=<regex>} 
Perlの正規表現にマッチするブランチまたはタグのrefを無視します。 @samp{^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$} のような「negative look-ahead assertion」(負の先読みアサーション)は、特定のrefのみを許可するために使用できます。

@display
config key: svn-remote.<name>.ignore-refs
@end display


ignore-refs 構成キーが設定されていて、コマンドラインオプションも指定されている場合は、両方の正規表現が使用されます。

@item  @samp{--ignore-paths=<regex>} 
これにより、SVNからのチェックアウトから一致するすべてのパスをスキップするPerl正規表現を指定できます。 @samp{--ignore-paths} オプションは、特定のリポジトリのすべての @samp{fetch} (@samp{clone}, @samp{dcommit}, @samp{rebase} などによる自動フェッチを含む)にマッチする必要があります。

@display
config key: svn-remote.<name>.ignore-paths
@end display


ignore-paths 構成キーが設定されていて、コマンドラインオプションも指定されている場合は、両方の正規表現が使用されます。

例:

@table @asis

@item  フェッチするたびに @samp{doc*} ディレクトリをスキップします 
@example
--ignore-paths="^doc"
@end example


@item  第1レベルのディレクトリの「branches」と「tags」をスキップします 
@example
--ignore-paths="^[^/]+/(?:branches|tags)"
@end example

@end table

@item  @samp{--include-paths=<regex>} 
これにより、SVNのチェックアウトからのマッチするパスのみを含めるPerl正規表現を指定できます。 @samp{--include-paths} オプションは、特定のリポジトリのすべての @samp{fetch}(@samp{clone}, @samp{dcommit}, @samp{rebase} などによる自動フェッチを含む)に一致する必要があります。 @samp{--ignore-paths} は @samp{--include-paths} よりも優先されます。

@display
config key: svn-remote.<name>.include-paths
@end display


@item  @samp{--log-window-size=<n>} 
Subversionの履歴をスキャンするときに、リクエストごとに<n>個のログエントリを取得します。 デフォルトは100です。非常に大きなSubversionリポジトリの場合、「クローン」/「フェッチ」 が妥当な時間で完了するには、より大きな値が必要になる場合があります。 ただし、値が大きすぎると、メモリ使用量が増え、リクエストののタイムアウトが発生する可能性があります。
@end table

@item  @samp{clone} 
@samp{init} と @samp{fetch} を実行します。 渡されたURLのベース名に基づいてディレクトリを自動的に作成します。 または2番目の引数が渡された場合はディレクトリを作成し、その中で動作します。 @samp{--fetch-all} と @samp{--parent} を除いて、 @samp{init} と @samp{fetch} コマンドが受け入れるすべての引数を受け入れます。 リポジトリのクローンが作成されると、「fetch」コマンドは作業ツリーに影響を与えることなくリビジョンを更新できるようになります。 「rebase」コマンドは、作業ツリーを最新の変更で更新できるようになります。

@table @asis

@item  @samp{--preserve-empty-dirs} 
Subversionからフェッチされた空のディレクトリごとに、ローカルGitリポジトリにプレースホルダーファイルを作成します。 これには、Subversionリポジトリ内のすべてのエントリを削除することによって空になるディレクトリが含まれます(ディレクトリ自体は削除されません)。 プレースホルダーファイルも追跡され、不要になったときに削除されます。

@item  @samp{--placeholder-filename=<filename>} 
@samp{--preserve-empty-dirs} によって作成されたプレースホルダーファイルの名前を設定します。 デフォルトは @samp{.gitignore} です。
@end table

@item  @samp{rebase} 
これにより、現在のHEADのSVN親からリビジョンがフェッチされ、現在の(SVNにコミットされていない)作業がリベースされます。

これは @samp{svn update} または @samp{git pull} と同様に機能しますが、 @samp{git svn} でのコミットを容易にするために @samp{git merge} ではなく @samp{git rebase} で線形履歴を保持する点が異なります。

これは、 @samp{git svn fetch} や @samp{git rebase} が受け入れるすべてのオプションを受け入れます。 ただし、 @samp{--fetch-all} は現在の[svn-remote]からのみフェッチし、すべての[svn-remote]定義からフェッチするわけではありません。

@samp{git rebase} と同様です。これには、作業ツリーがクリーンであり、コミットされていない変更がないことが必要です。

これにより、必要に応じてrev_mapが自動的に更新されます(詳細については、以下の「FILES」セクションの @samp{$GIT_DIR/svn/\**/.rev_map.*} を参照してください)。

@table @asis

@item  @samp{-l} 
@itemx  @samp{--local} 
リモートでフェッチしないでください。 アップストリームSVNから最後にフェッチされたコミットに対してのみ @samp{git rebase} を実行します。
@end table

@item  @samp{dcommit} 
現在のブランチからの各diffを直接SVNリポジトリにコミットしてから、リベースまたはリセットします(SVNとヘッドの間にdiffがあるかどうかによって異なります)。 これにより、GitのコミットごとにSVNにリビジョンが作成されます。

オプションのGitブランチ名(またはGitコミットオブジェクト名)が引数として指定されている場合、サブコマンドは現在のブランチではなく、指定されたブランチで機能します。

@samp{set-tree} (下記)よりも @samp{dcommit} の使用が推奨されます。

@table @asis

@item  @samp{--no-rebase} 
コミット後にリベースまたはリセットしないでください。

@item  @samp{--commit-url <URL>} 
このSVN URL(フルパス)にコミットします。 これは、ユーザーが後でコミット用の代替転送方法(例えば @samp{svn+ssh://} や @samp{https://})へのアクセスを許可された場合に、ある転送方法(例えば、匿名読み取りの場合は @samp{svn://} または @samp{http://})で作成された既存の @samp{git svn} リポジトリを再利用できるようにすることを目的としています。

@display
config key: svn-remote.<name>.commiturl
config key: svn.commiturl (overwrites all svn-remote.<name>.commiturl options)
@end display


注意: commiturl構成キーのSVN URLにはSVNブランチが含まれていることに注意してください。 SVNリポジトリ全体のコミットURLを設定する場合は、代わりに @samp{svn-remote.<name>.pushurl} を使用してください。

このオプションを他の目的(それがナニカは聞かないで下さい)で使用することは、全く全然欠片もお勧めできません。

@item  @samp{--mergeinfo=<mergeinfo>} 
dcommit中に指定されたマージ情報を追加します(たとえば @samp{--mergeinfo="/branches/foo:1-10"})。 すべてのsvnサーバーバージョンはこの情報を(プロパティとして)保存でき、バージョン1.5以降のsvnクライアントはそれを利用できます。 複数のブランチからのマージ情報を指定するには、ブランチの間に単一の空白文字を使用します(@samp{--mergeinfo="/branches/foo:1-10 /branches/bar:3,5-6,8"})

@display
config key: svn.pushmergeinfo
@end display


このオプションにより、git-svnは、可能な場合、SVNリポジトリの svn:mergeinfo プロパティに自動的にデータを入力しようとします。 現在、これは、最初の親を除くすべての親がすでにSVNにプッシュされている非早送りマージをコミットする場合にのみ実行できます。

@item  @samp{--interactive} 
パッチセットが実際にSVNに送信される必要があることを確認するようにユーザーに問い合わせます。 パッチごとに、「yes」(このパッチを受け入れる)、または「no」(このパッチを破棄する)、または「all」(すべてのパッチを受け入れる)、または「quit」と答えることができます。

@samp{git svn dcommit} は、回答が「no」または「quit」の場合、SVNに何もコミットせずに、すぐに終了します。
@end table

@item  @samp{branch} 
SVNリポジトリにブランチを作成します。

@table @asis

@item  @samp{-m} 
@itemx  @samp{--message} 
コミットメッセージを指定できます。

@item  @samp{-t} 
@itemx  @samp{--tag} 
@samp{git svn init} で指定された branchs_subdir の代わりに、 tags_subdir を使用してタグを作成します。

@item  @samp{-d<path>} 
@itemx  @samp{--destination=<path>} 
@samp{init} または @samp{clone} コマンドに複数の @samp{--branches}(または @samp{--tags})オプションが指定されている場合は、SVNリポジトリに作成するブランチ(またはタグ)の場所を指定する必要があります。 <path> はブランチやタグを作成するために使用するパスを指定し、設定されたブランチやタグのrefspecsのどれかの左側のパターンに一致する必要があります。

@display
git config --get-all svn-remote.<name>.branches
git config --get-all svn-remote.<name>.tags
@end display


ここで、 <name> は、@samp{init} の @samp{-R} オプションで指定されたSVNリポジトリーの名前です(またはデフォルトでは @samp{svn})。

@item  @samp{--username} 
コミットを実行するSVNユーザー名を指定します。 このオプションは、 @samp{username} 構成プロパティをオーバーライドします。

@item  @samp{--commit-url} 
指定のURLを使用して、宛先のSubversionリポジトリに接続します。 これは、ソースSVNリポジトリが読み取り専用である場合に役立ちます。 このオプションは、構成プロパティ @emph{commiturl} をオーバーライドします。

@example
git config --get-all svn-remote.<name>.commiturl
@end example

@item  @samp{--parents} 
親フォルダを作成します。 このパラメーターは、 @samp{svn cp} コマンドの @samp{--parents} パラメーターと同等であり、非標準のリポジトリーレイアウトで役立ちます。
@end table

@item  @samp{tag} 
SVNリポジトリにタグを作成します。 これは @samp{branch -t} の省略形です。

@item  @samp{log} 
これにより、svnユーザーが @samp{-r}/@samp{-revision} 番号を参照するときに、svnログメッセージを簡単に検索できるようになります。

@samp{svn log} では以下の機能がサポートされています:

@table @asis

@item  @samp{-r <n>[:<n>]} 
@itemx  @samp{--revision=<n>[:<n>]} 
数値以外の、 HEAD, NEXT, BASE, PREV, 等 はサポートされていません。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
@samp{svn log} の @samp{--verbose} 出力と完全互換性ではありませんが、かなり近いです。

@item  @samp{--limit=<n>} 
このオプションは @samp{--max-count} と同一ではなく、 マージされた/除外された コミットをカウントしません

@item  @samp{--incremental} 
supported(訳注: 原文ママ)
@end table

新機能:

@table @asis

@item  @samp{--show-commit} 
Gitコミットのsha1も表示します

@item  @samp{--oneline} 
私たちのバージョンの @samp{--pretty=oneline}
@end table

@quotation

@strong{Note}

SVN自体はUTCでのみ時間を保存し、他には何も保存しません。 通常のsvnクライアントは、UTC時刻を現地時間(local time)に(または TZ= 環境変数に基づいて)変換します。 このコマンドの振る舞いは同一です。
@end quotation

その他の引数はすべて @samp{git log} に直接渡されます

@item  @samp{blame} 
ファイルの各行を最後に変更したリビジョンと作成者を表示します。 このモードの出力は、デフォルトで @samp{svn blame} の出力と書式の互換があります。 SVN blameコマンドと同様に、作業ツリー内のローカルのコミットされていない変更は無視されます。 HEADリビジョンのファイルのバージョンに注釈を付けます。 不明な引数は「git blame」に直接渡されます。

@table @asis

@item  @samp{--git-format} 
@samp{git blame} と同じ形式で出力を生成しますが、Gitコミットハッシュの代わりにSVNリビジョン番号を使用します。 このモードでは、SVNにコミットされていない変更(ローカルの作業コピー編集を含む)は リビジョン0 として表示されます。
@end table

@item  @samp{find-rev} 
@samp{rN} の形式のSVNリビジョン番号を指定すると、対応するGitコミットハッシュを返します(オプションで、検索するブランチを指定するためにツリーっぽい何かの後に続けることができます)。 ツリーっぽい何かの場合は、対応するSVNリビジョン番号を返します。

@table @asis

@item  @samp{-B} 
@itemx  @samp{--before} 
SVNリビジョンが与えられた場合、完全一致は要求しません。代わりに、指定されたリビジョンでの(現在のブランチ上の)SVNリポジトリの状態に対応するコミットを探します。

@item  @samp{-A} 
@itemx  @samp{--after} 
SVNリビジョンが与えられた場合、完全一致を要求しません。 完全一致がない場合は、履歴内で前方に検索する最も近い一致を返します。
@end table

@item  @samp{set-tree} 
あなたは、このコマンドの代わりに「dcommit」の使用を検討する必要があります。 これは指定の コミットまたはツリーオブジェクト をSVNにコミットします。 これは、インポートされたフェッチデータが最新であることに依存しています。 よって、SVNにコミットするときにパッチを適用する試みはまったく行われず、ツリーまたはコミットで指定されたファイルでファイルが上書きされるだけです。 すべてのマージは、「git svn」機能とは独立して行われたと見なされます。

@item  @samp{create-ignore} 
ディレクトリの svn:ignore プロパティを再帰的に検索し、一致する .gitignore ファイルを作成します。 結果のファイルはコミットされるよう、ステージングされますが、コミットは行われません。 @samp{-r}/@samp{-revision} を使用して、特定のリビジョンを参照します。

@item  @samp{show-ignore} 
ディレクトリの @samp{svn:ignore} プロパティを再帰的に検索して一覧表示します。 この出力は、 @samp{$GIT_DIR/info/exclude} ファイルに追加するのに適しています。

@item  @samp{mkdirs} 
@samp{$GIT_DIR/svn/<refname>/unhandled.log} ファイルの情報に基づいてコアGitが追跡できない空のディレクトリを再作成しようとします。 「git svn clone」や「git svn rebase」を使用すると、空のディレクトリが自動的に再作成されるため、「mkdirs」は「git checkout」や「git reset」などのコマンドの後に使用することを目的としています。 (詳細については、 @samp{svn-remote.<name>.automkdirs} 構成ファイルオプションを参照してください。)

@item  @samp{commit-diff} 
コマンドラインで指定された2つのツリーっぽい引数のdiffをコミットします。 このコマンドは、 @samp{git svn init} されたリポジトリ内にあることに依存していません。 このコマンドは、 (a)差分する元のツリー、(b)新しいツリーの結果、(c)ターゲットのSubversionリポジトリのURL、の3つの引数を取ります。 @samp{git svn} 対応リポジトリ(@samp{git svn} で @samp{init} されているリポジトリ)から作業している場合は、最後の引数(URL)を省略できます。 これには、 @samp{-r<revision>} オプションが必要です。

コミットメッセージは、 @samp{-m} または @samp{-F} オプションを使用して直接提供されるか、2番目のツリーっぽい何かがそのようなオブジェクトを示す場合はタグまたはコミットから間接的に提供されるか、エディターを呼び出すことによって要求されます(下記 @samp{--edit} オプション参照)。

@table @asis

@item  @samp{-m <msg>} 
@itemx  @samp{--message=<msg>} 
指定された @samp{msg} をコミットメッセージとして使用します。 このオプションは、@samp{--edit} オプションを無効にします。

@item  @samp{-F <filename>} 
@itemx  @samp{--file=<filename>} 
指定されたファイルからコミットメッセージを取得します。 このオプションは @samp{--edit} オプションを無効にします。
@end table

@item  @samp{info} 
@samp{svn info} が提供するものと同様のファイルまたはディレクトリに関する情報を表示します。 現在のところ @samp{-r}/@samp{-revision} 引数はサポートしていません。 @samp{--url} オプションを使用すると、「URL:」フィールドの値のみを出力します。

@item  @samp{proplist} 
特定のファイルまたはディレクトリについてSubversionリポジトリに保存されているプロパティを一覧表示します。 @samp{-r}/@samp{-revision} を使用して、特定のSubversionリビジョンを参照します。

@item  @samp{propget} 
ファイルの最初の引数として指定されたSubversionプロパティを取得します。 特定のリビジョンは @samp{-r}/@samp{-revision} で指定できます。

@item  @samp{propset} 
最初の引数として与えられた Subversion のプロパティを、3番目の引数として与えられたファイルに対して2番目の引数として与えられた値に設定します。

例:

@example
git svn propset svn:keywords "FreeBSD=%H" devel/py-tipper/Makefile
@end example


これにより、ファイル @samp{devel/py-tipper/Makefile} のプロパティ @samp{svn:keywords} が @samp{FreeBSD=%H} に設定されます。

@item  @samp{show-externals} 
Subversionのexternalsを表示します。 @samp{-r}/@samp{-revision} を使用して、特定のリビジョンを指定します。

@item  @samp{gc} 
@samp{$GIT_DIR/svn/<refname>/unhandled.log} ファイルを圧縮し、 @samp{$GIT_DIR/svn/<refname>/index} ファイル達を削除します。

@item  @samp{reset} 
@samp{fetch} の効果を元に戻し、指定されたリビジョンに戻します。 これにより、SVNリビジョンを「再フェッチ」できます。 通常、SVNリビジョンの内容は決して変更されるべきではなく、「リセット」は必要ありません。 ただし、SVN権限が変更された場合、または @samp{--ignore-paths} オプションを変更した場合、「フェッチ」が「not found in commit」(コミットで見つかりません)(ファイルが以前に表示されなかった)または「checksum mismatch」(チェックサムの不一致)(変更を見逃した)で失敗する場合があります。 問題のあるファイルを永久に無視できない場合(@samp{--ignore-pathsを使用}）、リポジトリを修復する唯一の方法は「reset」を使用することです。

rev_map と @samp{refs/remotes/git-svn} のみが変更されます(詳細については、下記「ファイル」セクションの「$GIT_DIR/svn/**/.rev_map.*」を参照してください)。 @samp{reset} の後に @samp{fetch} を続け、次に @samp{git reset} または @samp{git rebase} を実行して、ローカルブランチを新しいツリーに移動します。

@table @asis

@item  @samp{-r <n>} 
@itemx  @samp{--revision=<n>} 
保持する最新のリビジョンを指定します。 それ以降のリビジョンはすべて破棄されます。

@item  @samp{-p} 
@itemx  @samp{--parent} 
指定のリビジョンも破棄し、代わりに最も近い親を保持します。

@item  例: 
「master」にローカルの変更があると仮定しますが、あなたは「r2」を再フェッチする必要があります。

@example
    r1---r2---r3 remotes/git-svn
                \
                 A---B master
@end example


そもそも「r2」が不完全になる原因となったignore-pathsまたはSVNパーミッションの問題を修正します。 それから:

@display
git svn reset -r2 -p
git svn fetch
@end display


@example
    r1---r2'--r3' remotes/git-svn
      \
       r2---r3---A---B master
@end example


次に、「master」を「git rebase」で修正します。 「git merge」を使用してはいけません。「git merge」を使用すると、履歴が将来の「dcommit」と互換性がなくなります。

@display
git rebase --onto remotes/git-svn A^ master
@end display


@example
    r1---r2'--r3' remotes/git-svn
                \
                 A'--B' master
@end example

@end table
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--shared[=(false|true|umask|group|all|world|everybody)]} 
@itemx  @samp{--template=<template-directory>} 
@samp{init} コマンドでのみ使用されます。 これらは @samp{git init} に直接渡されます。

@item  @samp{-r <arg>} 
@itemx  @samp{--revision <arg>} 
@samp{fetch} コマンドで使用されます。

これにより、部分的な(partial)/一部が取り除かれた(cauterized) 履歴のリビジョン範囲をサポートできます。 $NUMBER, $NUMBER1:$NUMBER2 (数値範囲) と $NUMBER:HEAD と $NUMBER：HEAD と BASE:$NUMBER はすべてサポートされています。

これにより、フェッチの実行時に部分ミラーを作成できます。 ただし、履歴がスキップされて失われるため、通常はお勧めしません。

@item  @samp{-} 
@itemx  @samp{--stdin} 
@samp{set-tree} コマンドでのみ使用されます。

stdinからコミットのリストを読み取り、逆の順序でコミットします。 各行からは先頭のsha1のみが読み取られるため、 @samp{git rev-list --pretty=oneline} 出力を使用できます。

@item  @samp{--rmdir} 
@samp{dcommit} と @samp{set-tree} と @samp{commit-diff} コマンドでのみ使用されます。

ファイルが残っていない場合は、SVNツリーからディレクトリを削除します。 SVNは空のディレクトリをバージョン管理でき、ファイルが残っていない場合、デフォルトでは削除されません。 Gitは空のディレクトリをバージョン管理できません。 このフラグを有効にすると、SVNへのコミットがGitのように機能します。

@display
config key: svn.rmdir
@end display


@item  @samp{-e} 
@itemx  @samp{--edit} 
@samp{dcommit} と @samp{set-tree} と @samp{commit-diff} コマンドでのみ使用されます。

SVNにコミットする前に、コミットメッセージを編集します。 これは、コミットされているオブジェクトではデフォルトでオフになっており、ツリーオブジェクトをコミットするときには強制的にオンになります。

@display
config key: svn.edit
@end display


@item  @samp{-l<num>} 
@itemx  @samp{--find-copies-harder} 
@samp{dcommit} と @samp{set-tree} と @samp{commit-diff} コマンドでのみ使用されます。

これらは両方とも「git diff-tree」に直接渡されます。 詳細については、 git-diff-tree(1) を参照してください。

@display
config key: svn.l
config key: svn.findcopiesharder
@end display


@item  @samp{-A<filename>} 
@itemx  @samp{--authors-file=<filename>} 
構文は「git cvs import」で使用されるファイルと互換性がありますが、空の電子メールアドレスを @samp{<>} で指定できます:

@example
        loginname = Joe User <user@@example.com>
@end example


このオプションが指定されていて、「git svn」が authors-file に存在しないSVNコミッター名を検出した場合、「git svn」は操作を中止(abort)します。 この後、ユーザーは適切なエントリを追加する必要があります。 authors-file を変更後、 先程の「git svn」コマンドを再実行すると、操作が続行されます。

@display
config key: svn.authorsfile
@end display


@item  @samp{--authors-prog=<filename>} 
このオプションを指定すると、authorsファイルに存在しないSVNコミッター名ごとに、指定のファイルを最初の引数としてコミッター名を使用してプログラムを実行します。プログラムは、「Name<email>」または「Name<>」の形式の1行を返すことが期待されており、これは、authorsファイルに含まれているかのように扱われます。

歴史的な理由により、相対的な @samp{filename} は、最初に「init」および「clone」の現在のディレクトリに対して、そして、「fetch」の作業ツリーのルートに対して、相対的に検索されます。 @samp{filename} が見つからない場合は、 @samp{$PATH} の他のコマンドと同様に検索されます。

@display
config key: svn.authorsProg
@end display


@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{git svn} のおしゃべりを減らします。 もう一度指定すると、おしゃべりがさらに少なくなります。

@item  @samp{-m} 
@itemx  @samp{--merge} 
@itemx  @samp{-s<strategy>} 
@itemx  @samp{--strategy=<strategy>} 
@itemx  @samp{-p} 
@itemx  @samp{--rebase-merges} 
これらは、 @samp{dcommit} と @samp{rebase} コマンドでのみ使用されます。

「git reset」を使用できない場合、「dcommit」を使用するときに「git rebase」に直接渡されます(「dcommit」コマンド参照)。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
これは、 @samp{dcommit} と @samp{rebase} と @samp{branch} と @samp{tag} コマンドで使用できます。

@samp{dcommit} の場合、どのdiffがSVNにコミットされるかを示す一連のGit引数を出力します。

@samp{rebase} の場合、現在のブランチに関連付けられているアップストリームsvnリポジトリに関連付けられているローカルブランチと、フェッチ元のsvnリポジトリのURLを表示します。

@samp{branch} や @samp{tag} の場合、ブランチまたはタグを作成するときにコピーに使用されるURLを表示します。

@item  @samp{--use-log-author} 
(「fetch」または「rebase」または「dcommit」操作の一部として、)svnのコミットをGitに取得する場合、ログメッセージで最初の @samp{From:} 行または @samp{Signed-off-by} トレーラーを探し、それを著者文字列として使用します。

@display
config key: svn.useLogAuthor
@end display


@item  @samp{--add-author-from} 
(「set-tree」または「dcommit」操作の一部として)Gitからsvnにコミットするとき、既存のログメッセージに @samp{From:} または @samp{Signed-off-by} トレーラーがまだ存在しない場合は、Gitコミットの作者文字列に基づく @samp{From:} 行を追加します。 これを使用すると @samp{--use-log-author} はすべてのコミットに対して有効な作者文字列を取得します。

@display
config key: svn.addAuthorFrom
@end display

@end table

@noindent

@chapheading ADVANCED OPTIONS

@table @asis

@item  @samp{-i<GIT_SVN_ID>} 
@itemx  @samp{--id <GIT_SVN_ID>} 
これにより、(環境変数を使用する代わりに) GIT_SVN_ID が設定されます。 これにより、ユーザーは単一のURLを追跡するときにフェッチするデフォルトのrefnameをオーバーライドできます。 @samp{log} コマンドと @samp{dcommit} コマンドは、もはや引数としてこのスイッチを必要としなくなりました。

@item  @samp{-R<remote name>} 
@itemx  @samp{--svn-remote <remote name>} 
使用する [svn-remote "<remote name>"] セクションを指定します。これにより、SVNの複数のリポジトリを追跡できます。 デフォルトは @samp{svn} です。

@item  @samp{--follow-parent} 
このオプションは、ブランチを追跡している場合にのみ関連します(リポジトリレイアウトオプション @samp{--trunk}, @samp{--tags}, @samp{--branches}, @samp{--stdlayout} のどれかを使用)。 追跡されたブランチごとに、そのリビジョンがどこからコピーされたかを調べ、ブランチの最初のGitコミットで適切な親を設定しようと試みます。 これは、リポジトリ内で移動されたディレクトリを追跡する場合に特に役立ちます。 この機能が無効になっている場合、「git svn」によって作成されたブランチはすべて線形であり、履歴を共有しません。つまり、ブランチが分岐またはマージされた場所に関する情報はありません。 ただし、長い/複雑 な履歴の追跡には長い時間がかかる可能性があるため、この機能を無効にすると、クローン作成プロセスが高速化される可能性があります。 この機能はデフォルトで有効になっています。無効にするには @samp{--no-follow-parent} を使用します。

@display
config key: svn.followparent
@end display

@end table

@noindent

@chapheading CONFIG FILE-ONLY OPTIONS

@table @asis

@item  svn.noMetadata 
@itemx  svn-remote.<name>.noMetadata 
これにより、すべてのコミットの最後にある @samp{git-svn-id:} 行が削除されます。

@samp{git svn} はメタデータなしでは再度フェッチできないため、このオプションはワンショットインポートにのみ使用できます。 さらに、もし、あなたが @samp{$GIT_DIR/svn/\**/.rev_map.*} ファイル達を失ってしまっても、 @samp{git svn} はそれらを再構築できません。

@samp{git svn log} コマンドは、これを使用するリポジトリ上でも機能しません。 これを使用すると、 (うまくいけば)明らかな理由で @samp{useSvmProps} オプションと競合します。

このオプションは、既存のドキュメントやバグレポートやアーカイブでSVNリビジョン番号への古い参照を追跡するのが困難になるため「お勧めしません」。 最終的にSVNからGitに移行することを計画していて、SVN履歴を削除することに確信がある場合は、代わりに @uref{https://github.com/newren/git-filter-repo,git-filter-repo} を検討してください。 filter-repoを使用すると、メタデータを再フォーマットして、「svn.authorsFile」以外のユーザーの作成者情報を読みやすく書き直しやすくすることもできます。

@item  svn.useSvmProps 
@itemx  svn-remote.<name>.useSvmProps 
これにより、「git svn」は、メタデータ用に @samp{SVN::Mirror} (またはsvk)を使用して作成されたミラーからリポジトリのURLとUUIDを再マップできます。

SVNリビジョンにプロパティ「svm:headrev」がある場合、リビジョンは (SVKでも使用される、) SVN::Mirror によって作成された可能性があります。 プロパティには、リポジトリUUIDとリビジョンが含まれています。 元のURLをミラーリングしているように見せるために、元のID URLとUUIDを返すヘルパー関数を導入し、コミットメッセージでメタデータを生成するときに使用します。

@item  svn.useSvnsyncProps 
@itemx  svn-remote.<name>.useSvnsyncprops 
useSvmPropsオプションと同様です。 これは、SVN 1.4.x以降で配布されている svnsync(1) コマンドのユーザー向けです。

@item  svn-remote.<name>.rewriteRoot 
これにより、ユーザーは代替URL(alternate URLs)からリポジトリを作成できます。 たとえば、管理者はサーバー上で @samp{git svn} をローカルで実行できますが(file:// 経由でアクセス)、メタデータに パブリック http:// または svn:// URL を含むリポジトリを配布して、ユーザーにパブリックURLが表示されるようにします。

@item  svn-remote.<name>.rewriteUUID 
useSvmPropsオプションと同様です。 これは、UUIDを手動で再マップする必要があるユーザー向けです。 これは、 useSvmProps または useSvnsyncProps のいずれかを介して元のUUIDを使用できない状況で役立つ場合があります。

@item  svn-remote.<name>.pushurl 
Gitの @samp{remote.<name>.pushurl} と同様に、このキーは、 @samp{url} が読み取り専用転送(transport)を介してSVNリポジトリを指している場合に使用され、代替の 読み取り/書き込み 転送を提供するように設計されています。 両方のキーが同じリポジトリを指していると想定されています。 @samp{commiturl} とは異なり、 @samp{pushurl} はベースパスです。 @samp{commiturl} または @samp{pushurl} のいずれかを使用できる場合は、 @samp{commiturl} が優先されます。

@item  svn.brokenSymlinkWorkaround 
これにより、壊れたクライアントによってSVNにチェックインされた壊れたシンボリックリンクを回避するための潜在的に高価なチェックが無効になります。 シンボリックリンクではない空のブロブが多数あるSVNリポジトリを追跡する場合は、このオプションを「false」に設定します。 このオプションは、「git svn」の実行中に変更され、フェッチされた次のリビジョンで有効になる場合があります。 設定されていない場合、「git svn」はこのオプションが「true」であると見なします。

@item  svn.pathnameencoding 
これは、パス名を特定のエンコーディングに再コード化するようにgit svnに指示します。 Windowsユーザーおよび 非utf-8 のロケールで作業するユーザーが使用して、ASCII以外の文字でファイル名が破損しないようにすることができます。 有効なエンコーディングは、PerlのEncodeモジュールでサポートされているものです。

@item  svn-remote.<name>.automkdirs 
通常、「git svn clone」および「git svn rebase」コマンドは、Subversionリポジトリにある空のディレクトリを再作成しようとします。 このオプションが「false」に設定されている場合、「git svn mkdirs」コマンドが明示的に実行された場合にのみ、空のディレクトリが作成されます。 設定されていない場合、「git svn」はこのオプションが「true」であると見なします。
@end table

noMetadata と rewriteRoot と rewriteUUID と useSvnsyncProps とuseSvmProps オプションはすべて、「git svn」によって生成および使用されるメタデータに影響を与えるためです。 これらは、履歴をインポートする前に構成ファイルで設定する必要があります。これらの設定は、一旦設定したら決して変更してはいけません。

さらに、これらのオプションは、一緒に使用できる rewriteRoot と rewriteUUID を除いて、 @samp{git-svn-id:} メタデータ行に影響を与えるため、svn-remoteセクションごとに使用できるのは1つだけです。

@noindent

@chapheading BASIC EXAMPLES

Subversion管理プロジェクトのtrunkの追跡と貢献(タグとブランチを無視):

@example
# リポジトリのクローン(`git clone` と同様):
        git svn clone http://svn.example.com/project/trunk
# 新しく複製されたディレクトリに入る:
        cd trunk
# あなたはmasterブランチにいる必要があります。 `git branch ` で再確認
        git branch
# いくつかの作業を行い、ローカルでGitにコミットします:
        git commit ...
# 何かをSVNにコミットし、
# SVNの最新の変更に対してあなたのローカルの変更をリベースします:
        git svn rebase
# 次に、変更(先程はGitを使用してコミットしたもの)を
# SVNにコミットし、作業中のHEADを自動的に更新します:
        git svn dcommit
# svn:ignore 設定をデフォルトのGit除外ファイルに追加します:
        git svn show-ignore >> .git/info/exclude
@end example


Subversion管理プロジェクト全体の追跡と貢献(trunkとタグとブランチを完備):

@example
# 標準のSVNディレクトリレイアウトを使用してリポジトリのクローンを作成します(`git clone`と同様):
        git svn clone http://svn.example.com/project --stdlayout --prefix svn/
# または、標準でないディレクトリレイアウトを使うリポジトリの場合は:
        git svn clone http://svn.example.com/project -T tr -b branch -t tag --prefix svn/
# クローンしたすべてのブランチとタグを表示:
        git branch -r
# SVNに新しいブランチを作成
        git svn branch waldo
# masterをtrunk(または他のブランチ。`trunk` は
# 適切な名前に置き換えて下さい)にリセットします:
        git reset --hard svn/trunk
# 一度に1つの ブランチ/タグ/trunk にのみコミットできます。
# dcommit/rebase/show-ignore の使用法は、上記と同じである必要があります。
@end example


最初の「git svn clone」は非常に時間がかかる可能性があります(特に大規模なSubversionリポジトリの場合)。 複数の人(または複数のマシンを持つ1人)が同じSubversionリポジトリと対話するために「git svn」を使用したい場合は、あなたがサーバー上のリポジトリに対して最初の「git svn clone」を実行し、 @samp{git clone} で各人にそのリポジトリのクローンを作成させることができます:

@example
# サーバーで初期インポートを実行します
        ssh server "cd /pub && git svn clone http://svn.example.com/project [options...]"
# ローカルでクローンします - refs/remotes/ 空間 がサーバーと一致することを確認してください
        mkdir project
        cd project
        git init
        git remote add origin server:/pub/project
        git config --replace-all remote.origin.fetch '+refs/remotes/*:refs/remotes/*'
        git fetch
# 今後、リモートGitサーバーからの フェッチ/プル を防止します
# 今後の更新には git svn のみを使用します
        git config --remove-section remote.origin
# フェッチしたブランチの1つからローカルブランチを作成します
        git checkout -b master FETCH_HEAD
# `git svn` をローカルで初期化します(サーバーで使用されたものと同じURLと
# `--stdlayout`/`-T`/`-b`/`-t`/`-prefix` オプションを使用してください)
        git svn init http://svn.example.com/project [options...]
# Subversionから最新の変更をプルする
        git svn rebase
@end example


@noindent

@chapheading REBASE VS. PULL/MERGE

統合されていないコミットを「git svn」ブランチと同期するには、「git pull」または「git merge」ではなく、「git svn rebase」または「git rebase」を使用することをお勧めします。 そうすることで、統合されていないコミットの履歴がアップストリームSVNリポジトリに対して線形に保たれ、優先される「git svn dcommit」サブコマンドを使用して統合されていないコミットをSVNにプッシュバックできるようになります。

当初、「git svn」は、開発者が「git svn」ブランチからプルまたはマージすることを推奨していました。 これは、作成者が複数のコミットをコミットするための @samp{git svn set-tree A..B} 表記ではなく、単一のヘッドをコミットするために @samp{git svn set-tree B} を好んだためです。 「git pull」または「git merge」を、 @samp{git svn set-tree A..B} と一緒に使用すると、SVNにコミットするときに非線形履歴がフラット化され、これにより、マージコミットがSVNの以前のコミットを予期せず逆転させる可能性があります。

@noindent

@chapheading MERGE TRACKING

@samp{git svn} は、標準レイアウト(standard layout)を採用しているリポジトリのコピー履歴(ブランチとタグを含む)を追跡できますが、git内でSVNユーザーに戻って発生したマージ履歴を表すことはできません。 したがって、SVNとの互換性を容易にするために、ユーザーはGit内で履歴を可能な限り線形に保つことをお勧めします(下記「CAVEATS」セクション参照)。

@noindent

@chapheading HANDLING OF SVN BRANCHES

@samp{git svn} がブランチをフェッチするように構成されている場合(そして @samp{--follow-branches} が有効な場合）、1つのSVNブランチに対して複数のGitブランチが作成されることがあり、追加のブランチの名前は @samp{branchname@@nnn}(nnn はSVNリビジョン番号)形式になります。 これらの追加のブランチは、 @samp{git svn} がSVNブランチの最初のコミットの親コミットを見つけられない場合に作成され、ブランチを他のブランチの履歴に接続します。

通常、SVNブランチの最初のコミットはコピー操作で構成されます。 「git svn」はこのコミットを読み取り、ブランチが作成されたSVNリビジョンを取得します。次に、このSVNリビジョンに対応するGitコミットを見つけようとし、それをブランチの親として使用します。ただし、親として機能する適切なGitコミットがない可能性があります。 これは、他の理由の中でも特に、SVNブランチが「git svn」によってフェッチされなかったリビジョンのコピーである場合(たとえば、 `--revision`でスキップされた古いリビジョンであるため)、またはSVNで「git svn」によって追跡されないディレクトリがコピーされた場合(まったく追跡されていないブランチ、または追跡されたブランチのサブディレクトリなど)に発生します。 このような場合、「git svn」は引き続きGitブランチを作成しますが、ブランチの親として既存のGitコミットを使用する代わりに、ブランチのコピー元のディレクトリのSVN履歴を読み取り、適切なGitコミットを作成します。これは、 "Initializing parent: <branchname>" というメッセージで示されます。

さらに、 @samp{<branchname>@@<SVN-Revision>} という名前の特別なブランチを作成します。ここで、<SVN-Revision> は、ブランチのコピー元のSVNリビジョン番号です。 このブランチは、ブランチの新しく作成された親コミットを指します。 SVNでブランチが削除され、後で別のバージョンから再作成された場合、 @samp{@@} が付いたこのようなブランチが複数存在します。

これは、単一のSVNリビジョンに対して複数のGitコミットが作成されることを意味する場合があることに注意してください。

例: 標準の トランク/タグ/ブランチ レイアウトのSVNリポジトリでは、ディレクトリ @samp{trunk/sub} が @samp{r.100} に作成されます。 @samp{r.200} では、 @samp{trunk/sub} は @samp{branchs/} にコピーすることで分岐します。 @samp{git svn clone -s`は、ブランチ `sub} を作成します。 また、 @samp{r.100} から @samp{r.199} までの新しいGitコミットを作成し、これらをブランチ @samp{sub} の履歴として使用します。 したがって、 @samp{r.100} から @samp{r.199} までのリビジョンごとに2つのGitコミットがあります(1つは @samp{trunk/} を含み、もう1つは @samp{trunk/sub/} を含みます)。 最後に、ブランチ @samp{sub} の新しい親コミットを指すブランチ @samp{sub@@200} を作成します(つまり、 @samp{r.200} および @samp{trunk/sub/} のコミット)。

@noindent

@chapheading CAVEATS

単純化とSubversionとの相互運用のために、すべての「git svn」ユーザーがSVNサーバーから直接クローンを作成し、フェッチしてdcommitし、Gitリポジトリとブランチ間で、すべての 「git clone」/「pull」/「merge」/「push」 操作を回避することをお勧めします。Gitブランチとユーザーの間でコードを交換するための推奨される方法は、「git format-patch」と「git am」、または単に「SVNリポジトリへのdcommit」です。

「dcommit」を計画しているブランチで「git merge」または「git pull」を実行することはお勧めしません。Subversionユーザーはあなたが行ったマージを見ることができないからです。 さらに、SVNブランチのミラーであるGitブランチからマージまたはプルすると、「dcommit」が間違ったブランチにコミットする可能性があります。

マージする場合は、以下のルールに注意してください: @samp{git svn dcommit} は、以下で指定されたSVNコミット上でコミットを試みます

@example
git log --grep=^git-svn-id: --first-parent -1
@end example


したがって、dcommitするブランチの最新のコミットがマージの「最初の」親であることを確認する「必要」があります。 特に最初の親が同じSVNブランチの古いコミットである場合は、混沌(chaos)になります。

@samp{git clone} は @samp{refs/remotes/} 階層下のブランチや @samp{git svn} のメタデータや設定をクローンしません。 そのため、@samp{git svn} を使って作成・管理されたリポジトリのクローンを作成する場合は @samp{rsync} を使用する必要があります。

@samp{commit} は内部でリベースを使用しているので、 @samp{dcommit} の前に @samp{git push} した Git ブランチは、リモートリポジトリの既存の ref を強制的に上書きする必要があります。 詳細は git-push(1) ドキュメントを参照ください。

すでにコミットした変更に、 git-commit(1) の @samp{--amend} オプションを使用しないでください。 他のユーザーのためのリモートリポジトリにすでにプッシュしたコミットを修正することは悪い習慣と考えられており、SVNを使用したdcommitはそれに類似しています。

SVNリポジトリのクローンを作成するときに、リポジトリレイアウトを記述するためのオプション(@samp{--trunk}, @samp{--tags}, @samp{--branches}, @samp{--stdlayout})が使用されてい無い場合、 @samp{git svn clone} は完全に線形の履歴を持つGitリポジトリを作成します 、ブランチとタグは作業コピーで別々のディレクトリとして表示されます。 これは完全なリポジトリのコピーを取得する最も簡単な方法ですが、多くのブランチを持つプロジェクトの場合、トランクだけの何倍ものサイズの作業コピーになります。 したがって、標準のディレクトリ構造(trunk/branchs/tags)を使用するプロジェクトの場合、オプション @samp{--stdlayout} を使用してクローンを作成することをお勧めします。 プロジェクトが非標準の構造を使用している場合、および/または ブランチとタグが不要な場合は、リポジトリのレイアウトオプションを指定せずに、1つのディレクトリ(通常はトランク)のみを複製するのが最も簡単です。 ブランチとタグを含む完全な履歴が必要な場合は、オプション @samp{--trunk}/@samp{--branches}/@samp{--tags} を使用する必要があります。

複数の @samp{--branches} または @samp{--tags} を使用する場合、「git svn」は名前の衝突を自動的に処理しません(たとえば、異なるパスからの2つのブランチが同じ名前である場合、またはブランチとタグが同じ名前である場合)。 このような場合は、「init」を使用してGitリポジトリを設定し、最初の「フェッチ」の前に、ブランチとタグが異なる名前空間に関連付けられるように $GIT_DIR/config ファイルを編集します。 例えば:

@example
branches = stable/*:refs/remotes/svn/stable/*
branches = debug/*:refs/remotes/svn/debug/*
@end example

@noindent

@chapheading CONFIGURATION

「git svn」は、 [svn-remote] 構成情報をリポジトリ $GIT_DIR/config ファイルに保存します。 @samp{fetch} キーがglob引数を受け入れないことを除いて、コアGitの [remote] セクションに似ています。 ただし、代わりに @samp{branches} キーと @samp{tags} キーによって処理されます。 一部のSVNリポジトリは、複数のプロジェクトで奇妙に構成されているため、以下にリストされているようなグロブ拡張が許可されます:

@example
[svn-remote "project-a"]
        url = http://server.org/svn
        fetch = trunk/project-a:refs/remotes/project-a/trunk
        branches = branches/*/project-a:refs/remotes/project-a/branches/*
        branches = branches/release_*:refs/remotes/project-a/branches/release_*
        branches = branches/re*se:refs/remotes/project-a/branches/*
        tags = tags/*/project-a:refs/remotes/project-a/tags/*
@end example


(@samp{:} の右側の)ローカル参照の @samp{*}(アスタリスク)ワイルドカードは、
最も右のパスコンポーネントである必要があることに注意してください。
ただし、リモートのワイルドカードは、独立したパスコンポーネント
(@samp{/} または EOLで囲まれている)である限り、どこにあってもかまいません。
このタイプの構成は、 @samp{init} によって自動的に作成されるわけではないため、
テキストエディターまたは @samp{git config} を使用して手動で入力する必要があります。

また、単語ごとに1つのアスタリスク(@samp{*})のみが許可されていることに注意してください。 例えば:

@example
branches = branches/re*se:refs/remotes/project-a/branches/*
@end example

ただし、これは、ブランチ @samp{release} 、@samp{rese} 、@samp{re123se} とマッチします

@example
branches = branches/re*s*e:refs/remotes/project-a/branches/*
@end example

これはエラーを発生させます。

中括弧(@samp{@{} , @samp{@}})内の名前のコンマ(@samp{,})区切りリストを使用して、ブランチまたはタグのサブセットをフェッチすることもできます。 例えば:

@example
[svn-remote "huge-project"]
        url = http://server.org/svn
        fetch = trunk/src:refs/remotes/trunk
        branches = branches/@{red,green@}/src:refs/remotes/project-a/branches/*
        tags = tags/@{1.0,2.0@}/src:refs/remotes/project-a/tags/*
@end example


複数フェッチとブランチとタグキーがサポートされています:

@example
[svn-remote "messy-repo"]
        url = http://server.org/svn
        fetch = trunk/project-a:refs/remotes/project-a/trunk
        fetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo
        branches = branches/server/*:refs/remotes/project-a/branches/*
        branches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*
        tags = tags/server/*:refs/remotes/project-a/tags/*
@end example


このような構成でブランチを作成するには、 @samp{-d} または @samp{--destination} フラグを使用して使用する場所を明確にする必要があります:

@example
$ git svn branch -d branches/server release-2-3-0
@end example


git-svnは、ブランチまたはタグが出現した最高のリビジョン(highest revision)を追跡することに注意してください。 フェッチ後にブランチまたはタグのサブセットが変更された場合は、 @samp{$GIT_DIR/svn/.metadata} を手動で編集して、必要に応じて branches-maxRev および/または tags-maxRev を削除(またはリセット)する必要があります。

@noindent

@chapheading FILES

@table @asis

@item  $GIT_DIR/svn/**/.rev_map.* 
Subversionリビジョン番号とGitコミット名の間のマッピング。 noMetadataオプションが設定されていないリポジトリでは、これはすべてのコミットの最後にある @samp{git-svn-id:} 行から再構築できます(詳細については、上記「svn.noMetadata」セクションを参照してください)。

@samp{git svn fetch} および @samp{git svn rebase} は、rev_mapが欠落しているか最新でない場合、自動的に更新します。 @samp{git svn reset} は自動的にそれを巻き戻します。
@end table

@noindent

@chapheading BUGS

svn:executable を除くすべてのSVNプロパティを無視します。 未処理のプロパティはすべて @samp{$GIT_DIR/svn/<refname>/unhandled.log} に記録されます

名前変更とコピーされたディレクトリはGitによって検出されないため、SVNにコミットするときに追跡されません。 考えられるすべてのレアケース(corner cases)に対応する作業を行うのは非常に困難で時間がかかるため、これに対するサポートを追加する予定はありません(Gitもサポートしていません)。 名前変更とコピーされたファイルのコミットは、Gitがそれらを検出するのに十分類似している場合、完全にサポートされます。

SVNでは、(推奨されていませんが)タグへの変更をコミットすることが可能です(タグは単なるディレクトリコピーであり、技術的にはブランチと同じであるため)。 SVNリポジトリのクローンを作成する場合、「git svn」は、タグへのそのようなコミットが将来発生するかどうかを知ることができません。 したがって、保守的な動作を行い、すべてのSVNタグをブランチとしてインポートし、タグ名の前に @samp{tags/} 接頭辞を付けます。

@noindent

@chapheading SEE ALSO

git-rebase(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-switch,,,Top
@chapheading Name

git-switch — ブランチを切り替える

@noindent

@chapheading Synopsis

@display
git switch [<options>] [--no-guess] <branch>
git switch [<options>] --detach [<start-point>]
git switch [<options>] (-c|-C) <new-branch> [<start-point>]
git switch [<options>] --orphan <new-branch>
@end display


@noindent

@chapheading DESCRIPTION

指定のブランチに切り替えます。作業ツリーとインデックスは、ブランチに一致するように更新されます。新規コミットは、全てこのブランチの先端に追加されることになります。

オプションで、同じ名前のリモートブランチから自動的に @samp{-c} や @samp{-C} を使用して新しいブランチを作成するか(@samp{--guess} 参照)、あるいは切り替え時に @samp{--detach} を使用して任意のブランチから作業ツリーをデタッチできます。

ブランチを切り替えるには、クリーンなインデックスと作業ツリーは必要ありません(つまり、「HEAD」との違いはありません)。ただし、操作によってローカル変更が失われる場合、 @samp{--discard-changes} または @samp{--merge} で特に指示されない限り、操作は中止されます。

!!このコマンドは実験的なものです。 動作が変わる可能性があります!!

@noindent

@chapheading OPTIONS

@table @asis

@item  <branch> 
切り替え先のブランチ

@item  <new-branch> 
新ブランチの名前

@item  <start-point> 
新ブランチの開始点。 @samp{<start-point>} を指定すると、HEADが現在指し示している場所以外の履歴内の場所に基づいてブランチを作成できます。(または、 @samp{--detach} の場合、他の場所から検査してデタッチすることができます。)

@samp{@@@{-N@}} 構文を使用して、「git switch」または「git checkout」操作を使用して切り替えられた最後からN番目のブランチ/コミットを参照できます。 @samp{@@@{-1@}} と同義の @samp{-} を指定することもできます。これは、2つのブランチをすばやく切り替えたり、誤って切り替えたブランチを元に戻したりするためによく使用されます。

特別な場合として、マージベースが1つしかない場合は、 @samp{A} と @samp{B} のマージベースのショートカットとして @samp{A...B} を使用できます。 @samp{A} と @samp{B} のうち片方を省略できます。その場合、省略した方はデフォルトで @samp{HEAD} になります。

@item  @samp{-c <new-branch>} 
@itemx  @samp{--create <new-branch>} 
ブランチに切り替える前に、 @samp{<start-point>} で始まる @samp{<new-branch>} という名前の新しいブランチを作成します。これは以下に代わる便利なショートカットです:

@example
$ git branch <new-branch>
$ git switch <new-branch>
@end example


@item  @samp{-C <new-branch>} 
@itemx  @samp{--force-create <new-branch>} 
@samp{--create`と似ていますが、 `<new-branch>} がすでに存在する場合、 @samp{<start-point>} にリセットされる点が異なります。これは以下に代わる便利なショートカットです:

@example
$ git branch -f <new-branch>
$ git switch <new-branch>
@end example


@item  @samp{-d} 
@itemx  @samp{--detach} 
検査と破棄可能な実験のためのコミットに切り替えます。詳細については、 git-checkout(1) の「DETACHED HEAD」セクションを参照してください。

@item  @samp{--guess} 
@itemx  @samp{--no-guess} 
@samp{<branch>} が見つからないが、名前が一致するリモートが正確に1つだけあり(@samp{<remote>} と呼びます)、それに追跡ブランチが存在する場合は、以下と同等のものとして扱います。

@example
$ git switch -c <branch> --track <remote>/<branch>
@end example


ブランチが複数のリモートに存在し、そのうちの1つが @samp{checkout.defaultRemote} 構成変数によって名前が付けられている場合、 @samp{<branch>} がすべてのリモートで一意でなくても、曖昧さ回避の目的でそのブランチを使用します。例えば、 @samp{<branch>} があいまいであるが、 @samp{origin} リモートに存在する場合、そこからリモートブランチを常にチェックアウトするには、これを @samp{checkout.defaultRemote=origin} と設定します。 git-config(1) の @samp{checkout.defaultRemote} も参照してください。

@samp{--guess} がデフォルトの動作です。無効にするには、 @samp{--no-guess} を使用します。

デフォルトの動作は、 @samp{checkout.guess} 構成変数で設定できます。

@item  @samp{-f} 
@itemx  @samp{--force} 
@samp{--discard-changes} のエイリアス。

@item  @samp{--discard-changes} 
インデックスまたは作業ツリーが @samp{HEAD} と異なっていても続行します。インデックスと作業ツリーの両方が、切り替え先(switching target)に一致するように復元されます。 @samp{--recurse-submodules} が指定されている場合、サブモジュールの内容も切り替え先に一致するように復元されます。これは、ローカルの変更を破棄するために使用されます。

@item  @samp{-m} 
@itemx  @samp{--merge} 
現在のブランチと切り替え先のブランチの間で異なる1つ以上のファイルにローカルの変更がある場合、コマンドは、変更をコンテキストに保持するためにブランチの切り替えを拒否します。 ただし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、および新しいブランチの間の3方向のマージが実行され、新しいブランチに移動します。

マージの競合が発生すると、競合するパスのインデックスエントリはマージされないままになり、競合を解決し、解決されたパスを @samp{git add} (またはマージによってパスが削除される場合は @samp{git rm})でマークする必要があります。

@item  @samp{--conflict=<style>} 
上記の @samp{--merge} オプションと同じですが、競合するハンクの表示方法を変更し、 @samp{merge.conflictStyle} 構成変数をオーバーライドします。 可能な値は、@samp{merge}(デフォルト)と @samp{diff3} と @samp{zdiff3} です。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
静かにします。フィードバックメッセージを抑制します。

@item  @samp{--progress} 
@itemx  @samp{--no-progress} 
@samp{--quiet} が指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。このフラグは、 @samp{--quiet} に関係なく、端末に接続されていない場合でも進行状況のレポートを有効にします。

@item  @samp{-t} 
@itemx  @samp{--track [direct|inherit]} 
新しいブランチを作成するときは、 "upstream" 構成をセットアップします。 @samp{-c} が暗黙に指定されたものと見なします。詳細については、 git-branch(1) の @samp{--track} を参照してください。

@samp{-c} オプションが指定されていない場合、新しいブランチの名前は、対応するリモート用に構成されたrefspecのローカル部分を調べ、次に、最初の部分を「*」まで削除することにより、リモート追跡ブランチから取得されます。これは、 @samp{origin/hack} (または @samp{remotes/origin/hack} あるいは @samp{refs/remotes/origin/hack})から分岐するときに、ローカルブランチとして @samp{hack} を使用するように指示します。指定された名前にスラッシュ(/)がない場合、または上記の推測の結果が空の名前になる場合、推測は中止されます。このような場合は、 @samp{-c} を使用して明示的に名前を付けることができます。

@item  @samp{--no-track} 
@samp{branch.autoSetupMerge} 構成変数がtrueであっても、 "upstream" 構成をセットアップしない。

@item  @samp{--orphan <new-branch>} 
@samp{<new-branch>} という名前の新しい 「孤立した」(orphan)ブランチを作成します。追跡中のファイルはすべて削除されます。

@item  @samp{--ignore-other-worktrees} 
@samp{git switch} は、必要なrefが別のワークツリーによってすでにチェックアウトされている場合に拒否します。このオプションを使用すると、とにかくrefをチェックアウトできます。つまり、refは複数のワークツリーで保持できます。

@item  @samp{--recurse-submodules} 
@itemx  @samp{--no-recurse-submodules} 
@samp{--recurse-submodules} を使用すると、スーパープロジェクト(親プロジェクト)に記録されたコミットに従って、すべてのアクティブなサブモジュールのコンテンツが更新されます。何も使用されていない(または @samp{--no-recurse-submodules})場合、サブモジュールの作業ツリーは更新されません。 git-submodule(1) と同様に、これはサブモジュールの @samp{HEAD} を切り離します(detach)。
@end table

@noindent

@chapheading EXAMPLES

以下のコマンドは "master" ブランチに切り替えます:

@example
$ git switch master
@end example


間違ったブランチで作業した後、正しいブランチへの切り替えは以下を使用して行われます:

@example
$ git switch mytopic
@end example


ただし、「間違った」ブランチと正しい「mytopic」ブランチは、ローカルで変更したファイルが異なる場合があります。その場合、上記のswitchは以下のように失敗します:

@example
$ git switch mytopic
error: You have local changes to 'frotz'; not switching branches.
@end example


コマンドに @samp{-m} フラグを指定すると、3方向のマージを試行します:

@example
$ git switch -m mytopic
Auto-merging frotz
@end example


この3者間マージの後、ローカルの変更はインデックスファイルに登録されないため、 @samp{git diff} は、新しいブランチの先端以降に行った変更を示します。

mytopicに切り替える前に前のブランチ(つまり、 "master" ブランチ)に戻すには:

@example
$ git switch -
@end example


どのコミットからでも新しいブランチを成長させることができます。たとえば、 "HEAD~3" に切り替えて、ブランチ "fixup" を作成します:

@example
$ git switch -c fixup HEAD~3
Switched to a new branch 'fixup'
@end example


同じ名前のリモートブランチから新しいブランチを開始する場合:

@example
$ git switch new-topic
Branch 'new-topic' set up to track remote branch 'new-topic' from 'origin'
Switched to a new branch 'new-topic'
@end example


新しいブランチを作成せずに、一時的な検査または実験のためにコミット @samp{HEAD~3} をチェックアウトするには:

@example
$ git switch --detach HEAD~3
HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'
@end example


一時的な検査または実験のために行ったことに維持する価値があることが判明した場合は、(切り替えることなく)、いつでも新しい名前を作成できます:

@example
$ git switch -c good-surprises
@end example


@noindent

@chapheading CONFIGURATION

このセクションの以下のすべては、 git-config(1) ドキュメントの抜粋です。 内容は git-config(1) ドキュメント にあるものと同一です:

@table @asis

@item  checkout.defaultRemote 
@samp{git checkout <something>} または @samp{git switch <something>} を実行し、リモートが1つしかない場合、 @samp{origin/<something>} のチェックアウトと追跡に暗黙的にフォールバックする可能性があります。 @samp{<something>} 参照を持つリモートが複数あるとすぐに動作しなくなります。 この設定により、曖昧性解消に関して常に勝利させる優先リモートの名前を設定できます。 典型的なユースケースは、これを @samp{origin} に設定することです。

現在、これは git-switch(1) と git-checkout(1) によって、@samp{git checkout <something>} や @samp{git switch <something>} が別のリモート上の @samp{<something>} ブランチをチェックアウトするときに使われています。また git-worktree(1) は @samp{git worktree add} がリモートブランチを参照しているときに使われています。 この設定は、将来、他のチェックアウトのようなコマンドまたは機能に使用される可能性があります。

@item  checkout.guess 
@samp{git checkout} と @samp{git switch} の、 @samp{--guess} または @samp{--no-guess} オプションのデフォルト値を提供します。 git-switch(1) および git-checkout(1) を参照してください。

@item  checkout.workers 
作業ツリーを更新するときに使用する並列ワーカーの数。デフォルトは1、つまり順次実行です。 1未満の値に設定すると、Gitは使用可能な論理コアの数と同じ数のワーカーを使用します。 この設定と @samp{checkout.thresholdForParallelism} は、チェックアウトを実行するすべてのコマンドに影響します。 例えば、 checkout, clone, reset, sparse-checkout, などです。

注意: 並列チェックアウトは通常、SSDまたはNFS上にあるリポジトリのパフォーマンスを向上させます。 回転するディスクやコアの数が少ないマシン上のリポジトリの場合、デフォルトのシーケンシャルチェックアウトの方がパフォーマンスが向上することがよくあります。 リポジトリのサイズと圧縮レベルも、並列バージョンのパフォーマンスに影響を与える可能性があります。

@item  checkout.thresholdForParallelism 
少数のファイルで並列チェックアウトを実行する場合、サブプロセスの生成とプロセス間通信のコストが並列化のメリットを上回る可能性があります。 この設定により、並列チェックアウトを試行する必要のあるファイルの最小数を定義できます。 デフォルトは100です。
@end table

@noindent

@chapheading SEE ALSO

git-checkout(1), git-branch(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-symbolic-ref,,,Top
@chapheading Name

git-symbolic-ref — シンボリックrefの読み取り、変更、および削除

@noindent

@chapheading Synopsis

@display
git symbolic-ref [-m <reason>] <name> <ref>
git symbolic-ref [-q] [--short] [--no-recurse] <name>
git symbolic-ref --delete [-q] <name>
@end display


@noindent

@chapheading DESCRIPTION

引数が1つ与えられると、指定されたシンボリックrefが参照するブランチヘッドを読み取り、 @samp{.git/} ディレクトリを基準にしてそのパスを出力します。 通常、作業ツリーがどのブランチにあるかを確認するには、 <name> 引数として @samp{HEAD} を指定します。

2つの引数を与えると、指定されたブランチ <ref> を指すようにシンボリックref <name> を作成または更新します。

@samp{--delete} と追加の引数を指定すると、指定されたシンボリックrefが削除されます。

シンボリックrefは、 @samp{ref: refs/} で始まる文字列を格納する通常のファイルです。 たとえば、 @samp{.git/HEAD} は、内容が @samp{ref: refs/heads/master} である通常のファイルです。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-d} 
@itemx  @samp{--delete} 
シンボリックref <name> を削除します。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
<name> がシンボリックrefではなく、切り離されたHEAD(detached HEAD)である場合は、エラーメッセージを発行しないでください。 代わりに、ゼロ以外のステータスで何も言わずに終了します。

@item  @samp{--short} 
<name> の値をシンボリックrefとして表示する場合は、値を短くする事を試みます。例えば @samp{refs/heads/master} から @samp{master} へ。

@item  @samp{--recurse} 
@itemx  @samp{--no-recurse} 
When showing the value of <name> as a symbolic ref, if <name> refers to another symbolic ref, follow such a chain of symbolic refs until the result no longer points at a symbolic ref (@samp{--recurse}, which is the default). @samp{--no-recurse} stops after dereferencing only a single level of symbolic ref.

@item  @samp{-m} 
<name> のreflogを <reason> で更新します。これは、シンボリックrefを作成または更新する場合にのみ有効です。
@end table

@noindent

@chapheading NOTES

以前は、 @samp{.git/HEAD} は @samp{refs/heads/master} を指すシンボリックリンクでした。別のブランチに切り替えたい場合は、 @samp{ln -sf refs/heads/newbranch .git/HEAD} を実行し、現在のブランチを確認したい場合は、 @samp{readlink .git/HEAD} を実行しました。 ただし、シンボリックリンクは完全に移植可能ではないため、非推奨になり、(上記のとおり)シンボリックrefがデフォルトで使用されます。

@emph{git symbolic-ref} は、シンボリックrefの内容が正しく出力された場合はステータス0で終了し、要求された名前がシンボリックrefでない場合はステータス1で終了し、別のエラーが発生した場合は128で終了します。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-tag,,,Top
@chapheading Name

git-tag — GPG署名されたタグオブジェクトを作成、一覧表示、削除、検証します

@noindent

@chapheading Synopsis

@display
git tag [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] [-e]
        <tagname> [<commit> | <object>]
git tag -d <tagname>…
git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]
        [--points-at <object>] [--column[=<options>] | --no-column]
        [--create-reflog] [--sort=<key>] [--format=<format>]
        [--merged <commit>] [--no-merged <commit>] [<pattern>…]
git tag -v [--format=<format>] <tagname>…
@end display


@noindent

@chapheading DESCRIPTION

タグを削除、一覧表示、検証するために @samp{-d/-l/-v} が指定されていない限り、 @samp{refs/tags/} にタグ参照を追加します。

@samp{-f} が指定されていない限り、名前付きタグはまだ存在してはいけません。

If one of @samp{-a}, @samp{-s}, or @samp{-u <key-id>} is passed, the command creates a @emph{tag} object, and requires a tag message. Unless @samp{-m <msg>} or @samp{-F <file>} is given, an editor is started for the user to type in the tag message.

If @samp{-m <msg>} or @samp{-F <file>} is given and @samp{-a}, @samp{-s}, and @samp{-u <key-id>} are absent, @samp{-a} is implied.

それ以外の場合は、指定されたオブジェクトを直接指すタグ参照(つまり、軽量タグ)が作成されます。

A GnuPG signed tag object will be created when @samp{-s} or @samp{-u <key-id>} is used. When @samp{-u <key-id>} is not used, the committer identity for the current user is used to find the GnuPG key for signing.    The configuration variable @samp{gpg.program} is used to specify custom GnuPG binary.

(@samp{-a} または @samp{-s} または @samp{-u} で作成した)タグオブジェクトは「注釈付き」タグ(annotated tags)と呼ばれます。 これらには、作成日や、タグ付け者(tagger)の名前と電子メールアドレスや、タグ付けメッセージや、オプションのGnuPG署名が含まれています。 一方、「軽量」タグ(lightweight tag)は単にオブジェクト(通常はコミットオブジェクト)の名前が含まれています。

注釈付きタグはリリース用であり、軽量タグはプライベートまたは一時オブジェクトラベル用です。 このため、オブジェクトに名前を付けるための一部のgitコマンド( @samp{git describe} など)は、デフォルトでは軽量タグを無視します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-a} 
@itemx  @samp{--annotate} 
署名されていない注釈付きのタグオブジェクトを作成します

@item  @samp{-s} 
@itemx  @samp{--sign} 
デフォルトの電子メールアドレスのキーを使用して、GPG署名付きタグを作成します。 タグGPG署名のデフォルトの動作は、存在する場合は @samp{tag.gpgSign} 構成変数によって制御され、存在しない場合は無効になります。 git-config(1) を参照してください。

@item  @samp{--no-sign} 
すべてのタグに強制的に署名するように設定されている @samp{tag.gpgSign} 構成変数をオーバーライドします。

@item  @samp{-u <key-id>} 
@itemx  @samp{--local-user=<key-id>} 
指定されたキーを使用して、GPG署名付きタグを作成します。

@item  @samp{-f} 
@itemx  @samp{--force} 
既存のタグを、(失敗して終了するのではなく、)指定された名前に置き換えます

@item  @samp{-d} 
@itemx  @samp{--delete} 
指定された名前の既存のタグを削除します。

@item  @samp{-v} 
@itemx  @samp{--verify} 
指定されたタグ名のGPG署名を検証(verify)します。

@item  @samp{-n<num>} 
<num> は、@samp{-l} を使用したときに、注釈を何行出力するか指定します。 @samp{--list} の指定を含んでいます。

デフォルトでは、注釈行は印刷されません。 @samp{-n} に番号が指定されていない場合、最初の行のみが出力されます。 タグに注釈が付けられていない場合は、代わりにコミットメッセージが表示されます。

@item  @samp{-l} 
@itemx  @samp{--list} 
タグを一覧表示します。オプションで @samp{<pattern>...} を指定すると、例えば @samp{git tag --list 'v-*'} のように、パターンにマッチするタグのみをリストアップします。

引数なしで @samp{git tag} を実行した時も、すべてのタグが一覧表示されます。 パターンはシェルワイルドカードです(つまり、fnmatch(3) を使用してマッチします)。 複数のパターンを指定できます。 それらのいずれかがマッチする場合、タグが表示されます。

このオプションは、 @samp{--contains} などの他のリストっぽいオプション(list-like option)が提供されている場合に暗黙的に提供されます。 詳細については、これらの各オプションのドキュメントを参照してください。

@item  @samp{--sort=<key>} 
指定されたキーに基づいて並べ替えます。 接頭辞 @samp{-} を使用して、値の降順で並べ替えます。 @samp{-sort=<key>} オプションは複数回使用できます。その場合、最後のキーが主キーになります。 "version:refname" または "v:refname" もサポートします(タグ名はバージョンとして扱われます)。 "version:refname" のソート順は、 @samp{versionsort.suffix} 構成変数の影響も受ける可能性があります。 サポートされているキーは、@samp{git for-each-ref} のキーと同じです。 並べ替え順序は、デフォルトで、 @samp{tag.sort} 変数が存在する場合は設定された値になり、存在しない場合は辞書式順序(lexicographic order)になります。 git-config(1) を参照してください。

@item  @samp{--color[=<when>]} 
@samp{--format} オプションで指定された色を尊重します。 @samp{<when>} フィールドは @samp{always}, @samp{never}, @samp{auto} のいずれかでなければなりません(@samp{<when>} がない場合は、 @samp{always} が指定されたかのように振る舞います)。

@item  @samp{-i} 
@itemx  @samp{--ignore-case} 
タグの並べ替えとフィルタリングでは英大文字小文字は区別されません(case insensitive)。

@item  @samp{--omit-empty} 
Do not print a newline after formatted refs where the format expands to the empty string.

@item  @samp{--column[=<options>]} 
@itemx  @samp{--no-column} 
タグリストを列(columns)に表示します。 オプションの構文については、構成変数 @samp{column.tag} を参照してください。 オプションのない @samp{--column} と @samp{--no-column} は、それぞれ @samp{always} と @samp{never} と同等です。

このオプションは、注釈行(annotation lines)のないタグをリストする場合にのみ適用できます。

@item  @samp{--contains [<commit>]} 
指定されたコミットを含むタグのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{--no-contains [<commit>]} 
指定されたコミットを含まないタグのみをリストします(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{--merged [<commit>]} 
指定されたコミットから、コミットに到達できるタグのみをリストします(指定されていない場合は @samp{HEAD})。

@item  @samp{--no-merged [<commit>]} 
指定されたコミットから、コミットに到達できないタグのみをリストします(指定されていない場合は @samp{HEAD})。

@item  @samp{--points-at <object>} 
指定されたオブジェクトのタグのみを一覧表示します(指定されていない場合はHEAD)。 @samp{--list} の指定を含んでいます。

@item  @samp{-m <msg>} 
@itemx  @samp{--message=<msg>} 
Use the given tag message (instead of prompting). If multiple @samp{-m} options are given, their values are concatenated as separate paragraphs. Implies @samp{-a} if none of @samp{-a}, @samp{-s}, or @samp{-u <key-id>} is given.

@item  @samp{-F <file>} 
@itemx  @samp{--file=<file>} 
Take the tag message from the given file. Use @emph{-} to read the message from the standard input. Implies @samp{-a} if none of @samp{-a}, @samp{-s}, or @samp{-u <key-id>} is given.

@item  @samp{-e} 
@itemx  @samp{--edit} 
@samp{-F} を使用してファイルから取得したメッセージと、 @samp{-m} を使用してコマンドラインを使用したメッセージは、通常は編集しないタグメッセージとして使用されます。 このオプションを使用すると、これらのソースから取得したメッセージをさらに編集できます。

@item  @samp{--cleanup=<mode>} 
このオプションは、タグメッセージのクリーンアップ方法を設定します。 @samp{<mode>} は、 @samp{verbatim}, @samp{whitespace}, @samp{strip} のいずれかになります。 @samp{strip} モードがデフォルトです。 @samp{verbatim} モードはメッセージをまったく変更せず、@samp{whitespace} は 先頭/末尾 の空白行のみを削除し、@samp{strip} は空白(whitespace)とコメント(commentary)の両方を削除します。

@item  @samp{--create-reflog} 
タグのreflogを作成します。 タグのreflogをグローバルに有効にするには、 git-config(1) の @samp{core.logAllRefUpdates} を参照してください。 否定形式 @samp{--no-create-reflog} は、(コマンドラインで)それ以前に指定された @samp{--create-reflog} をオーバーライドするだけですが、現在のところ、@samp{core.logAllRefUpdates} の設定を否定しません。

@item  @samp{--format=<format>} 
表示されているタグrefとそれが指すオブジェクトを @samp{%(fieldname)} によって差し込みする文字列。 形式はgit-for-each-ref(1) の形式と同じです。 指定しない場合、デフォルトは @samp{%(refname:strip=2)} です。

@item  <tagname> 
作成または削除または説明するタグの名前。 新しいタグ名は、git-check-ref-format(1) で定義されているすべてのチェックに合格する必要があります。 これらのチェックの一部は、タグ名で許可される文字を制限する場合があります。

@item  <commit> 
@itemx  <object> 
新しいタグが参照するオブジェクト、通常はコミット。 デフォルトはHEADです。
@end table

@noindent

@chapheading CONFIGURATION

デフォルトでは、 sign-with-default モード(@samp{-s})の @samp{git tag} は、コミッターID(@samp{Your Name <your@@email.address>} 形式)を使用してキーを検索します。 別のデフォルトキーを使用する場合は、リポジトリ構成(repository configuration)で以下のように指定できます:

@example
[user]
    signingKey = <gpg-key_id>
@end example


@samp{pager.tag} は、タグを一覧表示する場合、つまり @samp{-l} が使用または暗示されている場合にのみ尊重されます。 デフォルトではpagerを使用します。 git-config(1) を参照してください。

@noindent

@chapheading DISCUSSION

@noindent

@heading On Re-tagging

間違ったコミットにタグを付けてしまいました。再度タグを付けたい場合はどうすればよいですか？

あなたがまだ何もプッシュしたことがない場合は、タグを付け直してください。 古いものを置き換えるには @samp{-f} を使用します。 これで完了です。

しかし、あなたが何かプッシュした場合(または他の人があなたのリポジトリを直接読み取ることができた場合)、他の人はすでに古いタグを見ているでしょう。 その場合、あなたは以下の2つのいずれかを実行できます:

@enumerate 

@item
常識的には、失敗したことを認めて、別の名前を使用してください。 他の人は既にとあるタグ名を見たことがあり、同一の名前を保持している場合、2人が両方とも「バージョンX」を持っているように見える状況にあるかもしれませんが、実際には「異なる」「X」を持っています。 だから、それを「X.1」と呼んで、それで終わりです。

@item
非常識なやり方は、他の人がすでに古いバージョンを見たとしても、あなたは本当に新しいバージョンを「X」と呼びたいのです。 したがって、古いものをまだ公開していないかのように、もう一度 @samp{git tag -f} を使用します。
@end enumerate

しかしながら、Gitは、ユーザーの背後でタグを変更することはありません(また、変更すべきではありません)。 ですから、誰かが既に古いタグを取得している場合、あなたのツリーで @samp{git pull} を実行しても、古いタグを上書きすることにはならないはずです。

誰かがあなたからリリースタグを取得した場合、あなた自身のタグを更新することで、その人のタグを変更することはできません。これは、人々が自分のタグ名を信頼できなければならないという点で、大きなセキュリティ上の問題です。 もしあなたが本当に非常識なことをしたいのであれば、素直に白状して、自分が失敗したことを人々に伝える必要があります。そうするには、以下のように公言すればよいでしょう:

@example
私はやらかしちまって、間違いのあるバージョンをXとタグ付けしてプッシュしてしまいました。
それから私は、その何かを修正し、「修正された」ツリーを再度Xとしてタグ付けしました。

あなたが既に間違ったタグを取得してしまっていて、新しいタグが必要な場合は、
古いタグを削除し、以下の手順を実行して新しいタグをフェッチしてください。お願いします:

        git tag -d X
        git fetch origin tag X

これで更新されたタグを取得します。

あなたは以下のようにしてあなたの持っているタグをテストできます

        git rev-parse X

これは、あなたが新しいバージョンを持っているなら、 0123456789abcdef.. と返されるはずです。

ご不便おかけしてすみませんでした。
@end example


これは少し複雑に見えますか？ 然り。 自動的に「修正」するだけで正しくなる方法はありません。 人々にタグが変更された可能性があることを知らせる必要があります。

@noindent

@heading On Automatic following

他の誰かのツリーを追っている場合は、リモート追跡ブランチ(例: @samp{refs/remotes/origin/master})を使用している可能性があります。 通常、相手側からのタグが必要です。

一方、他の誰かからの一回限りの(one-shot)マージが必要なためにフェッチしている場合は、通常、そこからタグを取得する必要はありません。 これは、トップレベルに近い人によく起こりますが、それに限定されません。 神ならぬ人々は、お互いからプルするとき、必ずしも相手からプライベートアンカーポイントタグを自動的に取得したいとは思いません。

多くの場合、メーリングリストの「プルしてください」というメッセージは、リポジトリのURLとブランチ名の2つの情報を提供するだけです。 これは、 @samp{git fetch} コマンドラインの最後で簡単にカットアンドペーストできるように設計されています:

@example
リーナス、更新を取得するために、

        git://git..../proj.git master

上記から取得してください。
@end example


とあれば、以下のようになります:

@example
$ git pull git://git..../proj.git master
@end example


このような場合、あなたは相手のタグを自動的に追跡したくはないでしょう。

Gitの重要な側面の1つは分散型であり、これは主にシステムに固有の「上流」(upstream)または「下流」(downstream)がないことを意味します。 一見すると、上記の例は、タグの名前空間が上層部の人々によって所有されており、タグが下向きにのみ流れることを示しているように見えるかもしれませんが、そうではありません。 使用パターンによって、誰が誰のタグに関心があるかが決まることだけが示されています。

一回限りのプル(on-shot pull)は、あるコミット履歴が、独自のタグ(例:「これは、2.6.21リリースで一般消費向けに提案されるネットワーキンググループからの3番目のリリース候補です」)を持つあるサークル(例:「カーネルのネットワーキング部分に主に関心がある人々」)と、別のサークル(例:「さまざまなサブシステムの改善を統合する人々」)の間の境界を越えていることを示すサインです。 後者は通常、前者のグループで内部的に使用される詳細なタグには関心がありません(これが「内部」の意味です)。そのため、この場合、タグを自動的に追跡しないことが望ましいです。

ネットワーキングの人々の間では、グループ内でタグを交換したいと思うかもしれませんが、その作業フローでは、リモート追跡ブランチを使用して互いの進行状況を追跡している可能性があります。 繰り返しますが、そのようなタグを自動的に追跡するヒューリスティックは良いことです。

@noindent

@heading On Backdating Tags

別のVCSからいくつかの変更をインポートし、作業のメジャーリリースのタグを追加したい場合は、タグオブジェクト内に埋め込む日付を指定できると便利です。 タグオブジェクト内のこのようなデータは、たとえば、gitwebインターフェイスでのタグの順序に影響します。

将来のタグオブジェクトで使用される日付を設定するには、環境変数 GIT_COMMITTER_DATE を設定します(可能な値については後の説明を参照してください。最も一般的な形式は "YYYY-MM-DD HH:MM" です)。

For example:

@example
$ GIT_COMMITTER_DATE="2006-10-02 10:31" git tag -s v1.0.1
@end example


@noindent

@chapheading DATE FORMATS

@samp{GIT_AUTHOR_DATE} と @samp{GIT_COMMITTER_DATE} 環境変数は、以下の日付形式をサポートします:

@table @asis

@item  Git internal format 
これは @samp{<unix-timestamp> <time-zone-offset>} ここで、 @samp{<unix-timestamp>} UNIXエポックからの秒数です。 @samp{<time-zone-offset>} はUTCからの正または負のオフセットです。 たとえば、CET(UTCより1時間進んでいます)は @samp{+0100} です。

@item  RFC 2822 
RFC 2822で説明されている標準の電子メール形式。たとえば、 @samp{Thu, 07 Apr 2005 22:13:13 +0200} 。

@item  ISO 8601 
ISO 8601規格で指定されている日時(例: @samp{2005-04-07T22:13:13})。パーサは、 @samp{T} 文字の代わりにスペースも受け入れます。秒の小数部分は無視されます。たとえば、 @samp{2005-04-07T22:13:13.019} は @samp{2005-04-07T22:13:13} として扱われます。

@quotation

@strong{Note}

日付部分は、上記に加えて、 @samp{YYYY.MM.DD} または @samp{MM/DD/YYYY} または @samp{DD.MM.YYYY} 形式が受け入れられます。
@end quotation
@end table

@noindent

@chapheading FILES

@table @asis

@item  @samp{$GIT_DIR/TAG_EDITMSG} 
This file contains the message of an in-progress annotated tag. If @samp{git tag} exits due to an error before creating an annotated tag then the tag message that has been provided by the user in an editor session will be available in this file, but may be overwritten by the next invocation of @samp{git tag}.
@end table

@noindent

@chapheading NOTES

複数の @samp{--contains} フィルターと @samp{--no-contains} フィルターを組み合わせる場合、少なくとも1つの @samp{--contains} コミットを含み、 @samp{--no-contains} コミットを含まない参照のみが表示されます。

複数の @samp{--merged} フィルターと @samp{--no-merged} フィルターを組み合わせると、少なくとも1つの @samp{--merged} コミットから到達可能で、 @samp{--no-merged} コミットのいずれからも到達できない参照のみが表示されます。

@noindent

@chapheading SEE ALSO

git-check-ref-format(1). git-config(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-unpack-file,,,Top
@chapheading Name

git-unpack-file — ブロブの内容を含む一時(temporary)ファイルを作成します

@noindent

@chapheading Synopsis

@display
git unpack-file <blob>
@end display


@noindent

@chapheading DESCRIPTION

sha1で指定されたブロブの内容を保持するファイルを作成します。
一時(temporary)ファイルの名前を次の形式で返します:
.merge_file_XXXXX

@noindent

@chapheading OPTIONS

@table @asis

@item  <blob> 
ブロブIDである必要があります
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-unpack-objects,,,Top
@chapheading Name

git-unpack-objects — パックされたアーカイブからオブジェクトを取り出します

@noindent

@chapheading Synopsis

@display
git unpack-objects [-n] [-q] [-r] [--strict]
@end display


@noindent

@chapheading DESCRIPTION

標準入力からパックされたアーカイブ(.pack)を読み取り、そこに含まれるオブジェクトを展開して、"loose" 形式(ファイルごとに1つのオブジェクト)でリポジトリに書き込みます。

リポジトリにすでに存在するオブジェクトは、パックファイルから取り出されません。したがって、ターゲットリポジトリ内に存在するパックファイルでこのコマンドを使用しても、何も取り出されません。

新しいパックを生成して既存のパックを置き換えるオプションについては、 git-repack(1) を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-n} 
Dry run. Check the pack file without actually unpacking the objects.

@item  @samp{-q} 
このコマンドは通常、進捗率を表示しますが、このフラグはそれを抑制します。

@item  @samp{-r} 
破損したパックファイルから取り出そうとすると、コマンドは最初の破損で終了します。このフラグは破損があっても続行し、できるだけ多くのオブジェクトを回復するために最善を尽くすことを指示します。

@item  @samp{--strict} 
壊れたコンテンツやリンクを含むオブジェクトをリポジトリに書き込まない

@item  @samp{--max-input-size=<size>} 
入力サイズが <size> より大きい場合は何もせず終了します。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-update-index,,,Top
@chapheading Name

git-update-index — 作業ツリーのファイルの内容をインデックスに登録します

@noindent

@chapheading Synopsis

@display
git update-index
             [--add] [--remove | --force-remove] [--replace]
             [--refresh] [-q] [--unmerged] [--ignore-missing]
             [(--cacheinfo <mode>,<object>,<file>)…]
             [--chmod=(+|-)x]
             [--[no-]assume-unchanged]
             [--[no-]skip-worktree]
             [--[no-]ignore-skip-worktree-entries]
             [--[no-]fsmonitor-valid]
             [--ignore-submodules]
             [--[no-]split-index]
             [--[no-|test-|force-]untracked-cache]
             [--[no-]fsmonitor]
             [--really-refresh] [--unresolve] [--again | -g]
             [--info-only] [--index-info]
             [-z] [--stdin] [--index-version <n>]
             [--verbose]
             [--] [<file>…]
@end display


@noindent

@chapheading DESCRIPTION

インデックスを変更します。 言及された各ファイルはインデックスに更新され、「unmerged」(マージされていない)または「needs updating」(更新が必要)状態がクリアされます。

インデックスで最も一般的な操作のいくつかを実行するためのよりユーザーフレンドリーな方法については、 git-add(1) も参照してください。

@samp{git update-index} が通知されたファイルを処理する方法は、さまざまなオプションを使用して変更できます:

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--add} 
指定のファイルがまだインデックスにない場合は、追加されます。 デフォルトの動作では、新規ファイルは無視されます。

@item  @samp{--remove} 
指定のファイルがインデックスに含まれているが欠落している場合、そのファイルは削除されます。 デフォルトの動作では、削除済のファイルは無視されます。

@item  @samp{--refresh} 
現在のインデックスを調べ、 stat() 情報をチェックして、マージまたは更新が必要かどうかを確認します。

@item  @samp{-q} 
静かにします。 もし @samp{--refresh} がインデックスの更新を必要としていると判断した場合、デフォルトの動作はエラーになります。 このオプションは、 @samp{git update-index} をとにかく継続させます。

@item  @samp{--ignore-submodules} 
サブモジュールを更新しようと試みない。このオプションは、@samp{--refresh} より前に渡された場合にのみ尊重されます。

@item  @samp{--unmerged} 
@samp{--refresh} がインデックス内のマージされていない変更を検出した場合、デフォルトの動作はエラー終了です。 このオプションにより、「git update-index」はとにかく続行されます。

@item  @samp{--ignore-missing} 
@samp{--refresh} の処理中に欠落しているファイルを無視します

@item  @samp{--cacheinfo <mode>,<object>,<path>} 
@itemx  @samp{--cacheinfo <mode> <object> <path>} 
指定の情報を直接インデックスに挿入します。 下位互換性のために、これらの3つの引数を3つの別個のパラメーターとして指定することもできますが、新しいユーザーは単一パラメーター形式を使用することをお勧めします。

@item  @samp{--index-info} 
stdinからインデックス情報を読み取ります。

@item  @samp{--chmod=(+|-)x} 
更新されたファイルに実行権限を設定します。

@item  @samp{--[no-]assume-unchanged} 
このフラグを指定すると、パスに記録されているオブジェクト名は更新されません。 代わりに、このオプションは、パスの「assume unchanged」(無変更仮定)ビットを 設定(1)/設定解除(0) します。 「assume unchanged」ビットがオンの場合、ユーザーはファイルを変更しないことを約束し、作業ツリーファイルがインデックスに記録されているものと一致するとGitに想定させます。 作業ツリーファイルを変更する場合は、Gitに通知するビットを設定解除する必要があります。 これは、 lstat(2) システムコールが非常に遅いファイルシステム(cifsなど)で大きなプロジェクトを操作する場合に役立つことがあります。

インデックス内のこのファイルを変更する必要がある場合、例えばコミットにマージするとき、Gitは(正常に)失敗します。 したがって、追跡されていないと仮定されるファイルがアップストリームで変更された場合、あなたは状況を手動で処理する必要があります。

@item  @samp{--really-refresh} 
@samp{--refresh} と同様ですが、「assume unchanged」設定に関係なく、統計情報を無条件にチェックします。

@item  @samp{--[no-]skip-worktree} 
これらのフラグのいずれかが指定されている場合、パスに記録されているオブジェクト名は更新されません。 代わりに、これらのオプションは、パスの「skip-worktree」ビットを設定および設定解除します。 詳細については、下記「Skip-worktree bit」のセクションを参照してください。

@item  @samp{--[no-]ignore-skip-worktree-entries} 
@samp{--remove} オプションが指定されている場合でも、 skip-worktree (別名「インデックスのみ」) エントリを削除しないでください。

@item  @samp{--[no-]fsmonitor-valid} 
これらのフラグのいずれかが指定されている場合、パスに記録されているオブジェクト名は更新されません。 代わりに、これらのオプションは、パスの「fsmonitor valid」ビットを設定および設定解除します。 詳細については、下記「File System Monitor」のセクションを参照してください。

@item  @samp{-g} 
@itemx  @samp{--again} 
インデックスエントリが @samp{HEAD} コミットとは異なるパスで @samp{git update-index} 自体を実行します。

@item  @samp{--unresolve} 
誤ってクリアされた場合、マージ処理中のファイルの「unmerged」(マージされていない)または「needs updating」(更新が必要)状態を復元します。

@item  @samp{--info-only} 
このフラグに続くすべての <file> 引数に対して、オブジェクトデータベースにオブジェクトを作成しません。 オブジェクトIDをインデックスに挿入するだけです。

@item  @samp{--force-remove} 
作業ディレクトリにそのようなファイルがまだある場合でも、インデックスからファイルを削除します。 (@samp{--remove} の指定を含んでいます。)

@item  @samp{--replace} 
デフォルトでは、ファイル @samp{path} がインデックスに存在する場合、 @samp{git update-index} は @samp{path/file} を追加する試みを拒否します。 同様に、ファイル @samp{path/file} が存在する場合、ファイル @samp{path} を追加することはできません。 @samp{--replace} フラグを使用すると、競合する既存のエントリが警告メッセージとともに自動的に削除されて、エントリが追加されます。

@item  @samp{--stdin} 
コマンドラインからパスのリストを取得する代わりに、標準入力からパスのリストを読み取ります。 デフォルトでは、パスはLFで区切られます(つまり、1行に1つのパス)。

@item  @samp{--verbose} 
インデックスに 追加・削除 されているものを報告します。

@item  @samp{--index-version <n>} 
結果のインデックスを、指定のディスク上のフォーマットバージョン(on-disk format version)で書き出します。 サポートされているバージョンは 2 と 3 と 4 です。現在のデフォルトバージョンは、 @samp{git add -N} などの追加機能が使用されているかどうかに応じて、 2 または 3 です。

バージョン4は、単純なパス名圧縮を実行し、大規模なリポジトリでインデックスサイズを30%〜50%削減します。これにより、読み込み時間が短縮されます。 バージョン4は比較的若いです(2012年10月の1.8.0で最初にリリースされました)。 JGitやlibgit2などの他のGit実装は、まだサポートしていない可能性があります。

@item  @samp{-z} 
これは @samp{--stdin} または @samp{--index-info} でのみ意味があります。 パスは、LFではなくNUL文字で区切られます。

@item  @samp{--split-index} 
@itemx  @samp{--no-split-index} 
分割インデックスモードを有効または無効にします。 分割インデックスモードがすでに有効になっていて、 @samp{--split-index} が再度指定された場合、 $GIT_DIR/index のすべての変更が共有インデックスファイルに押し返されます。

これらのオプションは、構成変数 @samp{core.splitIndex} の値が何であれ有効になります(git-config(1) 参照)。 しかし、構成変数 @samp{core.splitIndex} の設定値に反する変更を行うと警告が表示されます。なぜなら、次回インデックスを読み込むときには構成変数 @samp{core.splitIndex} の設定値が有効になり、オプションの意図した効果がなくなってしまうからです。

@item  @samp{--untracked-cache} 
@itemx  @samp{--no-untracked-cache} 
追跡されていないモノのキャッシュ機能を有効または無効にします。 有効にする前には @samp{--test-untracked-cache} の使用をお願いします。

これらのオプションは、 @samp{core.untrackedCache} 構成変数の値に関係なく有効になります(git-config(1) 参照)。 ただし、 @samp{core.untrackedCache} 構成変数設定値に反する変更を行うと警告が表示されます。これは、インデックスを次に読み込むときには @samp{core.untrackedCache} 構成変数設定値が有効になり、このオプションが意図したとおりの効果を得られなくなってしまうからです。

@item  @samp{--test-untracked-cache} 
追跡されていないモノのキャッシュ(untracked cache)を使用できることを確認するために、作業ディレクトリでのみテストを実行します。 本当に使用したい場合は、後で @samp{--untracked-cache} または @samp{--force-untracked-cache} または @samp{core.untrackedCache} 構成変数を使用して、追跡されていないモノのキャッシュ(untracked cache)を手動で有効にする必要があります。 テストが失敗した場合、exitコードは1であり、必要に応じて機能しないことを説明するメッセージが表示されます。それ以外の場合、exitコードは0であり、OKと出力されます。

@item  @samp{--force-untracked-cache} 
@samp{--untracked-cache} と同一です。 @samp{--untracked-cache} が @samp{--test-untracked-cache} を意味するために使用されていた古いバージョンのGitとの下位互換性のために提供されていますが、このオプションは無条件に拡張を有効にします。

@item  @samp{--fsmonitor} 
@itemx  @samp{--no-fsmonitor} 
ファイルシステムモニター機能を有効または無効にします。 これらのオプションは、設定変数 @samp{core.fsmonitor} の値が何であっても有効になります((git-config(1) 参照)。 しかし、設定変数 @samp{core.fsmonitor} の設定値と異なる変更を行うと警告が表示されます。インデックスを次に読み込む際には設定変数 @samp{core.fsmonitor} の設定値が有効となり、オプションの意図した効果がなくなってしまうからです。

@item  @samp{--} 
これ以降の引数をオプションとして解釈しないでください。

@item  <file> 
作用するファイル。 注意: @samp{.} で始まるファイルは破棄されます。 これには、 @samp{./file} と @samp{dir/./file} が含まれます。 これがあなたの求めるものでない場合は、よりクリーンな名前を使用してください。 @samp{/} で終わるディレクトリと @samp{//} で終わるパスにも同じことが当てはまります。
@end table

@noindent

@chapheading USING --refresh

@samp{--refresh} は、新しいsha1ファイルを計算したり、また、モード/コンテンツ の変更についてインデックスを最新の状態にしたりしません。 ただし、ファイルの統計情報をインデックスと「再照合」(re-match)することで、変更されていないが統計エントリが古くなっているファイルのインデックスを更新できます。

たとえば、あなたが「git read-tree」を実行した後にこれを実行して、統計インデックスの詳細を適切なファイルにリンクすることができます。

@noindent

@chapheading USING --cacheinfo OR --info-only

@samp{--cacheinfo} は、現在の作業ディレクトリにないファイルを登録するために使用されます。 これは、最小チェックアウト(minimum-checkout)のマージに役立ちます。

path に mode と sha1 を持つファイルがあるように見せかけるには、以下のようにします:

@example
$ git update-index --add --cacheinfo <mode>,<sha1>,<path>
@end example


@samp{--info-only} は、ファイルをオブジェクトデータベースに配置せずに登録するために使用されます。 これは、ステータスのみ(status-only)のリポジトリに役立ちます。

@samp{--cacheinfo} と @samp{--info-only} はどちらも同じように振る舞います。インデックスは更新されますが、オブジェクトデータベースは更新されません。 @samp{--cacheinfo} は、オブジェクトがデータベースにあるが、ファイルがローカルで利用できない場合に役立ちます。 @samp{--info-only} は、ファイルが利用可能であるが、オブジェクトデータベースを更新したくない場合に役立ちます。

@noindent

@chapheading USING --index-info

@samp{--index-info} は、標準入力から複数のエントリ定義を供給できるより強力なメカニズムであり、スクリプト用に特別に設計されています。 以下の3つの形式の入力を受け取ることができます:

@enumerate 

@item
mode SP type SP sha1          TAB path

この形式は、 @samp{git ls-tree} 出力をインデックスに詰め込むためのものです。

@item
mode         SP sha1 SP stage TAB path

この形式は、より高次のステージをインデックスファイルに配置するためのものであり、 @samp{git ls-files --stage} の出力と一致します。

@item
mode         SP sha1          TAB path

この形式はGitコマンドでは生成されなくなりましたが、 @samp{update-index --index-info} では引き続きサポートされます。
@end enumerate

インデックスに上位ステージのエントリを配置するには、最初にパスに mode=0 エントリを入力してパスを削除し、次に必要な入力行を3番目の形式で入力する必要があります。

たとえば、以下のインデックスから始めます:

@example
$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz
@end example


あなたは以下の入力を @samp{--index-info} にフィードできます:

@example
$ git update-index --index-info
0 0000000000000000000000000000000000000000      frotz
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1       frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2       frotz
@end example


入力の最初の行は、パスを削除するモードとして0を供給します。 SHA-1は、適切にフォーマットされている限り問題ありません。 次に、2行目と3行目は、そのパスのステージ1とステージ2のエントリに供給します。 上記の後は、以下のようになるでしょう:

@example
$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1       frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2       frotz
@end example


@noindent

@chapheading 「assume unchanged」(無変更と仮定する)ビットの使用

Gitの多くの操作は、効率的な @samp{lstat(2)} 実装をファイルシステムに依存しているため、作業ツリーファイルの @samp{st_mtime} 情報を低コストでチェックして、ファイルの内容がインデックスファイルに記録されているバージョンから変更されているかどうかを確認できます。 残念ながら、一部のファイルシステムには非効率的な @samp{lstat(2)} があります。 ファイルシステムがそれらの1つである場合は、変更していないパスに「assume unchanged」(不変更仮定)ビットを設定して、Gitがこのチェックを行わないようにすることができます。 パスにこのビットを設定しても、Gitがファイルの内容をチェックしてファイルが変更されているかどうかを確認するわけではありません。Gitはチェックを省略し、変更されていないと見なします。 作業ツリーファイルに変更を加えるときは、変更する前または後に、「assume unchanged」ビットを削除して、Gitに明示的に通知する必要があります。

「assume unchanged」(不変更仮定)ビットを設定するには、 @samp{--assume-unchanged} オプションを使用します。 設定を解除するには、 @samp{--no-assume-unchanged} を使用します。 「assume unchanged」ビットが設定されているファイルを確認するには、 @samp{git ls-files -v} を使用します(git-ls-files(1) 参照)。

このコマンドは @samp{core.ignorestat} 構成変数を調べます。 core.ignorestat` 構成変数が true の場合、 @samp{git update-index paths...} で更新されたパスと、インデックスと作業ツリーの両方を更新する他のGitコマンド(例: @samp{git apply --index} や @samp{git checkout-index -u} や @samp{git read-tree -u})で更新されたパスは、自動的に「変更されていないと見なす」とマークされます。 注意: @samp{git update-index --refresh} が、作業ツリーファイルとインデックスが一致することを検出した場合、「assume unchanged」ビットは設定されないことに注意してください(あなたがそれらに「assume unchanged」マークを付けたい場合は、 @samp{git update-index --really-refresh} を使用してください)。

時々ユーザーは assume-unchanged ビットと skip-worktree ビットを混同することがあります。 これらの違いの説明については、 下記「Skip-worktree bit」セクションの最後の段落を参照してください。

@noindent

@chapheading EXAMPLES

すでにチェックアウトされているファイルのみをupdateおよびrefreshするには:

@example
$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh
@end example


@table @asis

@item  @samp{core.ignorestat} が設定された非効率的なファイルシステム上で… 
@example
$ git update-index --really-refresh              (1)
$ git update-index --no-assume-unchanged foo.c   (2)
$ git diff --name-only                           (3)
$ edit foo.c
$ git diff --name-only                           (4)
M foo.c
$ git update-index foo.c                         (5)
$ git diff --name-only                           (6)
$ edit foo.c
$ git diff --name-only                           (7)
$ git update-index --no-assume-unchanged foo.c   (8)
$ git diff --name-only                           (9)
M foo.c
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
lstat(2) に、インデックスに一致するパスに「assume unchanged」(無変更仮定)ビットをセットするように強制します。

@item @pxref{CO1-2,,(2)}
編集するパスをマークします。

@item @pxref{CO1-3,,(3)}
これは lstat(2) を実行し、インデックスがパスに一致することを検出します。

@item @pxref{CO1-4,,(4)}
これは lstat(2) を実行し、インデックスがパスと「一致しない」ことを検出します。

@item @pxref{CO1-5,,(5)}
新しいバージョンをインデックスに登録すると、「assume unchanged」(無変更仮定)ビットがセットされます。

@item @pxref{CO1-6,,(6)}
そしてそれは無変更と仮定されています(assumed unchanged)。

@item @pxref{CO1-7,,(7)}
それを編集した後でもです。

@item @pxref{CO1-8,,(8)}
あなたは事後に、変更について伝える事ができます。

@item @pxref{CO1-9,,(9)}
いまや、 lstat(2) をチェックして、変更されていることがわかります。
@end table
@end table

@noindent

@chapheading SKIP-WORKTREE BIT

skip-worktreeビットは1つの(長い)文で定義できます。 合理的に可能な限り作業ディレクトリへのファイルの書き込みを避け、 作業ディレクトリにファイルが存在しない場合は未変更として扱うようにgitに指示します。

注意: すべての git コマンドがこのビットに注意を払うわけではなく、部分的にしかサポートしていないものもあります。

update-index フラグと skip-worktree ビットに関連する read-tree 機能は、 git-sparse-checkout(1) コマンド導入以前のものです。 git-sparse-checkout(1) コマンド導入により、skip-worktree ビットを構成および処理するはるかに簡単な方法が提供されます。 リポジトリ内のファイルのサブセットのみを処理するように作業ツリーを縮小したい場合は、 低レベルの update-index や read-tree プリミティブに優先して、 git-sparse-checkout(1) の使用を強くお勧めします。

skip-worktree ビットの主な目的は、スパース・チェックアウトを有効にすることです。つまり、パスのサブセットのみが存在する作業ディレクトリを作成します。 skip-worktree ビットが設定されている場合、 (@samp{switch} や @samp{pull} や @samp{merge} のような) Git コマンドはこれらのファイルへの書き込みを回避します。 ただし、これらのコマンドは、マージ中またはリベース中の競合などの重要な場合に、 とにかくこれらのファイルを書き込むことがあります。 Git コマンドでは、そのようなファイルの欠如を意図的な削除として扱うことも回避します。 たとえば、 @samp{git add -u} はこれらのファイルの削除をステージングせず、 @samp{git commit -a} はそれらを削除するコミットも行いません。

このビットは、assume-unchange ビットに似ていますが、その目的は異なります。 変更されていないと仮定するビットは、 ファイルを作業ツリーに残しますが、 Git に変更のチェックを省略させ、 ファイルが変更されていないと推定するためのものです(ただし、 ファイルが変更されたと明記せずに判断できる場合は、 その変更を記録するのは自由にできます)。 skip-worktree は Git にファイルの不在を無視するように指示し、 通常は作業ディレクトリの大部分を更新するコマンド(例: @samp{checkout} や`switch` や @samp{pull} など)で可能な場合はファイルを更新しないようにし、その不在がコミットに記録されないようにします。 注意: (@samp{git sparse-checkout} または core.sparseCheckout を true に設定してセットアップする)スパース・チェックアウトでは、 ファイルがインデックスで skip-worktree としてマークされているが、作業ツリー内で見つかった場合、 Git はそのファイルの skip-worktree ビットをクリアすることに注意してください。

@noindent

@chapheading SPLIT INDEX

このモードは、非常に大きなインデックスを持つリポジトリ用に設計されており、これらのインデックスを繰り返し書き込むのにかかる時間を短縮することを目的としています。

このモードでは、インデックスは $GIT_DIR/index と $GIT_DIR/sharedindex.<SHA-1> の2つのファイルに分割されます。 変更は分割インデックスである $GIT_DIR/index に蓄積されますが、共有インデックス(shared index)ファイルにはすべてのインデックスエントリが含まれ、変更されません。

分割インデックスのエントリ数が splitIndex.maxPercentChange 構成変数で指定されたレベルに達すると、分割インデックスのすべての変更が共有インデックスファイルに押し戻されます(git-config(1) 参照)。

新しい共有インデックスファイルが作成されるたびに、古い共有インデックスファイルは、変更時間が splitIndex.sharedIndexExpire 構成変数で指定された時間よりも古い場合に削除されます(git-config(1) 参照)。

まだ使用されている共有インデックスファイルの削除を回避するために、共有インデックスファイルに基づく新しい分割インデックスが、作成または読み取られるたびに、その変更時刻が現在の時刻に更新されます。

@noindent

@chapheading UNTRACKED CACHE

このキャッシュは、 @samp{git status} などの追跡されていないファイルの判別を伴うコマンドを高速化することを目的としています。

この機能は、作業ツリーディレクトリのmtimeを記録し、mtimeが変更されていないディレクトリ内のファイルに対するディレクトリの読み取りとstat呼び出しを省略することで機能します。 これを機能させるには、ディレクトリ内のファイルが追加、変更、または削除された場合に、基盤となるオペレーティングシステムとファイルシステムがディレクトリの @samp{st_mtime} フィールドを変更する必要があります。

@samp{--test-untracked-cache} オプションを使用して、ファイルシステムがそれをサポートしているかどうかをテストできます。 @samp{--untracked-cache} オプションは、古いバージョンのGitでこのテストを暗黙的に実行するために使用されていましたが、現在はそうではありません。

この機能を有効(または無効)にする場合は、 各リポジトリで @samp{--untracked-cache} オプションを @samp{git update-index} に使用するよりも、 @samp{core.untrackedCache} 構成変数(git-config(1) 参照)を使用する方が簡単です。 特に、使用しているすべてのリポジトリに対してそうしたい場合は、あなたの @samp{$HOME/.gitconfig} で @samp{core.untrackedCache} 構成変数を @samp{true}(または @samp{false})と一度セットするだけですべてのリポジトリでその機能を使えるため、簡単です。

@samp{core.untrackedCache} 構成変数が変更されると、次にコマンドがインデックスを読み取るときに、追跡されていないキャッシュがインデックスに追加されるか、インデックスから削除されます。 一方、 @samp{--[no-|force-]untracked-cache} が使用されている場合、追跡されていないキャッシュはすぐにインデックスに追加されるか、インデックスから削除されます。

2.17より前は、追跡されていないモノのキャッシュ(untracked cache)にバグがあり、ディレクトリを別のディレクトリへのシンボリックリンクに置き換えると、gitによって追跡されたファイルが追跡されていないものとして誤って表示される可能性がありました。 git.git の「status: add a failing test showing a core.untrackedCache bug」コミットを参照してください。 その回避策は以下のとおりです(これは将来、他の未発見のバグでも機能する可能性があります):

@example
$ git -c core.untrackedCache=false status
@end example


このバグは、追跡されていないモノのキャッシュ(untracked cache)の内部構造に関して、ディレクトリをファイルに置き換えるシンボリックリンク以外のケースにも影響を与えることが示されていますが、これにより誤った「git status」出力が発生したケースは報告されていません。

2.17より前のバージョンのgitによって書き込まれた既存のインデックスが、もう存在しないディレクトリを参照し、「could not open directory」(ディレクトリを開けませんでした)という警告が「git status」に出力される可能性があります。 これらは、以前は黙って破棄されていた既存の問題に対する新しい警告です。

上記のバグと同様に、解決策は、 @samp{core.untrackedCache=false} で「git status」を1回実行して、残っている不良データをフラッシュすることです。

@noindent

@chapheading FILE SYSTEM MONITOR

この機能は、巨大な作業ディレクトリを持つリポジトリのgit操作を高速化することを目的としています。

これにより、gitはファイルシステムモニター(git-fsmonitor--daemon(1) と、 githooks(5) の「fsmonitor-watchman」セクションを参照)と連携して、どのファイルが変更されたかを通知できます。 これにより、gitは、変更されたファイルを見つけるためにすべてのファイルを lstat() する必要がなくなります。

追跡されていないモノのキャッシュ(untracked cache)と組み合わせて使用すると、作業ディレクトリ全体をスキャンして新しいファイルを探すコストを回避できるため、パフォーマンスをさらに向上させることができます。

この機能を有効(または無効)にする場合は、 各リポジトリの @samp{git update-index} に @samp{--fsmonitor} オプションを付けるよりも、 @samp{core.fsmonitor} 構成変数(git-config(1) 参照)を使用する方が簡単です。 特に、すべてのリポジトリで同じことをしたい場合は、あなたの @samp{$HOME/.gitconfig} で @samp{core.fsmonitor} 構成変数を一度設定するだけですべてのリポジトリでそれが適用されるので、使い勝手はよいでしょう。

@samp{core.fsmonitor} 構成変数が変更されると、次にコマンドがインデックスを読み取るときに、ファイルシステムモニターがインデックスに追加またはインデックスから削除されます。 @samp{--[no-]fsmonitor} を使用すると、ファイルシステムモニターはすぐにインデックスに追加またはインデックスから削除されます。

@noindent

@chapheading CONFIGURATION

このコマンドは、@samp{core.filemode} 構成変数を尊重します。
リポジトリが実行可能ビットの信頼性が低いファイルシステム上にある場合は、
これを「false」に設定する必要があります(git-config(1) 参照)。
これにより、コマンドは、インデックスに記録されたファイルモードと、
実行可能ビットのみが異なる場合はファイルシステムのファイルモードの違いを無視します。
このような不幸なファイルシステムでは、
「git update-index --chmod=」を使用する必要があるかもしれません。

まったく同様に、 @samp{core.symlinks} 構成変数が @samp{false} に設定されている場合(git-config(1) 参照)、シンボリックリンクはプレーンファイルとしてチェックアウトされ、そしてこのコマンドは記録されたファイルモードをシンボリックから通常のファイルへのリンクへ変更しません。

このコマンドは、 @samp{core.ignorestat} 構成変数を調べます。 上記「Using "assume unchanged" bit」セクションを参照してください。

このコマンドは、 @samp{core.trustctime} 構成変数も調べます。 iノードの変更時刻がGitの外部で定期的に変更される場合に便利です(ファイルシステムクローラーとバックアップシステムは、処理されたファイルのマーキングにctimeを使用します)(git-config(1) 参照)。

追跡されていないモノのキャッシュ(untracked cache)拡張は、 @samp{core.untrackedCache} 構成変数によって有効にできます(git-config(1) 参照)。

@noindent

@chapheading NOTES

ユーザーは、追跡されるファイルへの変更を無視するようにGitに指示するために、assume-unchangedビット と skip-worktreeビット を使用しようと試みることがよくありますが、 Gitは特定の操作を実行するときに、インデックスに対して作業ツリーファイルをチェックする可能性があるため、これは期待どおりに機能しません。 一般に、Gitは追跡されたファイルへの変更を無視する方法を提供しないため、別の解決策をお勧めします。

たとえば、変更するファイルがある種の構成ファイルである場合、リポジトリにサンプルの構成ファイルを含めることができます。このファイルは、無視された名前にコピーして変更できます。 リポジトリには、サンプルファイルをテンプレートとして扱い、自動的に変更およびコピーするスクリプトを含めることもできます。

@noindent

@chapheading SEE ALSO

git-config(1), git-add(1), git-ls-files(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-update-ref,,,Top
@chapheading Name

git-update-ref — refに保存されているオブジェクト名を安全に更新します

@noindent

@chapheading Synopsis

@display
git update-ref [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])
@end display


@noindent

@chapheading DESCRIPTION

2つの引数が与えられた場合、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。例えば、 @samp{git update-ref HEAD <newvalue>} は、現在のブランチヘッドを新しいオブジェクトに更新します。

3つの引数が与えられた場合、<ref>の現在の値が<oldvalue>と一致することを確認した後、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。 例えば、 @samp{git update-ref refs/heads/master <newvalue> <oldvalue>} は、現在の値が<oldvalue>の場合にのみ、masterブランチヘッドを<newvalue>に更新します。 あなたは、作成する参照がまだ存在しないこと示すために、40個の"0" または 空の文字列を <oldvalue> として指定する事ができます。

また、 "ref:" という4バイトのヘッダーシーケンスで開始することにより、「ref」ファイルを別のrefファイルへのシンボリックポインタにすることもできます。

さらに重要なことは、refファイルの更新は、シンボリックリンクであろうと、これらの「通常のファイルのシンボリック参照」であろうと、これらのシンボリックポインタに従います。 @samp{refs/} で始まる場合にのみ「実際」のシンボリックリンクをたどります。それ以外の場合は、それらを読み取って通常のファイルとして更新しようとします(つまり、ファイルシステムはそれらを追跡できますが、他の場所へのそのようなシンボリックリンクは通常のファイル名で上書きされます)。

@samp{--no-deref} を指定すると、シンボリックポインターをたどった結果ではなく、<ref>自体が上書きされます。

一般的には以下ように使います

@example
git update-ref HEAD "$head"
@end example

これは、以下のようにするよりもはるかに安全なはずです

@example
echo "$head" > "$GIT_DIR/HEAD"
@end example

シンボリックリンク追跡とエラーチェックの両方の観点から、シンボリックリンクの "refs/" ルールは、ツリーの「外側」を指すシンボリックリンクが安全であることを意味します。つまり、読み取りでは追跡されますが、書き込みでは追跡されません(したがって、シンボリックリンクツリーを作成してアーカイブ全体をコピーした場合は、refシンボリックリンクを介して他のツリーに書き込むことはありません)。

@samp{-d} フラグを使用すると、<ref>がまだ<oldvalue>を含んでいることを確認(verify)した後、名前付きの<ref>を削除します。

@samp{--stdin} を使用すると、update-refは標準入力から命令を読み取り、すべての変更を一緒に実行します。 以下の形式のコマンドを指定します:

@example
update SP <ref> SP <newvalue> [SP <oldvalue>] LF
create SP <ref> SP <newvalue> LF
delete SP <ref> [SP <oldvalue>] LF
verify SP <ref> [SP <oldvalue>] LF
option SP <opt> LF
start LF
prepare LF
commit LF
abort LF
@end example

@samp{--create-reflog} を使用すると、update-refは、通常は作成されない場合でも、各refのreflogを作成します。

Cソースコードの文字列であるかのように空白を含むフィールドをクォートします。 つまり、二重引用符で囲まれ、バックスラッシュ(@samp{\})でエスケープされます。 ゼロ値(zero value)を指定するには、40個の "0" 文字または空の文字列を使用します。 欠落している値(missing value)を指定するには、値とその前のSPを完全に省略します。

あるいは、 @samp{-z} を使用して、クォートせずにNUL終了形式で指定します:

@example
update SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL
create SP <ref> NUL <newvalue> NUL
delete SP <ref> NUL [<oldvalue>] NUL
verify SP <ref> NUL [<oldvalue>] NUL
option SP <opt> NUL
start NUL
prepare NUL
commit NUL
abort NUL
@end example

この形式では、40個の "0" を使用してゼロ値(zero value)を指定し、空の文字列を使用して欠落している値(missing value)を指定します。

どちらの形式でも、Gitがオブジェクト名として認識する任意の形式で値を指定できます。他の形式のコマンドまたは繰り返される<ref>は、エラーを生成します。 コマンドの意味は以下のとおりです:

@table @asis

@item  update 
指定されている場合は、<oldvalue>を確認した後、<ref>を<newvalue>に設定します。 ゼロ<newvalue>を指定して、更新後にrefが存在しないことを確認(verify)するか、ゼロ<oldvalue>を指定して、更新前にrefが存在しないことを確認(verify)します。

@item  create 
存在しないことを確認した後、<newvalue>を使用して<ref>を作成します。 指定された<newvalue>はゼロではない可能性があります。

@item  delete 
<oldvalue>が指定されている場合は、それが存在することを確認した後、<ref>を削除します。 指定した場合、<oldvalue>はゼロではない可能性があります。

@item  verify 
<ref>を<oldvalue>に対して確認(verify)しますが、変更しないでください。 <oldvalue>がゼロ(zero)または欠落(missing)している場合、refは存在してはなりません。

@item  option 
<ref>に名前を付ける次のコマンドの振る舞いを変更します。 唯一の有効なオプションは @samp{no-deref} で、シンボリックrefの逆参照を回避します。

@item  start 
トランザクションを開始します。 非トランザクションセッションとは対照的に、セッションが明示的なコミットなしで終了すると、トランザクションは自動的に中止(abort)されます。 このコマンドは、現在のトランザクションがすでにコミットまたは中止(abort)されている場合に、新しい空のトランザクションを作成する場合があります。

@item  prepare 
トランザクションをコミットする準備をします。 これにより、キューに入れられたすべての参照更新のロックファイルが作成されます。 ロックできない参照がある場合、トランザクションは中止(abort)されます。

@item  commit 
トランザクションのためにキューに入れられたすべての参照更新をコミットし、トランザクションを終了(ending)します。

@item  abort 
トランザクションを中止(abort)し、トランザクションが準備済み状態(prepared state)の場合はすべてのロックを解除します。
@end table

すべての<ref>を一致する<oldvalue>で同時にロックできる場合、すべての変更が実行されます。 それ以外の場合、変更は実行されません。 注意: 個々の<ref>はアトミックに更新または削除されますが、並行読み取り(concurrent reader)では変更のサブセットが表示される場合があることに注意してください。

@noindent

@chapheading LOGGING UPDATES

構成パラメーター @samp{core.logAllRefUpdates `がtrueで、参照が `refs/heads/} の下にある場合、 @samp{refs/remotes/} または @samp{refs/notes/} または HEADやORIG_HEADのような疑似参照 または ファイル @samp{$GIT_DIR/logs/<ref>} が存在する場合に、 @samp{git update-ref} はログファイル @samp{$GIT_DIR/logs/<ref>} にref値の変更を説明する行を追加します(ログ名を作成する前に、すべてのシンボリックrefを間接参照します)。 ログ行は以下のようにフォーマットされます:

@example
oldsha1 SP newsha1 SP committer LF
@end example

「oldsha1」は以前に<ref>に保存された40文字の16進値であり、「newsha1」は<newvalue>の40文字の16進値であり、「committer」は標準のGitコミッターID形式のコミッターの名前、メールアドレス、日付です。

オプションで @samp{-m} と一緒に使用すると:

@example
oldsha1 SP newsha1 SP committer TAB message LF
@end example

これは、すべてのフィールドが上記のとおりであり、「message」が @samp{-m} オプションに指定された値です。

現在のユーザーが新しいログファイルを作成できない場合、既存のログファイルに追加できない場合、またはコミッター情報が利用できない場合、更新は（<ref>を変更せずに）失敗します。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-update-server-info,,,Top
@chapheading Name

git-update-server-info — ダムサーバー(dumb servers)を支援するために補助情報ファイル(auxiliary info file)を更新する

@noindent

@chapheading Synopsis

@display
git update-server-info [-f | --force]
@end display


@noindent

@chapheading DESCRIPTION

オンザフライパック生成(on-the-fly pack generations)を行わないダムサーバー(dumb server)は、クライアントがサーバーの参照とパックを検出できるように、 $GIT_DIR/info と $GIT_OBJECT_DIRECTORY/info ディレクトリにいくつかの補助情報ファイル(auxiliary information files)を持っている必要があります。このコマンドは、そのような補助ファイルを生成します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-f} 
@itemx  @samp{--force} 
update the info files from scratch.
@end table

@noindent

@chapheading OUTPUT

現在、このコマンドは以下のファイルを更新します。それらの目的の説明については、 gitrepository-layout(5) を参照してください:

@itemize 

@item
objects/info/packs

@item
info/refs
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-upload-archive,,,Top
@chapheading Name

git-upload-archive — アーカイブを git-archive に送り返す

@noindent

@chapheading Synopsis

@display
git upload-archive <repository>
@end display


@noindent

@chapheading DESCRIPTION

@emph{git archive --remote} によって呼び出され、生成されたアーカイブをGitプロトコルを介して送信します。

このコマンドは通常、エンドユーザーによって直接呼び出されることはありません。 プロトコルのUIは @emph{git archive} 側にあり、プログラムのペアはリモートリポジトリからアーカイブを取得するために使用することを目的としています。

@noindent

@chapheading SECURITY

履歴から削除されたが、まだ剪定(prune)されてない可能性のあるオブジェクトのプライバシーを保護するために、 @samp{git-upload-archive} は、リポジトリのrefから到達できないコミットおよびツリーのアーカイブの提供を回避します。ただし、オブジェクトの到達可能性の計算には計算コストがかかるため、 @samp{git-upload-archive} は、より厳密でありながらチェックしやすい一連のルールを実装します。

@enumerate 

@item
クライアントは、refが直接指すコミットまたはツリーを要求できます。 例: @samp{git archive --remote=origin v1.0}

@item
クライアントは、 @samp{ref：path} 構文を使用して、コミットまたはツリー内のサブツリーを要求できます。例: @samp{git archive --remote=origin v1.0:Documentation}

@item
最終結果に到達できる場合でも、クライアントは他のsha1式を使用できません。 たとえば、refから結果に到達できる場合でも、 @samp{master^} のような相対コミットや @samp{abcd1234} のようなリテラルsha1は許可されません。
@end enumerate

注意: 3番目の規則3は、プライバシーに影響を与えない多くの場合を許可しないことに注意してください。これらのルールはgitの将来のバージョンで変更される可能性があり、 @samp{git archive --remote} によってアクセスされるサーバーは、これらの正確なルールに従う場合と従わない場合があります。

構成オプション @samp{uploadArchive.allowUnreachable} がtrueの場合、これらの規則は無視され、クライアントは任意のsha1式を使用できます。これは、到達不能なオブジェクトのプライバシーを気にしない場合、またはオブジェクトデータベースが非スマートhttp経由でアクセスできるようにすでに公開されている場合に役立ちます。

@noindent

@chapheading OPTIONS

@table @asis

@item  <repository> 
tarアーカイブを取得するリポジトリ。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-upload-pack,,,Top
@chapheading Name

git-upload-pack — パックされたオブジェクトをgit-fetch-packに送り返す

@noindent

@chapheading Synopsis

@display
git-upload-pack [--[no-]strict] [--timeout=<n>] [--stateless-rpc]
                  [--advertise-refs] <directory>
@end display


@noindent

@chapheading DESCRIPTION

@samp{git fetch-pack} によって呼び出され、通信の反対側で欠落しているオブジェクトを調べ、パッキング後にそれらを送信します。

このコマンドは通常、エンドユーザーによって直接呼び出されることはありません。プロトコルのUIは「git fetch-pack」側にあり、プログラムのペアはリモートリポジトリから更新をプルするために使用されることを目的としています。プッシュ操作については、「git send-pack」を参照してください。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--[no-]strict} 
<directory> Gitディレクトリでない場合、 <directory>/.git/ を試さない

@item  @samp{--timeout=<n>} 
非アクティブになった <n> 秒後に転送を中断します。

@item  @samp{--stateless-rpc} 
stdinとstdoutを使用して 読み取り/書き込み サイクルを1回だけ実行します。これは、プログラムが要求を読み取り、応答を書き込み、終了する必要があるHTTP POST要求処理モデルに適合します。

@item  @samp{--http-backend-info-refs} 
@samp{$GIT_URL/info/refs?service=git-upload-pack} リクエストを処理するために git-http-backend(1) によって使用されます。 gitprotocol-http(5) の「Smart Clients」と gitprotocol-v2(5) ドキュメントの「HTTP Transport」を参照してください。 git-receive-pack(1) でも理解されます。

@item  <directory> 
同期元のリポジトリ。
@end table

@noindent

@chapheading ENVIRONMENT

@table @asis

@item  @samp{GIT_PROTOCOL} 
ワイヤープロトコルをハンドシェイクするために使用される内部変数。サーバー管理者は、この変数を渡すことができるようにいくつかのトランスポートを構成する必要がある場合があります。 git(1) のdiscussionを参照してください。
@end table

@noindent

@chapheading SEE ALSO

gitnamespaces(7)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-var,,,Top
@chapheading Name

git-var — Git論理変数を表示します

@noindent

@chapheading Synopsis

@display
git var (-l | <variable>)
@end display


@noindent

@chapheading DESCRIPTION

Prints a Git logical variable. Exits with code 1 if the variable has no value.

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-l} 
論理変数をリストします。さらに、Git構成ファイル .git/config のすべての変数も一覧表示されます。 (ただし、構成変数を一覧表示する機能は非推奨になり、 @samp{git config -l} が採用されました。)
@end table

@noindent

@chapheading EXAMPLES

@example
$ git var GIT_AUTHOR_IDENT
Eric W. Biederman <ebiederm@@lnxi.com> 1121223278 -0600
@end example

@noindent

@chapheading VARIABLES

@table @asis

@item  GIT_AUTHOR_IDENT 
コードの作者。

@item  GIT_COMMITTER_IDENT 
コードの一部をGitに入れた人。

@item  GIT_EDITOR 
Gitコマンドで使用するためのテキストエディタ。 この値は、 使用時にシェルによって解釈されることを意図しています。 例: @samp{~/bin/vi} 、 @samp{$SOME_ENVIRONMENT_VARIABLE} 、 @samp{"C:\Program Files\Vim\gvim.exe" --nofork} 。 優先順位は、 @samp{$GIT_EDITOR} 環境変数 、@samp{core.editor} 構成、 @samp{$VISUAL} 、@samp{$EDITOR} 、そしてコンパイル時に選択されるデフォルト(通常は @samp{vi})です。

@item  GIT_SEQUENCE_EDITOR 
Text editor used to edit the @emph{todo} file while running @samp{git rebase -i}. Like @samp{GIT_EDITOR}, the value is meant to be interpreted by the shell when it is used. The order of preference is the @samp{$GIT_SEQUENCE_EDITOR} environment variable, then @samp{sequence.editor} configuration, and then the value of @samp{git var GIT_EDITOR}.

@item  GIT_PAGER 
Gitコマンドで使用するためのテキストビューア(例: less)。値はシェルによって解釈されることを意図しています。 優先順位は、 @samp{$GIT_PAGER} 環境変数、 @samp{core.pager} 構成、 @samp{$PAGER} 、そしてコンパイル時に選択されるデフォルト(通常は @samp{less})です。

@item  GIT_DEFAULT_BRANCH 
新しく初期化されたリポジトリで作成された最初のブランチの名前。

@item  GIT_SHELL_PATH 
The path of the binary providing the POSIX shell for commands which use the shell.

@item  GIT_ATTR_SYSTEM 
The path to the system gitattributes(5) file, if one is enabled.

@item  GIT_ATTR_GLOBAL 
The path to the global (per-user) gitattributes(5) file.

@item  GIT_CONFIG_SYSTEM 
The path to the system configuration file, if one is enabled.

@item  GIT_CONFIG_GLOBAL 
The path to the global (per-user) configuration files, if any.
@end table

Most path values contain only one value. However, some can contain multiple values, which are separated by newlines, and are listed in order from highest to lowest priority. Callers should be prepared for any such path value to contain multiple items.

Note that paths are printed even if they do not exist, but not if they are disabled by other environment variables.

@noindent

@chapheading SEE ALSO

git-commit-tree(1) git-tag(1) git-config(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-verify-commit,,,Top
@chapheading Name

git-verify-commit — コミットのGPG署名を確認します。

@noindent

@chapheading Synopsis

@display
git verify-commit [-v | --verbose] [--raw] <commit>…
@end display


@noindent

@chapheading DESCRIPTION

@emph{git commit -S} によって作成されたGPG署名を検証します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--raw} 
通常の人間が読める形式の出力ではなく、生のgpgステータス出力を、標準エラーに出力します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
検証する前に、コミットオブジェクトの内容を出力します。

@item  <commit>… 
GitコミットオブジェクトのSHA-1 ID。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-verify-pack,,,Top
@chapheading Name

git-verify-pack — パックされたGitアーカイブファイルを検証する

@noindent

@chapheading Synopsis

@display
git verify-pack [-v | --verbose] [-s | --stat-only] [--] <pack>.idx…
@end display


@noindent

@chapheading DESCRIPTION

@emph{git pack-objects} コマンドで作成されたパックされたGitアーカイブの指定のidxファイルを読み取り、idxファイルと、対応するパックファイルが正しいことを確認します。

@noindent

@chapheading OPTIONS

@table @asis

@item  <pack>.idx … 
確認するidxファイル(複数ファイル指定可)

@item  @samp{-v} 
@itemx  @samp{--verbose} 
パックを確認した後、パックに含まれるオブジェクトのリストとデルタチェーン長のヒストグラムを表示します。

@item  @samp{-s} 
@itemx  @samp{--stat-only} 
パックの内容を確認せず、デルタチェーン長のヒストグラムのみを表示します。 @samp{--verbose} を使用すると、オブジェクトのリストも表示されます。

@item  -- 
これ以降の引数をオプションとして解釈しないでください。
@end table

@noindent

@chapheading OUTPUT FORMAT

オプション -v を指定する場合、使用される形式は以下のとおりです:

@example
SHA-1 type size size-in-packfile offset-in-packfile
@end example

は、パックで削除されていないオブジェクトの場合です。そして、

@example
SHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1
@end example

は、削除されたオブジェクトの場合です。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-verify-tag,,,Top
@chapheading Name

git-verify-tag — タグのGPG署名を確認する

@noindent

@chapheading Synopsis

@display
git verify-tag [-v | --verbose] [--format=<format>] [--raw] <tag>…
@end display


@noindent

@chapheading DESCRIPTION

@emph{git tag} によって作成されたgpg署名を検証します。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--raw} 
通常の人間が読める形式の出力の代わりに、生のgpgステータス出力を標準エラーに出力します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
検証する前に、タグオブジェクトの内容を出力します。

@item  <tag>… 
GitタグオブジェクトのSHA-1 ID。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-version,,,Top
@chapheading Name

git-version — Gitに関するバージョン情報を表示する

@noindent

@chapheading Synopsis

@display
git version [--build-options]
@end display


@noindent

@chapheading DESCRIPTION

オプションが指定されていない場合、 @emph{git} のバージョンが標準出力に出力されます。

@samp{git --version} は @samp{git version} と同じであることに注意してください。これは、前者が内部で後者に変換されるためです。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--build-options} 
診断目的でgitがどのように構築されたかに関する追加情報を含めます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-web--browse,,,Top
@chapheading Name

git-web--browse — Webブラウザを起動するためのGitヘルパースクリプト

@noindent

@chapheading Synopsis

@display
git web--browse [<options>] (<URL>|<file>)…
@end display


@noindent

@chapheading DESCRIPTION

このスクリプトは、引数として渡されたURLとファイルを、可能な限り、既に開いているWebブラウザーの新しいタブにHTMLページとして表示しようとします。

現在、以下のブラウザ(またはコマンド)がサポートされています:

@itemize 

@item
firefox (これは、KDEを使用しない場合のX Windowのデフォルトです)

@item
iceweasel

@item
seamonkey

@item
iceape

@item
chromium (chromium-browser としてもサポートされています)

@item
google-chrome (chromeとしてもサポートされています)

@item
konqueror (これはKDEのデフォルトです。以下の「Note about konqueror」を参照してください)

@item
opera

@item
w3m (これはグラフィカル環境以外のデフォルトです)

@item
elinks

@item
links

@item
lynx

@item
dillo

@item
open (これはMac OS X GUIのデフォルトです)

@item
start (これはMinGWのデフォルトです)

@item
cygstart (これはCygwinのデフォルトです)

@item
xdg-open
@end itemize

カスタムコマンドを指定することもできます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-b <browser>} 
@itemx  @samp{--browser=<browser>} 
指定のブラウザを使用します。サポートされているブラウザのリストに含まれている必要があります。

@item  @samp{-t <browser>} 
@itemx  @samp{--tool=<browser>} 
同上。

@item  @samp{-c <conf.var>} 
@itemx  @samp{--config=<conf.var>} 
CONF.VAR はGit構成ファイルで検索されます。設定されている場合、その値は使用するブラウザを指定します。
@end table

@noindent

@chapheading CONFIGURATION VARIABLES

@noindent

@heading CONF.VAR( -c 由来) と web.browser

Webブラウザーは、 @samp{-c} (または @samp{--config})コマンドラインオプションで渡される構成変数、または前者が使用されていない場合は @samp{web.browser} 構成変数を使用して指定できます。

@noindent

@heading browser.<tool>.path

あなたは構成変数 @samp{browser.<tool>.path} を設定することにより、希望するブラウザーへのフルパスを明示的に指定できます。たとえば、 @samp{browser.firefox.path} を設定することで、Firefoxへの絶対パスを設定できます。それ以外の場合、 @samp{git web@{litdd@}browse} はツールがPATH上にあると想定します。

@noindent

@heading browser.<tool>.cmd

オプションまたは構成変数で指定されたブラウザーがサポートされているブラウザーに含まれていない場合、対応する @samp{browser.<tool>.cmd} 構成変数が検索されます。 この変数が存在する場合、 @samp{git web@{litdd@}browse} は指定されたツールをカスタムコマンドとして扱い、シェルのevalを使用してURLを引数として渡してコマンドを実行します。

@noindent

@chapheading NOTE ABOUT KONQUEROR

@samp{konqueror} がコマンドラインオプションまたは構成変数で指定されている場合、可能であれば、 @samp{kfmclient} を起動して、既に開いているkonquerorのHTMLマニュアルページを新しいタブで開こうとします。

一貫性を保つために、 @samp{browser.konqueror.path} が @samp{A_PATH_TO/konqueror} のように設定されている場合にも、このようなトリックを試します。 つまり、代わりに @samp{A_PATH_TO/kfmclient} を起動しようと試みます。

あなたが本当に @samp{konqueror} の使用を望むのなら、あなたは以下のようなものを使用できます:

@example
        [web]
                browser = konq

        [browser "konq"]
                cmd = A_PATH_TO/konqueror
@end example


@noindent

@heading 注意: git-config --global について

注意: これらの構成変数は、おそらく以下のように @samp{--global} フラグを使用して設定する必要があることに注意してください:

@example
$ git config --global web.browser firefox
@end example


なぜなら、おそらくリポジトリ固有よりもユーザー固有であるためです。詳細については、 git-config(1) を参照してください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-whatchanged,,,Top
@chapheading Name

git-whatchanged — 各コミットでの差分のログを表示

@noindent

@chapheading Synopsis

@display
git whatchanged <option>…
@end display


@noindent

@chapheading DESCRIPTION

各コミットのコミットログとdiff出力を表示します。

新規ユーザーは、これの代わりに git-log(1) を使用することをお勧めします。 @samp{whatchanged} コマンドは基本的に git-log(1) と同じですが、デフォルトでは生の形式の差分出力を表示し、マージをスキップします。

このコマンドは主に歴史的な理由で保持されています。@samp{git log} が発明されるずっと前に Linux kernel mailing list を読んで Gitを学んだ多くの人々の指は、このコマンドをタイプするよう訓練されています。

@noindent

@chapheading Examples

@table @asis

@item  @samp{git whatchanged -p v2.6.12.. include/scsi drivers/scsi} 
include/scsi または drivers/scsi サブディレクトリ内のファイルを変更したバージョン @emph{v2.6.12} 以降のコミットをパッチとして表示する

@item  @samp{git whatchanged --since="2 weeks ago" -- gitk} 
過去2週間の変更をファイル @emph{gitk} に表示します。 "--" は、「ブランチ名 @emph{gitk} 」との混同を避けるために必要です。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-worktree,,,Top
@chapheading Name

git-worktree — 複数の作業ツリー(working tree)を管理します

@noindent

@chapheading Synopsis

@display
git worktree add [-f] [--detach] [--checkout] [--lock [--reason <string>]]
                   [--orphan] [(-b | -B) <new-branch>] <path> [<commit-ish>]
git worktree list [-v | --porcelain [-z]]
git worktree lock [--reason <string>] <worktree>
git worktree move <worktree> <new-path>
git worktree prune [-n] [-v] [--expire <expire>]
git worktree remove [-f] <worktree>
git worktree repair [<path>…]
git worktree unlock <worktree>
@end display


@noindent

@chapheading DESCRIPTION

同一のリポジトリに接続されている複数の作業ツリーを管理します。

gitリポジトリは複数の作業ツリー(working tree)をサポートできるため、一度に複数のブランチをチェックアウトできます。 @samp{git worktree add} を使用すると、 新しい作業ツリーがリポジトリに関連付けられ、 その作業ツリーを、同一リポジトリの他の作業ツリーと区別する、追加のメタデータを関連付けます。 作業ツリーは、このメタデータとひっくるめて worktree (ワークツリー)と呼ばれます。

この新しい worktree は、 git-init(1) または git-clone(1) によって準備された「メイン worktree」とは対照的に、「リンクされた worktree」(linked worktree)と呼ばれます。 リポジトリには、1 つの メイン worktree (ベア・リポジトリでない場合) と、0 個以上のリンクされた worktree があります。 リンクされたworktree を使い終わったら、 @samp{git worktree remove} で削除します。

最も単純な形式では、 @samp{git worktree add <path>} は、名前が @samp{<path>} の最後のコンポーネントである新しいブランチを自動的に作成します。これは、あなたが新しいトピックで作業する場合に便利です。たとえば、 @samp{git worktree add ../hotfix} は、新しいブランチ @samp{hotfix} を作成し、パス @samp{../hotfix} でチェックアウトします。代わりに、既存のブランチの新しい worktree で作業するには、 @samp{git worktree add <path> <branch>} を使用します。一方、既存の開発を妨げることなく実験的な変更やテストを行う場合は、ブランチに関連付けられていない「使い捨て」の worktree を作成すると便利なことがよくあります。たとえば、 @samp{git worktree add -d <path>} は、現在のブランチと同じコミットで、切り離された`HEAD`(detached HEAD)を持つ新しい worktree を作成します。

@samp{git worktree remove} を使用せずに作業ツリーを削除すると、リポジトリにある関連する管理ファイル(後述の「DETAILS」参照)が最終的には自動的に削除されます(git-config(1) の @samp{gc.worktreePruneExpire} 参照)。 または、メインまたはリンクされた worktree で、古い管理ファイルをクリーンアップするために @samp{git worktree prune} を実行できます。

リンクされた workutree の作業ツリー(working tree)が、常にマウントされている訳ではないポータブル・デバイスまたはネットワーク共有に保存されている場合、 @samp{git worktree lock} コマンド(オプションで @samp{--reason} を指定して worktree がなぜロックされているかを説明)を発行することで、 管理ファイルが刈り込み(prune)されるのを防ぐことができます。

@noindent

@chapheading COMMANDS

@table @asis

@item  add <path> [<commit-ish>] 
@samp{<path>} に worktree を作成し、 そこに @samp{<commit-ish>} をチェックアウトします。 新しい worktree は現在のリポジトリにリンクされ、 @samp{HEAD} 、 @samp{index} などの worktree ごとのファイルを除くすべてを共有します。 便宜上、 @samp{<commit-ish>} は、 @samp{@@@{-1@}} と同義の @samp{-} だけでもかまいません。

上記 @samp{<commit-ish>} がブランチ名(以下 @samp{<branch>} とします)で見つからず、 @samp{-b} や @samp{-B} や @samp{--detach} のいずれも使用されていないが、名前が一致する1つのリモート(以下 @samp{<remote>} とします)には追跡ブランチが存在する場合、上記は以下と同等です:

@example
$ git worktree add --track -b <branch> <path> <remote>/<branch>
@end example


ブランチが複数のリモートに存在し、そのうちの1つが @samp{checkout.defaultRemote} 設定変数によって名付けられた場合、 @samp{<branch>} がすべてのリモートでユニークでなくても、曖昧さをなくすためにその1つを使用します。例えば、 @samp{checkout.defaultRemote=origin} と設定すると、 @samp{<branch>} があいまいで、かつ @samp{origin} リモートに存在する場合、常にそこからリモートブランチをチェックアウトすることができます。git-config(1) にある @samp{checkout.defaultRemote} も参照してください。

@samp{<commit-ish>} が省略され、 @samp{-b} も @samp{-B} も @samp{--detach} も使用されていない場合、便宜上、新しい worktree は @samp{$(basename <path>)} にちなんで名付けらたブランチ(@samp{<branch>} とします)に関連付けられます。@samp{<branch>} が存在しない場合、 @samp{-b <branch>} が指定されたかのように、 @samp{HEAD} に基づく新しいブランチが自動的に作成されます。 @samp{<branch>} が存在する場合で、他の場所でチェックアウトされていない場合は、新しい worktree でチェックアウトされます。 存在しない場合、(@samp{--force} が使用されている場合を除き、)コマンドは worktree の作成を拒否します。

If @samp{<commit-ish>} is omitted, neither @samp{--detach}, or @samp{--orphan} is used, and there are no valid local branches (or remote branches if @samp{--guess-remote} is specified) then, as a convenience, the new worktree is associated with a new orphan branch named @samp{<branch>} (after @samp{$(basename <path>)} if neither @samp{-b} or @samp{-B} is used) as if @samp{--orphan} was passed to the command. In the event the repository has a remote and @samp{--guess-remote} is used, but no remote or local branches exist, then the command fails with a warning reminding the user to fetch from their remote first (or override by using @samp{-f/--force}).

@item  list 
各 worktree の詳細を一覧表示します。 リストの最初はメインの worktree であり、その後にリンクされた各 worktree が続きます。 出力の詳細として、 worktree が裸(bare)かどうかや、 現在チェックアウトされているリビジョン(または、存在しない場合は「切り離された HEAD」
@cindex detached HEAD)
detached HEAD)や、 現在チェックアウトされているブランチや、 worktree がロックされているなら @samp{locked} が出力に含まれ、 worktree が @samp{prune} コマンドでプルーニングできる場合は @samp{prunable} が出力に含まれます。

@item  lock 
worktree が常にマウントされているとは限らないポータブルデバイスまたはネットワーク共有上にある場合は、 管理ファイルが自動的に刈り込み(prune)されないようにツリーをロック(lock)します。 これにより、移動や削除も防止されます。 オプションの`--reason` を使用してロック理由を記述します。

@item  move 
注意: worktree を新しい場所に移動します。このコマンドでは、 メインの worktree または、 サブモジュールを含むリンクされた worktree (linked worktree)は、移動できないことに注意してください。 (ただし、 @samp{git worktree repair} コマンドを使用すると、メインの worktree を手動で移動した場合、 リンクされた worktree ごとの接続を再確立できます。)

@item  prune 
@samp{$GIT_DIR/worktrees} の worktree 情報を刈り込みます(prune)。

@item  remove 
worktgree を削除します。削除できるのは、クリーンな worktree (追跡してないファイルが無く、かつ、追跡ファイルの変更が無い場合)のみです。綺麗でない(unclean) worktree または、サブモジュールのある worktree は、 @samp{--force} を使用して削除できます。メインの worktree は削除できません。

@item  repair [<path>…] 
可能であれば、外部要因によって、破損または古くなった worktree 管理ファイルを修復します。

たとえば、メインの worktree (またはベア・リポジトリ)を移動すると、リンクされた worktree (linked worktree)はそれを見つけることができなくなります。 メインの worktree で @samp{repair} を実行すると、リンクされた worktree からメインの worktree への接続が再確立されます。

同様に、リンクされた worktree (linked worktree)が @samp{git worktree move} を使用せずに移動された場合、 メイン worktree (またはベア・リポジトリ)はそれを見つけることができません。 直近に移動した worktree 内で @samp{repair} を実行すると、接続が再確立されます。 リンクされた worktree が複数移動された場合、 各 worktree の新しい @samp{<path>} を引数として任意の worktree から @samp{repair} を実行すると、指定されたすべてのパスへの接続が再確立されます。

メイン worktree とリンクされた worktree (linked worktree)の両方が手動で移動された場合、メイン worktree で @samp{repair} を実行し、 各リンクされた worktree の新しい @samp{<path>} を指定すると、両方向のすべての接続が再確立されます。

@item  unlock 
worktree のロックを解除(unlock)して、刈り込み(prune)または移動(move)または削除(delete)できるようにします。
@end table

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-f} 
@itemx  @samp{--force} 
デフォルトでは、@samp{<commit-ish>} がブランチ名であり、別の worktree によってすでにチェックアウトされている場合、 または @samp{<path>} がすでに worktree に割り当てられているが欠落している場合(たとえば、 @samp{<path>`が手動で削除された場合)、 `add} は新しい worktree の作成を拒否します。 このオプションは、これらの安全装置(safeguards)をオーバーライドします。 欠落しているがロックされている worktree パスを追加するには、 @samp{--force} を2回指定します。

@samp{--force} が2回指定されていない限り、 @samp{move} はロックされた worktree の移動を拒否します。移動先がすでに他の worktree に割り当てられているが欠落している場合(たとえば、 @samp{<new-path>} が手動で削除された場合)は、 @samp{--force} で移動を続行できます。移動先がロックされている場合は、 @samp{--force} を2回使用します。

@samp{remove} は、 @samp{--force} が使用されない限り、 クリーンでない(unclean)worktreeの削除を拒否します。 ロックされた(locked)worktreeを削除するには、 @samp{--force} を 2 回指定します。

@item  @samp{-b <new-branch>} 
@itemx  @samp{-B <new-branch>} 
@samp{add} を使用して、 @samp{<commit-ish>} から開始する @samp{<new-branch>} という名前の新しいブランチを作成し、 @samp{<new-branch>} を新しい worktree にチェックアウトします。 @samp{<commit-ish>} を省略すると、 デフォルトで @samp{HEAD} になります。 デフォルトでは、 @samp{-b} は、 新しいブランチがすでに存在する場合、そのブランチを作成することを拒否します。 @samp{-B} はこの安全装置をオーバーライドし、 @samp{<new-branch>} を @samp{<commit-ish>} にリセットします。

@item  @samp{-d} 
@itemx  @samp{--detach} 
@samp{add} を使用して、新しい worktree で @samp{HEAD} を切り離します(detach)。 git-checkout(1) の「DETACHED HEAD」を参照してください。

@item  @samp{--[no-]checkout} 
デフォルトでは、 @samp{add} は @samp{<commit-ish>} をチェックアウトしますが、 @samp{--no-checkout} を使用して、スパースチェックアウト(suppress checkout)の構成などのカスタマイズを行うためにチェックアウトを抑制することができます。 git-read-tree(1) の「Sparse checkout」を参照してください。

@item  @samp{--[no-]guess-remote} 
@samp{<commit-ish>} を伴わずに @samp{worktree add <path>} を使用し、 @samp{HEAD} から新しいブランチを作成する代わりに、 @samp{<path>} のベース名に一致する追跡ブランチが１つリモートにだけ存在する場合、新しいブランチをそのリモート追跡ブランチに基づいて作成し、そのリモート追跡ブランチを新しいブランチの「アップストリーム」としてマークします。

これは、 @samp{worktree.guessRemote} 構成オプションを使用してデフォルトの動作として設定することもできます。

@item  @samp{--[no-]track} 
新しいブランチを作成するときに、 @samp{<commit-ish>} がブランチである場合は、新しいブランチの「アップストリーム」としてマークします。 @samp{<commit-ish>} がリモート追跡ブランチの場合、これの振る舞いがデフォルトです。詳細については、 git-branch(1)の @samp{--track} を参照してください。

@item  @samp{--lock} 
作成後は、 worktree をロックしたままにします。 これは、 @samp{git worktree add} の後に @samp{git worktree lock} するのと同等ですが、競合状態(race condition)にはなりません。

@item  @samp{-n} 
@itemx  @samp{--dry-run} 
@samp{prune} では、何も削除しないでください。何が削除されるかを報告するだけです。

@item  @samp{--orphan} 
With @samp{add}, make the new worktree and index empty, associating the worktree with a new orphan/unborn branch named @samp{<new-branch>}.

@item  @samp{--porcelain} 
@samp{list} を使用すると、スクリプトの解析が容易な形式で出力されます。この形式は、Gitのバージョン間で、ユーザー構成に関係なく安定しています。 これは @samp{-z} と組み合わせることをお勧めします。 詳細については、後述します。

@item  @samp{-z} 
@samp{list} で @samp{--porcelain} が指定されている場合、改行(newline)ではなく NUL で各行を終了します。 これにより、 worktree パスに改行文字が含まれている場合、出力をパースできます。

@item  @samp{-q} 
@itemx  @samp{--quiet} 
@samp{add} を使用して、フィードバックメッセージを抑制します。

@item  @samp{-v} 
@itemx  @samp{--verbose} 
@samp{prune} を使用して、すべての削除を報告します。

@samp{list} を使用して、worktreeに関する追加情報を出力します(後述)。

@item  @samp{--expire <time>} 
@samp{prune} と共に使うと、 @samp{<time>} より古い未使用の worktree のみを期限切れにします。

@samp{list} と共に使うと、 @samp{<time>} より古い場合は、欠落している worktree に刈り込み可能(prunable)という注釈(annotate)を付けます。

@item  @samp{--reason <string>} 
@samp{lock} または @samp{add --lock} と共に使用して、その worktree がなぜロックされているかを記述します。

@item  <worktree> 
worktree は、相対パスまたは絶対パスのいずれかで識別できます。

worktree のパスの最後のパスコンポーネントが worktree 間で一意である場合、それを使用して worktree を識別できます。 たとえば、 @samp{/abc/def/ghi} と @samp{/abc/def/ggg} の2つの worktree しかない場合、 これらの worktree を指すには、 @samp{ghi} または @samp{def/ghi} で十分です。
@end table

@noindent

@chapheading REFS

複数の worktree を使用する場合、一部のrefはすべての worktree 間で共有されますが、その他は個々の worktree に固有です。 その一例が @samp{HEAD} で、これは worktree ごとに異なります。 このセクションでは、共有ルールと、ある worktree の ref を別の worktree からアクセスする方法について説明します。

一般に、すべての疑似ref(pseudo refs)は worktree ごとにあり、そして、 @samp{refs/} で始まるすべてのrefは共有されます。 疑似refは、 @samp{$GIT_DIR/refs} 内ではなく、 @samp{$GIT_DIR} の直下にある @samp{HEAD} のようなものです。 ただし、例外があります。 @samp{refs/bisect} 内のrefと @samp{refs/worktree} は共有されません。

worktree ごとのrefには、 別の worktree から、 @samp{main-worktree} と @samp{worktrees} の2つの特別なパスを介してアクセスできます。 前者はメインの worktree の worktree ごとのrefを提供し、後者はすべてのリンクされた worktree へのアクセスを提供します。

たとえば、 @samp{main-worktree/HEAD} や @samp{main-worktree/refs/bisect/good} は、それぞれメイン worktree の @samp{HEAD} や @samp{refs/bisect/good ` と同一の値に解決されます。 同様に、 `worktrees/foo/HEAD} や @samp{worktrees/bar/refs/bisect/bad} は、 @samp{$GIT_COMMON_DIR/worktrees/foo/HEAD} や @samp{$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad} と同一です。

refにアクセスするのに @samp{$GIT_DIR} の内部を直接調べないことをお勧めします。代わりに、refを正しく処理する git-rev-parse(1) や git-update-ref(1) などのコマンドを使用してください。

@noindent

@chapheading CONFIGURATION FILE

デフォルトでは、リポジトリの @samp{config} ファイルはすべての worktree で共有されます。 構成変数 @samp{core.bare} または @samp{core.worktree} が共通の構成ファイルに存在し、 @samp{extensions.worktreeConfig} が無効になっている場合、それらはメイン worktree のみに適用されます。

worktree 固有の構成を作成するには、 @samp{worktreeConfig} 拡張機能をオンにします。例:

@example
$ git config extensions.worktreeConfig true
@end example


このモードでは、指定の構成は @samp{git rev-parse --git-path config.worktree} が指すパスに残ります。 @samp{git config --worktree} を使用して、このファイルの構成を追加または更新できます。古いバージョンのGitは、この拡張機能を備えたリポジトリへのアクセスを拒否します。

注意: このファイルでは、 @samp{core.bare} と @samp{core.worktree} が例外扱いされないことに注意してください。 それらが @samp{$GIT_DIR/config} に存在する場合は、メイン worktree の @samp{config.worktree} に移動する必要があります。 また、この機会に、あなたが共有したくない他の構成を確認して、すべての worktree に移動することもできます。

@itemize 

@item
@samp{core.worktree} は決して共有しないでください。

@item
@samp{core.bare} は、 値が @samp{core.bare=true} である場合には共有されるべきではありません。

@item
すべての worktree に対して常にスパース・チェックアウトを使用することが確実でない限り、 @samp{core.sparseCheckout} は共有すべきではありません。
@end itemize

詳細については、 git-config(1) の @samp{extensions.worktreeConfig} のドキュメントを参照してください。

@noindent

@chapheading DETAILS

各々のリンクされた workutree (linked worktree)には、 リポジトリの @samp{$ GIT_DIR/worktrees} ディレクトリにプライベート・サブ・ディレクトリがあります。 プライベート・サブ・ディレクトリの名前は通常、リンクされた worktree のパスのベース名であり、 一意にするために番号が追加される場合があります。 たとえば、 @samp{$GIT_DIR=/path/main/.git} の場合、 コマンド @samp{git worktree add /path/other/test-next next} はリンクされた worktree を @samp{/path/other/test-next} に作成し、 そしてまた @samp{$GIT_DIR/worktrees/test-next} ディレクトリ(または、 @samp{test-next} がすでに存在する場合、 @samp{$GIT_DIR/worktrees/test-next1} ディレクトリ)を作成します。

リンクされた worktree (linked worktree)内で、 @samp{$GIT_DIR} は、このプライベート・ディレクトリを指すように設定され(例では @samp{/path/main/.git/worktrees/test-next})、 @samp{$GIT_COMMON_DIR} はメイン worktree の @samp{$GIT_DIR} (例では @samp{/path/main/.git} )を指すように設定されます。これらの設定は、リンクされた worktree の最上位ディレクトリにある @samp{.git} ファイルで行われます。

@samp{git rev-parse --git-path} によるパス解決では、 パスに応じて @samp{$GIT_DIR} または @samp{$GIT_COMMON_DIR} のいずれかが使用されます。たとえば、リンクされた worktree (linked worktree)では、 @samp{git rev-parse --git-path HEAD} は @samp{/path/main/.git/worktrees/test-next/HEAD} を返します(@samp{/path/other/test-next/.git/HEAD} や @samp{/path/main/.git/HEAD} ではありません)。 一方、 @samp{git rev-parse --git-path refs/heads/master} は @samp{$GIT_COMMON_DIR} を使用し、 @samp{/path/main/.git/refs/heads/ master} を返します。 refは、 @samp{refs/bisect} と @samp{refs/worktree} を除くすべての worktree で共有されるためです。

詳細については、 gitrepository-layout(5) を参照してください。 経験則では、 @samp{$GIT_DIR} 内の何かに直接アクセスする必要がある場合、パスが @samp{$GIT_DIR} または @samp{$GIT_COMMON_DIR} のどちらに属するかについては何も想定していません。 @samp{git rev-parse --git-path} を使用して、最終的なパスを取得してください。

リンクされた worktree (linked worktree)を手動で移動する場合は、 エントリのディレクトリにある @samp{gitdir} ファイルを更新する必要があります。 たとえば、リンクされた作業ツリーが @samp{/newpath/test-next} に移動され、 その @samp{.git} ファイルが @samp{/path/main/.git/worktrees/test-next} を指しているならば、 代わりに @samp{/path/main/.git/worktrees/test-next/gitdir} を更新し @samp{/newpath/test-next} を参照するようにします。 もっといいのは、 @samp{git worktree repair} を実行して、接続を自動的に再確立することです。

@samp{$GIT_DIR/worktrees} エントリが刈り込み(prune)されないようにする(これは、 エントリの worktree がポータブルデバイスに保存されている場合など、 状況によっては便利です)には、 @samp{git worktree lock} コマンドを使用します。 このコマンドは @samp{locked} という名前のファイルをエントリのディレクトリに追加します。 ファイルには、 理由(reason)がプレーンテキストで含まれています。 たとえば、リンクされた worktree (linked worktree)の @samp{.git} ファイルが @samp{/path/main/.git/worktrees/test-next} を指しているならば、 @samp{/path/main/.git/worktrees/test-next/locked} という名前のファイルは @samp{test-next} エントリが刈り込み(pruned)されるのを防ぎます。 詳細については、 gitrepository-layout(5) を参照してください。

@samp{extensions.worktreeConfig} が有効になっている場合、設定ファイル @samp{.git/worktrees/<id>/config.worktree} は @samp{.git/config} の後に読み込まれます。

@noindent

@chapheading LIST OUTPUT FORMAT

@samp{worktreelist} コマンドには2つの出力形式があります。デフォルトの形式では、詳細が1行に複数列で表示されます。例えば:

@example
$ git worktree list
/path/to/bare-source            (bare)
/path/to/linked-worktree        abcd1234 [master]
/path/to/other-linked-worktree  1234abc  (detached HEAD)
@end example


このコマンドは、状態に応じて、各 worktree の注釈(annotations)も表示します。これらの注釈は以下のとおりです:

@itemize 

@item
@samp{locked} : worktree がロックされている場合。

@item
@samp{prunable} : worktree が @samp{git worktree prune} を介して刈り込みできる場合。
@end itemize

@example
$ git worktree list
/path/to/linked-worktree    abcd1234 [master]
/path/to/locked-worktree    acbd5678 (brancha) locked
/path/to/prunable-worktree  5678abc  (detached HEAD) prunable
@end example


これらの注釈(annotations)については、理由(reason)も利用できる可能性があり、これは冗長モード(verbose mode)を使用して確認できます。そして、注釈はインデントされた次の行に移動され、その後に追加情報が続きます。

@example
$ git worktree list --verbose
/path/to/linked-worktree              abcd1234 [master]
/path/to/locked-worktree-no-reason    abcd5678 (detached HEAD) locked
/path/to/locked-worktree-with-reason  1234abcd (brancha)
        locked: worktree path is mounted on a portable device
/path/to/prunable-worktree            5678abc1 (detached HEAD)
        prunable: gitdir file points to non-existent location
@end example


注意: 追加情報が利用可能な場合、注釈は次の行に移動されることに注意してください。そうでない場合、注釈は worktree 自体と同じ行にとどまります。

@noindent

@heading Porcelain Format

磁器コマンドのフォーマットは、属性ごとに1行あります。 @samp{-z} が指定された場合、 行は改行(newline)ではなく NUL で終了します。 属性は、 単一のスペースで区切られたラベルと値でリストされます。 ブール属性(@samp{bare} や @samp{detached} など)はラベルとしてのみリストされ、 値がtrueの場合にのみ存在します。 一部の属性(@samp{locked} など)は、 ラベルとしてのみリストすることも、 理由が利用可能かどうかに応じて値とともにリストすることもできます。 worktree の最初の属性は常に @samp{worktree} であり、空行はレコードの終わりを示します。 例えば:

@example
$ git worktree list --porcelain
worktree /path/to/bare-source
bare

worktree /path/to/linked-worktree
HEAD abcd1234abcd1234abcd1234abcd1234abcd1234
branch refs/heads/master

worktree /path/to/other-linked-worktree
HEAD 1234abc1234abc1234abc1234abc1234abc1234a
detached

worktree /path/to/linked-worktree-locked-no-reason
HEAD 5678abc5678abc5678abc5678abc5678abc5678c
branch refs/heads/locked-no-reason
locked

worktree /path/to/linked-worktree-locked-with-reason
HEAD 3456def3456def3456def3456def3456def3456b
branch refs/heads/locked-with-reason
locked reason why is locked

worktree /path/to/linked-worktree-prunable
HEAD 1233def1234def1234def1234def1234def1234b
detached
prunable gitdir file points to non-existent location
@end example


@samp{-z} が使用されない限り、ロック理由での改行などの「異常な」文字はエスケープされ、 設定変数 @samp{core.quotePath} で説明されているように理由全体がクォートされます(git-config(1) 参照)。 例えば:

@example
$ git worktree list --porcelain
...
locked "reason\nwhy is locked"
...
@end example


@noindent

@chapheading EXAMPLES

リファクタリングセッションの真っ最中に、 上司がやって来て、 あなたに、 すぐに何かを修正するように要求します。 通常、 git-stash(1) を使用して変更を一時的に保存しますが、 作業ツリー(working tree)は、(新しいファイル、移動されたファイル、削除されたファイル、その他の断片が散らばっていて)混乱状態にあります。 あなたはそれのいずれかを邪魔する危険を冒したくありません。 あなたは代わりに、一時的にリンクされた worktree を作成して緊急修正を行い、 完了したらそれを削除してから、以前のリファクタリングセッションを再開することにします。

@example
$ git worktree add -b emergency-fix ../temp master
$ pushd ../temp
# ... hack hack hack ...
$ git commit -a -m 'emergency fix for boss'
$ popd
$ git worktree remove ../temp
@end example


@noindent

@chapheading BUGS

一般的な複数チェックアウト(multiple checkout)はまだ実験段階であり、サブモジュールのサポートは不完全です。スーパープロジェクトを複数チェックアウトすることはお勧めしません。

@noindent

@chapheading GIT

Part of the git(1) suite

@node git-write-tree,,,Top
@chapheading Name

git-write-tree — 現在のインデックスからツリーオブジェクトを作成します

@noindent

@chapheading Synopsis

@display
git write-tree [--missing-ok] [--prefix=<prefix>/]
@end display


@noindent

@chapheading DESCRIPTION

現在のインデックスを使用してツリーオブジェクトを作成します。新しいツリーオブジェクトの名前が標準出力に出力されます。

インデックスは完全にマージされた状態である必要があります。

概念的には、 @emph{git write-tree} は、現在のインデックスの内容をツリーファイルのセットに sync() します。現在ディレクトリに実際にあるものと一致させるには、 @emph{git write-tree} を実行する前に @emph{git update-index} フェイズを実行する必要があります。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{--missing-ok} 
通常、 @emph{git write-tree} は、ディレクトリによって参照されるオブジェクトがオブジェクトデータベースに存在することを保証します。このオプションは、このチェックを無効にします。

@item  @samp{--prefix=<prefix>/} 
サブディレクトリ @samp{<prefix>} を表すツリーオブジェクトを書き込みます。これは、指定されたサブディレクトリにあるサブプロジェクトのツリーオブジェクトを書き込むために使用できます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node git,,,Top
@chapheading Name

git — くだらないコンテンツトラッカー

@noindent

@chapheading Synopsis

@display
git [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]
    [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]
    [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
    [--config-env=<name>=<envvar>] <command> [<args>]
@end display


@noindent

@chapheading DESCRIPTION

Gitは、高速でスケーラブルな分散型リビジョン管理システムであり、高レベルの操作と内部へのフルアクセスの両方を提供する非常に豊富なコマンドセットを備えています。

始めは gittutorial(7) を参照してください。次に、便利な最小限のコマンドセットについては giteveryday(7) を参照してください。 @uref{user-manual.html,Git User’s Manual} には、より詳細な紹介があります。

あなたが基本的な概念をマスターしたら、このページに戻ってGitが提供するコマンドを学ぶことができます。「git help command」を使用して、個々のGitコマンドについて詳しく知ることができます。 gitcli(7) のマニュアルページには、コマンドラインコマンド構文の概要が記載されています。

最新のGitドキュメントの、フォーマットされ、ハイパーリンクされたコピーは、 @uref{https://git.github.io/htmldocs/git.html,https://git.github.io/htmldocs/git.html} または @uref{https://git-scm.com/docs,https://git-scm.com/docs} で表示できます。

@noindent

@chapheading OPTIONS

@table @asis

@item  @samp{-v} 
@itemx  @samp{--version} 
@samp{git} プログラムの元となったGitスイートのバージョンを出力します。

このオプションは内部で @samp{git version ...} に変換されるので、 git-version(1) コマンドと同じオプションを受け入れます。 @samp{--help} も指定されている場合は @samp{--version} よりも優先されます。

@item  @samp{-h} 
@itemx  @samp{--help} 
概要と、最も一般的に使用されるコマンドのリストを出力します。 オプション @samp{--all} または @samp{-a} を指定すると、使用可能なすべてのコマンドが出力されます。Gitコマンドが明示された場合、このオプションはそのコマンドのマニュアルページを表示します。

マニュアルページの表示方法を制御するために、他のオプションを使用できます。@samp{git --help ...} は内部で @samp{git help ...} に変換されるため、詳細については git-help(1) を参照してください。

@item  @samp{-C <path>} 
現在の作業ディレクトリではなく、 @samp{<path>} でgitが開始されたかのように実行します。 複数の @samp{-C} オプションが指定されている場合、後続の「非絶対(non-absolute) @samp{-C <path>} 」は、それぞれ先行する @samp{-C <path>} に関連して解釈されます。 @samp{<path>} は存在するが空の場合(例: @samp{-C" "})の場合、 現在の作業ディレクトリは変更されません。

このオプションは、パス名の解釈が @samp{-C} オプションによって引き起こされる作業ディレクトリに対して行われるという点で、 @samp{--git-dir} や @samp{--work-tree} のようなパス名を期待するオプションに影響します。たとえば、以下の2つの呼び出しは同等です:

@example
git --git-dir=a.git --work-tree=b -C c status
git --git-dir=c/a.git --work-tree=c/b status
@end example

@item  @samp{-c <name>=<value>} 
構成パラメーターをコマンドに渡します。指定された値は、構成ファイルの値を上書きします。 <name>は、「git config」(ドットで区切られたサブキー)でリストされているものと同じ形式である必要があります。

@samp{git -c foo.bar ...} で @samp{=} を省略することは許可されており、その場合 @samp{foo.bar} を(設定ファイルの @samp{[foo]bar} と同様に)ブール値のtrueに設定することに注意してください。等号と空の値(@samp{git -c foo.bar= ...} など)を含むと、 @samp{foo.bar} が空の文字列に設定されます。 @samp{git config --type=bool} ではこれを @samp{false} に変換します。

@item  @samp{--config-env=<name>=<envvar>} 
@samp{-c <name>=<value>} と同様に、構成変数 @samp{<name>} に値を指定します。ここで、 <envvar> は、値を取得する環境変数の名前です。 @samp{-c} とは異なり、値を空の文字列に直接設定するためのショートカットはありません。代わりに、環境変数自体を空の文字列に設定する必要があります。 @samp{<envvar>} が環境に存在しない場合はエラーになります。 @samp{<envvar>} には等号を含めることはできません。これは、 @samp{<name>} に等号が含まれている場合のあいまいさを避けるためです。

これは、あなたが一時的な構成オプションをgitに渡したいが、他のプロセスで、あなたのコマンドライン(たとえば @samp{/proc/self/cmdline})は読み取れるが、あなたの環境(たとえば @samp{/proc/self/environ})は読み取れない可能性があるOS上で作業している場合に役立ちます。この動作はLinuxのデフォルトですが、あなたのシステムでは設定されてない場合があります。

注意:これにより、機密情報が値の一部である @samp{http.extraHeader} などの変数のセキュリティが追加される可能性がありますが、機密情報をキーの一部にすることができるモノ、例えば @samp{url.<base>.insteadOf} は使用できません。

@item  @samp{--exec-path[=<path>]} 
あなたのコアGitプログラムがインストールされている場所へのパス。これは、 GIT_EXEC_PATH 環境変数を設定することによっても制御できます。パスが指定されていない場合、「git」は現在の設定を出力して終了します。

@item  @samp{--html-path} 
GitのHTMLドキュメントがインストールされているパスを末尾のスラッシュなしで印刷し、終了します。

@item  @samp{--man-path} 
このバージョンのGitのマニュアルページのmanpath(@samp{man(1)} 参照)を印刷して終了します。

@item  @samp{--info-path} 
このバージョンのGitを文書化したInfoファイルがインストールされているパスを印刷して終了します。

@item  @samp{-p} 
@itemx  @samp{--paginate} 
標準出力が端末の場合は、すべての出力を @samp{less} (または設定されている場合は $PAGER )にパイプします。これにより、 @samp{pager.<cmd>} 構成オプションが上書きされます(以下の「Configuration Mechanism」セクションを参照)。

@item  @samp{-P} 
@itemx  @samp{--no-pager} 
Git出力をページャーにパイプしないでください。

@item  @samp{--git-dir=<path>} 
リポジトリ(".git" ディレクトリ)へのパスを設定します。これは、 @samp{GIT_DIR} 環境変数を設定することによっても制御できます。現在の作業ディレクトリへの絶対パスまたは相対パスにすることができます。

このオプションを使用して @samp{.git} ディレクトリの場所を指定すると、 (リポジトリとトップレベルの作業ツリーを検出できる、) @samp{.git} サブディレクトリを持つディレクトリを検索しようとするリポジトリ検出機能がオフになり、あなたが作業ツリーの最上位にいるとGitに通知します。あなたが作業ツリーの最上位ディレクトリにいない場合は、 @samp{--work-tree=<path>} オプション(または @samp{GIT_WORK_TREE} 環境変数)を使用して、作業ツリーの最上位がどこにあるかをGitに通知する必要があります。

@samp{<path>} で開始されたかのようにgitを実行したい場合は、 @samp{git -C <path>} を使用します。

@item  @samp{--work-tree=<path>} 
作業ツリーへのパスを設定します。絶対パスまたは現在の作業ディレクトリからの相対パスにすることができます。これは、 GIT_WORK_TREE環境変数とcore.worktree構成変数を設定することによっても制御できます(詳細については、 git-config(1) の core.worktree を参照してください)。

@item  @samp{--namespace=<path>} 
Git名前空間を設定します。詳細については linkgit: gitnamespaces[7] を参照してください。 @samp{GIT_NAMESPACE} 環境変数を設定するのと同じです。

@item  @samp{--bare} 
リポジトリをベアリポジトリとして扱います。GIT_DIR環境が設定されていない場合は、現在の作業ディレクトリに設定されます。

@item  @samp{--no-replace-objects} 
Gitオブジェクトを置き換えるための置換refを使用しません。 詳細については git-replace(1) を参照してください。

@item  @samp{--literal-pathspecs} 
パススペックを文字通り扱います(つまり globbing 無し、 pathspec magic 無しです)。 これは、 @samp{GIT_LITERAL_PATHSPECS} 環境変数を @samp{1} に設定するのと同じです。

@item  @samp{--glob-pathspecs} 
すべてのパススペックにグロブマジック(glob magic)を追加します。 これは、 @samp{GIT_GLOB_PATHSPECS} 環境変数を @samp{1} に設定するのと同じです。 個々のパススペックで globbing を無効にするには、パススペックマジック @samp{:(literal)} を使用します。

@item  @samp{--noglob-pathspecs} 
すべてのパススペックにリテラルマジック(literal magic)を追加します。これは、 @samp{GIT_NOGLOB_PATHSPECS} 環境変数を @samp{1} に設定するのと同じです。個々のパススペックでグロブを有効にするには、パススペックマジック @samp{:(glob)} を使用します。

@item  @samp{--icase-pathspecs} 
すべてのパススペックに icase magic を追加します。 これは、 @samp{GIT_ICASE_PATHSPECS} 環境変数を @samp{1} に設定するのと同じです。

@item  @samp{--no-optional-locks} 
ロック(lock)を必要とするオプションの操作は実行しないでください。これは、 @samp{GIT_OPTIONAL_LOCKS} を @samp{0} に設定するのと同じです。

@item  @samp{--list-cmds=group[,group...]} 
コマンドをグループ別に一覧表示します。これは 内部/実験的 なオプションであり、将来変更または削除される可能性があります。サポートされているグループは、builtins、parseopt(parse-optionsを使用するbuiltinコマンド)、main(libexecディレクトリ内のすべてのコマンド)、その他(git-プレフィックスを持つ @samp{$PATH} 内の他のすべてのコマンド)、list-<category> (command-list.txt 内の categories を参照)、nohelpers(ヘルパーコマンドを除く)、alias、config(構成変数 completion.commands から取得したコマンドリスト)、です。

@item  @samp{--attr-source=<tree-ish>} 
Read gitattributes from <tree-ish> instead of the worktree. See gitattributes(5). This is equivalent to setting the @samp{GIT_ATTR_SOURCE} environment variable.
@end table

@noindent

@chapheading GIT COMMANDS

私達はGitを、高レベル(porcelain;磁器)コマンドと低レベル(plumbing;配管)コマンドに分けています。

@noindent

@chapheading High-level commands (porcelain)

磁器コマンドは、メインコマンド群といくつかの補助ユーティリティに分けられます。

@noindent

@heading Main porcelain commands

@table @asis

@item  git-add(1) 
ファイルの内容をインデックスに追加します.

@item  git-am(1) 
メールボックスから一連のパッチを適用します.

@item  git-archive(1) 
名前付きツリーからファイルのアーカイブを作成します.

@item  git-bisect(1) 
二分木検索を使用して、バグを引き起こしたコミットを見つけます.

@item  git-branch(1) 
ブランチを、一覧表示または作成または削除します.

@item  git-bundle(1) 
アーカイブごとにオブジェクトとrefを移動します.

@item  git-checkout(1) 
ブランチの切り替え、または作業ツリーファイルの復元を行います。.

@item  git-cherry-pick(1) 
いくつかの既存のコミットによって導入された変更を適用します.

@item  git-citool(1) 
git-commitのグラフィカルな代替手段.

@item  git-clean(1) 
作業ツリーから追跡されていないファイルを削除する.

@item  git-clone(1) 
リポジトリを新しいディレクトリにクローン(複製)します.

@item  git-commit(1) 
変更をリポジトリへ記録します.

@item  git-describe(1) 
有効なrefに基づいて、オブジェクトに人間が読める形式の名前を付けます.

@item  git-diff(1) 
コミット、コミット、作業ツリーなどの間の変更を表示する.

@item  git-fetch(1) 
別のリポジトリからオブジェクトとrefsをダウンロードします.

@item  git-format-patch(1) 
電子メール送信用のパッチを準備します.

@item  git-gc(1) 
不要なファイルをクリーンアップし、ローカルリポジトリを最適化する.

@item  git-grep(1) 
パターンにマッチする行を出力します.

@item  git-gui(1) 
Gitのための移植性の高いGUI.

@item  git-init(1) 
空のGitリポジトリを作成するか、既存のリポジトリを再初期化します.

@item  git-log(1) 
コミットのログを表示.

@item  git-maintenance(1) 
Gitリポジトリのデータを最適化するためのタスクの実行.

@item  git-merge(1) 
2つまたはそれ以上の開発履歴を結合します.

@item  git-mv(1) 
ファイルまたはディレクトリまたはシンボリックリンクを移動(move)または名前変更(rename)します.

@item  git-notes(1) 
オブジェクトノートを追加または検査します.

@item  git-pull(1) 
別のリポジトリまたはローカルブランチから取得して統合する.

@item  git-push(1) 
関連するオブジェクトとともにリモートrefを更新します.

@item  git-range-diff(1) 
2つのコミット範囲(例: ブランチの2つのバージョン)を比較します.

@item  git-rebase(1) 
別のベース先端の上にコミットを再適用します.

@item  git-reset(1) 
現在のHEADを指定の状態にリセットします.

@item  git-restore(1) 
作業ツリーファイルを復元します.

@item  git-revert(1) 
いくつかの既存のコミットを元に戻します.

@item  git-rm(1) 
作業ツリーとインデックスからファイルを削除します.

@item  git-shortlog(1) 
「git log」の出力を要約します。.

@item  git-show(1) 
さまざまなタイプのオブジェクトを表示.

@item  git-sparse-checkout(1) 
あなたの作業ツリーを追跡ファイルのサブセットのために縮小します.

@item  git-stash(1) 
汚い作業ディレクトリの変更を隠します.

@item  git-status(1) 
作業ツリーの状態を表示します.

@item  git-submodule(1) 
サブモジュールを初期化、更新、または検査します.

@item  git-switch(1) 
ブランチを切り替える.

@item  git-tag(1) 
GPG署名されたタグオブジェクトを作成、一覧表示、削除、検証します.

@item  git-worktree(1) 
複数の作業ツリー(working tree)を管理します.

@item  gitk(1) 
Gitリポジトリブラウザ.

@item  scalar 
大規模 Git リポジトリ管理ツール.
@end table

@noindent

@heading Ancillary Commands(補助コマンド)

操作コマンド:

@table @asis

@item  git-config(1) 
リポジトリオプションまたはグローバルオプションを、取得および設定する.

@item  git-fast-export(1) 
Gitデータエクスポーター.

@item  git-fast-import(1) 
高速Gitデータインポーターのバックエンド.

@item  git-filter-branch(1) 
ブランチを書き換えます.

@item  git-mergetool(1) 
マージ競合解決ツールを実行して、マージ競合を解決します.

@item  git-pack-refs(1) 
効率的なリポジトリアクセスのためにヘッド(heads)とタグ(tags)をパックします.

@item  git-prune(1) 
オブジェクトデータベースで、到達不能なすべてのオブジェクトを剪定(prune)します.

@item  git-reflog(1) 
reflog情報を管理します.

@item  git-remote(1) 
追跡中のリポジトリの組を管理します.

@item  git-repack(1) 
リポジトリ内のアンパックオブジェクトをパックする.

@item  git-replace(1) 
オブジェクトを置き換えるためのrefsの作成、一覧表示、削除.
@end table

問合せコマンド:

@table @asis

@item  git-annotate(1) 
指定ファイルの各行のコミット情報を表示.

@item  git-blame(1) 
ファイルの各行を最後に変更したリビジョンと作者を表示する.

@item  git-bugreport(1) 
ユーザーがバグ報告を提出するための情報を収集する.

@item  git-count-objects(1) 
パックされていない(unpack)オブジェクトの数とそのディスク消費量を計量します.

@item  git-diagnose(1) 
診断情報の zip アーカイブを生成する.

@item  git-difftool(1) 
一般的なdiffツールを使用して変更を表示します.

@item  git-fsck(1) 
データベース内のオブジェクトの接続性(connectivity)と有効性(validity)を検証します.

@item  git-help(1) 
Gitに関するヘルプ情報を表示します.

@item  git-instaweb(1) 
gitwebで作業リポジトリをインスタントにブラウズします.

@item  git-merge-tree(1) 
インデックスまたは作業ツリーにに触れずに(without touching)マージを実行する.

@item  git-rerere(1) 
競合するマージの記録された競合解決決定を再利用する.

@item  git-show-branch(1) 
ブランチとそのコミットを表示します.

@item  git-verify-commit(1) 
コミットのGPG署名を確認します。.

@item  git-verify-tag(1) 
タグのGPG署名を確認する.

@item  git-version(1) 
Gitに関するバージョン情報を表示する.

@item  git-whatchanged(1) 
各コミットでの差分のログを表示.

@item  gitweb(1) 
Git Webインターフェイス(GitリポジトリのためのWebフロントエンド).
@end table

@noindent

@heading Interacting with Others(他者との交流)

これらのコマンドは、電子メールを利用したパッチを介して、他のSCMや人々と対話するためのものです。

@table @asis

@item  git-archimport(1) 
GNU Arch リポジトリをGitにインポートします.

@item  git-cvsexportcommit(1) 
単一のコミットをCVSチェックアウトにエクスポートします.

@item  git-cvsimport(1) 
別の嫌われ者のSCMからあなたのデータを救難救助する.

@item  git-cvsserver(1) 
Git用のCVSサーバーエミュレーター.

@item  git-imap-send(1) 
標準入力からIMAPフォルダへパッチのコレクションを送信します.

@item  git-p4(1) 
Perforceリポジトリからのインポートと、Perforceリポジトリへのsubmit.

@item  git-quiltimport(1) 
quilt(キルト)パッチセットを現在のブランチに適用します.

@item  git-request-pull(1) 
保留中の変更の概要を生成します.

@item  git-send-email(1) 
パッチの集まりを電子メールとして送信します.

@item  git-svn(1) 
SubversionリポジトリとGit間の双方向操作.
@end table

@noindent

@heading Reset, restore and revert

同様の名前の3つのコマンドがあります。それは @samp{git reset} と @samp{git restore} と @samp{git revert} です。

@itemize 

@item
git-revert(1) は、他のコミットによって行われた変更を元に戻す新しいコミットを作成することです。

@item
git-restore(1) は、インデックスまたは別のコミットから作業ツリー内のファイルを復元することです。このコマンドはブランチを更新しません。このコマンドを使用して、別のコミットからインデックス内のファイルを復元することもできます。

@item
git-reset(1) は、ブランチを更新し、ブランチにコミットを追加または削除するために先端ポインタが指し示す先端(tip)を移動させることです。この操作により、コミット履歴が変更されます。

@samp{git restore} と重複しますが、 @samp{git reset} はインデックスを復元するためにも使用できます。
@end itemize

@noindent

@chapheading Low-level commands (plumbing)

Gitには独自の磁器コマンドレイヤーが含まれていますが、代替磁器コマンドの開発をサポートするには、その低レベルのコマンドで十分です。このような磁器コマンドの開発者は git-update-index(1) と git-read-tree(1) を読むことから始めるといいでしょう。

これらの低レベルコマンドへのインターフェイス(入力、出力、オプションのセット、セマンティクス)は、これらのコマンドが主にスクリプトで使用されるため、磁器レベルのコマンドよりもはるかに安定していることを意味します。 一方、磁器コマンドへのインターフェースは、エンドユーザーエクスペリエンスを向上させるために変更される可能性があります。

以下の説明では、低レベルのコマンドを、オブジェクト(リポジトリ、インデックス、作業ツリー内)を操作するコマンドと、オブジェクトに問い合わせて比較するコマンドと、リポジトリ間でオブジェクトと参照を移動するコマンドに、分けています。

@noindent

@heading Manipulation commands(操作コマンド)

@table @asis

@item  git-apply(1) 
パッチをファイルやインデックスに適用します.

@item  git-checkout-index(1) 
インデックスから作業ツリーにファイルをコピー.

@item  git-commit-graph(1) 
Gitコミットグラフファイル(commit-graph file)の書き出しと検証(verify).

@item  git-commit-tree(1) 
新しいコミットオブジェクトを作成します.

@item  git-hash-object(1) 
Compute object ID and optionally create an object from a file.

@item  git-index-pack(1) 
既存のパックされたアーカイブのパックインデックスファイル構築.

@item  git-merge-file(1) 
3方向ファイルマージを実行する.

@item  git-merge-index(1) 
マージが必要なファイルのマージを実行します.

@item  git-mktag(1) 
追加の検証(extra validation)でタグオブジェクトを作成します.

@item  git-mktree(1) 
ls-tree形式のテキストからツリーオブジェクトを構築する.

@item  git-multi-pack-index(1) 
multi-pack-indexを書き出し・検証します.

@item  git-pack-objects(1) 
オブジェクトのパックされたアーカイブを作成する.

@item  git-prune-packed(1) 
すでにパックファイルにある余分なオブジェクトを削除します.

@item  git-read-tree(1) 
ツリー情報をインデックスに読み込みます.

@item  git-symbolic-ref(1) 
シンボリックrefの読み取り、変更、および削除.

@item  git-unpack-objects(1) 
パックされたアーカイブからオブジェクトを取り出します.

@item  git-update-index(1) 
作業ツリーのファイルの内容をインデックスに登録します.

@item  git-update-ref(1) 
refに保存されているオブジェクト名を安全に更新します.

@item  git-write-tree(1) 
現在のインデックスからツリーオブジェクトを作成します.
@end table

@noindent

@heading Interrogation commands(問合せコマンド)

@table @asis

@item  git-cat-file(1) 
リポジトリオブジェクトのコンテンツまたはタイプとサイズの情報を提供します.

@item  git-cherry(1) 
アップストリームにまだ適用されていないコミットを検索する.

@item  git-diff-files(1) 
作業ツリーとインデックス内のファイルを比較します.

@item  git-diff-index(1) 
ツリーを作業ツリーまたはインデックスと比較します.

@item  git-diff-tree(1) 
2つのツリーオブジェクト間で、ブロブの内容とモードを比較します.

@item  git-for-each-ref(1) 
各refに関する情報を出力します.

@item  git-for-each-repo(1) 
リポジトリのリストでGitコマンドを実行します.

@item  git-get-tar-commit-id(1) 
git-archiveを使用して作成されたアーカイブからコミットIDを抽出します.

@item  git-ls-files(1) 
インデックスと作業ツリーのファイルに関する情報を表示する.

@item  git-ls-remote(1) 
リモートリポジトリの参照を一覧表示する.

@item  git-ls-tree(1) 
ツリーオブジェクトの内容を一覧表示します.

@item  git-merge-base(1) 
マージのために可能な限り良い共通の祖先を見つけます.

@item  git-name-rev(1) 
指定のrevのシンボリック名を検索します.

@item  git-pack-redundant(1) 
無駄なパックファイルを探す.

@item  git-rev-list(1) 
コミットオブジェクトを新しい順に一覧表示します.

@item  git-rev-parse(1) 
パラメータを選択してもみもみします。.

@item  git-show-index(1) 
パックされたアーカイブインデックスを表示する.

@item  git-show-ref(1) 
ローカルリポジトリ内の参照を一覧表示します.

@item  git-unpack-file(1) 
ブロブの内容を含む一時(temporary)ファイルを作成します.

@item  git-var(1) 
Git論理変数を表示します.

@item  git-verify-pack(1) 
パックされたGitアーカイブファイルを検証する.
@end table

一般に、問い合わせコマンドは作業ツリー内のファイルには影響しません。

@noindent

@heading Syncing repositories(リポジトリの同期)

@table @asis

@item  git-daemon(1) 
Gitリポジトリ用のほんまにシンプルなサーバー.

@item  git-fetch-pack(1) 
別のリポジトリから不足しているオブジェクトを受け取ります.

@item  git-http-backend(1) 
Git over HTTP のサーバー側実装.

@item  git-send-pack(1) 
Gitプロトコルを介してオブジェクトを別のリポジトリにプッシュする.

@item  git-update-server-info(1) 
ダムサーバー(dumb servers)を支援するために補助情報ファイル(auxiliary info file)を更新する.
@end table

以下は、上記で使用されるヘルパーコマンドです。エンドユーザーは通常、これらを直接使用することはありません。

@table @asis

@item  git-http-fetch(1) 
HTTPでリモートGitリポジトリからダウンロード.

@item  git-http-push(1) 
HTTP/DAV を介してオブジェクトを別のリポジトリにプッシュする.

@item  git-receive-pack(1) 
リポジトリにプッシュされたものを受信します.

@item  git-shell(1) 
GitのみのSSHアクセス用の制限付きログインシェル.

@item  git-upload-archive(1) 
アーカイブを git-archive に送り返す.

@item  git-upload-pack(1) 
パックされたオブジェクトをgit-fetch-packに送り返す.
@end table

@noindent

@heading Internal helper commands(内部ヘルパーコマンド)

これらは、他のコマンドで使用される内部ヘルパーコマンドです。エンドユーザーは通常、これらを直接使用することはありません。

@table @asis

@item  git-check-attr(1) 
gitattributes情報を表示.

@item  git-check-ignore(1) 
gitignoreや除外ファイルのデバッグ.

@item  git-check-mailmap(1) 
連絡先(contacts)の、正式な名前と電子メールアドレスを表示.

@item  git-check-ref-format(1) 
参照名が整形式であることを確認します.

@item  git-column(1) 
データを複数列表示する.

@item  git-credential(1) 
ユーザー資格情報の取得と保存.

@item  git-credential-cache(1) 
パスワードを一時的にメモリに保存するヘルパー.

@item  git-credential-store(1) 
資格情報をディスクに保存するヘルパー.

@item  git-fmt-merge-msg(1) 
git-fmt-merge-msg-マージコミットメッセージを生成します.

@item  git-hook(1) 
gitフックの実行.

@item  git-interpret-trailers(1) 
コミットメッセージの構造化情報を追加またはパースします.

@item  git-mailinfo(1) 
単一の電子メールメッセージからパッチと作成者を抽出します.

@item  git-mailsplit(1) 
簡易 UNIX mbox 分割プログラム.

@item  git-merge-one-file(1) 
git-merge-indexで使用する標準のヘルパープログラム.

@item  git-patch-id(1) 
パッチの一意のIDを計算します.

@item  git-sh-i18n(1) 
シェルスクリプトのためのGit用i18nセットアップコード.

@item  git-sh-setup(1) 
一般的なGitシェルスクリプトのセットアップコード.

@item  git-stripspace(1) 
不要な空白(whitespace)を削除します.
@end table

@noindent

@chapheading Guides(ガイド)

以下のドキュメントページ群は、Gitの概念に関するガイドです。

@table @asis

@item  gitcore-tutorial(7) 
開発者のためのGit coreチュートリアル.

@item  gitcredentials(7) 
Gitにユーザー名とパスワードを提供する.

@item  gitcvs-migration(7) 
CVSユーザー向けGit.

@item  gitdiffcore(7) 
diff出力の微調整.

@item  giteveryday(7) 
Git日常利用に役立つ最小限のコマンドセット.

@item  gitfaq(7) 
Gitの使用に関するよくある質問(FAQ).

@item  gitglossary(7) 
Git用語集.

@item  gitnamespaces(7) 
Git名前空間.

@item  gitremote-helpers(7) 
リモートリポジトリと対話するためのヘルパープログラム群.

@item  gitsubmodules(7) 
あるリポジトリを別のリポジトリ内にマウントする.

@item  gittutorial(7) 
Git入門.

@item  gittutorial-2(7) 
Git入門パート2.

@item  gitworkflows(7) 
Gitで推奨の作業手順の概要.
@end table

@noindent

@chapheading Repository, command and file interfaces

このドキュメントでは、ユーザーが直接操作する必要があるリポジトリとコマンド・インターフェイスについて説明します。 詳細については、 git-help(1) の @samp{--user-formats} を参照してください(訳注: @samp{--user-interfaces} の誤記?)。

@table @asis

@item  gitattributes(5) 
パスごとの属性の定義.

@item  gitcli(7) 
Gitコマンドラインのインターフェイスと規則.

@item  githooks(5) 
Gitで使われるフック.

@item  gitignore(5) 
無視する、意図的に追跡しないファイルを指定します.

@item  gitmailmap(5) 
作者(author)/コミッター(committer) および/または 電子メールアドレス(E-Mail addresses)をマップします.

@item  gitmodules(5) 
サブモジュールプロパティの定義.

@item  gitrepository-layout(5) 
Gitリポジトリの間取り.

@item  gitrevisions(7) 
Gitのリビジョンと範囲を指定する.
@end table

@noindent

@chapheading File formats, protocols and other developer interfaces

このドキュメントでは、ファイル形式や通信プロトコルやの他の git 開発者インターフェイスについて説明します。 git-help(1) の @samp{--developer-interfaces} を参照してください。

@table @asis

@item  gitformat-bundle(5) 
バンドル・ファイル形式.

@item  gitformat-chunk(5) 
チャンク・ベースのファイル形式.

@item  gitformat-commit-graph(5) 
Git commit-graph format.

@item  gitformat-index(5) 
Git インデックス形式.

@item  gitformat-pack(5) 
Gitパック形式.

@item  gitformat-signature(5) 
Git 暗号署名形式.

@item  gitprotocol-capabilities(5) 
プロトコル v0 と v1 の機能.

@item  gitprotocol-common(5) 
各種プロトコルの共通事項.

@item  gitprotocol-http(5) 
Git HTTPベース・プロトコル.

@item  gitprotocol-pack(5) 
パックが通信(over-the-wire)で転送される方法.

@item  gitprotocol-v2(5) 
Git通信プロトコル・バージョン 2.
@end table

@noindent

@chapheading Configuration Mechanism(構成メカニズム)

Gitは、単純なテキスト形式を使用して、リポジトリごとおよびユーザーごとのカスタマイズを保存します。 このような構成ファイルは以下のようになります:

@example
#
# A '#' or ';' character indicates a comment.
#

; core variables
[core]
        ; Don't trust file modes
        filemode = false

; user identity
[user]
        name = "Junio C Hamano"
        email = "gitster@@pobox.com"
@end example


さまざまなコマンドが構成ファイルから読み取られ、それに応じて操作が調整されます。構成メカニズムのリストと詳細については、 git-config(1) を参照してください。

@noindent

@chapheading Identifier Terminology(識別子の用語)

@table @asis

@item  <object> 
任意のタイプのオブジェクトのオブジェクト名を現します。

@item  <blob> 
BLOBオブジェクト名を現します。

@item  <tree> 
ツリーオブジェクト名を示します。

@item  <commit> 
コミットオブジェクト名を示します。

@item  <tree-ish> 
ツリーまたはコミットまたはタグオブジェクト名を示します。 <tree-ish> 引数を取るコマンドは、最終的には <tree> オブジェクトを操作したいので、 <tree> を指す <commit> オブジェクトと <tag> オブジェクトは自動的に逆参照(dereference)されます。(訳注: tree-ish;ツリーっぽいナニかの意)

@item  <commit-ish> 
コミットまたはタグオブジェクト名を示します。 <commit-ish> 引数を取るコマンドは、最終的には <commit> オブジェクトを操作したいので、 <commit> を指す <tag>オブジェクトを自動的に逆参照します。

@item  <type> 
オブジェクトタイプが必要であることを示します。 現在、 @samp{blob} または @samp{tree} または @samp{commit} または @samp{tag} のいずれかです。

@item  <file> 
ファイル名を示します。ほとんどの場合、 @samp{GIT_INDEX_FILE} が記述するツリー構造のルートを基準にしています。
@end table

@noindent

@chapheading Symbolic Identifiers

<object> を受け入れるGitコマンドでは、以下の記号表記も使用できます:

@table @asis

@item  HEAD 
現在のブランチのヘッドを現します。

@item  <tag> 
有効なタグ名(つまり @samp{refs/tags/<tag>} ref)。

@item  <head> 
有効なhead名(つまり @samp{refs/heads/<head>} ref)。
@end table

オブジェクト名のスペルのより完全なリストについては、 gitrevisions(7) の「SPECIFYING REVISIONS」セクションを参照してください。

@noindent

@chapheading File/Directory Structure

gitrepository-layout(5) 文書を参照してください。

各フックの詳細については githooks(5) をご覧下さい。

高レベルのSCMは、 @samp{$GIT_DIR} で追加情報を提供および管理する場合があります。

@noindent

@chapheading Terminology(用語)

gitglossary(7) を参照してください。

@noindent

@chapheading Environment Variables(環境変数)

Various Git commands pay attention to environment variables and change their behavior. The environment variables marked as "Boolean" take their values the same way as Boolean valued configuration variables, e.g. "true", "yes", "on" and positive numbers are taken as "yes".

Here are the variables:

@noindent

@heading The Git Repository

これらの環境変数は、「すべての」コアGitコマンドに適用されます。 Nb: Gitの上位にあるSCMSによって 使用/オーバーライド される可能性があることに注意してください。したがって、外部のフロントエンドを使用する場合は注意が必要です。

@table @asis

@item  @samp{GIT_INDEX_FILE} 
This environment variable specifies an alternate index file. If not specified, the default of @samp{$GIT_DIR/index} is used.

@item  @samp{GIT_INDEX_VERSION} 
This environment variable specifies what index version is used when writing the index file out. It won’t affect existing index files. By default index file version 2 or 3 is used. See git-update-index(1) for more information.

@item  @samp{GIT_OBJECT_DIRECTORY} 
オブジェクトストレージディレクトリがこの環境変数を介して指定されている場合、 sha1 ディレクトリがその下に作成されます。それ以外の場合は、デフォルトの @samp{$GIT_DIR/objects} ディレクトリが使用されます。

@item  @samp{GIT_ALTERNATE_OBJECT_DIRECTORIES} 
Gitオブジェクトは不変であるため、古いオブジェクトを共有の読み取り専用ディレクトリにアーカイブできます。この変数は、Gitオブジェクトの検索に使用できるGitオブジェクトディレクトリの @samp{:} で区切られた(Windowsでは @samp{;} で区切られた)リストを指定します。新しいオブジェクトはこれらのディレクトリに書き込まれません。

@samp{"} (二重引用符;\x22)で始まるエントリは、Cスタイルの引用符で囲まれたパスとして解釈され、先頭と末尾の二重引用符が削除され、バックスラッシュ(@samp{\} @samp{\x5c});のエスケープが尊重されます。たとえば、値 @samp{"path-with-\"-and-:-in-it":vanilla-path} には @samp{path-with-"-and-:-in-it} と @samp{vanilla-path} の2つのパスがあります。

@item  @samp{GIT_DIR} 
@samp{GIT_DIR} 環境変数が設定されている場合、リポジトリのベースにデフォルトの @samp{.git} の代わりに使用するパスを指定します。 @samp{--git-dir} コマンドラインオプションもこの値を設定します。

@item  @samp{GIT_WORK_TREE} 
作業ツリーのルートへのパスを設定します。 これは、 @samp{--work-tree} コマンドラインオプションと core.worktree 構成変数でも制御できます。

@item  @samp{GIT_NAMESPACE} 
Git名前空間(Git namespace)を設定します。詳細については、 gitnamespaces(7) を参照してください。 @samp{--namespace} コマンドラインオプションもこの値を設定します。

@item  @samp{GIT_CEILING_DIRECTORIES} 
これは、コロン(@samp{:})で区切られた絶対パスのリストである必要があります。設定されている場合、これは、リポジトリディレクトリを探すときにGitがchdirを実行してはいけないディレクトリのリストです(読み込みの遅いネットワークディレクトリを除外する場合に便利です)。コマンドラインまたは環境で設定されている現在の作業ディレクトリまたはGIT_DIRは除外されません。通常、Gitはこのリストのエントリを読み取り、現在のディレクトリと比較するために存在する可能性のあるシンボリックリンクを解決する必要があります。ただし、このアクセスが遅い場合でも、リストに空のエントリを追加して、後続のエントリがシンボリックリンクではなく、解決する必要がないことをGitに通知できます。 例: @samp{GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink}

@item  @samp{GIT_DISCOVERY_ACROSS_FILESYSTEM} 
When run in a directory that does not have ".git" repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This Boolean environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like @samp{GIT_CEILING_DIRECTORIES}, this will not affect an explicit repository directory set via @samp{GIT_DIR} or on the command line.

@item  @samp{GIT_COMMON_DIR} 
この変数にパスが設定されている場合、通常は $GIT_DIR にある非ワークツリーファイルが、代わりにこのパスから取得されます。HEADやインデックスなどのワークツリー固有のファイルは $GIT_DIR から取得されます。詳細については、 gitrepository-layout(5) と git-worktree(1) を参照してください。この変数は GIT_INDEX_FILE や GIT_OBJECT_DIRECTORY などの他のパス変数よりも優先順位が低くなります。

@item  @samp{GIT_DEFAULT_HASH} 
If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is ignored when cloning and the setting of the remote repository is always used. The default is "sha1". THIS VARIABLE IS EXPERIMENTAL! See @samp{--object-format} in git-init(1).
@end table

@noindent

@heading Git Commits

@table @asis

@item  @samp{GIT_AUTHOR_NAME} 
コミットまたはタグオブジェクトを作成するとき、またはreflogを書き込むときに、作者IDで使用される、人間が読める名前。 @samp{user.name} と @samp{author.name} の構成設定を上書きします。

@item  @samp{GIT_AUTHOR_EMAIL} 
コミットまたはタグオブジェクトを作成するとき、またはreflogを書き込むときに作者IDで使用される電子メールアドレス。 @samp{user.email} と @samp{author.email} の設定を上書きします。

@item  @samp{GIT_AUTHOR_DATE} 
commitまたはtagオブジェクトを作成するとき、またはreflogを書き込むときに作者IDに使用される日付。有効な形式については、 git-commit(1) を参照してください。

@item  @samp{GIT_COMMITTER_NAME} 
コミットオブジェクトまたはタグオブジェクトを作成するとき、またはreflogを書き込むときに、コミッターIDで使用される、人間が読める形式の名前。 @samp{user.name} と @samp{committer.name} の設定を上書きします。

@item  @samp{GIT_COMMITTER_EMAIL} 
コミットまたはタグオブジェクトを作成するとき、またはreflogを書き込むときに作者IDで使用される電子メールアドレス。 @samp{user.email} と @samp{committer.email} の設定を上書きします。

@item  @samp{GIT_COMMITTER_DATE} 
コミットオブジェクトまたはタグオブジェクトを作成するとき、またはreflogを書き込むときにコミッターIDに使用される日付。有効な形式については、 git-commit(1) を参照してください。

@item  @samp{EMAIL} 
他の関連する環境変数または構成設定が設定されていない場合に、作者とコミッターのIDで使用される電子メールアドレス。
@end table

@noindent

@heading Git Diffs

@table @asis

@item  @samp{GIT_DIFF_OPTS} 
有効な設定は、統一された差分(unified diff)が作成されたときに表示されるコンテキスト行の数を設定するための @samp{--unified=??} または @samp{-u??} だけです。これは、Git diff コマンドラインで渡される @samp{-U} または @samp{--unified} のオプション値よりも優先されます。

@item  @samp{GIT_EXTERNAL_DIFF} 
環境変数 @samp{GIT_EXTERNAL_DIFF} が設定されている場合、それによって指定されたプログラムが呼び出されてdiffが生成され、Gitは組み込みのdiff機構を使用しません。 追加または削除または変更されたパスの場合、 @samp{GIT_EXTERNAL_DIFF} は以下の7つのパラメーターで呼び出されます:

@example
path old-file old-hex old-mode new-file new-hex new-mode
@end example

これは:

@item  <old|new>-file 
are files GIT_EXTERNAL_DIFF can use to read the contents of <old|new>,

@item  <old|new>-hex 
16進40桁のSHA-1ハッシュです。

@item  <old|new>-mode 
8進数で表現されたファイルモードです。

The file parameters can point at the user’s working file (e.g. @samp{new-file} in "git-diff-files"), @samp{/dev/null} (e.g. @samp{old-file} when a new file is added), or a temporary file (e.g. @samp{old-file} in the index). @samp{GIT_EXTERNAL_DIFF} should not worry about unlinking the temporary file — it is removed when @samp{GIT_EXTERNAL_DIFF} exits.

パスがマージされていない場合、 @samp{GIT_EXTERNAL_DIFF} は1つのパラメーター <path> で呼び出されます。

パス @samp{GIT_EXTERNAL_DIFF} が呼び出されるたびに、 @samp{GIT_DIFF_PATH_COUNTER} と @samp{GIT_DIFF_PATH_TOTAL} の2つの環境変数が設定されます。

@item  @samp{GIT_DIFF_PATH_COUNTER} 
パスごとに1ずつインクリメントされる1で始まるカウンター。

@item  @samp{GIT_DIFF_PATH_TOTAL} 
パスの総数。
@end table

@noindent

@heading other

@table @asis

@item  @samp{GIT_MERGE_VERBOSITY} 
再帰的マージ戦略(recursive merge strategy)によって表示される出力の量を制御する数値。 merge.verbosity をオーバーライドします。 git-merge(1) を参照してください

@item  @samp{GIT_PAGER} 
この環境変数は @samp{$PAGER} をオーバーライドします。 空の文字列または値 "cat"に設定されている場合、Gitはページャーを起動しません。 git-config(1) の @samp{core.pager} オプションも参照してください。

@item  @samp{GIT_PROGRESS_DELAY} 
オプションの進行状況インジケーターを表示する前に遅延する秒数を制御する数値。デフォルトは2です。

@item  @samp{GIT_EDITOR} 
この環境変数は、 @samp{$EDITOR} と @samp{$VISUAL} をオーバーライドします。インタラクティブモードでエディタを起動するときに、いくつかのGitコマンドで使用されます。 git-var(1) と git-config(1) の @samp{core.editor} オプションも参照してください。

@item  @samp{GIT_SEQUENCE_EDITOR} 
この環境変数は、インタラクティブリベース(interactive rebase)のtodoリストを編集するときに、構成されたGitエディタをオーバーライドします。 git-rebase(1) と git-config(1) の @samp{sequence.editor} オプションも参照してください。

@item  @samp{GIT_SSH} 
@itemx  @samp{GIT_SSH_COMMAND} 
これらの環境変数のいずれかが設定されている場合、 @samp{git fetch} と @samp{git push} は、リモートシステムに接続する必要があるときに、 @samp{ssh} の代わりに指定されたコマンドを使用します。設定されたコマンドに渡されるコマンドラインパラメータは、 ssh.variant によって決定されます。詳細については、 git-config(1) の @samp{ssh.variant} オプションを参照してください。

@samp{$GIT_SSH_COMMAND} は @samp{$GIT_SSH} よりも優先され、シェルによって解釈されます。これにより、追加の引数を含めることができます。 一方、 @samp{$GIT_SSH} は、プログラムへのパスである必要があります(追加の引数が必要な場合は、ラッパーシェルスクリプトにすることができます)。

通常、個人の @samp{.ssh/config} ファイルを使用して必要なオプションを設定する方が簡単です。詳細については、あなたのお手元のsshのドキュメントを参照してください。

@item  @samp{GIT_SSH_VARIANT} 
この環境変数が設定されている場合、 @samp{GIT_SSH} ・ ` GIT_SSH_COMMAND` ・ @samp{core.sshCommand} が OpenSSH・plink・tortoiseplinkのいずれを参照しているかにかかわらず、Gitの自動検出をオーバーライドします。この変数は、同じ目的を果たす構成設定 @samp{ssh.variant} をオーバーライドします。

@item  @samp{GIT_SSL_NO_VERIFY} 
Setting and exporting this environment variable to any value tells Git not to verify the SSL certificate when fetching or pushing over HTTPS.

@item  @samp{GIT_ATTR_SOURCE} 
Sets the treeish that gitattributes will be read from.

@item  @samp{GIT_ASKPASS} 
この環境変数が設定されている場合、パスワードまたはパスフレーズを取得する必要があるGitコマンド(HTTPまたはIMAP認証など)は、コマンドライン引数として適切なプロンプトを使用してこのプログラムを呼び出し、そのプログラムの標準出力からパスワードを読み取ります。 git-config(1)の @samp{core.askPass} オプションも参照してください。

@item  @samp{GIT_TERMINAL_PROMPT} 
If this Boolean environment variable is set to false, git will not prompt on the terminal (e.g., when asking for HTTP authentication).

@item  @samp{GIT_CONFIG_GLOBAL} 
@itemx  @samp{GIT_CONFIG_SYSTEM} 
グローバルまたはシステムレベルの構成ファイルからではなく、指定されたファイルから構成を取得します。 @samp{GIT_CONFIG_SYSTEM} が設定されている場合、ビルド時に定義されたシステム構成ファイル(通常は @samp{/etc/gitconfig})は読み取られません。同様に、 @samp{GIT_CONFIG_GLOBAL} が設定されている場合、 @samp{$HOME/.gitconfig} も @samp{$XDG_CONFIG_HOME/git/config} も読み取られません。 @samp{/dev/null} に設定すると、それぞれのレベルの構成ファイルの読み取りをスキップできます。

@item  @samp{GIT_CONFIG_NOSYSTEM} 
Whether to skip reading settings from the system-wide @samp{$(prefix)/etc/gitconfig} file. This Boolean environment variable can be used along with @samp{$HOME} and @samp{$XDG_CONFIG_HOME} to create a predictable environment for a picky script, or you can set it to true to temporarily avoid using a buggy @samp{/etc/gitconfig} file while waiting for someone with sufficient permissions to fix it.

@item  @samp{GIT_FLUSH} 
この環境変数が @samp{1} に設定されている場合、
@samp{git blame} (インクリメンタルモード)、 @samp{git rev-list} 、 @samp{git log} 、
@samp{git check-attr} 、 @samp{git check-ignore} などのコマンドは、
各レコードがフラッシュされた後に出力ストリームを強制的にフラッシュします。
この変数が @samp{0} に設定されている場合、
これらのコマンドの出力は、完全にバッファリングされた入出力を使用して実行されます。
この環境変数が設定されていない場合、
Gitは、標準出力がファイルにリダイレクトされているように見えるかどうかに基づいて、
バッファリングするか、またはレコード指向のフラッシュを選択します。

@item  @samp{GIT_TRACE} 
一般的なトレースメッセージを有効にします。例えば、エイリアス拡張や、組み込みコマンド実行や、外部コマンド実行 においてです。

この変数が @samp{1} または @samp{2} または @samp{true} に設定されている場合(比較では英大文字小文字は区別されません)、トレースメッセージがstderrに出力されます。

変数が2より大きく10より小さい整数値(訳注:つまり 2 < 変数 < 10)に設定されている場合、(厳密には、)Gitはこの値を、開いているファイルデスクリプターとして解釈し、トレースメッセージをこのファイルデスクリプターに書き込もうとします。

または、 変数が絶対パス(@samp{/} 文字で始まる)に設定されている場合、 Gitはこれをファイル・パスとして解釈し、 トレース・メッセージをそのファイルに追加しようとします。

変数の設定を解除(unset)するか、空(empty) または @samp{0} または @samp{false} (英大文字小文字を区別しない)に設定すると、トレースメッセージが無効になります。

@item  @samp{GIT_TRACE_FSMONITOR} 
ファイルシステムモニター拡張機能(filesystem monitor extension)のトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_PACK_ACCESS} 
任意のパックへのすべてのアクセスに対してトレースメッセージを有効にします。アクセスごとに、パックファイル名とパック内のオフセットが記録されます。これは、パック関連のパフォーマンスの問題のトラブルシューティングに役立つ場合があります。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_PACKET} 
特定のプログラムに出入りするすべてのパケットのトレースメッセージを有効にします。これは、オブジェクトネゴシエーションまたはその他のプロトコルの問題のデバッグに役立ちます。 "PACK" で始まるパケットではトレースがオフになります(ただし、以下の @samp{GIT_TRACE_PACKFILE} を参照してください)。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_PACKFILE} 
特定のプログラムによって送受信されたパックファイルのトレースを有効にします。他のトレース出力とは異なり、このトレースは垂れ流しです。ヘッダーやバイナリデータの引用はありません。あなたはこれを、ファイルを端末に表示したり、他のトレース出力と混合したりするのではなく、ほぼ確実に、ファイル(たとえば、 @samp{GIT_TRACE_PACKFILE=/tmp/my.pack} )に転送する必要があります。

注意: これは現在、クローンとフェッチのクライアント側にのみ実装されていることに注意してください。

@item  @samp{GIT_TRACE_PERFORMANCE} 
パフォーマンス関連のトレースメッセージを有効にします。例えば、各Gitコマンドの合計実行時間です。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_REFS} 
refデータベースでの操作のトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_SETUP} 
Gitがセットアップフェーズを完了した後、@samp{.git} と作業ツリーと現在の作業ディレクトリを出力するトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_SHALLOW} 
浅い(shallow)リポジトリの フェッチ/クローン のデバッグに役立つトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_CURL} 
gitトランスポートプロトコルのすべての着信および発信データ(descriptive information;説明情報を含む)のcurlフルトレースダンプを有効にします。これは、コマンドラインで curl @samp{--trace-ascii} を実行するのと似ています。使用可能なトレース出力オプションについては、 @samp{GIT_TRACE} を参照してください。

@item  @samp{GIT_TRACE_CURL_NO_DATA} 
curlトレースが有効になっている場合(上記の @samp{GIT_TRACE_CURL} を参照)、データをダンプしないでください(つまり、情報行とヘッダー(info lines and headers)のみをダンプします)。

@item  @samp{GIT_TRACE2} 
「trace2」ライブラリからのより詳細なトレースメッセージを有効にします。 @samp{GIT_TRACE2} からの出力は、人間が読みやすいように単純なテキストベースの形式です。

この変数が @samp{1} または @samp{2} または @samp{true} に設定されている場合(比較では英大文字小文字は区別されません)、トレースメッセージがstderrに出力されます。

変数が2より大きく10より小さい整数値(訳注:つまり 2 < 変数 < 10)に設定されている場合、(厳密には、)Gitはこの値を、開いているファイルデスクリプターとして解釈し、トレースメッセージをこのファイルデスクリプターに書き込もうとします。

あるいは、変数が絶対パス(`/`文字で始まる)に設定されている場合、Gitはこれをファイルパスとして解釈し、トレースメッセージをそのファイルに追加しようとします。パスがすでに存在し、ディレクトリである場合、トレースメッセージは、SIDの最後のコンポーネントと(ファイル名の衝突を回避するための)オプションのカウンタに従って名前が付けられた、そのディレクトリ内のファイル(プロセスごとに1つ)に書き込まれます。

加えて、変数が @samp{af_unix:[<socket_type>:]<absolute-pathname>} に設定されている場合、GitはパスをUnixドメインソケットとして開こうとします。ソケットタイプは、 @samp{stream} または @samp{dgram} のいずれかです。

変数の設定を解除(unset)するか、空(empty) または @samp{0} または @samp{false} (英大文字小文字を区別しない)に設定すると、トレースメッセージが無効になります。

完全な詳細については @uref{technical/api-trace2.html,Trace2 documentation} を参照してください。

@item  @samp{GIT_TRACE2_EVENT} 
この設定は、ソフトウェア処理(machine interpretation)に適したJSONベースの形式で書き込みます。利用可能なトレース出力オプションについては @samp{GIT_TRACE2} を、詳細については @uref{technical/api-trace2.html,Trace2 documentation} を参照してください。

@item  @samp{GIT_TRACE2_PERF} 
@samp{GIT_TRACE2} で利用可能なテキストベースのメッセージに加えて、この設定はネスト領域(nesting regions)を理解するための列ベース(column-based)のフォーマットを書き込みます。利用可能なトレース出力オプションについては @samp{GIT_TRACE2} を、完全な詳細については @uref{technical/api-trace2.html,Trace2 documentation} を参照してください。

@item  @samp{GIT_TRACE_REDACT} 
By default, when tracing is activated, Git redacts the values of cookies, the "Authorization:" header, the "Proxy-Authorization:" header and packfile URIs. Set this Boolean environment variable to false to prevent this redaction.

@item  @samp{GIT_LITERAL_PATHSPECS} 
Setting this Boolean environment variable to true will cause Git to treat all pathspecs literally, rather than as glob patterns. For example, running @samp{GIT_LITERAL_PATHSPECS=1 git log -- '*.c'} will search for commits that touch the path @samp{*.c}, not any paths that the glob @samp{*.c} matches. You might want this if you are feeding literal paths to Git (e.g., paths previously given to you by @samp{git ls-tree}, @samp{--raw} diff output, etc).

@item  @samp{GIT_GLOB_PATHSPECS} 
Setting this Boolean environment variable to true will cause Git to treat all pathspecs as glob patterns (aka "glob" magic).

@item  @samp{GIT_NOGLOB_PATHSPECS} 
Setting this Boolean environment variable to true will cause Git to treat all pathspecs as literal (aka "literal" magic).

@item  @samp{GIT_ICASE_PATHSPECS} 
Setting this Boolean environment variable to true will cause Git to treat all pathspecs as case-insensitive.

@item  @samp{GIT_REFLOG_ACTION} 
refが更新されると、reflogエントリが作成され、refの新旧の値に加えて、refが更新された理由(通常はrefを更新した高レベルコマンドの名前)を追跡します。スクリプト化された磁器コマンドは、 @samp{git-sh-setup} のset_reflog_actionヘルパー関数を使用して、エンドユーザーがトップレベルコマンドとして呼び出したときにその名前をこの変数に設定して、reflogの本文(body)に記録できます。

@item  @samp{GIT_REF_PARANOIA} 
If this Boolean environment variable is set to false, ignore broken or badly named refs when iterating over lists of refs. Normally Git will try to include any such refs, which may cause some operations to fail. This is usually preferable, as potentially destructive operations (e.g., git-prune(1)) are better off aborting rather than ignoring broken refs (and thus considering the history they point to as not worth saving). The default value is @samp{1} (i.e., be paranoid about detecting and aborting all operations). You should not normally need to set this to @samp{0}, but it may be useful when trying to salvage data from a corrupted repository.

@item  @samp{GIT_ALLOW_PROTOCOL} 
コロン(@samp{:})で区切られたプロトコルのリストが設定されている場合、 @samp{protocol.allow} が @samp{never} に設定され、リストされた各プロトコルでは、 @samp{protocol.<name>.allow} が @samp{always} に設定されているかのように振る舞います(既存の構成をオーバーライドします)。 詳細については、 git-config(1) の @samp{protocol.allow} の説明を参照してください。

@item  @samp{GIT_PROTOCOL_FROM_USER} 
Set this Boolean environment variable to false to prevent protocols used by fetch/push/clone which are configured to the @samp{user} state. This is useful to restrict recursive submodule initialization from an untrusted repository or for programs which feed potentially-untrusted URLS to git commands. See git-config(1) for more details.

@item  @samp{GIT_PROTOCOL} 
内部使用のみ。ワイヤープロトコルのハンドシェイクで使用されます。オプションで値 @samp{key[=value]} を持つ、 コロン(@samp{:})で区切られたリストを含んでいます。不明なキーと値は無視する必要があります。

注意:この変数が一部のトランスポートを通過できるようにサーバーを構成する必要がある場合があることに注意してください。ローカルリポジトリ(つまり、 @samp{file://} またはファイルシステムパス)にアクセスするとき、および @samp{git://} プロトコルを介して自動的に伝播されます。 git-over-http の場合、ほとんどの構成で自動的に機能するはずですが、 git-http-backend(1) の説明を参照してください。 git-over-ssh の場合、クライアントがこの変数を渡すことができるようにsshサーバーを構成する必要がある場合があります(たとえば、OpenSSHで @samp{AcceptEnv GIT_PROTOCOL} を使用することにより)。

この構成はオプションです。変数が伝播されない場合、クライアントは元の "v0" プロトコルにフォールバックします(ただし、パフォーマンスの向上や機能の一部を見逃す可能性があります)。この変数は現在、cloneとfetchにのみ影響します。pushにはまだ使用されていません(ただし、将来的に使用される可能性があります)。

@item  @samp{GIT_OPTIONAL_LOCKS} 
If this Boolean environment variable is set to false, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent @samp{git status} from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to @samp{1}.

@item  @samp{GIT_REDIRECT_STDIN} 
@itemx  @samp{GIT_REDIRECT_STDOUT} 
@itemx  @samp{GIT_REDIRECT_STDERR} 
Windowsのみ: 標準の入力/出力/エラーハンドルを環境変数で指定されたパスにリダイレクトできるようにします。これは、 @samp{CreateProcess()} を介して標準ハンドルを渡す標準的な方法がオプションではないマルチスレッドアプリケーションで特に役立ちます。これは、ハンドルを継承可能としてマークする必要があるためです(したがって、生成された「すべて」のプロセスがそれらを継承し、通常のGit操作をブロックする可能性があります)。主な使用目的は、通信に名前付きパイプを使用することです(例: @samp{\\.\pipe\my-git-stdin-123})。

2つの特別な値がサポートされています。@samp{off} は対応する標準ハンドルを閉じるだけです。そして、 @samp{GIT_REDIRECT_STDERR} が @samp{2>&1} の場合、標準エラーは標準出力と同じハンドルにリダイレクトされます。

@item  @samp{GIT_PRINT_SHA1_ELLIPSIS} (deprecated) 
(非推奨): @samp{yes} に設定されている場合、(省略形の)SHA-1値の後に省略記号を出力します。これは、切り離されたHEAD(detached HEAD)の表示(git-checkout(1))と生のdiff出力(git-diff(1))に影響します。上記の場合に省略記号を印刷することはもはや適切であるとは見なされておらず、そのサポートは(この変数と一緒に)近い将来削除される可能性があります。
@end table

@noindent

@chapheading Discussion

以下の詳細については、 @uref{user-manual.html#git-concepts,Git concepts chapter of the user-manual} および gitcore-tutorial(7) から入手できます。

Gitプロジェクトは通常、最上位に @samp{.git} サブディレクトリがある作業ディレクトリで構成されます。 @samp{.git} ディレクトリには、プロジェクトの完全な履歴を表す圧縮オブジェクトデータベース、その履歴を作業ツリーの現在のコンテンツにリンクする「インデックス」ファイル、タグやブランチヘッドなど、その履歴への名前付きポインタが含まれています。

オブジェクトデータベースには、主に3つのタイプのオブジェクトが含まれています。ファイルデータを保持するブロブ(blob)。ディレクトリ階層を構築するためのブロブやその他のツリーを指すツリー(tree)。そしてコミット(commit)は、それぞれが単一のツリーといくつかの親コミットを参照します。

コミットは、他のシステムが「チェンジセット」または「バージョン」と呼ぶものと同等であり、プロジェクトの履歴のステップを表し、各親は直前のステップを表します。複数の親とのコミットは、それぞれ独立していた開発ラインの統合(マージ;merge)を表します。

すべてのオブジェクトは、その内容のSHA-1ハッシュによって名前が付けられ、通常は40桁の16進数の文字列として記述されます。このような名前はグローバルに一意です。コミットに至るまでの履歴全体は、そのコミットだけに署名することで保証できます。この目的のために、4番目のオブジェクトタイプであるタグ(tag)が提供されます。

最初に作成されたとき、オブジェクトは個々のファイルに保存されますが、効率を上げるために、後で「パックファイル」にまとめて圧縮される場合があります。

ref(refs)と呼ばれる名前付きポインターは、履歴の中で興味深い点を指し示しています。refには、オブジェクトのSHA-1名または別のrefの名前を含めることができます。名前が @samp{ref/head/} で始まるrefには、開発中のブランチの最新のコミット(または「head」)のSHA-1名が含まれます。対象のタグのSHA-1名は、 @samp{ref/tags/} の下に保存されます。 @samp{HEAD} という名前の特別な参照には、現在チェックアウトされているブランチの名前が含まれています。

インデックスファイルは、すべてのパスのリストと、パスごとのブロブオブジェクトと属性のセットで初期化されます。ブロブオブジェクトは、現在のブランチの先端にあるファイルの内容を表します。属性(最終変更時刻、サイズなど)は、作業ツリー内の対応するファイルから取得されます。作業ツリーへのその後の変更は、これらの属性を比較することで見つけることができます。インデックスは新しいコンテンツで更新される可能性があり、新しいコミットはインデックスに保存されているコンテンツから作成される可能性があります。

インデックスは、特定のパス名の複数のエントリ(「ステージ」と呼ばれる)を格納することもできます。これらのステージは、マージの進行中に、マージされていないさまざまなバージョンのファイルを保持するために使用されます。

@noindent

@chapheading FURTHER DOCUMENTATION

Gitの使用を開始するには、「description」セクションのリファレンスを参照してください。 以下は、初めてのユーザーにとっては、おそらく必要以上に詳細です。

@uref{user-manual.html#git-concepts,Git concepts chapter of the user-manual} と gitcore-tutorial(7) はどちらも、基盤となるGitアーキテクチャの概要を示しています。

おすすめの作業手順の概要については gitworkflows(7) を参照してください。

いくつかの便利な実例について @uref{howto-index.html,howto} 文書もご覧下さい。

Git内部については @uref{technical/api-index.html,Git API documentation} に記載されています。

CVSから移行するユーザーには gitcvs-migration(7) も読んで欲しいです。

@noindent

@chapheading Authors

GitはLinus Torvalds(リーナス トーバルズ)によって開始され、現在はJunio C Hamano(濱野 純)によって保守されています。Gitメーリングリスト <@uref{mailto:git@@vger.kernel.org,git@@vger.kernel.org}> から多くの貢献がありました。 @uref{http://www.openhub.net/p/git/contributors/summary,http://www.openhub.net/p/git/contributors/summary} は、貢献者のより完全なリストを提供します。

あなたが git.git 自体のクローンを持っている場合、 git-shortlog(1) と git-blame(1) の出力は、プロジェクトの特定の部分の作者を表示することができます。

@noindent

@chapheading Reporting Bugs

開発とメンテナンスが主に行われるGitメーリングリスト <@uref{mailto:git@@vger.kernel.org,git@@vger.kernel.org}> にバグを報告してください。そこにメッセージを送信するためにリストに登録する必要はありません。以前のバグレポートやその他の議論については、 @uref{https://lore.kernel.org/git,https://lore.kernel.org/git} メーリングリストアーカイブを参照してください。

セキュリティに関連する問題は、Gitセキュリティメーリングリスト <@uref{mailto:git-security@@googlegroups.com,git-security@@googlegroups.com}> に非公開で投稿する必要があります。

@noindent

@chapheading SEE ALSO

gittutorial(7), gittutorial-2(7), giteveryday(7), gitcvs-migration(7), gitglossary(7), gitcore-tutorial(7), gitcli(7), @uref{user-manual.html,The Git User’s Manual}, gitworkflows(7)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitattributes,,,Top
@chapheading Name

gitattributes — パスごとの属性の定義

@noindent

@chapheading Synopsis

$GIT_DIR/info/attributes, .gitattributes

@noindent

@chapheading DESCRIPTION

@samp{gitattributes} ファイルは、パス名に属性(attributes)を与える単純なテキストファイルです。

@samp{gitattributes} ファイルの各行は以下の形式です:

@example
pattern attr1 attr2 ...
@end example

つまり、パターンの後に空白(whitespaces)で区切られた属性リストが続きます。先頭と末尾の空白は無視されます。 @samp{#} で始まる行は無視されます。 二重引用符(@samp{"})で始まるパターンは、Cスタイルでクォートされます。パターンが問題のパスと一致すると、その行にリストされている属性がそのパスに与えられます。

各属性は、特定のパスに対して以下のいずれかの状態になる可能性があります:

@table @asis

@item  set(設定) 
パスには、特別な値 @samp{true} を持つ属性があります。これは、属性リストにその属性の名前のみをリストすることによって指定されます。

@item  unset(設定解除) 
パスには、特別な値 @samp{false} を持つ属性があります。 これは、属性リストにダッシュ @samp{-} で始まる属性の名前をリストすることによって指定されます。

@item  Set to a value(値を設定) 
パスには、指定の文字列値を持つ属性があります。これは、属性の名前の後に等号 @samp{=} とその値を、属性リストにリストすることによって指定されます。

@item  unspecified(未指定) 
パスに一致するパターンはなく、パスに属性があるかどうかはわかりません。パスの属性は未指定(unspecified)であると言われます。
@end table

複数のパターンがパスに一致する場合、後の行が前の行をオーバーライドします。このオーバーライドは属性ごとに行われます。

パターンがパスと一致するルールは、以下のいくつかの例外を除いて、 @samp{.gitignore} ファイル(gitignore(5) 参照)と同じです:

@itemize 

@item
否定パターンは使えません

@item
ディレクトリに一致するパターンは、そのディレクトリ内のパスに再帰的に一致しません(したがって、属性ファイルで末尾のスラッシュの @samp{path/} 構文を使用しても意味がありません。代わりに @samp{path/**} を使用してください)
@end itemize

パスに割り当てる属性を決定するとき、Gitは、(優先順位が最も高い) @samp{$GIT_DIR/info/attributes} ファイルと、問題のパスと同じディレクトリにある @samp{.gitattributes} ファイルと、作業ツリーの最上位までその親ディレクトリを参照します(@samp{.gitattributes} を含むディレクトリが問題のパスから離れるほど、優先順位は低くなります)。最後に、(優先順位が最も低い)グローバルファイルとシステム全体のファイルが考慮されます。

@samp{.gitattributes} ファイルが作業ツリーにない場合、インデックス内のパスがフォールバックとして使用されます。チェックアウト処理では、インデックスの @samp{.gitattributes} が使用され、作業ツリーのファイルがフォールバックとして使用されます。

単一のリポジトリのみに影響を与えたい(つまり、そのリポジトリの1人のユーザーのワークフローに固有のファイルに属性を割り当てる)場合は、属性を @samp{$GIT_DIR/info/attributes} ファイルに配置する必要があります。バージョン管理して他のリポジトリに配布する必要がある属性(つまり、すべてのユーザーが関心を持つ属性)は、 @samp{.gitattributes} ファイルに入れる必要があります(git-config(1) を参照)。 あるユーザーのすべてのリポジトリに影響を与える属性は、 @samp{core.attributesFile} 構成オプションで指定されたファイルに配置する必要があり、そのデフォルト値は $XDG_CONFIG_HOME/git/attributes です。 $XDG_CONFIG_HOME が設定されていないか空の場合、代わりに $HOME/.config/git/attributes が使用されます。システム上のすべてのユーザーの属性は、 @samp{$(prefix)/etc/gitattributes} ファイルに配置する必要があります。

しばしばあなたは、 Unspecified(未指定)状態へのパスの属性の設定をオーバーライドする必要があります。これは、感嘆符 @samp{!} が前に付いた属性の名前をリストすることで行えます。

@noindent

@chapheading EFFECTS

Gitによる特定の操作は、特定の属性をパスに割り当てることによって影響を受ける可能性があります。 現在、以下の操作は属性対応(attributes-aware)です。

@noindent

@heading Checking-out and checking-in

これらの属性は、 @samp{git switch} や @samp{git checkout} や @samp{git merge} などのコマンドが実行されたときに、リポジトリに保存されているコンテンツが作業ツリーファイルにコピーされる方法に影響します。 また、Gitが @samp{git add} や @samp{git commit} する時に準備したコンテンツをリポジトリの作業ツリーに保存する方法にも影響します。

@noindent

@subheading text

This attribute marks the path as a text file, which enables end-of-line conversion: When a matching file is added to the index, the file’s line endings are normalized to LF in the index. Conversely, when the file is copied from the index to the working directory, its line endings may be converted from LF to CRLF depending on the @samp{eol} attribute, the Git config, and the platform (see explanation of @samp{eol} below).

@table @asis

@item  set(設定) 
Setting the @samp{text} attribute on a path enables end-of-line conversion on checkin and checkout as described above. Line endings are normalized to LF in the index every time the file is checked in, even if the file was previously added to Git with CRLF line endings.

@item  unset(設定解除) 
パスの @samp{text} 属性を設定解除(unset)すると、チェックインまたはチェックアウト時に行末変換を試行しないようにGitに指示します。

@item  Set to string value "auto" 
When @samp{text} is set to "auto", Git decides by itself whether the file is text or binary. If it is text and the file was not already in Git with CRLF endings, line endings are converted on checkin and checkout as described above. Otherwise, no conversion is done on checkin or checkout.

@item  unspecified(未指定) 
@samp{text} 属性が指定されていない場合、Gitは @samp{core.autocrlf} 構成変数を使用してファイルを変換する必要があるかどうかを判断します。
@end table

その他の値の場合、Gitは @samp{text} が未指定(unspecified)であるかのように動作します。

@noindent

@subheading eol

This attribute marks a path to use a specific line-ending style in the working tree when it is checked out. It has effect only if @samp{text} or @samp{text=auto} is set (see above), but specifying @samp{eol} automatically sets @samp{text} if @samp{text} was left unspecified.

@table @asis

@item  文字列値 "crlf" を設定 
This setting converts the file’s line endings in the working directory to CRLF when the file is checked out.

@item  文字列値 "lf" を設定 
This setting uses the same line endings in the working directory as in the index when the file is checked out.

@item  unspecified(未指定) 
If the @samp{eol} attribute is unspecified for a file, its line endings in the working directory are determined by the @samp{core.autocrlf} or @samp{core.eol} configuration variable (see the definitions of those options in git-config(1)). If @samp{text} is set but neither of those variables is, the default is @samp{eol=crlf} on Windows and @samp{eol=lf} on all other platforms.
@end table

@noindent

@subheading crlf 属性との下位互換性

下位互換性のために、 @samp{crlf} 属性は以下のように解釈されます:

@example
crlf            text
-crlf           -text
crlf=input      eol=lf
@end example


@noindent

@subheading 行末変換

Gitは通常、ファイルの内容をそのままにしますが、リポジトリ内で行末をLFに正規化し、オプションで、ファイルがチェックアウトされたときにCRLFに変換するように構成できます。

あなたが作業しているリポジトリに関係なく、あなたの作業ディレクトリ内でCRLF行末を設定したいだけの場合は、属性を使用せずに構成変数 @samp{core.autocrlf} を設定できます。

@example
[core]
        autocrlf = true
@end example


これにより、テキストファイルの正規化は強制されませんが、リポジトリに導入するテキストファイルの行末は、追加時にLFに正規化され、リポジトリですでに正規化されているファイルは正規化されたままになります。

貢献者(contributor)がリポジトリに導入するテキストファイルの行末が正規化されていることを確認する場合は、「全て」のファイルに対して @samp{text} 属性を "auto" に設定できます。

@example
*       text=auto
@end example


属性を使用すると、行末の変換方法をきめ細かく制御できます。以下は、Gitが @samp{.txt} と、@samp{.vcproj} と @samp{.sh} ファイルを正規化し、 @samp{.vcproj} ファイルがCRLFを持ち、 @samp{.sh} ファイルが作業ディレクトリでLFを持っていることを確認し、@samp{.jpg} ファイルがその内容に関係なく正規化されないようにする例です。

@example
*               text=auto
*.txt           text
*.vcproj        text eol=crlf
*.sh            text eol=lf
*.jpg           -text
@end example


@quotation

@strong{Note}

中央リポジトリへのプッシュとプルを使用してクロスプラットフォームプロジェクトで @samp{text = auto} 変換が有効になっている場合、CRLFを含むテキストファイルを正規化する必要があります。
@end quotation

クリーンな作業ディレクトリから始めます:

@example
$ echo "* text=auto" >.gitattributes
$ git add --renormalize .
$ git status        # 正規化されるファイルを表示
$ git commit -m "Introduce end-of-line normalization"
@end example


正規化してはならないファイルが @samp{git status} に表示される場合は、 @samp{git add -u} を実行する前に、以下のように @samp{text} 属性の設定を解除してください。

@example
manual.pdf      -text
@end example


逆に、Gitが検出しないテキストファイルは、以下のように正規化を手動で有効にすることができます。

@example
weirdchars.txt  text
@end example


@samp{core.safecrlf} が "true" または "warn" に設定されている場合、Gitは変換が @samp{core.autocrlf} の現在の設定に対して可逆的であるかどうかを確認します。 "true" の場合、Gitは不可逆的な変換を拒否します。 "warn" の場合、Gitは警告を出力するだけで、元に戻せない変換を受け入れます。作業ツリー内のファイルに対してこのような変換が行われるのを防ぐための安全トリガーがありますが、いくつかの例外がありますが、しかし…

@itemize 

@item
@samp{git add} 自体は作業ツリー内のファイルに影響を与えません。その次に行うチェックアウトは影響を与えるため、セーフティーがトリガーされます:

@item
パッチでテキストファイルを更新するための @samp{git apply} は作業ツリー内のファイルに影響を与えますが、操作はテキストファイルに関するものであり、CRLF変換は行末の不整合の修正に関するものであるため、セーフティーはトリガーされません。

@item
@samp{git diff} 自体は作業ツリー内のファイルに影響を与えません。多くの場合、次に @samp{git add} する予定の変更を検査するために実行されます。潜在的な問題を早期に発見するために、セーフティーがトリガーされます。
@end itemize

@noindent

@subheading working-tree-encoding

Gitは、ASCIIまたはそのスーパーセットの1つ(UTF-8、ISO-8859-1など)でエンコードされたファイルをテキストファイルとして認識します。他の特定のエンコーディング(UTF-16など)でエンコードされたファイルはバイナリとして解釈されるため、組み込みのGitテキスト処理ツール(@samp{git diff} など)や、ほとんどのGitWebフロントエンドはデフォルトでこれらのファイルのコンテンツを視覚化しません 。

このような場合、 @samp{working-tree-encoding} 属性を使用して作業ディレクトリ内のファイルのエンコーディングをGitに指示できます。この属性を持つファイルがGitに追加されると、Gitは指定されたエンコーディングからUTF-8にコンテンツを再エンコードします。最後に、GitはUTF-8でエンコードされたコンテンツを内部データ構造(「インデックス」と呼ばれます)に格納します。チェックアウト時に、コンテンツは指定されたエンコーディングに再エンコードされます。

注意: @samp{working-tree-encoding} 属性を使用すると、いくつかの落とし穴があることに注意してください:

@itemize 

@item
(2018年3月現在、)代替のGit実装(JGitやlibgit2など)やGit古いバージョンは、 @samp{working-tree-encoding} 属性をサポートしていません。リポジトリで @samp{working-tree-encoding} 属性を使用する場合は、リポジトリを使用するすべてのクライアントがそれをサポートしていることを確認することを強くお勧めします。

たとえば、Microsoft Visual Studio リソースファイル(@samp{*.rc})またはPowerShellスクリプトファイル(@samp{*.ps1})は、UTF-16でエンコードされる場合があります。 @samp{*.ps1} をUTF-16のファイルとして宣言し、 @samp{working-tree-encoding} が有効なGitクライアントで @samp{foo.ps1} を追加すると、 @samp{foo.ps1} はUTF-8として内部に保存されます。 @samp{working-tree-encoding} をサポートしていないクライアントは、 @samp{foo.ps1} をUTF-8でエンコードされたファイルとしてチェックアウトします。これは通常、このファイルのユーザーに問題を引き起こします。

@samp{working-tree-encoding} 属性をサポートしないGitクライアントが新しいファイル @samp{bar.ps1} を追加した場合、 @samp{bar.ps1`は内部に「現状のまま」(この例ではおそらくUTF-16として)保存されます。そしてそれに対して、 `working-tree-encoding} をサポートするクライアントは、内部コンテンツをUTF-8として解釈し、チェックアウト時にUTF-16に変換しようとします。その操作は失敗し、エラーが発生します。

@item
コンテンツを非UTFエンコーディングに再エンコードすると、変換がUTF-8ラウンドトリップセーフではない可能性があるため、エラーが発生する可能性があります。 エンコーディングがラウンドトリップセーフではないと思われる場合は、それを @samp{core.checkRoundtripEncoding} に追加して、Gitにラウンドトリップエンコーディングをチェックさせます(git-config(1) を参照)。 SHIFT-JIS(日本語文字セット)はUTF-8でラウンドトリップ問題があることが知られており、デフォルトでチェックされています。

@item
コンテンツを再エンコードするには、計算機資源が必要なため、特定のGit操作(@samp{git checkout} や @samp{git add} など)の速度を低下させる可能性があります。
@end itemize

@samp{working-tree-encoding} 属性は、ファイルをUTF-8エンコーディングで保存できない場合や、Gitでコンテンツをテキストとして処理できるようにする場合にのみ使用してください。

例として、 あなたの @samp{*.ps1} ファイルがバイトオーダーマーク(BOM)付きでUTF-16エンコードされており、Gitであなたのプラットフォームに基づいて自動行末変換を実行する場合、以下の属性を使用します。

@example
*.ps1           text working-tree-encoding=UTF-16
@end example


あなたの @samp{* .ps1} ファイルがBOMなしでUTF-16リトルエンディアンでエンコードされており、Gitで作業ディレクトリのWindows行末を使用する場合は、以下の属性を使用します(BOMを使用したUTF-16リトルエンディアンが必要な場合、 @samp{UTF-16LE} の代わりに @samp{UTF-16LE-BOM} を使用します)。あいまいさを避けるために @samp{working-tree-encoding} 属性を使用する場合は、行末を @samp{eol} で明示的に定義することを強くお勧めします。

@example
*.ps1           text working-tree-encoding=UTF-16LE eol=CRLF
@end example


あなたは以下のコマンドを使用して、あなたのプラットフォームで使用可能なすべてのエンコーディングのリストを取得できます:

@example
iconv --list
@end example


ファイルのエンコーディングがわからない場合、あなたは @samp{file} コマンドを使用してエンコーディングを推測できます:

@example
file foo.ps1
@end example


@noindent

@subheading ident

パスに属性 @samp{ident} が設定されている場合、Gitはチェックアウト時にブロブオブジェクト内の @samp{$Id$} を @samp{$Id:} に置き換え、その後に40文字の16進ブロブオブジェクト名が続き、その後にドル記号 @samp{$} が続きます。ワークツリーファイルで @samp{$Id:} で始まり、 @samp{$} で終わるバイトシーケンスは、チェックイン時に @samp{$Id$} に置き換えられます。

@noindent

@subheading filter

filter` 属性には、構成で指定されたフィルタドライバの名前を文字列で指定することができます。

フィルタドライバは、 @samp{clean} コマンドと @samp{smudge} コマンドで構成されており、どちらも指定しないでおくことができます。チェックアウト時に、 @samp{smudge} コマンドが指定されると、コマンドはその標準入力からブロブオブジェクトを供給され、その標準出力はワークツリーファイルを更新するために使用されます。同様に、 @samp{clean} コマンドはチェックイン時にワークツリーファイルの内容を変換するために使用されます。デフォルトでは、これらのコマンドは単一のブロブのみを処理して終了します。長時間実行される @samp{process} フィルターが @samp{clean} および/または @samp{smudge} フィルターの代わりに使用される場合、Gitは単一のGitコマンドの存続期間中、単一のフィルターコマンド呼び出しですべてのブロブを処理できます。例えば @samp{git --all} を追加します。長時間実行される @samp{process} フィルターが構成されている場合、構成された単一のブロブフィルターよりも常に優先されます。 @samp{process} フィルターとの通信に使用されるプロトコルの説明については、以下のセクションを参照してください。

コンテンツフィルタリングの用途の1つは、プラットフォームやファイルシステムやユーザーが使用しやすい形にコンテンツをもみもみ(massage)することです。この操作モードでは、ここでのキーワードは「より便利」であり、「使用できないものを使用可能にする」ではありません。 つまり、誰かがフィルタードライバーの定義を設定解除した場合、または適切なフィルタープログラムを持っていない場合でも、プロジェクトは引き続き使用可能である必要があります。

コンテンツフィルタリングのもう1つの用途は、リポジトリに直接使用できないコンテンツ(Gitの外部に保存されている実際のコンテンツを参照するUUIDや暗号化されたコンテンツなど)を保存し、チェックアウト時に使用可能な形式に変換することです(例: 外部コンテンツをダウンロードする、または暗号化されたコンテンツを復号化する)。

これらの2つのフィルターの振る舞い異なり、デフォルトでは、フィルターは前者と見なされ、コンテンツをより便利な形にもみもみ(massage)します。構成にフィルタードライバー定義がないか、ゼロ以外のステータスで終了するフィルタードライバーはエラーではありませんが、フィルターを無操作パススルーにします。

filter.<driver>.required 構成変数を @samp{true} に設定することにより、フィルター自体が使用できないコンテンツを使用可能なコンテンツに変換することを宣言できます。

注意: clean フィルターを変更するたびに、リポジトリを再正規化する必要があります: $ git add --renormalize

たとえば、 @samp{.gitattributes} で、あなたはパスに @samp{filter} 属性を割り当てるとします。

@example
*.c     filter=indent
@end example


次に、あなたは以下のように @samp{.git/config} で @samp{filter.indent.clean} と @samp{filter.indent.smudge} 構成を定義して、ソースファイルがチェックインされたとき(@samp{clean} が実行されます)と、チェックアウトされたとき(コマンドが @samp{cat} であるため、変更は行われません)、にCプログラムの内容を変更するコマンドのペアを指定します。

@example
[filter "indent"]
        clean = indent
        smudge = cat
@end example


最良の結果を得るには、 @samp{clean} を2回実行しても出力を変更しないでください("clean→clean" は "clean" と同等である必要があります)。また、複数の @samp{smudge} コマンドで @samp{clean} の出力を変更しないでください("smudge→smudge→clean" は "clean” と同等である必要があります)。 以下のmergingセクションを参照してください。

"indent" フィルターは、この点で適切に動作します。すでに正しくインデントされている入力は変更されません。この場合、smudgeフィルターがないということは、cleanフィルターが自身の出力を変更せずに受け入れる必要があることを意味します。

保存されたコンテンツを使用可能にするためにフィルターが成功する必要がある場合は、構成でフィルターが @samp{required} (必須)であることを宣言できます:

@example
[filter "crypt"]
        clean = openssl enc ...
        smudge = openssl enc -d ...
        required
@end example


フィルタコマンドラインのシーケンス @samp{%f} は、フィルタが機能しているファイルの名前に置き換えられます。フィルタはこれをキーワード置換で使用する場合があります。例えば:

@example
[filter "p4"]
        clean = git-p4-filter --clean %f
        smudge = git-p4-filter --smudge %f
@end example


注意: @samp{%f} は、作業中のパスの名前であることに注意してください。フィルタリングされているバージョンによっては、ディスク上の対応するファイルが存在しないか、内容が異なる場合があります。したがって、smudgeおよびcleanコマンドは、ディスク上のファイルにアクセスしようとするのではなく、標準入力で提供されるコンテンツのフィルターとしてのみ機能する必要があります。

@noindent

@subheading Long Running Filter Process

フィルタコマンド(文字列値)が @samp{filter.<driver>.process} を介して定義されている場合、Gitは単一のGitコマンドの存続期間中、単一のフィルタ呼び出しですべてのブロブを処理できます。 これは、長時間実行プロセスプロトコル( technical/long-running-process-protocol.txt にて説明)を使用して実現されます。

Gitは、クリーニング(cleaned)またはスマッジング(smudged)が必要な最初のファイルを検出すると、フィルターを開始してハンドシェイクを実行します。ハンドシェイクでは、Gitによって送信されるウェルカムメッセージは "git-filter-client" であり、プロトコルバージョン2("version=2")のみがサポートされ、サポートされる機能は "clean" と "smudge" と ”delay" です。

その後、Gitはフラッシュパケットで終了する "key=value" ペアのリストを送信します。リストには、少なくとも(サポートされている機能に基づく)フィルターコマンドと、リポジトリルートを基準にしてフィルタリングするファイルのパス名が含まれます。フラッシュパケットの直後に、Gitはコンテンツを0個以上のpkt-lineパケットに分割して送信し、フラッシュパケットを送信してコンテンツを終了します。フィルタは、コンテンツと最終的なフラッシュパケットを受信する前に、応答を送信してはならないことに注意してください。 また、 "key=value" ペアの「value」には「=」文字を含めることができますが、キーには含めることはできません。

@example
packet:          git> command=smudge
packet:          git> pathname=path/testfile.dat
packet:          git> 0000
packet:          git> CONTENT
packet:          git> 0000
@end example


フィルタは、フラッシュパケットで終了する "key=value" ペアのリストで応答することが期待されます。フィルタで問題が発生しない場合は、リストに "success" ステータスが含まれている必要があります。これらのパケットの直後に、フィルターはコンテンツを0個以上のpkt-lineパケットで送信し、最後にフラッシュパケットを送信することが期待されます。最後に、フラッシュパケットで終了する "key=value" ペアの2番目のリストが必要です。フィルタは、2番目のリストのステータスを変更したり、空のリストでステータスをそのまま維持したりできます。空のリストは、フラッシュパケットで終了する必要があることに注意してください。

@example
packet:          git< status=success
packet:          git< 0000
packet:          git< SMUDGED_CONTENT
packet:          git< 0000
packet:          git< 0000  # empty list, keep "status=success" unchanged!
@end example


結果のコンテンツが空の場合、フィルターは "success" ステータスとフラッシュパケットで応答して、空のコンテンツを通知することが期待されます。

@example
packet:          git< status=success
packet:          git< 0000
packet:          git< 0000  # empty content!
packet:          git< 0000  # empty list, keep "status=success" unchanged!
@end example


フィルタがコンテンツを処理できない、または処理したくない場合は、 "error" ステータスで応答することが期待されます。

@example
packet:          git< status=error
packet:          git< 0000
@end example


フィルタの処理中にエラーが発生した場合、コンテンツが(部分的または完全に)送信された後、ステータス "error" を送信できます。

@example
packet:          git< status=success
packet:          git< 0000
packet:          git< HALF_WRITTEN_ERRONEOUS_CONTENT
packet:          git< 0000
packet:          git< status=error
packet:          git< 0000
@end example


フィルタがGitプロセスの存続期間中、コンテンツと将来のコンテンツを処理できない、または処理したくない場合は、プロトコルの任意の時点で "abort" ステータスで応答することが期待されます。

@example
packet:          git< status=abort
packet:          git< 0000
@end example


"error"/"abort" ステータスが設定されている場合、Gitはフィルタープロセスを停止も再開もしません。 ただし、Gitは @samp{filter.<driver>.required`フラグに従って終了コードを設定し、 `filter.<driver>.clean} / @samp{filter.<driver>.smudge} メカニズムの振る舞いを真似っこします。

通信中にフィルターが停止した場合、またはプロトコルに準拠していない場合、Gitはフィルタープロセスを停止し、処理が必要な次のファイルでフィルターを再開します。 @samp{filter.<driver>.required} フラグの設定によっては、Gitはそれをエラーとして解釈します。

@noindent

@subheading Delay

フィルタが "delay" 機能をサポートしている場合、Gitはフィルタコマンドとパス名の後にフラグ "can-delay" を送信できます。このフラグは、コンテンツなしでステータス "delayed" とフラッシュパケットで応答することにより、フィルターが現在のブロブのフィルタリングを遅らせることができることを示します(たとえば、ネットワーク遅延を補正するため)。

@example
packet:          git> command=smudge
packet:          git> pathname=path/testfile.dat
packet:          git> can-delay=1
packet:          git> 0000
packet:          git> CONTENT
packet:          git> 0000
packet:          git< status=delayed
packet:          git< 0000
@end example


フィルタが "delay" 機能をサポートしている場合は、 "list_available_blobs" コマンドをサポートしている必要があります。Gitがこのコマンドを送信すると、フィルターは、以前に遅延されて現在使用可能なブロブを表すパス名のリストを返すことが期待されます。リストはフラッシュパケットで終了する必要があり、その後に "success" ステータスが続き、これもフラッシュパケットで終了します。 遅延パスのブロブがまだ利用できない場合、フィルターは少なくとも1つのブロブが利用可能になるまで応答をブロックすることが期待されます。フィルタは、空のリストを送信することで、遅延ブロブがなくなったことをGitに伝えることができます。フィルタが空のリストで応答するとすぐに、Gitは質問を停止します。この時点でGitが受信していないすべてのブロブは欠落していると見なされ、エラーが発生します。

@example
packet:          git> command=list_available_blobs
packet:          git> 0000
packet:          git< pathname=path/testfile.dat
packet:          git< pathname=path/otherfile.dat
packet:          git< 0000
packet:          git< status=success
packet:          git< 0000
@end example


Gitはパス名を受け取った後、対応するブロブを再度要求します。これらのリクエストには、パス名と空のコンテンツセクションが含まれています。フィルターは、上記で説明した通常の方法で汚れたコンテンツ(smudged content)に応答することが期待されます。

@example
packet:          git> command=smudge
packet:          git> pathname=path/testfile.dat
packet:          git> 0000
packet:          git> 0000  # empty content!
packet:          git< status=success
packet:          git< 0000
packet:          git< SMUDGED_CONTENT
packet:          git< 0000
packet:          git< 0000  # empty list, keep "status=success" unchanged!
@end example


@noindent

@subheading Example

長時間実行されるフィルターのデモの実装は、Gitコアリポジトリにある @samp{contrib/long-running-filter/example.pl} にあります。 独自の長時間実行フィルタープロセスを開発する場合は、 @samp{GIT_TRACE_PACKET} 環境変数がデバッグに非常に役立ちます(git(1) を参照)。

既存の @samp{filter.<driver>.clean} や @samp{filter.<driver>.smudge} コマンドを @samp{filter.<driver>.process} で使用できないことに注意してください。前者は後者とは異なるプロセス間通信プロトコルを使用するからです。

@noindent

@subheading チェックイン/チェックアウト属性間の相互作用

チェックインのコードの流れでは、ワークツリーファイルは最初に(指定され、対応するドライバーが定義されている場合、) @samp{filter} ドライバーで変換され、次に結果が(指定されている場合) `ident`で処理され、最後に(指定されて適用可能な場合) `text`で処理されます。

チェックアウトのコードの流れでは、ブロブコンテンツは最初に @samp{text} で変換され、次に @samp{ident} で変換され、 @samp{filter} に送られます。

@noindent

@subheading チェックイン/チェックアウト属性が異なるブランチをマージする

clean/smudge フィルターや text/eol/ident 属性の追加など、そのファイルの正規リポジトリ形式を変更する属性をファイルに追加した場合、属性が配置されていない場所で何かをマージすると、通常、マージの競合が発生します。

これらの不必要なマージの競合を防ぐために、Gitは、 @samp{merge.renormalize} 構成変数を設定することにより、3方向マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトとチェックインを実行するように指示できます。これにより、チェックイン変換によって引き起こされた変更によって、変換されたファイルが変換されていないファイルとマージされるときに、誤ったマージの競合が発生するのを防ぐことができます。

「smudge→clean」の結果がすでに汚されている(smudged)ファイルでも「clean」と同じ出力になる限り、この戦略はすべてのフィルター関連の競合を自動的に解決します。このように機能しないフィルターは、手動で解決する必要がある追加のマージ競合を引き起こす可能性があります。

@noindent

@heading Generating diff text

@noindent

@subheading diff

属性 @samp{diff} は、Gitが特定のファイルのdiffを生成する方法に影響を与えます。パスのテキストパッチを生成するか、パスをバイナリファイルとして扱うかをGitに指示できます。 また、ハンクヘッダーの @samp{@@@@ -k,l +n,m @@@@} 行に表示される行に影響を与えたり、外部コマンドを使用して差分を生成するようにGitに指示したり、差分を生成する前にバイナリファイルをテキスト形式に変換するようにGitに依頼したりすることもできます。

@table @asis

@item  set(設定) 
@samp{diff} 属性が設定されているパスは、NULなどのテキストファイルには通常表示されないバイト値が含まれている場合でも、テキストとして扱われます。

@item  unset(設定解除) 
@samp{diff} 属性が設定されていないパスは、 @samp{Binary files differ} (バイナリファイル差分) (または、バイナリパッチが有効になっている場合、バイナリパッチ) を生成します。

@item  unspecified(未指定) 
@samp{diff} 属性が指定されていないパスは、最初にその内容が検査され、テキストのように見え、 core.bigFileThreshold よりも小さい場合は、テキストとして扱われます。さもなければ @samp{Binary files differ} (バイナリファイル差分) が生成されます。

@item  String(文字列値) 
指定されたdiffドライバーを使用してdiffが表示されます。以下のセクションで説明するように、各ドライバーは1つ以上のオプションを指定できます。diffドライバー「foo」のオプションは、Git構成ファイルの「diff.foo」セクションの構成変数によって定義されます。
@end table

@noindent

@subheading 外部diffドライバーの定義

diffドライバの定義は @samp{gitattributes} ファイルではなく @samp{gitconfig} で行われるため、厳密に言えば、このマニュアルページはそれについて話すのには間違った場所はありますが…

外部diffドライバー @samp{jcdiff} を定義するには、以下のように @samp{$GIT_DIR/config} ファイル(または @samp{$HOME/.gitconfig} ファイル)にセクションを追加します:

@example
[diff "jcdiff"]
        command = j-c-diff
@end example


Git は @samp{diff} 属性が @samp{jcdiff} に設定されているパスの diff を表示する必要がある場合、上記の設定で指定したコマンド、つまり @samp{j-c-diff} を 7 つのパラメータで、 @samp{GIT_EXTERNAL_DIFF} プログラムが呼ばれるのと同じように呼び出します。 詳しくは git(1) を参照してください。

@noindent

@subheading Setting the internal diff algorithm

The diff algorithm can be set through the @samp{diff.algorithm} config key, but sometimes it may be helpful to set the diff algorithm per path. For example, one may want to use the @samp{minimal} diff algorithm for .json files, and the @samp{histogram} for .c files, and so on without having to pass in the algorithm through the command line each time.

First, in @samp{.gitattributes}, assign the @samp{diff} attribute for paths.

@example
*.json diff=<name>
@end example


Then, define a "diff.<name>.algorithm" configuration to specify the diff algorithm, choosing from @samp{myers}, @samp{patience}, @samp{minimal}, or @samp{histogram}.

@example
[diff "<name>"]
  algorithm = histogram
@end example


This diff algorithm applies to user facing diff output like git-diff(1), git-show(1) and is used for the @samp{--stat} output as well. The merge machinery will not use the diff algorithm set through this method.

@quotation

@strong{Note}

If @samp{diff.<name>.command} is defined for path with the @samp{diff=<name>} attribute, it is executed as an external diff driver (see above), and adding @samp{diff.<name>.algorithm} has no effect, as the algorithm is not passed to the external diff driver.
@end quotation

@noindent

@subheading Defining a custom hunk-header

テキストdiff出力の変更の各グループ(ハンク(hunk)と呼ばれます)には、以下の形式の行が接頭辞として付けられます:

@example
@@@@ -k,l +n,m @@@@ TEXT
@end example

これはハンクヘッダー(hunk header)と呼ばれます。 "TEXT" の部分は、デフォルトでは、アルファベットまたは、アンダースコア(@samp{_})または、ドル記号(@samp{$})で始まる行です。 これは、GNU @samp{diff -p} 出力が使用するものとマッチします。ただし、このデフォルトの選択は一部のコンテンツには適していないため、カスタマイズされたパターンを使用して選択を行うことができます。

最初に、 .gitattributesで、パスに @samp{diff} 属性を割り当てます。

@example
*.tex   diff=tex
@end example


次に、 @samp{diff.tex.xfuncname} 構成を定義して、ハンクヘッダー "TEXT" として表示する行にマッチする正規表現を指定します。以下のように、 @samp{$GIT_DIR/config} ファイル(または @samp{$HOME/.gitconfig} ファイル)にセクションを追加します:

@example
[diff "tex"]
        xfuncname = "^(\\\\(sub)*section\\@{.*)$"
@end example


注意: 単一レベルのバックスラッシュは構成ファイルパーサーによって使用されるため、バックスラッシュを2重にする必要があります。 上記のパターンは、バックスラッシュで始まり、行の終わりまで、 @samp{sub} 、 @samp{section} 、 @samp{@{} の順に0回以上出現する行を選択します。

これを簡単にするための組み込みパターンがいくつかあり、 @samp{tex} はその1つであるため、構成ファイルに上記を書き込む必要はありません(これは、 @samp{.gitattributes} を介して属性メカニズムで有効にする必要があります)。以下の組み込みパターンを使用できます:

@itemize 

@item
@samp{ada} はAda言語のソースコードに適しています。

@item
@samp{bash} はBourne-Againシェル言語(bash)のソースコードに適しています。POSIXシェル関数定義のスーパーセットをカバーしています。

@item
@samp{bibtex} はBibTeXでコード化されたリファレンスを持つファイルに適しています。

@item
@samp{cpp} はC言語とC++言語のソースコードに適しています。

@item
@samp{csharp} はC#言語のソースコードに適しています。

@item
@samp{css} はCSS(cascading style sheets)に適しています。

@item
@samp{dts} は devicetree (DTS) ファイルに適しています。

@item
@samp{elixir} はElixir言語のソースコードに適しています。

@item
@samp{fortran} はFORTRAN言語のソースコードに適しています。

@item
@samp{fountain} はFountain文書に適しています。

@item
@samp{golang} はGo言語のソースコードに適しています。

@item
@samp{html} は HTML/XHTML 文書に適しています。

@item
@samp{java} はJava言語のソースコードに適しています。

@item
@samp{kotlin} はKotlin言語のソースコードに適しています。

@item
@samp{markdown} はMarkdown文書に適しています。

@item
@samp{matlab} はMATLABとOctave言語のソースコードに適しています。

@item
@samp{objc} はObjective-C言語のソースコードに適しています。

@item
@samp{pascal} は Pascal/Delphi 言語のソースコードに適しています。

@item
@samp{perl} はPerl言語のソースコードに適しています。

@item
@samp{php} はPHP言語のソースコードに適しています。

@item
@samp{python} はPython言語のソースコードに適しています。

@item
@samp{ruby} はRuby言語のソースコードに適しています。

@item
@samp{rust} はRust言語のソースコードに適しています。

@item
@samp{scheme} はScheme言語のソースコードに適しています。

@item
@samp{tex} はLaTeX文書のソースコードに適しています。
@end itemize

@noindent

@subheading Customizing word diff

@samp{diff.*.wordRegex} 構成変数で適切な正規表現を指定することにより、 @samp{git diff --word-diff} が単語を1行に分割するために使用するルールをカスタマイズできます。たとえば、TeXでは、バックスラッシュとそれに続く一連の文字がコマンドを形成しますが、そのようなコマンドのいくつかは、空白を介さずに一緒に実行できます。それらを分離するには、以下のように @samp{$GIT_DIR/config} ファイル(または @samp{$HOME/.gitconfig} ファイル)で正規表現を使用します:

@example
[diff "tex"]
        wordRegex = "\\\\[a-zA-Z]+|[@{@}]|\\\\.|[^\\@{@}[:space:]]+"
@end example


前のセクションにリストされているすべての言語には組み込みのパターンが用意されています。

@noindent

@subheading バイナリファイルのテキスト差分の取得

一部のバイナリファイルのテキスト変換バージョンの差分を確認することが望ましい場合があります。たとえば、ワードプロセッサ文書をASCIIテキスト表現に変換し、テキストの差分を表示することができます。この変換によって一部の情報が失われますが、結果のdiffは人間が見るのに役立ちます(ただし、直接適用(apply)することはできません)。

@samp{textconv} configオプションは、そのような変換を実行するためのプログラムを定義するために使用されます。プログラムは、変換するファイルの名前である単一の引数を取り、結果のテキストをstdoutに生成する必要があります。

たとえば、バイナリ情報の代わりにファイルのexif情報の差分を表示するには(exifツールがインストールされていると仮定して)、以下のセクションを @samp{$GIT_DIR/config} ファイル(または `$HOME/.gitconfig ファイル)に追加します:

@example
[diff "jpg"]
        textconv = exif
@end example


@quotation

@strong{Note}

テキスト変換は通常、一方向の変換です。この例では、実際の画像コンテンツを失い、テキストデータのみに焦点を当てています。これは、textconvによって生成されたdiffが適用(apply)に適していないことを意味します。このため、テキスト変換を実行するのは、 @samp{git diff} と @samp{git log} ファミリーのコマンド(つまり、log、whatchanged、show)のみです。 @samp{git format-patch} はこの出力を生成しません。バイナリファイルのテキスト変換された差分を誰かに送信したい場合(たとえば、行った変更をすばやく伝達するため)、それを別個に生成し、送信する通常のバイナリ差分に加えてコメントとして送信する必要があります。
@end quotation

特に @samp{git log -p} を使用して大量のテキスト変換を行う場合、テキスト変換が遅くなる可能性があるため、Gitは出力をキャッシュし、将来の差分で使用するメカニズムを提供します。 キャッシュを有効にするには、diffドライバーの構成で「cachetextconv」変数を設定します。 例えば:

@example
[diff "jpg"]
        textconv = exif
        cachetextconv = true
@end example


これにより、各ブロブで「exif」を実行した結果が無期限にキャッシュされます。diffドライバーのtextconv構成変数を変更すると、Gitはキャッシュエントリを自動的に無効にし、textconvフィルターを再実行します。キャッシュを手動で無効にしたい場合(たとえば、「exif」のバージョンが更新され、より良い出力が生成されようになった等)、 @samp{git update-ref -d refs/notes/textconv/jpg} を使用してキャッシュを手動で削除できます( ここで、「jpg」は上記の例のように、diffドライバーの名前です)。

@noindent

@subheading textconvと外部diffの選択

あなたがリポジトリ内のバイナリまたは特別にフォーマットされたブロブの違いを表示したい場合は、外部のdiffコマンドを使用するか、textconvを使用してそれらを差分可能(diff-able)なテキストフォーマットに変換するかを選択できます。どちらの方法を選択するかは、状況に完全に依存します。

外部diffコマンドを使用する利点は、柔軟性です。行指向の変更を見つける必要はありません。また、出力が統一されたdiff(unified diff)に似ている必要もありません。あなたはあなたのデータ形式に最も適した方法で変更を自由に見つけて報告できます。

それと比較すると、textconvははるかに制限的です。データを行指向のテキスト形式に変換すると、Gitは通常のdiffツールを使用して出力を生成します。この方法を選択することにはいくつかの利点があります:

@enumerate 

@item
容易に使えます。多くの場合、独自の差分を実行するよりも、バイナリからテキストへの変換を作成する方がはるかに簡単です。多くの場合、既存のプログラム(つまり exif や odt2txt)をtextconvフィルターとして使用できます。

@item
Gitのdiff機能。変換ステップのみを自分で実行することで、カラー化、単語diff、マージ用の複合diffなど、Gitのdiff機能の多くを引き続き利用できます。

@item
キャッシュ機能。 textconvキャッシングは、 @samp{git log -p} を実行してトリガーするような、繰り返されるdiffを高速化できます。
@end enumerate

@noindent

@subheading ファイルをバイナリとしてマークする

Gitは通常、コンテンツの先頭を調べることで、ブロブにテキストデータとバイナリデータのどちらが含まれているかを正しく推測します。ただし、ブロブにファイルの後半にバイナリデータが含まれている、またはコンテンツが技術的にはテキスト文字で構成されているものの、人間の読者には不明瞭であるために、あなたは、その推測を上書きしたい場合があります。たとえば、多くのポストスクリプトファイルにはASCII文字しか含まれていません(つまりテキストデータです)が、ノイズが多く意味のないdiffが生成されます。

ファイルをバイナリとしてマークする最も簡単な方法は、 @samp{.gitattributes} ファイルでdiff属性を設定解除(unset)することです。

@example
*.ps -diff
@end example


これにより、Gitは通常の差分ではなく @samp{Binary files differ} (バイナリファイルの差分)(またはバイナリパッチが有効になっている場合はバイナリパッチ)を生成します。

しかしながら、他のdiffドライバー属性を指定することもできます。 たとえば、 @samp{textconv} を使用してポストスクリプトファイルをASCII表現に変換し、人間が表示できるようにしたい場合があるけども、それ以外の場合はバイナリファイルとして扱いたいとします。 @samp{-diff} 属性 と @samp{diff=ps} 属性の両方を指定することはできません。 解決策は、 @samp{diff.*.binary} 構成オプションを使用することです:

@example
[diff "ps"]
  textconv = ps2ascii
  binary = true
@end example


@noindent

@heading Performing a three-way merge

@noindent

@subheading merge

属性 @samp{merge} は、 @samp{git merge} 中にファイルレベルのマージが必要な場合にファイルの3つのバージョンをマージする方法や、 @samp{gitr evert} や @samp{git cherry-pick} などの他のコマンドに、影響します。

@table @asis

@item  set(設定) 
組み込みの３方向マージドライバーは、 @samp{RCS} スイートの @samp{merge} コマンドと同様の方法でコンテンツをマージするために使用されます。これは通常のテキストファイルに適しています。

@item  unset(設定解除) 
現在のブランチのバージョンを暫定的なマージ結果として取得し、マージに競合があることを宣言します。これは、明確に定義されたマージセマンティクスを持たないバイナリファイルに適しています。

@item  unspecified(未指定) 
デフォルトでは、これは @samp{merge} 属性が設定されている場合と同じ組み込みの３方向マージドライバーを使用します。 ただし、 @samp{merge.default} 構成変数は、 @samp{merge} 属性未指定(unspecified)のパスで使用される別のマージドライバーに名前を付けることができます。

@item  String(文字列値) 
3方向マージは、指定のカスタムマージドライバーを使用して実行されます。組み込みの3方向マージドライバーは、「text」ドライバーを要求することで明示的に指定できます。 現在のブランチを取得する組み込みドライバーは、「binary」を要求することで指定できます。
@end table

@noindent

@subheading Built-in merge drivers

@samp{merge} 属性を介して要求できる、いくつかの組み込みの低レベルのマージドライバーが定義されています。

@table @asis

@item  text 
テキストファイルの通常の3方向ファイルレベルのマージ。 競合する領域は、競合マーカー @samp{<<<<<<<} と @samp{=======} と @samp{>>>>>>>} でマークされます。ブランチのバージョンは @samp{=======} マーカーの前に表示され、マージされたブランチのバージョンは @samp{=======} マーカーの後に表示されます。

@item  binary 
ブランチのバージョンを作業ツリーに保持しますが、ユーザーが整理できるようにパスを競合状態のままにします。

@item  union 
テキストファイルに対して3方向のファイルレベルのマージを実行しますが、競合マーカーを残すのではなく、両方のバージョンから行を取得します。これにより、結果のファイルに追加された行がランダムな順序で残る傾向があり、ユーザーは結果を確認すべきです。影響を理解していない場合は、これを使用してはいけません。
@end table

@noindent

@subheading Defining a custom merge driver

マージドライバの定義は、 @samp{gitattributes} ファイルではなく @samp{.git/config} ファイルで行われるため、厳密に言えば、このマニュアルページはそれについて話すのに間違った場所ではありますが…

カスタムマージドライバー @samp{filfre} を定義するには、以下のように @samp{$GIT_DIR/config} ファイル(または @samp{$HOME/.gitconfig} ファイル)にセクションを追加します:

@example
[merge "filfre"]
        name = feel-free merge driver
        driver = filfre %O %A %B %L %P
        recursive = binary
@end example


@samp{merge.*.name} 変数は、ドライバーに人間が読める名前を付けます。

@samp{merge.*.driver} 変数の値は、祖先のバージョン(@samp{%O})と、現在のバージョン(@samp{%A})と、他のブランチのバージョン(@samp{%B})をマージするために実行するコマンドを作成するために使用されます。これらの3つのトークンは、コマンドラインの構築時にこれらのバージョンの内容を保持する一時ファイルの名前に置き換えられます。さらに、 @samp{%L} は競合マーカーのサイズに置き換えられます(以下を参照)。

The merge driver is expected to leave the result of the merge in the file named with @samp{%A} by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts. When the driver crashes (e.g. killed by SEGV), it is expected to exit with non-zero status that are higher than 128, and in such a case, the merge results in a failure (which is different from producing a conflict).

@samp{merge.*.recursive} 変数は、複数の祖先が存在する場合に、共通の祖先間の内部マージのためにマージドライバーが呼び出されるときに使用する他のマージドライバーを指定します。指定しない場合、ドライバー自体が内部マージと最終マージの両方に使用されます。

マージドライバーは、プレースホルダー @samp{%P} を介して、マージされた結果が格納されるパス名を知ります。

@noindent

@subheading conflict-marker-size

この属性は、競合するマージ中に作業ツリーファイルに残る競合マーカーの長さを制御します。値を正の整数に設定するだけで、意味のある効果があります。

たとえば、 ファイル @samp{Documentation/git-merge.txt} の結果をマージすると競合するときに、@samp{.gitattributes} で(通常の7文字の長さではなく)はるかに長い競合マーカーを残すようにマージ機構に指示できます。

@example
Documentation/git-merge.txt     conflict-marker-size=32
@end example


@noindent

@heading Checking whitespace errors

@noindent

@subheading whitespace

@example
`core.whitespace` 設定変数を使用すると、プロジェクト内のすべてのパスに対して `diff` と `apply` が空白エラー(whitespace errors)をどうみなすかを定義します(linkgit:git-config[1] を参照)。この属性では、あなたはパスごとに細かく制御できます。
@end example

@table @asis

@item  set(設定) 
Gitでチェックできる全てのタイプの潜在的な空白エラーを通知します。タブ幅は @samp{core.whitespace} 構成変数の値から取得されます。

@item  unset(設定解除) 
何もエラーとして通知しません。

@item  unspecified(未指定) 
@samp{core.whitespace} 構成変数の値を使用して、エラーとして通知する内容を決定します。

@item  String(文字列値) 
Specify a comma separated list of common whitespace problems to notice in the same format as the @samp{core.whitespace} configuration variable.
@end table

@noindent

@heading Creating an archive

@noindent

@subheading export-ignore

属性 @samp{export-ignore} を持つファイルとディレクトリはアーカイブファイルに追加されません。

@noindent

@subheading export-subst

属性 @samp{export-subst} がファイルに設定されている場合、Gitはこのファイルをアーカイブに追加するときにいくつかのプレースホルダーを展開します。展開は、コミットIDの可用性に依存します。たとえば git-archive(1) にコミットやタグの代わりにツリーが与えられている場合、置換は行われません。プレースホルダーは、 git-log(1) のオプション @samp{--pretty=format:} のプレースホルダーと同じですが、ファイル内で @samp{$Format:PLACEHOLDERS$} のようにラップする必要がある点が異なります。 例えば、 文字列 @samp{$Format:%H$} は、コミットハッシュに置き換えられます。ただし、DoS攻撃(denial-of-service attacks)を回避するために、アーカイブごとに1つの @samp{%(describe)} プレースホルダーのみが展開されます。

@noindent

@heading Packing objects

@noindent

@subheading delta

属性 @samp{delta} がfalseに設定されているパスのブロブに対して、デルタ圧縮は試行されません。

@noindent

@heading Viewing files in GUI tools

@noindent

@subheading encoding

この属性の値は、関連するファイルの内容を表示するためにGUIツール(gitk(1) や git-gui(1) など)で使用される文字エンコードを指定します。注意: パフォーマンス上の考慮事項により、 gitk(1) は、オプションでファイルごとのエンコーディングを手動で有効にしない限り、この属性を使用しないことに注意してください。

この属性が設定されていないか、値が無効な場合は、代わりに @samp{gui.encoding} 構成変数の値が使用されます(git-config(1) を参照)。

@noindent

@chapheading USING MACRO ATTRIBUTES

追跡中のバイナリファイルに、行末変換を適用したり、テキストの差分を作成したりする必要はありません。あなたは、たとえば以下のように指定する必要があります。

@example
*.jpg -text -diff
@end example


しかし、多くの属性がある場合、これはめんどくさいです。マクロ属性を使用すると、あなたは設定時に他の多くの属性を同時に設定または設定解除する属性を定義できます。システムは、組み込みのマクロ属性 @samp{binary} を認識します:

@example
*.jpg binary
@end example


「binary」属性を設定すると、上記のように「text」属性と「diff」属性の設定も解除されます。マクロ属性は「set」のみであることに注意してください。ただし、1つを設定すると、他の属性をsetまたはunsetしたり、他の属性を「Unspecified」状態に戻したりする事があります。

@noindent

@chapheading DEFINING MACRO ATTRIBUTES

カスタムマクロ属性は、最上位のgitattributesファイル(@samp{$GIT_DIR/info/attributes} または、作業ツリーの最上位にある ` .gitattributes` ファイルまたは、グローバルgitattributesファイルまたは、システム全体のgitattributesファイル)でのみ定義でき、作業ツリーサブディレクトリの @samp{.gitattributes} ファイルでは定義できません。 組み込みのマクロ属性「binary」は、以下のものと同等です:

@example
[attr]binary -diff -merge -text
@end example


@noindent

@chapheading NOTES

作業ツリーの @samp{.gitattributes} ファイルにアクセスするとき、Gitはシンボリックリンクをたどりません。 これにより、ファイルシステムからではなく、インデックスまたはツリーからファイルにアクセスする場合の動作の一貫性が保たれます。

@noindent

@chapheading EXAMPLES

これらの以下の3つの @samp{gitattributes} ファイルがある場合:

@example
(in $GIT_DIR/info/attributes)

a*      foo !bar -baz

(in .gitattributes)
abc     foo bar baz

(in t/.gitattributes)
ab*     merge=filfre
abc     -foo -bar
*.c     frotz
@end example


パス @samp{t/abc} に与えられる属性は、以下のように計算されます:

@enumerate 

@item
(問題のパスと同じディレクトリにある) @samp{t/.gitattributes} を調べることにより、Gitは最初の行が一致することを検出します。 @samp{merge} 属性が設定されます。 また、2行目が一致し、属性 @samp{foo} と `bar`が設定解除(unseet)されていることもわかります。

@item
次に (親ディレクトリにある) @samp{.gitattributes} を調べ、最初の行がマッチすることを確認します。しかし、 @samp{t/.gitattributes} ファイルでは、このパスに対して @samp{merge} や @samp{foo} や @samp{bar} 属性をどのように与えるべきかを既に決めているので、@samp{foo} と @samp{bar} は設定解除(unset)のままにしています。属性 @samp{baz} がsetされます。

@item
最後に、 @samp{$GIT_DIR/info/attributes} を調べます。このファイルは、ツリー内の設定を上書きするために使用されます。最初の行がマッチして @samp{foo} がsetされ、 @samp{bar} が指定解除(unset)の状態に戻され、 @samp{baz} が設定解除(unset)されます。
@end enumerate

その結果、 @samp{t/abc} への属性の割り当ては以下のようになります:

@example
foo     set to true
bar     unspecified
baz     set to false
merge   set to string value "filfre"
frotz   unspecified
@end example


@noindent

@chapheading SEE ALSO

git-check-attr(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitcli,,,Top
@chapheading Name

gitcli — Gitコマンドラインのインターフェイスと規則

@noindent

@chapheading Synopsis

gitcli

@noindent

@chapheading DESCRIPTION

このマニュアルでは Git CLI 全体で使用される規則について説明します。

多くのコマンドは、引数としてリビジョン(revisions)(それはほとんどの場合「コミット」(commits)ですが、文脈とコマンドによっては「ツリーっぽい」(tree-ish)場合もあります)と、パス(paths)を取ります。ルールは以下のとおりです:

@itemize 

@item
オプションが最初に来て、次に引数が来ます。 サブコマンドは、 ダッシュで始まるオプション(@samp{--max-parents 2} などの独自の引数を取ることができます)と引数を取ることができます。 最初にダッシュで始まるオプション達を指定し、その後ろ次に引数達を指定する必要があります。 一部のコマンドは、 オプション以外の引数を指定した後でダッシュで始まるオプションを受け入れる場合がありますが、(コマンドがあいまいになる可能性があり、)それに依存すべきではありません(なぜなら、いずれは「オプションの後に引数」というルールを強制して、 これらの曖昧さを修正する事になるかもしれないからです)。

@item
リビジョン達が最初に来て、その次にパス達が来ます。 例えば、 @samp{git diff v1.0 v2.0 arch/x86 include/asm-x86} では @samp{v1.0} と @samp{v2.0} はリビジョン達であり、 @samp{arch/x86} と @samp{include/asm-x86} はパス達です。

@item
引数がリビジョンまたはパスのいずれかと誤解される可能性がある場合は、それらの間に @samp{--} を配置することで曖昧さを解消できます。例えば、 @samp{git diff -- HEAD} は、「作業ツリーにHEADというファイルがあります。インデックスにステージングしたバージョンと、そのファイルの作業ツリーにあるバージョンとの変更を表示してください」であり、「HEADコミットとワークツリー全体の違いを表示する」ではありません。後者を求めるには @samp{git diff HEAD --} とします。

@item
@samp{--} を明示しなくても、Gitは合理的な推測を行いますが、あいまいな場合はエラーが発生し、あなたに明確にするように求めます。例えば、作業ツリーにHEADというファイルがある場合、 @samp{git diff HEAD} はあいまいであり、曖昧さを解消するには、 @samp{git diff HEAD --} または @samp{git diff -- HEAD} のいずれかを指定する必要があります。

@item
一部のコマンドでは、 @samp{--} はリビジョンとパスを明確に区別するために使われるため、これら一部のコマンドでオプションとリビジョンを分離するために使用することはできません。これら一部のコマンドではオプションとリビジョンを分離するために @samp{--end-of-options} を使用できます(これら以外のパスのリビジョンを区別しないコマンドでも機能します。その場合、 @samp{--end-of-options} は単に @samp{--} のエイリアスです)。

ランダムなユーザー入力を処理することが期待されるスクリプトを作成するときは、適切な場所に曖昧さ回避の @samp{--} を配置することにより、どの引数がどれであるかを明示することをお勧めします。

@item
多くのコマンドではパスにワイルドカードを使用できますが、シェルによってワイルドカードが取得されないように保護する必要があります。以下の2つの意味は異なります:

@example
$ git restore *.c
$ git restore \*.c
@end example


前者を使用すると、シェルでfileglobを展開でき、作業ツリー内の C言語ソースファイル(dot-C)をインデックス内のバージョンで上書きするように要求されます。後者は @samp{*.c} をGitに渡し、作業ツリーにチェックアウトするパターンに一致するインデックス内のパスを要求しています。@samp{git add hello.c; rm hello.c} を実行後、前者では作業ツリーに @samp{hello.c} は表示されませんが、後者では表示されます。

@item
ファイルシステムの @samp{.} (ピリオド)が現在のディレクトリを参照するのと同じように、Gitでリポジトリ名として @samp{.} を使用すること(a dot-repository)は相対パスであり、あなたの現在のリポジトリを意味します。
@end itemize

Gitのスクリプトを作成するときに従う必要のある「フラグ」(flag)に関するルールは以下のとおりです:

@itemize 

@item
ダッシュで繋がない形式(non-dashed form)のGitコマンドを使用することをお勧めします。つまり、 @samp{git-foo} よりは @samp{git foo} を使用すべきです。

@item
短いオプションは分割して単語に区切ります( @samp{git foo -ab} よりも @samp{git foo -a -b} を優先します。前者は機能しない事があります)。

@item
コマンドラインオプションが引数を取る場合は、串刺し形式(stuck form) を使用します。つまり、短いオプションの場合は @samp{git foo -o Arg} の代わりに @samp{git foo -oArg} を記述し、長いオプションの場合は @samp{git foo --long-opt Arg} の代わりに @samp{git foo --long-opt=Arg} を記述します。オプションのオプション引数をとるオプションは、串刺し形式で記述する必要があります。

@item
コマンドにリビジョンパラメータを指定するときは、そのパラメータが作業ツリー内のファイルの名前と混同されないことを確認してください。例えば、 @samp{git log -1 HEAD} とは記述せず、@samp{git log -1 HEAD --} と記述します。作業ツリーに @samp{HEAD} というファイルがある場合、前者は機能しません。

@item
多くのコマンドでは、長いオプション @samp{--option} を一意であるかぎり短いプレフィックスのみに省略できます(たとえば、名前が @samp{opt} で始まるオプションが他にない場合は、 @samp{--opt} と入力して @samp{--option} フラグを呼び出すことができます)。ただし、スクリプトを作成するときは、省略してはいけません。なぜならGitのより新しいバージョンで、名前が同じプレフィックスを共有する新しいオプションが導入される可能性があるからです。例えば @samp{--optimize} が導入されると、以前は一意であった短いプレフィックス(@samp{--option} , @samp{--opt})を一意では無くしてしまいます。
@end itemize

@noindent

@chapheading ENHANCED OPTION PARSER

Git 1.5.4シリーズ以降、多くのGitコマンド(この文書の執筆時点ではすべてではありませんが)は、拡張オプションパーサーを備えています。

以下は、この拡張オプションパーサーによって提供される機能のリストです。

@noindent

@heading Magic Options

拡張オプションパーサーがアクティブになっているコマンドはすべて、いくつかの魔法のコマンドラインオプション(magic command-line options)を理解します:

@table @asis

@item  @samp{-h} 
コマンドの、かなり整った使用法を提供します。

@example
$ git describe -h
usage: git describe [<options>] <commit-ish>*
   or: git describe [<options>] --dirty

    --contains            find the tag that comes after the commit
    --debug               debug search strategy on stderr
    --all                 use any ref
    --tags                use any tag, even unannotated
    --long                always use long format
    --abbrev[=<n>]        use <n> digits to display SHA-1s
@end example


注意: 一部のサブコマンド(例: @samp{git grep} )は、コマンドラインに @samp{-h} 以外のものがある場合、動作が異なる場合がありますが、コマンドラインに何も含まれていない @samp{git subcmd -h} は、一貫して使用法を提供することを目的としています。

@item  @samp{--help-all} 
一部のGitコマンドは、配管コマンドにのみ使用されるオプションまたは非推奨のオプションを取り、そのようなオプションはデフォルトの使用法から隠されています。 このオプションはオプションの完全なリストを提供します。
@end table

@noindent

@heading 否定オプション

長いオプションは、接頭辞 @samp{--no-} を付けることで無効にできます。 たとえば、 @samp{git branch} にはオプション @samp{--track} があります。これはデフォルトで @samp{on} です。 @samp{--no-track} を使用して、その動作をオーバーライドできます。 @samp{--color} と @samp{--no-color} についても同じことが言えます。

@noindent

@heading 短いオプションのおまとめ

拡張オプションパーサーをサポートするコマンドを使用すると、短いオプションをおまとめできます。これは、たとえば、 @samp{git rm -rf} や @samp{git clean -fdx} を使用できることを意味します。

@noindent

@heading 長いオプションの省略

拡張オプションパーサーをサポートするコマンドは、クソ詳しく長いオプションの一意なプレフィックスを受け入れますが、これは注意して使用してください。 たとえば、 @samp{git commit --amen} は @samp{git commit --amend} と入力したかのように動作しますが、これは、後のバージョンのGitが同じプレフィックスを共有する別のオプションを導入するまでのみ当てはまります。例えば @samp{git commit --amenity} オプションが導入されたら一意で無くなります。

@noindent

@heading Separating argument from the option

コマンドラインで、オプションの必須パラメータを単に区切られた単語として記述することができます。これは、以下のすべての使い方が機能することを意味します:

@example
$ git foo --long-opt=Arg
$ git foo --long-opt Arg
$ git foo -oArg
$ git foo -o Arg
@end example


ただし、これは必須ではないオプションの値を持つスイッチでは許可されていません。その場合は串刺し形式を使用する必要があります:

@example
$ git describe --abbrev HEAD     # correct
$ git describe --abbrev=10 HEAD  # correct
$ git describe --abbrev 10 HEAD  # NOT WHAT YOU MEANT
@end example


@noindent

@chapheading 注意：よく混同されるオプションに関する注記

作業ツリーおよび/またはインデックス内のファイルを処理できる多くのコマンドは、 @samp{--cached} および/または @samp{--index} オプションを使用できます。インデックスは元々キャッシュと呼ばれていたため、これら2つは同義語であると誤解されることがあります。ちゃいます。これらの2つのオプションは非常に異なることを意味します。

@itemize 

@item
@samp{--cached} オプションは、通常は作業ツリー内のファイルで機能するコマンドに、「インデックスのみで」機能するように要求するために使用されます。 たとえば、 @samp{git grep} をコミットせずに使用して、どのコミットから文字列を検索するかを指定すると、通常は作業ツリー内のファイルで機能しますが、 @samp{--cached} オプションを使用するとインデックス内の文字列を検索します。

@item
@samp{--index} オプションは、通常は作業ツリー内のファイルで機能するコマンドに、「インデックスにも」影響を与えるように要求するために使用されます。たとえば、 @samp{git stash apply} は通常、stashエントリに記録された変更を作業ツリーにマージしますが、 @samp{--index} オプションを使用すると、インデックスへの変更もマージします。
@end itemize

@samp{git apply`コマンドは、 `--cached} または @samp{--index} のいずれかを伴って使用できます(同時に使用することはできません。通常、このコマンドは作業ツリー内のファイルにのみ影響しますが、 @samp{--index} を使用すると、ファイルとそのインデックスエントリの両方にパッチが適用され、 @samp{--cached} を使用すると、インデックスエントリのみが変更されます。

詳細については @uref{https://lore.kernel.org/git/7v64clg5u9.fsf@@assigned-by-dhcp.cox.net/,https://lore.kernel.org/git/7v64clg5u9.fsf@@assigned-by-dhcp.cox.net/} と @uref{https://lore.kernel.org/git/7vy7ej9g38.fsf@@gitster.siamese.dyndns.org/,https://lore.kernel.org/git/7vy7ej9g38.fsf@@gitster.siamese.dyndns.org/} も参照してください。

作業ツリー および/または インデックス内のファイルに対しても機能する他のいくつかのコマンドは、 @samp{--staged} および/または @samp{--worktree} を取ることができます。

@itemize 

@item
@samp{--staged} は @samp{--cached} とまったく同じです。これは、作業ツリーではなく、インデックスでのみ機能するようにコマンドに要求するために使用されます。

@item
@samp{--worktree} は反対に、インデックスではなく、作業ツリーのみで作業するようにコマンドに要求します。

@item
2つのオプションを一緒に指定して、インデックスと作業ツリーの両方で作業するようにコマンドに要求することができます。
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitcore-tutorial,,,Top
@chapheading Name

gitcore-tutorial — 開発者のためのGit coreチュートリアル

@noindent

@chapheading Synopsis

git *

@noindent

@chapheading DESCRIPTION

このチュートリアルでは、「コア」(core)Gitコマンドを使用してGitリポジトリを設定および操作する方法について説明します。

あなたがGitをリビジョン管理システムとして使用する必要がある場合は、「A Tutorial Introduction to Git」( linkgit: gittutorial[7] )または @uref{user-manual.html,the Git User Manual} から始めることをお勧めします。

しかしながら、Gitの内部を理解したい場合は、これら低レベルのツールを理解しておくと役に立ちます。

コアGit(core Git)は「配管」(plumbing)と呼ばれることが多く、その上に「磁器」(porcelain)と呼ばれるより美しいユーザーインターフェイスがあります。配管コマンドを直接使用することはあまりありませんが、磁器コマンドが使えない時に配管コマンドでどうするかを知っておくのは良い事です。

このドキュメントが最初に作成されたとき、多くの磁器コマンドはシェルスクリプトでした。説明を簡単にするために、配管がどのように組み合わされて磁器コマンドを形成するかを示す例としていまだそれらを使用しています。ソースツリーには、参照用に contrib/examples/ にこれらのスクリプトの一部が含まれています。これらは最早シェルスクリプトとして実装されなくなりましたが、それでも、配管レイヤーコマンドの機能の説明は引き続き有効です。

@quotation

@strong{Note}

より深い技術的な詳細は、多くの場合 Note 欄になっています。最初の読書ではスキップしてかまいません。
@end quotation

@noindent

@chapheading Creating a Git repository

新しいGitリポジトリの作成はこれ以上ないほど簡単です。すべてのGitリポジトリは空から始まります。必要なのは、作業ツリーとして使用するサブディレクトリを見つけることだけです。まったく新しいプロジェクトの場合は、それは空のものか、あるいは、Gitにインポートする既存の作業ツリーのいずれかです。

私達の最初の例において、既存のファイルを使用せずに、まったく新しいリポジトリを最初から開始します。これを「git-tutorial」と呼ぶことにします。起動するには、そのサブディレクトリを作成し、そのサブディレクトリに入って、 @samp{git init} を使用してGitインフラストラクチャを初期化します:

@example
$ mkdir git-tutorial
$ cd git-tutorial
$ git init
@end example


そうすると、Gitは以下のように答えます

@example
Initialized empty Git repository in .git/
@end example


これは、奇妙なことを何もしていないこと、そして新しいプロジェクト用にローカルの @samp{.git} ディレクトリセットアップを作成したことを示すGit流のやり方です。これで @samp{.git} ディレクトリができ、@emph{ls} でそれを調べることができます。新しい空のプロジェクトの場合、特に、以下の3つのエントリが表示されます:

@itemize 

@item
@samp{ref: refs/heads/master} という内容の @samp{HEAD} というファイル。これはシンボリックリンクに似ており、 @samp{HEAD} ファイルは @samp{refs/heads/master} を指します。

@samp{HEAD} リンクが指すファイルがまだ存在しないという事実について心配する必要はありません。まだあなたは @samp{HEAD} 開発ブランチを開始するコミットを作成していないからです。

@item
プロジェクトのすべてのオブジェクトを含む @samp{objects} というサブディレクトリ。オブジェクトを直接見る理由は何も無いはずですが、これらのオブジェクトがリポジトリ内のすべての実際の「データ」を含むものであることを知りたい場合があります。

@item
オブジェクトへの参照を含む @samp{refs} と呼ばれるサブディレクトリ。
@end itemize

特に、 @samp{refs} サブディレクトリには、それぞれ @samp{heads} と @samp{tags} という名前の2つのサブディレクトリが含まれます。それらは、名前が示すとおりに機能します。つまり、開発のさまざまな「ヘッド」(先頭)(別名「ブランチ」)への参照と、リポジトリ内の特定のバージョンに名前を付けるために作成した「タグ」への参照が含まれます。

注: 特別な @samp{master} ヘッドがデフォルトのブランチであるため、作成された @samp{.git/HEAD} ファイルは、まだ存在していなくてもそれを指します。基本的に、 @samp{HEAD} リンクは常に現在作業しているブランチを指しているはずであり、いつも @samp{master} ブランチでの作業から始まることを期待します。

けれども、これは単なる慣例であり、ブランチには任意の名前を付けることができ、あなたは「master」ブランチを持つ必要はありません。ただし、多くのGitツールは @samp{.git/HEAD} が最初から有効であると想定します。

@quotation

@strong{Note}

「オブジェクト」は、その160ビットのSHA-1ハッシュ、別名「オブジェクト名」によって識別され、オブジェクトへの参照は、常にそのSHA-1名の16進表現の40バイトです。 @samp{refs} サブディレクトリ内のファイルには、これらの16進参照(通常、末尾に @samp{\n} があります)が含まれていると予想されるため、実際にあなたのツリーにデータを入力し始めると、これらの @samp{refs} サブディレクトリにはこれらの参照を含む41バイトのファイルが多数表示されるはずです。
@end quotation

@quotation

@strong{Note}

上級ユーザーは、このチュートリアルを終了した後、 gitrepository-layout(5) を確認することをお勧めします。
@end quotation

これで、あなたの最初のGitリポジトリが作成されました。もちろん、空なのであまり役に立ちません。なので、データの入力を始めましょう。

@noindent

@chapheading Populating a Git repository

我々はシンプルかつ愚直に行きたいと思います、まずは簡単なファイルをいくつか入力して、その感触をつかむことから始めます。

あなたのGitリポジトリに保持したいランダムファイルを作成することから始めます。これがどのように機能するかを理解するために、いくつかの悪い例から始めます:

@example
$ echo "Hello World" >hello
$ echo "Silly example" >example
@end example


これで、あなたの作業ツリー(working tree)(別名「作業ディレクトリ」(working directory))に2つのファイルが作成されましたが、実際にあなたの作業をチェックインするには、以下の2つの手順を実行する必要があります:

@itemize 

@item
@emph{index} ファイル(別名 @emph{cache} ）に作業ツリーの状態に関する情報を入力します。

@item
そのインデックスファイルをオブジェクトとしてコミットします。
@end itemize

最初のステップは至極簡単です。作業ツリーへの変更についてGitに通知する場合は、 @samp{git update-index} プログラムを使用します。このプログラムは通常、更新するファイル名のリストを取得しますが、些細な間違いを避けるために、 @samp{--add} フラグを使用して新しいエントリを追加すること(または `--remove`でエントリを削除すること)を明示的に指定しない限り、インデックスへの新しいエントリの追加(または既存のものを削除)することを拒否します。

したがって、作成した2つのファイルをインデックスに追加するには、以下のようにします

@example
$ git update-index --add hello example
@end example


これで、あなたはGitにこれら2つのファイルを追跡するように指示しました。

実際、上記を行った後にオブジェクトディレクトリを調べると、Gitがオブジェクトデータベースに2つの新しいオブジェクトを追加していることがわかります。上記の手順を正確に実行した場合は、あなたは以下のように実行できます

@example
$ ls .git/objects/??/*
@end example


そうすると以下の２つのファイルが見えます:

@example
.git/objects/55/7db03de997c86a4a028e1ebd3a1ceb225be238
.git/objects/f2/4c74a2e500f5ee1332c86b94199f52b1d1d962
@end example


これは、それぞれ「557db…」および「f24c7…」という名前のオブジェクトに対応します。

必要に応じて、 @samp{git cat-file} を使用してこれらのオブジェクトを確認できますが、オブジェクトのファイル名ではなく、オブジェクト名を使用する必要があります:

@example
$ git cat-file -t 557db03de997c86a4a028e1ebd3a1ceb225be238
@end example


ここで、 @samp{-t} は @emph{git cat-file} に、オブジェクトの「タイプ」が何であるかを通知させます。 Gitは、「blob」(ブロブ)オブジェクト(つまり、通常のファイル)があることを通知し、あなたは以下のコマンドで内容を表示できます。

@example
$ git cat-file blob 557db03
@end example


"Hello World" が出力されます。オブジェクト @samp{557db03} は、ファイル @samp{hello} の内容そのものです。

@quotation

@strong{Note}

そのオブジェクトをファイル @samp{hello} 自体と混同しないでください。オブジェクトは文字通りファイルの特定の「内容」(contents)であり、後でファイル @samp{hello} の内容を変更しても、先ほど見たオブジェクトは変更されません。オブジェクトは不変(immutable)です。
@end quotation

@quotation

@strong{Note}

2番目の例は、ほとんどの場所でオブジェクト名を最初の数桁の16進数にのみに省略できることを示しています。
@end quotation

とにかく、前述したように、通常、オブジェクト自体を実際に確認することはありません。40文字の長い16進名を入力することは、通常は行いたくないことです。上記の余談は、「git update-index」が魔法のようなことをし、実際にファイルの内容をGitオブジェクトデータベースに保存したことを現しています。

インデックスを更新すると、他のことも行います。それは、 @samp{.git/index} ファイルの作成です。これは、現在の作業ツリーを説明するインデックスであり、とても注意を払う必要があります。 繰り返しになりますが、通常はインデックスファイル自体について心配することはありませんが、ここまでファイルを実際にはGitに「チェックイン」しておらず、Gitに「伝えただけ」であることに注意する必要があります。

しなしながら、Gitはそれらについて知っているため、最も基本的なGitコマンドのいくつかを使用して、ファイルを操作したり、ファイルのステータスを確認したりできます。

特に、この時点ではこの2つのファイルをGitにチェックインしないでください。私達は、最初に、@samp{hello} に別の行を追加することから始めます:

@example
$ echo "It's a new day for git" >>hello
@end example


これで、Gitに以前の @samp{hello} の状態について伝えたので、 @emph{git diff-files} コマンドを使用して、古いインデックスと比較してツリーで何が変更されたかをGitに尋ねることができます:

@example
$ git diff-files
@end example


おっと、これはあまり読みやすくないですね。これは @emph{diff} の独自の内部バージョンを吐き出すだけですが、その内部バージョンは、「hello」が変更されたこと、および古いオブジェクトの内容が別のものに置き換えられたことに気付いたことを示しています。

読みやすくするために、 @samp{-p} フラグを使用して、 @emph{git diff-files} にパッチとして差分を出力するように指示できます:

@example
$ git diff-files -p
diff --git a/hello b/hello
index 557db03..263414f 100644
--- a/hello
+++ b/hello
@@@@ -1 +1,2 @@@@
 Hello World
+It's a new day for git
@end example


つまり、これは @samp{hello} に別の行を追加することによって引き起された変更の diff です。

言い換えると、 @emph{git diff-files} は、常に、インデックスに記録されているものと、現在作業ツリーにあるものとの違いを示しています。これはとても便利です。

@samp{git diff-files -p} の一般的な省略形は、 @samp{git diff} と書くことで、左記と同一の事を行います。

@example
$ git diff
diff --git a/hello b/hello
index 557db03..263414f 100644
--- a/hello
+++ b/hello
@@@@ -1 +1,2 @@@@
 Hello World
+It's a new day for git
@end example


@noindent

@chapheading Committing Git state

次に、私達はGitの次の段階に進みます。これは、Gitが知っているファイルをインデックスより取得し、それらを実際のツリーとしてコミットすることです。これは次の2つのフェーズで行います。「ツリー」オブジェクトの作成し、そして、ツリーが何であるかについての説明と、私たちがどのようにしてその状態に到達したかについての情報とともに、その「ツリー」オブジェクトを「コミット」オブジェクトとしてコミットします。

ツリーオブジェクトの作成は至極簡単で、 @samp{git write-tree} を使用します。オプションやその他の入力はありません。 @samp{git write-tree} は現在のインデックスの状態を取得し、そのインデックス全体を記述するオブジェクトを書き込みます。つまり、現在、すべての異なるファイル名をそれらのコンテンツ(およびそれらのアクセス許可)と結び付けており、Gitの「ディレクトリ」オブジェクトに相当するものを作成します:

@example
$ git write-tree
@end example


これにより、結果のツリーの名前が出力されます。この場合(私が説明したとおり正確に実行した場合)、以下のようになっているべきです

@example
8988da15d077d4829fc51d8544c097def6644dbb
@end example


これは、別のワケワカメなオブジェクト名です。繰り返しになりますが、あなたは必要に応じて、 @samp{git cat-file -t 8988d...} を使用して、今回のオブジェクトが「ブロブ」オブジェクトではなく「ツリー」オブジェクトであることを確認できます( @samp{git cat-file} を使用して、生のオブジェクトの内容を実際に出力することもできますが、主にごちゃごちゃしたバイナリが見れるだけであまり面白くありません)。

しかしながら、通常は @samp{git commit-tree} コマンドを使用してツリーをコミットオブジェクトにコミットするため、通常は @samp{git write-tree} を単独で使用することはありません。 実際のところ @samp{git write-tree} を単独で使用するのではなく、その結果を @samp{git commit-tree} へ引数として渡す方が簡単です。

@emph{git commit-tree} は通常、いくつかの引数を取ります。 @samp{git commit-tree} はコミットの「親」が何であるかを知りたいのですが、これはこの新しいリポジトリでの最初のコミットであり、親がないため、ツリーのオブジェクト名を渡すだけで済みます。ただし、 @samp{git commit-tree} は、標準入力からコミットメッセージを取得することも必要です。そしてコミットの結果のオブジェクト名を標準出力に書き出します。

ここで、 @samp{HEAD} が指す @samp{.git/refs/heads/master} ファイルを作成します。このファイルには、masterブランチのツリーのてっぺん(top-of-tree)への参照が含まれているはずです。これはまさに「git commit-tree」が吐き出すものなので、一連の単純なシェルコマンドでこれをすべて行うことができます:

@example
$ tree=$(git write-tree)
$ commit=$(echo 'Initial commit' | git commit-tree $tree)
$ git update-ref HEAD $commit
@end example


この場合に限り、他の何にも関係のないまったく新しいコミットが作成されます。 通常、これはプロジェクトに対して「1回だけ」行います。このコミットはこの後のすべてのコミットの親になります。

繰り返しますが、通常、これを実際に手作業で行うことはありません。 これらすべてを実行する @samp{git commit} という便利なスクリプトがあります。 したがって、あなたは代わりに @samp{git commit} と記述すれば、上記の魔法のスクリプトが実行されます。

@noindent

@chapheading Making a change

以前、ファイル @samp{hello} で @samp{git update-index} を実行し、その後 @samp{hello} を変更して、 @samp{hello} の新しい状態を、インデックスファイルに保存した状態と比較したことを覚えていますか？

さらに、 私が @samp{git write-tree} は「インデックス」ファイルの内容をツリーに書き込むと言ったことを思い出してください。したがって、コミットしたのは、実際にはファイル @samp{hello} の「元の内容」であり、新しい内容ではありません。これは、インデックスの状態と作業ツリーの状態の違い、および私達が何かをコミットした場合でもそれらが一致する必要がない事を示すために意図的に行いました。

以前と同様に、git-tutorialプロジェクトで @samp{git diff-files -p} を実行した場合でも、前回と同一の差異が見られます。つまり、何かをコミットすることによってインデックスファイルが変更されていないということです。ただし、私達は何かをコミットしたので、新しいコマンド @samp{git diff-index} の使用方法を学ぶこともできます:

インデックスファイルと作業ツリーの違いを示した @samp{git diff-files} とは異なり、 @samp{gitdiff-index} はコミットされたツリーと、インデックスファイルまたは作業ツリーとの違いを示します。言い換えると、 @samp{git diff-index} はツリーとの差分することを望んでおり、コミットする前は、そもそも差分するモノがなかったため、差分を行うことができませんでした。

しかし、今や私達は以下のようにできます

@example
$ git diff-index -p HEAD
@end example


(ここで、@samp{-p} は @samp{git diff-files} のと同じ意味です。) 同一の差異が表示されますが、理由はまったく異なります。これは、作業ツリーを、インデックスファイルではなく、作成したツリーと比較しています。たまたまこれら2つが明らかに同じであるため、私達は同じ結果を得たのです。

繰り返しになりますが、これは一般的な操作であるため、以下のように短縮することもできます

@example
$ git diff HEAD
@end example


これで、結局は上記のようなことをやってくれます。

つまり、 @samp{git diff-index｀ は通常、ツリーを作業ツリーと比較しますが、 `--cached} フラグを指定すると、代わりにインデックスキャッシュの内容と比較し、現在の作業ツリーの状態を完全に無視するように指示します。我々はインデックスファイルをHEADに書き込んだばかりなので、 @samp{git diff-index --cached -p HEAD} を実行すると、空の差分セットを返すはずで、これは正に指示したとおりの結果です。

@quotation

@strong{Note}

@samp{git diff-index} は実際には「常に」その比較にインデックスを使用するため、ツリーを作業ツリーと比較すると言ったことは厳密には正確ではありません。特に、比較するファイルのリスト(「メタデータ」(meta-data))は、 @samp{--cached} フラグが使用されているかどうかに関係なく、常にインデックスファイルから取得されます。 @samp{--cached} フラグは、実際には、比較されるファイルの「内容」が作業ツリーからのものであるか否かを決定するだけです。

これを理解するのは難しいことでは無く、すぐにあなたは、Gitが明示的に通知されていないファイルを知らない(または気にしない)ことに気付きます。Gitは比較するファイルを「探す」ことは決してありません。ファイルが何であるかを教えて貰えることを期待しており、それがインデックスの目的なのです。
@end quotation

ただし、私達の次のステップは、私達の行った変更をコミットすることです。繰り返しますが、何が起こっているのかを理解するために、「作業ツリーの内容」と「インデックスファイル」と「コミットされたツリー」の違いに注意してください。私達がコミットしたい作業ツリーに変更があり、私達は常にインデックスファイルを処理する必要があるため、したがって、私達が最初に行う必要があるのは、インデックスキャッシュを更新することです:

@example
$ git update-index hello
@end example


(注意: Gitはファイルについてすでに知っていたので、私達は今回は @samp{--add} フラグを必要としなかったことに注意してください)。

注意: ここで、個別の @samp{git diff-@{asterisk@}} バージョンには何が起こるでしょうか。我々がインデックス内の @samp{hello} を更新した後、 @samp{git diff-files -p} は、違いを示さなくなりましたが、 @samp{git diff-index -p HEAD} は、現在の状態がコミットした状態とは異なることを示しています。 実際、 @samp{git diff-index} は、 @samp{--cached} フラグを使用するかどうかに関係なく同一の違いを示します。これは、インデックスは作業ツリーと一貫性があるためです。

これで、我々はインデックス内の @samp{hello} を更新したので、我々は新しいバージョンをコミットできます。我々はもう一度手動でツリーを作成し、ツリーをコミットすることでそれを行うことができます(今回は、 @samp{-p HEAD} フラグを使用して、HEADが新しいコミットの「親」であり、これが最初のコミットではなくなったことをコミットに通知する必要があります)。しかし、あなたはすでに一度この手作業を経験済みですので、今回は役立つスクリプトを使用してみましょう:

@example
$ git commit
@end example


これにより、あなたがコミットメッセージを書き込むためのエディタが起動し、あなたがさっきやった事についてちょっぴり教えてくれます。

あなたが必要なメッセージを書き込むと、 @samp{#} で始まるすべての行が削除され、残りはこの変更のコミットメッセージとして使用されます。あなたがこの時点で結局何もコミットしたくないと判断した場合(あなたは引き続き編集してインデックスを更新できます)、あなたは空のメッセージを残すことができます。それ以外の場合、 @samp{git commit} は変更をコミットします。

これで、最初の実際のGitコミットが完了しました。 @samp{git commit} が実際に何をするのかを知りたい場合は、お気軽に調査してください。役立つ(？)コミットメッセージヘッダーを生成するための非常に単純なシェルスクリプトがいくつかあり、そして実際にコミット自体を行ういくつかのワンライナーがあります(@samp{git commit})。

@noindent

@chapheading Inspecting Changes

変更を作成することは便利ですが、後で何が変更されたかを知ることができればさらに便利です。このための最も便利なコマンドは、diffファミリーのもう1つ、つまり @samp{git diff-tree} です。

@samp{git diff-tree} には任意の2つのツリーを指定でき、それらの間の違いがわかります。けれども、おそらくもっと一般的には、あなたはコミットオブジェクトを1つだけ与えることができ、そうすると、そのコミット自体の親を把握し、違いを直接表示します。したがって、すでに数回見たのと同一のdiffを取得するために、以下のようにすることができます

@example
$ git diff-tree -p HEAD
@end example


(繰り返しになりますが、 @samp{-p} は人間が読めるパッチとして違いを表示することを意味します)、(@samp{HEAD} が指す)最後のコミットが実際に何を変更したかを表示します。

@quotation

@strong{Note}

以下は、さまざまな @samp{diff-@{asterisk@}} コマンドが物事を比較する方法を表す、Jon Loeliger によるアスキーアートです。

@example
            diff-tree
             +----+
             |    |
             |    |
             V    V
          +-----------+
          | Object DB |
          |  Backing  |
          |   Store   |
          +-----------+
            ^    ^
            |    |
            |    |  diff-index --cached
            |    |
diff-index  |    V
            |  +-----------+
            |  |   Index   |
            |  |  "cache"  |
            |  +-----------+
            |    ^
            |    |
            |    |  diff-files
            |    |
            V    V
          +-----------+
          |  Working  |
          | Directory |
          +-----------+
@end example
@end quotation

さらに興味深いことに、 @samp{git diff-tree} に @samp{--pretty} フラグを指定することもできます。これにより、コミットメッセージと作者とコミットの日付も表示され、一連のdiff全体を表示するように指示します。または、「黙って」(silent)と指示して、差分をまったく表示せずに実際のコミットメッセージを表示することもできます。

実際には、 (リビジョンのリストを生成する) @samp{git rev-list} プログラムと一緒に使うことで、 @samp{git diff-tree} は、正に変更の源泉と化します。 @samp{git rev-list} の出力を @samp{git diff-tree --stdin} にパイプする簡単なスクリプトを使用して、 @samp{git log} や @samp{git log -p} などをエミュレートできます。これは正に初期バージョンの @samp{git log} が実装された方法でした。

@noindent

@chapheading Tagging a version

Gitには、「軽い」(light)タグと「注釈付きタグ」(annotated tag)の2種類のタグがあります。

「軽い」タグは、 ヘッドと呼ぶ代わりに @samp{.git/refs/tags/} サブディレクトリに配置することを除いて、技術的にはブランチ以上のものではありません。したがって、最も単純な形式のタグは以下のようになります

@example
$ git tag my-first-tag
@end example


これは、現在の HEAD を @samp{.git/refs/tags/my-first-tag} ファイルに書き込むだけです。その後は、その特定の状態にこのシンボル名を使用できます。たとえば、以下のことができます

@example
$ git diff my-first-tag
@end example


あなたの現在の状態をそのタグとdiffします。この時点では明らかに空のdiffになりますが、あなたが開発とコミットを続ければ、タグを「アンカーポイント」として使用して、あなたがタグを付けてから何が変更されたかを確認できます。

「注釈付きタグ」(annotated tag)は現実には実際のGitオブジェクトです。タグ付けする状態へのポインタだけでなく、小さなタグ名とメッセージ、およびオプションで「はい、あなたは実際にそのタグを作成した」というPGP署名もあります。これらの注釈付きタグは、 @samp{git tag} に対して @samp{-a} または @samp{-s} フラグを使用して作成します:

@example
$ git tag -s <tagname>
@end example


これは現在の`HEAD`に署名します(しかし、あなたはタグ付けするものを指定する別の引数を指定することもできます。たとえば、 @samp{git tag <tagname> mybranch} を使用して現在の @samp{mybranch} ポイントにタグを付けることができます)。

あなたは、通常は、メジャーリリースなどの署名付きタグ付けのみを行いますが、軽量タグ(light-weight tags)は、あなたがマーキングしたい時に便利です。つまり、特定のポイントを覚えておきたいと思ったときはいつでも、そのポイントのプライベートタグを作成するだけで、その時点の状態の適切なシンボル名が得られます。

@noindent

@chapheading Copying repositories

Gitリポジトリは通常、完全に自給自足で再配置可能です。たとえば、CVSとは異なり、「リポジトリ」と「作業ツリー」という別個の概念はありません。Gitリポジトリは通常、作業ツリーであり、ローカルのGit情報は @samp{.git} サブディレクトリに隠されています。他には何もありません。あなたが見たそのままです。

@quotation

@strong{Note}

あなたは、追跡中のディレクトリからGitの内部情報を分割するようにGitに指示できますが、我々は今のところはそれを無視します。なぜならそれは、通常のプロジェクトの仕組みでなく、本当に特別な用途のためだけのものだからです。よって、「Git情報は、それが記述する作業ツリーに常に直接関連付けられている」という概念は技術的には100%正確ではない可能性がありますが、通常はそれで通ります。
@end quotation

これには2つの意味があります:

@itemize 

@item
あなたが、作成したチュートリアルリポジトリに飽きてしまった場合(または間違えて最初からやり直したい場合)は、単純に以下のようにするだけです

@example
$ rm -rf git-tutorial
@end example


そしてそれはなくなります。外部リポジトリはありませんし、あなたが作成したプロジェクト以外に履歴はありません。

@item
あなたがGitリポジトリを移動または複製する場合は、あなたはそうすることができます。 @samp{git clone} コマンドがありますが、リポジトリ(と、それに伴うすべての完全な履歴とともに)のコピーを作成するだけの場合は、通常の @samp{cp -a git-tutorial new-git-tutorial} を使用して作成できます。

注意: Gitリポジトリを移動またはコピーした場合、Gitインデックスファイル(さまざまな情報、特に関連するファイルの「統計」情報の一部をキャッシュする)を更新する必要がある可能性があることに注意してください。したがって、 @samp{cp -a} を実行して新しいコピーを作成した後、あなたは以下を実行する必要があります

@example
$ git update-index --refresh
@end example


これは、新しいリポジトリで、インデックスファイルが最新であることを確認します。
@end itemize

注意: 2番目のポイントは、PC間でも当てはまることに注意してください。scpやrsyncやwget等々、通常のコピーメカニズムを使用してリモートGitリポジトリを複製できます。

リモートリポジトリをコピーするときは、あなたは、これを行うときに少なくともインデックスキャッシュを更新する必要があります。特に、他の人のリポジトリでは、インデックスキャッシュが既知の状態(あなたには、彼らが何をしたのか、まだチェックインしていないのかわかりません)にあることを確認する必要があるため、通常は @samp{git update-index} の前に以下のようにします。

@example
$ git read-tree --reset HEAD
$ git update-index --refresh
@end example


これにより、@samp{HEAD} が指すツリーからインデックス全体が再構築されます。それはインデックスの内容を @samp{HEAD} にリセットし、 @samp{git update-index} がすべてのインデックスエントリをチェックアウトされたファイルと一致させるようにします。元のリポジトリの作業ツリーにコミットされていない変更があった場合、 @samp{git update-index --refresh} はそれらに気づき、更新する必要があることをあなたに通知します。

上記は以下のように簡単に書くこともできます

@example
$ git reset
@end example


実際、一般的なGitコマンドの組み合わせの多くは、 @samp{git xyz} インターフェースを使用してスクリプト化できます。あなたは、さまざまなgitスクリプトが何をするかを見るだけで、物事を学ぶことができます。たとえば、 @samp{git reset} は、以前は上記2行を記述したものでした。ただし、 @samp{git status} や @samp{git commit} などのいくつかは、基本的なGitコマンドを中心とした少し複雑なスクリプトです。

多くの(ほとんどの？)パブリックリモートリポジトリには、チェックアウトされたファイルやインデックスファイルすら含まれず、実際のコアGitファイルのみが含まれます。このようなリポジトリには通常、 @samp{.git} サブディレクトリすらなく、すべてのGitファイルが直接リポジトリにあります。

このような「生の」Gitリポジトリのあなた独自のローカルな活きたコピー(local live copy)を作成するには、最初にプロジェクト用の独自のサブディレクトリを作成し、次に生のリポジトリの内容を @samp{.git} ディレクトリにコピーします。たとえば、Gitリポジトリのあなた独自のコピーを作成するには、以下のようにします

@example
$ mkdir my-git
$ cd my-git
$ rsync -rL rsync://rsync.kernel.org/pub/scm/git/git.git/ .git
@end example


これに、以下が続きます

@example
$ git read-tree HEAD
@end example


インデックスにデータを入力します。ただし、これでインデックスにデータが入力され、すべてのGit内部ファイルが作成されましたが、実際に作業するツリーファイルがないことに気付くでしょう。 それらを取得するには、以下のようにしてそれらをチェックアウトします

@example
$ git checkout-index -u -a
@end example


ここで、 @samp{-u} フラグは、(後で更新する必要がないように)チェックアウトでインデックスを最新の状態に保つことを意味し、 @samp{-a} フラグは「すべてのファイルをチェックアウトする」ことを意味します(古いコピーまたはチェックアウトされたツリーの古いバージョンがある場合は、最初に @samp{-f} フラグを追加して、 @samp{git checkout-index} に古いファイルの上書きを「強制」するように指示する必要がある事があります)。

繰り返しますが、これはすべて以下のように簡略化できます

@example
$ git clone git://git.kernel.org/pub/scm/git/git.git/ my-git
$ cd my-git
$ git checkout
@end example


これは正に上記のすべてを行います。

これで、あなたは、他の誰か誰か(またはあなた自身の)のリモートリポジトリをコピーし、チェックアウトすることに成功しました。

@noindent

@chapheading Creating a new branch

Gitのブランチは、実際には @samp{.git/refs/} サブディレクトリ内からGitオブジェクトデータベースへのポインタにすぎません。すでに説明したように、@samp{HEAD} ブランチはこれらのオブジェクトポインタの1つへのシンボリックリンクにすぎません。

あなたはプロジェクト履歴の任意のポイントを選択し、そのオブジェクトのSHA-1名を @samp{.git/refs/heads/} の下のファイルに書き込むだけで、いつでも新しいブランチを作成できます。任意のファイル名(実際にはサブディレクトリ名)を使用できますが、慣例では、「通常の」ブランチ(normal branch)は「master」と呼ばれます。 ただし、これは単なる慣例であり、強制されるものではありません。

これを例として示すために、以前使用したgit-tutorialリポジトリに戻り、その中にブランチを作成しましょう。これを行うには、あなたは新しいブランチをチェックアウトしたいと言うだけです:

@example
$ git switch -c mybranch
@end example


現在の @samp{HEAD} 位置に基づいて新しいブランチを作成し、それに切り替えます。

@quotation

@strong{Note}

あなたが、履歴の現在のHEAD以外の時点で新しいブランチを開始することを決定した場合は、 @samp{git switch} にチェックアウトの起点を指定するだけで開始できます。 言い換えれば、以前に作ったタグまたはブランチがある場合は以下のようにします。

@example
$ git switch -c mybranch earlier-commit
@end example


そうすると、これは以前のコミットにて新しいブランチ @samp{mybranch} を作成し、その時の状態をチェックアウトします。
@end quotation

以下のように実行することで、あなたはいつでも元の @samp{master} ブランチに戻ることができます

@example
$ git switch master
@end example


(または、その他のブランチ名を指定します。) そして、あなたがたまたまどのブランチにいるのかを忘れた場合は、単純に以下のようにします。

@example
$ cat .git/HEAD
@end example


とすると、それが指している場所を教えてくれます。あなたが持っているブランチのリストを取得するには、以下のようにします。

@example
$ git branch
@end example


これは、以前は、 @samp{ls .git/refs/heads} を囲む単純なスクリプトにすぎませんでした。それはそれとして、これは、現在使用しているブランチの前にアスタリスクが表示されます。

実際にチェックアウトして切り替えることなく、新しいブランチを作成したい場合があります。その場合は、以下のコマンドを使用してください

@example
$ git branch <branchname> [startingpoint]
@end example


これは単にブランチを作成しますが、それ以上は何もしません。 その後 — そのブランチで実際に開発することを決定したら — 引数としてブランチ名を使用して、通常の `git switch `を使用してそのブランチに切り替えることができます。

@noindent

@chapheading Merging two branches

ブランチを持つことのアイデアの1つは、ブランチでいくつかの(おそらく実験的な)作業を行い、最終的にそれをメインブランチにマージすることです。したがって、元の @samp{master} ブランチと同じである、上記の @samp{mybranch} を作成したと仮定して、我々がそのブランチにいることを確認し、そこでいくつかの作業を行いましょう。

@example
$ git switch mybranch
$ echo "Work, work, work" >>hello
$ git commit -m "Some work." -i hello
@end example


ここでは、 @samp{hello} に別の行を追加し、 @samp{-i} フラグ(コミット時にこれまでにインデックスファイルに対して行ったことに加えて、そのファイルを「含める」ようにGitに指示)を使用してファイル名を @samp{git commit} に直接指定する、 @samp{git update-index hello} と @samp{git commit} の両方を実行するための省略形を使用しました。 @samp{-m} フラグは、コマンドラインからコミットログメッセージを指定するためのものです。

ここで、もう少し面白くするために、他の誰かが元のブランチで何らかの作業を行っていると仮定し、マスターブランチに戻って同じファイルを別の方法で編集することにより、それをシミュレートします:

@example
$ git switch master
@end example


ここで、 @samp{hello} の内容を確認して、あなたが @samp{mybranch} で行った作業が含まれていないことに注目してください。その作業は @samp{master} ブランチではまったく行われていないためです。確認後、以下のようにします

@example
$ echo "Play, play, play" >>hello
$ echo "Lots of fun" >>example
$ git commit -m "Some fun." -i hello example
@end example


masterブランチもいい感じになってきました。

いまや、2つのブランチがあり、あなたは完了した作業をマージすることにしました。 その前に、何が起こっているのかを確認するのに役立つクールなグラフィカルツールを紹介しましょう:

@example
$ gitk --all
@end example


あなたのブランチ(これが @samp{--all} の意味です。通常は、現在の @samp{HEAD} が表示されます)とその履歴の両方をグラフィカルに表示します。また、それらがどのようにして共通のソースから得られたのかを正確に確認することもできます。

とにかく、 @emph{gitk} を終了( @samp{^Q} または Fileメニュー)し、 @samp{mybranch} ブランチで行った作業を @samp{master} ブランチ（現在は @samp{HEAD} でもあります)にマージすることにします。これを行うために、 @samp{git merge} と呼ばれる優れたスクリプトがあり、それは、あなたがどのブランチを解決したいのか、そのマージが何なのかを知りたがっています:

@example
$ git merge -m "Merge work in mybranch" mybranch
@end example


マージを自動的に解決できる場合は、最初の引数がコミットメッセージとして使用されます。

さて、今回は、マージを手動で修正する必要がある状況を意図的に作成したので、Gitは可能な限り多くのことを自動的に実行(この場合は、 @samp{mybranch} ブランチの、差異がない @samp{example} ファイルをマージするだけ)した上で、以下のように言います:

@example
        Auto-merging hello
        CONFLICT (content): Merge conflict in hello
        Automatic merge failed; fix conflicts and then commit the result.
@end example


これは、「自動マージ」(Automatic merge)を実行したら @samp{hello} の競合が原因で失敗したと表示しています。

でも心配無用。これにより、あなたがCVSを使ったことがあるなら既に慣れている形式で @samp{hello} に競合を残したので、エディタで @samp{hello} を開いて、なんとかして修正しましょう。私は `hello`に4行すべてが含まれるようにすることを提案することにします:

@example
Hello World
It's a new day for git
Play, play, play
Work, work, work
@end example


手動マージに満足したら、以下の手順を実行します。

@example
$ git commit -i hello
@end example


これは、現在マージをコミットしていることを非常に大声で警告します(今回は正しい事をしているので、警告は気にしないでください)。また、あなたは @samp{git merge} 遊園地でのあなたの冒険についての小さなマージメッセージを書くことができます。

完了したら、 @samp{gitk --all} を起動して、履歴がどのように表示されるかをグラフィカルに確認します。 @samp{mybranch} はまだ存在していることに注意してください。これに切り替えて、必要に応じて作業を続けることができます。 @samp{mybranch} ブランチにはそのマージが含まれませんが、次回 @samp{master} ブランチにてそれをマージするときに、Gitはそれがどのようにマージされたかを知っているため、再度マージを行う必要はありません。

X-Window環境で常に作業するわけではない場合、もう1つの便利ツールは、 @samp{git show-branch} です。

@example
$ git show-branch --topo-order --more=1 master mybranch
* [master] Merge work in mybranch
 ! [mybranch] Some work.
--
-  [master] Merge work in mybranch
*+ [mybranch] Some work.
*  [master^] Some fun.
@end example


最初の2行は、ツリーの最上位コミットのタイトル付の2つのブランチを示しています。あなたは現在(アスタリスク @samp{*} 文字に注意)、 @samp{master} ブランチを使用しており、その後の出力行は、 @samp{master} ブランチに含まれるコミットと、 @samp{mybranch} ブランチの行の2桁目(@samp{+})を表示するために使用されます。3つのコミットがタイトルとともに表示されます。それらはすべて1桁目に空白以外の文字があり( @samp{*} は現在のブランチでの通常のコミットを示し、@samp{-} はマージコミットです)、これはそれらが現在 @samp{master} ブランチの一部であることを意味します。 @samp{mybranch} はmasterブランチからのこれらのコミットを組み込むためにマージされていないため、「Some work」コミットのみが2桁目にプラスの @samp{+} 文字を持っています。コミットログメッセージの前の括弧内の文字列は、コミットに名前を付けるために使用できる短い名前です。上記の例では、 "master" と "mybranch" がブランチヘッドです。 "master^" は "master" ブランチヘッドの最初の親です。より複雑なケースを確認したい場合は、 gitrevisions(7) を参照してください。

@quotation

@strong{Note}

@emph{--more=1} オプションがないと、 @emph{[mybranch]} コミット は @emph{master} と @emph{mybranch} の両方の先端の共通の祖先であるため、 @samp{git show-branch} は '[master^] コミットを出力しません。詳細については、 git-show-branch(1) を参照してください。
@end quotation

@quotation

@strong{Note}

マージ後に @samp{master} ブランチにさらにコミットがあった場合、@samp{git show-branch} はデフォルトではマージコミット自体を表示しません。この場合、マージコミットを表示するには、 @samp{--sparse} オプションを指定する必要があります。
@end quotation

さて、あなたが @samp{mybranch} ですべての作業を行ったとしましょう。そして、あなたの努力の成果がついに @samp{master} ブランチに統合されました。あなたは `mybranch`に戻り、 @emph{git merge} を実行して、「アップストリームの変更」をあなたのブランチに戻しましょう。

@example
$ git switch mybranch
$ git merge -m "Merge upstream changes." master
@end example


これは以下のようなものを出力します(実際のコミットオブジェクト名は異なります)

@example
Updating from ae3a2da... to a80b4aa....
Fast-forward (no commit created; -m option ignored)
 example | 1 +
 hello   | 1 +
 2 files changed, 2 insertions(+)
@end example


あなたのブランチにはすでに @samp{master} ブランチにマージされたもの以外のものが含まれていなかったため、マージ操作は実際にはマージを実行しませんでした。代わりに、あなたのブランチのツリーのトップを @samp{master} ブランチのツリーのトップに更新しました。これはしばしば「早送り」(fast-forward)マージと呼ばれます。

あなたは再び @samp{gitk --all} を実行して、コミットの祖先がどのように見えるかを確認するか、 @samp{show-branch} を実行して表示します。

@example
$ git show-branch master mybranch
! [master] Merge work in mybranch
 * [mybranch] Merge work in mybranch
--
-- [master] Merge work in mybranch
@end example


@noindent

@chapheading Merging external work

通常、自分のブランチとマージするよりも、他の誰かのとマージする方がはるかに一般的です。そして、Gitを使用すると、これも非常に簡単になります。事実、 @samp{git merge} を実行するのとそれほど違いはありません。 実際、リモートマージは、「リモートリポジトリから一時的タグ(temporary tag)に作業をフェッチする」だけで、その後に @samp{git merge} が続きます。

リモートリポジトリからのフェッチは、ご想像の通り、 @samp{git fetch} によって行われます:

@example
$ git fetch <remote-repository>
@end example


以下の転送方法(transport)のいずれかを使用して、ダウンロード元のリポジトリに名前を付けることができます:

@table @asis

@item  SSH 
@samp{remote.machine:/path/to/repo.git/} または

@samp{ssh://remote.machine/path/to/repo.git/}

この転送方法(transport)はアップロードとダウンロードの両方に使用でき、リモートマシンへの @samp{ssh} を介したログイン権限が必要です。転送元と転送先が持つヘッドコミットを交換し、オブジェクトの最小組を(限定的に)転送することにより、反対側に欠けているオブジェクトの組を見つけます。これは、リポジトリ間でGitオブジェクトを交換するための最も効率的な方法です。

@item  ローカルディレクトリ 
@samp{/path/to/repo.git/}

この転送方法はSSH転送と同じですが、 @samp{ssh} を介してリモートマシンでもう一方の端を実行する代わりに、 @samp{sh} を使用してローカルマシンで転送元と転送先で実行します。

@item  Gitネイティブ 
@samp{git://remote.machine/path/to/repo.git/}

この転送方法は、匿名(anonymous)でダウンロードするために設計されました。SSH転送と同様に、ダウンストリーム側にないオブジェクトの組を検出し、最小のオブジェクトの組を(限定的)転送します。

@item  HTTP(S) 
@samp{http://remote.machine/path/to/repo.git/}

http URL や https URL からのダウンローダーは、最初に、 @samp{repo.git/refs/} ディレクトリの下にある指定のref名を調べて、リモートサイトから最上位のコミットオブジェクト名を獲得し、それから、そのコミットオブジェクトのオブジェクト名を使用して @samp{repo.git/objects/xx/xxx...} からダウンロードすることにより、コミットオブジェクトの取得を試みます。次に、そのコミットオブジェクトを読み取り、その親コミットと関連するツリーオブジェクトを見つけます。必要なすべてのオブジェクトを取得するまで、このプロセスを繰り返します。この動作のため、これらは「コミットウォーカー」(commit walkers)と呼ばれることもあります。

「コミットウォーカー」(commit walkers)は、Gitネイティブ転送のようにGit対応のスマートサーバーを必要としないため、「バカ転送」(dumb transports)と呼ばれることもあります。ディレクトリインデックスさえサポートしていないストックHTTPサーバーで十分です。 ただし、バカ転送ダウンローダー(dumb transport downloaders)を支援するには、 @samp{git update-server-info} を使用してリポジトリを準備する必要があります。
@end table

リモートリポジトリからフェッチしたら、あなたはそれを現在のブランチに「マージ」します。

ただし、「フェッチ」してすぐに「マージ」するのは非常に一般的なことなので、 @samp{git pull} を使えば簡単に実行できます:

@example
$ git pull <remote-repository>
@end example


そして、オプションで、リモート側のブランチ名を2番目の引数として指定します。

@quotation

@strong{Note}

あなたが持ちたいブランチの数のローカルリポジトリを保持し、ブランチ間のマージと同様に @samp{git pull} でそれらの間のマージを行うことで、ブランチを全く使用しないことも可能です。このアプローチの利点は、チェックアウトされた各々「ブランチ」のファイルの組を保持できることです。複数の開発ラインを同時に調整すると、切り替えが簡単になる場合があります。もちろん、複数の作業ツリーを保持するためにディスク使用量を増やすという代償を払うことにはなりますが、最近のディスク容量は安価です。
@end quotation

あなたは同じリモートリポジトリからしばしばプルする可能性があります。なので略記法として、リモートリポジトリのURLをローカルリポジトリの設定ファイルに以下のように保存できます:

@example
$ git config remote.linus.url http://www.kernel.org/pub/scm/git/git.git/
@end example


そして、完全なURLの代わりに @samp{git pull} で "linus" キーワードを使用します。

例:

@enumerate 

@item
@samp{git pull linus}

@item
@samp{git pull linus tag v0.99.1}
@end enumerate

上記は以下と同じです:

@enumerate 

@item
@samp{git pull http://www.kernel.org/pub/scm/git/git.git/ HEAD}

@item
@samp{git pull http://www.kernel.org/pub/scm/git/git.git/ tag v0.99.1}
@end enumerate

@noindent

@chapheading How does the merge work?

このチュートリアルでは、動作しない磁器コマンドに対処するために配管コマンドがどのように機能するかを示していますが、これまでのところ、マージが実際にどのように機能するかについては説明していません。あなたがこのチュートリアルを初めて読む時は、「Publishing your work」セクションにスキップして、後でここに戻ってくることをお勧めします。

上記を了承したとして、続きをやります。例を示すために、 @samp{hello} ファイルと @samp{example} ファイルを使用した以前のリポジトリに戻り、マージ前の状態に戻しましょう:

@example
$ git show-branch --more=2 master mybranch
! [master] Merge work in mybranch
 * [mybranch] Merge work in mybranch
--
-- [master] Merge work in mybranch
+* [master^2] Some work.
+* [master^] Some fun.
@end example


@samp{git merge} を実行する前は、 @samp{master} ヘッドが "Some fun." コミット、 @samp{mybranch} ヘッドが "Some work." コミットだったことを思い出してください。

@example
$ git switch -C mybranch master^2
$ git switch master
$ git reset --hard master^
@end example


巻き戻し後、コミット構造は以下のようになります:

@example
$ git show-branch
* [master] Some fun.
 ! [mybranch] Some work.
--
*  [master] Some fun.
 + [mybranch] Some work.
*+ [master^] second commit.
@end example


これで、手動でマージを試す準備ができました。

@samp{git merge} コマンドは、2つのブランチをマージするときに、3方向マージアルゴリズムを使用します。 まず、それらの間の共通の祖先を見つけます。使用するコマンドは @samp{git merge-base} です:

@example
$ mb=$(git merge-base HEAD mybranch)
@end example


このコマンドは、共通の祖先のコミットオブジェクト名を標準出力に書き込むため、我々は次のステップで使用するため、その出力を変数にキャプチャしました。ちなみに、今回は、共通の祖先コミットは「second commit.」コミットです。あなたはそれを以下のように言うことができます:

@example
$ git name-rev --name-only --tags $mb
my-first-tag
@end example


共通の祖先コミットを見つけた後の、2番目のステップは以下のとおりです:

@example
$ git read-tree -m -u $mb HEAD mybranch
@end example


これは、すでに見たのと同じ @samp{git read-tree} コマンドですが、前の例とは異なり、3つのツリーが必要です。 これにより、各ツリーの内容がインデックスファイルの異なる「ステージ」に読み込まれます(最初のツリーはステージ1に、2番目はステージ2に、等)。3つのツリーを3つのステージに読み取った後、3つのステージで同じパスがある場合はステージ0に「折りたたまれます」(collapsed)。また、3つのステージのうちの2つで同じパスは、ステージ0に折りたたまれ、ステージ1と異なるステージ2またはステージ3のいずれかからSHA-1を取得します(つまり、共通の祖先から片側だけが変更されます)。

「折りたたみ」(collapsing)操作の後、3つのツリーで異なるパスはゼロ以外のステージに残されます。この時点で、以下のコマンドを使用してインデックスファイルを調査できます:

@example
$ git ls-files --stage
100644 7f8b141b65fdcee47321e399a2598a235a032422 0       example
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1       hello
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2       hello
100644 cc44c73eb783565da5831b4d820c962954019b69 3       hello
@end example


私達の2つのファイルのみの例では、変更されていないファイルがなかったため、 @samp{example} のみが折りたたまれました。 しかし、実際の大規模なプロジェクトでは、1回のコミットで変更されるファイルの数が少ない場合、この「折りたたみ」はほとんどのパスをかなり迅速にマージする傾向があり、ゼロ以外のステージでの実際の変更はほんの一握りになります。

ゼロ以外のステージのみを確認するには、 @samp{--unmerged} フラグを使用します:

@example
$ git ls-files --unmerged
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1       hello
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2       hello
100644 cc44c73eb783565da5831b4d820c962954019b69 3       hello
@end example


マージの次のステップは、3方向マージを使用して、これら3つのバージョンのファイルをマージすることです。これは、 @samp{git merge-index} コマンドの引数の1つとして @samp{git merge-one-file} コマンドを指定することによって行われます:

@example
$ git merge-index git-merge-one-file hello
Auto-merging hello
ERROR: Merge conflict in hello
fatal: merge program failed
@end example


@samp{git merge-one-file} スクリプトは、これら3つのバージョンを記述するためのパラメーターを使用して呼び出され、マージ結果を作業ツリーに残す役割を果たします。 これはかなり単純なシェルスクリプトであり、最終的にはRCSスイートから @samp{merge} プログラムを呼び出して、ファイルレベルの3方向マージを実行します。今回は、 @samp{merge} は競合を検出し、競合マークのあるマージ結果が作業ツリーに残ります。これは、この時点で @samp{ls-files --stage} を再度実行すると確認できます:

@example
$ git ls-files --stage
100644 7f8b141b65fdcee47321e399a2598a235a032422 0       example
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1       hello
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2       hello
100644 cc44c73eb783565da5831b4d820c962954019b69 3       hello
@end example


これは、 @samp{git merge} が制御を返した後のインデックスファイルと作業ファイルの状態であり、競合するマージを解決できるようにします。 パス @samp{hello} はまだマージされておらず、この時点で @samp{git diff} で表示されるのは、ステージ2(つまり、あなたのバージョン)との違いであることに注意してください。

@noindent

@chapheading Publishing your work

そういうわけで、私達はリモートリポジトリから他の人の作業を使用することはできますが、他の人がリポジトリからプルできるようにリポジトリを作成するには、あなたはどうすればよいのでしょうか？

あなたのプライマリリポジトリが @samp{.git} サブディレクトリとしてその下にぶら下がっているあなたの作業ツリーで実際の作業を行っています。あなたはそのリポジトリにリモートでアクセスできるようにして、そこからプルするように人々に依頼することも可能ですが、実際には、それは通常の方法ではありません。推奨される方法は、パブリックリポジトリを用意し、他の人がアクセスできるようにすることです。あなたのプライマリ作業ツリーに加えた変更がよい状態になったら、そこからパブリックリポジトリを更新します。これはしばしば「プッシュ」(pushing)と呼ばれます。

@quotation

@strong{Note}

このパブリックリポジトリはさらにミラーリングされる可能性があり、それが @samp{kernel.org} のGitリポジトリの管理方法です。
@end quotation

ローカル(プライベート)リポジトリからリモート(パブリック)リポジトリに変更を公開するには、リモートマシンでの書き込み権限が必要です。単一のコマンド @samp{git-receive-pack} を実行するには、そこにSSHアカウントが必要です。

まず、パブリックリポジトリを格納する空のリポジトリをリモートマシンに作成する必要があります。この空のリポジトリは、後でプッシュすることで、データが設定され、最新の状態に保たれる。明らかに、このリポジトリの作成は1度だけ実行する必要があります。

@quotation

@strong{Note}

@samp{git push} は、ローカルマシンでは @samp{git send-pack} 、リモートマシンでは @samp{git-receive-pack} というコマンドのペアを使用します。ネットワークを介した2つのコマンドの間の通信は、内部でSSH接続を使用します。
@end quotation

あなたのプライベートリポジトリのGitディレクトリは通常 @samp{.git} ですが、パブリックリポジトリはプロジェクト名にちなんで名付けられていることがよくあります。つまり @samp{<project>.git} です。 プロジェクト @samp{my-git} のこのようなパブリックリポジトリを作成しましょう。リモートマシンにログインした後、以下のように空のディレクトリを作成します:

@example
$ mkdir my-git.git
@end example


次に、 @emph{git init} を実行してそのディレクトリをGitリポジトリにしますが、今回はその名前が通常の @samp{.git} ではないため、我々は少し異なる方法で処理します:

@example
$ GIT_DIR=my-git.git git init
@end example


あなたが選択した転送方法(transport)を介して変更をプルする他のユーザーがこのディレクトリを使用できることを確認してください。 また、あなたは @samp{$PATH} 上に @emph{git-receive-pack} プログラムがあることを確認する必要があります。

@quotation

@strong{Note}

sshdの多くのインストールでは、あなたがプログラムを直接実行するときに、ログインシェルとしてあなたのシェルが呼び出されません。これが意味するのは、ログインシェルが @samp{bash} の場合、 @samp{.bashrc} のみが読み取られ、 @samp{.bash_profile} は読み取られないということです。 回避策として、あなたが @samp{git-receive-pack} プログラムを実行できるように、 @samp{.bashrc} で @samp{$PATH} を設定していることを確認してください。
@end quotation

@quotation

@strong{Note}

あなたがこのリポジトリを公開してhttp経由でアクセスする場合は、この時点で @samp{mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update} を実行する必要があります。これにより、このリポジトリにプッシュするたびに、 @samp{git update-server-info} が実行されます。
@end quotation

これで、あなたの「パブリックリポジトリ」であなたの変更を受け入れる準備が整いました。あなたのプライベートリポジトリがあるマシンに戻ってください。 そこから、以下のコマンドを実行します:

@example
$ git push <public-host>:/path/to/my-git.git master
@end example


これにより、あなたのパブリックリポジトリが同期され、指定のブランチヘッド(つまり、この場合は @samp{master})と、あなたの現在のリポジトリ内のそれらから到達可能なオブジェクトが一致します。

実例として、以下は私のパブリックGitリポジトリを更新する方法です。Kernel.orgミラーネットワークは、他の公開されているマシンへの伝播を処理します:

@example
$ git push master.kernel.org:/pub/scm/git/git.git/
@end example


@noindent

@chapheading Packing your repository

以前、私達は作成したGitオブジェクトごとに @samp{.git/objects/??/} ディレクトリの下に1つのファイルが保存されていることを確認しました。この表現は、アトミックかつ安全に作成するには効率的ですが、ネットワークを介した転送にはそれほど便利ではありません。Gitオブジェクトは、作成されると不変であるため、「一緒にパックする」ことでストレージを最適化する方法があります。以下のコマンド

@example
$ git repack
@end example


は、あなたのためにそれをします。チュートリアルの例に従うと、これまでに約17個のオブジェクトが @samp{.git/objects/??/} ディレクトリに蓄積されているはずです。 @samp{git repack} は、パックしたオブジェクトの数を示し、パックされたファイルを @samp{.git/objects/pack} ディレクトリに保存します。

@quotation

@strong{Note}

@samp{.git/objects/pack} ディレクトリに @samp{pack-*.pack} と @samp{pack-*.idx} の2つのファイルがあります。これらは互いに密接に関連しているため、何らかの理由で手動で別のリポジトリにコピーする場合は、必ず一緒にコピーする必要があります。前者はパック内のオブジェクトからのすべてのデータを保持し、後者はランダムアクセスのためのインデックスを保持します。
@end quotation

あなたが病的なほど疑り深い場合は、 @samp{git verify-pack} コマンドを実行すると、破損したパックがあるかどうかが検出されますが、あまり心配する必要はありません。私たちのプログラムは常に完璧です ;-)

オブジェクトをパックしたら、既にパックファイルに取り込まれている、パックされていないオブジェクトを残す必要はありません。

@example
$ git prune-packed
@end example


これは、あなたのためにそれらを削除します。

あなたがもの好きならば、@samp{git prune-packed} を実行する前後に @samp{find .git/objects -type f} を実行してみてください。 また、 @samp{git count-objects} は、リポジトリ内でパックされていないオブジェクト(unpacked objects)の数と、それらが消費しているスペースの量を示します。

@quotation

@strong{Note}

パックされたリポジトリでは比較的大きなパックに含まれるオブジェクトが比較的少ない可能性があるため、HTTP転送(transport)での @samp{git pull} は少々面倒です。パブリックリポジトリから多くのHTTPプルが予想される場合は、頻繁に再パックして整理するか、まったく行わないことをお勧めします。
@end quotation

この時点で再度 @samp{git repack} を実行すると、「Nothing new to pack.」(新しくパックするものはありません)と表示されます。あなたが開発を続行して変更を蓄積してから、 @samp{git repack} を再度実行すると、前回リポジトリをパックして以降に作成されたオブジェクトを含む新しいパックが作成されます。最初のインポートの直後にプロジェクトをパックし(プロジェクトを最初から開始する場合を除く)、プロジェクトの活発度度に応じて、時々 @samp{git repack} を実行することをお勧めします。

リポジトリが @samp{git push} と @samp{git pull} を介して同期される場合、転送元リポジトリにてパックされてたオブジェクトは通常、転送先ではアンパックされて保存されます。これにより、転送元と転送先で異なるパッキング戦略を使用できますが、両方のリポジトリを時々再パックする必要がある場合もあります。

@noindent

@chapheading Working with Others

Gitは真に分散されたシステムですが、多くの場合、開発者の非公式な階層でプロジェクト編成すると便利です。Linuxカーネル開発はこの方法で実行されます。 @uref{https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf,Randy Dunlap’s presentation} の (17ページ "Merges to Mainline") にイラストがあります。

この階層は純粋に「非公式」であることを強調しておく必要があります。この階層が意味する「パッチフローのチェーン」を強制するようなGitでの必須のものは何もありません。あなたはただ1つのリモートリポジトリからプルする必要はありません。

「プロジェクト指揮」(project lead)の推奨作業フローは以下のようになります:

@enumerate 

@item
あなたのローカルマシンで、あなたのプライマリリポジトリを準備します。あなたの作業はそこで行います。

@item
他の人がアクセスできる公開リポジトリを準備します。

他の人がバカ転送プロトコル(dumb transport protocols)(HTTP)を介してリポジトリからプルしている場合、このリポジトリを「バカ転送フレンドリー」(dumb transport friendly)に保つ必要があります。 @samp{git init} 後、標準テンプレートからコピーした @samp{$GIT_DIR/hooks/post-update.sample} には、 @samp{git update-server-info} の呼び出しが含まれますが、あなたは @samp{mv post-update.sample post-update} を使用してフックを手動で有効にする必要があります。これにより、 @samp{git update-server-info} が必要なファイルを最新の状態に保つことができます。

@item
あなたのプライマリリポジトリから公開リポジトリにプッシュします。

@item
公開リポジトリを @samp{git repack} します。これにより、オブジェクトの初期セットをベースラインとして含む大きなパックが確立されます。リポジトリからのプルに使用される転送方法(transport)がパックされたリポジトリ(packed repositories)をサポートしている場合は、 @samp{git prune} が使える可能性があります。

@item
あなたはプライマリリポジトリで作業を続けます。あなたの変更は、あなた独自の変更や、電子メールで受信するパッチや、「サブシステム保守者」の「公開」リポジトリをプルした結果のマージを含んでいます。

あなたはこのプライベートリポジトリはいつでも再パックできます。

@item
あなたの変更を公開リポジトリにプッシュし、公開します。

@item
時々、公開リポジトリを @samp{git repack} します。 手順5に戻り、作業を続行します。
@end enumerate

そのプロジェクトに取り組んでいて、独自の「公開リポジトリ」を持つ「サブシステム保守者」に推奨される作業サイクルは以下のようになります:

@enumerate 

@item
「プロジェクト指揮」の公開リポジトリ上で @samp{git clone} を実行して、あなたの作業リポジトリを準備します。初期クローン作成に使用されるURLは、 remote.origin.url 構成変数に格納されます。

@item
「プロジェクト指揮」の人と同じように、他の人がアクセスできる公開リポジトリを準備します。

@item
「プロジェクト指揮」リポジトリが同じマシン上にある場合を除き、パックされたファイルを「プロジェク指揮」の公開リポジトリからあなたの公開リポジトリにコピーします。後者の場合、あなたは @samp{objects/info/alternates} ファイルを使用して、借用しているリポジトリを指すことができます。

@item
あなたのプライマリリポジトリから公開リポジトリにプッシュします。@samp{git repack} を実行し、そして、リポジトリからのプルに使用される転送方法(transport)がパックされたリポジトリ(packed repositories)をサポートしている場合は @samp{git prune} を実行します。

@item
あなたのプライマリリポジトリで作業を続けます。あなたの変更には、あなた独自の変更や、電子メールで受信するパッチや、「プロジェクト指揮」と場合によっては「サブサブシステム保守者」の「公開」リポジトリをプルした結果のマージが含まれます。

あなたはこのプライベートリポジトリはいつでも再パックできます。

@item
あなたの変更をあなたの公開リポジトリにプッシュし、「プロジェクト指揮」と、場合によっては「サブサブシステム保守者」にプルするように依頼します。

@item
時々、公開リポジトリを @samp{git repack} します。 手順5に戻り、作業を続行します。
@end enumerate

「公開」リポジトリを持たない「個人開発者」に推奨される作業サイクルは多少異なります。以下のようになります:

@enumerate 

@item
「プロジェクト指揮」(またはサブシステムで作業している場合は「サブシステム保守者」)の公開リポジトリを @samp{git clone} して、あなたの作業リポジトリを準備します。初期クローン作成に使用されるURLは、 remote.origin.url 構成変数に格納されます。

@item
あなたは、あなたのリポジトリの @emph{master} ブランチで作業を行います。

@item
時々、あなたのアップストリームの公開リポジトリから @samp{git fetcho rigin} を実行します。これは @samp{git pull} の前半のみを実行しますが、マージはしません。公開リポジトリのヘッドは @samp{.git/refs/remotes/origin/master} に保存されています。

@item
@samp{git cherry origin} を使用して、どのパッチが受け入れられたかを確認したり、 @samp{git rebase origin} を使用して、あなたのマージされていない変更を更新されたアップストリームに転送します。

@item
@samp{git format-patch origin} を使用して、アップストリームへの電子メール送信用のパッチを準備し、送信します。 手順2に戻り、作業を続行します。
@end enumerate

@noindent

@chapheading Working with Others, Shared Repository Style

あなたがCVS界隈から来ていたら、前のセクションで提案された協力のスタイルはあなたにとって新しいものかもしれません。でも心配する必要はありません。 Gitは、おそらくあなたもよく知っている「共有公開リポジトリ」(shared public repository)スタイルの協同作業をサポートしています。

詳細については gitcvs-migration(7) を参照してください。

@noindent

@chapheading Bundling your work together

あなたは一度に複数のことに取り組む可能性があります。Gitでブランチを使用すると、これらの多かれ少なかれ独立したタスクを簡単に管理できます。

私達は2つのブランチを使用した「fun and work」の例で、ブランチがどのように機能するかはすでに見てきました。ブランチが3つ以上ある場合も、考え方は同じです。 @samp{master} ヘッドから始めて、 @samp{master} ブランチにいくつかの新しいコードがあり、 @samp{commit-fix} ブランチと @samp{diff-fix} ブランチに2つの独立した修正があるとします:

@example
$ git show-branch
! [commit-fix] Fix commit message normalization.
 ! [diff-fix] Fix rename detection.
  * [master] Release candidate #1
---
 +  [diff-fix] Fix rename detection.
 +  [diff-fix~1] Better common substring algorithm.
+   [commit-fix] Fix commit message normalization.
  * [master] Release candidate #1
++* [diff-fix~2] Pretty-print messages.
@end example


両方の修正は十分にテストされており、この時点で、両方をマージする必要があります。あなたは以下のように、最初に @samp{diff-fix} でマージし、次に @samp{commit-fix} でマージする事ができます:

@example
$ git merge -m "Merge fix in diff-fix" diff-fix
$ git merge -m "Merge fix in commit-fix" commit-fix
@end example


この結果は以下のようになります:

@example
$ git show-branch
! [commit-fix] Fix commit message normalization.
 ! [diff-fix] Fix rename detection.
  * [master] Merge fix in commit-fix
---
  - [master] Merge fix in commit-fix
+ * [commit-fix] Fix commit message normalization.
  - [master~1] Merge fix in diff-fix
 +* [diff-fix] Fix rename detection.
 +* [diff-fix~1] Better common substring algorithm.
  * [master~2] Release candidate #1
++* [master~3] Pretty-print messages.
@end example


しかしながら、あなたが持っているものが真に独立した変更のセットである場合、最初に一方のブランチにマージし、次にもう一方のブランチにマージする特別な理由はありません(もし順序が重要な場合は、それらは定義上独立しているとは言えません)。代わりに、これら2つのブランチを現在のブランチに一度にマージすることができます。まずは、今行ったことを元に戻して、最初からやり直しましょう。 @samp{master~2} にリセットすることにより、これら2つのマージの前のmasterブランチを取得する必要があります:

@example
$ git reset --hard master~2
@end example


@samp{git show-branch} すれば、先ほど行った2つの @samp{git merge} の前の状態と一致することを確認できます。 次に、2つの @samp{git merge} コマンドを連続して実行する代わりに、これら2つのブランチヘッドをマージします(これは「making an Octopus」(タコ足メイク)として知られています):

@example
$ git merge commit-fix diff-fix
$ git show-branch
! [commit-fix] Fix commit message normalization.
 ! [diff-fix] Fix rename detection.
  * [master] Octopus merge of branches 'diff-fix' and 'commit-fix'
---
  - [master] Octopus merge of branches 'diff-fix' and 'commit-fix'
+ * [commit-fix] Fix commit message normalization.
 +* [diff-fix] Fix rename detection.
 +* [diff-fix~1] Better common substring algorithm.
  * [master~1] Release candidate #1
++* [master~2] Pretty-print messages.
@end example


注意: 可能であるからいって必ずしもタコ足(octopus)をやるべきではない、ということに注意してください。タコ足(octopus)は有効な方法であり、2つ以上の独立した変更を同時にマージする場合、コミット履歴を簡単に表示できることがよくあります。しかし、マージしているブランチのいずれかとマージの競合があり、手動で解決する必要がある場合は、これは、これらのブランチで発生した開発が結局独立していないことを示しています。そうすると、あなたは、どうして一度に2つをマージして、競合をどのように解決したか、および一方の側で行われた変更をもう一方の側よりも優先した理由を文書化しなければならなくなります。そうしないと、プロジェクトの履歴を追跡するのが難しくなり、簡単ではなくなります。

@noindent

@chapheading SEE ALSO

gittutorial(7), gittutorial-2(7), gitcvs-migration(7), git-help(1), giteveryday(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitcredentials,,,Top
@chapheading Name

gitcredentials — Gitにユーザー名とパスワードを提供する

@noindent

@chapheading Synopsis

@example
git config credential.https://example.com.username myusername
git config credential.helper "$helper $options"
@end example


@noindent

@chapheading DESCRIPTION

Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. Some remotes accept a personal access token or OAuth access token as a password. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.

@noindent

@chapheading REQUESTING CREDENTIALS

資格情報ヘルパーが定義されていない場合、Gitは以下の戦略でユーザーにユーザー名とパスワードを要求します:

@enumerate 

@item
@samp{GIT_ASKPASS} 環境変数が設定されている場合、その環境変数で指定したプログラムが呼び出されます。コマンドラインでプログラムによって適切なプロンプトが表示され、ユーザーの入力が標準出力から読み取られます。

@item
それ以外の場合、 @samp{core.askPass} 構成変数が設定されていると、その値は上記と同様に使用されます。

@item
それ以外の場合、@samp{SSH_ASKPASS} 環境変数が設定されていると、その値は上記と同様に使用されます。

@item
それ以外の場合、端末でユーザーの入力が促されます。
@end enumerate

@noindent

@chapheading AVOIDING REPETITION

同じ資格情報を何度も入力するのは面倒な場合があります。 Gitには、この煩わしさを軽減する2つの方法があります:

@enumerate 

@item
指定の認証コンテキストのためのユーザー名の静的構成。

@item
パスワードをキャッシュまたは保存するため、またはシステムパスワードウォレットまたはキーチェーンと対話するための資格情報ヘルパー。
@end enumerate

1つ目は、パスワードに使用できる安全なストレージがない場合に簡単で適切です。これは通常、以下を構成に追加することによって設定します:

@example
[credential "https://example.com"]
        username = me
@end example


Credential helpers, on the other hand, are external programs from which Git can request both usernames and passwords; they typically interface with secure storage provided by the OS or other programs. Alternatively, a credential-generating helper might generate credentials for certain servers via some API.

ヘルパーを使用するには、最初に使用するヘルパーを選択する必要があります。Gitには現在、以下のヘルパーが含まれています:

@table @asis

@item  cache 
資格情報をメモリに短期間キャッシュします。 詳細については git-credential-cache(1) を参照してください。

@item  store 
資格情報をディスクに無期限に保存します。詳細については git-credential-store(1) を参照してください。
@end table

サードパーティのヘルパーがインストールされている場合もあります。 @samp{git help -a} の出力で @samp{credential-*} を検索し、個々のヘルパーのドキュメントを参照してください。あなたが使いたいヘルパーを選んだら、その名前を credential.helper 変数に入力することで、Gitにそのヘルパーを使用するように指示できます。

@enumerate 

@item
ヘルパーを探す。

@example
$ git help -a | grep credential-
credential-foo
@end example


@item
その説明を読む。

@example
$ git help credential-foo
@end example


@item
Gitにそれを使用するように伝えます。

@example
$ git config --global credential.helper foo
@end example

@end enumerate

@noindent

@chapheading CREDENTIAL CONTEXTS

Gitは、各資格情報がURLによって定義されたコンテキストを持っていると見なします。このコンテキストは、コンテキスト固有の構成を検索するために使用され、すべてのヘルパーに渡されます。ヘルパーは、これを安全なストレージへのインデックスとして使用できます。

たとえば、 @samp{https://example.com/foo.git} にアクセスしていると想像してください。Gitが構成ファイルを調べてセクションがこのコンテキストに一致するかどうかを確認するとき、コンテキストが構成ファイル内のパターンのより具体的なサブセットである場合、Gitは2つが一致すると見なします。たとえば、設定ファイルに以下がある場合:

@example
[credential "https://example.com"]
        username = foo
@end example


これはマッチします。両方のプロトコルが同じで、かつ、両方のホストが同じであり、かつ、パターンURLはパス部分を気にしないからです。ただし、以下のコンテキストは一致しません:

@example
[credential "https://kernel.org"]
        username = foo
@end example


なぜならホスト名が異なるためです。 また、 @samp{foo.example.com} とは一致しません。 Gitは、2つのホストが同じドメインの一部であるかどうかを考慮せずに、ホスト名を正確に比較します。 同様に、 @samp{http://example.com} の設定エントリは一致しません。Gitはプロトコルを正確に比較します。 ただし、 @samp{http.<URL>.*} オプションと同様に、ドメイン名やその他のパターンマッチングにワイルドカードを使用できます。

パターンURLにパス部分が含まれている場合、これも完全に一致する必要があります。コンテキスト @samp{https://example.com/bar/baz.git} は(@samp{https://example.com} 部分の照合に加えてパス部分も一致する) @samp{https://example.com/bar/baz.git} の設定エントリとは一致しますが、 @samp{https://example.com/bar} 構成エントリとは一致しません。

@noindent

@chapheading CONFIGURATION OPTIONS

コンテキストのオプションは、 @samp{credential.*} (すべての資格情報に適用) または @samp{credential.<URL>.*} のいずれかで構成できます。ここで、 <URL> は上記のコンテキストと一致します。

以下のオプションは、どちらの場所でも使用できます:

@table @asis

@item  helper 
外部資格情報ヘルパーの名前、および関連するオプション。ヘルパー名が絶対パスでない場合は、文字列 @samp{git credential-} が先頭に追加されます。結果の文字列はシェルによって実行されます(たとえば、これを @samp{foo --option=bar} に設定すると、シェルを介して @samp{git credential-foo --option=bar} が実行されます。例については使用するヘルパーのマニュアルを参照してください。

If there are multiple instances of the @samp{credential.helper} configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a non-expired password, no more helpers will be tried.

@samp{credential.helper} が空の文字列に設定されている場合、これによりヘルパーリストが空にリセットされます(したがって、空の文字列ヘルパーを構成し、その後に必要なヘルパーのセットを構成することで、優先度の低い構成ファイルによって設定されたヘルパーをオーバーライドできます)。

@item  username 
URLに指定されていない場合のデフォルトのユーザー名。

@item  useHttpPath 
デフォルトでは、Gitはhttp URLのパス部分を外部ヘルパーを介して照合する価値があるとは見なしません。 これは、 @samp{https://example.com/foo.git} に保存されている資格情報が @samp{https://example.com/bar.git} にも使用されることを意味します。これらの場合を区別したい場合は、このオプションを「true」に設定してください。
@end table

@noindent

@chapheading CUSTOM HELPERS

あなた独自のカスタムヘルパーを作成して、資格情報を保持している任意のシステムとインターフェイスすることができます。

資格情報ヘルパーは、資格情報を長期ストレージとの間でフェッチまたは保存するためにGitによって実行されるプログラムです(「長期」とは単一のGitプロセスよりも単純に長いという意味です。たとえば、資格情報はメモリ内に数分間、またはディスク上で無期限に保存される場合があります)。

各ヘルパーは、構成変数 @samp{credential.helper} の単一の文字列で指定されます(その他 git-config(1) を参照)。文字列はGitによって、以下のルールを使用して実行されるコマンドに変換されます:

@enumerate 

@item
ヘルパー文字列が "!" で始まる場合、それはシェルスニペットと見なされ、 "!" の後のすべてが コマンドになります。

@item
それ以外の場合、ヘルパー文字列が絶対パスで始まる場合は、文字列がそのままコマンドとして扱われます。

@item
それ以外の場合は、文字列 "git credential-" がヘルパー文字列の前に付加され、その結果がコマンドになります。
@end enumerate

結果のコマンドには「operation」引数が追加され(詳細は下記参照)、結果はシェルによって実行されます。

仕様の例を以下に示します:

@example
# run "git credential-foo"
[credential]
        helper = foo

# same as above, but pass an argument to the helper
[credential]
        helper = "foo --bar=baz"

# the arguments are parsed by the shell, so use shell
# quoting if necessary
[credential]
        helper = "foo --bar='whitespace arg'"

# you can also use an absolute path, which will not use the git wrapper
[credential]
        helper = "/path/to/my/helper --with-arguments"

# or you can specify your own shell snippet
[credential "https://example.com"]
        username = your_user
        helper = "!f() @{ test \"$1\" = get && echo \"password=$(cat $HOME/.secret)\"; @}; f"
@end example


一般的に、上記の ルール(3）は、ユーザーが指定するのが最も簡単です。資格情報ヘルパーの作成者は、プログラムに "git-credential-$NAME" という名前を付け、インストール中に @samp{$PATH} または @samp{$GIT_EXEC_PATH} に配置して、ユーザーが @samp{git config credential.helper $NAME} を有効にできるようにすることで、ユーザーを支援するように努める必要があります。

ヘルパーが実行されると、コマンドラインに以下のいずれかの「操作」引数が追加されます:

@table @asis

@item  @samp{get} 
一致する資格情報が存在する場合は、それを返します。

@item  @samp{store} 
ヘルパーに該当する場合は、資格情報を保存します。

@item  @samp{erase} 
Remove matching credentials, if any, from the helper’s storage.
@end table

資格情報の詳細は、ヘルパーの標準入力ストリームで提供されます。正確な形式は、 @samp{git credential} 配管コマンドの 入力/出力形式 と同じです(詳細な仕様については、 git-credential(1) の「INPUT/OUTPUT FORMAT」のセクションを参照してください)。

For a @samp{get} operation, the helper should produce a list of attributes on stdout in the same format (see git-credential(1) for common attributes). A helper is free to produce a subset, or even no values at all if it has nothing useful to provide. Any provided attributes will overwrite those already known about by Git’s credential subsystem. Unrecognised attributes are silently discarded.

すべての属性を上書きすることが可能ですが、正常に動作するヘルパーは、ユーザー名とパスワード以外の属性については上書きしないようにする必要があります。

ヘルパーが @samp{true} または @samp{1} の値で @samp{quit} 属性を出力した場合、それ以上のヘルパーは参照されず、ユーザーにプロンプトも表示されません(資格情報が提供されていない場合、操作は失敗します)。

同様に、ユーザー名とパスワードの両方が提供されると、ヘルパーに相談することはありません。

@samp{store} または @samp{erase} 操作の場合、ヘルパーの出力は無視されます。

ヘルパーが要求された操作の実行に失敗した場合、または潜在的な問題をユーザーに通知する必要がある場合、ヘルパーは標準エラー出力に書き込むことがあります。

If it does not support the requested operation (e.g., a read-only store or generator), it should silently ignore the request.

ヘルパーが他の操作を受け取った場合、ヘルパーはその要求を黙って無視する必要があります。これにより、将来の操作を追加する余地が残ります(古いヘルパーは新しい要求を無視するだけです)。

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitcvs-migration,,,Top
@chapheading Name

gitcvs-migration — CVSユーザー向けGit

@noindent

@chapheading Synopsis

@display
git cvsimport *
@end display


@noindent

@chapheading DESCRIPTION

GitはCVSとは異なり、すべての作業ツリーにはプロジェクト履歴の完全なコピーを含むリポジトリが含まれており、他のどのリポジトリよりも決定的に重要であるリポジトリなどというものはありません。ただし、あなたはユーザーが同期できる単一の共有リポジトリを指定することで、CVSモデルをエミュレートできます。このドキュメントでは、その方法について説明します。

Gitに関する基本的な知識が必要ですが、 gittutorial(7) と gitglossary(7) を理解しておけば十分です。

@noindent

@chapheading 共有リポジトリに対面する開発

ホスト foo.com の /pub/repo.git に共有リポジトリが設定されているとします。次に、個々のコミッターは、以下コマンドを使用してssh経由で共有リポジトリのクローンを作成できます:

@example
$ git clone foo.com:/pub/repo.git/ my-project
$ cd my-project
@end example


そしてハックハックします。 @samp{cvs update} に相当するものは以下です

@example
$ git pull origin
@end example


これは、クローン操作以降に他の人が行った可能性のあるすべての作業をマージします。作業ツリーにコミットされていない変更がある場合は、まずは @samp{git pull} を実行する前にコミットしてください。

@quotation

@strong{Note}

@samp{pull} コマンドは、最初の @samp{git clone} コマンドによって設定された構成変数によって、更新をどこから取得するかを認識しています。詳細については、 @samp{git config -l} および git-config(1) のマニュアルページを参照してください。
@end quotation

まずあなたの変更をコミットしてから、その後 @samp{git push} コマンドを使用することで、あなたの変更を採用して共有リポジトリを更新できます:

@example
$ git push origin master
@end example


それらのコミットを共有リポジトリに「プッシュ」します。他の誰かが最近リポジトリを更新した場合、「cvs commit」のように「git push」が文句を言います。その場合、プッシュを再試行する前に変更をプルする必要があります。

上記の @samp{git push} コマンドで、更新するリモートブランチの名前(@samp{master})を指定します。これを省略した場合、 @samp{git push} は、ローカルリポジトリ内のブランチと同じ名前を持つリモートリポジトリ内のブランチを更新しようとします。したがって、最後の「プッシュ」は以下のいずれかで実行できます:

@example
$ git push origin
$ git push foo.com:/pub/project.git/
@end example


上記は共有リポジトリに @samp{master} 以外のブランチがない限りは動作します。

@noindent

@chapheading Setting Up a Shared Repository

私達は、プロジェクトのGitリポジトリをすでに作成しているか、または最初からまたはtarballから作成したか(gittutorial(7) を参照)、または既存のCVSリポジトリからインポートした(次のセクションを参照)と想定しします。

あなたの既存のリポジトリが /home/alice/myproject にあると想定します。新しい「ベア」リポジトリ(作業ツリーのないリポジトリ)を作成し、あなたのプロジェクトをそのリポジトリにフェッチします:

@example
$ mkdir /pub/my-repo.git
$ cd /pub/my-repo.git
$ git --bare init --shared
$ git --bare fetch /home/alice/myproject master:master
@end example


次に、すべてのチームメンバーにこのリポジトリへの読み取り/書き込みアクセスを許可します。これを行う簡単な方法の1つは、すべてのチームメンバーにリポジトリがホストされているマシンへのsshアクセスを許可することです。マシン上で完全なシェルを提供したくない場合は、ユーザーがGitのプッシュとプルのみを実行できる制限付きシェルがあります。 git-shell(1) を参照してください。

コミッター全員を同じグループに入れ、リポジトリをそのグループで書き込み可能にします:

@example
$ chgrp -R $group /pub/my-repo.git
@end example


コミッターが作成するディレクトリが他のグループメンバーによって書き込みおよび検索できるように、コミッターのumaskが027であることを確認してください。

@noindent

@chapheading Importing a CVS archive

@quotation

@strong{Note}

これらの手順では、gitに付属している @samp{git-cvsimport} スクリプトを使用しますが、他のインポーターがより良い結果を提供する場合があります。他のオプションについては、 git-cvsimport(1) のthe noteを参照してください。
@end quotation

まず、 @uref{https://github.com/andreyvit/cvsps,https://github.com/andreyvit/cvsps} からバージョン2.1以降のcvspsをインストールし、あなたの $PATH に含まれていることを確認します。次に、あなたが関心を持っているプロジェクトのチェックアウトされたCVS作業ディレクトリにcdして、 git-cvsimport(1) を実行します:

@example
$ git cvsimport -C <destination> <module>
@end example


これにより、指定されたCVSモジュールのGitアーカイブがディレクトリ <destination> に必要に応じて作成され、配置されます。

インポートは、すべてのファイルのすべてのリビジョンをCVSからチェックアウトします。聞いた限りでは、cvsimportは1秒あたり平均約20個のリビジョンを処理できるので、中規模のプロジェクトの場合、これには数分以上かかることはありません。大規模なプロジェクトやリモートリポジトリには時間がかかる場合があります。

メインtrunkは @samp{origin} という名前のGitブランチに保存され、追加のCVSブランチは同じ名前のGitブランチに保存されます。メインtrunkの最新バージョンも `master`ブランチにチェックアウトされたままなので、すぐにあなた独自の変更を追加し始めることができます。

インポートはインクリメンタルであるため、来月再度呼び出すと、その間に行われたCVS更新がフェッチされます。これが機能するためには、インポートされたブランチを変更してはなりません。代わりに、独自の変更のために新しいブランチを作成し、必要に応じてインポートされたブランチをマージします。

あなたが共有リポジトリが必要な場合は、上記のように、あなたはインポートされたディレクトリのベアクローンを作成する必要があります。次に、増分インポートをマージするために、インポートされたディレクトリを別の開発クローンとして扱います。

@noindent

@chapheading Advanced Shared Repository Management

Gitでは、特定の箇所で実行される「フック」(hooks)と呼ばれるスクリプトを指定できます。これらを使用して、たとえば、共有リポジトリへのすべてのコミットをメーリングリストに送信することができます。 githooks(5) を参照してください。

更新フックを使用して、よりきめ細かいアクセス許可を適用できます。 @uref{howto/update-hook-example.html,Controlling access to branches using update hooks} (更新フックを使用したブランチへのアクセスの制御) を参照してください。

@noindent

@chapheading Providing CVS Access to a Git Repository

開発者が引き続きCVSを使用できるように、Gitリポジトリへの真のCVSアクセスを提供することも可能です。詳細については、 git-cvsserver(1) を参照してください。

@noindent

@chapheading Alternative Development Models

CVSユーザーは、開発者のグループに共通のリポジトリへのコミットアクセスを与えることに慣れています。これまで見てきたように、これはGitでも可能です。ただし、Gitの分散性により、他の開発モデルが利用可能になるため、最初に、そのうちのどれがプロジェクトにより適しているかどうかを検討することをお勧めします。

たとえば、プロジェクトのプライマリ公開リポジトリを保守するために1人の人を選択できます。次に、他の開発者がこのリポジトリのクローンを作成し、それぞれが独自のクローンで作業します。満足のいく一連の変更がある場合、変更を含むブランチからプルするように保守者に依頼します。保守者は変更を確認し、プライマリリポジトリにプルします。プライマリリポジトリは、他の開発者が調整を維持するために必要に応じてプルします。 Linuxカーネルおよびその他のプロジェクトは、このモデルのバリエーションを使用します。

少人数のグループでは、開発者は中央の保守者を必要とせずに、互いのリポジトリから変更をプルするだけで済みます。

@noindent

@chapheading SEE ALSO

gittutorial(7), gittutorial-2(7), gitcore-tutorial(7), gitglossary(7), giteveryday(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitdiffcore,,,Top
@chapheading Name

gitdiffcore — diff出力の微調整

@noindent

@chapheading Synopsis

@display
git diff *
@end display


@noindent

@chapheading DESCRIPTION

diffコマンド @samp{gitdiff-index} と @samp{git diff-files} と @samp{git diff-tree} は、 @samp{diff} 出力を表示する前に、従来とは異なる方法で検出した差異を操作するように指示できます。この操作を総称して「diffcore変換」(diffcore transformation)と呼びます。この短いノートでは、それらが何であるか、およびそれらを使用して、従来の種類よりも理解しやすい @samp{diff} 出力を生成する方法について説明します。

@noindent

@chapheading The chain of operation

@samp{git diff-@{asterisk@}} ファミリの仕事は、まずは2つのファイルセットを比較することです:

@itemize 

@item
@samp{git diff-index} は、 (@samp{--cached} フラグが使用されていない場合)ツリーオブジェクトと作業ディレクトリの内容を比較するか、または(` --cached` フラグが使用されている場合)ツリーオブジェクトとインデックスファイルの内容を比較します。

@item
@samp{git diff-files} は、インデックスファイルと作業ディレクトリの内容を比較します。

@item
@samp{git diff-tree} は、2つのツリーオブジェクトの内容を比較します。
@end itemize

これらすべての場合において、コマンド自体は、最初にオプションで、コマンドラインで指定されたパススペックによって2つのファイルの組を限定し、結果として得られる2つのファイルの組の対応するパスを比較します。

パススペックは、diffが動作するワールドを制限するために使用されます。これらは、指定されたパス名の組の外側にあるファイルペア(filepairs)を削除します。例えば。ファイルペアの入力組が含まれている場合:

@example
:100644 100644 bcd1234... 0123456... M junkfile
@end example


しかし、コマンドの呼び出しが @samp{git diff-files myfile} の場合、 @samp{myfile} のみが考慮されているため、junkfileエントリがリストから削除されます。

比較の結果は、これらのコマンドから、 `-p｀ オプションが使用されていない場合に出力されるものと同様の形式で、内部的に「diffcore」と呼ばれるものに渡されます。例えば

@example
in-place edit  :100644 100644 bcd1234... 0123456... M file0
create         :000000 100644 0000000... 1234567... A file4
delete         :100644 000000 1234567... 0000000... D file5
unmerged       :000000 000000 0000000... 0000000... U file6
@end example


diffcoreメカニズムには、そのような比較結果のリストが提供され(それぞれが「ファイルペア」(filepair)と呼ばれますが、この時点ではそれぞれ1つのファイルについて話します)、そのようなリストを別のリストに変換します。現在、そのような変換(transformations)は5つあります:

@itemize 

@item
diffcore-break

@item
diffcore-rename

@item
diffcore-merge-broken

@item
diffcore-pickaxe

@item
diffcore-order

@item
diffcore-rotate
@end itemize

これらは順番に適用されます。 @samp{git diff-@{asterisk@}} コマンド群の探索のファイルペアのセットは、diffcore-breakへの入力として使用されます。diffcore-breakからの出力は、次の変換への入力として使用されます。そして、最終結果が出力ルーチンに渡され、diff-raw形式(マニュアルの @samp{git diff-@{asterisk@}} コマンド の「Output format」セクションを参照)またはdiff-patch形式のいずれかが生成されます。

@noindent

@chapheading diffcore-break: 完全な書き換えを分割するため

操作チェーンの2番目の変換(transformation)はdiffcore-breakで、 @samp{git diff-@{asterisk@}} コマンド群の @samp{-B} オプションによって制御されます。これは、「完全な書き換え」を表すファイルペアを検出し、そして、そのようなファイルペアを削除と作成を表す2つのファイルペアに分割するために使用されます。例えば、入力に以下のファイルペアが含まれている場合:

@example
:100644 100644 bcd1234... 0123456... M file0
@end example


そして、ファイル "file0" が完全に書き換えられたことを検出すると、以下のように変更されます:

@example
:100644 000000 bcd1234... 0000000... D file0
:000000 100644 0000000... 0123456... A file0
@end example


ファイルペアを切断する(break)目的で、diffcore-breakは、変更前後のファイルの内容(つまり、上記の例では、SHA-1コンテンツIDとして @samp{bcd1234...} と @samp{0123456...} を持つコンテンツ)の間の変更の程度を調べます。元のコンテンツの削除と新しい素材の挿入の量が合計され、「ブレークスコア」(break score)を超えると、ファイルペアが2つに分割されます。ブレークスコアのデフォルトは、元のサイズと結果の小さい方のサイズの50%であり(つまり、編集によってファイルが縮小される場合は、結果のサイズが使用されます。編集によってファイルが長くなる場合は、元のサイズが使用されます)、 @samp{-B} オプションの後に数字を付けることでカスタマイズできます(たとえば、 @samp{-B75} で75%にするように指示します)。

@noindent

@chapheading diffcore-rename: 名前変更とコピーを検出するため

この変換(transformation)は、名前変更とコピーを検出するために使用され、 @samp{git diff-@{asterisk@}} コマンド群の @samp{-M} オプション(名前変更検出用）と @samp{-C} オプション(コピーも検出するため)によって制御されます。入力にこれらのファイルペアが含まれている場合:

@example
:100644 000000 0123456... 0000000... D fileX
:000000 100644 0000000... 0123456... A file0
@end example


ここで、削除されたファイルfileXの内容は、作成されたファイルfile0の内容と十分に類似しているため、名前変更検出はこれらのファイルペアをマージして以下を作成します:

@example
:100644 100644 0123456... 0123456... R100 fileX file0
@end example


@samp{-C} オプションを使用すると、変更されたファイルと削除されたファイル( @samp{--find-copies-harder} オプションが使用されている場合は、変更されていないファイルも)の元の内容が、名前変更/コピー 操作のソースファイルの候補と見なされます。入力がこれらのファイルペアのようなものである場合、変更されたファイルfileYと新しく作成されたファイルfile0について以下のようになります:

@example
:100644 100644 0123456... 1234567... M fileY
:000000 100644 0000000... bcd3456... A file0
@end example


fileYの元の内容とfile0の結果の内容が比較され、それらが十分に類似している場合は、以下のように変更されます:

@example
:100644 100644 0123456... 1234567... M fileY
:100644 100644 0123456... bcd3456... C100 fileY file0
@end example


名前の変更とコピーの検出の両方で、diffcore-breakで使用されるのと同じ「変更の範囲」(extent of changes)アルゴリズムを使用して、2つのファイルが「十分に類似」しているかどうかを判断し、デフォルトの50%とは異なる類似スコアを使用するようにカスタマイズできます。 @samp{-M} または @samp{-C} オプションの後に番号を付けます(たとえば、 @samp{-M8} で 8/10 = 80% にするように指示します)。

注意: 名前変更検出がオンで、コピーとブレークの両方の検出がオフの場合、名前変更検出は、ファイル名を同じに保ちながらファイルがディレクトリ間で移動されるかどうかを最初にチェックする予備ステップを追加することに注意してください。 別のディレクトリから削除された同じ名前のファイルと内容が十分に類似しているファイルがディレクトリに追加されている場合、それらを名前変更としてマークし、後の2次ステップ(一致しないすべてのファイルをペアごとに比較して、コンテンツの類似性が最も高いことによって決定される「最良の」一致を見つけるステップ)から除外します。したがって、たとえば、削除された docs/ext.txt と追加された docs/config/ext.txt が十分に類似している場合、それらは名前変更としてマークされ、削除された docs/ext.txt にさらに類似している可能性のある、追加された docs/ext.md が後のステップで名前変更先と見なされないようにします。 このため、予備の「同じファイル名に一致」ステップでは、少し高いしきい値を使用してファイルペアを名前変更としてマークし、他の候補をより適切に一致させることを検討しなくなります。 この予備ステップでは、ファイルごとに最大で1つの比較が行われます。したがって、正確な名前変更が検出された後、ディレクトリ階層全体にext.txtファイルがいくつか残っている場合は、これらのファイルのこの準備手順をスキップできます。

注意: @samp{-C} オプションを @samp{--find-copies-harder} オプションとともに使用すると、 @samp{git diff-@{asterisk@}} コマンド群は、変更されていないファイルペアと変更されたファイルペアをdiffcoreメカニズムに送ります。これにより、コピー検出器は、ファイルの速度を低下させる代わりに、変更されていないファイルをコピーソース候補と見なすことができます。 @samp{--find-copies-harder} がないと、 @samp{git diff-@{asterisk@}} コマンド群は、コピーされたファイルがたまたま同じチェンジセットで変更された場合にのみコピーを検出できます。

@noindent

@chapheading diffcore-merge-broken: 完全な書き換えを元に戻すため

この変換は、diffcore-breakによって分割したファイルペアをマージするために使用され、 diffcore-rename によって rename/copy に変換されず、単一の変更に戻されます。これは、diffcore-breakが使用されている場合は常に実行されます。

分割したファイルペアをマージする目的で、 diffcore-break および diffcore-rename で使用されるものとは異なる「変更の範囲」の計算を使用します。オリジナルからの削除のみをカウントし、挿入はカウントしません。100行のドキュメントから10行だけを削除した場合、新しい1000行のドキュメントを作成するために910行を追加しても、完全な書き換えは行われたとは見なしません。 diffcore-break は、 diffcore-renameがそのようなファイルペアを 名前変更/コピー 検出の候補と見なすのを助けるためにそのような場合のを分割しますが、その方法で分割したファイルペアが他のファイルペアと一致して 名前変更/コピー を作成しなかった場合、この変換でそれらをマージして「元の変更」に戻します 。

「変更の範囲」パラメータは、 @samp{-B} に2番目の数値を指定することで、デフォルトの80%から微調整できます(つまり、元のマテリアルの80%以上が削除されない限り、分割されたペアは1つの変更にマージされます)。以下のように指定できます:

@itemize 

@item
@samp{-B50/60} (diffcore-breakに50%の「ブレークスコア」を与え、diffcore-merge-brokenに60%を与えます)。

@item
@samp{-B/60} (上記と同じです。diffcore-breakのデフォルトは50%であるため)。
@end itemize

注意:以前の実装では、個別の作成パッチと削除パッチとして分割したペアが残っていたことに注意してください。これは不必要なハックであり、最新の実装では常にすべての分割されたペアが変更にマージされます。ただし、結果のパッチ出力は、 @samp{-} で始まる古いバージョンのコンテンツ全体を表示することにより、このような完全な書き換えの場合に簡単に確認できるように、異なる形式になっています。その後に、接頭辞 @samp{+} が付いた新しいバージョンのコンテンツ全体が続きます。

@noindent

@chapheading diffcore-pickaxe: 指定の文字列(string)の追加/削除の検知のため

この変換により、ファイルペアの組が、特定の方法でプリイメージとポストイメージの間で指した文字列を変更するものに制限されます。 @samp{-S<テキストのブロック>} および @samp{-G<正規表現>} オプションは、これらの文字列を検索するさまざまな方法を指定するために使用されます。

@samp{-S<テキストブロック>} は、指定されたテキストのブロックの出現回数がプリイメージとポストイメージで異なるファイルペアを検出します。定義上、ファイル内の移動は検出されません。また、チェンジセットが対象の文字列に影響を与えずにファイルを大規模に移動すると、通常どおりdiffcore-renameが開始され、@samp{-S} はファイルペアを省略します(その文字列の出現回数は、名前変更で検出されたファイルペアで変更されなかったため)。 @samp{--pickaxe-regex} と一緒に使用する場合、<テキストブロック>は、リテラル文字列ではなく、マッチする拡張POSIX正規表現として扱います。

@samp{-G<正規表現>} (grep文法)は、指定された正規表現にマッチする行が追加または削除されたテキスト差分を持つファイルペアを検出します。これは、ノイズであるファイル内の移動(またはrename-detectionが同じファイルと見なすもの)を検出することを意味します。実装はdiffを2回実行してgrepsしますが、これは非常にコストがかかる可能性があります。高速化のため、textconvフィルタがないバイナリファイルは無視されます。

@samp{-S} または @samp{-G} を @samp{--pickaxe-all} なしで使用すると、それぞれの基準に一致するファイルペアのみが出力に保持されます。 @samp{--pickaxe-all} が使用されている場合、1つのファイルペアでもチェンジセット内のそれぞれの基準に一致すると、チェンジセット全体が保持されます。この振る舞いは、チェンジセット全体のコンテキストでの変更のレビューを容易にするために設計されています。

@noindent

@chapheading diffcore-order: ファイル名に基づいて出力をソートするため

これは、ユーザー(またはプロジェクト)の好みに応じてファイルペアを並べ替えるために使用され、 @samp{git diff-@{asterisk@}} コマンド群の @samp{-O} オプションによって制御されます。

これは、各行がシェルグロブパターンであるテキストファイルを取ります。ファイルの前の行のグロブパターンに一致するファイルペアは、後の行に一致するファイルペアの前に出力され、どのグロブパターンにも一致しないファイルペアは最後に出力されます。

例として、コアGitの一般的な orderfile おそらく以下のようになります:

@example
README
Makefile
Documentation
*.h
*.c
t
@end example


@noindent

@chapheading diffcore-rotate: 出力開始パス(path)を変更するため

この変換は1つのパス名を取り、ファイルペアのセットをローテーションして、指定されたパス名のファイルペアが最初に来るようにします。オプションで、その前にあるパスを破棄します。これは、 @samp{--skip-to} および @samp{--rotate-to} オプションを実装するために使用されます。指定されたパス名がファイルペアのセットにない場合はエラーになりますが、 @samp{git log ` ファミリーのコマンドで使用するとエラーになることはありません。 `git log} コマンドで表示されるすべてのコミットによって特定のパスが変更されることを期待するのは不合理だからです。このため、 @samp{git log} と一緒に使用すると、指定されたパス名と同じように並べ替えられるファイルペア、または最初に並べ替えられるファイルペアが出力の開始場所になります。

この変換をdiffcore-orderと組み合わせて使用すると、diffcore-orderが有効な場合、この変換への入力がソートされない可能性があるため、予期しない結果が生成されます。

@noindent

@chapheading SEE ALSO

git-diff(1), git-diff-files(1), git-diff-index(1), git-diff-tree(1), git-format-patch(1), git-log(1), gitglossary(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node giteveryday,,,Top
@chapheading Name

giteveryday — Git日常利用に役立つ最小限のコマンドセット

@noindent

@chapheading Synopsis

Git日常利用の為の20程度のコマンド

@noindent

@chapheading DESCRIPTION

日常のGit利用に役立つコマンドの小さなセットを説明するため、Gitユーザーを大きく4つのカテゴリに分類します。

@itemize 

@item
開発者個人(スタンドアローン) (@pxref{[STANDALONE]}) のコマンドは
一人で作業する人でも、コミットする人には不可欠です。

@item
他の人と一緒に作業する場合は、開発者個人(グループプロジェクト参加者) (@pxref{[PARTICIPANT]})
セクションにリストされているコマンドも必要になります。

@item
インテグレーター (@pxref{[INTEGRATOR]}) 役の人々は、
上記に加えて更に幾つかのコマンドを学ぶ必要があります。

@item
リポジトリ管理 (@pxref{[ADMINISTRATION]}) コマンドは、
Gitリポジトリの管理と提供を担当するシステム管理者向けです。
@end itemize

@noindent

@chapheading Individual Developer (Standalone)

独立した個々の開発者は、他の人とパッチを交換せず、以下のコマンドを使用して、単一のリポジトリで単独で作業します。

@itemize 

@item
git-init(1) 新しいリポジトリを作成します。

@item
git-log(1) 何が起こったのか確認します。

@item
git-switch(1) と git-branch(1) ブランチを切り替えます。

@item
git-add(1) インデックスファイルを管理します。

@item
git-diff(1) と git-status(1) を使用して、あなたは何をしている最中か確認します。

@item
git-commit(1) を使用して、現在のブランチを進めます。

@item
git-restore(1) を使用して、変更を元に戻します(undo)。

@item
git-merge(1) は、ローカルブランチ間でマージします。

@item
git-rebase(1) は、トピックブランチを保守します。

@item
git-tag(1) を使用して、既知のポイントをマークします。
@end itemize

@noindent

@heading Examples

@table @asis

@item  新しいリポジトリの開始点としてtarballを使用します 
@example
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . (1)
$ git commit -m "import of frotz source tree."
$ git tag v2.43 (2)
@end example


@table @asis

@item @pxref{CO1-1,,(1)}
あなたが現在いるディレクトリ下のすべてをaddします。

@item @pxref{CO1-2,,(2)}
軽量で注釈のないタグを作成します。
@end table

@item  トピックブランチを作成して開発します 
@example
$ git switch -c alsa-audio (1)
$ edit/compile/test
$ git restore curses/ux_audio_oss.c (2)
$ git add curses/ux_audio_alsa.c (3)
$ edit/compile/test
$ git diff HEAD (4)
$ git commit -a -s (5)
$ edit/compile/test
$ git diff HEAD^ (6)
$ git commit -a --amend (7)
$ git switch master (8)
$ git merge alsa-audio (9)
$ git log --since='3 days ago' (10)
$ git log v2.43.. curses/ (11)
@end example


@table @asis

@item @pxref{CO2-1,,(1)}
新しいトピックブランチを作成します。

@item @pxref{CO2-2,,(2)}
@samp{curses/ux_audio_oss.c} で失敗した変更を元に戻します(revert)。

@item @pxref{CO2-3,,(3)}
あなたは新しいファイルを追加したかどうかをGitに伝える必要があります。 後で @samp{git commit -a} を実行すると、削除と変更が捕捉されます。

@item @pxref{CO2-4,,(4)}
コミットしようとしている変更を確認します。

@item @pxref{CO2-5,,(5)}
あなたがテストしたと署名(sign-off)して、全てをコミットします。

@item @pxref{CO2-6,,(6)}
前のコミットを含むすべての変更を確認します。

@item @pxref{CO2-7,,(7)}
元のメッセージを流用して、以前のコミットを修正し、すべての新しい変更を追加します。

@item @pxref{CO2-8,,(8)}
masterブランチに切り替えます。

@item @pxref{CO2-9,,(9)}
トピックブランチをあなたのmasterブランチへマージします。

@item @pxref{CO2-10,,(10)}
コミットログを確認します。出力を制限する他の形式を組み合わせて、 @samp{-10} (最大10個のコミットを表示）、 @samp{--until=2005-12-10} などを含めることができます。

@item @pxref{CO2-11,,(11)}
@samp{v2.43} タグ以降 、@samp{curses/} ディレクトリにあるものに影響を与える変更のみを表示します。
@end table
@end table

@noindent

@chapheading Individual Developer(Participant;グループプロジェクト参加者)

グループプロジェクトの参加者として作業する開発者個人は、他の人と連絡する方法を学ぶ必要があり、スタンドアロンの開発者個人が必要とするコマンドに加えて、これらのコマンドを使用します。

@itemize 

@item
git-clone(1) をアップストリームから実行して、あなたのローカルリポジトリを準備します。

@item
git-pull(1) と git-fetch(1) により、 "origin" をアップストリームと共に最新の状態に保ちます。

@item
CVSスタイルの共有リポジトリワークフローを採用している場合、共有リポジトリのために git-push(1) を使います。

@item
Linuxカーネルスタイルのパブリックフォーラムワークフローを採用している場合に、 git-format-patch(1) は電子メール送信を準備します。

@item
git-send-email(1) を使用して、MUAによる破損なしに電子メール送信を送信します。

@item
git-request-pull(1) を使用して、あなたのアップストリームがプルする変更の概要を作成します。
@end itemize

@noindent

@heading Examples

@table @asis

@item  アップストリームのクローンを作成して作業します。 変更をアップストリームに送ります。 
@example
$ git clone git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6
$ cd my2.6
$ git switch -c mine master (1)
$ edit/compile/test; git commit -a -s (2)
$ git format-patch master (3)
$ git send-email --to="person <email@@example.com>" 00*.patch (4)
$ git switch master (5)
$ git pull (6)
$ git log -p ORIG_HEAD.. arch/i386 include/asm-i386 (7)
$ git ls-remote --heads http://git.kernel.org/.../jgarzik/libata-dev.git (8)
$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL (9)
$ git reset --hard ORIG_HEAD (10)
$ git gc (11)
@end example


@table @asis

@item @pxref{CO3-1,,(1)}
master から新ブランチ @samp{mine} を作成し、 @samp{mine} でチェックアウトします。

@item @pxref{CO3-2,,(2)}
必要に応じてこの作業を繰り返します。

@item @pxref{CO3-3,,(3)}
masterに関連して、あなたのブランチからパッチを抽出します。

@item @pxref{CO3-4,,(4)}
そしてそれらを電子メールで送ります。

@item @pxref{CO3-5,,(5)}
@samp{master} に戻り、最新情報を確認する準備をします

@item @pxref{CO3-6,,(6)}
@samp{git pull} はデフォルトで @samp{origin} からフェッチし、現在のブランチにマージします。

@item @pxref{CO3-7,,(7)}
プルした直後に、前回チェックしてから上流で行われた変更を、関心のある領域でのみ確認します。

@item @pxref{CO3-8,,(8)}
(不明な場合)外部リポジトリのブランチ名を確認します。

@item @pxref{CO3-9,,(9)}
指定のリポジトリから、指定のブランチ @samp{ALL} をフェッチしマージします。

@item @pxref{CO3-10,,(10)}
プルしたのを元に戻します。(revert)

@item @pxref{CO3-11,,(11)}
ガベージコレクションは、元に戻されたプルからゴミオブジェクト(leftover objects)を収集します。
@end table

@item  別のリポジトリにプッシュします。 
@example
satellite$ git clone mothership:frotz frotz (1)
satellite$ cd frotz
satellite$ git config --get-regexp '^(remote|branch)\.' (2)
remote.origin.url mothership:frotz
remote.origin.fetch refs/heads/*:refs/remotes/origin/*
branch.master.remote origin
branch.master.merge refs/heads/master
satellite$ git config remote.origin.push \
           +refs/heads/*:refs/remotes/satellite/* (3)
satellite$ edit/compile/test/commit
satellite$ git push origin (4)

mothership$ cd frotz
mothership$ git switch master
mothership$ git merge satellite/master (5)
@end example


@table @asis

@item @pxref{CO4-1,,(1)}
マザーシップ機には、ホームディレクトリの下にfrotzリポジトリがあります。そこからクローンを作成して、サテライト機でリポジトリを開始します。

@item @pxref{CO4-2,,(2)}
cloneは、これらの構成変数をデフォルトで設定します。 これは、マザーシップ機のブランチをフェッチしてローカルの @samp{remotes/origin/*} リモートトラッキングブランチに保存するために @samp{git pull} を手配します。

@item @pxref{CO4-3,,(3)}
すべてのローカルブランチをマザーシップ機の対応するブランチにプッシュするために @samp{git push} を手配します。

@item @pxref{CO4-4,,(4)}
pushは、マザーシップ機の @samp{remotes/satellite/*} リモートトラッキングブランチへすべての作業をstashします。これをバックアップ方法として使用できます。同様に、あなたはそのマザーシップ機があなたから「フェッチされた」ふりをすることができます(アクセスが一方的な場合に便利です)。

@item @pxref{CO4-5,,(5)}
マザーシップ機で、サテライト機で行われた作業をmasterブランチにマージします。
@end table

@item  Branch off of a specific tag. 
@example
$ git switch -c private2.6.14 v2.6.14 (1)
$ edit/compile/test; git commit -a
$ git checkout master
$ git cherry-pick v2.6.14..private2.6.14 (2)
@end example


@table @asis

@item @pxref{CO5-1,,(1)}
よく知られている(ただし多少遅れている)タグに基づいてプライベートブランチを作成します。

@item @pxref{CO5-2,,(2)}
forward port all changes in @samp{private2.6.14} branch to @samp{master} branch without a formal "merging". Or longhand + @samp{git format-patch -k -m --stdout v2.6.14..private2.6.14 |
git am -3 -k}
@end table
@end table

別の参加者送信メカニズム(participant submission mechanism)は、 @samp{git request-pull} または pull-request メカニズム(GitHub（www.github.com）で使用されているものなど)を使用して、あなたの貢献をあなたのアップストリームに通知します。

@noindent

@chapheading インテグレーター

グループプロジェクトのインテグレーターとして機能するかなり中心的な人物は、他の人が行った変更を受け取り、それらをレビューして統合し、参加者が必要とするコマンドに加えて以下のコマンドを使用して、他の人が使用できるように結果を公開します。

このセクションのコマンドは、GitHub（www.github.com）で @samp{git request-pull} または pull-request に応答するユーザーが、他のユーザーの作業を履歴に統合するために使用することもできます。 リポジトリの部分担当サブリーダー(sub-area lieutenant)は、参加者とインテグレーターの両方として機能します。

@itemize 

@item
git-am(1) を使用して、寄稿者から電子メールで送信されて来たパッチを適用します。

@item
git-pull(1) を使用して、信頼できる部分担当サブリーダーの分からマージします。

@item
git-format-patch(1) を準備し、提案された代替案を寄稿者に送信します。

@item
git-revert(1) は、失敗したコミットを元に戻します。(revert)

@item
git-push(1) を使用して、最先端を公開します。
@end itemize

@noindent

@heading Examples

@table @asis

@item  典型的なGitインテグレーターの一日。 
@example
$ git status (1)
$ git branch --no-merged master (2)
$ mailx (3)
& s 2 3 4 5 ./+to-apply
& s 7 8 ./+hold-linus
& q
$ git switch -c topic/one master
$ git am -3 -i -s ./+to-apply (4)
$ compile/test
$ git switch -c hold/linus && git am -3 -i -s ./+hold-linus (5)
$ git switch topic/one && git rebase master (6)
$ git switch -C seen next (7)
$ git merge topic/one topic/two && git merge hold/linus (8)
$ git switch maint
$ git cherry-pick master~4 (9)
$ compile/test
$ git tag -s -m "GIT 0.99.9x" v0.99.9x (10)
$ git fetch ko && for branch in master maint next seen (11)
    do
        git show-branch ko/$branch $branch (12)
    done
$ git push --follow-tags ko (13)
@end example


@table @asis

@item @pxref{CO6-1,,(1)}
どちらかといえば、あなたが途中で何をしていたかを見てください。

@item @pxref{CO6-2,,(2)}
@samp{master} にマージされていないのがどのブランチかを確認してください。他の統合ブランチ(@samp{maint} 、` next` 、 @samp{seen})についても同様です。

@item @pxref{CO6-3,,(3)}
メールを読んだり、該当するものを保存したり、準備が整っていないものを保存したりします(他のメールリーダーも利用できます)。

@item @pxref{CO6-4,,(4)}
あなたの署名伴って、対話的にそれらを適用します。

@item @pxref{CO6-5,,(5)}
必要に応じてトピックブランチを作成し、再度署名して適用します。

@item @pxref{CO6-6,,(6)}
masterにマージされていない、または安定したブランチの一部として公開されていない内部トピックブランチをリベースします。

@item @pxref{CO6-7,,(7)}
next から 毎回 @samp{seen} を再スタートします。

@item @pxref{CO6-8,,(8)}
そして、まだ調理中のトピックブランチをバンドルします。

@item @pxref{CO6-9,,(9)}
深刻な修正をバックポートします。

@item @pxref{CO6-10,,(10)}
署名付きタグを作成します。

@item @pxref{CO6-11,,(11)}
masterがすでにpushされたものを超えて誤って巻き戻されていないことを確認してください。

@item @pxref{CO6-12,,(12)}
@samp{git show-branch} からの出力では、 @samp{master} には @samp{ko/master} が持つすべてのものが含まれ、 @samp{next} には @samp{ko/next} が持つすべてのものが含まれる必要があります。

@item @pxref{CO6-13,,(13)}
プッシュされた履歴を指す新しいタグとともに、最先端をプッシュします。
@end table
@end table

この例では、 @samp{ko} の省略形はkernel.orgにあるGitメンテナのリポジトリを指しており、以下のようになります:

@example
(in .git/config)
[remote "ko"]
        url = kernel.org:/pub/scm/git/git.git
        fetch = refs/heads/*:refs/remotes/ko/*
        push = refs/heads/master
        push = refs/heads/next
        push = +refs/heads/seen
        push = refs/heads/maint
@end example


@noindent

@chapheading リポジトリ管理

リポジトリ管理者は、以下のツールを使用して、開発者によるリポジトリへのアクセスを設定および維持します。

@itemize 

@item
git-daemon(1) を使用して、リポジトリからの匿名ダウンロードを許可します。

@item
git-shell(1) は、共有中央リポジトリユーザーの「制限付きログインシェル」として使用できます。

@item
git-http-backend(1) は、フェッチサービスとプッシュサービスの両方を可能にする Git-over-HTTP(スマートhttp)のサーバー側実装を提供します。

@item
gitweb(1) は、GitリポジトリへのWebフロントエンドを提供します。これは、 git-instaweb(1) スクリプトを使用して設定できます。
@end itemize

@uref{howto/update-hook-example.html,update hook howto} には、共有中央リポジトリを管理する良い例があります。

さらに、以下のような他の広く展開されているホスティング、ブラウジング、レビューソリューションがいくつかあります:

@itemize 

@item
gitolite 、 gerrit code review 、 cgit 、その他。
@end itemize

@noindent

@heading Examples

@table @asis

@item  @samp{/etc/services} では以下を前提としています 
@example
$ grep 9418 /etc/services
git             9418/tcp                # Git Version Control System
@end example


@item  Run git-daemon to serve /pub/scm from inetd. 
@example
$ grep git /etc/inetd.conf
git     stream  tcp     nowait  nobody \
  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm
@end example


実際の行は1行で書く必要があります。

@item  Run git-daemon to serve /pub/scm from xinetd. 
@example
$ cat /etc/xinetd.d/git-daemon
# default: off
# description: The Git server offers access to Git repositories
service git
@{
        disable = no
        type            = UNLISTED
        port            = 9418
        socket_type     = stream
        wait            = no
        user            = nobody
        server          = /usr/bin/git-daemon
        server_args     = --inetd --export-all --base-path=/pub/scm
        log_on_failure  += USERID
@}
@end example


あなたの xinetd(8) のドキュメントとセットアップを確認してください。これはFedoraシステムからのものです。その他は異なる場合があります。

@item  Give push/pull only access to developers using git-over-ssh. 
例えばこのように使います: @samp{$ git push/pull ssh://host.xz/pub/scm/project}

@example
$ grep git /etc/passwd (1)
alice:x:1000:1000::/home/alice:/usr/bin/git-shell
bob:x:1001:1001::/home/bob:/usr/bin/git-shell
cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell
david:x:1003:1003::/home/david:/usr/bin/git-shell
$ grep git /etc/shells (2)
/usr/bin/git-shell
@end example


@table @asis

@item @pxref{CO7-1,,(1)}
ログインシェルは /usr/bin/git-shell に設定されており、 @samp{git push} と @samp{git pull} 以外は許可されていません。ユーザーはマシンへのsshアクセスを必要とします。

@item @pxref{CO7-2,,(2)}
多くのディストリビューションでは、 /etc/shells にはログインシェルとして使用されるものをリストする必要があります。
@end table

@item  CVS-style shared repository. 
@example
$ grep git /etc/group (1)
git:x:9418:alice,bob,cindy,david
$ cd /home/devo.git
$ ls -l (2)
  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -> refs/heads/master
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches
  -rw-rw-r--   1 david git    84 Dec  4 22:40 config
  -rw-rw-r--   1 david git    58 Dec  4 22:40 description
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks
  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info
  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects
  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes
$ ls -l hooks/update (3)
  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update
$ cat info/allowed-users (4)
refs/heads/master       alice\|cindy
refs/heads/doc-update   bob
refs/tags/v[0-9]*       david
@end example


@table @asis

@item @pxref{CO8-1,,(1)}
開発者を同じgitグループに配置します。

@item @pxref{CO8-2,,(2)}
そして、共有リポジトリをグループで書き込み可能にします。

@item @pxref{CO8-3,,(3)}
ブランチポリシーの制御には、 Documentation/howto/ の Carl による update-hook の例を使用してください。

@item @pxref{CO8-4,,(4)}
alice と cindy はmasterにプッシュでき、bobだけがdoc-updateにプッシュできます。 davidはリリースマネージャーであり、バージョンタグを作成してプッシュできる唯一の人物です。
@end table
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitfaq,,,Top
@chapheading Name

gitfaq — Gitの使用に関するよくある質問(FAQ)

@noindent

@chapheading Synopsis

gitfaq

@noindent

@chapheading DESCRIPTION

このFAQの例では、 @samp{bash} や @samp{dash} などの標準のPOSIXシェルと、ホスティングプロバイダー @samp{git.example.org} にアカウント @samp{author} を持つユーザー A U Thor を想定しています。

@noindent

@chapheading Configuration

@table @asis


@item  @samp{user.name} には何を入れるべきですか？ 
個人名、通常は名前とファミリーネームを使用した形式を入力する必要があります。たとえば、Gitの現在のメンテナは "Junio C Hamano" (濱野 純)を使用しています。 これは、コミットするたびに保存される名前の部分になります。

この構成は、リモートサービスへの認証には影響しません。 そのためには、 git-config(1) の @samp{credential.username} を参照してください。

@item  @samp{http.postBuffer} は実際には何をしますか？ 
このオプションは、HTTPまたはHTTPSを介してデータをリモートにプッシュするときにGitが使用するバッファーのサイズを変更します。データがこのサイズより大きい場合、GitのHTTPサポートを処理するlibcurlは、プッシュされたデータのサイズが事前にわからないため、チャンク転送エンコーディングを使用します。

リモートサーバーまたは中間のプロキシが、(チャンク転送エンコーディングを導入している) HTTP/1.1 をサポートしていないか、チャンクデータが壊れていることがわかっている場合を除いて、この値をデフォルトサイズのままにしておくことは問題ありません。これは一般的なプッシュ問題の解決策として、(誤って)提案されることがよくありますが、ほとんどすべてのサーバーとプロキシが少なくとも HTTP/1.1 はサポートしているため、この値を上げてもほとんどのプッシュ問題は解決されません。 HTTP/1.1 とチャンク転送エンコーディングを正しくサポートしていなかったサーバーまたはプロキシは、大量のトラフィックを遮断するため、今日のインターネットでは無用の長物です。

注意: この値を増やすと、GitがHTTPまたはHTTPSを介して行うすべての関連プッシュで使用されるメモリが増えることに注意してください。これは、すべてが使用されているかどうかに関係なく、バッファ全体が割り当てられるためです。したがって、別の値が必要であることが確実でない限り、デフォルトのままにしておくことをお勧めします。

@item  別のエディタを構成するにはどうすればよいですか？ 
Git専用のエディターを指定していない場合は、デフォルトで、「VISUAL」または「EDITOR」環境変数を使用して構成したエディターが使用されます。どちらも指定されていない場合は、システムのデフォルト(通常は「vi」)が使用されます。 @samp{vi} は使いにくい、または別のエディターを好む人もいるため、使用するエディターを変更することが望ましい場合があります。

エディタを必要とするプログラム用に、あなたがエディタを構成したい場合、シェル構成(つまり、 @samp{~/.bashrc} とか @samp{~/.zshenv})を編集して、 @samp{EDITOR} または @samp{VISUAL} 環境変数に適切な値に設定する行を含めることができます。たとえば、エディタ @samp{nano} が必要な場合は、以下のように記述できます:

@example
export VISUAL=nano
@end example


あなたがGit専用のエディタを構成したい場合は、 @samp{core.editor} 構成 または @samp{GIT_EDITOR} 環境変数を設定できます。これらのオプションが参照される順序の詳細については git-var(1) を参照してください。

注意: いずれの場合も、エディタの値はシェルに渡されるため、スペースを含む引数は適切に引用符で囲む必要があることに注意してください。さらに、エディタが呼び出されたとき、通常ターミナルからデタッチするタイプのエディタ場合は、それを行わないようにする引数を指定して指定する必要があります。そうしないと、Gitはエディタでの変更を認識しません。 Windowsでこれらの問題の両方に対処する構成の例は、構成 @samp{"C:\Program Files\Vim\gvim.exe" --nofork} です。これは、空白を含んだファイル名をクォートし、プロセスのバックグラウンド実行を回避するため @samp{--nofork} オプションを指定します。
@end table

@noindent

@chapheading Credentials

@table @asis


@item  HTTPでプッシュするときに資格情報を指定するにはどうすればよいですか？ 
これを行う最も簡単な方法は、 @samp{credential.helper} 構成を介して資格情報ヘルパーを使用することです。ほとんどのシステムは、システム資格情報マネージャーと統合するための標準的な選択肢を提供します。たとえば、Git for Windowsは「wincred」資格情報マネージャーを提供し、macOSは「osxkeychain」資格情報マネージャーを提供し、標準デスクトップ環境を備えたUnixシステムは「libsecret」資格情報マネージャーを使用できます。 これらはすべて、パスワードまたはトークンを安全に保つために暗号化されたストアに資格情報を保存します。

さらに、ホームディレクトリのファイルに保存する @samp{store} 資格情報マネージャー、または資格情報を永続的に保存しないが、特定の時間、資格情報の入力を求められないようにする @samp{cache} 資格情報マネージャーを使用できます。

プロンプトが表示されたら、パスワードを入力することもできます。 URLにパスワード(パーセントエンコードする必要があります)を配置することは可能ですが、これは全然安全じゃ無く、誤って資格情報が公開される可能性があるため、お勧めしません。

@item  環境変数からパスワードまたはトークンを読み取るにはどうすればよいですか？ 
@samp{credential.helper} 構成オプションは、標準出力で資格情報プロトコルを生成する任意のシェルコマンドを受け取ることもできます。これは、たとえば、資格情報をコンテナに渡すときに役立ちます。

このようなシェルコマンドは、オプション値を感嘆符(@samp{!})で開始することで指定できます。パスワードまたはトークンが @samp{GIT_TOKEN} に保存されている場合は、以下のコマンドを実行して資格情報ヘルパーを設定できます:

@example
$ git config credential.helper \
        '!f() @{ echo username=author; echo "password=$GIT_TOKEN"; @};f'
@end example


@item  資格情報マネージャーに保存したパスワードまたはトークンを変更するにはどうすればよいですか？ 
通常、パスワードまたはトークンが無効な場合、Gitはそれを消去し、新しいものを要求します。ただし、これが常に発生するとは限りません。パスワードまたはトークンを変更するには、既存の資格情報を消去してください。そうすればGitが新しい資格情報の入力を求めます。資格情報を消去するには、以下の構文を使用します(ユーザー名(「author」の部分)とホスト名(「git.example.org」の部分)をあなた自身のに置き換えてください):

@example
$ echo url=https://author@@git.example.org | git credential reject
@end example


@item  HTTPを使用して同じホスティングプロバイダーで複数のアカウントを使用するにはどうすればよいですか？ 
通常、これらのアカウントを区別する最も簡単な方法は、URLでユーザー名を使用することです。 たとえば、 @samp{git.example.org} にアカウント @samp{author} と @samp{committer} がある場合、URLに @uref{https://author@@git.example.org/org1/project1.git,https://author@@git.example.org/org1/project1.git} と @uref{https://committer@@git.example.org/org2/project2.git,https://committer@@git.example.org/org2/project2.git} を使用できます。このように、資格情報ヘルパーを使用すると、アカウントの正しい資格情報が自動的に検索されます。すでにリモートを設定している場合は @samp{git remote set-url origin https://author@@git.example.org/org1/project1.git} としてURLを変更できます(詳細は git-remote(1) を参照)。

@item  SSHを使用して同じホスティングプロバイダーで複数のアカウントを使用するにはどうすればよいですか？ 
SSHをサポートするほとんどのホスティングプロバイダーでは、単一のキーペアがユーザーを一意に識別します。したがって、複数のアカウントを使用するには、アカウントごとにキーペアを作成する必要があります。適度に最新のOpenSSHバージョンを使用している場合は @samp{ssh-keygen -t ed25519 -f ~/.ssh/id_committer} などとして新しいキーペアを作成できます。次に、公開鍵(この場合は @samp{~/.ssh/id_committer.pub} ※拡張子 @samp{.pub} に注意) をホスティングプロバイダーに登録できます。

ほとんどのホスティングプロバイダーは、プッシュに単一のSSHアカウントを使用します。つまり、すべてのユーザーが @samp{git} アカウント(例: @samp{git@@git.example.org})にプッシュします。プロバイダーの場合は、SSHで複数のエイリアスを設定して、使用するキーペアを明確にすることができます。たとえば、以下のようなのを @samp{~/.ssh/config} に記述して、適切な秘密鍵ファイルに置き換えることができます:

@example
# This is the account for author on git.example.org.
Host example_author
        HostName git.example.org
        User git
        # This is the key pair registered for author with git.example.org.
        IdentityFile ~/.ssh/id_author
        IdentitiesOnly yes
# This is the account for committer on git.example.org.
Host example_committer
        HostName git.example.org
        User git
        # This is the key pair registered for committer with git.example.org.
        IdentityFile ~/.ssh/id_committer
        IdentitiesOnly yes
@end example


こうすれば、あなたはプッシュURLを調整して、 @samp{git@@example.org} の代わりに @samp{git@@example_author} または @samp{git@@example_committer} を使用できます(例: @samp{git remote set-url git@@example_author:org1/project1.git}) 。
@end table

@noindent

@chapheading Common Issues

@table @asis


@item  前回のコミットでミスをしました。どうすれば変更できますか？ 
作業ツリーに適切な変更を加え、必要に応じて @samp{git add <file>} または @samp{git rm <file>} を実行してステージングしてから、 @samp{git commit --amend} を実行できます。変更はコミットに含まれ、コミットメッセージを再度編集するように求められます。元のメッセージをそのまま使用したい場合は、 @samp{--no-edit} オプションを伴ってて @samp{git commit} を使用するか、または、エディタが開いたら何もせず保存して終了して済ませることもできます。

@item  バグで変更を加えましたが、それは既にメインブランチに含まれてしまっています。どうすれば元に戻すことができますか？ 
これに対処する通常の方法は、 @samp{git revert} を使用することです。これにより、元の変更が行われて貴重な貢献であった、という履歴が保持されるとともに、元の変更に問題があったためにそれらの変更を元に戻す新しいコミットも導入されます。revertのコミットメッセージは、復帰(revert)されたコミットを示し、通常、復帰(revert)が行われた理由に関する説明を含むように編集されます。

@item  追跡されているファイルへの変更を無視するにはどうすればよいですか？ 
Gitはこれを行う方法を提供していません。 その理由は、チェックアウト中など、Gitがこのファイルを上書きする必要がある場合、ファイルへの変更が貴重で保持されるべきかどうか、または無関係で安全に破棄できるかどうかがわからないためです。したがって、安全なルートを取り、常にそれらを保存する必要があります。

@samp{git update-index} の特定の機能、つまり、assume-unchangedビットとskip-worktreeビットを使おうとするのは魅力的ですが、これらはこの目的には適切に機能しないため、このように使用しないでください。

あなたの目的が構成ファイルを変更することの場合は、テンプレートまたはデフォルトのセットであるファイルをリポジトリにチェックインして、一緒にコピーして必要に応じて変更できると便利なことがよくあります。この場合の変更されたファイルは、誤ってコミットすることを防ぐために、通常は無視されます。

@item  さまざまなファイルを無視するようにGitに依頼したはずなのに、それらはまだ追跡されています 
@samp{gitignore} ファイルは、Gitによって追跡されていない特定のファイルが追跡されないままであることを保証します。ただし、特定のファイルが @samp{.gitignore} に追加される前に追跡されている場合は追跡されたままになります。ファイル/パターン を追跡解除して無視するには、 @samp{git rm --cached <file/pattern>} を使用し、 <file> に一致するパターンを @samp{.gitignore} に追加します。詳細については gitignore(5) を参照してください。

@item  フェッチまたはプルのどちらを実行すればよいか知るにはどうすればよいですか？ 
フェッチは、作業ツリーや現在のブランチを変更せずに、リモートリポジトリからの最新の変更のコピーを保存します。その後、自由に、アップストリームの変更を検査、マージ、リベース、または無視することができます。プルは、フェッチとその直後のマージまたはリベースで構成されます。 git-pull(1) を参照してください。
@end table

@noindent

@chapheading Merging and Rebasing

@table @asis


@item  寿命の長いブランチをスカッシュマージとマージすると、どのような問題が発生する可能性がありますか？ 
一般に、スカッシュマージを使用して2つのブランチを複数回マージすると、さまざまな問題が発生する可能性があります。これには、GUIを使用した場合、または @samp{...`表記を使用して範囲を表す場合に、 `git log} 出力で追加のコミットが表示されることや、競合を何度も再解決する必要がある可能性が含まれます。

Gitが2つのブランチ間で通常のマージを行う場合、正確に3者が考慮されます。2つのブランチと、通常は2つのコミットの共通の祖先である「マージベース」(merge base)と呼ばれる3番目のコミットです。マージの結果は、マージベースと各headの間の変更の合計です。2つのブランチを通常のマージコミットでマージすると、新しい共通の祖先を持つ、新しいコミットが発生し、再度マージされるときはそれが最終的なマージベースになります。そうすると、Gitは、マージベースの前に発生した変更を考慮する必要がないため、以前に解決した競合を再解決する必要がありません。

スカッシュマージを実行する場合、マージコミットは作成されません。代わりに、一方の側からの変更は、もう一方の側への通常のコミットとして適用されます。つまり、これらのブランチのマージベースは変更されないため、Gitが次のマージを実行するときに、前回考慮したすべての変更と新しい変更が考慮されます。つまり、競合を再解決する必要があるかもしれません。 同様に、 @samp{git diff} または @samp{git log} またはGUIで @samp{...} 表記を使用すると、元のマージベース以降のすべての変更が表示されます。

結果として、2つの長期間有効なブランチを繰り返しマージする場合は、常に通常のマージコミットを使用するのが最善です。

@item  2つのブランチに変更を加えた後、それを1つに戻した場合、それら2つのブランチのマージに変更が含まれるのはなぜですか？ 
デフォルトでは、Gitがマージを行うとき、それは「ort」戦略と呼ばれる戦略を使用します。これは、派手な3者間マージ(fancy three-way merge)を行います。 このような場合、Gitはマージを実行するときに、正確に3つのポイントを考慮します。2つのheadと、通常はこれらのコミットの共通の祖先である「マージベース」(merge base)と呼ばれる3番目のポイントです。 Gitは、これらのブランチで発生した履歴や個々のコミットをまったく考慮しません。

その結果、両方の側に変更があり、一方の側がその変更を元に戻した場合、結果には変更が含まれます。 これは、コードが一方の側で変更され、もう一方の側では正味の変更がないためです。このシナリオでは、Gitが変更を採用します。

これが問題になる場合は、代わりにリベースを実行して、ブランチを他のブランチに戻すことでリベースすることができます。このシナリオでのリベースは変更を元に戻します。これは、リベースが元に戻すことを含め、個々のコミットを適用するためです。リベースは書き換え履歴(rewrite history)をリベースするため、問題がない場合を除いて、公開されたブランチのリベースは避けてください。詳細については、 git-rebase(1)のNOTESセクションを参照してください。
@end table

@noindent

@chapheading Hooks

@table @asis


@item  フックを使用して、ユーザーが特定の変更を行うのを妨げるにはどうすればよいですか？ 
これらの変更を行うための唯一の安全な場所は、リモートリポジトリ(つまり、Gitサーバー)で、通常は @samp{pre-receive} フックまたは継続的インテグレーション(CI)システムです。これらは、ポリシーを効果的に実施できる場所です。

@samp{pre-commit} フック(または、コミットメッセージの場合は @samp{commit-msg} フック)を使用してこれらをチェックするのが一般的です。これは、単独の開発者として作業していて、ツールが役立つことを望んでいる場合に最適です。ただし、開発者のマシンでフックを使用することは、ユーザーが(他のさまざまな方法の中でも)気付かれることなく @samp{--no-verify} でこれらのフックをバイパスできるため、ポリシーコントロールとしては効果的ではありません。 Gitは、ユーザーがローカルリポジトリを管理していることを前提としており、これを防止したり、ユーザーを攻撃したりすることはありません。

さらに、一部の上級ユーザーは、「pre-commit」フックが、一時的なコミットを使用して進行中の作業をステージングしたり、修正コミットを作成したりするワークフローの障害であると感じているため、とにかくこれらの種類のチェックはサーバーに押しやることをお勧めします。
@end table

@noindent

@chapheading Cross-Platform Issues

@table @asis


@item  Windowsを使用していますが、テキストファイルがバイナリとして検出されます。 
Gitは、テキストファイルをUTF-8として保存する場合に最適に機能します。Windows上の多くのプログラムはUTF-8をサポートしていますが、Gitがバイナリとして検出するリトルエンディアンのUTF-16形式を使用していないプログラムもあります。プログラムでUTF-8を使用できない場合は、これらのファイルをUTF-8としてリポジトリに保存しながら、ファイルをチェックアウトするエンコードを示す作業ツリーエンコーディング(working tree encoding)を指定できます。これにより、 git-diff(1) などのツールを期待どおりに機能させながら、ツールを機能させることができます。

これを行うには、 @samp{working-tree-encoding} 属性を使用して gitattributes(5) パターンを指定できます。たとえば、以下のパターンは、Windowsで一般的なエンコーディングである UTF-16LE-BOM を使用するようにすべてのC言語ファイルを設定します:

@example
*.c     working-tree-encoding=UTF-16LE-BOM
@end example


これを有効にするには、 @samp{git add --renormalize} を実行する必要があります。プラットフォーム間で使用されるプロジェクトでこれらの変更を行う場合は、ユーザーごとの構成ファイルまたは @samp{$GIT_DIR/info/attributes} の構成ファイルで行う必要があることに注意してください。リポジトリ内の @samp{.gitattributes} ファイルは、リポジトリのすべてのユーザーに適用されます。

行末の正規化については以下のエントリを参照してください。属性ファイルの詳細については、gitattributes(5) を参照してください。

@item  Windowsの git diff はファイルの最後に @samp{^M} があると表示します。 
デフォルトでは、GitはファイルがUnixの行末で保存されることを想定しています。そのため、Windowsの行末の一部であるキャリッジリターン(@samp{^M})は、末尾の空白と見なされるため、表示されます。Gitはデフォルトで、既存の行ではなく、新しい行にのみ末尾の空白を表示します。

ファイルをUnixの行末でリポジトリに保存し、プラットフォームの行末に自動的に変換できます。 これを行うには、構成オプション @samp{core.eol} を @samp{native} に設定し、以下のエントリで、ファイルをテキストまたはバイナリとして構成する方法について確認してください。

行末からキャリッジリターン(CR;\x0d)を削除したくない場合は、 @samp{core.whitespace} 設定を使用してこの動作を制御することもできます。

@item  常に変更されるファイルがあるのはなぜですか？ 
内部的には、Gitは常にファイル名をバイトのシーケンスとして保存し、エンコードや大文字と小文字の区別は行いません。 ただし、WindowsとmacOSはどちらも、デフォルトでファイル名に対して大文字と小文字を区別します。その結果、大文字と小文字が区別される場合にのみ名前が異なる複数のファイルまたはディレクトリが作成される可能性があります。Gitはこれを問題なく処理できますが、ファイルシステムはこれらのファイルの1つしか保存できないため、Gitが他のファイルを読み取ってその内容を確認すると、変更されているように見えます。

ファイルが1つだけになるように、ファイルの1つを削除することをお勧めします。これは、以下のようなコマンド(2つのファイル @samp{AFile.txt} と`afile.txt` を想定)を使用して、他の点ではクリーンな作業ツリーで実行できます:

@example
$ git rm --cached AFile.txt
$ git commit -m 'Remove files conflicting in case'
$ git checkout .
@end example


これにより、ディスクへの変更は回避され、追加のファイルは削除されます。プロジェクトでは、この問題が再発しないように、すべて小文字の名前などの命名規則を採用することをお勧めします。このような規則は、 @samp{pre-receive} フックを使用して、または継続的インテグレーション(CI)システムにてチェックできます。

システムでスマッジまたはクリーンフィルター(a smudge or clean filter)が使用されているが、スマッジまたはクリーンフィルターを実行せずにファイルが以前にコミットされた場合、任意のプラットフォームで永続的に変更されたファイルが発生する可能性もあります。これを修正するには、他の点ではクリーンな作業ツリーで以下を実行します:

@example
$ git add --renormalize .
@end example


@item  Gitにファイルを保存するための推奨の方法は何ですか？ 
Gitはあらゆるタイプのあらゆるファイルを保存および処理できますが、他の設定よりもうまく機能する設定がいくつかあります。一般に、テキストファイルは、LF(Unixスタイル)で終わるバイト順マーク(BOM)なしでUTF-8に保存することをお勧めします。また、コミットメッセージでUTF-8(ここでもBOMなし)を使用することをお勧めします。これらは、プラットフォーム間や @samp{git diff} や @samp{git merge} などのツールで最適に機能する設定です。

さらに、テキストベースまたは非テキストベースのストレージ形式を選択できる場合は、ファイルをテキスト形式で保存し、必要に応じて他の形式に変換することをお勧めします。たとえば、1行に1つのレコードを持つテキストベースのSQLダンプは、実際のデータベースファイルよりも差分とマージにはるかに適しています。同様に、MarkdownやAsciiDocなどのテキストベースの形式は、MicrosoftWordやPDFなどのバイナリ形式よりもうまく機能します。

同様に、バイナリ依存関係(共有ライブラリやJARファイルなど)を格納したり、リポジトリに製品をビルドしたりすることは、通常はお勧めしません。依存関係とビルド製品は、リポジトリに保存されている参照、URL、ハッシュのみを使用して、アーティファクトサーバーまたはパッケージサーバーに保存するのが最適です。

また、 gitattributes(5) ファイルを設定して、どのファイルがテキストでどのファイルがバイナリであるかを明示的にマークすることをお勧めします。Gitに推測させたい場合は、属性 @samp{text=auto} を設定できます。 たとえば、一部のプロジェクトでは以下の設定が適切な場合があります:

@example
# By default, guess.
*       text=auto
# Mark all C files as text.
*.c     text
# Mark all JPEG files as binary.
*.jpg   binary
@end example


これらの設定は、ツールがパッチなどの出力に適切な形式を選択するのに役立ち、プラットフォームに適切な行末コードでファイルがチェックアウトされます。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-bundle,,,Top
@chapheading Name

gitformat-bundle — バンドル・ファイル形式

@noindent

@chapheading Synopsis

@display
*.bundle
*.bdl
@end display


@noindent

@chapheading DESCRIPTION

Git バンドル形式は、 ref と Git オブジェクトの両方を表す形式です。 バンドルは、 git-show-ref(1) のような形式のヘッダーの後に *.pack 形式のパックが続きます。

この形式は git-bundle(1) コマンドで作成・読み込みができ、 git-fetch(1) や git-clone(1) などでサポートされています。

@noindent

@chapheading FORMAT

ABNF 記法を使用して Git バンドル形式を定義します。 詳細については、gitprotocol-common(5) を参照してください。

v2バンドルは以下のようになります:

@example
bundle    = signature *prerequisite *reference LF pack
signature = "# v2 git bundle" LF

prerequisite = "-" obj-id SP comment LF
comment      = *CHAR
reference    = obj-id SP refname LF

pack         = ... ; packfile
@end example


v3バンドルは以下のようになります:

@example
bundle    = signature *capability *prerequisite *reference LF pack
signature = "# v3 git bundle" LF

capability   = "@@" key ["=" value] LF
prerequisite = "-" obj-id SP comment LF
comment      = *CHAR
reference    = obj-id SP refname LF
key          = 1*(ALPHA / DIGIT / "-")
value        = *(%01-09 / %0b-FF)

pack         = ... ; packfile
@end example


@noindent

@chapheading SEMANTICS

Gitバンドルはいくつかの部分で構成されています。

@itemize 

@item
@samp{capabilities} (機能)はv3形式のみであり、バンドルを正しく読み取るために必要な機能を示します。

@item
@samp{prerequisites} (前提条件)には、バンドルに含まれていないオブジェクトがリストされており、バンドル内のデータを使用するには、バンドルのリーダーがそれらを既に持っている必要があります。 バンドルに格納されているオブジェクトは、前提条件オブジェクトとそれらから到達可能なもの(たとえば、バンドル内のツリーオブジェクトは、前提条件から到達可能なブロブを参照できます)、および/または 前提条件オブジェクトに対するデルタとして表現されているものを参照する場合があります。

@item
@samp{references} には、履歴グラフのヒントが記録されています。つまり、バンドルのリーダーがそこから `git fetch ` できるモノです。

@item
@samp{pack} は、上記の「references」に記録された参照を持つリポジトリから、上記の「prerequisites」にリストされたオブジェクトを指す参照を持つリポジトリにフェッチする場合に、 @samp{git fetch} が送信するパックデータストリームです。
@end itemize

バンドル形式では、前提条件(prerequisite)の obj-id の後にコメントを付けることができます。 これはコメントであり、特別な意味はありません。 バンドルの作成者は、ここに任意の文字列を入れてもいいです。 バンドルのリーダーはコメントを無視しなければなりません。

@noindent

@heading Note on the shallow clone and a Git bundle

注意: 前提条件は、浅いクローンの境界(shallow-clone boundary)を表していないことに注意してください。 前提条件と浅いクローンの境界のセマンティクスは異なり、Gitバンドルv2形式は浅いクローンのリポジトリを表すことはできません。

@noindent

@chapheading CAPABILITIES

不明な機能は、 交渉(negotiation)の機会がないため、 @samp{git bundle} の中止(abort)を引き起こします。

@itemize 

@item
@samp{object-format} には使用中のハッシュ・アルゴリズムを指定し、 @samp{extensions.objectFormat} 構成値と同じ値を取ることができます。

@item
@samp{filter} は、git-rev-list(1) の @samp{--filter} オプションのようにオブジェクト・フィルタを指定します。 生成されたパック・ファイルは、バンドル解除(unbundle)後に @samp{.promisor} パック・ファイルとしてマークする必要があります。
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-chunk,,,Top
@chapheading Name

gitformat-chunk — チャンク・ベースのファイル形式

@noindent

@chapheading Synopsis

gitformat-commit-graph(5) や MIDX形式で使用されます(gitformat-pack(5) の「pack format」のドキュメントを参照してください)。

@noindent

@chapheading DESCRIPTION

Git の一部のファイル形式では、 「チャンク」という一般的な概念を使用して、ファイルのセクションを記述します。 これにより、小さな「目次」をスキャンして残りのデータを探すことで、 大きなファイルへの構造化されたアクセスが可能になります。 この一般的な形式は、 コミット・グラフ・ファイルとマルチ・パック・インデックス・ファイルで使用されます。チャンクを使用して構造化データを記述する方法については、 gitformat-pack(5) の マルチ・パックインデックス形式と gitformat-commit-graph(5) の コミット・グラフ形式を参照してください。

チャンクベースファイル形式(chunk-based file format)は、その形式に合わせたヘッダー情報から始まります。 そのヘッダーには、ファイルタイプ、形式バージョン、ファイル内のチャンクの数、を識別するのに十分な情報が含まれている必要があります。 この情報から、そのファイルはチャンクベース領域(chunk-based region)の開始を決定する事ができます。

チャンクベース領域(chunk-based region)は、各チャンクの開始と終了を説明する目次(table of contents)で始まります。 これは、各行(row)12バイトの (C+1)行(row)で構成されます。ここで、Cはチャンクの数です。 以下の表をじっくり見やがれしてください。

@example
  | Chunk ID (4 bytes) | Chunk Offset (8 bytes) |
  |--------------------|------------------------|
  | ID[0]              | OFFSET[0]              |
  | ...                | ...                    |
  | ID[C]              | OFFSET[C]              |
  | 0x0000             | OFFSET[C+1]            |
@end example


各行(row)は、4バイトのチャンク識別子(ID)と8バイトのオフセットで構成されます。各整数はネットワークバイトオーダーで格納されます。

チャンク識別子 @samp{ID[i]} は、 @samp{OFFSET[i]} (含む) から @samp{OFFSET[i+1]} (含まない) (訳注: OFFSET[i] ⇐ ID[i]のデータ < OFFSET[i+1]) までの、このフィル内に格納されたデータのラベルです。したがって、 @samp{i} 番目のチャンクのサイズは、@samp{OFFSET[i+1]} と @samp{OFFSET[i]} の差に等しくなります(訳注: つまり、サイズ = OFFSET[i+1] - OFFSET[i])。 このためには、チャンクデータが目次と同じ順序で連続して表れる必要があります。

目次の最後のエントリは、4つのゼロバイトである必要があります。 これにより、目次が終了していることが確認され、チャンクベースのデータの終了のオフセットが提供されます。

注意: チャンクベース形式では、ファイルの @samp{OFFSET[C+1]} の後に、「少なくとも」末尾のハッシュ(trailing hash)が含まれている必要があります。

チャンクベースのファイル形式を操作するための関数は、 @samp{chunk-format.h} で宣言されています。 これらのメソッドを使用すると、開発者が新しいファイル形式を作成するときに役立つ追加のチェックが提供されます。

@noindent

@chapheading Writing chunk-based file formats

チャンクベースファイル形式を作成するには、 @samp{init_chunkfile()_ を呼び出して `struct chunkfile} を作成し、 @samp{struct hashfile} ポインタを渡します。 呼び出し元は、 @samp{hashfile} を開き、ヘッダー情報を書き込む責任があります。これにより、チャンクベース形式が始まる前にファイル形式を識別できます。

次に、書き込み用のチャンクごとに @samp{add_chunk()} を呼び出します。 これにより、@samp{chunkfile} に書き込む各チャンクの順序とサイズに関する情報が入力されます。 要求に応じてチャンクデータの書き込みを実行するための @samp{chunk_write_fn} 関数ポインタを提供します。

@samp{write_chunkfile()} を呼び出して、目次(table of contents)を @samp{hashfile} に書き込み、その後に各チャンクを書き込みます。 これにより、各チャンクが予想される量のデータを書き込んだことを確認し、目次が正しいことを確認します。

最後に、 @samp{free_chunkfile()} を呼び出して、 @samp{structc hunkfile} データをクリアします。 呼び出し元は、末尾のハッシュ(trailing hash)を書き込んでファイルを閉じることにより、 @samp{hashfile} を完成させる責任があります。

@noindent

@chapheading Reading chunk-based file formats

チャンクベースファイル形式を読み取るには、ファイルをメモリマップ領域(memory-mapped region)として開く必要があります。 チャンク形式のAPIは、ファイル全体が連続したメモリ領域としてマップされることを想定しています。

@samp{init_chunkfile(NULL)} で @samp{struct chunkfile} ポインタを初期化します。

ファイルの先頭からチャンクカウント(chunk count)を含むヘッダー情報を読み取った後、 @samp{read_table_of_contents()} を呼び出して、 @samp{structc hunkfile} にチャンクのリスト、それらのオフセット、およびそれらのサイズを入力します。

@samp{pair_chunk()} または @samp{read_chunk()} を使用して、各チャンクのデータ情報を抽出します:

@itemize 

@item
@samp{pair_chunk()} は、そのチャンクのオフセットに対応するメモリマップされたファイル(memory-mapped file)内の場所に特定のポインタを割り当てます。 チャンクが存在しない場合、ポインターは変更されません。

@item
@samp{read_chunk()} は、 @samp{chunk_read_fn} 関数ポインタを受け取り、適切な初期ポインタとサイズ情報を使用して呼び出します。 チャンクが存在しない場合、関数は呼び出されません。 即時パース(immediate parsing)を実行する必要がある場合、またはチャンクのサイズに基づいてロジックを実行する必要がある場合は、このメソッドを使用してチャンクを読み取ります。
@end itemize

これらのメソッドを呼び出した後、 @samp{free_chunkfile()} を呼び出して @samp{structc hunkfile} データをクリアします。 これにより、メモリマップ領域は閉じられません。 呼び出し元は、領域へのポインタが必要とされている間はデータを所有しつづけることが期待されます。

@noindent

@chapheading Examples

これらのファイル形式はチャンク形式のAPIを使用しており、将来の形式の例として使用できます:

@table @asis

@item  commit-graph 
gitformat-commit-graph(5) の「commit-graph file format」に記載されているコミット・グラフ・ファイル形式を記述および解析するためにチャンク形式 API を使用する方法については、 @samp{commit-graph.c} の @samp{write_commit_graph_file()} と @samp{parse_commit_graph()} を参照してください。

@item  multi-pack-index 
gitformat-pack(5) の「multi-pack-index file format」のセクションに記載されているマルチ・パック・インデックス・ファイル形式を記述および解析するためにチャンク形式 API がどのように使用されるかについては、 @samp{midx.c} の @samp{write_midx_internal()} と @samp{load_multi_pack_index()} を参照してください。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-commit-graph,,,Top
@chapheading Name

gitformat-commit-graph — Git commit-graph format

@noindent

@chapheading Synopsis

@display
$GIT_DIR/objects/info/commit-graph
$GIT_DIR/objects/info/commit-graphs/*
@end display


@noindent

@chapheading DESCRIPTION

The Git commit-graph stores a list of commit OIDs and some associated metadata, including:

@itemize 

@item
コミットの世代番号。

@item
ルートツリーOID。

@item
コミット日付。

@item
グラフファイル内の位置参照を使用して保存されたコミットの親。

@item
要求された場合、コミットとその最初の親の間で変更されたパスを伝えるコミットのブルームフィルター
@end itemize

これらの位置参照は、コミット OID のリスト内の配列位置に対応する符号なし 32 ビット整数として格納されます。 親を追跡するために使用するいくつかの特別な定数により、最大で (1 << 30) + (1 << 29) + (1 << 28) - 1 (約 18 億) のコミットを格納できます。

@noindent

@chapheading Commit-graph files have the following format:

グラフに余分なデータを追加する拡張を可能にするために、ボディを「チャンク」に編成し、ぼでぃの先頭にバイナリ ルックアップ テーブルを提供します。 ヘッダーには、チャンク数やハッシュ タイプなどの特定の値が含まれます。

すべての複数バイト数値はネットワークバイトオーダーです。

@noindent

@heading HEADER:

@itemize 

@item
4バイト シグネチャ:

シグネチャは: @{@emph{C}, @emph{G}, @emph{P}, @emph{H}@}

@item
1バイト バージョン番号:

現在、有効なバージョンは 1 のみです。

@item
1バイト ハッシュバージョン

以下の値からハッシュ長(H)を推測します:

@example
1 => SHA-1
2 => SHA-256
@end example

ハッシュタイプがリポジトリのハッシュアルゴリズムと一致しない場合、コミットグラフファイルは無視され、ユーザーに警告が表示されます。

@item
1バイト チャンクの数©

@item
1バイト ベースコミットグラフの数(B)

この値からベースグラフチャンクの長さ(H*B)を推測します。
@end itemize

@noindent

@heading CHUNK LOOKUP:

@itemize 

@item
(C + 1) * 12 バイト チャンクの目次をリストします:

最初の 4 バイトはチャンク ID を表します。 値 0 は終了ラベルです。 他の 8 バイトは、チャンクが始まる現在のファイル内バイトオフセットを提供します。 (チャンクはファイル内で連続して並べられているため、必要に応じて次のチャンク位置を使用して長さを推測できます。) 各チャンク ID は最大 1 回しか表れせん。
@end itemize

CHUNK LOOKUP は、チャンクベースのファイル形式の目次とマッチします。 gitformat-chunk(5) を参照してください。

@noindent

@heading CHUNK DATA:

@noindent
@anchor{OID Fanout [ID; @{O; I; D; F@}] [256 * 4 bytes]}
@subheading OID Fanout (ID: @{O, I, D, F@}) (256 * 4 bytes)

i 番目のエントリ F[i] には、 最初のバイトが最大で i 個の OID の数が格納されます。 したがって、 F[255] にはコミットの総数 (N) が格納されます。

@noindent
@anchor{OID Lookup [ID; @{O; I; D; L@}] [N * H bytes]}
@subheading OID Lookup (ID: @{O, I, D, L@}) (N * H bytes)

昇順でソートされた、グラフ内のすべてのコミットの OID。

@noindent
@anchor{Commit Data [ID; @{C; D; A; T @}] [N * [H + 16] bytes]}
@subheading Commit Data (ID: @{C, D, A, T @}) (N * (H + 16) bytes)

@itemize 

@item
最初の H バイトは、ルートツリーの OID 用です。

@item
次の 8 バイトは、i 番目のコミットの最初の 2 つの親の位置用です。 その位置に親がいない場合は、値 0x70000000 を格納します。 親が 3 つ以上ある場合、2 番目の値の最上位ビットがオンになり、他のビットは配列位置を Extra Edge List チャンクに格納します。

@item
その次の 8 バイトには、コミットのトポロジレベル(世代番号 v1)とエポックからのコミット時間(秒単位)が格納されます。 世代番号は最初の 4 バイトの上位 30 ビットを使用し、コミット時間はその次の 4 バイトの 32 ビットと最下位バイトの下位 2 ビットを使用して、コミット時間の 33 番目と 34 番目のビットを格納します。
@end itemize

@noindent
@anchor{Generation Data [ID; @{G; D; A; 2 @}] [N * 4 bytes] [Optional]}
@subheading Generation Data (ID: @{G, D, A, 2 @}) (N * 4 bytes) [Optional]

@itemize 

@item
この 4 バイト値のリストには、コミットデータチャンクと同じ順序で配置された、コミットの修正されたコミット日付オフセットが格納されます。

@item
修正されたコミット日付オフセットが 31 ビット以内に格納できない場合、値の最上位ビットがオンになり、他のビットは修正されたコミット日付の位置をジェネレーション データ オーバーフロー チャンク(Generation Data Overflow chunk)に格納します。

@item
ジェネレーション データ チャンクは、互換性のあるバージョンの Git によってコミット グラフ ファイルが書き込まれた場合にのみ存在し、分割されたコミット グラフ チェーンの場合、最上層にもジェネレーション データ チャンクがあります。
@end itemize

@noindent
@anchor{Generation Data Overflow [ID; @{G; D; O; 2 @}] [Optional]}
@subheading Generation Data Overflow (ID: @{G, D, O, 2 @}) [Optional]

@itemize 

@item
この 8 バイト値のリストには、31 ビット内に格納できない修正されたコミット日付オフセットを持つコミットの修正されたコミット日付オフセットが格納されます。

@item
ジェネレーション データ オーバーフロー チャンクは、ジェネレーション データ チャンクが存在し、少なくとも 1 つ以上修正されたコミット日付オフセットが 31 ビット内に格納できない場合にのみ存在します。
@end itemize

@noindent
@anchor{Extra Edge List [ID; @{E; D; G; E@}] [Optional]}
@subheading Extra Edge List (ID: @{E, D, G, E@}) [Optional]

この 4 バイト値のリストには、すべてのオクトパス・マージの 2 番目から n 番目の親が格納されます。 コミット・データの 2 番目の親の値は、 このリスト内の配列位置を最上位ビットをオンにして格納します。 その配列位置から開始して、 最上位ビットがオンの値に到達するまで、 親のコミット位置のこのリストを繰り返します。 他のビットは、 最後の親の位置に対応します。

@noindent
@anchor{Bloom Filter Index [ID; @{B; I; D; X@}] [N * 4 bytes] [Optional]}
@subheading Bloom Filter Index (ID: @{B, I, D, X@}) (N * 4 bytes) [Optional]

@itemize 

@item
i 番目のエントリ BIDX[i] には、コミット 0 からコミット i までのすべてのブルームフィルターのバイト数が、辞書順で格納されます。 i 番目のコミットのブルーム フィルターは、BIDX[i-1] から BIDX[i] (およびヘッダー長) に及びます。ここで、BIDX[-1] は 0 です。

@item
BDAT チャンクが存在しない場合、BIDX チャンクは無視されます。
@end itemize

@noindent
@anchor{Bloom Filter Data [ID; @{B; D; A; T@}] [Optional]}
@subheading Bloom Filter Data (ID: @{B, D, A, T@}) [Optional]

@itemize 

@item
3 つの符号なし 32 ビット整数で構成されるヘッダーで始まります:

@itemize 

@item
使用されているハッシュ・アルゴリズムのバージョン。 現在、 @samp{https://en.wikipedia.org/wiki/MurmurHash#Algorithm} で説明されているとおりに実装された murmur3 ハッシュの 32 ビット・バージョンに対応する値 1 と、 @samp{https://doi.org/10.1007/978-3-540-30494-4_26} "Bloom Filters in Probabilistic Verification" で説明されているシード値 0x293ae76f および 0x7e646e2 を使用する二重ハッシュ手法(double hashing technique)のみをサポートしています。

@item
パスがハッシュ化される回数、 つまり、コミットにおいてファイルが存在するかどうかを累積的に判断するビット位置の数です。

@item
ブルーム・フィルターのエントリあたりのビット @samp{b} の最小数。 フィルタに @samp{n} 個のエントリが含まれる場合、 フィルタ・サイズは、 n*b ビットを含む 64 ビット ワードの最小数です。
@end itemize

@item
チャンクの残りの部分は、コミットに対して計算されたすべてのブルーム・フィルター(Bloom filter)を辞書順で連結したものです。

@item
注意: 変更がないコミット、または 512 を超える変更があるコミットは、 長さが 1 のブルーム・フィルターを持ち、すべてのビットがそれぞれ 0 または 1 に設定されます。

@item
BDAT チャンクは、 BIDX が存在する場合にのみ存在します。
@end itemize

@noindent
@anchor{Base Graphs List [ID; @{B; A; S; E@}] [Optional]}
@subheading Base Graphs List (ID: @{B, A, S, E@}) [Optional]

この H バイト・ハッシュのリストは、 コミット・グラフ・チェーンを形成する一連の B コミット・グラフ・ファイルを記述します。 このファイルの OID ルックアップ・チャンクの i 番目のコミットのグラフ位置は、 i にすべてのベース・グラフのコミット数を加えた値に等しくなります。 B がゼロでない場合、 このチャンクが存在する必要があります。

@noindent

@heading TRAILER:

上記すべての H バイト ハッシュ チェックサム。

@noindent

@chapheading Historical Notes:

Generation Data (GDA2) および Generation Data Overflow (GDO2) チャンクのチャンク ID には @samp{2} という数字が含まれています。 これは、 以前のバージョンの Git が ID @samp{GDAT} および @samp{GDOV} を使用してこれらのチャンクに誤ったデータを書き込んだためです。 ID を変更することで、 Git の新しいバージョンは古いチャンクを黙って無視し、 誤ったデータを信頼することなく新しい情報を書き込みます。

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-index,,,Top
@chapheading Name

gitformat-index — Git インデックス形式

@noindent

@chapheading Synopsis

@display
$GIT_DIR/index
@end display


@noindent

@chapheading DESCRIPTION

Git インデックス形式(index format)

@noindent

@chapheading The Git index file has the following format

すべての2進数はネットワークバイトオーダーです。 従来の SHA-1 を使用するリポジトリでは、以下で説明するチェックサムとオブジェクトID (オブジェクト名) はすべて SHA-1 を使用して計算されます。 同様に、SHA-256 リポジトリでは、これらの値は SHA-256 を使用して計算されます。 特に断りのない限り、ここではバージョン 2 について説明します。

@itemize 

@item
12バイトのヘッダー は以下から構成されます

@itemize 

@item
4バイト シグネチャ:

シグネチャは @{ @samp{D}, @samp{I}, @samp{R}, @samp{C} @} (「dircache」の略)

@item
4バイト バージョン番号:

現在サポートしているバージョンは 2 と 3 と 4 です。

@item
32ビット インデクスエントリの数
@end itemize

@item
ソートされたインデックスエントリの数(下記参照)。

@item
拡張機能(extensions)

拡張機能(extensions)はシグネチャによって識別されます。 オプションの拡張機能(extensions)は、Git が理解できない場合は無視できます。

@itemize 

@item
4バイト 拡張機能シグネチャ。最初のバイトが @samp{A} 〜 @samp{Z} の場合は、その拡張機能はオプションで、無視する事ができます。

@item
32ビット 拡張機能(extension)のサイズ

@item
拡張機能データ
@end itemize

@item
このチェックサムより前のインデックスファイルの内容に対するハッシュチェックサム。
@end itemize

@noindent

@chapheading Index entry

インデックスエントリは名前フィールドで昇順にソートされ、符号なしバイト(unsigned bytes)の文字列(string)として解釈されます(つまり、 memcmp() 順で、ローカライズなしで、ディレクトリセパレータ @samp{/} という特別な場合は無し)。 同一名のエントリでは、それらのステージフィールド(stage field)によってソートされます。

通常、インデックスエントリはファイルを表します。 ただし、コーンモードでスパースチェックアウトが有効(@samp{core.sparseCheckoutCone} が有効)で、 @samp{extensions.sparseIndex} 拡張機能が有効な場合、インデックスにはスパースチェックアウト定義外のディレクトリのエントリが含まれる場合があります。 これらのエントリのモードは「040000」で、「SKIP_WORKTREE」ビットが含まれ、パスはディレクトリセパレータで終わります。

@itemize 

@item
32ビット ctime秒。ファイルのメタデータが最後に変更された時刻

これは stat(2) のデータです

@item
32ビット ctime のナノ秒部分

これは stat(2) のデータです

@item
32ビット mtime 秒。ファイルのデータが最後に変更された時刻

これは stat(2) のデータです

@item
32ビット mtime のナノ秒部分

これは stat(2) のデータです

@item
32ビット dev

これは stat(2) のデータです

@item
32ビット ino

これは stat(2) のデータです

@item
32ビット モード。以下の通り分割されています(高位からから低位ビットの順です)

@itemize 

@item
4ビット オブジェクトタイプ

有効な値は、2進数で 1000 (通常のファイル)と、1010 (シンボリック リンク)と、1110 (gitlink) です。

@item
16-bit unused, must be zero

@item
4-bit object type + valid values in binary are 1000 (regular file), 1010 (symbolic link) and 1110 (gitlink)

@item
3-bit unused, must be zero
@end itemize

@item
32ビット uid

これは stat(2) のデータです

@item
32ビット gid

これは stat(2) のデータです

@item
32ビット ファイルサイズ
これは stat(2) からのディスク上のサイズで、32ビットに切り捨て(truncate)られます。

@item
表現されたオブジェクトのオブジェクト名

@item
16ビットの「flags」フィールドは以下のように分割されています(高位ビットから低位ビットへの順です)

@itemize 

@item
1ビット assume-valid フラグ

@item
1ビット extended フラグ(バージョン2ではゼロでなければなりません)

@item
2ビット ステージ(マージ作業中のステージ)

@item
12ビット 名前の長さ(長さが 0xFFF 未満の場合)、それ以外の場合、このフィールドには 0xFFF が格納されます。

(バージョン3以降) 16ビットフィールド。上記の「extended flag」が 1 の場合にのみ適用され、以下のように分割されます(上位ビットから下位ビットの順)

@item
1ビット 将来の為に予約

@item
1ビット skip-worktree フラグ(スパースチェックアウトで使用)

@item
1ビット intent-to-add フラグ(「git add -N」で使用)

@item
13ビット 未使用。0でなければならない
@end itemize

@item
最上位ディレクトリに対するエントリ パス名 (可変長) (先頭のスラッシュなし)。 @samp{/} はパス区切りとして使用されます。 特別なパスコンポーネント @samp{.} と @samp{..} と @samp{.git} (引用符なし) は許可されていません。 末尾のスラッシュも許可されていません。

正確なエンコーディングは未定義ですが、 @samp{.} と @samp{/} 文字は 7ビットASCII でエンコードされ、エンコードに NUL バイトを含めることはできません (つまり、これは UNIX パス名です)。

(バージョン 4) バージョン 4 では、 エントリのパス名は、 前のエントリのパス名に対してプレフィックス圧縮されます(最初のエントリは、 前のエントリのパス名が空の文字列であるかのようにエンコードされます)。 エントリの先頭に、 可変幅エンコーディング(オフセットと同じエンコーディングが OFS_DELTA パック・エントリにエンコードされます。 gitformat-pack(5) 参照)の整数 N が格納され、その後に NUL で終了する文字列 S が続きます。 前のエントリのパス名の末尾から N バイトを削除し、 文字列 S に置き換えると、このエントリのパス名が生成されます。

@item
1～8個の nul バイト。 名前を NUL で終了させたまま、必要に応じて 1～8個の nul バイト を使用して エントリを 8 バイトの倍数にパディングします。

(バージョン 4)バージョン4では、パス名の後のパディングは存在しません。
@end itemize

分割インデックスモードでのインデックス エントリの解釈は、まったく異なります。 詳細については、下記を参照してください。

@noindent

@chapheading 拡張機能(extensions)

@noindent

@heading Cache tree

インデックスはディレクトリのエントリを記録しないため、キャッシュエントリは、既存のコミットから変更されていないインデックスの領域のオブジェクトデータベースに既に存在するツリーオブジェクトを記述することはできません。 キャッシュツリー拡張機能は、既に存在し、キャッシュエントリのセクションと完全に一致するツリーを記述する再帰的なツリー構造を格納します。 これにより、そのコミットに対して「新しい」ツリーのみを計算することで、新しいコミットのインデックスからのツリー オブジェクトの生成が高速化されます。 また、ツリーの比較で同等性が示される場合にインデックスのセクションをスキップできるため、インデックスを @samp{HEAD^@{tree@}} などの別のツリーと比較する場合にも役立ちます。

再帰的なツリー構造は、多数の キャッシュエントリや、サブノードのリストや、オブジェクトID(OID) を格納するノードを使用します。 OID は、そのノードの既存のツリーが存在することがわかっている場合、それを参照します。 サブノードは、それ自体がキャッシュツリーノードを持つサブディレクトリに対応します。 キャッシュエントリの数は、そのツリーのディレクトリ内のパスを記述するインデックス内のキャッシュエントリの数に対応します。

拡張機能は、キャッシュツリー拡張機能で全体のディレクトリ構造(full directory structure)を追跡しますが、これは通常、全体のキャッシュエントリリスト(full cache entry list)よりも小さくなります。

インデックスでパスが更新されると、Gitはそのパスの親ディレクトリに対応する再帰キャッシュツリーのすべてのノードを無効にします。 キャッシュエントリの数として「-1」を使用して、これらのツリーノードを「無効」として保存します。 無効なノードは引き続き一連のインデックスエントリを格納するため、Git は完全なキャッシュツリーを再構築する際にその作業に集中できます。

@itemize 

@item
この拡張機能のシグネチャは @{ @samp{T}, @samp{R}, @samp{E}, @samp{E} @} です。

@item
一連のエントリの連なりで拡張機能全体を満たします。これは以下のものから構成されています:

@itemize 

@item
NUL終端のパスコンポーネント(その親ディレクトリからの相対指定);

@item
ASCII文字による10進数の数値 このエントリが表すツリーによってカバーされるインデックス内のエントリの数 (entry_count);

@item
空白1つ(ASCII 32);

@item
ASCII文字による10進数の数値。このツリーが持っているサブツリーの数をあらわします。

@item
改行(newline)(ASCII 10);

@item
オブジェクト名。この範囲のインデックスをツリーとして書き込んだ結果となるオブジェクトのオブジェクト名。
@end itemize
@end itemize

エントリは無効化された状態にある可能性があり、entry_count フィールドに負の数があることで表されます。 この場合、オブジェクト名はなく、改行(newline)の直後に次のエントリが開始されます。 無効なエントリを書き込む場合、entry_count として常に「-1」を使用する必要があります。

エントリは、上から下へ、深さ優先の順序で書き出されます。 最初のエントリはリポジトリのルート レベルを表し、ルートレベルの最初のサブツリー(これをAとする)(これはルートレベルに相対的な名前です)が続き、さらに A の最初のサブツリー(これはAに相対的な名前です)が続きます。 サブツリーの指定された数は、再帰スタックの現在のレベルがいつ完了するかを示します。

@noindent

@heading Resolve undo

競合は、より高いステージのエントリのセットとしてインデックスで表されます。 (「git add path」などを使用して)競合が解決されると、これらの上位ステージのエントリが削除され、適切な解決策を持つ ステージ 0 エントリが追加されます。

これらのより高いステージのエントリが削除されると、解決前に戻す拡張機能(the resolve undo extension)に保存されるため、ユーザーが最初から競合解決をやり直したい場合に備えて、競合を再作成できます (たとえば、「git checkout -m」を使用)。

@itemize 

@item
この拡張機能のシグネチャは @{ @samp{R}, @samp{E}, @samp{U}, @samp{C} @} です。

@item
一連のエントリの連なりで拡張機能全体を満たします。これは以下のものから構成されています:

@itemize 

@item
エントリを説明する、NULで終わるパス名(リポジトリのルートからの相対、つまりフルパス名)

@item
3つのNULで終わるASCII文字による8進数値。ステージ1〜3でのエントリのエントリモード(欠落しているステージは、このフィールドでは「0」で表されます)

@item
ステージ1〜3でのエントリの最大3つのオブジェクト名(欠落しているステージには何も書き込まれません)。
@end itemize
@end itemize

@noindent

@heading Split index

分割インデックス モードでは、インデックスエントリの大部分を別のファイルに保存できます。 この拡張機能は、最終的なインデックスを生成するために加えられる変更を記録します。

@itemize 

@item
この拡張機能のシグネチャは @{ @samp{l}, @samp{i}, @samp{n}, @samp{k} @} です。

@item
この拡張機能は以下から構成されます:

@itemize 

@item
共有インデックスファイルのハッシュ。 共有インデックスファイルのパスは @samp{$GIT_DIR/sharedindex.<hash>} です。 すべてのビットが 0 の場合、インデックスは共有インデックスファイルを必要としません。

@item
ewahでエンコードされた削除ビットマップで、各ビットは共有インデックス内のエントリを表します。ビットが設定されている場合、共有インデックス内の対応するエントリが最終インデックスから削除されます。 削除操作はインデックス エントリの位置を変更しますが、置換フェーズでは元の位置が必要になるため、エントリを削除するようにマークし、置換後に一括削除を実行することをお勧めします。

@item
ewahでエンコードされた置換ビットマップで、各ビットは共有インデックス内のエントリを表します。 ビットが設定されている場合、共有インデックス内の対応するエントリは、このインデックス ファイル内のエントリに置き換えられます。 置換されたすべてのエントリは、このインデックスに並べ替えられた順序で格納されます。 置換ビットマップの最初の「1」ビットは最初のインデックス エントリに対応し、2 番目の「1」ビットは 2 番目のエントリに対応し、以下同様です。 スペースを節約するために、置換されたエントリのパス名が空の場合があります。
@end itemize
@end itemize

置き換えられた後の残りのインデックスエントリは、最終的なインデックスに追加されます。 これらの追加されたエントリも、エントリ名、ステージの順でソートされます。

@noindent

@chapheading Untracked cache

未追跡キャッシュ(untracked cache)は、未追跡ファイルのリストと、キャッシュを検証するために必要なデータを保存します。 この拡張機能(extension)のシグネチャは @{@samp{U}, @samp{N}, @samp{T}, @samp{R} @} です。

この拡張機能は以下から始まります

@itemize 

@item
可変長エンコーディング(variable width encoding)のシーケンスのサイズが前に付いた、NUL で終了する文字列のシーケンス。 各文字列には、キャッシュを使用できる環境が記述されています。

@item
$GIT_DIR/info/exclude の統計(stat)データ。 ctime フィールドから「file size」までの「Index entry」セクションを参照してください。

@item
core.excludesFileの統計(stat)データ

@item
32ビット dir_flags (struct dir_struct 参照)

@item
$GIT_DIR/info/exclude の ハッシュ。 nullハッシュは、ファイルが存在しないことを意味します。

@item
core.excludesFile のハッシュ。 null ハッシュは、ファイルが存在しないことを意味します。

@item
ディレクトリごとの除外ファイル名の NUL で終わる文字列。 これは通常「.gitignore」です。

@item
次のディレクトリブロックの数、可変長エンコーディング(variable width encoding)。 この数がゼロの場合、拡張機能(the extension)は、ここに続く NUL で終わりです。

@item
深さ優先検索順(depth-first-search order)のディレクトリブロックの数。これは以下から構成されます

@itemize 

@item
未追跡エントリ(untracked entries)の数。可変長エンコーディング。

@item
サブディレクトリブロックの数。可変長エンコーディング。

@item
NUL終端されたディレクトリ名。

@item
NUL終端された 未追跡ファイル名/未追跡ディレクトリ名 の数。
@end itemize
@end itemize

各ディレクトリブロックの残りのデータは、タイプ別にグループ化されます:

@itemize 

@item
ewah ビットマップでは、n番目のビットは、n番目のディレクトリに未追跡の有効なキャッシュエントリがあるかどうかを表します。

@item
ewah ビットマップでは、n番目のビットは、n番目のディレクトリの read_directory_recursive() の「check-only」ビットを記録します。

@item
ewah ビットマップでは、n番目のビットは、ハッシュと統計(stat)データがn番目のディレクトリで有効であり、次のデータに存在するかどうかを表します。

@item
統計(stat)データの配列。 n番目のデータは、この前にあるewahビットマップのn番目の「1」ビットに対応します。

@item
ハッシュの配列。 n番目のハッシュは、この前のewahビットマップのn番目の「1」ビットに対応します。

@item
1つのNUL。
@end itemize

@noindent

@chapheading File System Monitor cache

ファイルシステムモニター キャッシュは、 core.fsmonitor フックが変更を通知したファイルを追跡します。 この拡張機能のシグネチャは @{ @samp{F}, @samp{S}, @samp{M}, @samp{N} @} です。

この拡張機能は以下から始まります

@itemize 

@item
32ビット version number: 現在サポートするバージョンは 1 と 2 です。

@item
(バージョン 1)

64ビット time: 拡張機能データは、1970年1月1日午前0時からの経過ナノ秒として格納されている指定の時間までのすべての変更を反映します。

@item
(バージョン 2)

NULL終端文字列: ファイルシステムモニター アプリケーションによって定義される不透明な(opaque)トークン。 拡張機能データには、そのトークンに関連するすべての変更が反映されます。

@item
32ビット bitmap size: CE_FSMONITOR_VALIDビットマップのサイズ。

@item
ewah ビットマップでは、n 番目のビットは、n 番目のインデックス エントリが CE_FSMONITOR_VALID では無いかどうかを表します。
@end itemize

@noindent

@chapheading End of Index Entry

インデックスエントリの終わり(End of Index Entry;EOIE)は、可変長インデックスエントリの終わりと拡張機能の始まりを見つけるために使用されます。プログラムコードはこれを利用して、すべてのインデックスエントリを解析しなくてもインデックス拡張をすばやく見つけることができます。

可変長キャッシュエントリやその他のインデックス拡張の前にロードできる必要があるため、この拡張機能は最後に書き込む必要があります。この拡張機能のシグネチャは @{ @samp{E}, @samp{O}, @samp{I}, @samp{E} @} です。

この拡張機能は以下から構成されます:

@itemize 

@item
32ビット インデックス エントリの末尾までのオフセット

@item
拡張機能のタイプとそのサイズをハッシュします(ただし、その内容はハッシュしません)。 例えば。 N バイト長の「TREE」拡張機能、M バイト長の「REUC」拡張機能の後に「EOIE」が続く場合、ハッシュは以下のようになります:

Hash("TREE" + <binary representation of N>
"REUC" + <binary representation of M>)
@end itemize

@noindent

@chapheading Index Entry Offset Table

インデックスエントリオフセットテーブル(Index Entry Offset Table;IEOT)は、キャッシュエントリをディスク上のフォーマットからメモリ上のフォーマットに変換する処理のマルチスレッド化を有効にすることで、インデックスをロードするための CPU コストに対処するために使用されます。 この拡張機能のシグネチャは @{ @samp{I}, @samp{E}, @samp{O}, @samp{T} @} です。

この拡張機能は以下から構成されます:

@itemize 

@item
32ビット version (現在 1)

@item
インデックスオフセットエントリの数。以下から構成されます:

@itemize 

@item
32ビット。ファイルの先頭から、このエントリブロック内の最初のキャッシュエントリまでのオフセット。

@item
32ビット。このブロック内のキャッシュエントリの数
@end itemize
@end itemize

@noindent

@chapheading Sparse Directory Entries

sparse-checkout をコーンモードで使用する場合、ツリー内の展開されたパスのリスト全体ではなく、ツリー オブジェクトをポイントすることで、インデックス内の一部のディレクトリ全体を要約できます。 このようなエントリを含むインデックスは「スパースインデックス」です。 インデックス フォーマット バージョン 4 以前は、このようなエントリを考慮して実装されていませんでした。 したがって、これらのバージョンでは、スパース ディレクトリ エントリを含むインデックスには、この拡張機能とシグネチャ @{ @samp{s}, @samp{d}, @samp{i}, @samp{r} @} が含まれます。 分割インデックス拡張機能と同様に、ツールは、この拡張機能を理解していない限り、スパースインデックスとのやり取りを避ける必要があります。

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-pack,,,Top
@chapheading Name

gitformat-pack — Gitパック形式

@noindent

@chapheading Synopsis

@display
$GIT_DIR/objects/pack/pack-.@{pack,idx@}
$GIT_DIR/objects/pack/pack-.rev
$GIT_DIR/objects/pack/pack-*.mtimes
$GIT_DIR/objects/pack/multi-pack-index
@end display


@noindent

@chapheading DESCRIPTION

Git パック形式は現在、Git のプライマリ・リポジトリ・データのほとんどを格納しています。 リポジトリの存続期間中、(もしあれば)緩いオブジェクトと小さなパックは、より大きなパック達に統合されていきます。 git-gc(1) と git-pack-objects(1) を参照してください。

パック形式は通信(over-the-wire)でも使用されます。 たとえば gitprotocol-v2(5) を参照して下さい。 そして、 gitformat-bundle(5) では他のコンテナ形式の一部です。

@noindent

@chapheading Checksums and object IDs

従来のSHA-1を使用するリポジトリでは、以下で説明するパックチェックサム、インデックスチェックサム、およびオブジェクトID(オブジェクト名)はすべてSHA-1を使用して計算されます。 同様に、SHA-256リポジトリでは、これらの値はSHA-256を使用して計算されます。

@noindent

@chapheading pack-*.pack files have the following format:

@itemize 

@item
ヘッダーは最初にあらわれ、以下のもので構成されます

@table @asis

@item  4-byte シグネチャ 
The signature is: @{@samp{P}, @samp{A}, @samp{C}, @samp{K}@}

@item  4-byte version number (network byte order) 
Gitは現在バージョン番号2または3を受け入れますが、バージョン2のみを生成します。

@item  4-byte パックに含まれるオブジェクトの数(network byte order) 
所見: このバージョンでは、パック内のオブジェクトは4Gを超えることはできず、パックも4Gを超えることはできません。
@end table

@item
ヘッダーの後には、オブジェクトエントリの数が続き、各エントリは以下のようになります

@table @asis

@item  (非デルタ化表現) 
n-byte type and length (type:3ビット幅、length: (n-1)*7+4 ビット幅)

圧縮データ

@item  (デルタ化表現) 
n-byte type and length (type:3ビット幅、length: (n-1)*7+4 ビット幅)

OBJ_REF_DELTAの場合はベースオブジェクト名、OBJ_OFS_DELTAオブジェクトの場合はパック内のデルタオブジェクトの位置からの負の相対オフセット

圧縮デルタデータ
@end table

@item
所見: 各オブジェクトの長さは可変長形式でエンコードされ、32ビットなどに制限されません。

@item
トレーラー(trailer)は、上記のすべてのパックチェックサムを記録します。
@end itemize

@noindent

@heading Object types

有効なオブジェクトタイプは以下のとおりです:

@itemize 

@item
OBJ_COMMIT (1)

@item
OBJ_TREE (2)

@item
OBJ_BLOB (3)

@item
OBJ_TAG (4)

@item
OBJ_OFS_DELTA (6)

@item
OBJ_REF_DELTA (7)
@end itemize

タイプ5は、将来の拡張用に予約されています。 タイプ0は無効です。

@noindent

@heading Size encoding

このドキュメントでは、負でない整数で、「サイズエンコーディング」(size encoding)を使用します。つまりそれは、 各バイトから、下位7ビットを使用して結果の整数を形成します。 最上位ビットが1である限り、この処理は続行されます。 MSB 0 のバイトは、最後の7ビットを提供します。これら7ビットのチャンクは連結されます。 後の値の方が上位です。

このサイズエンコーディング(size encoding)を、このドキュメントでも使用されている「オフセットエンコーディング」(offset encoding)と混同しないでください。

@noindent

@heading Deltified representation(デルタ化表現)

概念的には、commit、tree、tag、blobの4つのオブジェクトタイプしかありません。 ただし、スペースを節約するために、オブジェクトを別の「ベース」(base)オブジェクトの「デルタ」(delta)として格納できます。 これらの表現には、パックファイルでのみ有効な新しいタイプの ref-delta および ofs-delta が割り当てられます。

ofs-deltaとref-deltaはどちらも、オブジェクトを再構築するために別のオブジェクト(「ベースオブジェクト」と呼ばれる)に適用される「デルタ」を格納します。 それらの違いは、ref-deltaがベースオブジェクト名を直接エンコードすることです。 ベースオブジェクトが同じパックにある場合、ofs-deltaは代わりにパック内のベースオブジェクトのオフセットをエンコードします。

同一パックに含まれている場合は、ベースオブジェクトを削除することもできます。 ref-deltaは、パック外のオブジェクト(つまり、いわゆる「薄いパック」(thin pack)）を参照することもできます。 ただし、ディスクに保存する場合は、循環依存を回避するためにパックを自己完結型にする必要があります。

デルタデータは、ベースオブジェクトのサイズと再構築されるオブジェクトのサイズから始まります。 これらのサイズは、上記サイズエンコーディングを使用してエンコードされます。 デルタデータの残りの部分は、ベースオブジェクトからオブジェクトを再構築するための一連の命令です。 ベースオブジェクトが削除されている場合は、最初に標準形に変換する必要があります。 各命令は、完了するまでターゲットオブジェクトにどんどんデータを追加します。現時点でサポートされている命令は2つあります。1つはソースオブジェクトからバイト範囲をコピーするためのもので、もう1つは命令自体に埋め込まれた新しいデータを挿入するためのものです。

各命令の長さは可変です。 命令タイプは、最初のオクテット(訳注:1バイト(8ビット))のビット7(訳注:つまりこのバイトの最上位ビット)によって決定されます。 以下の図は、RFC 1951（Deflate compressed data format;圧縮データ形式の解凍）の規則に従います。

@noindent

@subheading ベースオブジェクトからのコピー命令

@example
+----------+---------+---------+---------+---------+-------+-------+-------+
| 1xxxxxxx | offset1 | offset2 | offset3 | offset4 | size1 | size2 | size3 |
+----------+---------+---------+---------+---------+-------+-------+-------+
@end example

これは、ソースオブジェクトからバイト範囲をコピーするための命令です。 コピー元のオフセットとコピーするバイト数をエンコードします。 オフセットとサイズはリトルエンディアンです。

すべてのオフセットバイトとサイズバイトはオプションです。 これは、小さなオフセットまたはサイズをエンコードするときに命令サイズを減らすためです。 最初のオクテットの最初の7つのビット(訳注:bit6〜0)は、次の7つのオクテットのどれが存在するかを決定します。 ビットゼロが設定されている場合、offset1が存在します。 ビット1が設定されている場合、offset2が存在します。

注意: よりコンパクトな形式は、オフセットとサイズのエンコーディングを変更しないことに注意してください。 たとえば、以下のようにoffset2のみが省略されている場合でも、offset3にはビット16〜23が含まれています。 それはoffset1の隣に続くからoffset2という訳ではなくて、(offset3の)ビット8〜15が含まれています。

@example
+----------+---------+---------+
| 10000101 | offset1 | offset3 |
+----------+---------+---------+
@end example

最もコンパクトな形式では、この命令はオフセットとサイズの両方が省略された1バイト(0x80)のみを使用し、デフォルト値はゼロになります。 もうひとつ例外があります。サイズゼロは自動的に 0x10000 に変換されます。

@noindent

@subheading 新データ追加命令

@example
+----------+============+
| 0xxxxxxx |    data    |
+----------+============+
@end example

これは、ベースオブジェクトなしでターゲットオブジェクトを構築するための命令です。続くデータがターゲットオブジェクトに追加されます。最初のオクテットの最初の7つのビット(訳注:bit6〜0)は、データのサイズをバイト単位で決定します。サイズはゼロ以外でなければなりません。

@noindent

@subheading Reserved instruction

@example
+----------+============
| 00000000 |
+----------+============
@end example

これは、将来の拡張のために予約されている命令です。

@noindent

@chapheading Original (version 1) pack-*.idx files have the following format:

@itemize 

@item
ヘッダーは、256個の4バイトのネットワークバイトオーダー整数で構成されます。このテーブルのN番目のエントリは、対応するパック内のオブジェクトの数を記録します。オブジェクト名の最初のバイトはN以下です。これは、「first-level fan-out」テーブルと呼ばれます。

@item
ヘッダーの後には、ソートされた24バイトのエントリが続きます(パック内のオブジェクトごとに1つのエントリ)。 各エントリは以下のとおりです:

@itemize 

@item
4-byte ネットワークバイトオーダー整数で、オブジェクトが格納されている場所をパックファイル先頭からのオフセットとして記録します。

@item
適切なサイズの1つのオブジェクト名。
@end itemize

@item
ファイルはトレーラーで締めくくられています:

対応するパックファイルの最後にあるパックチェックサムのコピー。

@item
上記すべてのインデックスチェックサム。
@end itemize

@noindent

@heading パックIdxファイル:

@example
        --  +--------------------------------+
fanout      | fanout[0] = 2 (for example)    |-.
table       +--------------------------------+ |
            | fanout[1]                      | |
            +--------------------------------+ |
            | fanout[2]                      | |
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
            | fanout[255] = total objects    |---.
        --  +--------------------------------+ | |
main        | offset                         | | |
index       | object name 00XXXXXXXXXXXXXXXX | | |
table       +--------------------------------+ | |
            | offset                         | | |
            | object name 00XXXXXXXXXXXXXXXX | | |
            +--------------------------------+<+ |
          .-| offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | +--------------------------------+   |
          | | offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   |
          | | offset                         |   |
          | | object name FFXXXXXXXXXXXXXXXX |   |
        --| +--------------------------------+<--+
trailer   | | packfile checksum              |
          | +--------------------------------+
          | | idxfile checksum               |
          | +--------------------------------+
          .-------.
                  |
Pack file entry: <+
@end example


パックされたオブジェクトのヘッダー:

@table @asis

@item  byte size extension bit (MSB) 
@itemize 

@item
type (next 3 bit)

@item
size0 (lower 4-bit)

@item
n-byte sizeN (MSBがセットされている限り。各7ビット) size0..sizeN form 4+7+7+..+7 ビット整数で、size0 は最も下位で、 sizeN が最も上位です。
@end itemize

@item  パックされたオブジェクトのデータ 
@itemize 

@item
DELTAでない場合は、解凍されたバイト(上記のサイズは圧縮前のサイズです)。

@item
REF_DELTAの場合、ベースオブジェクト名(上記サイズは後続のデルタデータのサイズです)。

@item
圧縮されたデルタデータ。

@item
OFS_DELTAの場合、nバイトオフセット(以下参照)は、ofs-deltaエントリのヘッダーのタイプバイトからの負のオフセットとして解釈されます(上記サイズは、後続のデルタデータのサイズです)。

@item
圧縮されたデルタデータ。
@end itemize

@item  offset encoding 
最後の1つを除くすべてにMSBが設定されたnバイト。 オフセットは、各バイトの下位7ビットを連結して作成された数値であり、n >= 2 の場合、結果に @samp{2^7 + 2^14 + ... + 2^(7*(n-1))} を加算します。
@end table

@noindent

@chapheading バージョン2 pack-*.idx ファイルは4GiBより大きいパックをサポートし、他のいくつかの再編成があります。それらの形式は以下のとおりです:

@itemize 

@item
4-byte マジックナンバー @samp{\377tOc} は、 unreasonable fanout[0] 値です。

@item
4-byte バージョン番号 (= 2)

@item
v1と同様の256エントリのファンアウトテーブル。

@item
ソートされたオブジェクト名のテーブル。 これらはオフセット値なしで一緒にパックされ、特定のオブジェクト名のバイナリ検索のキャッシュフットプリント(cache footprint)を削減します。

@item
パックされたオブジェクトデータの4バイトCRC32値のテーブル。 これはv2の新機能で、再パック中に、未検出データ破損無しで圧縮データをパックからパックに直接コピーできます。

@item
4バイトのオフセット値のテーブル(ネットワークバイトオーダー)。 これらは通常31ビットパックファイルオフセットですが、ラージオフセットは、msbitが設定された次のテーブルへのインデックスとしてエンコードされます。

@item
8バイトのオフセットエントリのテーブル(2 GiB未満のパックファイルの場合は空)。 パックファイルは、頻繁に使用されるオブジェクトを手前に配置するように編成されているため、ほとんどのオブジェクト参照はこのテーブルを参照する必要はありません。

@item
v1パックファイルと同一のトレーラー:

対応するパックファイルの最後にあるパックチェックサムのコピー。

@item
上記すべてのインデックスチェックサム。
@end itemize

@noindent

@chapheading pack-*.rev ファイルは以下の形式です:

@itemize 

@item
4-byte マジックナンバー @samp{0x52494458} (@samp{RIDX}).

@item
4-byte バージョンID(= 1)。

@item
4-byte ハッシュ機能ID(= 1:SHA-1, 2:SHA-256)。

@item
インデックス位置のテーブル(パックされたオブジェクトごとに1つ、合計 num_objects、それぞれネットワークオーダーで4バイトの符号なし整数)。パックファイル内の対応するオフセットでソートされます。

@item
トレーラーは、対応するパックファイルのチェックサムと、上記のすべてのチェックサムを含みます。
@end itemize

全ての 4-byte 数値はネットワークオーダーです。

@noindent

@chapheading pack-*.mtimes files have the format:

全ての 4バイト数はネットワーク・バイト・オーダーです。

@itemize 

@item
4バイト。マジック・ナンバー @samp{0x4d544d45} (@samp{MTME})

@item
4-byte バージョンID(= 1)。

@item
4-byte ハッシュ機能ID(= 1:SHA-1, 2:SHA-256)。

@item
4バイトの符号なし整数の表。 i 番目の値は、 対応するパック内の i 番目のオブジェクトの変更時間(mtime)であり、 辞書順(インデックス順)です。 mtimes は、 標準エポック秒をカウントします。

@item
対応するパックファイルのチェックサムと上記すべてのチェックサムを含むトレーラー (それぞれ指定されたハッシュ関数に応じた長さ)。
@end itemize

@noindent

@chapheading multi-pack-index (MIDX) ファイルの形式は以下の通り:

multi-pack-indexファイルは、複数のパックファイル(pack-files)と緩いオブジェクト(loose objects)を参照します。

MIDXにデータを追加する拡張機能を使用できるようにするために、ボディを「チャンク」に編成し、ボディの先頭にルックアップテーブルを提供します。 ヘッダーには、パックの数、ベースMIDXファイルの数、ハッシュの長さ、タイプなど、特定の長さ値達が含まれます。

全ての 4-byte 数値はネットワークオーダーです。

@noindent

@heading HEADER:

@table @asis

@item  4-byte シグネチャ 
The signature is: @{@samp{M}, @samp{I}, @samp{D}, @samp{X}@}

@item  1-byte バージョン番号 
Gitはバージョン 1 のみを書き込みまたは認識します。

@item  1-byte オブジェクトIDバージョン(= 1: SHA-1, 2: SHA-256) 
この値からオブジェクトID(OID)の長さを推測します。 ハッシュタイプがリポジトリのハッシュアルゴリズムと一致しない場合は、multi-pack-indexファイルを無視して、ユーザーに警告を表示する必要があります。

@item  1-byte チャンクの数 
チャンクの数

@item  1-byte 「ベース multi-pack-index ファイル」の数 
この値は現在のところ常にゼロです。

@item  4-byte パックファアイルの数 
パックファアイルの数
@end table

@noindent

@heading CHUNK LOOKUP:

@itemize 

@item
(C + 1) * 12 bytes はチャンクオフセットを提供します

最初の4バイトはチャンクIDです。値 0 はラベル終端です。

他の8バイトは、現在のファイルでチャンクを開始するためのオフセットを提供します。(チャンクはファイル順に提供されるため、必要に応じて次のチャンク位置を使用して長さを推測できます。)

@item
CHUNK LOOKUP は、チャンク・ベースのファイル形式の目次と一致します。 gitformat-chunk(5) を参照してください。

@item
ボディの残りのデータは一度に1つのチャンクで記述され、これらのチャンクは任意の順序で指定できます。 特に指定がない限り、チャンクは必要です。
@end itemize

@noindent

@heading CHUNK DATA:

@table @asis

@item  Packfile Names (ID: @{@samp{P}, @samp{N}, @samp{A}, @samp{M}@}) 
パックファイル名達を連結されたnullで終了する文字列として格納します。名前による高速ルックアップを行うには、パックファイルを辞書式順序でリストする必要があります。 これは、長さが4バイトの倍数であることが保証されていない唯一のチャンクであるため、アライメント上の理由から最後のチャンクにする必要があります。

@item  OID Fanout (ID: @{@samp{O}, @samp{I}, @samp{D}, @samp{F}@}) 
i番目のエントリF[i]は、最初のバイトが最大iのOIDの数を格納します。 したがって、F[255]はオブジェクトの総数を格納します。

@item  OID Lookup (ID: @{@samp{O}, @samp{I}, @samp{D}, @samp{L}@}) 
MIDX内のすべてのオブジェクトのOIDは、このチャンクに辞書式順序(lexicographic order)で格納されます。

@item  Object Offsets (ID: @{@samp{O}, @samp{O}, @samp{F}, @samp{F}@}) 
オブジェクトごとに2つの4バイト値を格納します。

@enumerate 

@item
このオブジェクトを格納するパックの pack-int-id。

@item
パック内オフセット。 すべてのオフセットが @samp{2^32} 未満(less than)の場合、 巨大オフセット・チャック(large offset chunk)は存在せず、 IDX v1 としてオフセットが格納されます。 @samp{2^32-1} を超える(larger than)オフセット値が少なくとも 1 つある場合、 巨大オフセット・チャック(large offset chunk)が存在する必要があり、 @samp{2^31-1} を超えるオフセットはそこに格納されなければなりません。 巨大オフセット・チャック(large offset chunk)が存在し、 31 番目のビットがオンの場合、 そのビットを削除すると、 このオブジェクトの 8バイト・オフセットを含む、巨大オフセット(large offsets)の行位置が判ります。
@end enumerate

@item  [オプション] Object Large Offsets (ID: @{@samp{L}, @samp{O}, @samp{F}, @samp{F}@}) 
8-byte 大きなパックファイル(large packfiles)へのオフセット。

@item  [Optional] Bitmap pack order (ID: @{@samp{R}, @samp{I}, @samp{D}, @samp{X}@}) 
MIDX 位置のリスト(MIDX 内のオブジェクトごとに 1 つ、 合計で num_objects 個、 それぞれがネットワーク・バイト順で 4 バイトの符号なし整数)で、相対的な ビットマップ/疑似パック 位置に従って並べ替えられます。
@end table

@noindent

@heading TRAILER:

@itemize 

@item
上記の内容のインデックスチェックサム。
@end itemize

@noindent

@chapheading multi-pack-index reverse indexes

パックベースのリバースインデックスと同様に、マルチパックインデックスを使用してリバースインデックスを生成することもできます。

この逆インデックスは、offset、pack-、index の位置の間でマッピングする代わりに、MIDX内のオブジェクトの位置と、MIDXが記述する疑似パック内のそのオブジェクトの位置の間でマッピングします(つまり、マルチパック逆インデックスのi番目のエントリは、i番目のオブジェクトのMIDX位置を疑似パック順に保持します)。

これらの順序の違いを明確にするために、マルチパック到達可能性ビットマップ(まだ存在していませんが、現在これを目指して開発中です)を検討してください。 各ビットはMIDX内のオブジェクトに対応する必要があるため、ビット位置からMIDX位置への効率的なマッピングが必要です。

解決策の一つは、ビットがMIDXによって格納された、oidソートされたインデックスの同じ位置を占めるようにすることです。 ただし、oidは事実上ランダムであるため、結果として得られる到達可能性ビットマップには局所性がなく、圧縮が不十分になります。 (これが、シングルパックビットマップが同じ目的で、 .idx順序ではなく、パック順序を使用する理由です。)

そのため、パックの順序に基づいてMIDX全体の順序を定義します。これにより、局所性が大幅に向上します（したがって、より効率的に圧縮されます）。 MIDX内のすべてのパックを連結して作成された疑似パックを考えることができます。 たとえば、3つのパック（a、b、c）、それぞれ10、15、および20個のオブジェクトを含むMIDXがある場合、以下のようなオブジェクトの順序を想像できます:

@example
|a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|
@end example

ここで、パックの順序はMIDXのパックリストによって定義され、各パック内のオブジェクトの順序は実際のパックファイルでの順序と同じです。

パックのリストとオブジェクトの数を考えると、その疑似パックの順序を簡単に再構築できます(たとえば、パック「a」と「b」がスロットの25を消費したため、位置27のオブジェクトは（c、1）でなければなりません)。 しかし、落とし穴があります。 オブジェクトはパック間で複製される可能性があるのです。その場合、MIDXはオブジェクトへのポインターを1つだけ格納します(したがって、ビットマップに1つのスロットのみが必要です)。

呼び出し元は、ビット位置の順にオブジェクトを読み取ることで重複を処理できますが、オブジェクトの数は直線的であり、通常のビットマップルックアップにはコストがかかりすぎます。 逆インデックスを作成すると、これが解決されます。これは、インデックスの論理的な逆であり、そのインデックスはすでに重複を削除しているためです。 ただし、その場で逆インデックスを作成すると、コストがかかる可能性があります。 パックベースの逆インデックス用のオンディスク形式がすでにあるので、MIDXの疑似パックにも再利用する事しましょう。

MIDXのオブジェクトは、疑似パックをつなぎ合わせるために次のように順序付けられます。 @samp{pack(o)} がMIDXによって @samp{o} が選択されたパックを返し、（MIDXによって保存された)数値IDに基づいてパックの順序を定義します。 @samp{offset(o)} が @samp{pack(o)} 内の @samp{o} のオブジェクトオフセットを返すようにします。 次に、@samp{o1} と` o2`を以下のように比較します:

@itemize 

@item
@samp{pack(o1)} と @samp{pack(o2)} の一方が優先され、もう一方が優先されない場合、優先される方が最初にソートされます。

(詳細に言うと、これは、MIDXビットマップがビット位置0にあるオブジェクトを含むパックをMIDXに求めることができるので、パック再利用メカニズムによって使用されるべきパックを決定することを可能にします)。

@item
@samp{pack(o1) ≠ pack(o2)} の場合、パックIDに基づいて2つのオブジェクトを降順で並べ替えます。

@item
それ以外の場合、 @samp{pack(o1) = pack(o2)} であり、オブジェクトはパック順に並べ替えられます(つまり、 @samp{offset(o1) < offset(o2)} の場合、@samp{o1} は @samp{o2} よりも先に並べ替えられます)。
@end itemize

要するに、MIDXの擬似パックは、MIDXによって保存されたパック内のオブジェクトをパック順に並べ、パックをMIDX順(優先パックが先に来る)に並べたものを重複排除して連結したものです。

MIDX の逆インデックスは、 MIDX 自体内の、オプションの @samp{RIDX} チャンクに格納されます。

@noindent

@chapheading cruft packs

残り物パック(cruft pack)機能は、 到達不能オブジェクトを削除するという Git の従来のメカニズムに代わる手段を提供します。 このドキュメントでは、 Git の刈り込み(pruning)メカニズムの概要と、 代わりに残り物パックを使用して同一のことを実現する方法について説明します。

@noindent

@heading Background

到達不能なオブジェクトをリポジトリから削除するために、 Git は @samp{git repack -Ad} を提供しています(git-repack(1) を参照)。 以下、ドキュメントから引用します:

@example
[...] 以前のパックの到達不能オブジェクトは、 古いパックに残されるのではなく、
パック解凍された緩いブジェクトになります。 [...] 到達不能なオブジェクトは、
次の `git gc` 呼び出しで通常の有効期限ルールに従って削除されます。
@end example


到達不能なオブジェクトはすぐには削除されません。 すぐに削除してしまうと、 削除しようとしているオブジェクトを参照する可能性のある後続のプッシュと競合する可能性があるためです。 代わりに、 これらの到達不能オブジェクトは緩いオブジェクトとして保存され、 期限切れウィンドウ(expiration window)より古くなるまでそのままの状態で保管されます。 期限切れになった時点で git-prune(1) で削除されます。

Git は、オブジェクトごとの mtime を追跡するために、 これらの到達不能オブジェクトを緩い(loose)オブジェクトに保存する必要があります。 これらの到達不能オブジェクトが 1 つの大きなパックに書き込まれた場合、 そのパックを(その中に含まれるオブジェクトが書き直されたため)リフレッシュするするか、 または到達不能オブジェクトの新しいパックを作成すると、 パックの mtime が更新され、 その中のオブジェクトが有効期限ウィンドウから離脱することは決してありません。 代わりに、 個々のオブジェクトの mtimes を追跡し、 すべての残り物(cruft)オブジェクトが一度に更新される状況を回避するために、 オブジェクトは緩いオブジェクトとして格納されます。

これにより、猶予期間を過ぎていない到達不能オブジェクトがリポジトリに多数含まれている場合に、望ましくない状況が発生する可能性があります。 @samp{.git/objects} の一部(shard)に大きなディレクトリがあると、 リポジトリのパフォーマンスが低下する可能性があります。 また、 到達不能なオブジェクトがとても沢山ある場合、 i ノードの枯渇につながり、 システム全体のパフォーマンスを低下させる可能性があります。 これらのオブジェクトをパックすることはできないため、 これらのリポジトリは多くの場合、 大量のディスク領域を占有します。 それらは zlib 圧縮することしかできず、デルタ・チェーンに格納することはできないためです。

@noindent

@heading Cruft packs

残り物パック(cruft pack)は、 すべての緩い(loose)オブジェクトを含む単一のパックと一緒に、 オブジェクトごとの mtimes を別のファイルに含めることで、 到達不能なオブジェクトを緩いオブジェクト状態で保存する必要をなくします。

残り物パックは、 新しいパックを生成するときに @samp{git repack --cruft} によって書き込まれます。 注意: @samp{git repack --cruft} は古典的なオールインワンの再パックであることに注意してください。 つまり、結果のパック内のすべてが到達可能であり、 他のすべては到達不能です。 @samp{--cruft} オプションを記述すると、@samp{git repack} に対して、前のステップでパックされなかったオブジェクトのみを含む別のパックを生成するように指示されます (これは、すべての到達不能オブジェクトを一緒にパックすることと同じです)。 これは以下のとおりに進行します:

@enumerate 

@item
すべてのオブジェクトを列挙し、 (a)「keep-pack に含まれていないオブジェクト」および、 (b)「mtime がトラバーサル・ヒントとしての猶予期間内にあるオブジェクト」をマークします。

@item
前のステップで収集したヒントに基づいて到達可能性のトラバーサルを実行し、 その途中ですべてのオブジェクトをパックに追加します。

@item
オブジェクトごとのタイムスタンプを記録する @samp{.mtimes} ファイルとともに、 パックを書き出します。
@end enumerate

このモードは、 残り物パック(cruft pack)を作成するように指示されたときに、 git-repack(1) によって内部的に呼び出されます。 重要なことは、コア内に保持されたパックのセットは、 再パックによって削除されないパックのセットであることで、 つまり、リポジトリの到達可能なすべてのオブジェクトが含まれています。

リポジトリに既に残り物パック(cruft pack)がある場合、 @samp{git repack --cruft} は通常、 それにオブジェクトを追加するだけです。 これに対する例外は、 @samp{git repack} に @samp{--cruft-expiration} オプションが与えられた場合です。 これにより生成された残り物パックは、 後で git-gc(1) がそれらのオブジェクトを期限切れにするのを待つ代わりに、 期限切れのオブジェクトを省略できます。

通常、 期限切れの到達不能オブジェクトの削除を担当するのは git-gc(1) です。

@noindent

@heading Caution for mixed-version environments

残り物パック(cruft pack)を含むリポジトリは、 古いバージョンの Git で引き続き動作します。 ただし、 @samp{.mtimes} ファイルを認識しない以前のバージョンの Git は、残り物パックの mtime をその中のすべてのオブジェクトの mtime として使用することに注意してください。 つまり、 Git の古い (残り物パック以前の) バージョンが @samp{.mtimes} ファイルの内容を解釈したり、読み取ったりすることを期待しないでください。

注意 Git GC実行結果のバージョンが混在していると、 到達不能なオブジェクトが完全に刈り込みされない可能性があることに注意してください。 これは以下の状況で発生する可能性があります:

@itemize 

@item
古いバージョンの Git の GC 実行は、 残り物パックの mtime を使用して、 既存の残り物パックのコンテンツを緩いオブジェクトにします。

@item
新しいバージョンのGit の GC 実行は、 これらの緩いオブジェクトを残り物パックに収集します。 @samp{.mtime} ファイルは緩いオブジェクトの実際の mtime を反映しますが、残り物パックの mtime の値は「現在」になります。
@end itemize

このプロセスを繰り返すと、 オブジェクトの mtime を現在の時刻に繰り返しリセットした結果、 到達不能オブジェクトが刈り込みされなくなります。

If you are GC-ing repositories in a mixed version environment, consider omitting the @samp{--cruft} option when using git-repack(1) and git-gc(1), and setting the @samp{gc.cruftPacks} configuration to "false" until all writers understand cruft packs.

@noindent

@heading Alternatives

この設計の注目すべき代替案は以下のとおりです:

@itemize 

@item
オブジェクトごとの mtime データの配置と、

@item
到達不能なオブジェクトの複数の残り物パックへの格納。
@end itemize

mtime データの配置においては、 @samp{.idx} 形式の複雑化を避けるために、 パックに関連付けられた新しい補助ファイルが選択されました。 @samp{.idx} 形式がオプションのデータ・チャンクのサポートを獲得したならば、 @samp{.mtimes} 形式を @samp{.idx} 自体に統合することは理にかなっているかもしれません。

複数の残り物パック(cruft pack)間(たとえば、 各再パック操作中に、 以前の残り物パックにまだ格納されていない到達不能オブジェクトのみを含む新しい残り物パックを作成)で到達不能オブジェクトを格納することは、 構築するのが非常に複雑であるため、 ここでは追求しません。 現在の実装の明らかな欠点は、 残り物パック全体を最初から書き直さなければならないことです。

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitformat-signature,,,Top
@chapheading Name

gitformat-signature — Git 暗号署名形式

@noindent

@chapheading Synopsis

@display
<[tag|commit] object header(s)>
<over-the-wire protocol>
@end display


@noindent

@chapheading DESCRIPTION

Git uses cryptographic signatures in various places, currently objects (tags, commits, mergetags) and transactions (pushes). In every case, the command which is about to create an object or transaction determines a payload from that, calls an external program to obtain a detached signature for the payload (@samp{gpg -bsa} in the case of PGP signatures), and embeds the signature into the object or transaction.

Signatures begin with an "ASCII Armor" header line and end with a tail line, which differ depending on signature type (as selected by @samp{gpg.format}, see git-config(1)). These are, for @samp{gpg.format} values:

@table @asis

@item  @samp{gpg} (PGP) 
@samp{-----BEGIN PGP SIGNATURE-----} and @samp{-----END PGP SIGNATURE-----}. Or, if gpg is told to produce RFC1991 signatures, @samp{-----BEGIN PGP MESSAGE-----} and @samp{-----END PGP MESSAGE-----}

@item  @samp{ssh} (SSH) 
@samp{-----BEGIN SSH SIGNATURE-----} and @samp{-----END SSH SIGNATURE-----}

@item  @samp{x509} (X.509) 
@samp{-----BEGIN SIGNED MESSAGE-----} and @samp{-----END SIGNED MESSAGE-----}
@end table

署名は、 通常のペイロードの一部として表示される場合もあれば(たとえば、署名されたタグには、 署名が適用されるペイロードの後に署名ブロックが追加されています)、 オブジェクト・ヘッダーの値として表示される場合もあります(たとえば、 署名されたタグをマージしたマージ・コミットは、その @samp{mergetag} ヘッダーにタグの内容全体を持ちます)。 後者の場合、オブジェクト・ヘッダーの通常の複数行書式設定規則が適用され、つまり、 2 行目以降の行には、 その行が前の行から継続していることを示すために、 SP が前に付けられます。

This is even true for an originally empty line. In the following examples, the end of line that ends with a whitespace letter is highlighted with a @samp{$} sign; if you are trying to recreate these example by hand, do not cut and paste them—they are there primarily to highlight extra whitespace at the end of some lines.

署名されたペイロードと署名の埋め込み方法は、オブジェクト応答タイプや取引に依存します。

@noindent

@chapheading Tag signatures

@itemize 

@item
作成方法: @samp{git tag -s}

@item
ペイロード: annotated tag object

@item
埋め込み: 署名されていないタグオブジェクトに署名を追加します

@item
example: 件名が @samp{signedtag} のタグ @samp{signedtag}
@end itemize

@example
object 04b871796dc0420f8e7561a895b52484b701d51a
type commit
tag signedtag
tagger C O Mitter <committer@@example.com> 1465981006 +0000

signed tag

signed tag message body
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJXYRhOAAoJEGEJLoW3InGJklkIAIcnhL7RwEb/+QeX9enkXhxn
rxfdqrvWd1K80sl2TOt8Bg/NYwrUBw/RWJ+sg/hhHp4WtvE1HDGHlkEz3y11Lkuh
8tSxS3qKTxXUGozyPGuE90sJfExhZlW4knIQ1wt/yWqM+33E9pN4hzPqLwyrdods
q8FWEqPPUbSJXoMbRPw04S5jrLtZSsUWbRYjmJCHzlhSfFWW4eFd37uquIaLUBS0
rkC3Jrx7420jkIpgFcTI2s60uhSQLzgcCwdA2ukSYIRnjg/zDkj8+3h/GaROJ72x
lZyI6HWixKJkWw8lE9aAOD9TmTW9sFJwcVAzmAuFX2kUreDUKMZduGcoRYGpD7E=
=jpXa
-----END PGP SIGNATURE-----
@end example


@itemize 

@item
検証方法: @samp{git verify-tag [-v]} または @samp{git tag -v}
@end itemize

@example
gpg: Signature made Wed Jun 15 10:56:46 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia <discord@@example.net>"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
object 04b871796dc0420f8e7561a895b52484b701d51a
type commit
tag signedtag
tagger C O Mitter <committer@@example.com> 1465981006 +0000

signed tag

signed tag message body
@end example


@noindent

@chapheading Commit signatures

@itemize 

@item
作成方法: @samp{git commit -S}

@item
ペイロード: commit object

@item
埋め込み: ヘッダーエントリ @samp{gpgsig} (コンテンツの前にスペースがあります)

@item
example: 件名`signed commit` を伴ってコミット
@end itemize

@example
tree eebfed94e75e7760540d1485c740902590a00332
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor <author@@example.com> 1465981137 +0000
committer C O Mitter <committer@@example.com> 1465981137 +0000
gpgsig -----BEGIN PGP SIGNATURE-----
 Version: GnuPG v1
 $
 iQEcBAABAgAGBQJXYRjRAAoJEGEJLoW3InGJ3IwIAIY4SA6GxY3BjL60YyvsJPh/
 HRCJwH+w7wt3Yc/9/bW2F+gF72kdHOOs2jfv+OZhq0q4OAN6fvVSczISY/82LpS7
 DVdMQj2/YcHDT4xrDNBnXnviDO9G7am/9OE77kEbXrp7QPxvhjkicHNwy2rEflAA
 zn075rtEERDHr8nRYiDh8eVrefSO7D+bdQ7gv+7GsYMsd2auJWi1dHOSfTr9HIF4
 HJhWXT9d2f8W+diRYXGh4X0wYiGg6na/soXc+vdtDYBzIxanRqjg8jCAeo1eOTk1
 EdTwhcTZlI0x5pvJ3H0+4hA2jtldVtmPM4OTB0cTrEWBad7XV6YgiyuII73Ve3I=
 =jKHM
 -----END PGP SIGNATURE-----

signed commit

signed commit message body
@end example


@itemize 

@item
検証方法: @samp{git verify-commit [-v]} (または @samp{git show --show-signature})
@end itemize

@example
gpg: Signature made Wed Jun 15 10:58:57 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia <discord@@example.net>"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
tree eebfed94e75e7760540d1485c740902590a00332
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor <author@@example.com> 1465981137 +0000
committer C O Mitter <committer@@example.com> 1465981137 +0000

signed commit

signed commit message body
@end example


@noindent

@chapheading Mergetag signatures

@itemize 

@item
作成方法: 署名されたタグ上で @samp{git merge}

@item
ペイロード/埋め込み: 署名されたタグオブジェクト全体が、ヘッダーエントリ @samp{mergetag} として(マージ)コミットオブジェクトに埋め込まれます

@item
example: 上記のように署名されたタグ @samp{signedtag} のマージ
@end itemize

@example
tree c7b1cff039a93f3600a1d18b82d26688668c7dea
parent c33429be94b5f2d3ee9b0adad223f877f174b05d
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor <author@@example.com> 1465982009 +0000
committer C O Mitter <committer@@example.com> 1465982009 +0000
mergetag object 04b871796dc0420f8e7561a895b52484b701d51a
 type commit
 tag signedtag
 tagger C O Mitter <committer@@example.com> 1465981006 +0000
 $
 signed tag
 $
 signed tag message body
 -----BEGIN PGP SIGNATURE-----
 Version: GnuPG v1
 $
 iQEcBAABAgAGBQJXYRhOAAoJEGEJLoW3InGJklkIAIcnhL7RwEb/+QeX9enkXhxn
 rxfdqrvWd1K80sl2TOt8Bg/NYwrUBw/RWJ+sg/hhHp4WtvE1HDGHlkEz3y11Lkuh
 8tSxS3qKTxXUGozyPGuE90sJfExhZlW4knIQ1wt/yWqM+33E9pN4hzPqLwyrdods
 q8FWEqPPUbSJXoMbRPw04S5jrLtZSsUWbRYjmJCHzlhSfFWW4eFd37uquIaLUBS0
 rkC3Jrx7420jkIpgFcTI2s60uhSQLzgcCwdA2ukSYIRnjg/zDkj8+3h/GaROJ72x
 lZyI6HWixKJkWw8lE9aAOD9TmTW9sFJwcVAzmAuFX2kUreDUKMZduGcoRYGpD7E=
 =jpXa
 -----END PGP SIGNATURE-----

Merge tag 'signedtag' into downstream

signed tag

signed tag message body

# gpg: Signature made Wed Jun 15 08:56:46 2016 UTC using RSA key ID B7227189
# gpg: Good signature from "Eris Discordia <discord@@example.net>"
# gpg: WARNING: This key is not certified with a trusted signature!
# gpg:          There is no indication that the signature belongs to the owner.
# Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
@end example


@itemize 

@item
検証方法: 検証は、デフォルトでマージコミットメッセージに埋め込まれています。 代替手段として @samp{git show --show-signature} を使用します:
@end itemize

@example
commit 9863f0c76ff78712b6800e199a46aa56afbcbd49
merged tag 'signedtag'
gpg: Signature made Wed Jun 15 10:56:46 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia <discord@@example.net>"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
Merge: c33429b 04b8717
Author: A U Thor <author@@example.com>
Date:   Wed Jun 15 09:13:29 2016 +0000

    Merge tag 'signedtag' into downstream

    signed tag

    signed tag message body

    # gpg: Signature made Wed Jun 15 08:56:46 2016 UTC using RSA key ID B7227189
    # gpg: Good signature from "Eris Discordia <discord@@example.net>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node gitglossary,,,Top
@chapheading Name

gitglossary — Git用語集

@noindent

@chapheading Synopsis

*

@noindent

@chapheading DESCRIPTION

@table @asis

@item  alternate object database 
代役(alternate)メカニズムを介して、 リポジトリ (@pxref{[def_repository]}) は オブジェクトデータベース (@pxref{[def_object_database]}) の一部を "alternate" (代役) 呼ばれる別のオブジェクトデータベースから継承できます。

@item  bare repository 
ベアリポジトリは通常、適切な名前のディレクトリ (@pxref{[def_directory]})で、接尾辞は @samp{.git} で、リビジョン管理下にあるファイルのローカルでチェックアウトされたコピーはありません。つまり、通常は非表示の @samp{.git} サブディレクトリに存在するすべてのGit管理ファイルと制御ファイルは、代わりに @samp{repository.git} ディレクトリに直接存在し、他のファイルは存在せず、チェックアウトされません。通常、公開リポジトリの発行者は、ベアリポジトリを利用可能にします。

@item  blob object(ブロブオブジェクト) 
型の無いオブジェクト (@pxref{[def_object]})。例:ファイルの中身。

@item  branch 
A "branch" is a line of development. The most recent commit (@pxref{[def_commit]}) on a branch is referred to as the tip of that branch. The tip of the branch is referenced (@pxref{[def_ref]}) by a branch head (@pxref{[def_head]}), which moves forward as additional development is done on the branch. A single Git repository (@pxref{[def_repository]}) can track an arbitrary number of branches, but your working tree (@pxref{[def_working_tree]}) is associated with just one of them (the "current" or "checked out" branch), and HEAD (@pxref{[def_HEAD]}) points to that branch.

@item  cache 
廃止。 index (@pxref{[def_index]}) を使ってください。

@item  chain(チェーン,チェイン) 
オブジェクトのリスト。リスト内の各 オブジェクト (@pxref{[def_object]}) には、その後ろへの参照が含まれます(たとえば、 コミット (@pxref{[def_commit]}) の後ろはその 親 (@pxref{[def_parent]}) の1つである可能性があります)。

@item  changeset 
"コミット (@pxref{[def_commit]})" の BitKeeper/cvsps での言い方です。 Git は変更(change)ではなく状態(state)を保存するため、Gitでコミットを「changeset」と呼ぶのはナンセンスです。

@item  checkout 
作業ツリー (@pxref{[def_working_tree]})の全部または一部をオブジェクトデータベース (@pxref{[def_object_database]})のツリーオブジェクト (@pxref{[def_tree_object]})またはブロブ (@pxref{[def_blob_object]})で更新し、作業ツリー全体が新しいブランチ (@pxref{[def_branch]})を指している場合は、インデックス (@pxref{[def_index]})とHEAD (@pxref{[def_HEAD]})を更新する操作。

@item  cherry-picking(チェリーピック,チェリーピッキング) 
SCM (@pxref{[def_SCM]}) の専門用語では、 "cherry pick" (つまみ食い)とは、一連の変更(通常はコミット)から変更のサブセットを選択し、それらを別のコードベースの上に新しい一連の変更として記録することを意味します。Gitでは、これは "git cherry-pick" コマンドによって実行され、既存のコミット (@pxref{[def_commit]})によって導入された変更を抽出し、現在のブランチ (@pxref{[def_branch]})の先端に基づいてそれを新しいコミットとして記録します。

@item  clean 
現在のヘッド (@pxref{[def_head]})が参照するリビジョン (@pxref{[def_revision]})と作業ツリー (@pxref{[def_working_tree]})が完全に一致(correspond)しているのであれば、その作業ツリー (@pxref{[def_working_tree]})はクリーンです。「dirty (@pxref{[def_dirty]})」も参照下さい。

@item  commit 
名詞として: Gitの履歴における一つのポイント。プロジェクトの履歴全体は、相互に関連する一連のコミットとして表されます。「コミット」という言葉は、他のリビジョン管理システムが「リビジョン」または「バージョン」という言葉を使用するのと同じ場所で、Gitによってよく使用されます。 コミットオブジェクト (@pxref{[def_commit_object]}) の省略形としても使用されます。

動詞として(コミットする): インデックス (@pxref{[def_index]})の現在の状態を表す新しいコミットを作成し、その新しいコミットをポイントするようにHEAD (@pxref{[def_HEAD]})を進めることにより、プロジェクトの状態の新しいスナップショットをGit履歴に保存する操作。

@item  commit graph concept, representations and usage 
A synonym for the DAG (@pxref{[def_DAG]}) structure formed by the commits in the object database, referenced (@pxref{[def_ref]}) by branch tips, using their chain (@pxref{[def_chain]}) of linked commits. This structure is the definitive commit graph. The graph can be represented in other ways, e.g. the "commit-graph" file (@pxref{[def_commit_graph_file]}).

@item  commit-graph file 
The "commit-graph" (normally hyphenated) file is a supplemental representation of the commit graph (@pxref{[def_commit_graph_general]}) which accelerates commit graph walks. The "commit-graph" file is stored either in the .git/objects/info directory or in the info directory of an alternate object database.

@item  commit object 
親 (@pxref{[def_parent]})、コミッター、作者、日付、保存されたリビジョンの最上位ディレクトリ (@pxref{[def_directory]})に対応するツリーオブジェクト (@pxref{[def_tree_object]})など、特定のリビジョン (@pxref{[def_revision]})に関する情報を含むオブジェクト (@pxref{[def_object]})。

@item  commit-ish (also committish)(コミットっぽい;コミット風) 
コミットオブジェクト (@pxref{[def_commit_object]})または、コミットオブジェクト (@pxref{[def_commit_object]})に再帰的に逆参照可能なオブジェクト (@pxref{[def_object]})。 コミットオブジェクト (@pxref{[def_commit_object]})や、コミットオブジェクト (@pxref{[def_commit_object]})を指すタグオブジェクト (@pxref{[def_tag_object]})や、コミットオブジェクト (@pxref{[def_commit_object]})を指すタグオブジェクト (@pxref{[def_tag_object]})を指すタグオブジェクト (@pxref{[def_tag_object]})などは全てcommit-ish(commit-ishes)です。

@item  core Git 
Gitの基本的なデータ構造とユーティリティ。これは、限定的なソースコード管理ツールのみです。

@item  DAG 
有向非巡回グラフ(Directed acyclic graph)。 コミットオブジェクト (@pxref{[def_commit_object]}) は、(有向の)親を持ち、コミットオブジェクトのグラフが非巡回(同じ オブジェクト (@pxref{[def_object]}) で開始・終了する チェイン (@pxref{[def_chain]}) はありません)であるため有向非巡回グラフを形成します。

@item  dangling object 
(ぶらぶら揺れるオブジェクト)他の到達不能オブジェクト (@pxref{[def_unreachable_object]})からでも到達できない到達不能オブジェクト (@pxref{[def_unreachable_object]})。 danglingオブジェクトには、リポジトリ (@pxref{[def_repository]})内の任意のrefまたはオブジェクト (@pxref{[def_object]})からの参照はありません。

@item  detached HEAD 
通常、HEAD (@pxref{[def_HEAD]})はブランチ (@pxref{[def_branch]})の名前を格納し、HEADが示す履歴を操作するコマンドは、HEADが指すブランチの先端につながる履歴を操作します。 ただし、Gitでは、必ずしも特定のブランチの先端ではない任意のコミット (@pxref{[def_commit]})をチェックアウト (@pxref{[def_checkout]})することもできます。このような状態のHEADを「detached」(切り離されている、デタッチされている)と呼びます。

注意: 現在のブランチの履歴を操作するコマンド(たとえば、その上に新しい履歴を構築するための @samp{git commit})は、HEADがデタッチされている間も機能することに注意してください。それらは、ブランチに影響を与えることなく、更新された履歴の先端を指すようにHEADを更新します。現在のブランチに関する情報を更新または照会するコマンド(たとえば、現在のブランチが統合するリモートトラッキングブランチを設定する @samp{git branch --set-upstream-to})は、この状態で問い合わせる(実際の)現在のブランチがないため、明らかに機能しません。

@item  directory 
あなたが "ls" で得られる一覧の事 :-)

@item  dirty 
作業ツリー (@pxref{[def_working_tree]})で、現在のブランチ (@pxref{[def_branch]})に対してコミット (@pxref{[def_commit]})されてない変更が含まれている場合、「作業ツリー (@pxref{[def_working_tree]})はダーティーである」と言われます。

@item  evil merge 
邪悪なマージとは、どの 親 (@pxref{[def_parent]}) にも表示されない変更を導入する マージ (@pxref{[def_merge]}) です。

@item  fast-forward 
fast-forward(早送り)は、とあるリビジョン (@pxref{[def_revision]})に、その子孫である別のブランチ (@pxref{[def_branch]})の変更をマージする特殊なタイプのマージ (@pxref{[def_merge]})です。このような場合、新しいマージ (@pxref{[def_merge]})コミット (@pxref{[def_commit]})を行うのではなく、マージするブランチと同じリビジョンを指すようにブランチを更新するだけです。これは、リモートリポジトリ (@pxref{[def_repository]})のリモート追跡ブランチ (@pxref{[def_remote_tracking_branch]})で頻繁に発生します。

@item  fetch 
ブランチ (@pxref{[def_branch]})をフェッチするということは、リモートリポジトリ (@pxref{[def_repository]})からブランチのhead ref (@pxref{[def_head_ref]})を取得して、ローカルのオブジェクトデータベース (@pxref{[def_object_database]})に欠落しているオブジェクトを見つけ、そして欠落したオブジェクトを取得することを意味します。 git-fetch(1) も参照してください。

@item  file system 
リーナス・トーバルズは当初、Gitをユーザー空間ファイルシステム、つまりファイルとディレクトリを保持するインフラストラクチャとして設計しました。これにより、Gitの効率と速度が保証されました。

@item  Git archive 
リポジトリ (@pxref{[def_repository]}) の同義語(arch people 向け)。

@item  gitfile 
実際のリポジトリであるディレクトリを指す、作業ツリーのルートにあるプレーンファイル @samp{.git}

@item  grafts 
graftsは、コミットの偽の祖先情報を記録することで、他の点では異なる2つの開発ラインを結合できます。こうすることで、あるコミット (@pxref{[def_commit]})が持つ親 (@pxref{[def_parent]})の組を、コミット作成時に記録されたものとは異なるものとして Git に見せかけることができるのです。これは @samp{.git/info/grafts} ファイルを介して構成されます。

注意: graftsメカニズムは時代遅れであり、リポジトリ間でオブジェクトを転送する際に問題が発生する可能性があることに注意してください。 同じことを行うためのより柔軟で堅牢なシステムについては、 git-replace(1) を参照してください。

@item  hash 
Gitの文脈では オブジェクト名 (@pxref{[def_object_name]}) と同義語。

@item  head 
ブランチ (@pxref{[def_branch]}) の先端にある コミット (@pxref{[def_commit]}) への、 名付けられた参照 (@pxref{[def_ref]}) です。パックされた参照を使用する場合を除いて、headは @samp{$GIT_DIR/refs/heads/} ディレクトリのファイルに保存されます。 (linkgit: git-pack-refs[1] を参照してください。)

@item  HEAD 
現在のブランチ (@pxref{[def_branch]})。 より詳細に言うと、あなたの作業ツリー (@pxref{[def_working_tree]})は通常、HEADによって参照されるツリーの状態から派生します。HEADは、リポジトリ内のhead (@pxref{[def_head]})達のうちの一つへの参照です。ただし、detached HEAD (@pxref{[def_detached_HEAD]})をの場合は、任意のコミットを直接参照しています。

@item  head ref 
head (@pxref{[def_head]}) の同義語。

@item  hook 
いくつかのGitコマンドの通常の実行中に、開発者が機能を追加したりチェックしたりできるようにするオプションのスクリプトを呼び出します。通常、フックを使用すると、コマンドを事前に確認して中止することができ、そしてまた、操作の完了後に事後通知を行うことができます。フックスクリプトは @samp{$GIT_DIR/hooks/} ディレクトリにあり、ファイル名から @samp{.sample} サフィックスを削除するだけで有効になります。以前のバージョンのGitでは、それらを実行可能にする必要がありました。

@item  index 
状態情報を含むファイルのコレクションで、その内容はオブジェクトとして保存されます。インデックスは、あなたの作業ツリー (@pxref{[def_working_tree]})の保存バージョンです。正直なところ、これには、マージ (@pxref{[def_merge]})のときに使用される、作業ツリーの2番目および3番目のバージョンを含めることもできます。

@item  index entry 
インデックス (@pxref{[def_index]})に保存されている特定のファイルに関する情報。マージ (@pxref{[def_merge]})が開始されたが、まだ終了していない場合(つまり、インデックスにそのファイルの複数のバージョンが含まれている場合)、インデックスエントリをマージ解除(unmerge)できます。

@item  master 
デフォルトの開発 ブランチ (@pxref{[def_branch]}) 。 Git リポジトリ (@pxref{[def_repository]}) を作成するたびに、「master」という名前のブランチが作成され、アクティブなブランチになります。 ほとんどのローカル開発に含まれていますが、これは純粋に慣例によるものであり、必須ではありません。

@item  merge 
動詞として: 別のブランチ (@pxref{[def_branch]})(あるいは外部のリポジトリ (@pxref{[def_repository]})から)の内容を現在のブランチに取り込むこと。マージされたブランチが別のリポジトリからのものである場合、これは最初にリモートブランチをフェッチ (@pxref{[def_fetch]})し、次に結果を現在のブランチにマージすることによって行われます。このフェッチ操作とマージ操作の組み合わせは、プル(pull) (@pxref{[def_pull]})と呼ばれます。マージは、ブランチが分岐してから行われた変更を識別し、それらすべての変更を一緒に適用する自動プロセスによって実行されます。変更が競合する場合は、マージを完了するために手動による介入が必要になる場合があります。

名詞として: fast-forward (@pxref{[def_fast_forward]})でない限り、マージ成功の結果として、マージされたブランチ (@pxref{[def_branch]})の先端を親 (@pxref{[def_parent]})に持つ新しいコミット (@pxref{[def_commit]})が作成されます。このコミットは「マージコミット」と呼ばれます。または単に「マージ」と呼ばれることもあります。

@item  object(オブジェクト) 
Gitの保管ユニット(unit of storage)。その内容による SHA-1 (@pxref{[def_SHA1]}) によって一意に識別されます。したがって、オブジェクトを変更することはできません。

@item  object database 
「オブジェクト」の組を格納し、個々のオブジェクト (@pxref{[def_object]})はそのオブジェクト名 (@pxref{[def_object_name]})によって識別されます。オブジェクトは通常、 @samp{$GIT_DIR/objects/} にあります。

@item  object identifier (oid) 
object name (@pxref{[def_object_name]}) (オブジェクト名)の同義語

@item  object name(オブジェクト名) 
オブジェクト> の一意の識別子。オブジェクト名は通常、40文字の16進文字列で表されます。一般に <<def_SHA1 (@pxref{[def_object]}) とも呼ばれます。

@item  object type(オブジェクトタイプ) 
「コミット (@pxref{[def_commit_object]}) 識別子」または「ツリー (@pxref{[def_tree_object]}) 識別子」または「タグ (@pxref{[def_tag_object]}) 識別子」または「ブロブ (@pxref{[def_blob_object]}) 識別子」のいずれかで、 オブジェクト (@pxref{[def_object]}) のタイプを表します。

@item  octopus 
3つ以上(more than two)のブランチをマージします

@item  origin 
デフォルトの上流(upstream)リポジトリ (@pxref{[def_repository]})。ほとんどのプロジェクトには、追跡する上流プロジェクトが少なくとも1つあります。デフォルトでは、「origin」がその目的で使用されます。新しい上流更新分は、 origin/name-of-upstream-branch という名前の リモート追跡ブランチ (@pxref{[def_remote_tracking_branch]})にフェッチされます。これは、 @samp{git branch-r} を使用して確認できます。

@item  overlay 
@samp{cp -R} が宛先ディレクトリの内容を更新するのと同様に、ファイルを更新して作業ディレクトリに追加するのみで削除を行いません。これは、インデックス (@pxref{[def_index]})またはツリー風の何か(tree-ish) (@pxref{[def_tree-ish]})からファイルをチェックアウトするときのcheckout (@pxref{[def_checkout]})のデフォルトモードです。対照的に、オーバーレイなしモード(no-overlay mode)では、 @samp{rsync --delete} と同様に、ソース側に存在しない追跡ファイルは削除されます。

@item  pack 
1つのファイルに圧縮されたオブジェクトの組(スペースを節約するため、またはそれらを効率的に送信するため)。

@item  pack index 
パックの内容に効率的にアクセスするのに役立つ、パック (@pxref{[def_pack]})内のオブジェクトの識別子とその他の情報のリスト。

@item  pathspec 
(パススペック):Gitコマンドでパスを制限するために使用されるパターン。

pathspec は、「git ls-files」や「git ls-tree」や「git add」や「git grep」や「git diff」や「git checkout」や、ツリーまたは作業ツリー(working tree)のサブセットへの操作の為にスコープを制限する他の多くのコマンドの、コマンドラインで使用されます。 パスが現在のディレクトリまたはトップレベルのどちらを基準にしているかについては、 各コマンドのドキュメントを参照してください。 pathspec の構文は以下のとおりです:

@itemize 

@item
どのパスもそれ自体と一致します

@item
最後がスラッシュであるpathspecは、ディレクトリプレフィックスを表します。そのpathspecのスコープは、そのサブツリーに制限されています。

@item
pathspecの残りの部分は、pathnameの残りの部分のパターンです。 ディレクトリプレフィックスに関連するパスは、 fnmatch(3) を使用してそのパターンと照合されます。特に、 @samp{*} と @samp{?} はディレクトリ区切り文字と一致させる事ができます。
@end itemize

たとえば、 @samp{Documentation/*.jpg} は、 @samp{Documentation/chapter_1/figure_1.jpg} を含む、Documentationサブツリー内のすべての @samp{.jpg} ファイルと一致します。

コロン(@samp{:})で始まるpathspecには特別な意味があります。短い形式では、先頭のコロン(@samp{:})の後に0個以上の「魔法記号」(magic signature)(オプションで別のコロン(@samp{:})で終了)が続き、残りはパスと照合するパターンです。「魔法記号」は、英数字、グロブ、正規表現の特殊文字でもコロンでもないASCII記号で構成されます。パターンが「魔法記号」シンボルセットに属さず、コロンではない文字で始まる場合、「魔法記号」を終了するオプションのコロンは省略できます。

長い形式では、先頭のコロン(@samp{:})の後に開き括弧(@samp{(}) 、0個以上の「魔法単語」(magic words)のコンマ区切りリスト、および閉じ括弧(@samp{)}) が続き、残りは次のパターンです。パスと一致します。

コロンのみのpathspecは、「pathspecが無い」ことを意味します。 この形式は、他のpathspecと組み合わせないでください。

@table @asis

@item  top 
魔法単語 @samp{top} (魔法記号: @samp{/})は、サブディレクトリ内からコマンドを実行している場合でも、作業ツリーのルートからパターンを一致させます。

@item  literal 
@samp{*} または @samp{?} などのパターンのワイルドカードはリテラル文字として扱われます。

@item  icase 
(英文字の)大文字小文字区別せずにマッチ

@item  glob 
Gitはパターンを、 FNM_PATHNAMEフラグを指定した fnmatch(3) に消費されるのに適したシェルグロブとして扱います。パターン内のワイルドカードは、パス名内の / と一致しません。 たとえば、「Documentation/*.html」は「Documentation/git.html」と一致しますが、「Documentation/ppc/ppc.html」または「tools/perf/Documentation/perf.html」とは一致しません。

フルパス名と一致するパターンの2つの連続するアスタリスク @samp{**} は、特別な意味を持つ場合があります:

@itemize 

@item
先頭の @samp{**} の後にスラッシュが続く場合は、すべてのディレクトリで一致することを意味します。たとえば、 @samp{**/foo} は、パターン @samp{foo} と同じように、ファイルまたはディレクトリ @samp{foo} のどこにでも一致します。 @samp{**/foo/bar} は、ディレクトリ @samp{foo} の直下にあるファイルまたはディレクトリ @samp{bar} と一致します。

@item
末尾の @samp{/**} は、内部のすべてに一致します(matches everything inside)。たとえば、 @samp{abc/**} は、 @samp{.gitignore} ファイルの場所を基準にして、ディレクトリ "abc" 内のすべてのファイルと無限の深さで一致します。

@item
スラッシュの後に2つの連続するアスタリスクが続く場合、スラッシュは0個以上のディレクトリに一致します。 たとえば、 @samp{a/**/b} は @samp{a/b} 、 @samp{a/x/b} 、@samp{a/x/y/b} などと一致します。

@item
他の連続するアスタリスクは無効と見なされます。

グロブ魔法はリテラル魔法と互換性がありません。
@end itemize

@item  attr 
@samp{attr:} の後には、スペースで区切られた「属性要件」(attribute requirements)のリストがあります。パスが一致すると見なされるには、これらすべてを満たす必要があります。これは、通常の非魔法pathspecパターンマッチングに追加されます。 gitattributes(5) 参照。

パスの各属性要件は、以下のいずれかの形式を取ります:

@itemize 

@item
@samp{ATTR} では、属性 @samp{ATTR} を設定する必要があります。

@item
@samp{-ATTR} では、属性 @samp{ATTR} が設定されていない必要があります。

@item
@samp{ATTR = VALUE} では、属性 @samp{ATTR} を文字列 @samp{VALUE} に設定する必要があります。

@item
@samp{!ATTR} では、属性 @samp{ATTR} が指定されていない必要があります。

注意: ツリーオブジェクトと照合する場合、属性は、指定されたツリーオブジェクトからではなく、作業ツリーから取得されることに注意してください。
@end itemize

@item  exclude 
パスが非除外pathspecと一致すると、すべての除外pathspec(魔法記号: @samp{!} またはその同義語 @samp{^})が実行されます。一致する場合、パスは無視されます。非除外pathspecがない場合、pathspecなしで呼び出されたかのように、除外が結果セットに適用されます。
@end table

@item  parent(親) 
コミットオブジェクト (@pxref{[def_commit_object]})には、開発ラインで論理的に前にあったもののリスト、つまり親が含まれています(あるいは、前・親が無い場合は空です)。

@item  pickaxe 
pickaxe (@pxref{[def_pickaxe]})(ピカクス;十字鋤;鶴嘴;つるはし)という用語は、特定のテキスト文字列を追加または削除する変更を選択するのに役立つdiffcoreルーチンのオプションを指します。 @samp{--pickaxe-all} オプションを使用すると、特定のテキスト行などを導入または削除した完全なチェンジセット (@pxref{[def_changeset]})を表示するために使用できます。 git-diff(1) を参照してください。

@item  plumbing(配管) 
core Git (@pxref{[def_core_git]}) のキュートな呼び方。

@item  porcelain(磁器) 
core Git (@pxref{[def_core_git]})に依存するプログラムとプログラムスイートのキュートな名前で、コアGitへの高レベルのアクセスを示します。磁器(porcelain)は、配管(plumbing) (@pxref{[def_plumbing]})よりも多くのSCM (@pxref{[def_SCM]})インターフェースを公開します。

@item  per-worktree ref 
グローバルではなく、 worktree (@pxref{[def_worktree]})ごとのref。これは現在、HEAD (@pxref{[def_HEAD]})と @samp{refs/bisect/} で始まるすべてのrefのみですが、今後、他の普通でないrefが含まれる可能性があります。

@item  pseudoref 
疑似参照(pseudoref)は @samp{$GIT_DIR} の下にあるファイルのクラスであり、rev-parseしたときrefのように動作しますが、それはgitによって特別扱されます。疑似参照はすべて大文字の名前を持ち、かつ、常にSHA-1 (@pxref{[def_SHA1]})とそれに続く空白(whitespace)で構成される行で始まります。したがって、HEADは疑似参照ではありません。なぜならHEADはシンボリック参照である場合があるためです。オプションで、いくつかの追加データが含まれる場合があります。例としては @samp{MERGE_HEAD} と @samp{CHERRY_PICK_HEAD} があります。 per-worktree refs (@pxref{[def_per_worktree_ref]}) とは異なり、これらのファイルはシンボリックrefにすることはできず、reflogを含めることはできません。 また、通常のref更新機構を使用して更新することもできません。代わりに、ファイルに直接書き込むことによって更新されます。ただし、それらはrefであるかのように読み取ることができるため、 @samp{git rev-parse MERGE_HEAD} は機能します。

@item  pull 
ブランチ (@pxref{[def_branch]})をプルするとは、それをフェッチ (@pxref{[def_fetch]})しマージ (@pxref{[def_merge]})することを意味します。 git-pull(1) も参照してください。

@item  push 
ブランチ (@pxref{[def_branch]})をプッシュするとは、リモートリポジトリ (@pxref{[def_repository]})からブランチのヘッド参照 (@pxref{[def_head_ref]})を取得し、それがブランチのローカルヘッド参照の祖先であるかどうかを確認し、そしてその場合ローカルヘッド参照から到達可能 (@pxref{[def_reachable]})であり、かつ、リモートリポジトリに欠落しているすべてのオブジェクトを、リモートオブジェクトデータベース (@pxref{[def_object_database]})に持っていき、リモートヘッド参照を更新します。リモートヘッド (@pxref{[def_head]})がローカルヘッドの祖先でない場合、プッシュは失敗します。

@item  reachable(到達可能) 
特定のコミット (@pxref{[def_commit]})のすべての祖先は、その特定のコミットから到達可能(reachable)であると言われます。より一般的には、タグ (@pxref{[def_tag]})付けしたものだったり、親またはツリーへのコミットオブジェクト (@pxref{[def_commit_object]})だったり、ツリー (@pxref{[def_tree_object]})に含まれるツリーやブロブだったり、をたどるチェーン (@pxref{[def_chain]})によって、あるオブジェクト (@pxref{[def_object]})から別のオブジェクト (@pxref{[def_object]})に到達できる場合に到達が可能です。

@item  reachability bitmaps 
Reachability bitmaps store information about the reachability (@pxref{[def_reachable]}) of a selected set of commits in a packfile, or a multi-pack index (MIDX), to speed up object search. The bitmaps are stored in a ".bitmap" file. A repository may have at most one bitmap file in use. The bitmap file may belong to either one pack, or the repository’s multi-pack index (if it exists).

@item  rebase 
一連の変更をブランチ (@pxref{[def_branch]})から別のベースに再適用し、そのブランチのヘッド (@pxref{[def_head]})を再適用した結果にリセットします。

@item  ref 
オブジェクト名または別のrefを指す @samp{refs/} で始まる名前(例: @samp{refs/heads/master};別のrefを指すrefは シンボリックref (@pxref{[def_symref]}) と呼ぶ)。便宜上、Gitコマンドの引数として使用する場合は @samp{refs/} を省略できる場合があります。詳細については gitrevisions(7) を参照してください。 refs は repository (@pxref{[def_repository]}) に保存されます。

ref名前空間は階層的です。さまざまなサブ階層がさまざまな目的で使用されます(たとえば、 @samp{refs/heads/} 階層はローカルブランチを表すために使用されます)。

@samp{refs/} で始まらない特別な目的のrefがいくつかあります。最も注目すべき例は @samp{HEAD} です。

@item  reflog 
reflogは、refのローカルの「履歴」を示します。 つまり、このリポジトリの最後の3番目のリビジョンが何であったか、およびこのリポジトリの昨日の午後9時14分時点での「現在の状態」が何であったかを知ることができます。詳細については git-reflog(1) を参照してください。

@item  refspec 
「refspec」は、フェッチ (@pxref{[def_fetch]})やプッシュ (@pxref{[def_push]})によって使用され、リモートref (@pxref{[def_ref]})とローカルrefの間のマッピングを記述します。

@item  remote repository 
同じプロジェクトを追跡するために使用されるが、別の場所にあるリポジトリ (@pxref{[def_repository]})。リモートと通信するには、フェッチ (@pxref{[def_fetch]})またはプッシュ (@pxref{[def_push]})を参照してください。

@item  remote-tracking branch 
別のリポジトリ (@pxref{[def_repository]})からの変更を追跡するために使用されるref (@pxref{[def_ref]})。 これは通常、 @samp{refs/remotes/foo/bar} のように見え(「foo」という名前のリモートで「bar」という名前のブランチを追跡することを示します)、構成されたフェッチrefspec (@pxref{[def_refspec]})の右側(right-hand-side)に一致します。リモート追跡ブランチには、直接の変更を含めたり、ローカルコミットを行ったりしないでください。

@item  repository 
<< def_ref,refs>>のコレクションと、refから到達可能 (@pxref{[def_reachable]})なすべてのオブジェクトを含むオブジェクトデータベース (@pxref{[def_object_database]})。1つまたは複数の磁器 (@pxref{[def_porcelain]})コマンドからのメタデータが付随している可能性があります。リポジトリは、代替メカニズム (@pxref{[def_alternate_object_database]})を介してオブジェクトデータベースを他のリポジトリと共有できます。

@item  resolve 
失敗した自動 マージ (@pxref{[def_merge]}) が残したものを手動で修正する操作。

@item  revision 
コミット (@pxref{[def_commit]}) (名詞) の同義語

@item  rewind(巻き戻し) 
開発の一部を破棄する、つまり、 head (@pxref{[def_head]}) を以前の リビジョン (@pxref{[def_revision]}) に割り当てる。

@item  SCM 
Source code management (tool).

@item  SHA-1 
セキュアハッシュアルゴリズム1(Secure Hash Algorithm 1);暗号化ハッシュ関数。 Git界隈ではオブジェクト名 (@pxref{[def_object_name]})の同義語として使用されます。

@item  shallow clone 
ほとんどの場合 shallowリポジトリ (@pxref{[def_shallow_repository]}) の同義語ですが、この言い方は、 @samp{git clone --depth=...} コマンドを実行して作成されたこと明言したものです。

@item  shallow repository 
浅いリポジトリ(shallow repository)には不完全な履歴があり、そのコミットの一部では親が削除されて(cauterized away)います(言い換えると、Gitは、コミットオブジェクトに記録があっても、これらのコミットには親がないふりをするように指示されます)。これは、アップストリームで記録された実際の履歴がはるかに大きい場合でも、プロジェクトの最近の履歴のみに関心がある場合に役立つことがあります。浅いリポジトリは、 git-clone(1) に @samp{--depth} オプションを指定することで作成され、その履歴は後で git-fetch(1) で深めることができます。

@item  stash entry 
ダーティ (@pxref{[def_dirty]}) な作業ディレクトリの内容とインデックスを、将来の再利用のために一時的に保存するのに使用される オブジェクト (@pxref{[def_object]}) 。

@item  submodule 
とあるリポジトリの内部で、それとは別個のプロジェクトの履歴を保持する リポジトリ (@pxref{[def_repository]}) (ここで、その、とあるリポジトリを スーパープロジェクト (@pxref{[def_superproject]}) と呼びます)。

@item  superproject 
作業ツリー内の他のプロジェクトのリポジトリを サブモジュール (@pxref{[def_submodule]}) として参照する リポジトリ (@pxref{[def_repository]}) 。 スーパープロジェクトは、含まれているサブモジュールのコミットオブジェクトの名前を知っています(ただし、そのコピーは保持していません)。

@item  symref 
シンボリックref: SHA-1 (@pxref{[def_SHA1]}) ID自体を含む代わりに「ref: refs/some/thing」の形式であり、参照されると、この参照を再帰的に逆参照します。 @samp{<<def_HEAD,HEAD>>} はsymrefの代表的な例です。シンボリックrefは git-symbolic-ref(1) コマンドで操作されます。

@item  tag 
任意のタイプのオブジェクトを指す @samp{refs/tags/} 名前空間の下のref (@pxref{[def_ref]})(通常、タグは タグ (@pxref{[def_tag_object]}) または コミットオブジェクト (@pxref{[def_commit_object]}) のいずれかを指します)。head (@pxref{[def_head]})とは対照的に、タグは @samp{commit} コマンドによって更新されません。Gitタグは、Lispタグとは何の関係もありません(Git界隈では、それはオブジェクトタイプ (@pxref{[def_object_type]})と呼ばれます)。タグは通常、コミットの祖先チェーン (@pxref{[def_chain]})の特定のポイントをマークするために使用されます。

@item  tag object 
別のオブジェクトを指すref (@pxref{[def_ref]})を含むオブジェクト (@pxref{[def_object]})。これには、コミットオブジェクト (@pxref{[def_commit_object]})のようにメッセージを含めることができます。またPGP署名を含めることもでき、その場合、「署名付きタグオブジェクト」(signed tag object)と呼ばれます。

@item  topic branch 
開発者が概念的な開発ラインを識別するために使用する通常のGitブランチ (@pxref{[def_branch]})。(従来のSCMに比べて)ブランチは非常に簡単で処理コストが掛からないため、それぞれが非常に明確に定義された概念または小さな増分であるが関連する変更を含む、いくつかの小さなブランチを持つことが望ましい場合がよくあります。

@item  tree 
作業ツリー (@pxref{[def_working_tree]})、または、ツリーオブジェクト (@pxref{[def_tree_object]})とそれに依存するブロブ (@pxref{[def_blob_object]})やツリーオブジェクト(つまり、作業ツリーの保存された表現)、のいずれか。

@item  tree object 
ファイル名とモードのリスト、および関連するブロブやツリーオブジェクトへのrefを含むオブジェクト (@pxref{[def_object]})。<< def_tree,ツリー>>とディレクトリ (@pxref{[def_directory]})は同じ意味です。

@item  tree-ish (also treeish) 
ツリーっぽい何か。ツリーオブジェクトに再帰的に逆参照できる ツリーオブジェクト (@pxref{[def_tree_object]}) または オブジェクト (@pxref{[def_object]}) です。 コミットオブジェクト (@pxref{[def_commit_object]}) を逆参照すると、その リビジョン (@pxref{[def_revision]}) の最上位 ディレクトリ> に対応するツリーオブジェクトが生成されます。※右記は全てツリーっぽい(tree-ish)モノです: <<def_commit-ish (@pxref{[def_directory]}) 、ツリーオブジェクト、ツリーオブジェクトを指す タグオブジェクト (@pxref{[def_tag_object]}) 、タグオブジェクトを指すタグオブジェクト

@item  unmerged index 
マージされていないインデックスエントリ (@pxref{[def_index_entry]})を含むインデックス (@pxref{[def_index]})。

@item  unreachable object 
ブランチ (@pxref{[def_branch]}) または タグ (@pxref{[def_tag]}) またはその他の参照から 到達可能 (@pxref{[def_reachable]}) ではない(辿れない、ポイントされてない) オブジェクト (@pxref{[def_object]}) 。

@item  upstream branch 
当該のブランチからマージされる(または当該のブランチがリベースされる)デフォルトのブランチ (@pxref{[def_branch]})。これは、 @samp{branch.<name>.remote} や @samp{branch.<name>.merge} を介して構成されます。Aのアップストリームブランチが @samp{origin/B} の場合、「Aは @samp{origin/B} を追跡しています」と言うことがあります。

@item  working tree 
実際にチェックアウトされたファイル群のツリー。 作業ツリーには通常、 HEAD (@pxref{[def_HEAD]}) コミットのツリーの内容に加えて、任意の、まだコミットされていないローカルの変更が含まれています。

@item  worktree 
(ワークツリー):リポジトリには、ゼロ(ベア・リポジトリ)または1つ以上の worktree を当てはめる(attach)ことができます。 1 つの「worktree」は「作業ツリー」(working tree)とリポジトリ・メタデータで構成され、 そのほとんどは単一のリポジトリの他の worktree 間で共有され、一部は worktree ごとに個別に維持されます(例: インデックスやHEADやMERGE_HEADなどの疑似ref(pseudorefs)、worktreeごとの ref や worktree ごとの構成ファイル)。
@end table

@noindent

@chapheading SEE ALSO

gittutorial(7), gittutorial-2(7), gitcvs-migration(7), giteveryday(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node githooks,,,Top
@chapheading Name

githooks — Gitで使われるフック

@noindent

@chapheading Synopsis

$GIT_DIR/hooks/* (or `git config core.hooksPath`/*)

@noindent

@chapheading DESCRIPTION

フック(hook)は、フックディレクトリ(hooks directory)に配置して、gitの実行の特定の時点でアクションをトリガーできるプログラムです。実行可能ビットが設定されていないフックは無視されます。

デフォルトでは、フックディレクトリ(ooks directory)は @samp{$GIT_DIR/hooks} ですが、これは @samp{core.hooksPath} 構成変数を介して変更できます(git-config(1) を参照)。

Gitはフックを呼び出す前に、ベアリポジトリでは作業ディレクトリを $GIT_DIRに変更し、非ベアリポジトリではの作業ディレクトリを作業ツリーのルートに変更します。例外は、プッシュ中にトリガーされるフック(@samp{pre-receive}, @samp{update}, @samp{post-receive}, @samp{post-update}, @samp{push-to-checkout})で、常に $GIT_DIR で実行されます。

Environment variables, such as @samp{GIT_DIR}, @samp{GIT_WORK_TREE}, etc., are exported so that Git commands run by the hook can correctly locate the repository. If your hook needs to invoke Git commands in a foreign repository or in a different working tree of the same repository, then it should clear these environment variables so they do not interfere with Git operations at the foreign location. For example:

@example
local_desc=$(git describe)
foreign_desc=$(unset $(git rev-parse --local-env-vars); git -C ../foreign-repo describe)
@end example


フックは、環境変数やコマンドライン引数やstdinを介して引数を取得できます。詳細については、以下の各フックのドキュメントを参照してください。

@samp{git init} は、その構成に応じて、フックを新しいリポジトリにコピーする場合があります。詳細については、 git-init(1) の「TEMPLAT EDIRECTORY」セクションを参照してください。このドキュメントの残りの部分で「デフォルトのフック」について言及している場合は、Gitに付属しているデフォルトのテンプレートについて説明しています。

現在サポートされているフックを以下に説明します。

@noindent

@chapheading HOOKS

@noindent

@heading applypatch-msg

このフックは git-am(1) によって呼び出されます。単一のパラメータとして、提案するコミットログメッセージを保持するファイルの名前を取ります。ゼロ以外のステータスで終了すると、パッチを適用する前に @samp{git am} が中止されます。

フックを使用すると、メッセージファイルを所定の場所で編集でき、メッセージをプロジェクトの標準形式に正規化するために使用できます。 また、メッセージファイルを検査した後にコミットを拒否するために使用することもできます。

デフォルトの @samp{applypatch-msg} フックが有効になっている場合に @samp{commit-msg} フックが有効になっていれば、 @samp{commit-msg} フックを実行します。

@noindent

@heading pre-applypatch

このフックは git-am(1) によって呼び出されます。これはパラメーターを受け取らず、パッチが適用された後、コミットが行われる前に呼び出されます。

これがゼロ以外のステータスで終了する場合、パッチの適用後に作業ツリーはコミットされません。

現在の作業ツリーを検査し、特定のテストに合格しない場合はコミットを拒否するために使用できます。

デフォルトの @samp{pre-applypatch} フックが有効になっている場合に @samp{pre-commit} フックが有効になっている場合は、 @samp{pre-commit} フックが実行されます。

@noindent

@heading post-applypatch

このフックは git-am(1) によって呼び出されます。これはパラメーターを受け取らず、パッチが適用されてコミットが行われた後に呼び出されます。

このフックは主に通知用であり、 @samp{git am} の結果に影響を与えることはできません。

@noindent

@heading pre-commit

このフックは git-commit(1) によって呼び出され、 @samp{--no-verify} オプションでバイパスできます。パラメータを必要とせず、提案したコミットログメッセージを取得してコミットする前に呼び出されます。このスクリプトをゼロ以外のステータスで終了すると、コミットを作成する前に @samp{git commit} コマンドが中止(abort)されます。

デフォルトの @samp{pre-commit} フックを有効にすると、末尾に空白がある行の導入をキャッチし、そのような行が見つかるとコミットを中止(abort)します。

すべての @samp{git commit} フックは環境変数 $GIT_EDITOR を @samp{GIT_EDITOR=:} とすれば、 コミットメッセージを変更するためのエディターを起動しません。

デフォルトの @samp{pre-commit} フックが有効になっていて、かつ、 @samp{hooks.allownonascii} 構成オプションが設定されていないかfalseに設定されている場合、非ASCIIファイル名の使用を防止します。

@noindent

@heading pre-merge-commit

このフックは git-merge(1) によって呼び出され、 @samp{--no-verify} オプションでバイパスできます。パラメータを必要とせず、マージが正常に実行された後、提案したコミットログメッセージを取得してコミットする前に呼び出されます。このスクリプトをゼロ以外のステータスで終了すると、コミットを作成する前に @samp{git merge} コマンドが中止(abort)されます。

デフォルトの @samp{pre-merge-commit} フックが有効になっている場合に @samp{pre-commit} フック後者が有効になっている場合は、 @samp{pre-commit} フックが実行されます。

このフックは環境変数 $GIT_EDITOR を @samp{GIT_EDITOR=:} とすれば、 コミットメッセージを変更するためのエディターを起動しません。

マージを自動的に実行できない場合は、競合を解決し、結果を個別にコミットする必要があります(git-merge(1) 参照)。その時点では、このフックは実行されませんが、 @samp{pre-commit} が有効になっている場合は @samp{pre-commit} フックが実行されます。

@noindent

@heading prepare-commit-msg

このフックは、デフォルトのログメッセージを準備した直後、エディターを起動する前に、 git-commit(1) によって呼び出されます。

1つから3つのパラメーターを取ります。 1つ目は、内容がコミットログメッセージであるファイルの名前です。2番目はコミットメッセージのソースであり、@samp{message}(@samp{-m} または @samp{-F} オプションが指定された場合)、 @samp{template}( @samp{-t} オプションが指定された場合、または構成オプション @samp{commit.template} が設定されている場合)、 @samp{merge}(コミットがマージであるか、 @samp{.git/MERGE_MSG} ファイルが存在する場合)、 @samp{squash}( @samp{.git/SQUASH_MSG} ファイルが存在する場合)、または @samp{commit}( @samp{-c} または @samp{-C} または @samp{--amend} オプションが指定された場合)に続いて(3つ目のパラメータとして) commitオブジェクト名。

終了ステータスがゼロ以外の場合、 @samp{git commit} は中止(abort)されます。

フックの目的は、メッセージファイルを所定の位置で編集することであり、 @samp{--no-verify} オプションによって抑制されることはありません。ゼロ以外ステータスでの終了は、フックの失敗を意味し、コミットを中止(abort)します。pre-commitフックの代わりとして使用すべきではありません。

Gitに付属するサンプルの @samp{prepare-commit-msg} フックは、コミットテンプレートのコメント部分にあるヘルプメッセージを削除します。

@noindent

@heading commit-msg

このフックは git-commit(1) と git-merge(1) によって呼び出され、 @samp{--no-verify} オプションでバイパスできます。単一のパラメータとして提案されたコミットログメッセージを保持するファイルの名前を取ります。ゼロ以外のステータスで終了すると、コマンドは中止(abort)されます。

フックを使用すると、メッセージファイルを所定の場所で編集でき、メッセージをプロジェクトの標準形式に正規化するために使用できます。 また、メッセージファイルを検査した後にコミットを拒否するために使用することもできます。

デフォルトの @samp{commit-msg} フックを有効にすると、重複する @samp{Signed-off-by} トレーラーが検出され、見つかった場合はコミットが中止(abort)されます。

@noindent

@heading post-commit

このフックは git-commit(1) によって呼び出されます。パラメータを必要とせず、コミットが行われた後に呼び出されます。

このフックは主に通知用であり、 @samp{git commit} の結果に影響を与えることはできません。

@noindent

@heading pre-rebase

このフックは git-rebase(1) によって呼び出され、ブランチがリベースされるのを防ぐために使用できます。フックは、1つまたは2つのパラメーターで呼び出すことができます。最初のパラメーターは、シリーズがフォークされたアップストリームです。2番目のパラメーターは、リベースされるブランチであり、現在のブランチをリベースするときは設定されません。

@noindent

@heading post-checkout

このフックは、ワークツリーを更新した後に git-checkout(1) または git-switch(1) が実行されたときに呼び出されます。フックには、以前のHEADのref、新しいHEADのref(変更されている場合と変更されていない場合があります)、およびチェックアウトがブランチチェックアウト(ブランチの変更、flag=1)あるいはファイルのチェックアウト(インデックスからファイルを取得、flag=0)のいずれかであるかどうかを示すフラグ、の3つのパラメーターが与えられます。このフックは、フックの終了ステータスがこれら2つのコマンドの終了ステータスになることを除いて、 @samp{git switch} または @samp{git checkout} の結果に影響を与えることはできません。

これは @samp{--no-checkout} (@samp{-n})オプションが使用されていない限り、 git-clone(1)の後でも実行されます。 フックに指定された最初のパラメーターは null-refで、2番目は新しいHEADのrefであり、フラグは常に1です。@samp{--no-checkout} が使用されていない限り、 @samp{git worktree add} についても同様です。

このフックを使用して、リポジトリの有効性チェックを実行したり、以前のHEADとの違いを自動表示したり、作業ディレクトリのメタデータプロパティを設定したりできます。

@noindent

@heading post-merge

このフックは git-merge(1) によって呼び出されます。これは、ローカルリポジトリで @samp{git pull} が実行されたときに発生します。フックは単一のパラメーター、つまり、実行されているマージがスカッシュマージ(squash merge)であるかどうかを指定するステータスフラグを受け取ります。このフックは @samp{git merge} の結果に影響を与えることはできず、競合が原因でマージが失敗した場合は実行されません。

このフックを対応するpre-commitフックと組み合わせて使用すると、作業ツリーに関連付けられている任意の形式のメタデータ(たとえば、権限/所有権、ACLSなど)を保存および復元できます。これを行う方法の例については、 contrib/hooks/setgitperms.perl を参照してください。

@noindent

@heading pre-push

このフックは git-push(1) によって呼び出され、プッシュが行われないようにするために使用できます。フックは、宛先リモートの名前と場所を提供する2つのパラメーターで呼び出されます。名前付きリモートが使用されていない場合、両方の値は同一になります。

何をプッシュするかについての情報は、フックの標準入力に次の形式の行で提供されます:

@example
<local ref> SP <local object name> SP <remote ref> SP <remote object name> LF
@end example

たとえば、コマンド @samp{git push origin master:foreign} を実行すると、フックは以下のような行を受け取ります:

@example
refs/heads/master 67890 refs/heads/foreign 12345
@end example

ただし、完全なオブジェクト名が提供されます。外部参照がまだ存在しない場合、 <remote object name> はすべてゼロのオブジェクト名になります。refを削除する場合は、 <local ref> が @samp{(delete)} として提供され、 @samp{<local object name>} がすべてゼロのオブジェクト名になります。ローカルコミットが拡張可能な名前以外の名前(@samp{HEAD~} やオブジェクト名など)で指定された場合は、最初に指定されたとおりに提供されます。

このフックがゼロ以外のステータスで終了した場合、 @samp{git push} は何もプッシュせずに中止(abort)します。プッシュが拒否された理由に関する情報は、標準エラーに書き込むことでユーザーに送信される場合があります。

@noindent

@heading pre-receive

このフックは、 @samp{git push} に反応し、リポジトリ内の参照を更新するときに、 git-receive-pack(1) によって呼び出されます。リモートリポジトリのrefの更新を開始する直前に、pre-receiveフックが呼び出されます。その終了ステータスによって、更新の成功または失敗が決まります。

このフックは、受信操作に対して1回実行されます。引数は必要ありませんが、更新される各refについて、標準入力で以下の形式の行を受け取ります:

@example
<old-value> SP <new-value> SP <ref-name> LF
@end example

ここで、 @samp{<old-value>} は、refに保存されている古いオブジェクト名です。 @samp{<new-value>} はrefに格納される新しいオブジェクト名です。 @samp{<ref-name>} はrefのフルネームです。 新しいrefを作成する場合、 @samp{<old-value>} はすべてゼロのオブジェクト名です。

フックがゼロ以外のステータスで終了した場合、どのrefも更新されません。フックがゼロで終了する場合でも、個々のrefの更新は@samp{update} (@pxref{update})フックによって防ぐことができます。

標準出力と標準エラー出力の両方がもう一方の側の @samp{git send-pack} に転送(forward)されるため、ユーザーにメッセージを @samp{echo} するだけで済みます。

@samp{git push --push-option=...} のコマンドラインで指定された、プッシュオプションの数は環境変数 @samp{GIT_PUSH_OPTION_COUNT} から読み取ることができ、オプション自体は @samp{GIT_PUSH_OPTION_0} 、 @samp{GIT_PUSH_OPTION_1} 、 … から読み取る事ができます。プッシュオプションフェーズを使用しないように取り決めた場合、環境変数は設定されません。クライアントがプッシュオプションの使用を選択したが、何も送信しない場合、カウント変数はゼロ、つまり @samp{GIT_PUSH_OPTION_COUNT=0} に設定されます。

いくつかの注意点については、 git-receive-pack(1) の「Quarantine Environment」のセクションを参照してください。

@noindent

@heading update

このフックは、 @samp{git push} に反応し、リポジトリ内の参照を更新するときに、 git-receive-pack(1) によって呼び出されます。リモートリポジトリのrefを更新する直前に、 update フックが呼び出されます。その終了ステータスによって、ref更新の成功または失敗が決まります。

フックは、更新されるrefごとに1回実行され、以下の3つのパラメーターを取ります:

@itemize 

@item
更新されるrefの名前

@item
refに保存されている古いオブジェクト名

@item
refに格納される新しいオブジェクト名
@end itemize

更新フックがゼロステータスで終了すると、refを更新できます。ゼロ以外のステータスで終了すると、 @samp{git receive-pack} はそのrefを更新できなくなります。

このフックは、オブジェクト名が古いオブジェクト名で指定されたコミットオブジェクトの子孫であるコミットオブジェクトであることを確認することにより、特定のrefでの「強制」更新を防ぐために使用できます。つまり、「早送りのみ」(fast-forward only)のポリシーを適用します。

また、 old..new ステータスをログに記録するために使用することもできます。ただし、ブランチのセット全体を認識しているわけではないため、単純に使用すると、refごとに1つの電子メールが送信されることになります。そのためには@samp{post-receive} (@pxref{post-receive})フックの方が適しています。

ユーザーのアクセスをネットワーク経由のgitコマンドのみに制限する環境では、このフックを使用して、ファイルシステムの所有権やグループメンバーシップに依存せずにアクセス制御を実装できます。ログインシェルを使用してユーザーのアクセスをgitコマンドのみに制限する方法については、 git-shell(1) を参照してください。

標準出力と標準エラー出力の両方がもう一方の側の @samp{git send-pack} に転送(forward)されるため、ユーザーにメッセージを @samp{echo} するだけで済みます。

デフォルトの @samp{update} フックが有効になっている場合 — および @samp{hooks.allowunannotated} 構成オプションが設定されていないかfalseに設定されている場合 — 注釈のないタグ(unannotated tags)がプッシュされるのを防ぎます。

@noindent

@heading proc-receive

このフックは git-receive-pack(1) によって呼び出されます。サーバーが複数値の構成変数 @samp{receive.procReceiveRefs} を設定し、そして @samp{receive-pack} に送信されるコマンドの参照名が一致する場合、これらのコマンドは、内部の @samp{execute_commands()} 関数ではなく、このフックによって実行されます。このフックは、関連する参照を更新し、結果を @samp{receive-pack} に報告する役割を果たします。

このフックは、受信操作に対して1回実行されます。引数は取りませんが、pkt-line形式のプロトコルを使用して @samp{receive-pack} と通信し、コマンド、プッシュオプションを読み取り、結果を送信します。行かのプロトコルの例では、文字 @samp{S} は @samp{receive-pack} を表し、文字 @samp{H} はこのフックを表します。

@example
# Version and features negotiation.
S: PKT-LINE(version=1\0push-options atomic...)
S: flush-pkt
H: PKT-LINE(version=1\0push-options...)
H: flush-pkt
@end example

@example
# Send commands from server to the hook.
S: PKT-LINE(<old-oid> <new-oid> <ref>)
S: ... ...
S: flush-pkt
# Send push-options only if the 'push-options' feature is enabled.
S: PKT-LINE(push-option)
S: ... ...
S: flush-pkt
@end example

@example
# Receive result from the hook.
# OK, run this command successfully.
H: PKT-LINE(ok <ref>)
# NO, I reject it.
H: PKT-LINE(ng <ref> <reason>)
# Fall through, let 'receive-pack' to execute it.
H: PKT-LINE(ok <ref>)
H: PKT-LINE(option fall-through)
# OK, but has an alternate reference.  The alternate reference name
# and other status can be given in option directives.
H: PKT-LINE(ok <ref>)
H: PKT-LINE(option refname <refname>)
H: PKT-LINE(option old-oid <old-oid>)
H: PKT-LINE(option new-oid <new-oid>)
H: PKT-LINE(option forced-update)
H: ... ...
H: flush-pkt
@end example

@samp{proc-receive} フックの各コマンドは、疑似参照(pseudo-reference)を指す場合があり、そのold-oidとして常にゼロオールドを持ちます。一方、 @samp{proc-receive} フックは代替参照(alternate reference)を更新する可能性があり、代替参照はゼロ以外のold-oidで既に存在する可能性があります。この場合、このフックは @samp{option} ディレクティブを使用して、先頭の @samp{ok} ディレクティブによって指定された参照の拡張属性を報告します。

このフックのコマンドの報告は、入力と同じ順序である必要があります。 @samp{proc-receive} フックの終了ステータスは、アトミックプッシュ(atomic push)が使用されていない限り、送信したコマンドグループの成功または失敗のみを決定します。

@noindent

@heading post-receive

このフックは、 @samp{git push} に反応し、リポジトリ内の参照を更新するときに、 git-receive-pack(1) によって呼び出されます。すべてのrefが更新された後、リモートリポジトリで実行されます。

このフックは、受信操作に対して1回実行されます。引数は取りませんが、 @samp{pre-receive} (@pxref{pre-receive}) フックが標準入力で行うのと同じ情報を取得します。

このフックは、実際の作業が完了した後に呼び出されるため、 @samp{git receive-pack} の結果には影響しません。

これは、名前に加えてすべてのrefの古い値と新しい値の両方を取得するという点で、 @samp{post-update} (@pxref{post-update}) フックに取って代わります。

標準出力と標準エラー出力の両方がもう一方の側の @samp{git send-pack} に転送(forward)されるため、ユーザーにメッセージを @samp{echo} するだけで済みます。

デフォルトの @samp{post-receive} フックは空ですが、Gitディストリビューションの @samp{contrib/hooks} ディレクトリにサンプルスクリプト @samp{post-receive-email} があり、コミットメールの送信を実装しています。

@samp{git push --push-option=...} のコマンドラインで指定された、プッシュオプションの数は環境変数 @samp{GIT_PUSH_OPTION_COUNT} から読み取ることができ、オプション自体は @samp{GIT_PUSH_OPTION_0} 、 @samp{GIT_PUSH_OPTION_1} 、 … から読み取る事ができます。プッシュオプションフェーズを使用しないように取り決めた場合、環境変数は設定されません。クライアントがプッシュオプションの使用を選択したが、何も送信しない場合、カウント変数はゼロ、つまり @samp{GIT_PUSH_OPTION_COUNT=0} に設定されます。

@noindent

@heading post-update

このフックは、 @samp{git push} に反応し、リポジトリ内の参照を更新するときに、 git-receive-pack(1) によって呼び出されます。すべてのrefが更新された後、リモートリポジトリで実行されます。

可変数のパラメーターを取ります。各パラメーターは、実際に更新されたrefの名前です。

このフックは主に通知用であり、 @samp{git receive-pack} の結果に影響を与えることはできません。

@samp{post-update} フックは、プッシュされたヘッドが何であるかを知ることができますが、元の値と更新された値が何であるかを知らないため、 logold..new を実行するのに適した場所ではありません。 @samp{post-receive} (@pxref{post-receive})フックは、参照の元の値と更新された値の両方を取得するので、必要に応じて、このフックの代わりに検討することもできます。

有効にすると、デフォルトの @samp{post-update} フックが @samp{git update-server-info} を実行して、バカ転送(dumb transports)(例:HTTP)で使用される情報を最新の状態に保ちます。 HTTP経由でアクセスできるGitリポジトリを公開している場合は、あなたはおそらくこのフックを有効にする必要があります。

標準出力と標準エラー出力の両方がもう一方の側の @samp{git send-pack} に転送(forward)されるため、ユーザーにメッセージを @samp{echo} するだけで済みます。

@noindent

@heading reference-transaction

このフックは、参照の更新を実行するGitコマンドによって呼び出されます。参照トランザクションが、準備またはコミットまたは中止されるたびに実行されるため、複数回呼び出される可能性があります。このフックはシンボリック参照をカバーしていません(ただし、将来変更される可能性があります)。

フックは引数を1つだけ取りますが、これは指定された参照トランザクションの現在の状態です:

@itemize 

@item
"prepared" : すべての参照更新がトランザクションのキューに入れられ、参照がディスク上でロックされました。

@item
"committed": 参照トランザクションがコミットされ、すべての参照にそれぞれの新しい値が追加されました。

@item
"aborted": 参照トランザクションが中止され、変更は実行されず、ロックが解放されました。
@end itemize

トランザクションに追加された参照更新ごとに、フックは標準入力で以下の形式の行を受け取ります:

@example
<old-value> SP <new-value> SP <ref-name> LF
@end example

ここで、 @samp{<old-value>} は、参照トランザクションに渡された古いオブジェクト名です。 @samp{<new-value>} はrefに格納される新しいオブジェクト名であり、 @samp{<ref-name>} はrefのフルネームです。現在の値に関係なく参照を強制的に更新する場合、または参照を新たに作成する場合は、 @samp{<old-value>} はすべてゼロのオブジェクト名です。あなたは、これらのケースを区別するために、 @samp{gitrev-parse} を介して @samp{<ref-name>} の現在の値を調べることができます。

フックの終了ステータスは、「prepared」(準備済み)状態を除くすべての状態で無視されます。「prepared」状態では、ゼロ以外の終了ステータスにより、トランザクションが中止(abort)されます。その場合、フックは「中止」状態で呼び出さることはありません。

@noindent

@heading push-to-checkout

プッシュが現在チェックアウトされているブランチを更新しようと試み、かつ、 @samp{receive.denyCurrentBranch} 構成変数が @samp{updateInstead} に設定されている場合、このフックは、 @samp{git push} に反応し、リポジトリ内の参照を更新するときに、 git-receive-pack(1) によって呼び出されます。作業ツリーとリモートリポジトリのインデックスが現在チェックアウトされているコミットと異なる場合、このようなプッシュはデフォルトで拒否されます。作業ツリーとインデックスの両方が現在のコミットと一致する場合、それらは、ブランチの新しくプッシュされた先端に一致するように更新されます。このフックは、デフォルトの動作をオーバーライドするために使用されます。

フックは、現在のブランチの先端が更新されるコミットを受け取ります。ゼロ以外のステータスで終了してプッシュを拒否できます(そうする場合は、インデックスまたは作業ツリーを変更してはいけません)。または、作業ツリーとインデックスに必要な変更を加えて、現在のブランチの先端が新しいコミットに更新されたときにそれらを目的の状態にし、ゼロステータスで終了することもできます。

例えば、フックは単純に @samp{git read-tree -u -m HEAD "$1"} を実行して、@samp{git push} と逆方向に実行する @samp{git fetch} をエミュレートすることができます。 @samp{git read-tree -u -m} の二木形式(two-tree form)は、ブランチの違いを妨げない範囲で作業ツリー(working tree)のローカル変更を維持しながらブランチを切り替える @samp{git switch} や @samp{git checkout} と本質的に同じものだからです。

@noindent

@heading pre-auto-gc

このフックは @samp{git gc --auto} によって呼び出されます(git-gc(1) を参照)。パラメータを必要とせず、このスクリプトをゼロ以外のステータスで終了させると、 @samp{git gc --auto} が中止(abort)されます。

@noindent

@heading post-rewrite

このフックは、commitを書き換えるコマンド(@samp{--amend} や git-rebase(1) から呼び出された場合の git-commit(1) 。ただし、 git-fast-import(1)や @uref{https://github.com/newren/git-filter-repo,git-filter-repo} などの完全な履歴(再)書き込みツールは通常、呼び出さないでください！)によって呼び出されます。その最初の引数は、それが呼び出されたコマンドを示します。それは現在、@samp{amend} または @samp{rebase} のいずれかです。将来、コマンドに依存する引数がさらに渡される可能性があります。

フックは、stdinから、書き換えられたコミットのリストを以下の形式で受け取ります。

@example
<old-object-name> SP <new-object-name> [ SP <extra-info> ] LF
@end example

@samp{extra-info} もコマンド依存です。空の場合、先行するSPも省略されます。現在、 @samp{extra-info} を渡すコマンドはありません。

フックは常に、自動noteコピー(git-config(1)の @samp{notes.rewrite.<command>} 参照)が発生した後に実行されるため、フックはこれらのnoteにアクセスできます。

以下のコマンド固有のコメントが適用されます:

@table @asis

@item  rebase 
@samp{squash} 操作と @samp{fixup} 操作の場合、スカッシュされたすべてのコミットは、スカッシュされたコミットに書き換えられたものとしてリストされます。これは、同じ「new-object-name」を共有する複数の行があることを意味します。

コミットは、リベースによって処理された順序でリストされることが保証されています。
@end table

@noindent

@heading sendemail-validate

This hook is invoked by git-send-email(1).

It takes these command line arguments. They are,
1. the name of the file which holds the contents of the email to be sent.
2. The name of the file which holds the SMTP headers of the email.

The SMTP headers are passed in the exact same way as they are passed to the user’s Mail Transport Agent (MTA). In effect, the email given to the user’s MTA, is the contents of $2 followed by the contents of $1.

An example of a few common headers is shown below. Take notice of the capitalization and multi-line tab structure.

@example
From: Example <from@@example.com>
To: to@@example.com
Cc: cc@@example.com,
        A <author@@example.com>,
        One <one@@example.com>,
        two@@example.com
Subject: PATCH-STRING
@end example

Exiting with a non-zero status causes @samp{git send-email} to abort before sending any e-mails.

The following environment variables are set when executing the hook.

@table @asis

@item  @samp{GIT_SENDEMAIL_FILE_COUNTER} 
A 1-based counter incremented by one for every file holding an e-mail to be sent (excluding any FIFOs). This counter does not follow the patch series counter scheme. It will always start at 1 and will end at GIT_SENDEMAIL_FILE_TOTAL.

@item  @samp{GIT_SENDEMAIL_FILE_TOTAL} 
The total number of files that will be sent (excluding any FIFOs). This counter does not follow the patch series counter scheme. It will always be equal to the number of files being sent, whether there is a cover letter or not.
@end table

These variables may for instance be used to validate patch series.

The sample @samp{sendemail-validate} hook that comes with Git checks that all sent patches (excluding the cover letter) can be applied on top of the upstream repository default branch without conflicts. Some placeholders are left for additional validation steps to be performed after all patches of a given series have been applied.

@noindent

@heading fsmonitor-watchman

このフックは、使用するフックのバージョンに応じて、構成オプション @samp{core.fsmonitor} が @samp{.git/hooks/fsmonitor-watchman} または @samp{.git/hooks/fsmonitor-watchmanv2} に設定されている場合に呼び出されます。

バージョン1は、バージョン(つまり、1)と、1970年1月1日の0:00から経過したナノ秒単位の時間の、2つの引数を取ります。

バージョン2は、バージョン(つまり、2)と、トークン以降の変更を識別するために使用されるトークンの、2つの引数を取ります。ウォッチマン(watchman)の場合、これはクロックID(clock id)になります。このバージョンでは、新しいトークンの後のファイルのリストの前にNULを付けて標準出力しなければなりません。

フックは、要求された時間以降に変更された可能性のある作業ディレクトリ内のすべてのファイルのリストをstdoutに出力する必要があります。潜在的な変更を見逃さないように、ロジックは包括的(inclusive)である必要があります。パスは、作業ディレクトリのルートを基準にして、単一のNULで区切る必要があります。

実際に変更されていないファイルを含めてもかまいません。新しく作成および削除されたファイルを含むすべての変更を含める必要があります。ファイルの名前を変更するときは、古い名前と新しい名前の両方を含める必要があります。

Gitは、指定のパス名に基づいて、変更をチェックするファイルと、追跡されていないファイルをチェックするディレクトリを制限します。

gitに「すべてのファイルが変更されました」と伝えるための最適化された方法は、ファイル名 @samp{/} を返すことです。

終了ステータスは、gitがフックからのデータを使用して検索を制限するかどうかを決定します。エラーが発生すると、すべてのファイルとフォルダーの検証にフォールバックします。

@noindent

@heading p4-changelist

このフックは @samp{git-p4 submit} によって呼び出されます。

@samp{p4-changelist} フックは、ユーザーがチェンジリストメッセージ(changelist message)を編集した後に実行されます。 @samp{--no-verify} オプションでバイパスできます。提案されたチェンジリストテキストを保持するファイルの名前という単一のパラメータを取ります。ゼロ以外のステータスで終了すると、コマンドは中止(abort)されます。

フックはチェンジリストファイル(changelist file)の編集を許可されており、テキストをプロジェクトの標準形式に正規化するために使用できます。また、メッセージファイルを検査した後に送信を拒否するために使用することもできます。

詳細については、 @samp{git-p4 submit --help} を実行してください。

@noindent

@heading p4-prepare-changelist

このフックは @samp{git-p4 submit} によって呼び出されます。

@samp{p4-prepare-changelist} フックは、デフォルトのチェンジリストメッセージ(changelist message)を準備した直後、エディタが起動する前に実行されます。これは、チェンジリストのテキストを含むファイルの名前という1つのパラメーターを取ります。スクリプトをゼロ以外のステータスで終了すると、プロセスが中止(abort)されます。

フックの目的は、メッセージファイルを所定の位置で編集することであり、@samp{--no-verify} オプションによって抑制されることはありません。 このフックは、 @samp{--prepare-p4-only} が設定されている場合でも呼び出されます。

詳細については、 @samp{git-p4 submit --help} を実行してください。

@noindent

@heading p4-post-changelist

このフックは @samp{git-p4 submit} によって呼び出されます。

@samp{p4-post-changelist} フックは、送信(submit)がP4で正常に発生した後に呼び出されます。これはパラメーターを必要とせず、主に通知を目的としており、git p4 submitアクションの結果に影響を与えることはできません。

詳細については、 @samp{git-p4 submit --help} を実行してください。

@noindent

@heading p4-pre-submit

このフックは @samp{git-p4 submit} によって呼び出されます。これはパラメータをとらず、標準入力から何も取りません。このスクリプトをゼロ以外のステータスで終了すると、 @samp{git-p4 submit} の起動を妨げます。 @samp{--no-verify} コマンドラインオプションでバイパスできます。詳細については、 @samp{git-p4 submit --help} を実行してください。

@noindent

@heading post-index-change

このフックは、インデックスが read-cache.c の do_write_locked_index に書き込まれるときに呼び出されます。

フックに渡される最初のパラメーターは、更新される作業ディレクトリのインジケーターです。「1」は作業ディレクトリが更新されたことを意味し、「0」は作業ディレクトリが更新されなかったことを意味します。

フックに渡される2番目のパラメーターは、インデックスが更新され、 skip-worktree ビットが変更された可能性があるかどうかを示すインジケーターです。「1」はskip-worktreeビットが更新された可能性があることを意味し、「0」は更新されなかったことを意味します。

フックの実行時に "1" に設定するパラメーターは1つだけです。 両方のパラメータを "1" に設定してはいけません。

@noindent

@chapheading SEE ALSO

git-hook(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitignore,,,Top
@chapheading Name

gitignore — 無視する、意図的に追跡しないファイルを指定します

@noindent

@chapheading Synopsis

$XDG_CONFIG_HOME/git/ignore, $GIT_DIR/info/exclude, .gitignore

@noindent

@chapheading DESCRIPTION

@samp{gitignore} ファイルは、Gitが無視する必要のある意図的に追跡しないファイルを指定します。 Gitによってすでに追跡されているファイルは影響を受けません。 詳細については、以下のNOTESを参照してください。

@samp{gitignore} ファイルの各行にはパターンを指定します。パスを無視するかどうかを決定するとき、Gitは通常、複数のソースからの @samp{gitignore} パターンを、最高から最低の順に以下の優先順位でチェックします(各レベルの優先順位内では最後に一致するパターンが結果を決定します)。

@itemize 

@item
パターンは、それらをサポートするコマンドのコマンドラインから読み取られます。

@item
そのパスから見て同じディレクトリまたは親ディレクトリ(作業ツリーの最上位まで)にある @samp{.gitignore} ファイルから読み取られたパターン。ディレクトリの上位レベルのファイルのパターンは、@samp{.gitignore} ファイルを含むディレクトリまでディレクトリ下位レベルの @samp{.gitignore} ファイルのパターンによって上書きされますこれらのパターンは、 @samp{.gitignore} ファイルのあるディレクトリを基準にしてマッチします。 プロジェクトは通常、リポジトリにそのような、プロジェクトビルドの部品として生成されたファイルのパターンを含んだ @samp{.gitignore} ファイルを含みます。(訳注:各サブディレクトリに .gigignore ファイルを含む事ができ、各ディレクトリの .gitignore はその親ディレクトリまたはその上位ディレクトリの .gitignore をオーバーライドする)

@item
パターンは @samp{$GIT_DIR/info/exclude} から読み取られます。

@item
構成変数 @samp{core.excludesFile} で指定されたファイルから読み取られたパターン。
@end itemize

パターンを配置するファイルは、パターンの使用方法によって異なります。

@itemize 

@item
バージョン管理され、クローンを介して他のリポジトリに配布される必要があるパターン(つまり、すべての開発者が無視したいファイル)は、 @samp{.gitignore} ファイルに入れる必要があります。

@item
特定のリポジトリに固有であるが、他の関連するリポジトリと共有する必要のないパターン(たとえば、リポジトリ内に存在するが1人のユーザーのワークフローに固有の補助ファイル)は、 @samp{$GIT_DIR/info/exclude} ファイルに配置する必要があります。

@item
ユーザーがすべての状況でGitに無視させたいパターン(たとえば、選択したユーザーのエディタによって生成されたバックアップファイルまたは一時ファイル)は、通常、ユーザーの @samp{~/.gitconfig} の @samp{core.excludesFile} で指定されたファイルに入ります。デフォルト値は $XDG_CONFIG_HOME/git/ignore です。 $XDG_CONFIG_HOME が設定されていないか空の場合、代わりに $HOME/.config/git/ignore が使用されます。
@end itemize

@samp{gitls-files} や @samp{git read-tree} などの基盤となるGit配管コマンドツールは、 コマンドラインオプションで指定された @samp{gitignore} パターンを読み取るか、 コマンドラインオプションで指定されたファイルから読み取ります。 @samp{git status} や @samp{git add} などの高レベルのGitツールは、 上記で指定されたソースからのパターンを使用します。

@noindent

@chapheading PATTERN FORMAT

@itemize 

@item
空行はどのファイルともマッチしないため、読みやすくするための区切りとして使えます。

@item
@samp{#} で始まる行はコメントとして機能します。 @samp{#} で始まるパターンの最初の @samp{#} の前にはバックスラッシュ(「@samp{\}」)を置きます。

@item
末尾の空白は、バックススラッシュ(@samp{\})でクォートされていない限り無視されます。

@item
パターンを否定するオプションのプレフィックス @samp{!} 。以前のパターンで除外されたマッチするファイルは、再び含まれるようになります。そのファイルの親ディレクトリが除外されている場合、そのファイルを再インクルードすることはできません。Gitはパフォーマンス上の理由から除外されたディレクトリを一覧表示しないため、含まれているファイルのパターンは、それらがどこで定義されていても効果がありません。 リテラル @samp{!} で始まるパターンの場合は、最初の @samp{!} の前にバックスラッシュ(@samp{\})を付けます(例: @samp{\!important!.txt})。

@item
スラッシュ @samp{/} はディレクトリ区切り文字として使用されます。区切り文字は、 @samp{.gitignore} 検索パターンの最初、中間、または最後に発生する可能性があります。

@item
パターンの先頭または中間(あるいはその両方)に区切り文字がある場合、パターンは特定の @samp{.gitignore} ファイル自体のディレクトリレベルに関連しています。そうしないと、パターンは @samp{.gitignore} レベルより下の任意のレベルでも一致する可能性があります。

@item
パターンの最後に区切り文字がある場合、パターンはディレクトリのみに一致します。それ以外の場合、パターンはファイルとディレクトリの両方に一致する可能性があります。

@item
たとえば、パターン @samp{doc/frotz/} は @samp{doc/frotz} ディレクトリと一致しますが、 @samp{a/doc/frotz} ディレクトリとは一致しません。 ただし、 @samp{frotz/} は @samp{frotz} およびディレクトリである @samp{a/frotz} と一致します(すべてのパスは @samp{.gitignore} ファイルのあるディレクトリからの相対パスです)。

@item
アスタリスク(@samp{*})はスラッシュ(@samp{/})以外のものと一致します。文字 @samp{?} は、 @samp{/} 以外の任意の1文字と一致します。 範囲表記、例えば @samp{[a-zA-Z]} は、範囲内の文字の1つと一致させるために使用できます。詳細については、 fnmatch3）および FNM_PATHNAME フラグを参照してください。
@end itemize

フルパス名と一致するパターンの、2つの連続するアスタリスク(@samp{**})は、以下の特別な意味を持つ場合があります:

@itemize 

@item
先頭の @samp{**} の後にスラッシュ(@samp{/})が続く場合は、すべてのディレクトリで一致することを意味します。 たとえば、 @samp{**/foo} は、パターン @samp{foo} と同じように、任意の場所のファイルまたはディレクトリ @samp{foo} と一致します。 @samp{**/foo/bar} は、ディレクトリ @samp{foo} の直下にあるファイルまたはディレクトリ @samp{bar} と一致します。

@item
末尾の @samp{/**} は内部のすべてに一致します。 たとえば、 @samp{abc/**} は、 @samp{.gitignore} ファイルの場所を基準にして、ディレクトリ @samp{abc} 内のすべてのファイルと無限の深さで一致します。

@item
スラッシュ(@samp{/})の後に2つの連続するアスタリスク(@samp{**})が続く場合、スラッシュは0個以上のディレクトリに一致します。たとえば、 @samp{a/**/b} は @samp{a/b} や @samp{a/x/b} や @samp{a/x/y/b} などと一致します。

@item
他の連続するアスタリスクは通常のアスタリスクと見なされ、以前のルールに従って一致します。
@end itemize

@noindent

@chapheading CONFIGURATION

オプションの構成変数 @samp{core.excludesFile} は、 @samp{$GIT_DIR/info/exclude} と同様に、除外するファイル名のパターンを含むファイルへのパスを示します。 @samp{$GIT_DIR/info/exclude} のパターンに加えて、excludeファイルのパターンが使用されます。

@noindent

@chapheading NOTES

gitignoreファイルの目的は、Gitによって未だ追跡されていない特定のファイルがGitによって追跡される事が無いようにすることです。

To stop tracking a file that is currently tracked, use @emph{git rm --cached} to remove the file from the index. The filename can then be added to the @samp{.gitignore} file to stop the file from being reintroduced in later commits.

作業ツリーの @samp{.gitignore} ファイルにアクセスするとき、Gitはシンボリックリンクをたどりません。これにより、ファイルシステムからではなく、インデックスまたはツリーからファイルにアクセスする場合の動作の一貫性が保たれます。

@noindent

@chapheading EXAMPLES

@itemize 

@item
パターン @samp{hello.*} は、 名前が @samp{hello.} で始まるすべてのファイルまたはディレクトリにマッチします。 これをディレクトリのみに制限し、 そのサブディレクトリには制限したくない場合は、 パターンの前にスラッシュを付けることができます。 つまり、 @samp{/hello.*} とします。 このパターンは @samp{hello.txt} や @samp{hello.c} とマッチしますが、 @samp{a/hello.java} とはマッチしません。

@item
パターン @samp{foo/} は、ディレクトリ @samp{foo} とその下のパスに一致しますが、通常のファイルまたはシンボリックリンク @samp{foo} には一致しません(これは、Gitでのpathspecの一般的な動作方法と一致します)

@item
パターン @samp{doc/frotz} と @samp{/doc/frotz} は、どの @samp{.gitignore} ファイルでも同じ効果があります。つまり、パターンの中間にスラッシュ(@samp{/})がある場合、先頭のスラッシュは関係ありません。

@item
パターン @samp{foo/*} は、 @samp{foo/test.json} (通常のファイル) や @samp{foo/bar} (ディレクトリ)とマッチしますが、パターンのアスタリスク(@samp{*})がスラッシュ(@samp{/})を含む @samp{bar/hello.c} とマッチしないため、 @samp{foo/bar/hello.c} (通常のファイル)とは一致しません。
@end itemize

@example
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    #       Documentation/gitignore.html
    #       file.o
    #       lib.a
    #       src/internal.o
    [...]
    $ cat .git/info/exclude
    # ignore objects and archives, anywhere in the tree.
    *.[oa]
    $ cat Documentation/.gitignore
    # ignore generated html files,
    *.html
    # except foo.html which is maintained by hand
    !foo.html
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    [...]
@end example


別の例:

@example
    $ cat .gitignore
    vmlinux*
    $ ls arch/foo/kernel/vm*
    arch/foo/kernel/vmlinux.lds.S
    $ echo '!/vmlinux*' >arch/foo/kernel/.gitignore
@end example


2番目の .gitignore は、Gitが @samp{arch/foo/kernel/vmlinux.lds.S} を無視するのを防ぎます。

特定のディレクトリ @samp{foo/bar} 以外のすべてを除外する例(@samp{/*} に注意してください。スラッシュ(@samp{/})なしでワイルドカード(@samp{*})は、 @samp{foo/bar} 内のすべても除外します):

@example
    $ cat .gitignore
    # exclude everything except directory foo/bar
    /*
    !/foo
    /foo/*
    !/foo/bar
@end example


@noindent

@chapheading SEE ALSO

git-rm(1), gitrepository-layout(5), git-check-ignore(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitk,,,Top
@chapheading Name

gitk — Gitリポジトリブラウザ

@noindent

@chapheading Synopsis

@display
gitk [<options>] [<revision range>] [--] [<path>…]
@end display


@noindent

@chapheading DESCRIPTION

リポジトリまたは選択したコミットのセットの変更を表示します。 これには、コミットグラフの視覚化、各コミットに関連する情報、および各リビジョンのツリー内のファイルの表示が含まれます。

@noindent

@chapheading OPTIONS

表示するリビジョンを制御するために、gitkは @samp{git rev-list} コマンドに適用できるほとんどのオプションをサポートしています。 また、 @samp{git diff-*} コマンド群に適用できるいくつかのオプションをサポートして、各コミットによって導入される変更の表示方法を制御します。最後に、いくつかのgitk固有のオプションをサポートします。

gitkは通常、コマンドラインパーサーの制限により、串刺し形式(sticked form)の引数を持つオプションのみを理解します(linkgit: gitcli[7] を参照)。

@noindent

@heading rev-list options and arguments

このマニュアルページでは、最も頻繁に使用されるオプションについてのみ説明しています。 完全なリストについては、 git-rev-list(1) を参照してください。

@table @asis

@item  @samp{--all} 
全ての参照(ブランチ、タグ、等)を表示します。

@item  @samp{--branches[=<pattern>]} 
@itemx  @samp{--tags[=<pattern>]} 
@itemx  @samp{--remotes[=<pattern>]} 

@item  @samp{--since=<date>} 
指定の日付よりも新しいコミットを表示します。

@item  @samp{--until=<date>} 
指定の日付より古いコミットを表示します。

@item  @samp{--date-order} 
可能な場合は、コミットを日付順で並べ替えます。

@item  @samp{--merge} 
マージの試みが競合で停止した後、競合するファイルを変更し、マージされるすべてのヘッドに存在しない2つのブランチ間(つまり、HEADとMERGE_HEAD)の履歴のコミットを表示します。

@item  @samp{--left-right} 
対称差のどちら側からコミットに到達できるかをマークします。左側からのコミットには @samp{<} 記号が接頭辞として付けられ、右側からのコミットには @samp{>} 記号が付けられます。

@item  @samp{--full-history} 
@samp{<path>...} で履歴をフィルタリングする場合、一部の履歴は削除されません。(詳細な説明については、 git-log(1) の「History simplification」を参照してください。)

@item  @samp{--simplify-merges} 
@samp{--full-history} への追加オプションで、このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除します。(詳細な説明については、 git-log(1) の「History simplification」を参照してください。)

@item  @samp{--ancestry-path} 
表示するコミットの範囲が指定されている(例: @samp{commit1..commit2} または @samp{commit2 @{caret@}commit1})場合、 commit1とcommit2の間の祖先チェーンに直接存在するコミット、つまりcommit1の子孫であり、commit2の祖先でもあるコミットのみを表示します。(詳細な説明については、 linkgit：git-log[1] の「History simplification」を参照してください。)

@item  @samp{-L<start>,<end>:<file>} 
@itemx  @samp{-L:<funcname>:<file>} 
<file> 内で、 @samp{<start>,<end>} 、または正規表現の関数名 <funcname> で指定された行範囲をトレースします。pathspec リミッターを指定することはできません。これは現在、単一のリビジョンから開始するウォークに制限されています。つまり、0個または1個の正のリビジョン引数のみを指定でき、 <start> と <end> (または <funcname>) が開始リビジョンに存在する必要があります。このオプションは複数回指定できます。これは @samp{--patch} オプションの機能を含んでいます。パッチ出力は @samp{--no-patch} を使用して抑制できますが、他の差分形式(つまり、 @samp{--raw}, @samp{--numstat}, @samp{--shortstat}, @samp{--dirstat}, @samp{--summary}, @samp{--name-only}, @samp{--name-status}, @samp{--check})は現在実装されていません。

<start> と <end> は、以下のいずれかの形式です:

@itemize 

@item
数値

<start> または <end> が数値の場合、絶対行番号を指定します(行は1から数えます)。

@item
@samp{/regex/}

この形式は、指定されたPOSIX正規表現に一致する最初の行を使用します。 <start> が正規表現の場合、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 <start> が @samp{^/regex/} の場合、ファイルの先頭から検索します。 <end> が正規表現の場合、 <start> で指定された行から検索開始します。

@item
+offset or -offset

これは <end> に対してのみ有効であり、 <start> で指定された行の前後の行数を指定します。
@end itemize

<start> と <end> の代わりに @samp{:<funcname>} が指定されている場合、これは <funcname> に一致する最初の関数名行から次の関数名行までの範囲を示す正規表現です。 @samp{:<funcname>} は、前の @samp{-L} 範囲の末尾から検索します。それ以外の場合は、ファイルの先頭から検索します。 @samp{^:<funcname>} はファイルの先頭から検索します。関数名は、 @samp{git diff} がパッチハンクヘッダーを処理するのと同じ方法で決定されます(gitattributes(5) の「Defining a custom hunk-header」参照)。

@item  <revision range> 
表示するリビジョンを制限します。これは、指定されたリビジョンからの表示を意味する単一のリビジョンのいずれか、または、"@emph{<from>}..@emph{<to>}" 形式の範囲で、 <from> から <to> までのすべてのリビジョンを表示することもできます。注意:より高度なリビジョン選択を適用できることに注意してください。オブジェクト名のスペルのより完全なリストについては、 gitrevisions(7) を参照してください。

@item  <path>… 
指定されたパス内のファイルにアクセスするモノだけにコミットを制限します。注意:リビジョン名に関するあいまいさを避けるために、 @samp{--} を使用してパスを先行するオプションから分離することに注意してください。
@end table

@noindent

@heading gitk-specific options

@table @asis

@item  @samp{--argscmd=<command>} 
gitkが表示するリビジョン範囲を決定する必要があるたびに実行されるコマンド。このコマンドは、標準出力に、表示される追加のリビジョンのリストを1行に1つずつ出力することが期待されています。表示するコミットのセットが更新ごとに異なる可能性がある場合は、<リビジョン範囲> を明示的に指定する代わりにこれを使用してください。

@item  @samp{--select-commit=<ref>} 
グラフを読み込んだ後、指定したコミットを選択します。デフォルトの動作は、 @samp{-select-commit=HEAD} を指定するのと同じです。
@end table

@noindent

@chapheading Examples

@table @asis

@item  gitk v2.6.12.. include/scsi drivers/scsi 
バージョン「v2.6.12」以降の変更で、include/scsiまたはdrivers/scsiサブディレクトリ内で変更されたファイルを表示する

@item  gitk --since="2 weeks ago" -- gitk 
ファイル @samp{gitk} について過去2週間の変更を表示します。 @samp{--} は、ブランチ名 @samp{gitk} と混同されるのを避けるために必要です。

@item  gitk --max-count=100 --all -- Makefile 
ファイル @samp{Makefile} に加えられた最大100個の変更を表示します。現在のブランチの変更だけを探すのではなく、すべてのブランチを調べます。
@end table

@noindent

@chapheading Files

ユーザー構成と設定は以下の場所に保存されます:

@itemize 

@item
存在すれば @samp{$XDG_CONFIG_HOME/git/gitk} です。でなければ、

@item
存在すれば @samp{$HOME/.gitk} です。
@end itemize

上記のいずれも存在しない場合は、デフォルトで @samp{$XDG_CONFIG_HOME/git/gitk} が作成されて使用されます。 @emph{$XDG_CONFIG_HOME} が設定されていない場合、すべての場合でデフォルトで @samp{$HOME/.config} になります。

@noindent

@chapheading History

Gitkは最初のグラフィカルリポジトリブラウザでした。それはtcl/tkで書かれています。

@samp{gitk} は実際には独立したプロジェクトとして維持されていますが、エンドユーザーの便宜のために安定したバージョンがGitスイートの一部として配布されています。

gitk-git/ は、 Paul Mackerras のgitkプロジェクトからのものです:

@example
git://ozlabs.org/~paulus/gitk
@end example

@noindent

@chapheading SEE ALSO

@table @asis

@item  @emph{qgit(1)} 
Qtを使用してC++で記述されたリポジトリブラウザです。

@item  @emph{tig(1)} 
Ncursesを使用してCで記述された最小限のリポジトリブラウザーとGitツールの出力ハイライト。
@end table

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitmailmap,,,Top
@chapheading Name

gitmailmap — 作者(author)/コミッター(committer) および/または 電子メールアドレス(E-Mail addresses)をマップします

@noindent

@chapheading Synopsis

$GIT_WORK_TREE/.mailmap

@noindent

@chapheading DESCRIPTION

ファイル @samp{.mailmap} がリポジトリのトップレベルに存在する場合、または @samp{mailmap.file} とか @samp{mailmap.blob} 構成オプション(git-config(1) 参照)が指す場所(ファイルパスとかブロブ)に存在する場合は、 作者とコミッターの名前と電子メールアドレスを、正規の本名と電子メールアドレスにマッピングするために使用されます。

@noindent

@chapheading SYNTAX

@emph{#} 文字から行末まではコメントで、空白行は無視されます。

単純な形式では、ファイルの各行は、作成の正規の本名、空白、および名前にマップするためにコミットで使用される電子メールアドレス(@emph{<} と @emph{>} で囲まれている)で構成されます。 例えば:

@example
Proper Name <commit@@email.xx>
@end example

より複雑な形式では:

@example
<proper@@email.xx> <commit@@email.xx>
@end example

で、これにより、メールマップはコミット用の電子メールアドレスのみを置き換えることができます。そして:

@example
Proper Name <proper@@email.xx> <commit@@email.xx>
@end example

では、mailmapは、指定されたコミット用電子メールアドレスに一致するコミッターの名前と電子メールのアドレス両方を置き換えることができます。そして:

@example
Proper Name <proper@@email.xx> Commit Name <commit@@email.xx>
@end example

では、mailmapは、指定されたコミッターの名前と電子メールアドレスの両方に一致するコミッターの名前と電子メールの両方を置き換えることができます。

電子メールアドレスと名前の両方が大文字と小文字を区別せずに照合されます。たとえば、以下は上記の @emph{Commit Name <commit@@email.xx>} とも一致します:

@example
Proper Name <proper@@email.xx> CoMmIt NaMe <CoMmIt@@EmAiL.xX>
@end example

@noindent

@chapheading NOTES

作業ツリーの @samp{.mailmap} ファイルにアクセスするとき、Gitはシンボリックリンクをたどりません。 これにより、ファイルがインデックスまたはツリーからアクセスされたときとファイルシステムからアクセスされたときの動作の一貫性が保たれます。

@noindent

@chapheading EXAMPLES

あなたの履歴には、JaneとJoeの2人の作者(authors)によるコミットが含まれています。これらの作成の名前は、リポジトリにいくつかの形式で表示されます:

@example
Joe Developer <joe@@example.com>
Joe R. Developer <joe@@example.com>
Jane Doe <jane@@example.com>
Jane Doe <jane@@laptop.(none)>
Jane D. <jane@@desktop.(none)>
@end example


ここで、Joeが当初は、ミドルネームを使用することを望み、Janeが彼女の家族名を完全に綴ることを好むとします。名前を修正するための @samp{.mailmap} ファイルは以下のようになります:

@example
Joe R. Developer <joe@@example.com>
Jane Doe <jane@@example.com>
Jane Doe <jane@@desktop.(none)>
@end example


注意: 名前を修正するためだけに、 @emph{<jane@@laptop.(none)>} のnamesをマップする必要はないことに注意してください。ただし、明らかに壊れた @emph{<jane@@laptop.(none)>} と @emph{<jane@@desktop.(none)>} というの電子メールアドレスをそのままにしておくことは、通常、希望するものではありません。したがって、これらも修正する @samp{.mailmap} ファイルは以下のとおりです:

@example
Joe R. Developer <joe@@example.com>
Jane Doe <jane@@example.com> <jane@@laptop.(none)>
Jane Doe <jane@@example.com> <jane@@desktop.(none)>
@end example


最後に、JoeとJaneが電子メールアドレスを共有しているが、名前は共有していないとしましょう。バグ報告システムによって生成された履歴にそれぞれのコミットを含めるとします。つまり、履歴には以下のように名前があらわれます:

@example
Joe <bugs@@example.com>
Jane <bugs@@example.com>
@end example


これらのケースも処理する完全な @samp{.mailmap} ファイル(上記の例に2行追加)は以下のようになります:

@example
Joe R. Developer <joe@@example.com>
Jane Doe <jane@@example.com> <jane@@laptop.(none)>
Jane Doe <jane@@example.com> <jane@@desktop.(none)>
Joe R. Developer <joe@@example.com> Joe <bugs@@example.com>
Jane Doe <jane@@example.com> Jane <bugs@@example.com>
@end example


@noindent

@chapheading SEE ALSO

git-check-mailmap(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitmodules,,,Top
@chapheading Name

gitmodules — サブモジュールプロパティの定義

@noindent

@chapheading Synopsis

$GIT_WORK_TREE/.gitmodules

@noindent

@chapheading DESCRIPTION

Git作業ツリーの最上位ディレクトリにある @samp{.gitmodules} ファイルは、 git-config(1) の構文を持つテキストファイルです。

このファイルには、サブモジュールごとに1つのサブセクションが含まれており、サブセクションの値はサブモジュールの名前です。名前は、 @samp{git submodule add} の @samp{--name} プションでカスタマイズされていない限り、サブモジュールが追加されたパス名として使用されます。各サブモジュールセクションには、以下の必須キーも含まれています:

@table @asis

@item  submodule.<name>.path 
サブモジュールがチェックアウトされると予想される、Git作業ツリーの最上位ディレクトリを基準にしたパスを定義します。 パス名は`/` で終わらせてはいけません。 すべてのサブモジュールパスは、 @samp{.gitmodules} ファイル内で一意である必要があります。

@item  submodule.<name>.url 
サブモジュールリポジトリのクローンを作成できるURLを定義します。 これは、 git-clone(1) に渡す準備ができている絶対URLか、 ( @samp{./} または @samp{../} で始まる場合)スーパープロジェクトの、元のリポジトリ(superproject’s origin repository)から相対的な場所のいずれかです。
@end table

さらに、いくつかのオプションのキーがあります:

@table @asis

@item  submodule.<name>.update 
名前付きサブモジュールのデフォルトの更新手順を定義します。つまり、スーパープロジェクトの @samp{git submodul eupdate} コマンドによってサブモジュールが更新される方法を定義します。これは、同一名称の構成変数を初期化するために @samp{git submodule init} によってのみ使用されます。 ここで許可される値は、「checkout」、「rebase」、「merge」、「none」です。 それらの意味については、 git-submodule(1) の「update」コマンドの説明を参照してください。セキュリティ上の理由から、「!command」形式は受け入れられません。

@item  submodule.<name>.branch 
アップストリームサブモジュールの更新を追跡するためのリモートブランチ名。このオプションが指定されていない場合のデフォルトは、リモートのHEADになります。 別な値 @samp{.} は、サブモジュール内のブランチ名が現在のリポジトリ内の現在のブランチ名と同一でなければならないことを示すために使用されます。詳細については、 git-submodule(1) の @samp{--remote} ドキュメントを参照してください。

@item  submodule.<name>.fetchRecurseSubmodules 
このオプションは、このサブモジュールの再帰的フェッチを制御するために使用できます。このオプションがスーパープロジェクトの @samp{.git/config} のサブモジュールのエントリにも存在する場合、そこでの設定は @samp{.gitmodules} にある設定を上書きします。コマンドラインで両方の設定を上書きするには、 @samp{--[no-]recurse-submodules} オプションを @samp{git fetch} と @samp{git pull} で使用します。

@item  submodule.<name>.ignore 
どのような状況で @samp{git status} とdiffファミリーがサブモジュールを変更済みとして表示するかを定義します。指定できるのは以下の値です:

@table @asis

@item  all 
The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).

@item  dirty 
All changes to the submodule’s work tree will be ignored, only committed differences between the @samp{HEAD} of the submodule and its recorded state in the superproject are taken into account.

@item  untracked 
Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.

@item  none 
No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.
@end table

このオプションがスーパープロジェクトの @samp{.git/config} のサブモジュールのエントリにも存在する場合、そこでの設定は @samp{.gitmodules} にある設定を上書きします。

@samp{--ignore-submodules} オプションを使用すると、コマンドラインで両方の設定を上書きできます。 @samp{git submodule} コマンドは、この設定の影響を受けません。

@item  submodule.<name>.shallow 
trueに設定すると、ユーザーが明示的に非浅いクローン(non-shallow clone)を要求しない限り、このサブモジュールのクローンは浅いクローン(shallow clone)(履歴の深さ1)として実行されます。
@end table

@noindent

@chapheading NOTES

Gitは、作業ツリー内の @samp{.gitmodules} ファイルをシンボリックリンクにすることを許可せず、そのようなツリーエントリのチェックアウトを拒否します。これにより、ファイルがインデックスまたはツリーからアクセスされたときとファイルシステムからアクセスされたときの動作の一貫性が保たれ、Gitがファイルの内容のセキュリティチェックを確実に実施できるようになります。

@noindent

@chapheading EXAMPLES

以下の @samp{.gitmodules} ファイルについて考えてみます:

@example
[submodule "libfoo"]
        path = include/foo
        url = git://foo.com/git/lib.git

[submodule "libbar"]
        path = include/bar
        url = git://bar.com/git/lib.git
@end example


これは、@samp{libfoo} と @samp{libbar} の2つのサブモジュールを定義します。 これらはパス @samp{include/foo} と @samp{include/bar} でチェックアウトされることが期待されており、両方のサブモジュールに対して、サブモジュールのクローン作成に使用できるURLが指定されています。

@noindent

@chapheading SEE ALSO

git-submodule(1), gitsubmodules(7), git-config(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitnamespaces,,,Top
@chapheading Name

gitnamespaces — Git名前空間

@noindent

@chapheading Synopsis

@display
GIT_NAMESPACE=<namespace> git upload-pack
GIT_NAMESPACE=<namespace> git receive-pack
@end display


@noindent

@chapheading DESCRIPTION

Gitは、単一のリポジトリのrefを複数の名前空間に分割することをサポートしています。各名前空間には、独自のブランチ、タグ、およびHEADがあります。Gitは、オブジェクトストアを共有し、すべてのrefを git-gc(1) などの操作に公開しながら、プル元とプッシュ先の独立したリポジトリとして各名前空間を公開できます。

複数のリポジトリを単一のリポジトリの名前空間として保存すると、同じソースの複数のブランチを保存する場合など、同じオブジェクトの重複コピーを保存することを回避できます。代替メカニズムは、重複を回避するための同様のサポートを提供しますが、名前空間が行うのに対し、代替は、継続的なメンテナンスなしでリポジトリに追加された新しいオブジェクト間の重複を防止しません。

名前空間を指定するには、 @samp{GIT_NAMESPACE} 環境変数に名前空間を設定します。 ref名前空間ごとに、Gitは対応するrefを @samp{refs/namespaces/} の下のディレクトリに保存します。 たとえば、 @samp{GIT_NAMESPACE=foo} はrefを @samp{refs/namespaces/foo/} の下に保存します。 git(1) の @samp{--namespace} オプションを使用して名前空間を指定することもできます。

注意: @samp{/} を含む名前空間は、名前空間の階層に拡張されることに注意してください。たとえば、 @samp{GIT_NAMESPACE=foo/bar} はrefを @samp{refs/namespaces/foo/refs/namespaces/bar/} の下に保存します。 これにより、 @samp{GIT_NAMESPACE} のパスが階層的に動作するため、 @samp{GIT_NAMESPACE=foo/bar} でクローンを作成すると、 @samp{GIT_NAMESPACE=foo} でクローンを作成してそのリポジトリから @samp{GIT_NAMESPACE=bar} でクローンを作成するのと同じ結果が得られます。また、 @samp{foo/refs/heads/} などの奇妙な名前空間パスとのあいまいさを回避します。そうしないと、 @samp{refs} ディレクトリ内で ディレクトリ/ファイル の競合が発生する可能性があります。

git-upload-pack(1) と git-receive-pack(1) は、 @samp{GIT_NAMESPACE} で指定されているようにrefの名前を書き換えます。 git-upload-pack と git-receive-pack は、指定された名前空間外のすべてのrefを無視します。

スマートHTTPサーバー git-http-backend(1) は、 GIT_NAMESPACE をバックエンドプログラムに渡します。リポジトリの名前空間をリポジトリとして公開するための設定例については、 git-http-backend(1) を参照してください。

簡単なローカルテストには、あなたは git-remote-ext(1) を使用できます:

@example
git clone ext::'git --namespace=foo %s /tmp/prefixed.git'
@end example


@noindent

@chapheading SECURITY

フェッチおよびプッシュプロトコルは、共有することを意図していない一方の側が他方のリポジトリからデータを盗むのを防ぐようには設計されていません。悪意のある者から保護する必要のあるプライベートデータがある場合、最善のオプションはそれを別のリポジトリに保存することです。これは、クライアントとサーバーの両方に適用されます。特に、サーバー上の名前空間は、読み取りアクセス制御には効果的ではありません。リポジトリ全体への読み取りアクセスで信頼できるクライアントにのみ、名前空間への読み取りアクセスを許可する必要があります。

既知の攻撃ベクトル(attack vectors)は以下のとおりです:

@enumerate 

@item
被害者は、明示的に共有することを意図していないオブジェクトのIDをアドバタイズする "have" 行を送信しますが、他にもIDを持っている者が居る場合は、転送を最適化するために使用できます。攻撃者はオブジェクトID Xを選択して盗み、refをXに送信しますが、被害者はすでにXのコンテンツを持っているため、Xのコンテンツを送信する必要はありません。 これで、被害者は攻撃者がXを持っていると信じ、Xのコンテンツを後で攻撃者に送り返します。 (この攻撃は、クライアントがアクセスできる名前空間にXへのrefを作成してフェッチすることにより、クライアントがサーバー上で実行するのが最も簡単です。サーバーがクライアント上で実行する最も可能性の高い方法は、Xをパブリックブランチにマージし、ユーザーがこのブランチで追加の作業を行い、マージに気付かずにサーバーにプッシュバックすることを期待します。)

@item
#1 と同様に、攻撃者は盗むオブジェクトID Xを選択します。被害者は、攻撃者がすでに持っているオブジェクトYを送信し、攻撃者はYではなくXを持っていると誤って主張するため、被害者はYをXに対するデルタとして送信します。デルタは、攻撃者にYに類似したXの領域を明らかにします。
@end enumerate

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitprotocol-capabilities,,,Top
@chapheading Name

gitprotocol-capabilities — プロトコル v0 と v1 の機能

@noindent

@chapheading Synopsis

@display
<over-the-wire-protocol>
@end display


@noindent

@chapheading DESCRIPTION

@quotation

@strong{Note}

このドキュメントでは、パックプロトコルのバージョン 0 および 1 の機能について説明します。 バージョン 2 については、 gitprotocol-v2(5) ドキュメントを参照してください。
@end quotation

サーバーは、このドキュメントで定義されているすべての機能をサポートするべきです。

receive-pack および upload-pack の最初のサーバー応答の最初の行で、最初の参照の後に NUL バイトが続き、次にスペースで区切られたサーバー機能のリストが続きます。 これらにより、サーバーはクライアントに対してサポートできるものとサポートできないものを宣言できます。

次に、クライアントは、有効にしたい機能のスペース区切りのリストを送信します。 クライアントは、サーバーがサポートしているとは言っていない機能を要求してはいけません。

サーバーは送信された機能について診断し、理解できない機能が送信された場合、中止(abort)しなければなりません。サーバーは、クライアントが要求し、かつ、サーバーが宣伝(advertise)した機能の実行を無視してはなりません。 これらのルールの結果として、サーバーは理解できない機能を宣伝してはなりません。

atomic 機能と report-status 機能と report-status-v2 機能と delete-refs 機能と quiet 機能と push-cert 機能が送信され、 receive-pack 処理(サーバーへのプッシュ処理)によって認識されます。

@samp{ofs-delta} と @samp{side-band-64k} 機能は、 upload-pack プロトコルと receive-pack プロトコルの両方によって送信および認識されます。 agent 機能と session-id 機能は、オプションで両方のプロトコルで送信できます。

他のすべての機能は、upload-pack (サーバーからのフェッチ) 処理によってのみ認識されます。

@noindent

@chapheading multi_ack

「multi_ack」機能により、サーバーは、クライアントの要求セットと所持しているセットの間で、共通のベースとして使用できるコミットを見つけるとすぐに「ACK obj-id continue」を返すことができます。

これを早期に送信することで、サーバーは、クライアントがクライアントのリポジトリ履歴の特定のブランチをさらにたどり下っていくのを防ぐことができます。 クライアントは、サーバーが DAG を完全に通過するまで、またはクライアントが「完了」と言うまで、他のブランチをたどってそれらのラインを送信する必要がある場合があります。

multi_ack がない場合、サーバーが共通のベースを見つけるまで、クライアントは @samp{--date-order} で have 行を送信します。 つまり、クライアントは、サーバーが既に共通であると認識している行を送信します。これは、サーバーがまだ共通のベースを見つけていない別のブランチと時間的に重複するためです。

たとえば、以下の図のように、クライアントにはサーバーにない大文字で表されるのコミットがあり、サーバーにはクライアントにはない小文字で表されるコミットがあるとします:

@example
       +---- u ---------------------- x
/              +----- y
/              /
a -- b -- c -- d -- E -- F
\
        +--- Q -- R -- S
@end example

クライアントが x,y を必要としていて、最初に have F,S と言って開始した場合、サーバーは F,S が何であるかを知りません。 最終的に、クライアントは「have d」と言い、サーバーは「ACK d continue」を送信して、クライアントにそのラインをたどるのをやめるように通知します（したがって、c-b-a を送信しないでください）が、しかし、まだ完了していないため、x のベースが必要です。 クライアントは、a に到達するまで S-R-Q を続行し、到達した時点でサーバーは明確なベースを持ち、すべてが終了します。

multi_ackがなければ、クライアントは S-R-Q を差し挟んで、いずれにせよ c-b-a チェーンを送信していたでしょう。

@noindent

@chapheading multi_ack_detailed

これは、クライアントがサーバーのメモリ内状態をよりよく理解できるようにする multi_ack の拡張です。 詳細については、 gitprotocol-pack(5) の「Packfile Negotiation」セクションを参照してください。

@noindent

@chapheading no-done

この機能は、スマート HTTP プロトコルでのみ使用するべきです。 multi_ack_detailed と no-done の両方が存在する場合、送信者は、最初の「ACK obj-id ready」メッセージに続いて、パックをすぐに自由に送信できます。

スマート HTTP プロトコルで no-done がないと、サーバーセッションが終了し、サーバーがパックを送信する前に、クライアントは "done" を送信するために別のトリップ(trip)を行う必要があります。 no-done は最後のラウンド(round)を削除するため、待ち時間がわずかに短縮されます。

@noindent

@chapheading thin-pack

シンパックは、パック内に含まれていないベースオブジェクトを参照するデルタを持つパックです (ただし、受信側に存在することがわかっています)。 これにより、ネットワークトラフィックを大幅に削減できますが、受信側は、不足しているベースをパックに追加してこれらのパックを「厚く」する方法を知っている必要があります。

upload-pack サーバーは、シンパックを生成して送信できる場合に「thin-pack」を宣伝(advertise)します。 クライアントは、それを「厚く」する方法を理解したときに「thin-pack」機能を要求し、そのようなパックを受信できることをサーバーに通知します。 シンパックを自己完結型パックに変換できない場合、クライアントは「thin-pack」機能を要求してはなりません。

一方、 receive-pack はデフォルトでシンパックを処理できると想定されていますが、「no-thin」機能をアドバタイズすることで、クライアントに機能を使用しないように要求できます。 サーバーが「no-thin」機能を宣伝する場合、クライアントはシンパックを送信してはなりません。

この非対称性の理由は歴史的なものです。 receive-pack プログラムはシンパックが発明されるまで存在しなかったため、歴史的には receive-pack のリファレンス実装は常にシンパックを理解していました。 後で「no-thin」を追加すると、後方互換性のある方法で receive-pack が機能を無効にすることができました。

@noindent

@chapheading side-band, side-band-64k

この機能は、サーバーが送信できることを意味し、クライアントは、パックファイル自体に差し挟まれた多重化された進行状況レポートとエラー情報を理解します。

これら 2 つのオプションは相互に排他的です。 最新のクライアントは、常に「side-band-64k」を好みます。

いずれのモードも、パックファイルデータが「side_band」の場合は最大 1000 バイト、「side_band_64k」の場合は 65520 バイトのパケットに分割されてストリーミングされることを示します。 各パケットは、パケット内のデータ量を示す先頭の 4 バイトの pkt-line 長と、その後に続く 1 バイトのストリームコード、および実際のデータで構成されます。

ストリームコードは以下のいずれか一つです:

@example
1 - パックデータ
2 - 進行メッセージ
3 - ストリームが中止(abort)される直前の致命的なエラーメッセージ
@end example

「side-band-64k」機能は、古いクライアントとの下位互換性を維持しながら、実際にはほぼいっぱいに詰め込まれたパケットを要求するために、はるかに大きなパケットを処理できる新しいクライアントの方法として生まれました。

さらに、 side-band とその最大 1000 バイトのメッセージを使用すると、実際には 999 バイトのペイロードと 1 バイトのストリームコードになります。 side-band-64k を使用すると、同じ取引で、最大 65519 バイトのデータと 1 バイトのストリームコードで使用できます。

クライアントは、 "side-band" と "side-band-64k" の最大値のどちらか 1 つだけ送信しなければなりません。 クライアントが両方を要求した場合、サーバーはそれをエラーとして診断しなければなりません。

@noindent

@chapheading ofs-delta

サーバーは送信でき、クライアントは、obj-id ではなくパック内の位置によってベースを参照するデルタを使用して PACKv2 を理解します。 つまり、パックファイルで OBJ_OFS_DELTA (別名:タイプ 6) を 送信/読み取り することができます。

@noindent

@chapheading agent

サーバーは、サーバーがバージョン「X」を実行していることをクライアントに通知するために、オプションで「agent=X」の形式の機能を送信できます。 クライアントはオプションで、@samp{agent=Y} 機能で応答することにより、独自のエージェント文字列を返すことができます (ただし、サーバーがエージェント機能について言及していない場合は、そうしてはなりません)。 @samp{X} および @samp{Y} 文字列には、スペースを除く任意の印刷可能な ASCII 文字 (つまり、バイト範囲 32 < x < 127) を含めることができ、通常は「パッケージ/バージョン」(「git/1.8.3.1」など) の形式になります。 エージェント文字列は、統計とデバッグの目的で純粋に情報を提供するものであり、特定の機能の有無をプログラムで想定するために使用してはなりません。

@noindent

@chapheading object-format

ハッシュアルゴリズムを引数として取るこの機能は、サーバーが特定のハッシュ アルゴリズムをサポートしていることを示します。 複数回送信される場合があります。 その場合、最初に指定されたものは、ref 広告(ref advertisement)で使用されたものです。

クライアントによって提供された場合、これは、クライアントが指定のハッシュアルゴリズムを使用して通信することを意図していることを示します。 提供されるアルゴリズムは、サーバーがサポートするものでなければなりません。

この機能が提供されていない場合、サポートされているアルゴリズムは SHA-1 だけであると見なされます。

@noindent

@chapheading symref

このパラメーター化された機能は、どのシンボリック ref がどの ref を指しているかを受信者に通知するために使用されます。 たとえば、 @samp{symref=HEAD:refs/heads/master} は、HEAD が master を指していることをレシーバーに伝えます。 この機能を繰り返して、複数の symref を表すことができます。

HEAD symref が送信される参照の 1 つである場合、サーバーはこの機能を HEAD symref に含めるべきです。

クライアントは、この機能のパラメーターを使用して、リポジトリのクローンを作成するときに適切な初期ブランチを選択するでしょう。

@noindent

@chapheading shallow

この機能は、「deepen」と「shallow」と「unshallow」コマンドを fetch-pack/upload-pack プロトコルに追加して、クライアントが浅いクローン(shallow clones)を要求できるようにします。

@noindent

@chapheading deepen-since

この機能により、「deepen-since」コマンドが fetch-pack/upload-pack プロトコルに追加されるため、クライアントは深さではなく、特定の日時でカットされる浅いクローンを要求できます。 内部的には、サーバー側で @samp{rev-list --max-age=<timestamp>} を実行するのと同じです。 「deepen-since」は「deepen」と併用できません。

@noindent

@chapheading deepen-not

この機能により、「deepen-not」コマンドが fetch-pack/upload-pack プロトコルに追加されるため、クライアントは深さではなく特定のリビジョンでカットされた浅いクローンを要求できます。 内部的には、サーバー側で @samp{rev-list --not <rev>} を実行するのと同じです。 「deepen-not」は「deepen」では使用できませんが、「deepen-since」では使用できます。

@noindent

@chapheading deepen-relative

この機能がクライアントによって要求された場合、「deepen」コマンドのセマンティクスが変更されます。 「深さ」引数は、リモートrefからの深さではなく、現在の浅い境界からの深さです。

@noindent

@chapheading no-progress

クライアントは「git clone -q」などで開始され、その サイドバンド 2 は必要ありません。基本的に、クライアントは「私はサイドバンドでストリーム 2 を受信したくないので、送信しないでください。 もし送信されたら、とにかく破棄します。(I will drop it on the floor anyway)」 ただし、サイドバンド チャネル 3 はエラー応答に引き続き使用されます。

@noindent

@chapheading include-tag

「include-tag」機能は、それらが指すオブジェクトを送信する場合に、注釈付きタグを送信することに関するものです。 オブジェクトをクライアントにパックし、タグ オブジェクトがそのオブジェクトを正確に指す場合、タグオブジェクトもパックします。 一般に、これにより、クライアントは単一のネットワーク接続でブランチをフェッチするときに、すべての新しい注釈付きタグを取得できます。

クライアントは、サーバーがこの機能を宣伝するときに、常に include-tag を要求にハードコーディングして送信しても構いません。 クライアントが include-tag を要求するかどうかの決定は、サーバーが @samp{refs/tags/*} 名前空間でオブジェクトを宣伝したかどうかに関係なく、タグデータに対するクライアントの要求にのみ関係があります。

サーバーは、リファラント(referrant)がパックされていて、クライアントが include-tags を要求している場合、タグをパックする必要があります。

クライアントは、サーバーが include-tag を無視し、パック内のタグを実際に送信していない場合に備えなければなりません。 そのような場合、クライアントは後続のフェッチを発行して、そうでなければ include-tag がクライアントに与えるタグを取得する必要があります。

サーバーは、使用可能なタグがあるかどうかに関係なく、サポートしている場合、 include-tag を送信すべきです。

@noindent

@chapheading report-status

receive-pack プロセスは、「report-status」機能を受け取ることができます。これは、クライアントがパックファイルのアップロードと参照の更新後に何が起こったかのレポートを必要としていることを伝えます。 プッシュするクライアントがこの機能を要求すると、参照をアンパックして更新した後、サーバーはパックファイルが正常にアンパックされたかどうか、および各参照が正常に更新されたかどうかを応答します。 それらのいずれかが成功しなかった場合、エラーメッセージが返されます。 メッセージの例については、 gitprotocol-pack(5) を参照してください。

@noindent

@chapheading report-status-v2

機能「report-status-v2」は、「proc-receive」フックによって書き換えられた参照をサポートするために、新しい「option」ディレクティブを追加して機能「report-status」を拡張します。 「proc-receive」フックは、異なる名前、new-oid、および old-oid で参照を作成または更新する可能性がある疑似参照のコマンドを処理できます。 機能「report-status」ではそのような場合にレポートできません。 詳細については、 gitprotocol-pack(5) を参照してください。

@noindent

@chapheading delete-refs

サーバーが「delete-refs」機能を返送する場合、それは参照更新のターゲット値としてゼロ ID 値を受け入れることができることを意味します。 クライアントから送り返されるのではなく、参照を削除するためにゼロ ID 値を送信できることをクライアントに通知するだけです。

@noindent

@chapheading quiet

receive-pack サーバーが「quiet」機能を宣伝する場合、受信したパックを処理するときに表示される可能性のある、人間が読める進行状況出力を黙らせる事ができます。 send-pack クライアントは、ローカルの進捗レポートも抑制されている場合 (たとえば、「push -q」を介して、または stderr が tty に出力されない場合)、サーバー側の進捗レポートを抑制する「quiet」機能で応答する必要があります。

@noindent

@chapheading atomic

サーバーが「atomic」機能を送信すると、アトミック プッシュを受け入れることができます。 プッシュするクライアントがこの機能を要求すると、サーバーはたった 1 つのアトミック取引(atomic transaction)でrefを更新します。 すべてのrefが更新されるか、まったく更新されません。

@noindent

@chapheading push-options

サーバーが「push-options」機能を送信すると、updateコマンドが送信された後、パックファイルがストリーミングされる前に、プッシュ オプションを受け入れることができます。 プッシュするクライアントがこの機能を要求すると、サーバーは、このプッシュ要求を処理する pre-receive フックと post-receive フックにオプションを渡します。

@noindent

@chapheading allow-tip-sha1-in-want

upload-pack サーバーがこの機能を宣伝する場合、fetch-pack は、サーバーに存在するが、upload-pack によって宣伝されていないオブジェクト名を含む「want」行を送信する場合があります。 歴史的な理由から、この機能の名前には「sha1」が含まれています。 オブジェクト名は常に、「object-format」機能によってネゴシエートされたオブジェクトフォーマットを使用して指定されます。

@noindent

@chapheading allow-reachable-sha1-in-want

upload-pack サーバーがこの機能を宣伝する場合、fetch-pack は、サーバーに存在するが、upload-pack によって宣伝されていないオブジェクト名を含む「want」行を送信する場合があります。 歴史的な理由から、この機能の名前には「sha1」が含まれています。 オブジェクト名は常に、「object-format」機能によってネゴシエートされたオブジェクトフォーマットを使用して指定されます。

@noindent

@chapheading push-cert=<nonce>

この機能を宣伝する receive-pack サーバーは、署名されたプッシュ証明書を喜んで受け入れ、<nonce> をプッシュ証明書に含めるように要求します。 send-pack クライアントは、receive-pack サーバーがこの機能を宣伝しない限り、push-cert パケットを送信してはいけません (MUST NOT)。

@noindent

@chapheading filter

upload-pack サーバーが「filter」機能を宣伝する場合、fetch-pack は「filter」コマンドを送信して部分クローン(partial clone)または部分フェッチ(partial fetch)を要求し、サーバーがパックファイルからさまざまなオブジェクトを省略するように要求する場合があります。

@noindent

@chapheading session-id=<session id>

サーバーは、複数のリクエストでこのプロセスを識別するために使用できるセッション ID を宣伝する場合があります。 クライアントは、独自のセッション ID をサーバーに宣伝することもできます。

セッション ID は、特定のプロセスに対して一意である必要があります。 それらはパケット行内に収まる必要があり、印刷できない文字や空白文字を含んではなりません。 現在の実装では trace2 セッション ID を使用していますが (詳細については、 @uref{technical/api-trace2.html,api-trace2} を参照してください)、これは変更される可能性があり、セッション ID のユーザーはこの事実に依存しないでください。

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitprotocol-common,,,Top
@chapheading Name

gitprotocol-common — 各種プロトコルの共通事項

@noindent

@chapheading Synopsis

@display
<over-the-wire-protocol>
@end display


@noindent

@chapheading DESCRIPTION

このドキュメント・セットは、 Git で使用されるさまざまな通信プロトコルとファイル形式に共通の事柄を定義します。

@noindent

@chapheading ABNF Notation

以下の置換コア・ルールが使用されていることを除き、RFC 5234で説明されているABNF記法がプロトコルドキュメント内で使用されます:

@example
  HEXDIG    =  DIGIT / "a" / "b" / "c" / "d" / "e" / "f"
@end example


また、以下の共通ルールを定義します:

@example
  NUL       =  %x00
  zero-id   =  40*"0"
  obj-id    =  40*(HEXDIGIT)

  refname  =  "HEAD"
  refname /=  "refs/" <see discussion below>
@end example


refnameは、 "refs/" で始まり、 @samp{git-check-ref-format} コマンドの検証ルールに違反していない階層的な8ビット文字列(octet string)です。より具体的には、それらは:

@enumerate 

@item
階層(ディレクトリ)グループ化のためにスラッシュ @samp{/} を含めることができますが、スラッシュで区切られたコンポーネントをドット @samp{.} で始めることはできません。

@item
少なくとも1つの @samp{/} が含まれている必要があります。 これにより、 @samp{heads/} 、 @samp{tags/} などのカテゴリの存在が強制されますが、実際の名前は制限されません。

@item
どこにも2つの連続したドット @samp{..} を含めることはできません。

@item
どこにも ASCII制御文字(つまり、値が \040 未満、または \177 @samp{DEL} )、空白、チルダ @samp{~} 、キャレット @samp{^} 、コロン @samp{:} 、 疑問符 @samp{?} 、アスタリスク @samp{*} 、 開き角かっこ @samp{[} は使用できません。

@item
スラッシュ @samp{/} またはドット @samp{.} で終了することはできません。

@item
シーケンス @samp{.lock} で終了することはできません。

@item
シーケンス @samp{@@@{} を含めることはできません。

@item
@samp{\} を含めることはできません。
@end enumerate

@noindent

@chapheading pkt-line Format

(すべてではありませんが)ペイロードの多くがpkt-lines周りで説明されています。

pkt-lineは、可変長のバイナリ文字列です。行の最初の4バイトであるpkt-lenは、行の全長を16進数で示します。pkt-lenには、長さの16進表現を含めるために使用される4バイトが含まれます。

pkt-lineにはバイナリデータが含まれる場合があるため、実装者はpkt-lineの パース/フォーマット ルーチンが8ビットクリーンであることを確認する必要があります。

非バイナリ行はLFで終了する必要があります。LFが存在する場合は、全長に含める必要があります。受信者は、非バイナリデータを含むpkt-lineを、末尾のLFが含まれているかどうかに関係なく同じように処理する必要があります(LFが存在する場合はそれを取り除き、欠落している場合は文句を言いません)。

pkt-lineのデータコンポーネントの最大長は65516バイトです。実装は、長さが65520(65516バイトのペイロード+4バイトの長さデータ)を超えるpkt-lineの送信は禁止でです。

実装は空のpkt-line("0004")を送信すべきではありません。

flash-pktと呼ばれる長さフィールドが0("0000")のpkt-lineは特殊なケースであり、空のpkt-line("0004")とは異なる方法で処理しなければいけません。

@example
  pkt-line     =  data-pkt / flush-pkt

  data-pkt     =  pkt-len pkt-payload
  pkt-len      =  4*(HEXDIG)
  pkt-payload  =  (pkt-len - 4)*(OCTET)

  flush-pkt    = "0000"
@end example


例(C言語の文字列形式):

@example
  pkt-line          actual value
  ---------------------------------
  "0006a\n"         "a\n"
  "0005a"           "a"
  "000bfoobar\n"    "foobar\n"
  "0004"            ""
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node gitprotocol-http,,,Top
@chapheading Name

gitprotocol-http — Git HTTPベース・プロトコル

@noindent

@chapheading Synopsis

@display
<over-the-wire-protocol>
@end display


@noindent

@chapheading DESCRIPTION

Git は、2 つの HTTP ベースの転送プロトコルをサポートしています。 接続するサーバー側で標準の HTTP サーバーのみを必要とする「バカ」(dumb)プロトコルと、Git 対応の CGI (またはサーバーモジュール) を必要とする「スマート」プロトコルです。 このドキュメントでは、両方のプロトコルについて説明します。

設計機能として、スマートクライアントは「バカ」(dumb)プロトコル URL をスマート URL に自動的にアップグレードできます。 これにより、すべてのユーザーが同じ URL を公開できるようになり、接続先(the peers)では利用可能な最も効率的な転送方法(transport)を自動的に選択します。

@noindent

@chapheading URL Format

HTTP によってアクセスされる Git リポジトリの URL は、RFC 1738 で文書化されている標準の HTTP URL 構文を使用するため、以下の形式になります:

@example
http://<host>:<port>/<path>?<searchpart>
@end example

このドキュメントでは、プレースホルダー @samp{$GIT_URL} は、エンドユーザーが入力した http:// リポジトリ URL を表すことにします。

サーバーは、@samp{$GIT_URL} に一致する場所へのすべてのリクエストを処理するべきです。 これは、Git で使用される「スマート」および「バカ」(dumb) HTTP プロトコルの両方が、ユーザーが指定した @samp{$GIT_URL} 文字列の末尾に追加のパスコンポーネントを追加することによって動作するためです。

ルーズオブジェクトをリクエストするバカ(dumb)クライアントの例:

@example
$GIT_URL:     http://example.com:8080/git/repo.git
URL request:  http://example.com:8080/git/repo.git/objects/d0/49f6c27a2244e12041955e262a404c7faba355
@end example

キャッチオール(catch-all)ゲートウェイへのスマートリクエストの例:

@example
$GIT_URL:     http://example.com/daemon.cgi?svc=git&q=
URL request:  http://example.com/daemon.cgi?svc=git&q=/info/refs&service=git-receive-pack
@end example

サブモジュール(submodule)へのリクエスト例:

@example
$GIT_URL:     http://example.com/git/repo.git/path/submodule.git
URL request:  http://example.com/git/repo.git/path/submodule.git/info/refs
@end example

クライアントは、サーバーに送信されるURLに空のパストークン(@samp{//})が表示されるのを防ぐために、ユーザーから与えられた $GIT_URL 文字列から、末尾に @samp{/} がある場合はそれを削除しなければなりません。 互換性のあるクライアントは、@samp{$GIT_URL/info/refs} を @samp{foo//info/refs} ではなく、@samp{foo/info/refs} として展開しなｋればなりません。

@noindent

@chapheading Authentication

リポジトリへのアクセスに認証が必要な場合は、標準の HTTP 認証が使用され、HTTPサーバーソフトウェアによって構成および強制される場合があります。

Gitリポジトリは標準パスコンポーネントによってアクセスされるため、サーバー管理者はHTTPサーバー内でディレクトリベースのアクセス許可を使用して、リポジトリ アクセスを制御できます。

クライアントは、RFC 2617 で説明されているベーシック認証をサポートする必要があります。 サーバーは、Gitサーバーソフトウェアの前に置かれたHTTPサーバーに頼ってベーシック認証をサポートすべきです(SHOULD)。

サーバーは、認証またはアクセス制御の目的で HTTP クッキーを要求すべきではありません。

クライアントとサーバーは、ダイジェスト認証など、他の一般的なHTTPベースの認証形式をサポートする場合があります。

@noindent

@chapheading SSL

クライアントとサーバーはSSLをサポートするべきです(SHOULD)。特に、ベーシック HTTP 認証に頼る場合にパスワードを保護するためです。

@noindent

@chapheading Session State

Git over HTTP プロトコル (HTTP 自体とよく似ています) は、HTTP サーバー側から見るとステートレスです。 すべての状態は、クライアントプロセスによって保持および管理されなければなりません。 これにより、サーバー側で単純なラウンドロビン負荷分散が可能になり、状態管理について心配する必要がなくなります。

クライアントは、正しく機能するためにサーバー側に状態管理を要求してはなりません。

サーバーは、正しく機能するために HTTP Cookie を要求してはなりません。 クライアントは、RFC 2616 (HTTP/1.1) で説明されているように、リクエスト処理中に HTTP Cookie を保存および転送できます。 サーバーは、クライアントから送信されたすべての Cookie を無視する必要があります。

@noindent

@chapheading General Request Processing

特に明記されている場合を除き、すべての標準 HTTP 動作は、クライアントとサーバーの両方で想定される必要があります。 これには以下が含まれます(必ずしもこれらに限定されません):

$GIT_URL にリポジトリがない場合、または $GIT_URL に一致する場所が指すリソースが存在しない場合、サーバーは @samp{200 OK} 応答で応答してはいけません。 サーバーは、 @samp{404 Not Found} または @samp{410 Gone} または要求どおりにリソースが存在することを意味しないその他の適切な HTTP ステータス コードで応答する必要があります。

$GIT_URL にリポジトリがあるが、アクセスが現在許可されていない場合、サーバーは @samp{403 Forbidden} HTTP ステータス コードで応答しなければなりません。

サーバーは、HTTP 1.0 と HTTP 1.1 の両方をサポートする必要があります。 サーバーは、リクエスト本文とレスポンス本文の両方でチャンクエンコーディングをサポートする必要があります。

クライアントは、HTTP 1.0 と HTTP 1.1 の両方をサポートする必要があります。 クライアントは、リクエスト本文とレスポンス本文の両方でチャンクエンコーディングをサポートする必要があります。

サーバは ETag かつ/または Last-Modified ヘッダー を返すことがあります。

クライアントは、If-Modified-Since および/または If-None-Match リクエストヘッダーを含めることにより、キャッシュされたエンティティを再検証することができます。

関連するヘッダーがリクエストに表れ、エンティティが変更されていない場合、サーバーは @samp{304 Not Modified} を返す場合があります。 クライアントは、キャッシュされたエンティティを再利用することにより、 @samp{304 Not Modified} を @samp{200 OK} と同じように扱わなければいけません。

Cache-Control および/または Expires ヘッダーがキャッシュを許可する場合、クライアントは再検証なしでキャッシュされたエンティティを再利用できます。 クライアントとサーバーは、キャッシュ制御について RFC 2616 に従わなければなりません。

@noindent

@chapheading Discovering References

すべての HTTP クライアントは、リモートリポジトリで利用可能な参照を検出して、フェッチまたはプッシュ交換を開始する必要があります。

@noindent

@heading Dumb Clients

「バカ」(dumb)プロトコルのみをサポートする HTTP クライアントは、リポジトリの特別な info/refs ファイルをリクエストして、参照を検出する必要があります。

バカ(dumb) HTTP クライアントは、検索/クエリ パラメータなしで、 @samp{$GIT_URL/info/refs} に対して @samp{GET} リクエストを作成する必要があります。

@example
C: GET $GIT_URL/info/refs HTTP/1.0
@end example

@example
S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1.0^@{@}
@end example

返された info/refs エンティティの Content-Type は、 @samp{text/plain charset=utf-8} であるべきですが、任意の Content-Type である場合があります。 クライアントは、返された Content-Type の検証を試みてはいけません。 バカ(dumb)サーバーは、 @samp{application/x-git-} で始まる戻り値のタイプを返してはいけません。

返されたエンティティのキャッシングを無効にするために、 Cache-Control ヘッダーが返される場合があります。

応答クライアントを調べる場合、HTTP ステータス コードのみを調べる必要があります。 有効な応答は、 @samp{200 OK} または @samp{304 Not Modified} です。

返されるコンテンツは、各refとその既知の値を記述した UNIX 形式のテキストファイルです。 ファイルは、C ロケールの順序に従って名前でソートする必要があります。 ファイルには、 @samp{HEAD} という名前のデフォルトrefを含めるべきではありません。

@example
info_refs   =  *( ref_record )
ref_record  =  any_ref / peeled_ref
@end example

@example
any_ref     =  obj-id HTAB refname LF
peeled_ref  =  obj-id HTAB refname LF
               obj-id HTAB refname "^@{@}" LF
@end example

@noindent

@heading Smart Clients

「スマート」(smart)プロトコル (または「スマート」プロトコルと「バカ」(dumb)プロトコルの両方) をサポートする HTTP クライアントは、リポジトリの info/refs ファイルに対してパラメーター化された要求を行うことにより、参照を検出する必要があります。

リクエストには、@samp{service=$servicename} というクエリパラメータが 1 つだけ含まれている必要があります。ここで、 @samp{$servicename} は、クライアントが操作を完了するために接続したいサービス名でなければなりません。 リクエストに追加のクエリパラメータを含めてはいけません。

@example
C: GET $GIT_URL/info/refs?service=git-upload-pack HTTP/1.0
@end example

バカ(dumb)サーバー返答:

@example
S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1.0^@{@}
@end example

スマートサーバー返答:

@example
S: 200 OK
S: Content-Type: application/x-git-upload-pack-advertisement
S: Cache-Control: no-cache
S:
S: 001e# service=git-upload-pack\n
S: 0000
S: 004895dcfa3633004da0049d3d0fa03f80589cbcaf31 refs/heads/maint\0multi_ack\n
S: 003fd049f6c27a2244e12041955e262a404c7faba355 refs/heads/master\n
S: 003c2cb58b79488a98d2721cea644875a8dd0026b115 refs/tags/v1.0\n
S: 003fa3c2e2402b99163d1d59756e5f207ae21cccba4c refs/tags/v1.0^@{@}\n
S: 0000
@end example

クライアントは、 追加パラメーター(Extra Parameters; gitprotocol-pack(5) 参照) を、 Git-Protocol HTTP ヘッダーでコロンで区切られた文字列として送信できます。

`--http-backend-info-refs@@ オプションを git-upload-pack(1) に使用します。

@noindent

@subheading Dumb Server Response

バカ(dumb)サーバーは、バカサーバー応答形式(the dumb server reply format)で応答しなければなりません。

バカ(dumb)サーバー応答の詳細な説明については、前述の「dumb clients」セクションを参照してください。

@noindent

@subheading Smart Server Response

サーバーがリクエストされたサービス名を認識しない場合、またはリクエストされたサービス名がサーバー管理者によって無効にされている場合、サーバーは @samp{403 Forbidden} HTTP ステータス コードで応答する必要があります。

それ以外の場合、スマートサーバーは、リクエストされたサービス名のスマートサーバー返答形式(the smart server reply format)で応答する必要があります。

Cache-Control ヘッダーは、返されたエンティティのキャッシュを無効にするために使用する必要があります。

Content-Type は @samp{application/x-$servicename-advertisement} でなければなりません。 別のコンテンツタイプが返された場合、クライアントはバカ(dumb)プロトコルにフォールバックする必要があります。 バカ(dumb)プロトコルクライアントにフォールバックするとき、クライアントは @samp{$GIT_URL/info/refs} に追加のリクエストを行うべきではなく、代わりに既に手元にある応答を使用すべきです。 バカ(dumb)プロトコルをサポートしていない場合、クライアントは続行(continue)してはいけません。

クライアントは、ステータスコードが @samp{200 OK} または @samp{304 Not Modified} であることを検証(validate)する必要があります。

クライアントは、応答エンティティの最初の 5 バイトが正規表現 @samp{^[0-9a-f]@{4@}#} とマッチすることを検証(validate)する必要があります。 このテストが失敗した場合、クライアントは続行(continue)してはいけません。

クライアントは、応答全体を一連の pkt-line レコードとしてパースしなければなりません。

クライアントは、最初の pkt-line が @samp{# service=$servicename} であることを確認(verify)する必要があります。 サーバーは $servicename をリクエストパラメータ値に設定する必要があります。 サーバーは、この行の最後に LF を含める必要があります。 クライアントは、行末の LF を無視する必要があります。

サーバーは、魔法の @samp{0000} pkt-line 終了マーカー(the magic @samp{0000} end pkt-line marker)で応答を終了する必要があります。

返される応答は、各refとその既知の値を説明する pkt-line ストリームです。 ストリームは、C ロケールの順序に従って名前でソートする必要があります。 ストリームには、最初のrefとして @samp{HEAD} という名前のデフォルトref照を含める必要があります。 ストリームは、最初のrefの NUL の後ろに機能宣言(capability declarations)を含める必要があります。

"version=1" が 追加パラメータ(Extra Parameter) として送信された場合、返される応答には "version 1" が含まれます。

@example
smart_reply     =  PKT-LINE("# service=$servicename" LF)
                   "0000"
                   *1("version 1")
                   ref_list
                   "0000"
ref_list        =  empty_list / non_empty_list
@end example

@example
empty_list      =  PKT-LINE(zero-id SP "capabilities^@{@}" NUL cap-list LF)
@end example

@example
non_empty_list  =  PKT-LINE(obj-id SP name NUL cap_list LF)
                   *ref_record
@end example

@example
cap-list        =  capability *(SP capability)
capability      =  1*(LC_ALPHA / DIGIT / "-" / "_")
LC_ALPHA        =  %x61-7A
@end example

@example
ref_record      =  any_ref / peeled_ref
any_ref         =  PKT-LINE(obj-id SP name LF)
peeled_ref      =  PKT-LINE(obj-id SP name LF)
                   PKT-LINE(obj-id SP name "^@{@}" LF
@end example

@noindent

@chapheading Smart Service git-upload-pack

このサービスは、 @samp{$GIT_URL} が指すリポジトリから読み込みます。

クライアントは、最初に @samp{$GIT_URL/info/refs?service=git-upload-pack} を使用して ref 検出を実行しなければなりません。

@example
C: POST $GIT_URL/git-upload-pack HTTP/1.0
C: Content-Type: application/x-git-upload-pack-request
C:
C: 0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7\n
C: 0032have 441b40d833fdfa93eb2908e52742248faf0ee993\n
C: 0000
@end example

@example
S: 200 OK
S: Content-Type: application/x-git-upload-pack-result
S: Cache-Control: no-cache
S:
S: ....ACK %s, continue
S: ....NAK
@end example

クライアントは、キャッシュされた応答を再利用(reuse)または再検証(revalidate)してはなりません。 サーバーは、応答のキャッシュを防ぐために十分な Cache-Control ヘッダーを含める必要があります。

サーバーは、ここで定義されたすべての機能をサポートすべきです。

クライアントは、リクエスト本文で少なくとも 1 つの @samp{want} コマンドを送信する必要があります。 サーバーが機能 @samp{allow-tip-sha1-in-want} または @samp{allow-reachable-sha1-in-want} を宣伝(advertise)しない限り、クライアントは @samp{want} コマンドで ref 検出によって取得された応答に表示されなかった ID を参照してはいけません。

@example
compute_request   =  want_list
                     have_list
                     request_end
request_end       =  "0000" / "done"
@end example

@example
want_list         =  PKT-LINE(want SP cap_list LF)
                     *(want_pkt)
want_pkt          =  PKT-LINE(want LF)
want              =  "want" SP id
cap_list          =  capability *(SP capability)
@end example

@example
have_list         =  *PKT-LINE("have" SP id LF)
@end example

TODO: 更に文書化する

@noindent

@heading The Negotiation Algorithm

最小パックを選択するための計算は以下のように行われます(C = クライアント、S = サーバー):

@samp{初期化ステップ:}

C: 広告されたref(advertised refs)を取得するためにref検出を使用します。

C: 検出したオブジェクトを @samp{advertised} セットに配置します。

C: 後で両端にあると判断されるかもしれないオブジェクトを保持するために、
空のセット @samp{common} を作成します。

C: ref検出中に発見したものに基づいて、クライアントが取得(fetch)したい
@samp{advertised} オブジェクトの @samp{want} セットを構築します。

C: コミット時間順に並べられたキュー @samp{c_pending} を開始(最新のものを最初に取り出す(pop))。
すべてのクライアントrefを追加します。
コミットがキューから取り出される(pop)と、その親が自動的に挿入し直されます(SHOULD)。
コミットがキューに入るのはは一度だけでなければなりません。

@samp{1回分の計算ステップ:}

C: @samp{$GIT_URL/git-upload-pack} リクエストを1つ送信します:

@example
C: 0032want <want #1>...............................
C: 0032want <want #2>...............................
....
C: 0032have <common #1>.............................
C: 0032have <common #2>.............................
....
C: 0032have <have #1>...............................
C: 0032have <have #2>...............................
....
C: 0000
@end example

ストリームは「コマンド群」に編成され、各コマンドは単独で pkt-line に表れれます。 コマンド行内では、最初の空白までのテキストがコマンド名であり、行の残りの最初の LF までが値です。 コマンド行は、 pkt-line 値の最後のバイトとしての LF で終了します。

コマンド群がリクエストストリームに表れる場合、以下の順序でなければなりません:

@itemize 

@item
"want"

@item
"have"
@end itemize

ストリームは pkt-line フラッシュ(@samp{0000})によって終了します。

単一の @samp{want} または @samp{have} コマンドは、その値として 1 つの 16 進形式のオブジェクト名を持たなければなりません。 複数のオブジェクト名は複数のコマンドを送信する必要があります。 オブジェクト名は、 @samp{object-format} 機能 (デフォルト SHA-1) によってネゴシエートされたオブジェクトフォーマットを使用して与える必要があります。

@samp{have} リストは、 @samp{c_pending} から最初の 32 個のコミットを取り出す(pop)ことによって作成されます。 @samp{c_pending} が空である場合、供給できる量が少なくなります。

クライアントが 256 の @samp{have} コミットを送信し、 @samp{s_common} からそれらの 1 つをまだ受信していない場合、またはクライアントが @samp{c_pending} を空にした場合、サーバーに続行しないことを知らせる @samp{done} コマンドを含める必要があります:

@example
C: 0009done
@end example

S: git-upload-pack リクエストをパースする:

@samp{want} 内のすべてのオブジェクトがrefから直に到達可能であることを確認(verify)します。

サーバーは、履歴または reflog をさかのぼって、気持ち古いリクエストを許可する場合があります。

@samp{want} オブジェクトが受信されない場合は、エラーを送信します: TODO: @samp{欲しい} 行がリクエストされていない場合はエラーを定義します。

@samp{want} オブジェクトに到達できない場合は、エラーを送信します: TODO: 無効な @samp{want} がリクエストされた場合はエラーを定義します。

空のリスト @samp{s_common} を作成します。

もし @samp{have} が送信されたら:

クライアントから提供された順序でオブジェクトをループします。

各オブジェクトについて、サーバーに ref から到達可能なオブジェクトがある場合は、それを @samp{s_common} に追加します。 コミットが s_common に追加された場合、祖先が have に含まれていても追加しないでください。

S: git-upload-pack 応答を送信:

サーバーがパックするオブジェクトの閉じたセットを見つけた場合、またはリクエストが @samp{done} で終了した場合、サーバーはパックで応答します。 TODO: パックベースの応答を文書化する

@example
S: PACK...
@end example

返されるストリームは、 git-upload-pack サービスでサポートされている side-band-64k プロトコルであり、パックはストリーム 1 に埋め込まれます。サーバー側からの進行状況メッセージは、ストリーム 2 に表示される場合があります。

ここで、「オブジェクトの閉じたセット」(closed set of objects)とは、すべての @samp{want} から少なくとも 1 つの @samp{common} オブジェクトへの少なくとも 1 つのパスを持つように定義されます。

サーバーがさらに情報を必要とする場合、サーバーは status continue 応答で応答します: TODO: パック以外の応答を文書化する

C: Parse the upload-pack response:
TODO: Document parsing response

@samp{次の回の計算ステップを実行します。}

@noindent

@chapheading Smart Service git-receive-pack

このサービスは、 @samp{$GIT_URL} が指すリポジトリから読み込みます。

クライアントは、最初に @samp{$GIT_URL/info/refs?service=git-receive-pack} を使用して ref 検出を実行する必要があります。

@example
C: POST $GIT_URL/git-receive-pack HTTP/1.0
C: Content-Type: application/x-git-receive-pack-request
C:
C: ....0a53e9ddeaddad63ad106860237bbf53411d11a7 441b40d833fdfa93eb2908e52742248faf0ee993 refs/heads/maint\0 report-status
C: 0000
C: PACK....
@end example

@example
S: 200 OK
S: Content-Type: application/x-git-receive-pack-result
S: Cache-Control: no-cache
S:
S: ....
@end example

クライアントは、キャッシュされた応答を再利用(reuse)または再検証(revalidate)してはなりません。 サーバーは、応答のキャッシュを防ぐために十分な Cache-Control ヘッダーを含める必要があります。

サーバーは、ここで定義されたすべての機能をサポートすべきです。

クライアントは、リクエスト本文で少なくとも 1 つのコマンドを送信する必要があります。 リクエストボディのコマンド部分内で、クライアントは、ref 検出を通じて取得した ID を old_id として送信する必要があります。

@example
update_request  =  command_list
                   "PACK" <binary data>
@end example

@example
command_list    =  PKT-LINE(command NUL cap_list LF)
                   *(command_pkt)
command_pkt     =  PKT-LINE(command LF)
cap_list        =  *(SP capability) SP
@end example

@example
command         =  create / delete / update
create          =  zero-id SP new_id SP name
delete          =  old_id SP zero-id SP name
update          =  old_id SP new_id SP name
@end example

TODO: 更に文書化する

@noindent

@chapheading REFERENCES

@itemize 

@item
@uref{http://www.ietf.org/rfc/rfc1738.txt,RFC 1738: Uniform Resource Locators (URL)}

@item
@uref{http://www.ietf.org/rfc/rfc2616.txt,RFC 2616: Hypertext Transfer Protocol — HTTP/1.1}
@end itemize

@noindent

@chapheading SEE ALSO

gitprotocol-pack(5) gitprotocol-capabilities(5)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitprotocol-pack,,,Top
@chapheading Name

gitprotocol-pack — パックが通信(over-the-wire)で転送される方法

@noindent

@chapheading Synopsis

@display
<over-the-wire-protocol>
@end display


@noindent

@chapheading DESCRIPTION

Git は、 @samp{ssh://} や @samp{git://} や @samp{http://} や @samp{file://} 転送を介したパック・ファイルでのデータ転送をサポートしています。 クライアントからサーバーにデータをプッシュするためのプロトコルと、 サーバーからクライアントにデータをフェッチするためのプロトコルの、 2 つのセットがあります。 3 つの転送 (ssh, git, file) は、同じプロトコルを使用してデータを転送します。 http 転送については gitprotocol-http(5) に記載されています。

正規の Git 実装で呼び出されるプロセスは、サーバー側では @samp{upload-pack} 、クライアント側ではデータを取得(fetch)するための @samp{fetch-pack} です。 それから、データをプッシュするためには、サーバー側では @samp{receive-pack} 、クライアント側では @samp{send-pack} です。 プロトコルは、サーバーが現在サーバー上にあるものをクライアントに通知し、それから双方で送信する最小量のデータをネゴシエートして、一方または他方を完全に更新するよう機能します。

@noindent

@chapheading pkt-line Format

以下の説明は、 gitprotocol-common(5) で説明されている pkt-line 形式に基づいています。 文法が @samp{PKT-LINE(...)} を示す場合、 特に明記しない限り、 通常の pkt-line LF ルールが適用されます。

エラーパケットは、エラー文字列を含む特別な pkt-line です。

@example
  error-line     =  PKT-LINE("ERR" SP explanation-text)
@end example


@samp{PKT-LINE(...)} が期待されるそのプロトコル中の何処であっても、エラーパケットが送信される場合があります。 このパケットがクライアントまたはサーバーによって送信されると、そのプロトコルで定義されたデータ転送プロセスは終了します。

@noindent

@chapheading Transports

パックファイルプロトコルが開始される転送(transport)は 3 つあります。 Git 転送は、クライアントが希望するコマンド (ほとんどの場合 @samp{upload-pack} ですが、Git サーバーはグローバルに書き込み可能に構成でき、 @samp{receive-pack} 開始も許可されます) を受け取る単純な非認証サーバーです。 通信して実行し、リクエスト元のプロセスに接続します。

SSH 転送では、クライアントは SSH プロトコルを介してサーバー上で @samp{upload-pack} または @samp{receive-pack} プロセスを実行し、SSH 接続を介して、その呼び出されたプロセスと通信します。

@samp{file://} 転送は、 @samp{upload-pack} または @samp{receive-pack} プロセスをローカルで実行し、パイプを介して通信します。

@noindent

@chapheading Extra Parameters

このプロトコルは、クライアントが最初のメッセージで追加情報をサーバーに送信できるメカニズムを提供します。 これらは「追加パラメーター」(Extra Parameters)と呼ばれ、Git と SSH と HTTP プロトコルでサポートされています。

各追加パラメーター(Extra Parameter)は、 @samp{<key>=<value>} 形式または @samp{<key>} 形式を取ります。

そのような追加パラメータ(Extra Parameters)を受信するサーバーは、 認識されていないすべてのキーを無視する必要があります。 現在認識されている追加パラメータは、値が @samp{1} または @samp{2} である @samp{version} のみです。 プロトコル・バージョン 2 の詳細については、 gitprotocol-v2(5) を参照してください。

@noindent

@chapheading Git Transport

Git 転送(transport)は、 pkt-line 形式を使用してネットワーク上でコマンドとリポジトリを送信することから始まり、その後に NUL バイトとホスト名パラメーターが続き、NUL バイトで終了します。

@example
0033git-upload-pack /project.git\0host=myserver.com\0
@end example

その転送は、NUL バイトを追加し、そして更に 1 つ以上の、 NUL で終了する文字列を追加することによって、追加のパラメーター(Extra Parameters)を送信できます:

@example
003egit-upload-pack /project.git\0host=myserver.com\0\0version=1\0
@end example

@example
git-proto-request = request-command SP pathname NUL
                    [ host-parameter NUL ] [ NUL extra-parameters ]
request-command   = "git-upload-pack" / "git-receive-pack" /
                    "git-upload-archive"   ; case sensitive
pathname          = *( %x01-ff ) ; exclude NUL
host-parameter    = "host=" hostname [ ":" port ]
extra-parameters  = 1*extra-parameter
extra-parameter   = 1*( %x01-ff ) NUL
@end example

host-parameter は、 git-daemon の 名前ベースの仮想ホスティング(name based virtual hosting)に使用されます。 @samp{%H/%CH} 形式の文字を使用した git デーモンの @samp{--interpolated-path} オプションを参照してください。

基本的に、GitクライアントがGitプロトコルを介してサーバー側の @samp{upload-pack} プロセスに接続するために行っていることは以下のとおりです:

@example
$ echo -e -n \
  "003agit-upload-pack /schacon/gitbook.git\0host=example.com\0" |
  nc -v example.com 9418
@end example

@noindent

@chapheading SSH Transport

SSH 経由で upload-pack または receive-pack プロセスを開始することは、SSH リモート実行を介してサーバー上でバイナリを実行することです。 これは基本的に以下を実行するのと同じです:

@example
$ ssh git.example.com "git-upload-pack '/project.git'"
@end example

サーバーが SSH を介して特定のユーザーの Git プッシュおよびプルをサポートするには、そのユーザーが、ログイン時に提供される SSH シェルを介して、これらのコマンドのいずれかまたは両方を実行できる必要があります。 一部のシステムでは、そのシェル アクセスは、これら 2 つのコマンドの実行のみ、またはそれらの 1 つだけに制限されています。

@samp{ssh://} 形式の URI では、これは URI 内で絶対的であるため、ホスト名 (またはポート番号) の後の @samp{/} が引数として送信され、リモートの git-upload-pack によってそのまま読み取られます。 そのため、実質的にはリモートファイルシステムの絶対パスです。

@example
   git clone ssh://user@@example.com/project.git
                |
                v
ssh user@@example.com "git-upload-pack '/project.git'"
@end example

@samp{user@@host:path} 形式の URI では、Git クライアントが実行されるため、ユーザーのホーム ディレクトリに相対的です:

@example
   git clone user@@example.com:project.git
                  |
                  v
ssh user@@example.com "git-upload-pack 'project.git'"
@end example

例外は、 @samp{~} が使用されている場合です。この場合、先頭の @samp{/} なしで実行されます。

@example
   ssh://user@@example.com/~alice/project.git,
                  |
                  v
ssh user@@example.com "git-upload-pack '~alice/project.git'"
@end example

@samp{protocol.version} 構成変数の値に応じて、Git は GIT_PROTOCOL 環境変数のコロン(@samp{:})で区切られた文字列を追加パラメーター(Extra Parameters)として送信しようとする場合があります。 これは、 @samp{ssh.variant} 構成変数で、ssh コマンドが環境変数を引数として渡すことをサポートすることを示している場合にのみ行われます。

ここでいくつか覚えておいて欲しいことがあります:

@itemize 

@item
「コマンド名」はダッシュ(@samp{-})で続けて綴られます (例: git-upload-pack) が、これはクライアントによってオーバーライドできます。

@item
リポジトリパスは常に一重引用符(single quotes)で囲みます。
@end itemize

@noindent

@chapheading Fetching Data From a Server

ある Git リポジトリが 2 つ目のリポジトリにあるデータを取得したい場合、最初の Git リポジトリは 2つめ目のリポジトリから「fetch」(取得)できます。 この操作は、サーバーが持っていてクライアントが持っていないデータを判別し、そのデータを packfile 形式でクライアントにストリーミングします。

@noindent

@chapheading Reference Discovery

クライアントが最初に接続すると、サーバーはすぐに、バージョン番号 ("version=1" が追加パラメーター(Extra Parameter)として送信された場合) と、それが持つ各参照 (すべてのブランチとタグ) のリストと、各参照が現在指しているオブジェクト名で、応答します。

@example
$ echo -e -n "0045git-upload-pack /schacon/gitbook.git\0host=example.com\0\0version=1\0" |
   nc -v example.com 9418
000eversion 1
00887217a7c7e582c46cec22a130adf4b9d7d950fba0 HEAD\0multi_ack thin-pack
             side-band side-band-64k ofs-delta shallow no-progress include-tag
00441d3fcd5ced445d1abc402225c0b8a1299641f497 refs/heads/integration
003f7217a7c7e582c46cec22a130adf4b9d7d950fba0 refs/heads/master
003cb88d2441cac0977faf98efc80305012112238d9d refs/tags/v0.9
003c525128480b96c89e6418b1e40909bf6c5b2d580f refs/tags/v1.0
003fe92df48743b7bc7d26bcaabfddde0a1e20cae47c refs/tags/v1.0^@{@}
0000
@end example

返される応答は、各refとその現在の値を説明する pkt-line ストリームです。 そのストリームは、C ロケールの順序に従って名前でソートする必要があります。

HEAD が有効な ref である場合、HEAD は最初に広告(advertise)された ref として表示されなければなりません。 HEAD が有効な ref でない場合、HEAD は広告(advertise)リストにまったく表示されてはなりませんが、他の ref は表示される可能性があります。

ストリームは、最初のrefの NUL の後ろに機能宣言を含める必要があります。 ref の皮をむいた値(the (peeled value) (つまり、@samp{ref^@{@}}) は、提示される場合、ref 自体の直後になければなりません。 準拠するサーバーは、注釈付きタグの場合、ref を皮むき(peel)しなければなりません。

@example
  advertised-refs  =  *1("version 1")
                      (no-refs / list-of-refs)
                      *shallow
                      flush-pkt

  no-refs          =  PKT-LINE(zero-id SP "capabilities^@{@}"
                      NUL capability-list)

  list-of-refs     =  first-ref *other-ref
  first-ref        =  PKT-LINE(obj-id SP refname
                      NUL capability-list)

  other-ref        =  PKT-LINE(other-tip / other-peeled)
  other-tip        =  obj-id SP refname
  other-peeled     =  obj-id SP refname "^@{@}"

  shallow          =  PKT-LINE("shallow" SP obj-id)

  capability-list  =  capability *(SP capability)
  capability       =  1*(LC_ALPHA / DIGIT / "-" / "_")
  LC_ALPHA         =  %x61-7A
@end example


サーバーとクライアントは obj-id に英小文字を使用する必要があり、サーバーとクライアントどちらも obj-id を英大文字と英小文字を区別しないものとして扱わなければなりません。

許可されているサーバー機能と説明のリストについては、 protocol-capabilities.txt を参照してください。

@noindent

@chapheading Packfile Negotiation

参照と機能の検出後、クライアントは、 パックデータが不要になった時、 flush-pkt を送信して接続を終了することを決定し、サーバーに正常に終了できるようになったことを伝え、切断できます。 これは ls-remote コマンドで発生する可能性があり、そしてまた、クライアントが既に最新の状態である場合にも発生する可能性があります。

それ以外の場合は、ネゴシエーション フェーズに入り、クライアントとサーバーは、必要なオブジェクトや、浅い(shallow)オブジェクト (存在する場合)や、必要なコミットの最大深度 (対応する場合) をサーバーに伝えることによって、転送に必要な最小限のパックファイルを決定します。 クライアントは、サーバーが最初の @samp{want} 行に対して、実行できると言った機能の中から、有効にしたい機能のリストも送信します。

@example
  upload-request    =  want-list
                       *shallow-line
                       *1depth-request
                       [filter-request]
                       flush-pkt

  want-list         =  first-want
                       *additional-want

  shallow-line      =  PKT-LINE("shallow" SP obj-id)

  depth-request     =  PKT-LINE("deepen" SP depth) /
                       PKT-LINE("deepen-since" SP timestamp) /
                       PKT-LINE("deepen-not" SP ref)

  first-want        =  PKT-LINE("want" SP obj-id SP capability-list)
  additional-want   =  PKT-LINE("want" SP obj-id)

  depth             =  1*DIGIT

  filter-request    =  PKT-LINE("filter" SP filter-spec)
@end example


クライアントは、参照検出フェーズから必要なすべての obj-id を @samp{want} 行として送信する必要があります。 クライアントは、リクエスト本文で少なくとも 1 つの @samp{want} コマンドを送信する必要があります。 クライアントは、ref 検出によって取得された応答に表示されなかった obj-id について @samp{want} コマンドで言及してはなりません。

クライアントは、サーバーがクライアントの履歴の制限を認識できるように、浅い(shallow)コピーしか持たない (つまり、コミットの親を持たない) すべての obj-id を @samp{shallow} 行として書き込まなければなりません。

クライアントは、この取引(transaction)に必要な最大のコミット履歴の深さを送信します。 これは、履歴の先端から必要なコミットの数であり、存在する場合は @samp{deepen} 行として送信します。 深度 0 は、深度(depth)リクエストを行わないことと同じです。 クライアントは、この深さを超えるコミットを受け取りたくないし、それらのコミットを完了するためだけに必要なオブジェクトも欲していません。 結果として親が受信されないコミットは、浅い(shallow)ものとして定義され、サーバーでそのようにマークされます。 この情報は、次のステップでクライアントに送り返されます。

クライアントはオプションで、いくつかのフィルタリング手法の 1 つを使用して、 pack-objects が パックファイルからさまざまなオブジェクトを省略するように要求できます。 これらは、部分(partial)クローンおよび部分(partial)フェッチ操作で使用するためのものです。 @samp{want} 行で明示的に要求されない限り、 filter-spec 値を満たさないオブジェクトは省略されます。 可能な filter-spec 値については、 @samp{rev-list} を参照してください。

すべての @samp{want} と @samp{shallow} (およびオプションの @samp{deepen} ) が転送されると、クライアントは、リストの送信が完了したことをサーバー側に通知するために、 flush-pkt を送信する必要があります。

それ以外の場合、クライアントが正の深さ(depth)のリクエストを送信した場合、サーバーはどのコミットが浅い(shallow)かどうかを判断し、その情報をクライアントに送信します。 クライアントが正の深さをリクエストしなかった場合、この手順はスキップされます。

@example
  shallow-update   =  *shallow-line
                      *unshallow-line
                      flush-pkt

  shallow-line     =  PKT-LINE("shallow" SP obj-id)

  unshallow-line   =  PKT-LINE("unshallow" SP obj-id)
@end example


クライアントが正の深さをリクエストした場合、サーバーは目的の深さまでの一連のコミットを計算します。 一連のコミットは、クライアントの要求(wants)から始まります。

サーバーは、結果として親が送信されないコミットごとに @samp{shallow} 行を書き込みます。 サーバーは、クライアントが浅いと示したコミットごとに、現在要求されている深さ(depth)ではもはや浅く(shallow)は無いため、 @samp{unshallow} 行を書き込みます(つまり、その親が送信されます)。 サーバーは、クライアントが浅い(shallow)と示していないものを非浅い(unshallow)としてマークしてはなりません。

これで、クライアントは @samp{have} 行を使用して、所有している obj-id のリストを送信するため、サーバーはクライアントが必要とするオブジェクトのみを含むパックファイルを作成できます。 multi_ack モードでは、正規の実装はこれらを一度に最大 32 個送信して、それから flush-pkt を送信します。 正規の実装では、先にスキップして次の 32 をすぐに送信し、一度に 32 の 「送信中」(in-flight on the wire)のブロックが常に存在するようにします。

@example
  upload-haves      =  have-list
                       compute-end

  have-list         =  *have-line
  have-line         =  PKT-LINE("have" SP obj-id)
  compute-end       =  flush-pkt / PKT-LINE("done")
@end example


サーバーが @samp{have} 行を読み取ると、サーバーも持っているとクライアントが言った obj-id のいずれかに ACK を返すことで応答します。 サーバーは、クライアントが選択した ack モードに応じて、異なる方法で obj-id を ACK します。

multi_ack モードでは:

@itemize 

@item
サーバーは、一般的なコミットに対して @samp{ACK obj-id continue} で応答します。

@item
サーバーが受け入れ可能な共通ベースのコミットを見つけ、パックファイルを作成する準備が整うと、サーバーはすべての @samp{have} obj-id を盲目的にクライアントに返します。

@item
サーバーは @samp{NAK} を送信し、クライアントからの別の応答を待ちます。それは @samp{done} または @samp{have} 行の別のリストのいずれかです。
@end itemize

multi_ack_detailed モードでは:

@itemize 

@item
サーバーは、 @samp{ACK obj-id ready} 行でデータを送信する準備ができていることを通知する ACK を識別し、そして、 @samp{ACK obj-id common} 行で識別された共通コミットを通知します。
@end itemize

multi_ack または multi_ack_detailed を使用しない場合:

@itemize 

@item
upload-pack は、最初に見つけた共通オブジェクトに対して @samp{ACK obj-id} を送信します。 その後、クライアントが @samp{done} するまで何も言いません。

@item
共通オブジェクトがまだ見つからない場合、 upload-pack は flush-pkt で @samp{NAK} を送信します。 1 つ見つかった場合、ACK が既に送信されている場合は、 flush-pkt では何も言いません。
@end itemize

クライアントが十分な ACK 応答を取得して、サーバーが効率的なパックファイルを送信するのに十分な情報を持っていると判断した場合(正規の実装では、 これは @samp{--date-order} キューに残っているすべてをサーバーと共通のものとして色付けできるほど十分な ACK を受信した場合、 または @samp{--date-order} キューが空である場合、に決定されます)、またはクライアントがあきらめたい(wants to give up)と判断した場合(正規の実装では、これは、クライアントが 256 の @samp{have｀行をサーバーからの ACK を取得せずに送信したとき -- これはサーバーとの共通点がなく、サーバーはすべてのオブジェクトを送信する必要があることを意味します-- に決定されます)、クライアントは `done} コマンドを送信します。 @samp{done} コマンドは、クライアントがパックファイルデータを受信する準備ができていることをサーバーに通知します。

ただし、256 の制限は、前のラウンド中に少なくとも 1 つの @samp{ACK %s continue} を受信した場合にのみ、正規のクライアント実装で有効になります。 これにより、完全にあきらめる(give up)前に、共通の祖先を少なくとも 1 つ見つけることができます。

@samp{done} 行がクライアントから読み取られると、サーバーは最後の @samp{ACK obj-id} を送信するか、あるいは @samp{NAK`を送信する場合があります。 `obj-id} は、一般的であると判断された最後のコミットのオブジェクト名です。 サーバーは、少なくとも 1 つの共通ベースがあり、 multi_ack または multi_ack_detailed が有効になっている場合にのみ、 @samp{done} 後に ACK を送信します。 共通のベースが見つからない場合、サーバーは @samp{done} 後に常に NAK を送信します。

@samp{ACK} または @samp{NAK} の代わりに、サーバーはエラーメッセージを送信する場合があります(たとえば、クライアントから受信した @samp{want} 行のオブジェクトを認識できない場合)。

その後、サーバーはパックファイルデータの送信を開始します。

@example
  server-response = *ack_multi ack / nak
  ack_multi       = PKT-LINE("ACK" SP obj-id ack_status)
  ack_status      = "continue" / "common" / "ready"
  ack             = PKT-LINE("ACK" SP obj-id)
  nak             = PKT-LINE("NAK")
@end example


単純なクローンは以下のようになります(@samp{have} 行はありません):

@example
   C: 0054want 74730d410fcb6603ace96f1dc55ea6196122532d multi_ack \
     side-band-64k ofs-delta\n
   C: 0032want 7d1665144a3a975c05f1f43902ddaf084e784dbe\n
   C: 0032want 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a\n
   C: 0032want 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01\n
   C: 0032want 74730d410fcb6603ace96f1dc55ea6196122532d\n
   C: 0000
   C: 0009done\n

   S: 0008NAK\n
   S: [PACKFILE]
@end example


増分更新(fetch)応答は以下のようになります:

@example
   C: 0054want 74730d410fcb6603ace96f1dc55ea6196122532d multi_ack \
     side-band-64k ofs-delta\n
   C: 0032want 7d1665144a3a975c05f1f43902ddaf084e784dbe\n
   C: 0032want 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a\n
   C: 0000
   C: 0032have 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01\n
   C: [30 more have lines]
   C: 0032have 74730d410fcb6603ace96f1dc55ea6196122532d\n
   C: 0000

   S: 003aACK 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01 continue\n
   S: 003aACK 74730d410fcb6603ace96f1dc55ea6196122532d continue\n
   S: 0008NAK\n

   C: 0009done\n

   S: 0031ACK 74730d410fcb6603ace96f1dc55ea6196122532d\n
   S: [PACKFILE]
@end example


@noindent

@chapheading Packfile Data

クライアントとサーバーは、クライアントに送信する必要があるデータの最小量についてのネゴシエーションを終了したので、サーバーは必要なデータを作成してパックファイル形式で送信します。

パック・ファイル自体が実際にどのように見えるかについては、 gitformat-pack(5) を参照してください。

@samp{side-band} または @samp{side-band-64k} 機能がクライアントによって指定されている場合、サーバーはパックファイルデータを多重化して送信します。

各パケットは、後続のデータ量のパケット行長さで始まり、後続のデータが入ってくるサイドバンドを指定する 1 バイトが続きます。

@samp{side-band} モードでは、最大 999 データ バイトと 1 つの制御コード、つまり合計で最大 1000 バイトを pkt-line で送信します。 @samp{side-band-64k} モードでは、最大 65519 データ バイトと 1 つの制御コード、つまり合計で最大 65520 バイトを pkt-line で送信します。

サイドバンドバイトは「1」または「2」または「3」になります。 サイドバンド @samp{1} には packfile データが含まれ、サイドバンド @samp{2} はクライアントが通常 stderr に出力する進捗情報に使用され、サイドバンド @samp{3} はエラー情報に使用されます。

@samp{side-band} 機能が指定されていない場合、サーバーは多重化せずにパックファイル全体をストリーミングします。

@noindent

@chapheading Pushing Data To a Server

データをサーバーにプッシュすると、サーバー上で @samp{receive-pack} プロセスが呼び出されます。これにより、クライアントは更新する必要がある参照をクライアントに通知し、それらの新しい参照を完結させるためにサーバーが必要とするすべてのデータを送信できます。 すべてのデータが受信されて検証(validate)されると、サーバーはその参照をクライアントが指定したものに更新します。

@noindent

@chapheading Authentication

プロトコル自体には、認証メカニズムは含まれていません。 これは、 @samp{receive-pack} プロセスが呼び出される前に、SSH などの転送(transport)によって処理されます。 @samp{receive-pack} がGit転送(transport)上で構成されている場合、その転送(transport)は認証されていないため、そのポート(9418)にアクセスできる人なら誰でもこれらのリポジトリに書き込みできます。

@noindent

@chapheading Reference Discovery

参照検出フェーズは、フェッチプロトコル(the fetching protocol)とほぼ同じ方法で行われます。 サーバー上の各参照 obj-id と名前は、 packet-line 形式でクライアントに送信され、その後に flush-pkt が続きます。 唯一の違いは、機能リストが異なることです。可能な値は、 @samp{report-status}, @samp{report-status-v2}, @samp{delete-refs}, @samp{ofs-delta}, @samp{atomic}, @samp{push-options} のみです。

@noindent

@chapheading Reference Update Request and Packfile Transfer

クライアントがサーバー上にある参照を知ったら、参照更新リクエストのリストを送信できます。 更新するサーバー上の参照ごとに、現在サーバー上にある obj-id と、クライアントが更新したい obj-id と、参照の名前を、リストした行を送信します。

このリストの後には、flush-pkt が続きます。

@example
  update-requests   =  *shallow ( command-list | push-cert )

  shallow           =  PKT-LINE("shallow" SP obj-id)

  command-list      =  PKT-LINE(command NUL capability-list)
                       *PKT-LINE(command)
                       flush-pkt

  command           =  create / delete / update
  create            =  zero-id SP new-id  SP name
  delete            =  old-id  SP zero-id SP name
  update            =  old-id  SP new-id  SP name

  old-id            =  obj-id
  new-id            =  obj-id

  push-cert         = PKT-LINE("push-cert" NUL capability-list LF)
                      PKT-LINE("certificate version 0.1" LF)
                      PKT-LINE("pusher" SP ident LF)
                      PKT-LINE("pushee" SP url LF)
                      PKT-LINE("nonce" SP nonce LF)
                      *PKT-LINE("push-option" SP push-option LF)
                      PKT-LINE(LF)
                      *PKT-LINE(command LF)
                      *PKT-LINE(gpg-signature-lines LF)
                      PKT-LINE("push-cert-end" LF)

  push-option       =  1*( VCHAR | SP )
@end example


サーバーが @samp{push-options} 機能を広告し、クライアントが上記の機能リストの一部として @samp{push-options} を指定した場合、クライアントはプッシュオプションに続いて flush-pkt を送信します。

@example
  push-options      =  *PKT-LINE(push-option) flush-pkt
@end example


古い Git サーバーとの下位互換性のために、クライアントがプッシュ証明書とプッシュオプションを送信する場合、プッシュ証明書内に埋め込まれたプッシュオプションと、プッシュ証明書の後のプッシュオプションの両方を送信する必要があります。 (注意: 証明書内のプッシュオプションにはプレフィックスが付いていますが、証明書の後のプッシュオプションには付いていないことに注意してください。) これらのリストは、プレフィックスを除けば、両方とも同一でなければなりません。

その後、サーバーが新しい参照を完結させるために必要なすべてのオブジェクトを含むパックファイルが送信されます。

@example
  packfile          =  "PACK" 28*(OCTET)
@end example


受信側が delete-refs をサポートしていない場合、送信側は delete コマンドを要求してはなりません。

受信側がプッシュ証明書をサポートしていない場合、送信側はプッシュ証明書コマンドを送信してはいけません。 push-cert コマンドが送信される場合、command-list は送信してはいけません。 代わりに、プッシュ証明書に記録されているコマンド(commands)が使用されます。

使用されるコマンドが @samp{delete} のみの場合、パックファイルを送信してはなりません。

create または update コマンドを使用する場合は、サーバーに必要なすべての
オブジェクトが既にある場合でも、パックファイルを送信する必要があります。
の場合、クライアントは空のパックファイルを送信する必要があります。
クライアントが既存の obj-id を指す新しいブランチまたはタグを
作成している場合に、これが発生する可能性が高いです。

サーバーはパックファイルを受け取り、アンパックし、更新中の各参照がリクエストの処理中に変更されていないこと(obj-id は古い old-id と同一のままでである)を検証(validate)し、更新フックを実行して、更新が受け入れられることを確かめます。 すべて問題なければ、サーバーは参照を更新します。

@noindent

@chapheading Push Certificate

プッシュ証明書は一連のヘッダー行で始まります。 ヘッダーと1行の空行の後に、プロトコル コマンドが 1 行に 1 つずつ続きます。 push-cert PKT-LINE の末尾の LF は「オプションでは無い」ことに注意してください。 しかし push-cert PKT-LINE の末尾の LF は存在していなければなりません。

現在、以下のヘッダーフィールドが定義されています:

@table @asis

@item  @samp{pusher} ID 
@samp{Human Readable Name <email@@address>} 形式で GPG キーを識別します。

@item  @samp{pushee} URL 
@samp{git push} を実行したユーザーがプッシュしようとしていたリポジトリ URL (URL に認証情報が含まれている場合は匿名化)。

@item  @samp{nonce} ノンス 
リプレイ攻撃(replay attacks)を防ぐために、受信リポジトリ側がプッシュするユーザーに証明書に含めるように要求した「ノンス」(nonce)文字列。
@end table

GPG 署名行は、署名ブロックが開始される前にプッシュ証明書に記録された、コンテンツから切り離された署名(detached signature)です。 切り離された署名(detached signature)は、署名者(signer)でなければならないプッシャー(pusher)によってコマンドが与えられたことを証明するために使用されます。

@noindent

@chapheading Report Status

送信側からパックデータを受信した後、 @samp{report-status} または @samp{report-status} 機能が有効な場合、受信側はレポートを送信します。 これは、その更新で何が起こったかの短いリストです。 最初に、パックファイルのアンパックのステータスが @samp{unpack ok} または @samp{unpack [error]} としてリストされます。 次に、更新しようとした各参照のステータスを一覧表示します。 各行は、更新が成功した場合は @samp{ok [refname]} 、更新が失敗した場合は @samp{ng [refname] [error]} の、いずれかです。

@example
  report-status     = unpack-status
                      1*(command-status)
                      flush-pkt

  unpack-status     = PKT-LINE("unpack" SP unpack-result)
  unpack-result     = "ok" / error-msg

  command-status    = command-ok / command-fail
  command-ok        = PKT-LINE("ok" SP refname)
  command-fail      = PKT-LINE("ng" SP refname SP error-msg)

  error-msg         = 1*(OCTET) ; where not "ok"
@end example


@samp{report-status-v2} 機能は、 @samp{proc-receive} フックによって書き換え(rewritten)られた参照のレポートをサポートするために、新しいオプション行を追加してプロトコルを拡張(extend)します。 @samp{proc-receive} フックは、1 つまたは複数の参照を作成または更新する疑似参照(pseudo-reference)のコマンドを処理できます。各参照は、異なる名前と、異なる new-oidと、異なる old-oid を、持つことができます。

@example
  report-status-v2  = unpack-status
                      1*(command-status-v2)
                      flush-pkt

  unpack-status     = PKT-LINE("unpack" SP unpack-result)
  unpack-result     = "ok" / error-msg

  command-status-v2 = command-ok-v2 / command-fail
  command-ok-v2     = command-ok
                      *option-line

  command-ok        = PKT-LINE("ok" SP refname)
  command-fail      = PKT-LINE("ng" SP refname SP error-msg)

  error-msg         = 1*(OCTET) ; where not "ok"

  option-line       = *1(option-refname)
                      *1(option-old-oid)
                      *1(option-new-oid)
                      *1(option-forced-update)

  option-refname    = PKT-LINE("option" SP "refname" SP refname)
  option-old-oid    = PKT-LINE("option" SP "old-oid" SP obj-id)
  option-new-oid    = PKT-LINE("option" SP "new-oid" SP obj-id)
  option-force      = PKT-LINE("option" SP "forced-update")
@end example


更新は、さまざまな理由で失敗する可能性があります。 参照検出フェーズが最初に送信されてから参照が変更された可能性があります。つまり、その間に誰かがプッシュしたことを意味します。 プッシュされる参照は非早送り(non-fast-forward)参照である可能性があり、更新フックまたは構成がそれを許可しないように設定されている可能性があります。 また、一部の参照は更新できまるけど、他の参照は拒否とかできます。

クライアント/サーバー 通信の例は以下のようになります:

@example
   S: 006274730d410fcb6603ace96f1dc55ea6196122532d refs/heads/local\0report-status delete-refs ofs-delta\n
   S: 003e7d1665144a3a975c05f1f43902ddaf084e784dbe refs/heads/debug\n
   S: 003f74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/master\n
   S: 003d74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/team\n
   S: 0000

   C: 00677d1665144a3a975c05f1f43902ddaf084e784dbe 74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/debug\n
   C: 006874730d410fcb6603ace96f1dc55ea6196122532d 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a refs/heads/master\n
   C: 0000
   C: [PACKDATA]

   S: 000eunpack ok\n
   S: 0018ok refs/heads/debug\n
   S: 002ang refs/heads/master non-fast-forward\n
@end example


@noindent

@chapheading GIT

Part of the git(1) suite

@node gitprotocol-v2,,,Top
@chapheading Name

gitprotocol-v2 — Git通信プロトコル・バージョン 2

@noindent

@chapheading Synopsis

@display
<over-the-wire-protocol>
@end display


@noindent

@chapheading DESCRIPTION

このドキュメントは、Gitの通信(wire)プロトコルのバージョン2の仕様を示しています。プロトコルv2は、以下の方法でv1を改善します:

@itemize 

@item
複数のサービス名の代わりに、単一のサービスで複数のコマンドがサポートされます

@item
機能(capability)がプロトコルの独自のセクションに移動され、NULバイトの後ろに隠されたり、pkt行のサイズによって制限されたりすることがないため、簡単に拡張できます。

@item
NULバイトの後ろに隠されている他の情報を分離します(たとえば、機能(capability)としてのエージェント文字列とsymrefsは @samp{ls-refs} を使用して要求できます)

@item
明示的に要求されない限り、 reference advertisement は省略されます

@item
一部のrefを明示的に要求する ls-refs コマンド

@item
http と stateless-rpc を念頭に置いて設計されています。明確なフラッシュセマンティクス(flush semantics)を使用すると、httpリモートヘルパーは単にプロキシとして機能できます
@end itemize

プロトコルv2では、通信はコマンド指向です。サーバーに最初に接続するときに、機能のリストが広告されます。これらの機能の一部は、クライアントが実行を要求できるコマンドになります。コマンドが完了すると、クライアントは接続を再利用して、他のコマンドの実行を要求できます。

@noindent

@chapheading Packet-Line Framing

すべての通信は、v1と同様に、パケットラインフレーミングを使用して行われます。 詳細については、 gitprotocol-pack(5) と gitprotocol-common(5) を参照してください。

プロトコルv2では、これらの特別なパケットの意味は以下のとおりです:

@itemize 

@item
@samp{0000} フラッシュパケット (flush-pkt) - メッセージの終わりを示します

@item
@samp{0001} 区切りパケット (delim-pkt) - メッセージのセクションを区切ります

@item
@samp{0002} 応答終了パケット (response-end-pkt) - ステートレス接続の応答の終了を示します
@end itemize

@noindent

@chapheading Initial Client Request

一般に、クライアントは、使用されているトランスポートのそれぞれのサイドチャネルを介して @samp{version=2} を送信することにより、プロトコルv2を話すように要求できます。これにより、必然的に @samp{GIT_PROTOCOL} が定されます。詳細については gitprotocol-pack(5) や gitprotocol-http(5) と、 @samp{git.txt} の @samp{GIT_PROTOCOL} 定義を参照してください。すべての場合において、サーバーからの応答は機能広告(capability advertisement)です。

@noindent

@heading Git Transport

git:// 輸送を使用する場合、追加のパラメーターとして "version=2" を送信することにより、プロトコルv2の使用を要求できます:

@example
003egit-upload-pack /project.git\0host=myserver.com\0\0version=2\0
@end example

@noindent

@heading SSH and File Transport

ssh:// 輸送 または file:// 輸送 のどちらかを使用する場合、GIT_PROTOCOL環境変数を明示的に設定して「version=2」を含める必要があります。この環境変数が渡されるようにサーバーを構成する必要がある場合があります。

@noindent

@heading HTTP Transport

http:// 転送または https:// 転送を使用する場合、 クライアントは gitprotocol-http(5) で説明されているように「smart」な info/refs リクエストを作成し、 @samp{Git-Protocol} ヘッダー内で「version=2」を指定してv2を使用するように要求します。

@example
C: GET $GIT_URL/info/refs?service=git-upload-pack HTTP/1.0
C: Git-Protocol: version=2
@end example

v2サーバーは以下のように応答します:

@example
S: 200 OK
S: <Some headers>
S: ...
S:
S: 000eversion 2\n
S: <capability-advertisement>
@end example

その後の要求は、サービス @samp{$GIT_URL/git-upload-pack} に対して直接行われます。(これはgit-receive-packでも同じように機能します)。

@samp{--http-backend-info-refs} オプションを使用して git-upload-pack(1) を実行します。

サーバーは、 @samp{GIT_PROTOCOL} 変数を介してこのヘッダーの内容を渡すように構成する必要がある場合があります。 @samp{git-http-backend.txt} の説明を参照してください。

@noindent

@chapheading Capability Advertisement

(クライアントからの要求に基づいて)プロトコルバージョン2を使用して通信することを決定したサーバーは、初期応答でバージョン文字列を送信し、続いてその機能を広告することによってクライアントに通知します。各機能は、オプションの値を持つキーです。クライアントは、不明なキーをすべて無視する必要があります。未知の値の意味は、各キーの定義に任されています。一部の機能では、クライアントによる実行を要求できるコマンドについて説明します。

@example
capability-advertisement = protocol-version
                           capability-list
                           flush-pkt
@end example

@example
protocol-version = PKT-LINE("version 2" LF)
capability-list = *capability
capability = PKT-LINE(key[=value] LF)
@end example

@example
key = 1*(ALPHA | DIGIT | "-_")
value = 1*(ALPHA | DIGIT | " -_.,?\/@{@}[]()<>!@@#$%^&*+=:;")
@end example

@noindent

@chapheading Command Request

機能広告を受信した後、クライアントは、特定の機能または引数を使用して、必要なコマンドを選択する要求を発行できます。その次に、クライアントがコマンド固有のパラメータまたはクエリを提供できるオプションのセクションがあります。 一度に要求できるコマンドは1つだけです。

@example
request = empty-request | command-request
empty-request = flush-pkt
command-request = command
                  capability-list
                  delim-pkt
                  command-args
                  flush-pkt
command = PKT-LINE("command=" key LF)
command-args = *command-specific-arg
@end example

@example
command-specific-argsは、個々のコマンドによって定義される
パケットラインフレームの引数です。
@end example

次に、サーバーは、クライアントの要求が、広告された有効な機能だけでなく、有効なコマンドで構成されていることを確認します。リクエストが有効な場合、サーバーはコマンドを実行します。 サーバーは、応答を発行する前に、クライアントの要求全体を受信するまで待機する必要があります。応答の形式は実行中のコマンドによって決まりますが、すべての場合で、flush-pktは応答の終了を示します。

コマンドが終了し、クライアントがサーバーからの応答全体を受信すると、クライアントは別のコマンドの実行を要求するか、接続を終了することができます。 クライアントは、オプションで、flush-pktのみで構成される空の要求を送信して、これ以上要求が行われないことを示すことができます。

@noindent

@chapheading Capabilities

機能には異なる2つのタイプがあります。情報を伝達したり要求の動作を変更したりするために使用できる通常の機能と、クライアントが実行したいコアアクション（フェッチ、プッシュなど）であるコマンドです。

プロトコルバージョン2は、デフォルトではステートレスです。 つまり、クライアントがサーバーで状態を維持する必要があることを指示する機能を要求しない限り、すべてのコマンドは1ラウンドだけ持続し、サーバー側の観点からステートレスである必要があります。クライアントは、正しく機能するためにサーバー側に状態管理を要求してはいけません(MUST NOT)。これにより、サーバー側では状態管理について心配することなく、単純なラウンドロビン負荷分散が可能になります。

@noindent

@heading agent

サーバーは、値 @samp{X} (@samp{agent=X} 形式)を使用して @samp{agent} 機能を広告ズし、サーバーがバージョン @samp{X} を実行していることをクライアントに通知できます。クライアントは、サーバーへの要求に値 @samp{Y} (@samp{agent=Y} 形式)を持つ @samp{agent} 機能を含めることにより、オプションで独自のエージェント文字列を送信できます(ただし、サーバーがagent機能を広告しなかった場合は、クライアントから送信してはいけません(MUST NOT))。@samp{X} および @samp{Y} 文字列には、スペースを除く任意の印刷可能なASCII文字(つまり、バイト範囲32 < x <127)を含めることができ、通常は「パッケージ/バージョン」(例: 「git/1.8.3.1」形式です)。エージェント文字列は、統計およびデバッグの目的で純粋に情報を提供するものであり、特定の機能の有無をプログラムで想定するために使用してはいけません(MUST NOT)。

@noindent

@heading ls-refs

@samp{ls-refs} は、v2で参照広告を要求するために使用されるコマンドです。現在の参照広告とは異なり、ls-refsは、サーバーから送信される参照を制限するために使用できる引数を取ります。

基本コマンドでサポートされていない追加の機能は、機能広告のコマンドの値として、スペースで区切られた機能のリストの形式で広告されます: "<command>=<feature 1> <feature 2>"

ls-refsは以下の引数を取ります:

@table @asis

@item  symrefs 
それが指すオブジェクトに加えて、シンボリックrefを表示するときに、それが指す基になるrefを表示します。

@item  peel 
剥いたタグ(peeled tags)を表示します。

@item  ref-prefix <prefix> 
指定すると、 指定された接頭辞のいずれかに一致する接頭辞を持つ参照のみが表示されます。 複数のインスタンスを指定できます。 その場合、プレフィックスに一致する参照が表示されます。 注意: これは純粋に最適化のためであることに注意してください。 サーバーは、 選択した場合、 プレフィックスに一致しない参照を表示する場合があり、 クライアントは結果を自分でフィルターする必要があります。
@end table

「unborn」機能が広告される場合、以下の引数をクライアントの要求に含めることができます。

@table @asis

@item  unborn 
サーバーは、 @samp{unborn HEAD symref-target:<target>} の形式で、unbornブランチを指すsymrefであっても、HEADに関する情報を送信します。
@end table

ls-refsの出力は以下のとおりです:

@example
output = *ref
         flush-pkt
obj-id-or-unborn = (obj-id | "unborn")
ref = PKT-LINE(obj-id-or-unborn SP refname *(SP ref-attribute) LF)
ref-attribute = (symref | peeled)
symref = "symref-target:" symref-target
peeled = "peeled:" obj-id
@end example

@noindent

@heading fetch

@samp{fetch} は、v2でパックファイルをフェッチするために使用されるコマンドです。 これは、v1 fetch の修正バージョンと見なすことができ、(@samp{ls-refs} コマンドがその役割を果たしているため、)ref-advertisementが削除され、メッセージ形式が調整されて冗長性が排除され、将来の拡張機能を簡単に追加できるようになっています。

基本コマンドでサポートされていない追加の機能は、機能広告のコマンドの値として、スペースで区切られた機能のリストの形式で広告されます: "<command>=<feature 1> <feature 2>"

@samp{fetch} リクエストは、以下の引数を取ることができます:

@table @asis

@item  want <oid> 
クライアントが取得したいオブジェクトをサーバーに提示します。欲しいものは何でもかまいません。広告されているオブジェクトに限定されません。

@item  have <oid> 
クライアントがローカルに持っているオブジェクトをサーバーに提示します。 これにより、サーバーは、クライアントが必要とするオブジェクトのみを含むパックファイルを作成できます。 複数の「have」行を指定できます。

@item  done 
ネゴシエーションを終了する必要があること(またはクローンを実行する場合は開始しないこと)、およびサーバーが要求で提供された情報を使用してパックファイルを作成する必要があることをサーバーに提示します。

@item  thin-pack 
シンパック(thin pack)の送信を要求します。これは、パック内に含まれていない（ただし、受信側に存在することがわかっている）ベースオブジェクトを参照するデルタを含むパックです。これにより、ネットワークトラフィックを大幅に削減できますが、受信側は、シンパックに不足しているベースを追加して、これらのパックを「厚く」(thicken)する方法を知っている必要があります。

@item  no-progress 
パックファイル転送中にサイドバンドチャネル2で通常送信される進行状況情報を送信しないように要求します。 ただし、サイドバンドチャネル3は引き続きエラー応答に使用されます。

@item  include-tag 
注釈付きタグ(annotated tags)が指すオブジェクトが送信されている場合は、注釈付きタグ(annotated tags)を送信するように要求します。

@item  ofs-delta 
クライアントが PACKv2を理解していることを提示します。デルタは、OIDではなくパック内の位置によってベースを参照しています。 つまり、パックファイル内の OBJ_OFS_DELTA (別名タイプ 6)を読み取ることができます。
@end table

「shallow」機能が広告される場合、以下で説明するように、以下の引数をクライアント要求に含めることができ、サーバーの応答に「shallow-info」セクションを追加する可能性があります。

@table @asis

@item  shallow <oid> 
クライアントは、サーバーがクライアントの履歴の制限を認識できるように、そのようなオブジェクトごとに「shallow <oid>」行を指定することにより、shallowコピーしかない(つまり、そのコミットの親がないことを意味する、)すべてのコミットをサーバーに通知する必要があります。 これは、クライアントがそのようなコミットから到達可能なすべてのオブジェクトを持っていない可能性があることをサーバーが認識できるようにするためです。

@item  deepen <depth> 
フェッチ/クローンを浅くし(shallow)、リモート側に対してコミットの深さが<depth>であることを要求します。

@item  deepen-relative 
「deepen」コマンドのセマンティクスを変更して、要求された深さが、要求されたコミットではなく、クライアントの現在のshallow境界に関連していることを示すように要求します。

@item  deepen-since <timestamp> 
shallow クローン/フェッチ を深さではなく特定の日付時刻でカットするように要求します。 内部的には、「git rev-list --max-age=<timestamp>」を実行するのと同じです。 「deepen」との併用はできません。

@item  deepen-not <rev> 
shallow クローン/フェッチを、深さではなく、 <rev> で指定された特定のリビジョンでカットするように要求します。 内部的には、「git rev-list --not <rev>」を実行するのと同じです。 「deepen」では使用できませんが、「deepen-since」では使用できます。
@end table

@samp{filter} 機能が広告される場合、以下の引数をクライアントの要求に含めることができます:

@table @asis

@item  filter <filter-spec> 
いくつかのフィルタリング手法のいずれかを使用して、パックファイルのさまざまなオブジェクトを省略するように要求します。これらは、部分クローン(partial clone)および部分フェッチ(partial fetch)操作での使用を目的としています。 可能な「filter-spec」値については、@samp{rev-list} を参照してください。他のプロセスと通信する場合、送信者はスケーリングされた整数(「1k」など)を完全に拡張された形式(「1024」など)に変換して、新発想のスケーリングサフィックスを理解できない古い受信者との相互運用性を支援する必要があります。しかしながら、受信者は次のサフィックスを受け入れる必要があります：「k」、「m」、「g」で、それぞれ、1024、1048576、1073741824 を現します。
@end table

「ref-in-want」機能が広告される場合、以下で説明するように、以下の引数をクライアントの要求に含めることができ、サーバーの応答に「wanted-refs」セクションを追加する可能性があります。

@table @asis

@item  want-ref <ref> 
クライアントが特定のrefを取得することをサーバーに提示します。ここで、 <ref> はサーバー上のrefのフルネームです。
@end table

@samp{sideband-all} 機能が広告される場合、以下の引数をクライアントの要求に含めることができます:

@table @asis

@item  sideband-all 
packfileセクションだけでなく、応答全体を多重化して送信するようにサーバーに指示します。(packfileセクションだけでなく、)応答内のすべての非フラッシュ(non-flush)および non-delim PKT-LINEは、そのサイドバンド(1または2または3)を示すバイトで始まります。サーバーは、キープアライブパケットとして「0005\2」（ペイロードのないサイドバンド2のPKT-LINE)を送信する場合があります。
@end table

「packfile-uris」機能が広告される場合、以下で説明するように、以下の引数をクライアントの要求に含めることができ、サーバーの応答に「packfile-uris」セクションを追加する可能性があります。

@table @asis

@item  packfile-uris <comma-separated list of protocols> 
クライアントが、送信されたパックファイル内のオブジェクトの代わりに、指定されたプロトコルのいずれかのURIを受信する用意があることをサーバーに提示します。 接続チェックを実行する前に、クライアントは指定されたすべてのURIからダウンロードする必要があります。 現在、サポートされているプロトコルは「http」と「https」です。
@end table

@samp{wait-for-done} 機能が広告される場合、以下の引数をクライアントの要求に含めることができます。

@table @asis

@item  wait-for-done 
サーバは決して "ready" を送らず、クライアントが "done" と言うまで待ってからパックファイルを送信するように指示します。
@end table

@samp{fetch} の応答は、区切り文字パケット(0001)で区切られたいくつかのセクションに分割され、各セクションはセクションヘッダーで始まります。ほとんどのセクションは、パックファイルが送信されたときにのみ送信されます。

@example
output = acknowledgements flush-pkt |
         [acknowledgments delim-pkt] [shallow-info delim-pkt]
         [wanted-refs delim-pkt] [packfile-uris delim-pkt]
         packfile flush-pkt
@end example

@example
acknowledgments = PKT-LINE("acknowledgments" LF)
                  (nak | *ack)
                  (ready)
ready = PKT-LINE("ready" LF)
nak = PKT-LINE("NAK" LF)
ack = PKT-LINE("ACK" SP obj-id LF)
@end example

@example
shallow-info = PKT-LINE("shallow-info" LF)
               *PKT-LINE((shallow | unshallow) LF)
shallow = "shallow" SP obj-id
unshallow = "unshallow" SP obj-id
@end example

@example
wanted-refs = PKT-LINE("wanted-refs" LF)
              *PKT-LINE(wanted-ref LF)
wanted-ref = obj-id SP refname
@end example

@example
packfile-uris = PKT-LINE("packfile-uris" LF) *packfile-uri
packfile-uri = PKT-LINE(40*(HEXDIGIT) SP *%x20-ff LF)
@end example

@example
packfile = PKT-LINE("packfile" LF)
           *PKT-LINE(%x01-03 *%x00-ff)
@end example

@table @asis

@item  acknowledgments section 
@itemize 

@item
クライアントが「done」行を送信してネゴシエーションが終了したと判断した場合(したがって、サーバーにパックファイルを送信する必要があります)、サーバーの応答からacknowledgmentsセクションを省略しなければなりません(MUST)。

@item
常にセクションヘッダー「acknowledgements」で始まります

@item
have行として送信されたオブジェクトIDがどれも共通していない場合、サーバーは「NAK」で応答します。

@item
サーバーは、共通のhave行として送信されたすべてのオブジェクトIDに対して「ACK obj-id」で応答します。

@item
応答に「ACK」行と「NAK」行の両方を含めることはできません。

@item
サーバーは、サーバーが許容可能な共通ベースを検出し、packfile（同じ応答のpackfileセクションにあります）を作成して、送信する準備ができていることを示す「ready」行で応答します。

@item
サーバーが適切な切断点(cut point)を見つけて「ready」行を送信することを決定した場合、サーバーは(最適化として)応答中に送信した「ACK」行を省略することを決定できます。これは、サーバーがクライアントに送信する予定のオブジェクトをすでに決定しており、それ以上のネゴシエーションが必要ないためです。
@end itemize

@item  shallow-info section 
@itemize 

@item
クライアントが shallow フェッチ/クローン を要求した場合、shallowクライアントがフェッチを要求するか、サーバーがshallowの場合、サーバーの応答に shallow-info セクションが含まれる場合があります。(上記の条件のいずれかにより、サーバーがクライアントにshallow 境界(shallow boundaries)を通知する必要がある場合、または既存の浅い境界をクライアントと調整する必要がある場合は、 shallow-info セクションが含まれます。

@item
常にセクションヘッダー「shallow-info」で始まります

@item
正数の深さが要求された場合、サーバーは指定の深さよりも深くないコミットのセットを計算します。

@item
サーバーは、続くパックファイルで親が送信されないコミットごとに「shallow obj-id」行を送信します。

@item
サーバーは、クライアントがshallowを指示したコミットごとに「unshallow obj-id」行を送信しますが、(その親が次のパックファイルで送信されるため、)フェッチの結果としてはshallowにはなりません。

@item
サーバーは、クライアントが要求の一部としてshallowを指示していないものに対して、「unshallow」行を送信しては「いけません」。
@end itemize

@item  wanted-refs section 
@itemize 

@item
このセクションは、クライアントが「want-ref」行を使用してrefを要求し、packfileセクションも応答に含まれている場合にのみ含まれます。

@item
常にセクションヘッダー「wanted-refs」で始まります。

@item
サーバーは、「want-ref」行を使用して要求された参照ごとに、参照リスト("<oid> <refname>")を送信します。

@item
サーバーは、「want-ref」行を使用して要求されなかった参照を送信しては「いけません」。
@end itemize

@item  packfile-uris section 
@itemize 

@item
このセクションは、クライアントが「packfile-uris」を送信し、サーバーに送信するそのようなURIが少なくとも1つある場合にのみ含まれます。

@item
常にセクションヘッダー「packfile-uris」で始まります。

@item
サーバーが送信するURIごとに、パックの内容のハッシュ(git index-packによって出力される)と、それに続くURIを送信します。

@item
ハッシュの長さは40文字です。 Gitが新しいハッシュアルゴリズムにアップグレードするとき、これを更新する必要があるかもしれません。 (「pack\t」または「keep\t」の後に出力されるインデックスパックと一致する必要があります)。
@end itemize

@item  packfile section 
@itemize 

@item
このセクションは、クライアントがリクエストで「want」行を送信し、「done」を送信してこれ以上ネゴシエーションを行わないように要求した場合、または、サーバーがパックファイルを生成するのに十分なカットポイントを見つけたと判断した場合、のいずれかにのみ含まれます。

@item
常にセクションヘッダー「packfile」で始まります

@item
パックファイルの送信は、セクションヘッダーの直後に開始されます

@item
パックファイルのデータ転送は、プロトコルバージョン1の「side-band-64k」機能と同じセマンティクスを使用して、常に多重化されます。つまり、packfileデータストリーム中の各パケットは、先頭の4バイトの pkt-line長(通常はpkt-line形式)、1バイトのストリームコード、実際のデータで構成されます。
@end itemize
@end table

The stream code can be one of:
1 - pack data
2 - progress messages
3 - fatal error message just before stream aborts

@noindent

@heading server-option

広告されている場合は、サーバー固有のオプションをいくつでもリクエストに含めることができることを示します。これは、リクエストの機能リストセクションで「server-option=<option>」機能行として各オプションを送信することによって行われます。

提供されるオプションには、NULまたはLF文字を含めることはできません。

@noindent

@heading object-format

サーバーは、値 @samp{X} (@samp{object-format=X} 形式)を使用して @samp{object-format} 機能を広告し、サーバーがハッシュアルゴリズムXを使用してオブジェクトを処理できることをクライアントに通知できます。 指定しない場合、サーバーはSHA-1のみを処理すると見なされます。 クライアントがSHA-1以外のハッシュアルゴリズムを使用する場合は、object-formatの文字列を指定する必要があります。

@noindent

@heading session-id=<session id>

サーバーは、複数のリクエストにわたってこのプロセスを識別するために使用できるセッションIDを広告する場合があります。 クライアントは、自身のセッションIDをサーバーに広告することもできます。

セッションIDは、特定のプロセスに固有である必要があります。それらはパケット行内に収まる必要があり、印刷不可能な文字や空白文字を含めることはできません。 現在の実装ではtrace2セッションID(詳細は @uref{technical/api-trace2.html,api-trace2} 参照)を使用していますが、これは変更される可能性があるため、セッションIDのユーザーはこの事実に依存しないでください。

@noindent

@heading object-info

@samp{object-info} は、1つまたは複数のオブジェクトに関する情報を取得するためのコマンドです。 その主な目的は、クライアントがオブジェクトを完全にフェッチすることなく、この情報に基づいて決定を下せるようにすることです。 現在サポートされている情報はオブジェクトサイズのみです。

@samp{object-info} リクエストは以下の引数を取ります:

@table @asis

@item  size 
リストされたオブジェクトIDごとに返されるサイズ情報を要求します。

@item  oid <oid> 
クライアントが情報を取得したいオブジェクトをサーバーに指示します。
@end table

@samp{object-info} の応答は、要求されたオブジェクトIDと関連する要求された情報のリストであり、それぞれが1つのスペースで区切られています。

@example
output = info flush-pkt
@end example

@example
info = PKT-LINE(attrs) LF)
        *PKT-LINE(obj-info LF)
@end example

@example
attrs = attr | attrs SP attrs
@end example

@example
attr = "size"
@end example

@example
obj-info = obj-id SP obj-size
@end example

@noindent

@heading bundle-uri

If the @emph{bundle-uri} capability is advertised, the server supports the ‘bundle-uri’ command.

The capability is currently advertised with no value (i.e. not "bundle-uri=somevalue"), a value may be added in the future for supporting command-wide extensions. Clients MUST ignore any unknown capability values and proceed with the 'bundle-uri` dialog they support.

The @emph{bundle-uri} command is intended to be issued before @samp{fetch} to get URIs to bundle files (see git-bundle(1)) to "seed" and inform the subsequent @samp{fetch} command.

The client CAN issue @samp{bundle-uri} before or after any other valid command. To be useful to clients it’s expected that it’ll be issued after an @samp{ls-refs} and before @samp{fetch}, but CAN be issued at any time in the dialog.

@noindent

@subheading DISCUSSION of bundle-uri

The intent of the feature is optimize for server resource consumption in the common case by changing the common case of fetching a very large PACK during git-clone(1) into a smaller incremental fetch.

It also allows servers to achieve better caching in combination with an @samp{uploadpack.packObjectsHook} (see git-config(1)).

By having new clones or fetches be a more predictable and common negotiation against the tips of recently produces *.bundle file(s). Servers might even pre-generate the results of such negotiations for the @samp{uploadpack.packObjectsHook} as new pushes come in.

One way that servers could take advantage of these bundles is that the server would anticipate that fresh clones will download a known bundle, followed by catching up to the current state of the repository using ref tips found in that bundle (or bundles).

@noindent

@subheading PROTOCOL for bundle-uri

A @samp{bundle-uri} request takes no arguments, and as noted above does not currently advertise a capability value. Both may be added in the future.

When the client issues a @samp{command=bundle-uri} request, the response is a list of key-value pairs provided as packet lines with value @samp{<key>=<value>}. Each @samp{<key>} should be interpreted as a config key from the @samp{bundle.*} namespace to construct a list of bundles. These keys are grouped by a @samp{bundle.<id>.} subsection, where each key corresponding to a given @samp{<id>} contributes attributes to the bundle defined by that @samp{<id>}. See git-config(1) for the specific details of these keys and how the Git client will interpret their values.

Clients MUST parse the line according to the above format, lines that do not conform to the format SHOULD be discarded. The user MAY be warned in such a case.

@noindent

@subheading bundle-uri CLIENT AND SERVER EXPECTATIONS

@table @asis

@item  URI CONTENTS 
The content at the advertised URIs MUST be one of two types.

The advertised URI may contain a bundle file that @samp{git bundle verify} would accept. I.e. they MUST contain one or more reference tips for use by the client, MUST indicate prerequisites (in any) with standard "-" prefixes, and MUST indicate their "object-format", if applicable.

The advertised URI may alternatively contain a plaintext file that @samp{git config --list} would accept (with the @samp{--file} option). The key-value pairs in this list are in the @samp{bundle.*} namespace (see git-config(1)).

@item  bundle-uri CLIENT ERROR RECOVERY 
A client MUST above all gracefully degrade on errors, whether that error is because of bad missing/data in the bundle URI(s), because that client is too dumb to e.g. understand and fully parse out bundle headers and their prerequisite relationships, or something else.

Server operators should feel confident in turning on "bundle-uri" and not worry if e.g. their CDN goes down that clones or fetches will run into hard failures. Even if the server bundle(s) are incomplete, or bad in some way the client should still end up with a functioning repository, just as if it had chosen not to use this protocol extension.

All subsequent discussion on client and server interaction MUST keep this in mind.

@item  bundle-uri SERVER TO CLIENT 
The ordering of the returned bundle uris is not significant. Clients MUST parse their headers to discover their contained OIDS and prerequisites. A client MUST consider the content of the bundle(s) themselves and their header as the ultimate source of truth.

A server MAY even return bundle(s) that don’t have any direct relationship to the repository being cloned (either through accident, or intentional "clever" configuration), and expect a client to sort out what data they’d like from the bundle(s), if any.

@item  bundle-uri CLIENT TO SERVER 
The client SHOULD provide reference tips found in the bundle header(s) as @emph{have} lines in any subsequent @samp{fetch} request. A client MAY also ignore the bundle(s) entirely if doing so is deemed worse for some reason, e.g. if the bundles can’t be downloaded, it doesn’t like the tips it finds etc.

@item  WHEN ADVERTISED BUNDLE(S) REQUIRE NO FURTHER NEGOTIATION 
If after issuing @samp{bundle-uri} and @samp{ls-refs}, and getting the header(s) of the bundle(s) the client finds that the ref tips it wants can be retrieved entirely from advertised bundle(s), the client MAY disconnect from the Git server. The results of such a @emph{clone} or @emph{fetch} should be indistinguishable from the state attained without using bundle-uri.

@item  EARLY CLIENT DISCONNECTIONS AND ERROR RECOVERY 
A client MAY perform an early disconnect while still downloading the bundle(s) (having streamed and parsed their headers). In such a case the client MUST gracefully recover from any errors related to finishing the download and validation of the bundle(s).

I.e. a client might need to re-connect and issue a @emph{fetch} command, and possibly fall back to not making use of @emph{bundle-uri} at all.

This "MAY" behavior is specified as such (and not a "SHOULD") on the assumption that a server advertising bundle uris is more likely than not to be serving up a relatively large repository, and to be pointing to URIs that have a good chance of being in working order. A client MAY e.g. look at the payload size of the bundles as a heuristic to see if an early disconnect is worth it, should falling back on a full "fetch" dialog be necessary.

@item  WHEN ADVERTISED BUNDLE(S) REQUIRE FURTHER NEGOTIATION 
A client SHOULD commence a negotiation of a PACK from the server via the "fetch" command using the OID tips found in advertised bundles, even if’s still in the process of downloading those bundle(s).

This allows for aggressive early disconnects from any interactive server dialog. The client blindly trusts that the advertised OID tips are relevant, and issues them as @emph{have} lines, it then requests any tips it would like (usually from the "ls-refs" advertisement) via @emph{want} lines. The server will then compute a (hopefully small) PACK with the expected difference between the tips from the bundle(s) and the data requested.

The only connection the client then needs to keep active is to the concurrently downloading static bundle(s), when those and the incremental PACK are retrieved they should be inflated and validated. Any errors at this point should be gracefully recovered from, see above.
@end table

@noindent

@subheading bundle-uri PROTOCOL FEATURES

The client constructs a bundle list from the @samp{<key>=<value>} pairs provided by the server. These pairs are part of the @samp{bundle.*} namespace as documented in git-config(1). In this section, we discuss some of these keys and describe the actions the client will do in response to this information.

In particular, the @samp{bundle.version} key specifies an integer value. The only accepted value at the moment is @samp{1}, but if the client sees an unexpected value here then the client MUST ignore the bundle list.

As long as @samp{bundle.version} is understood, all other unknown keys MAY be ignored by the client. The server will guarantee compatibility with older clients, though newer clients may be better able to use the extra keys to minimize downloads.

Any backwards-incompatible addition of pre-URI key-value will be guarded by a new @samp{bundle.version} value or values in @emph{bundle-uri} capability advertisement itself, and/or by new future @samp{bundle-uri} request arguments.

Some example key-value pairs that are not currently implemented but could be implemented in the future include:

@itemize 

@item
Add a "hash=<val>" or "size=<bytes>" advertise the expected hash or size of the bundle file.

@item
Advertise that one or more bundle files are the same (to e.g. have clients round-robin or otherwise choose one of N possible files).

@item
A "oid=<OID>" shortcut and "prerequisite=<OID>" shortcut. For expressing the common case of a bundle with one tip and no prerequisites, or one tip and one prerequisite.

This would allow for optimizing the common case of servers who’d like to provide one "big bundle" containing only their "main" branch, and/or incremental updates thereof.

A client receiving such a a response MAY assume that they can skip retrieving the header from a bundle at the indicated URI, and thus save themselves and the server(s) the request(s) needed to inspect the headers of that bundle or bundles.
@end itemize

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitremote-helpers,,,Top
@chapheading Name

gitremote-helpers — リモートリポジトリと対話するためのヘルパープログラム群

@noindent

@chapheading Synopsis

@display
git remote-<transport> <repository> [<URL>]
@end display


@noindent

@chapheading DESCRIPTION

リモートヘルパープログラムは通常、エンドユーザーが直接使用することはありませんが、Gitがネイティブでサポートしていないリモートリポジトリと対話する必要がある場合にGitによって呼び出されます。 特定のヘルパーは、ここに記載されている機能のサブセットを実装します。 Gitがリモートヘルパーを使用してリポジトリと対話する必要がある場合、Gitは独立したプロセスとしてヘルパーを生成し、ヘルパーの標準入力にコマンドを送信し、ヘルパーの標準出力からの結果を期待します。 リモートヘルパーはGitから独立したプロセスとして実行されるため、新しいヘルパーを追加するためにGitを再リンクする必要も、ヘルパーをGitの実装にリンクする必要もありません。

すべてのヘルパーは @samp{capabilities} (機能)コマンドをサポートする必要があります。これは、ヘルパーが受け入れる他のコマンドをGitが決定するために使用します。これらの他のコマンドを使用して、リモート参照の検出と更新や、オブジェクトデータベースとリモートリポジトリ間のオブジェクトの転送や、ローカルオブジェクトストアの更新を行うことができます。

Gitには、 @samp{git-remote-http} や、 @samp{git-remote-https} や、 @samp{git-remote-ftp} や、 @samp{git-remote-ftps} などのさまざまな転送(transport)プロトコルを処理する "curl" ファミリーのリモートヘルパーが付属しています。これらは、機能(capabilities)として、 @samp{fetch} と @samp{option} と @samp{push} を実装します。

@noindent

@chapheading INVOCATION

リモートヘルパープログラムは、1つまたは(オプションで)2つの引数を使用して呼び出されます。最初の引数は、Gitのようにリモートリポジトリを指定します。それは設定されたリモートの名前またはURLのいずれかです。2番目の引数はURLを指定します。 通常は @samp{<transport>://<address>} の形式ですが、任意の文字列を使用できます。 @samp{GIT_DIR} 環境変数はリモートヘルパー用に設定されており、追加データを保存する場所や、補助Gitコマンドを呼び出すディレクトリを決定するために使用できます。

Gitが @samp{<transport>://<address>} の形式のURLを検出すると、ここで、 @samp{<transport>} はネイティブに処理できないプロトコルで、2番目の引数として完全なURLを使用して @samp{git remote-<transport>} を自動的に呼び出します。そのようなURLがコマンドラインで直接検出された場合は最初の引数は2番目の引数と同じであり、構成されたリモートで検出された場合最初の引数はそのリモートの名前です。

@samp{<transport>::<address>} の形式のURLは、2番目の引数として @samp{<address>} を使用して @samp{git remote-<transport>} を呼び出すようにGitに明示的に指示します。このようなURLがコマンドラインで直接検出された場合最初の引数は @samp{<address>} であり、構成されたリモートで検出された場合最初の引数はそのリモートの名前です。

さらに、構成されたリモートで @samp{remote.<name>.vcs} が @samp{<transport>} に設定されている場合、Gitは最初の引数として @samp{<name>} を使用して @samp{git remote-<transport>} を明示的に呼び出します。 @samp{remote.<name>.url} が設定されている場合は、2番目の引数は @samp{remote.<name>.url} です。 @samp{remote.<name>.url} が設定されてない場合、2番目の引数は省略されます。

@noindent

@chapheading INPUT FORMAT

Gitは、リモートヘルパーの標準入力にコマンドのリストを1行に1つずつ送信します。 最初のコマンドは常に @samp{capabilities} (機能)コマンドであり、これに応答して、リモートヘルパーはサポートする機能のリスト(以下を参照)とそれに続く空白行を出力する必要があります。機能コマンドへの応答により、Gitがコマンドストリームの残りの部分で使用するコマンドが決まります。

コマンドストリームは空白行で終了します。場合によっては(関連するコマンドのドキュメントに示されています)、この空白行の後に他のプロトコル(packプロトコルなど)のペイロードが続きますが、他の場合は入力の終了を示します。

@noindent

@heading Capabilities

各リモートヘルパーは、コマンド群のサブセットのみをサポートすることが期待されています。ヘルパーがサポートする操作は、 @samp{capabilities} コマンドへの応答でGitに宣言されます(以下のCOMMANDSを参照)。

以下に、定義されているすべての機能をリストし、それぞれについて、その機能を持つヘルパーが提供しなければならないコマンドをリストします。

@noindent

@subheading Capabilities for Pushing

@table @asis

@item  connect 
gitのネイティブpackfileプロトコルを使用した通信のために、 @samp{git receive-pack}(プッシュ用)、 @samp{git upload-pack} などへの接続を試みることができます。これには、双方向の全二重接続が必要です。

サポートされているコマンド: @samp{connect}

@item  stateless-connect 
実験的:内部使用のみ。 gitのワイヤープロトコル バージョン2を使用して、通信のためにリモートサーバーへの接続を試みることができます。詳細については、 stateless-connect コマンドのドキュメントを参照してください。

サポートされているコマンド: @samp{stateless-connect}.

@item  push 
リモートrefを発見する事ができ、そして、ローカルコミットとそれらに至るまでの履歴を、新規または既存のリモートrefにプッシュする事ができます。

サポートされているコマンド: @samp{list for-push}, @samp{push}.

@item  export 
リモートrefを発見し、指定のオブジェクトを高速インポートストリームからリモートrefにプッシュできます。

サポートされているコマンド: @samp{list for-push}, @samp{export}.
@end table

ヘルパーが @samp{connect} を広告(advertise)する場合、Gitは可能であればそれを使用し、接続時にヘルパーが要求すると別の機能にフォールバックします(「COMMANDS」セクションの @samp{connect} コマンド参照)。 @samp{push} と @samp{export} のどちらかを選択する場合、Gitは @samp{push} を優先します。他のフロントエンドには、他の優先順位がある場合があります。

@table @asis

@item  no-private-update 
@samp{refspec} 機能を使用する場合、gitは通常、プッシュが成功するとプライベートrefを更新します。リモートヘルパーが機能 @samp{no-private-update} を宣言すると、この更新は無効になります。
@end table

@noindent

@subheading Capabilities for Fetching

@table @asis

@item  connect 
Gitのネイティブpackfileプロトコルを使用した通信のために、 @samp{git upload-pack}(フェッチ用)、 @samp{git receive-pack} などへの接続を試みることができます。これには、双方向の全二重接続が必要です。

サポートされているコマンド: @samp{connect}

@item  stateless-connect 
実験的:内部使用のみ。 gitのワイヤープロトコル バージョン2を使用して、通信のためにリモートサーバーへの接続を試みることができます。詳細については、 stateless-connect コマンドのドキュメントを参照してください。

サポートされているコマンド: @samp{stateless-connect}.

@item  fetch 
リモートrefを発見し、それらから到達可能なオブジェクトをローカルオブジェクトストアに転送できます。

サポートされているコマンド: @samp{list}, @samp{fetch}.

@item  import 
リモートrefを発見し、それらから到達可能なオブジェクトを高速インポート形式(fast-import format)のストリームとして出力できます。

サポートされているコマンド: @samp{list}, @samp{import}.

@item  check-connectivity 
クローンを要求(request)されたときに、受信したパックが、自己完結しており、そして、接続されていることを保証できます。

@item  get 
@samp{get} コマンドを使用して、 特定の URI からファイルをダウンロードできます。
@end table

ヘルパーが @samp{connect} を広告(advertise)する場合、Gitは可能であればそれを使用し、接続時にヘルパーが要求すると別の機能にフォールバックします(「COMMANDS」セクションの @samp{connect} コマンド参照)。 @samp{fetch} と @samp{import} のどちらかを選択する場合、Gitは @samp{fetch} を優先します。他のフロントエンドには、他の優先順位がある場合があります。

@noindent

@subheading Miscellaneous capabilities

@table @asis

@item  option 
他のコマンドの実行方法に影響を与える @samp{verbosity} (stderrに書き込む出力量)や、 @samp{depth} (浅いクローン(shallow clone)の場合に必要な履歴量)などの設定を指定します。

@item  refspec <refspec> 
@samp{import} または @samp{export} を実装するリモートヘルパーの場合、この機能により、 @samp{refs/heads} または @samp{refs/remotes} に直接書き込む代わりに、refsをプライベート名前空間に制約できます。 @samp{import} 機能を提供するすべてのインポーターがこれを使用することをお勧めします。 @samp{export} では必須です。

機能 @samp{refspec refs/heads/*:refs/svn/origin/branches/*} を広告(advertise)するヘルパーは、 @samp{import refs/heads/topic} と問われた時に出力されるストリームは 、@samp{refs/svn/origin/branches/topic} ref を更新します。

この機能は複数回広告できます。最初に適用可能なrefspecが優先されます。この機能でアドバタイズされるrefspecの(@samp{:} の)左側は、listコマンドによって報告されるすべてのrefをカバーする必要があります。 @samp{refspec} 機能が広告されていない場合は暗黙の @samp{refspec *:*} が設定されています。

分散型バージョン管理システム用のリモートヘルパーを作成する場合は、リポジトリのローカルコピーを保持して対話することをお勧めします。プライベート名前空間refsがこのローカルリポジトリを指すようにし、refs/remotes 名前空間はリモートリポジトリを追跡するために使用されます。

@item  bidi-import 
これにより、 @samp{import} 機能が変更されます。fast-importコマンドの @samp{cat-blob} と @samp{ls} をリモートヘルパーが使用して、fast-importのメモリにすでに存在するブロブとツリーに関する情報を取得できます。これには、fast-importからリモートヘルパーへのチャネルが必要です。 @samp{import} に加えて広告される場合、Gitはfast-importからリモートヘルパーのstdinへのパイプを確立します。 したがって、Gitとfast-importは両方ともリモートヘルパーのstdinに接続されています。Gitは複数のコマンドをリモートヘルパーに送信できるため、データをfast-importに送信する前に、 @samp{bidi-import} を使用するヘルパーがバッチのすべての @samp{import} コマンドをバッファリングする必要があります。 これは、ヘルパーのstdinでコマンドと、fast-import高速インポート応答が混在するのを防ぐためです。

@item  export-marks <file> 
これにより、 @samp{export} 機能が変更され、完了時に内部マークテーブル(internal marks table)を<file>にダンプするようにGitに指示します。詳細については git-fast-export(1) の @samp{--export-marks=<file>} を参照してください。

@item  import-marks <file> 
これにより、 @samp{export} 機能が変更され、入力を処理する前に<file>で指定したマークをロードするようにGitに指示します。詳細については git-fast-export(1) の @samp{--import-marks=<file>} を参照してください。

@item  signed-tags 
これにより、 @samp{export} 機能が変更され、 @samp{--signed-tags=verbatim} を linkgit：git-fast-export[1]に渡すようにGitに指示します。この機能がない場合、Gitは @samp{--signed-tags=warn-strip} を使用します。

@item  object-format 
これは、ヘルパーが明示的なハッシュアルゴリズム拡張(explicit hash algorithm extension)を使用してリモート側と対話できることを示しています。
@end table

@noindent

@chapheading COMMANDS

コマンドは、ヘルパーの標準入力に、呼び出し元によって1行に1つずつ与えられます。

@table @asis

@item  capabilities 
ヘルパーの機能を1行に1つずつリスト出力し、空白行で終わります。各機能の前に @samp{*} を付けることができます。これは、リモートヘルパーを使うGitのバージョンで理解することが必須であることを示します。不明な必須機能は致命的なエラーです。

このコマンドのサポートは必須です。

@item  list 
refを1行に1つずつ、 @samp{<value> <name> [<attr> ...]} の形式で一覧出力します。 値は、16進のsha1ハッシュ または、symrefの場合は @samp{@@<dest>} または、キーと値のペアの場合は @samp{:<keyword> <value>} または、 `？｀ の場合はヘルパーがrefの値を取得できなかったことを示します。 nameの後には、スペースで区切られたattributes(属性)のリストが続きます。認識されない属性は無視されます。リストは空白行で終わります。

現在定義されている属性のリストについては、「REF LIST ATTRIBUTES」を参照してください。現在定義されているキーワードのリストについては、「REF LIST KEYWORDS」を参照してください。

ヘルパーに「fetch」または「import」機能がある場合にサポートされます。

@item  list for-push 
@samp{list} と似ていますが、呼び出し元が結果のrefリストでプッシュコマンドを準備したい場合にのみ使用される点が異なります。プッシュとフェッチの両方をサポートするヘルパーは、これを使用して、 @samp{list} の出力が使用される操作を区別し、実行する必要のある作業の量を減らすことができます。

ヘルパーに "push" または "export" 機能がある場合にサポートされます。

@item  option <name> <value> 
転送(transport)ヘルパーオプション <name> を <value> に設定します。出力は、 @samp{ok}(オプションが正常に設定された)または、 @samp{unsupported}(オプションが認識されない)または、 @samp{error <msg>}(オプション<name>はサポートされていますが、<value>は無効です)のいずれかを含む単一行です。オプションは他のコマンドの前に設定する必要があり、それらのコマンドの動作に影響を与える可能性があります。

現在定義されているオプションのリストについては、OPTIONSを参照してください。

ヘルパーに "option" 機能がある場合にサポートされます。

@item  fetch <sha1> <name> 
指定されたオブジェクトをフェッチし、必要なオブジェクトをデータベースに書き込みます。fetchコマンドは、1行に1つずつバッチで送信され、空白行で終了します。 同じバッチ内のすべてのfetchコマンドが完了すると、1行の空白行を出力します。この方法でフェッチできるのは、sha1を使用した @samp{list} の出力で報告されたオブジェクトのみです。

オプションで、refが適切に更新されるまでパックを保持している @samp{$GIT_DIR/objects/pack} の下のファイルのフルパスを示す @samp{lock<file>} 行を出力できます。パスは @samp{.keep} で終わる必要があります。これは、keepコンポーネントのみを指定して、 <pack,idx,keep> タプルに名前を付けるメカニズムです。保持されたパックは、フェッチが完了するまでそのオブジェクトが参照されない場合でも、並列再パック(concurrent repack)によって削除されません。 @samp{.keep} ファイルはフェッチの終了時に削除されます。

オプション @samp{check-connectivity} が要求された場合、クローンが自己完結型(self-contained)で接続されていれば、ヘルパーは @samp{connectivity-ok} を出力する必要があります。

ヘルパーに "fetch" 機能がある場合にサポートされます。

@item  push +<src>:<dst> 
指定された ローカル <src> コミットまたはブランチを、 <dst>で記述されたリモートブランチにプッシュします。 1つ以上の @samp{push} コマンドのバッチシーケンスは空白行で終了します(pushへの参照が1つしかない場合は、単一の @samp{push} コマンドの後に空白行が続きます)。たとえば、以下は @samp{push} の2つのバッチであり、最初のはリモートヘルパーに、ローカル参照 @samp{master} をリモート参照 @samp{master} にプッシュし、ローカル @samp{HEAD} をリモート @samp{branch} にプッシュするように要求します。2番目のは ref @samp{foo} を ref @samp{bar} にプッシュするように要求します(@samp{+} によって要求された強制更新です)。

@example
push refs/heads/master:refs/heads/master
push HEAD:refs/heads/branch
\n
push +refs/heads/foo:refs/heads/bar
\n
@end example


最後の @samp{push} コマンドの後、バッチの終了空白行の前に、0個以上のプロトコルオプションを入力できます。

プッシュが完了すると、1つ以上の @samp{ok <dst>} または @samp{error <dst> <why>?} 行を出力して、プッシュされた各参照の成功または失敗を示します。ステータスレポートの出力は空白行で終了します。オプションフィールド <why> は、LFが含まれている場合、Cスタイルの文字列でクォートされる場合があります。

ヘルパーに "push" 機能がある場合にサポートされます。

@item  import <name> 
名前付きrefの現在の値をインポートするfast-importストリームを生成します。履歴を効率的に構築するために、必要に応じて他の参照を追加でインポートする場合があります。スクリプトは、ヘルパー固有のプライベート名前空間に書き込みます。名前付きrefの値は、「refspec」機能からのrefspecをrefの名前に適用することによって派生した、この名前空間内の場所に書き込む必要があります。

他のバージョン管理システムとの相互運用性に特に役立ちます。

@samp{push} と同様に、1つ以上の @samp{import} のバッチシーケンスは空白行で終了します。 @samp{import} の各バッチごとに、リモートヘルパーは @samp{done} コマンドで終了する fast-import ストリームを生成する必要があります。

@samp{bidi-import} 機能を使用する場合は、ヘルパーのstdinでの、コマンドとfast-import応答の混合を防ぐために、fast-importへのデータの送信を開始する前にバッチシーケンスを完全にバッファリングする必要があることに注意してください。

ヘルパーに "import" 機能がある場合にサポートされます。

@item  export 
後続の入力は、リモートにプッシュする必要のあるオブジェクトを含むfast-importストリーム( @samp{git fast-export} によって生成される)の一部であることをリモートヘルパーに指示します。

他のバージョン管理システムとの相互運用性に特に役立ちます。

@samp{export-marks} と @samp{import-marks} 機能は、指定されている場合、 @samp{git fast-export｀ に渡される限り、このコマンドに影響します。 `git fast-export} は、ローカルオブジェクトのマークのテーブルを ロード/保存 します。 これは、増分操作の実装に使用できます。

ヘルパーに "export" 機能がある場合にサポートされます。

@item  connect <service> 
指定のサービスに接続します。ヘルパーの標準入力と標準出力は、リモート側で指定指定のサービスに接続されます(gitプレフィックスはサービス名に含まれているので、例えばフェッチはサービスとして @samp{git-upload-pack} を使用します)。このコマンドに対する有効な応答は、空行(接続が確立されました)と、 @samp{fallback} (スマート転送サポートなし、バカ転送(dumb transports)にフォールバック)と、エラーメッセージが印刷された状態で終了するだけです(接続できません、フォールバックしようと気にしないで)。肯定(空)応答が改行で終了すると、サービスの出力が開始されます。接続が終了すると、リモートヘルパーは終了します。

ヘルパーに "connect" 機能がある場合にサポートされます。

@item  stateless-connect <service> 
実験的: 内部使用のみ。 gitのワイヤープロトコルバージョン2を使用して通信するために、指定のリモートサービスに接続します。このコマンドへの有効な応答は、空行(接続が確立されました)と、 @samp{fall back} (スマート転送サポートなし、バカ転送にフォールバック)と、エラーメッセージ出力するだけです(接続できません。わざわざフォールバックしようとしないでください)。 正の(空の)応答を終了する改行の後、サービスの出力が開始されます。 メッセージ(要求と応答の両方)は、0個以上のPKT-LINEで構成され、フラッシュパケットで終了する必要があります。 応答メッセージには、応答の終了を示すフラッシュパケットの後に応答終了パケットがあります。 クライアントは、サーバーが要求と応答のペアの間に状態を保持することを期待してはなりません。接続が終了すると、リモートヘルパーが終了します。

ヘルパーに "stateless-connect" 機能がある場合にサポートされます。

@item  get <uri> <path> 
指定の @samp{<uri>} から指定の @samp{<path>} へファイルをダウンロードします。 @samp{<path>.temp} が存在する場合、Git は @samp{.temp} ファイルが以前の試みからの部分的なダウンロードであると想定し、 その位置からダウンロードを再開します。
@end table

致命的なエラーが発生した場合、プログラムはエラーメッセージをstderrに書き込み、終了します。呼び出し元は、子が現在のコマンドに対する有効な応答を完了せずに接続を閉じた場合に、適切なエラーメッセージを出力することを期待します。

ヘルパーによって報告された機能から判断できるように、追加のコマンドがサポートされる場合があります。

@noindent

@chapheading REF LIST ATTRIBUTES

@samp{list} コマンドは、各refの後に属性(attribute)のリストが続くことがあるrefのリストを生成します。以下のrefリスト属性(ref list attributes)が定義されています。

@table @asis

@item  unchanged 
このrefは、最後にインポートまたはフェッチしたときから変更されていませんが、ヘルパーは必ずしもどの値が生成されたかを判別することはできるわけではありません。
@end table

@noindent

@chapheading REF LIST KEYWORDS

listコマンドは、キーと値のペア(key-value pairs)のリストを生成する場合があります。以下のキーが定義されています。

@table @asis

@item  object-format 
refは指定のハッシュアルゴリズムを使用しています。このキーワードは、サーバーとクライアントの両方がオブジェクト形式の拡張機能(object-format extension)をサポートしている場合にのみ使用されます。
@end table

@noindent

@chapheading OPTIONS

以下のオプションは、リモートヘルパーに option 機能がある場合にGitによって定義され、(適切な状況下で)設定されます。

@table @asis

@item  option verbosity <n> 
ヘルパーによって表示されるメッセージの詳細度を変更します。 <n>の値0は、プロセスが静かに動作し、ヘルパーがエラー出力のみを生成することを意味します。 1は冗長性のデフォルトレベルであり、<n>の値が大きさは、コマンドラインで渡される @samp{-v} フラグの数に対応します。

@item  option progress @{@samp{true}|@samp{false}@} 
コマンド実行中に転送(transport)ヘルパーによって表示される進行状況メッセージを有効(または無効)にします。

@item  option depth <depth> 
浅いリポジトリ(shallow repository)の履歴を深めます。

@item  option deepen-since <timestamp> 
時間に基づいて浅いリポジトリ(shallow repository)の履歴を深めます。

@item  option deepen-not <ref> 
refを除く浅いリポジトリ(shallow repository)の履歴を深めます。複数回使用できます。

@item  option deepen-relative @{@samp{true}|@samp{false}@} 
現在の境界に比べて浅いリポジトリの履歴を深めます。 「option depth」で使用する場合にのみ有効です。

@item  option followtags @{@samp{true}|@samp{false}@} 
有効にすると、フェッチコマンド中にタグが指すオブジェクトが転送された場合、ヘルパーは注釈付きのタグオブジェクトを自動的にフェッチする必要があります。 タグがヘルパーによってフェッチされない場合、通常、2番目のフェッチコマンドが送信され、タグを具体的に要求します。一部のヘルパーは、このオプションを使用して2番目のネットワーク接続を回避できる場合があります。

@item  option dry-run @{@samp{true}|@samp{false}@} 
trueの場合、操作が正常に完了したふりをしますが、実際にはリポジトリデータを変更しません。 ほとんどのヘルパーの場合、これはサポートされている場合、 @samp{push} にのみ適用されます。

@item  option servpath <c-style-quoted-path> 
次の接続のサービスパス(@samp{--upload-pack} 、@samp{--receive-pack} など)を設定します。 リモートヘルパーはこのオプションをサポートする場合がありますが、接続要求が発生する前に、設定されているこのオプションに依存してはなりません。

@item  option check-connectivity @{@samp{true}|@samp{false}@} 
ヘルパーにクローンの接続を確認(check)するように依頼(request)します。

@item  option force @{@samp{true}|@samp{false}@} 
ヘルパーに強制更新を実行するように依頼(request)します。デフォルトは @samp{false} です。

@item  option cloning @{@samp{true}|@samp{false}@} 
これがクローンリクエストであることをヘルパーに通知します(つまり、現在のリポジトリは空であることが保証されています)。

@item  option update-shallow @{@samp{true}|@samp{false}@} 
新しいrefで必要な場合は、 .git/shallow を拡張できるようにします。

@item  option pushcert @{@samp{true}|@samp{false}@} 
GPG署名プッシュ。

@item  option push-option <string> 
<string>をプッシュオプションとして送信します。プッシュオプションにはLFまたはNUL文字を含めることはできないため、文字列はエンコードされません。

@item  option from-promisor @{@samp{true}|@samp{false}@} 
これらのオブジェクトがpromisorからフェッチされていることを示します。

@item  option no-dependents @{@samp{true}|@samp{false}@} 
依存関係ではなく、必要なオブジェクトのみをフェッチする必要があることを示します。

@item  option atomic @{@samp{true}|@samp{false}@} 
プッシュするときは、リモートサーバーに単一のアトミックトランザクションで参照を更新するように要求します。 成功すると、すべての参照が更新されるか、何も更新されません。 リモート側がこの機能をサポートしていない場合、プッシュは失敗します。

@item  option object-format @{@samp{true}|algorithm@} 
@samp{true} の場合、呼び出し元がハッシュアルゴリズム情報をリモートから返されることを望んでいることを示します。 このモードは、refをフェッチするときに使用されます。

algorithm に設定されている場合は、発信者がそのアルゴリズムを使用してリモート側と対話することを希望していることを示します。
@end table

@noindent

@chapheading SEE ALSO

git-remote(1)

git-remote-ext(1)

git-remote-fd(1)

git-fast-import(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitrepository-layout,,,Top
@chapheading Name

gitrepository-layout — Gitリポジトリの間取り

@noindent

@chapheading Synopsis

$GIT_DIR/*

@noindent

@chapheading DESCRIPTION

Gitリポジトリには2つの風味があります:

@itemize 

@item
作業ツリーのルートにある @samp{.git} ディレクトリ

@item
bare(裸の)リポジトリである(つまり、独自の作業ツリーがない)「<project>.git」ディレクトリ。通常、このディレクトリにプッシュしてフェッチすることにより、他のユーザーと履歴を交換するために使用されます。
@end itemize

@strong{注}: また、作業ツリーのルートにプレーンテキストファイル @samp{.git} を作成できます。
このファイルには、リポジトリがある実際のディレクトリを指す @samp{gitdir: <path>} が含まれています。
このメカニズムは、サブモジュールチェックアウトの作業ツリーによく使用され、
サブモジュールを含むスーパープロジェクトで、
サブモジュールを持たないブランチを「git checkout」できるようにします。
@samp{checkout} は、サブモジュールリポジトリを失うことなく、
サブモジュール作業ツリー全体を削除する必要があります。

以下のものがGitリポジトリに存在する可能性があります。

@table @asis

@item  objects 
このリポジトリに関連付けられているオブジェクトストア。通常、オブジェクトストアは自給自足です(つまり、そこにあるオブジェクトによって参照されるすべてのオブジェクトもそこにあります)が、それに違反する方法はいくつかあります。

@enumerate 

@item
浅いクローン(shallow clone)を作成することにより、不完全であるがローカルで使用可能なリポジトリを作成できます。 git-clone(1) を参照してください。

@item
@samp{objects/info/alternates} または @samp{$GIT_ALTERNATE_OBJECT_DIRECTORIES} メカニズムを使用して、他のオブジェクトストアからオブジェクトを「借用」(borrow)することができます。この種の不完全なオブジェクトストアを持つリポジトリは、馬鹿プロトコル(dumb transport)で使用するために公開するのには適していませんが、それ以外の場合は「objects/info/alternates」が借用するオブジェクトストアを指している限り問題ありません。

$GIT_COMMON_DIR が設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/objects」が使用されます。
@end enumerate

@item  objects/[0-9a-f][0-9a-f] 
新しく作成されたオブジェクトは、独自のファイルに保存されます。オブジェクトは、sha1オブジェクト名の最初の2文字を使用して、256個のサブディレクトリに分散され、 @samp{objects} 自体のディレクトリエントリの数を管理可能な数に保ちます。ここにあるオブジェクトは、「アンパックオブジェクト」(unpacked obuject)(または「ルーズオブジェクト」(loose object))と呼ばれることがよくあります。

@item  objects/pack 
パック(多くのオブジェクトを圧縮形式で格納するファイルと、ランダムにアクセスできるようにするためのインデックスファイル)は、このディレクトリにあります。

@item  objects/info 
オブジェクトストアに関する追加情報は、このディレクトリに記録されます。

@item  objects/info/packs 
このファイルは、馬鹿プロトコルがこのオブジェクトストアで使用可能なパックを検出するのに役立ちます。リポジトリが馬鹿プロトコル用に公開されている場合は、パックを追加または削除するたびに、 @samp{git update-server-info} を実行して、このファイルを最新の状態に保つ必要があります。 @emph{git repack} はデフォルトでこれを行います。

@item  objects/info/alternates 
このファイルは、このオブジェクトストアがオブジェクトを借用(borrow)する代替オブジェクトストアへのパスを、1行に1つのパス名で記録します。ネイティブGitツールがローカルで使用するだけでなく、HTTP fetcher もリモートで使用しようとすることに注意してください。これは通常、代替ファイルに相対パス(リポジトリではなくオブジェクトデータベースに対して！)がある場合は機能しますが、ファイルシステムとWeb URLの絶対パスが同じでない限り、絶対パスを使用する場合は機能しません。 @samp{objects/info/http-alternates} も参照してください。

@item  objects/info/http-alternates 
このファイルは、このオブジェクトストアがオブジェクトを借用(borrow)する代替オブジェクトストアへのURLを記録し、リポジトリがHTTP経由でフェッチされるときに使用されます。

@item  refs 
参照(reference)は、このディレクトリのサブディレクトリに保存されます。 @emph{git prune} コマンドは、このディレクトリとそのサブディレクトリに見つかったrefsから到達可能なオブジェクトを認識し保持します。$GIT_COMMON_DIRが設定されていて、代わりに「$GIT_COMMON_DIR/refs」が使用される場合、このディレクトリは無視されます(refs/bisectとrefs/rewrittenとrefs/worktreeを除く)。

@item  refs/heads/@samp{name} 
ブランチ @samp{name} のツリーの先端(tip-of-the-tree)のコミットオブジェクトを記録します

@item  refs/tags/@samp{name} 
オブジェクト名を記録します(必ずしもコミットオブジェクト、またはコミットオブジェクトを指すタグオブジェクトである必要はありません)。

@item  refs/remotes/@samp{name} 
リモートリポジトリからコピーされたブランチのツリーの先端(tip-of-the-tree)のコミットオブジェクトを記録します。

@item  refs/replace/@samp{<obj-sha1>} 
@samp{<obj-sha1>} を置き換えるオブジェクトのSHA-1を記録します。これはinfo/graftsに似ており、 git-replace(1) によって内部的に使用および保守されます。 このようなrefsはリポジトリ間で交換できますが、graftsは交換できません。

@item  packed-refs 
refs/heads/ や refs/tags/ と同じ情報を記録し、そして friends がより効率的な方法で記録します。 git-pack-refs(1) を参照してください。 $GIT_COMMON_DIR が設定されている場合、このファイルは無視され、代わりに「$GIT_COMMON_DIR/packed-refs」が使用されます。

@item  HEAD 
現在アクティブなブランチを説明する @samp{refs/heads/} 名前空間へのシンボリックref(symref;glossaryを参照)。リポジトリが作業ツリーに関連付けられていない場合(つまり、ベアリポジトリの場合)はあまり意味がありませんが、有効なGitリポジトリにはHEADファイルが「必要」です。一部の磁器コマンドは、これを使用して、リポジトリの指定された「デフォルト」ブランチ(通常は「master」)を推測する場合があります。名前付きブランチ @emph{name} が(まだ)存在しない場合も合法です。一部のレガシー設定では、現在のブランチを指すシンボリックref(symref)ではなくシンボリックリンクです。

HEADは、現在のブランチを指すシンボリックref(symref)である代わりに、特定のコミットを直接記録することもできます。このような状態は「detached HEAD」と呼ばれることがよくあります。詳細については git-checkout(1)を参照してください。

@item  config 
リポジトリ固有の構成ファイル。 $GIT_COMMON_DIR が設定されている場合、このファイルは無視され、代わりに「$GIT_COMMON_DIR/config」が使用されます。

@item  config.worktree 
複数の作業ディレクトリ設定の、メイン作業ディレクトリための、作業ディレクトリ固有の構成ファイル(git-worktree(1) を参照)。

@item  branches 
@emph{git fetch} や @emph{git pull} や @emph{git push} へのURLを指定するために使用される短縮形を格納するための、少々非推奨の方法。ファイルは @samp{branches/<name>} として保存でき、 @emph{repository} 引数の代わりに @emph{name} をこれらのコマンドに指定できます。詳細については、 git-fetch(1) の REMOTES セクションを参照してください。この機構はレガシーであり、最新のリポジトリには見られない可能性があります。 $GIT_COMMON_DIR が設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/branches」が使用されます。

@item  hooks 
フックは、さまざまなGitコマンドで使用されるカスタマイズスクリプトです。 @emph{git init} を実行すると、いくつかのサンプルフックがインストールされますが、デフォルトではすべて無効になっています。有効にするには、ファイル名から @samp{.sample} サフィックスを削除して名前を変更する必要があります。各フックの詳細については、 githooks(5) をお読みください。 $GIT_COMMON_DIR が設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/hooks」が使用されます。

@item  common 
複数の作業ツリーが使用されている場合、 $GIT_DIR 内のほとんどのファイルは、いくつかの既知の例外を除いて、各作業ツリー毎とにありますです。ただし、「common」の下にあるすべてのファイルは、すべての作業ツリー間で共有されます。

@item  index 
リポジトリの現在のインデックスファイル。通常、ベアリポジトリには見つかりません。

@item  sharedindex.<SHA-1> 
$GIT_DIR/indexおよびその他の一時(temporary)インデックスファイルによって参照される共有インデックス部分。スプリットインデックスモード(split index mode)でのみ有効です。

@item  info 
リポジトリに関する追加情報は、このディレクトリに記録されます。 $GIT_COMMON_DIR が設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/info」が使用されます。

@item  info/refs 
このファイルは、馬鹿プロトコル(dumb transports)がこのリポジトリで使用可能なrefsを検出するのに役立ちます。リポジトリが馬鹿プロトコル(dumb transports)用に公開されている場合、このファイルは、タグまたはブランチが作成または変更されるたびに、「git update-server-info」によって再生成される必要があります。これは通常、リポジトリに「git push」したときに「git-receive-pack」コマンドによって実行される「hooks/update」フックから実行されます。

@item  info/grafts 
このファイルは、コミットが実際に作成された方法とは異なる親のセットを装うために、偽のコミットの祖先情報を記録します。1行に1つのレコードは、スペースで区切られ、改行で終了する40バイトの16進オブジェクト名をリストすることにより、コミットとその偽の親を記述します。

graftsメカニズムは古臭く、リポジトリ間でオブジェクトを転送する際に問題が発生する可能性があることに注意してください。 同じことを行うためのより柔軟で堅牢なシステムについては、 git-replace(1) を参照してください。

@item  info/exclude 
このファイルは、磁器コマンドの慣例により、除外パターンリストを格納します。 @samp{.gitignore} は、ディレクトリごとの無視ファイルです。「git status」、「git add」、「git rm」、「git clean」はこの除外パターンリストを調べますが、コアGitコマンドはこの除外パターンリストを調べません。 gitignore(5) も参照してください。

@item  info/attributes 
ディレクトリごとの @samp{.gitattributes} ファイルと同様に、パスに割り当てる属性を定義します。
gitattributes(5) も参照してください。

@item  info/sparse-checkout 
このファイルには、スパースチェックアウトパターン(sparse checkout patterns)が格納されています。 git-read-tree(1) も参照してください。

@item  remotes 
@emph{git fetch} と @emph{git pull} と @emph{git push} コマンドを介してリモートリポジトリと対話するときに使用するURLの省略形とデフォルトのref名を格納します。詳細については、 git-fetch(1)のREMOTESセクションを参照してください。このメカニズムはレガシーであり、最新のリポジトリには見られない可能性があります。 $GIT_COMMON_DIR が設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/remotes」が使用されます。

@item  logs 
refに加えられた変更の記録は、このディレクトリに保存されます。詳細については、 git-update-ref(1) を参照してください。 $GIT_COMMON_DIRが設定されていて、代わりに「$GIT_COMMON_DIR/logs」が使用される場合、このディレクトリは無視されます(但し、logs/HEADを除く)。

@item  logs/refs/heads/@samp{name} 
@samp{name} という名前のブランチ先端(branch tip)に加えられたすべての変更を記録します。

@item  logs/refs/tags/@samp{name} 
@samp{name} という名前のタグに加えられたすべての変更を記録します。

@item  shallow 
これは @samp{info/grafts} に似ていますが、内部的に使用され、浅いクローンメカニズム(shallow clone mechanism)によって維持されます。 git-clone(1) と git-fetch(1) の @samp{--depth} オプションを参照してください。 $GIT_COMMON_DIRが設定されている場合、このファイルは無視され、代わりに「$GIT_COMMON_DIR/shallow」が使用されます。

@item  commondir 
このファイルが存在する場合、明示的に設定されていなければ、 $GIT_COMMON_DIR (git(1) を参照)はこのファイルで指定されたパスに設定されます。指定されたパスが相対パスの場合、それは$GIT_DIRからの相対パスです。commondirのあるリポジトリは、「commondir」が指すリポジトリがないと不完全です。

@item  modules 
サブモジュールのgitリポジトリが含まれています。

@item  worktrees 
リンクされた作業ツリー(linked working trees)の管理データが含まれています。各サブディレクトリには、リンクされた作業ツリーの作業ツリー関連部分が含まれています。 $GIT_COMMON_DIRが設定されている場合、このディレクトリは無視され、代わりに「$GIT_COMMON_DIR/worktrees」が使用されます。

@item  worktrees/<id>/gitdir 
ここを指す .git ファイルに戻る絶対パスを含むテキストファイル。これは、リンクされたリポジトリが手動で削除されているかどうかを確認するために使用され、このディレクトリをこれ以上保持する必要はありません。 このファイルのmtimeは、リンクされたリポジトリにアクセスするたびに更新する必要があります。

@item  worktrees/<id>/locked 
このファイルが存在する場合、リンクされた作業ツリーがポータブルデバイス上にあり、使用できない可能性があります。このファイルが存在すると、 @samp{git worktree prune} によって @samp{worktrees/<id>} が自動または手動で剪定(prune)されるのを防ぎます。ファイルには、リポジトリがロックされている理由を説明する文字列が含まれている場合があります。

@item  worktrees/<id>/config.worktree 
作業ディレクトリ固有の構成ファイル。
@end table

@noindent

@chapheading Git Repository Format Versions

すべてのgitリポジトリは、その @samp{config} ファイルの @samp{core.repositoryformatversion} キーに、バージョン数値が印されています。このバージョン数値は、ディスク上のリポジトリデータを操作するためのルールを指定します。 ディスク上のリポジトリから告知された特定のバージョンを理解しないgitの実装は、そのリポジトリで動作してはなりません。そうすることは、間違った結果を生み出すだけでなく、実際にデータを失うリスクがあります。

このルールのため、バージョンアップは最小限に抑える必要があります。代わりに、我々は一般的に以下の戦略を好みます:

@itemize 

@item
個々のデータファイル(インデックス、パックファイルなど)のフォーマットバージョン番号をバージョンアップします。これにより、非互換性がそれらのファイルのみに制限されます。

@item
古いクライアントで使用すると正常に機能制限される(gracefully degrade)新しいデータを導入します(たとえば、パックビットマップファイルは古いクライアントでは無視され、提供される最適化を利用しません)。
@end itemize

リポジトリ全体の形式のバージョンアップは、個別にバージョン管理できない部分だけにするべきです。たとえば、オブジェクトの到達可能性ルール、またはrefをロックするためのルールを変更する場合、リポジトリ形式バージョンのバージョンアップが必要になります。

注意: これは、リポジトリのディスクコンテンツに直接アクセスする場合にのみ適用されることに注意してください。 フォーマット @samp{0} のみを理解する古いクライアントは、サーバープロセスがフォーマット @samp{1} を理解している限り、フォーマット @samp{1} を使用して @samp{git://} を介してリポジトリに接続できます。

バージョンアップをお披露目するための推奨される戦略(リポジトリ全体または単一ファイル)は、gitに新しい形式を読み取るように教え、(実験用または古いgitとの下位互換性については気にしないでいいように)構成スイッチまたはコマンドラインオプションを使用して新しい形式を記述できるようにすることです。その後、読み取り機能が一般的になるまでの長い期間の後、デフォルトを新しい形式の書き込みに切り替える場合があります。

現在定義されているフォーマットバージョンは以下のとおりです:

@noindent

@heading Version 0

これは、gitの初期バージョンで定義されている形式であり、リポジトリディレクトリ、リポジトリ構成ファイル、オブジェクトおよびrefストレージの形式が含まれま すが、これらに限定されません。gitの完全な動作を記述することは、このドキュメントの役割ではありません。

@noindent

@heading Version 1

この形式は、以下の例外を除いて、バージョン `0`と同じです:

@enumerate 

@item
@samp{core.repositoryformatversion} 変数を読み取る場合、バージョン1をサポートするgit実装は、構成ファイルの @samp{extensions} セクションにある構成キーも読み取る必要があります。

@item
バージョン1リポジトリが、実行中のgitが実装していない @samp{extensions.*} キーを指定している場合、操作の続行は禁止です。同様に、既知のキーの値が実装によって理解されない場合、操作の続行は禁止です。
@end enumerate

注意: 設定ファイルに拡張機能(extension)の指定が無い場合は、 @samp{core.repositoryformatversion} を @samp{0} に設定する必要があります(`1`に設定してもメリットはなく、リポジトリはgitの古い実装と互換性がなくなります)。

このドキュメントは、拡張機能のマスターリストとして機能します。新しい拡張機能を定義したい実装は、名前を主張するために、ここにそれを書き留めておく必要があります。

定義されている拡張機能は以下のとおりです:

@noindent

@subheading noop

この拡張機能は、gitの動作をまったく変更しません。 これは、フォーマット1の互換性をテストする場合にのみ役立ちます。

@noindent

@subheading preciousObjects

設定キー @samp{extensions.preciousObjects} が @samp{true} に設定されている場合、リポジトリ内のオブジェクトを削除してはなりません(たとえば、 @samp{git-prune} または @samp{git repack -d} など)。

@noindent

@subheading partialClone

When the config key @samp{extensions.partialClone} is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a "promisor remote" and it promises that all such omitted objects can be fetched from it in the future.

このキーの値は、promisor remoteの名前です。

@noindent

@subheading worktreeConfig

設定されている場合、デフォルトでは、「git config」はGIT_DIRの「config」ファイルと「config.worktree」ファイルの両方からこの順序で読み取ります。複数の作業ディレクトリモードでは、「config.worktree」が作業ディレクトリごとにある間（つまり、 GIT_COMMON_DIR/worktrees/<id>/config.worktree にあります)、「config」ファイルは共有されます。

@noindent

@chapheading SEE ALSO

git-init(1), git-clone(1), git-fetch(1), git-pack-refs(1), git-gc(1), git-checkout(1), gitglossary(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitrevisions,,,Top
@chapheading Name

gitrevisions — Gitのリビジョンと範囲を指定する

@noindent

@chapheading Synopsis

gitrevisions

@noindent

@chapheading DESCRIPTION

多くのGitコマンドは、リビジョンパラメーターを引数として取ります。コマンドに応じて、特定のコミットを示します。リビジョングラフをたどるコマンド(git-log(1) など)の場合は、そのコミットから到達可能なすべてのコミットを示します。リビジョングラフをたどるコマンドの場合、リビジョンの範囲を明示的に指定することもできます。

さらに、一部のGitコマンド(git-show(1) や git-push(1) など)は、コミット以外のオブジェクトを示すリビジョンパラメーターを受け取ることもできます。例えば、ブロブ(ファイル)またはツリー(ファイルのディレクトリ)です。

@noindent

@chapheading SPECIFYING REVISIONS

リビジョンパラメータ @samp{<rev>} は必ずしもそうとは限りませんが、通常はコミットオブジェクトに名前を付けます。これは、いわゆる「拡張SHA-1」構文を使用します。 オブジェクト名を綴るにはさまざまな方法があります。このリストの終わり近くにリストされているものは、コミットに含まれているツリーとブロブに名前を付けています。

@quotation

@strong{Note}

この文書は、gitで見られる「生の」構文を示しています。シェルおよびその他のUIでは、特殊文字を保護し、単語の分割を回避するために、追加の引用符が必要になる場合があります。
@end quotation

@table @asis

@item  @samp{<sha1>} 例: @samp{dae86e1950b1277e545cee180551750029cfe735}, @samp{dae86e} 
完全なSHA-1オブジェクト名(40バイトの16進文字列)、またはリポジトリ内で一意の先頭のsubstring。例えば dae86e1950b1277e545cee180551750029cfe735 と dae86e はどちらも、リポジトリ内にオブジェクト名が dae86e で始まる他のオブジェクトがない場合、全く同じコミットオブジェクトに名前を付けます。

@item  @samp{<describeOutput>} 例: @samp{v1.7.4.2-679-g3bee7fb} 
@samp{git describe} からの出力。つまり、現在のコミットから最も近いタグ。オプションで、ダッシュ(-)とそのタグ以降現在のコミットが何番目になるかの数が続き、その後にダッシュ(-)、「g」、および省略されたオブジェクト名が続きます。

@item  @samp{<refname>} 例: @samp{master}, @samp{heads/master}, @samp{refs/heads/master} 
シンボリックref名。例えば @samp{master} は通常、 @samp{refs/heads/master} によって参照されるコミットオブジェクトを意味します。 @samp{heads/master} と @samp{tags/master} の両方がある場合は、あなたは @samp{heads/master} と明示的に指定して、どちらを意味するかをGitに伝えることができます。 あいまいな場合、 @samp{<refname>} は、以下のルールに従い最初の一致を採用ことで明確になります:

@enumerate 

@item
If @emph{$GIT_DIR/<refname>} exists, that is what you mean (this is usually useful only for @samp{HEAD}, @samp{FETCH_HEAD}, @samp{ORIG_HEAD}, @samp{MERGE_HEAD}, @samp{REBASE_HEAD}, @samp{REVERT_HEAD}, @samp{CHERRY_PICK_HEAD}, @samp{BISECT_HEAD} and @samp{AUTO_MERGE});

@item
でなければ @samp{refs/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/tags/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/heads/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/remotes/<refname>} が存在すればそれを採用します。

@item
でなければ @samp{refs/remotes/<refname>/HEAD} が存在すればそれを採用します。
@end enumerate

@table @asis

@item  @samp{HEAD} 
names the commit on which you based the changes in the working tree.

@item  @samp{FETCH_HEAD} 
records the branch which you fetched from a remote repository with
your last @samp{git fetch} invocation.

@item  @samp{ORIG_HEAD} 
is created by commands that move your @samp{HEAD} in a drastic way (@samp{git
am}, @samp{git merge}, @samp{git rebase}, @samp{git reset}), to record the position
of the @samp{HEAD} before their operation, so that you can easily change
the tip of the branch back to the state before you ran them.

@item  @samp{MERGE_HEAD} 
records the commit(s) which you are merging into your branch when you
run @samp{git merge}.

@item  @samp{REBASE_HEAD} 
during a rebase, records the commit at which the operation is
currently stopped, either because of conflicts or an @samp{edit} command in
an interactive rebase.

@item  @samp{REVERT_HEAD} 
records the commit which you are reverting when you run @samp{git revert}.

@item  @samp{CHERRY_PICK_HEAD} 
records the commit which you are cherry-picking when you run @samp{git
cherry-pick}.

@item  @samp{BISECT_HEAD} 
records the current commit to be tested when you run @samp{git bisect
--no-checkout}.

@item  @samp{AUTO_MERGE} 
records a tree object corresponding to the state the
@emph{ort} merge strategy wrote to the working tree when a merge operation
resulted in conflicts.
@end table

注意: 上記の @samp{refs/*} の場合、 @samp{$GIT_DIR/refs} ディレクトリまたは @samp{$GIT_DIR/packed-refs} ファイルのいずれかから発生する可能性があることに注意してください。ref名のエンコードは指定されていませんが、一部の出力処理ではUTF-8でref名を想定する場合があるため、UTF-8が推奨されます。

@item  @samp{@@} 
@samp{@@} 単独では @samp{HEAD} のショートカットを意味します。

@item  @samp{[<refname>]@@@{<date>@}} 例: @samp{master@@@{yesterday@}}, @samp{HEAD@@@{5 minutes ago@}} 
refの後に接尾辞 @samp{@@} が続き、日付指定が中括弧のペアで囲まれています(例: @samp{@{yesterday@}} 、 @samp{@{1 month 2 weeks 3 days 1 hour 1 second ago@}} 、@samp{@{1979-02-26 18:30:00@}} )。これは以前の時点でのrefの値を指定します。この接尾辞は、ref名の直後にのみ使用でき、refには既存のログ( @samp{$GIT_DIR/logs/<ref>} )が必要です。これは、特定の時点での @strong{ローカル} refの状態を検索することに注意してください。たとえば、先週ローカルの @samp{master} ブランチに何があったか、です。特定の時間に行われたコミットを確認する場合は、 @samp{--since} と @samp{--until} を参照してください。

@item  @samp{<refname>@@@{<n>@}} 例: @samp{master@@@{1@}} 
refの後に接尾辞 @samp{@@} が続き、数の指定が中括弧のペアで囲まれている場合(たとえば @samp{@{1@}}, @samp{@{15@}})、そのrefのn個前の値を指定します。たとえば @samp{master@@@{1@}} は @samp{master} の直前の値であり、 @samp{master@@@{5@}} は @samp{master} の5個前の値です。この接頭辞は、ref名の直後にのみ使用でき、refには既存のログ( @samp{$GIT_DIR/logs/<refname>} )が必要です。

@item  @samp{@@@{<n>@}} 例: @samp{@@@{1@}} 
空のref部分で @samp{@@} コンストラクトを使用して、現在のブランチのreflogエントリを取得できます。たとえば、あなたがブランチ @samp{blabla} を使用している場合、 @samp{@@@{1@}} は @samp{blabla@@@{1@}} と同じ意味になります。

@item  @samp{@@@{-<n>@}} 例: @samp{@@@{-1@}} 
構成 @samp{@@@{-<n>@}} は、現在のブランチ/コミットの前にチェックアウトされた<n>番目のブランチ/コミットを意味します。

@item  @samp{[<branchname>]@@@{upstream@}} 例: @samp{master@@@{upstream@}}, @samp{@@@{u@}} 
ブランチ B は、 リモート R (@samp{branch.<name>.remote} で構成)で、ブランチ X (@samp{branch.<name>.merge} で構成)の上に構築するようにセットアップできます。 @samp{B@@@{u@}} は、リモート R から取られたブランチ X のリモート追跡ブランチを参照し、 通常は @samp{refs/remotes/R/X} にあります。

@item  @samp{[<branchname>]@@@{push@}} 例: @samp{master@@@{push@}}, @samp{@@@{push@}} 
接尾辞 @samp{@@\@{push@}} は、 @samp{branchname} がチェックアウトされているときに @samp{git push} が実行された場合(またはブランチ名が指定されていない場合は現在の @samp{HEAD} )、「プッシュ先」のブランチを報告します。 @samp{@@\@{upstream\@}} の場合と同様に、リモートのブランチに対応するリモート・トラッキング・ブランチを報告します。

ここで、よりはっきり分かる例を以下に示します:

@example
$ git config push.default current
$ git config remote.pushdefault myfork
$ git switch -c mybranch origin/master

$ git rev-parse --symbolic-full-name @@@{upstream@}
refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @@@{push@}
refs/remotes/myfork/mybranch
@end example


注意: この例では、ある場所からプルして別の場所にプッシュする三角形のワークフローを設定していることに注意してください。非三角形のワークフローでは、 @samp{@@\@{push@}} は @samp{@@\@{upstream@}} と同じであり、このようなことをする必要はありません。

この接尾辞は大文字で綴る場合にも受け入れられ、大文字と小文字を問わず同じことを意味します。

@item  @samp{<rev>^[<n>]} 例: @samp{HEAD^, v1.5.1^0} 
リビジョンパラメータの接尾辞 @samp{^} は、そのコミットオブジェクトの最初の親を意味します。 @samp{^<n>} は <n> 番目の親を意味します(つまり、 @samp{<rev>^} は @samp{<rev>^1} と同じです)。特別ルールとして、 @samp{<rev>^0} はコミット自体を意味し、 @samp{<rev>} がコミットオブジェクトを参照するタグオブジェクトのオブジェクト名である場合に使用されます。

@item  @samp{<rev>~[<n>]} 例: @samp{HEAD~, master~3} 
リビジョンパラメータの接尾辞 @samp{~} は、そのコミットオブジェクトの最初の親を意味します。リビジョンパラメータの接尾辞 @samp{~<n>} は、最初の親のみに続く、指定されたコミットオブジェクトの <n> 世代の祖先であるコミットオブジェクトを意味します。つまり、 @samp{<rev>~3} は @samp{<rev>^^^} と同じで、するってぇと @samp{<rev>^1^1^1} と同じということです。この形式については以下の図を参照してください。

@item  @samp{<rev>^@{<type>@}} 例: @samp{v0.99.8^@{commit@}} 
接尾辞 @samp{^} の後に中括弧のペアで囲まれたオブジェクトタイプ名が続くということは、タイプ @samp{<type>} のオブジェクトが見つかるか、オブジェクトを逆参照できなくなるまで、 @samp{<rev>} でオブジェクトを再帰的に逆参照する(この場合は、いろいろ一旦飲み込んでしまったのを吐きもどすような感じだぬ)ことを意味します。 たとえば、 @samp{<rev>} がコミットっぽい場合、 @samp{<rev>^@{commit@}} は対応するコミットオブジェクトを記述します。同様に、 @samp{<rev>} がツリーっぽい場合、 @samp{<rev>^@{tree@}} は対応するツリーオブジェクトを記述します。 @samp{<rev>^0} は @samp{<rev>^@{commit@}} の省略形です。

@samp{<rev>^@{object@}} を使用すると、 @samp{<rev>} がタグである必要がなく、 @samp{<rev>} を逆参照することなく、 @samp{<rev>} が存在するオブジェクトに名前を付けることができます。なお、タグはすでにオブジェクトであるため、オブジェクトに到達するために一度も逆参照する必要はありません。

@samp{<rev>^@{tag@}} を使用して、 @samp{<rev>} が既存のタグオブジェクトを確実に識別することができます。

@item  @samp{<rev>^@{@}} 例: @samp{v0.99.8^@{@}} 
接尾辞 @samp{^} の後に空のブレースペアが続くということは、オブジェクトがタグである可能性があることを意味し、タグ以外のオブジェクトが見つかるまでタグを再帰的に逆参照します。

@item  @samp{<rev>^@{/<text>@}} 例: @samp{HEAD^@{/fix nasty bug@}} 
リビジョンパラメータの接尾辞 @samp{^} と、それに続くスラッシュで始まるテキストを含む中括弧のペアは、以下の @samp{:/fix nasty bug} 構文と同じですが、 @samp{^} の前の @samp{<rev>} から到達可能な一致する最も若いコミットを返す点が異なります。

@item  @samp{:/<text>} 例: @samp{:/fix nasty bug} 
コロンに続いてスラッシュそしてそれに続くテキストは、コミットメッセージが指定された正規表現と一致するコミットを示します。この名前は、HEADを含む任意のrefから到達可能な最も若い一致するコミットを返します。正規表現は、コミットメッセージの任意の部分に一致できます。文字列で始まるメッセージを照合するには、たとえば、 @samp{:/^foo} とします。特別なシーケンス @samp{:/!} はマッチングの修飾子用に予約されています。ます。 @samp{:/!-foo} は一致の否定を実行し、 @samp{:/!!foo} はリテラル @samp{!} 後に @samp{foo} が続く文字列とマッチします。 @samp{:/!} で始まるその他のシーケンスは今のところ予約されています。指定されたテキストによっては、シェルにより追加の引用符が必要になる場合があります。

@item  @samp{<rev>:<path>} 例: @samp{HEAD:README}, @samp{master:./README} 
接尾辞 @samp{:} の後にパス(path)を続けると、コロンの前の部分によって名前が付けられたツリー風のオブジェクト内の、指定されたパスにあるブロブまたはツリーに名前が付けられます。 @samp{./} または @samp{../} で始まるパスは、現在の作業ディレクトリからの相対パスです。指定のパスは、作業ツリーのルートディレクトリからの相対パスに変換されます。これは、作業ツリーと同じツリー構造を持つコミットまたはツリーからブロブまたはツリーをアドレス指定するのに最も役立ちます。

@item  @samp{:[<n>:]<path>} 例: @samp{:0:README}, @samp{:README} 
コロンに、オプションでステージ番号(0〜3)とコロンが続き、それにパスが続くと、指定されたパスのインデックス内のブロブオブジェクトに名前を付けます。ステージ番号省略(およびそれに続くコロン)は、ステージ0エントリーを示します。マージ作業中、ステージ1は共通の祖先、ステージ2はターゲットブランチのバージョン(通常は現在のブランチ)、ステージ3はマージされるブランチのバージョンです。
@end table

以下はJon Loeligerによる図解です。コミットノードBとCはどちらもコミットノードAの親です。親コミットは左から右に順序付けられます。

@example
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
@end example

@example
A =      = A^0
B = A^   = A^1     = A~1
C =      = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
@end example

@noindent

@chapheading SPECIFYING RANGES

@samp{git log} などの履歴トラバースコマンドは、単一のコミットだけでなく、一連のコミットで動作します。

これらのコマンドの場合、前のセクションで説明した表記法を使用して単一のリビジョンを指定することは、指定のコミットから「到達可能」なコミットの組を意味します。

複数のリビジョンを指定するということは、指定のコミットのいずれかから到達可能なコミットの組を意味します。

コミットの到達可能な組は、コミット自体とその祖先チェーン内のコミットです。

以下に示すように、接続されたコミット(connected commits)の組(「リビジョン範囲」(revision range)と呼ばれる)を指定するためのいくつかの表記法があります。

@noindent

@heading Commit Exclusions

@table @asis

@item  @samp{^<rev>} (カレット)記法 
とある到達可能なコミットをコミット達から除外するには、接頭辞 @samp{^} 表記を使用します。 例えば @samp{^r1 r2} は @samp{r2} から到達可能なコミットだけども、 @samp{r1} から到達可能なコミット(つまり @samp{r1} とその祖先)は除外する事を意味します。
@end table

@noindent

@heading Dotted Range Notations

@table @asis

@item  @samp{..} (2ドット)範囲記法 
@samp{^r1 r2} 操作は頻繁に表示されるため、省略形があります。(上記の SPECIFYING REVISIONS で説明されている構文に従って名前が付けられている)2つのコミット @samp{r1} と @samp{r2} がある場合、あなたは @samp{^r1 r2} によってr1から到達可能なコミットを取り除き、r2から到達可能なコミットを要求できます。そしてこれは @samp{r1..r2} と書くことができます。

@item  @samp{...} (3ドット)対称差記法 
似た表記 @samp{r1...r2} は @samp{r1} と @samp{r2} の対称差と呼ばれ、 @samp{r1 r2 --not $(git merge-base --all r1 r2)} として定義されます。 これは、 @samp{r1} (左側)または @samp{r2} (右側)のいずれかから到達可能であるが、両方からは到達できないコミットの組です。
@end table

これらの2つの省略表記では、一方の端を省略して、デフォルトでHEADにすることができます。たとえば、 @samp{origin..} は @samp{origin..HEAD} の省略形であり、「originブランチから分岐(fork)してから何をしましたか？」と尋ねます。 同様に、 @samp{..origin} は @samp{HEAD..origin} の省略形であり、「私がそれらから分岐してから、originは何をしましたか？」と尋ねます。 @samp{..} は @samp{HEAD..HEAD} を意味することに注意してください。これは、HEADから到達可能および到達不能の両方の空の範囲です。

2つの異なる範囲を取るように特別に設計されたコマンド(たとえば、2つの範囲を比較するための "git range-diff R1 R2" ) は存在しますが、それらは例外です。特に明記されていない限り、一連のコミットを操作するすべての "git" コマンドは、単一のリビジョン範囲で機能します。言い換えると、2つの「2ドット範囲表記」を隣り合わせに記述します。

@example
$ git log A..B C..D
@end example

ほとんどのコマンドでは2つのリビジョン範囲を指定しません。代わりに、接続された単一のコミットの組、つまりBまたはDのいずれかから到達可能であるが、AまたはCのどちらからも到達可能でないコミットの組に名前を付けます。線形履歴では、以下のようになります:

@example
---A---B---o---o---C---D
@end example

AとBはCから到達可能であるため、これら2つの2ドット範囲記法で指定されたリビジョン範囲は単一のコミットDです。

@noindent

@heading Other <rev>^ Parent Shorthand Notations

コミットとその親コミットによって形成される組に名前を付けるために、マージコミットに特に役立つ他の3つの省略形が存在します。

@samp{r1^@@} 表記は、 @samp{r1} のすべての親を意味します。

@samp{r1^!} 表記には コミット @samp{r1} が含まれますが、そのすべての親は除外されます。この表記自体は、単一のコミット @samp{r1} を示します。

@samp{<rev>^-[<n>]} 表記には @samp{<rev>} が含まれますが、 <n> 番目の親(つまり、 @samp{<rev>^<n>..<rev>} の省略形)は除外されます。 <n> が指定されていない場合は @samp{<n>} = 1 とみなします。これは通常、 @samp{<commit>^-} を渡すだけで、マージコミット @samp{<commit>}(@samp{<commit>} 自体を含む)でマージされたブランチ内のすべてのコミットを取得できるマージコミットに役立ちます。

@samp{<rev>^<n>} は単一のコミット親を指定することに関するものでしたが、これらの3つの表記はその親も考慮します。たとえば、 @samp{HEAD^2^@@} と言うことはできますが、 @samp{HEAD^@@^2} と言うことはできません。

@noindent

@chapheading Revision Range Summary

@table @asis

@item  @samp{<rev>} 
<rev> から到達可能なコミット(つまり <rev> とその祖先)を含めます。

@item  @samp{^<rev>} 
<rev> から到達可能なコミット(つまり <rev> とその祖先)を除外します。

@item  @samp{<rev1>..<rev2>} 
<rev2> から到達可能なコミットを含めますが、 <rev1> から到達可能なコミットは除外します。 <rev1> または <rev2> のいずれかを省略すると、それらはそれぞれデフォルトで @samp{HEAD} になります。

@item  @samp{<rev1>...<rev2>} 
<rev1> または <rev2> のいずれかから到達可能なコミットを含めますが、両方から到達可能なコミットは除外します。 <rev1> または <rev2> のいずれかを省略すると、それらはそれぞれデフォルトで @samp{HEAD} になります。

@item  @samp{<rev>^@@} 例: @samp{HEAD^@@} 
接尾辞 @samp{^} の後にアットマーク(@samp{@@})を付けることは、 @samp{<rev>} のすべての親をリストすることと同じです(つまり、親から到達可能なものはすべて含まれますが、コミット自体は含まれません)。

@item  @samp{<rev>^!} 例: @samp{HEAD^!} 
A suffix @emph{^} followed by an exclamation mark is the same as giving commit @emph{<rev>} and all its parents prefixed with @emph{^} to exclude them (and their ancestors).

@item  @samp{<rev>^-<n>} 例: @samp{HEAD^-, HEAD^-2} 
@samp{<rev>^<n>..<rev>} と同等であり、 @samp{<n>} が指定されていない場合は @samp{<n>} = 1 です。
@end table

上記のLoeliger図解を使用したいくつかの例を以下に示します。表記の拡張と選択は、それぞれ段階が分かるようステップを踏んで説明してあります:

@example
   Args   Expanded arguments    Selected commits
   D                            G H D
   D F                          G H I J D F
   ^G D                         H D
   ^D B                         E I J F B
   ^D B C                       E I J F B C
   C                            I J F C
   B..C   = ^B C                C
   B...C  = B ^F C              G H D E B C
   B^-    = B^..B
          = ^B^1 B              E I J F B
   C^@@    = C^1
          = F                   I J F
   B^@@    = B^1 B^2 B^3
          = D E F               D G H E F I J
   C^!    = C ^C^@@
          = C ^C^1
          = C ^F                C
   B^!    = B ^B^@@
          = B ^B^1 ^B^2 ^B^3
          = B ^D ^E ^F          B
   F^! D  = F ^I ^J D           G H D F
@end example

@noindent

@chapheading SEE ALSO

git-rev-parse(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitsubmodules,,,Top
@chapheading Name

gitsubmodules — あるリポジトリを別のリポジトリ内にマウントする

@noindent

@chapheading Synopsis

@example
.gitmodules, $GIT_DIR/config
@end example

@example
git submodule
git <command> --recurse-submodules
@end example


@noindent

@chapheading DESCRIPTION

サブモジュール(submodule)は、別のリポジトリ内に埋め込まれたリポジトリです。サブモジュールにはサブモジュール独自の履歴があります。 それが埋め込まれているリポジトリはスーパープロジェクト(superproject)と呼ばれます。

ファイルシステムでは、サブモジュールは通常(常にではありませんが。以下のFORMSを参照)、(i)スーパープロジェクトの @samp{$GIT_DIR/modules/} ディレクトリの下にあるGitディレクトリや、(ii)スーパープロジェクトの作業ディレクトリ内の作業ディレクトリや、(i)の指すサブモジュールの作業ディレクトリのルートにある @samp{.git} ファイルで構成されます。

サブモジュールのGitディレクトリが @samp{$GIT_DIR/modules/foo/} にあり、作業ディレクトリが @samp{path/to/bar/} にあるとすると、スーパープロジェクトは、ツリーの @samp{path/to/bar} にある @samp{gitlink} エントリと、@samp{submodule.foo.path = path/to/bar} 形式の @samp{.gitmodules} ファイル(linkgit: gitmodules[5] を参照)のエントリを介してサブモジュールを追跡します。

@samp{gitlink} エントリには、スーパープロジェクトがサブモジュールの作業ディレクトリにあると予想するコミットのオブジェクト名が含まれています。

@samp{.gitmodules} ファイルのセクション @samp{submodule.foo.*} は、Gitの磁器レイヤーに追加のヒントを提供します。 たとえば、 @samp{submodule.foo.url} 設定は、サブモジュールを取得する場所を指定します。

サブモジュールは、少なくとも2つの異なるユースケースに使用できます:

@enumerate 

@item
独立した履歴を維持しながら別のプロジェクトを使用。サブモジュールを使用すると、両方のプロジェクトの履歴を分離したまま、あなた独自の作業ツリー内に別のプロジェクトの作業ツリーを含めることができます。また、サブモジュールは任意のバージョンに固定できるため、別のプロジェクトは、スーパープロジェクトに影響を与えることなく独立して開発でき、スーパープロジェクトプロジェクトが必要とした場合にのみ別プロジェクトを新しいバージョンに固定できます。

@item
(論理的に単一の)プロジェクトを複数のリポジトリに分割し、それらを結び付けます。これを使用して、Gitの実装の現在の制限を克服し、よりきめ細かいアクセスを実現できます:

@table @asis

@item  Gitリポジトリのサイズ 
現在の形式では、
Gitは、ツリー間のデルタ計算によって圧縮されていないコンテンツを含む大規模なリポジトリではスケールアップが十分にできません。
たとえば、あなたはサブモジュールを使用して大きなバイナリアセットを保持し、
これらのリポジトリを浅く複製して、
ローカルに大きな履歴がないようにすることができます。

@item  転送サイズ 
現在の形式では、Gitは作業ツリー全体が存在する必要があります。
部分的なツリーをフェッチまたはクローンで転送することはできません。
あなたが作業しているプロジェクトが、
スーパープロジェクトのサブモジュールとして結合された複数のリポジトリで構成されている場合は、
関心のないリポジトリの作業ツリーをフェッチすることを回避できます。

@item  アクセス制御 
サブモジュールへのユーザーアクセスを制限することにより、
さまざまなユーザーの読み取り/書き込みポリシーを実装できます。
@end table
@end enumerate

@noindent

@chapheading The configuration of submodules

サブモジュール操作は、以下のメカニズムを使用して構成(configure)できます(優先順位の高い順です):

@itemize 

@item
パススペックの一部としてサブモジュールを使用することをサポートするコマンドのコマンドライン。 ほとんどのコマンドには、サブモジュールに再帰するかどうかを指定するブールフラグ @samp{--recurse-submodules} があります。 例としては、 @samp{grep} や @samp{checkout} があります。 @samp{fetch} や @samp{push} などの一部のコマンドは、サブモジュールがどのように影響を受けるかを指定できる列挙型を取ります。

@item
サブモジュール内の構成。 これには、サブモジュール内の @samp{$GIT_DIR/config} だけでなく、サブモジュール内のコマンドの動作を指定する @samp{.gitattributes} または @samp{.gitignore} ファイルなどのツリー内の設定も含まれます。

たとえば、スーパープロジェクトで @samp{git status --ignore-submodules=none} を実行すると、サブモジュールの @samp{.gitignore} ファイルの効果が確認できます。これは、サブモジュールの @samp{.gitignore} ファイルに注意を払いながらサブモジュールで @samp{status} を実行することにより、サブモジュールの作業ディレクトリから情報を収集します。

サブモジュールの @samp{$GIT_DIR/config} ファイルは、スーパープロジェクトで @samp{git push --recurse-submodules=check} を実行すると機能します。これは、サブモジュールにリモートに公開されていない変更があるかどうかをチェックするためです。リモートは、通常どおりサブモジュールの @samp{$GIT_DIR/config} ファイルで構成されます。

@item
スーパープロジェクトの構成ファイル @samp{$GIT_DIR/config} 。Gitはアクティブなサブモジュールのみ再帰します(以下の「ACTIVE SUBMODULES」セクションを参照)。

サブモジュールがまだ初期化されていない場合、サブモジュール内の構成(configuration)はまだ存在しないため、たとえば、サブモジュールを取得する場所はここで構成されます。

@item
スーパープロジェクト内の @samp{.gitmodules} ファイル。プロジェクトは通常、このファイルを使用して、サブモジュールの名前とパスの間に必要なマッピングについて、上流のリポジトリコレクションのデフォルトを提案します。

このファイルは主に、スーパープロジェクト内のサブモジュールの名前とパスの間のマッピングとして機能し、サブモジュールのGitディレクトリを見つけることができます。

サブモジュールが初期化されていない場合、これはサブモジュール構成が見つかる唯一の場所です。 これは、サブモジュールを取得する場所を指定するための最後のフォールバックとして機能します。
@end itemize

@noindent

@chapheading FORMS

サブモジュールは以下の形式をとることができます:

DESCRIPTIONで説明されている、Gitディレクトリと、作業ディレクトリと、 @samp{gitlink} と、 `.gitmodules`エントリ、を含む基本形式。

「古い形式」のサブモジュール: @samp{.git} ディレクトリが埋め込まれた作業ディレクトリと、スーパープロジェクトの @samp{gitlink} および @samp{.gitmodules} エントリの追跡。 これは通常、古いバージョンのGitを使用して生成されたリポジトリにあります。

+
これらの古い形式のリポジトリを手動で構築することは可能です。

+
非初期化(deinitialized)または削除されると(以下を参照)、サブモジュールのGitディレクトリはスーパープロジェクトの @samp{$GIT_DIR/modules/<name>/} に自動的に移動されます。

非初期化された(deinitialized)サブモジュール: @samp{gitlink} と @samp{.gitmodules} エントリがありますが、サブモジュールの作業ディレクトリはありません。サブモジュールのGitディレクトリは、Gitディレクトリを初期化解除した後も保持されているため、そこにある可能性があります。 代わりに、作業ディレクトリであるはずのディレクトリが空になります。

+
サブモジュールは、 @samp{git submodule deinit} を実行することで非初期化(deinitialized)できます。このコマンドは、作業ディレクトリを空にするだけでなく、スーパープロジェクトの @samp{$GIT_DIR/config} ファイルのみを変更するため、スーパープロジェクトの履歴は影響を受けません。 これは、 @samp{git submodule init} を使用して元に戻すことができます。

削除されたサブモジュール: サブモジュールは、 @samp{git rm <submodule path> && git commit} を実行することで削除できます。これは、 @samp{git revert} を使用して元に戻すことができます。

+
削除すると、スーパープロジェクトの追跡データが削除されます。これは、 @samp{gitlink} エントリと @samp{.gitmodules} ファイルのセクションの両方です。サブモジュールの作業ディレクトリはファイルシステムから削除されますが、Gitディレクトリは、別のリポジトリからフェッチすることなく過去のコミットをチェックアウトできるようにするために保持されます。

+
サブモジュールを完全に削除するには、手動で @samp{$GIT_DIR/modules/<name>/} を削除します。

@noindent

@chapheading ACTIVE SUBMODULES

サブモジュールがアクティブと見なされるには、

@enumerate 

@item
if @samp{submodule.<name>.active} が @samp{true} に設定されている

or

@item
if サブモジュールのパスが @samp{submodule.active} のパススペックと一致する

or

@item
if @samp{submodule.<name>.url} が設定されている
@end enumerate

これらは上記の順序で評価されます。

例:

@example
  [submodule "foo"]
    active = false
    url = https://example.org/foo
  [submodule "bar"]
    active = true
    url = https://example.org/bar
  [submodule "baz"]
    url = https://example.org/baz
@end example


上記の構成では、サブモジュール @samp{bar} と @samp{baz} のみがアクティブになります。 @samp{bar} は上記(1)により、 @samp{baz} は上記(3)によりアクティブになります。 (1)が(3)よりも優先されるため、 @samp{foo} は非アクティブです。

上記(1)と(2)でサブモジュールがアクティブでないことを指定している場合は、(3)は歴史的遺物であり、無視されることに注意してください。 つまり、 @samp{submodule.<name>.active} が @samp{false} に設定されている場合、またはサブモジュールのパスが @samp{submodule.active} のパススペックで除外されている場合、URLは存在するかどうかは関係ありません。これを以下の例に示します。

@example
  [submodule "foo"]
    active = true
    url = https://example.org/foo
  [submodule "bar"]
    url = https://example.org/bar
  [submodule "baz"]
    url = https://example.org/baz
  [submodule "bob"]
    ignore = true
  [submodule]
    active = b*
    active = :(exclude) baz
@end example


ここでは、 baz を除くすべてのサブモジュール(foo、bar、bob)がアクティブになっています。 foo はそれ自体のアクティブフラグによるものであり、他のすべては submodule active パススペック によるものです。これは、 .url フィールドの存在に関係なく、baz を除く @samp{b} で始まるすべてのサブモジュールもアクティブであることを指定します。

@noindent

@chapheading Workflow for a third party library

@example
  # サブモジュールの追加
  git submodule add <URL> <path>

  # ときどきサブモジュールを新しいバージョンに更新します:
  git -C <path> checkout <new version>
  git add <path>
  git commit -m "update submodule to new version"

  # スーパープロジェクト内でサブモジュールのリストを表示します
  git submodule status

  # サブモジュールの削除については、「FORMS」を参照してください
@end example


@noindent

@chapheading Workflow for an artificially split repo

@example
  # 関連するコマンドの再帰(recursion)を有効にし、
  # 対象のコマンドがデフォルトでサブモジュールで再帰処理するようにします
  git config --global submodule.recurse true

  # 他のほとんどのコマンドとは異なり、
  # cloneには独自の再帰フラグが必要です:
  git clone --recurse <URL> <directory>
  cd <directory>

  # (ソース)コードを知る為に取得する
  git grep foo
  git ls-files --recurse-submodules
@end example


@quotation

@strong{Note}

@samp{git ls-files} もまた、それ独自の @samp{--recurse-submodules} フラグが必要です。
@end quotation

@example
  # 新しいコードを得る
  git fetch
  git pull --rebase

  # 作業ツリーの変更
  git checkout
  git reset
@end example


@noindent

@chapheading Implementation details

サブモジュールを含むリポジトリのクローンを作成またはプルする場合、デフォルトではサブモジュールはチェックアウトされません。クローンにサブモジュールに再帰するように指示できます。 @samp{git submodule} の @samp{init} および @samp{update} サブコマンドは、チェックアウトされたサブモジュールを維持し、作業ツリーの適切なリビジョンに維持します。 または、 @samp{submodule.recurse} を設定して @samp{checkout} をサブモジュールに再帰させることもできます( @samp{submodule.recurse} は他のGitコマンドにも影響することに注意してください。完全なリストについてはgit-config(1) を参照してください)。

@noindent

@chapheading SEE ALSO

git-submodule(1), gitmodules(5).

@noindent

@chapheading GIT

Part of the git(1) suite

@node gittutorial-2,,,Top
@chapheading Name

gittutorial-2 — Git入門パート2

@noindent

@chapheading Synopsis

@display
git *
@end display


@noindent

@chapheading DESCRIPTION

このGit入門パート2を読む前に、 gittutorial(7) (Git入門)を読んで下さい。

この入門の目的は、Gitのアーキテクチャの2つの基本的な部分(オブジェクトデータベースとインデックスファイル)を紹介し、残りのGit文書を理解するために必要なすべてのものを読者に提供することです。

@noindent

@chapheading The Git object database

新しいプロジェクトを開始して、履歴を少々作成しましょう:

@example
$ mkdir test-project
$ cd test-project
$ git init
Initialized empty Git repository in .git/
$ echo 'hello world' > file.txt
$ git add .
$ git commit -a -m "initial commit"
[master (root-commit) 54196cc] initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 file.txt
$ echo 'hello world!' >file.txt
$ git commit -a -m "add emphasis"
[master c4d59f3] add emphasis
 1 file changed, 1 insertion(+), 1 deletion(-)
@end example


さて、ここで、Gitがコミットで返してきた7桁の16進数は一体何でしょうか？

入門のパート1で、コミットには名前が付いていることがわかりました。Git履歴内のすべてのオブジェクトは、40桁の16進名で保存されていることがわかりました。その名前は、オブジェクトの内容のSHA-1ハッシュです。特に、これにより、Gitが同じデータを2回保存することはなく(同一のデータには同一のSHA-1名が付けられるため)、Gitオブジェクトの内容が変更されることはありません(オブジェクトの名前も変更されるため)。ここでの7文字の16進文字列は、このような40文字の長さの文字列の略語です。 略語は、明確である限り(訳注:その環境で一意になる限り)、40文字の16進文字列を使用できるすべての場所で使用できます。

上記の例に従って作成したコミットオブジェクトのコンテンツは、コミットオブジェクトが作成された時刻とコミットを実行した人の名前を記録するため、上記とは異なるSHA-1ハッシュを生成することが期待されます。

@samp{cat-file} コマンドを使用して、この特定のオブジェクトについてGitに問い合わせることができます。上記の例から40桁の16進数をコピーするのではなく、あなたの手元で実行したバージョンの16進数を使用してください。40桁すべての16進数を入力する手間を省くために、数文字に短縮できることに注目です:

@example
$ git cat-file -t 54196cc2
commit
$ git cat-file commit 54196cc2
tree 92b8b694ffb1675e5975148e1121810081dbdffe
author J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143414668 -0500
committer J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143414668 -0500

initial commit
@end example


ツリーは、それぞれがファイルに対応する、1つ以上のブロブ(blob)オブジェクトを参照できます。さらに、ツリーは他のツリーオブジェクトを参照することもできるため、ディレクトリ階層が作成されます。 ls-tree を使用して任意のツリーの内容を調べることができます(その際、SHA-1の最初の部分を指定するだけで十分なことを忘れないでください)。

@example
$ git ls-tree 92b8b694
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    file.txt
@end example


これで、このツリーには1つのファイルが含まれていることがわかります。SHA-1ハッシュは、そのファイルのデータへの参照(reference)です:

@example
$ git cat-file -t 3b18e512
blob
@end example


「blob」は単なるファイルデータであり、cat-fileで調べることもできます:

@example
$ git cat-file blob 3b18e512
hello world
@end example


注意: これは古いファイルデータであることに注意してください。つまり、Gitが最初のツリーに対する応答で名付けたオブジェクトは、最初のコミットで記録されたディレクトリ状態のスナップショットを持つツリーです。

これらのオブジェクトはすべて、Gitディレクトリ内部にSHA-1名で保存されます:

@example
$ find .git/objects/
.git/objects/
.git/objects/pack
.git/objects/info
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/92
.git/objects/92/b8b694ffb1675e5975148e1121810081dbdffe
.git/objects/54
.git/objects/54/196cc2703dc165cbd373a65a4dcf22d50ae7f7
.git/objects/a0
.git/objects/a0/423896973644771497bdc03eb99d5281615b51
.git/objects/d0
.git/objects/d0/492b368b66bdabf2ac1fd8c92b39d3db916e59
.git/objects/c4
.git/objects/c4/d59f390b9cfd4318117afde11d601c1085f241
@end example


そして、これらのファイルの内容は、圧縮されたデータに加えて、ファイルの長さとタイプを識別するヘッダーだけです。 タイプは、blob、tree、commit、tag のいずれかです。

見つけるのが最も簡単なコミットはHEADコミットで、これは .git/HEAD から見つけることができます:

@example
$ cat .git/HEAD
ref: refs/heads/master
@end example


ご覧のとおり、これにより、現在どのブランチを使用しているかがわかります。 @samp{.git} ディレクトリの下にあるファイルに名前を付ける事でこれを私達に知らせます。このディレクトリ自体には、コミットオブジェクトを参照するSHA-1名が含まれていて、 cat-file で調べることができます:

@example
$ cat .git/refs/heads/master
c4d59f390b9cfd4318117afde11d601c1085f241
$ git cat-file -t c4d59f39
commit
$ git cat-file commit c4d59f39
tree d0492b368b66bdabf2ac1fd8c92b39d3db916e59
parent 54196cc2703dc165cbd373a65a4dcf22d50ae7f7
author J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143418702 -0500
committer J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143418702 -0500

add emphasis
@end example


ここでの「tree」オブジェクトは、ツリーの新しい状態を指します:

@example
$ git ls-tree d0492b36
100644 blob a0423896973644771497bdc03eb99d5281615b51    file.txt
$ git cat-file blob a0423896
hello world!
@end example


そして「親」オブジェクトは前のコミットを参照します:

@example
$ git cat-file commit 54196cc2
tree 92b8b694ffb1675e5975148e1121810081dbdffe
author J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143414668 -0500
committer J. Bruce Fields <bfields@@puzzle.fieldses.org> 1143414668 -0500

initial commit
@end example


そのツリーオブジェクトは最初に調べたツリーであり、このコミットには親がないという点でレアです。

多くのコミットでは親が1つしかないですが、
複数の親を持つコミットも割とあります。
その場合、コミットはマージを表し、
親参照はマージされたブランチのヘッドを指します。

ブロブ・ツリー・コミット以外に残っているオブジェクトのタイプは「タグ」だけです。これについてはここでは説明しません。 詳細については、 git-tag(1) を参照してください。

これで、Gitがオブジェクトデータベースを使用してプロジェクトの履歴を表す方法がわかりました:

@itemize 

@item
「コミット」オブジェクトは、履歴の特定のポイントでのディレクトリツリーのスナップショットを表す「ツリー」オブジェクトを指し、「親」コミットを、プロジェクト履歴にどのように接続されているかを示すために参照します。

@item
「ツリー」オブジェクトは単一のディレクトリの状態を表し、ディレクトリ名をファイルデータを含む「ブロブ」オブジェクトとサブディレクトリ情報を含む「ツリー」オブジェクトに関連付けます。

@item
「ブロブ」オブジェクトには、他の構造でないファイルデータが含まれています。

@item
各ブランチのヘッドにあるコミットオブジェクトへの参照は、 .git/refs/heads/ の下のファイルに保存されます。

@item
現在のブランチの名前は .git/HEAD に保存されます。
@end itemize

注意: ちなみに、多くのコマンドは引数としてツリーを使用することに注意してください。 しかし、上で見ることができるように、ツリーは多くの異なる方法(そのツリーのSHA-1名、そのツリーを参照するコミットの名前、そのツリーを参照するヘッドを持つブランチの名前など)で参照できます。そのツリーのSHA-1名、ツリーを参照するコミットの名前、ヘッドが参照するブランチの名前 そのツリーなどに-そしてそのようなコマンドのほとんどはこれらの名前のいずれかを受け入れることができます。

コマンドの概要では、「tree-ish」(ツリーっぽい)という単語がそのような引数を示すために使用されることがあります。

@noindent

@chapheading The index file

コミットを作成するために使用している主なツールは @samp{git-commit -a} です。これは、作業ツリーに加えたすべての変更を含むコミットを作成します。しかし、特定のファイルの変更のみをコミットしたい場合はどうでしょうか？ または、特定のファイルの特定(一部の)の変更のみをコミットしたい場合はどうでしょうか？

コミット作成の秘密を知れば、コミットを作成するより柔軟な方法があることがわかります。

我々のテストプロジェクトを続けて、file.txt を再び変更しましょう:

@example
$ echo "hello world, again" >>file.txt
@end example


しかし、今回はすぐにコミットするのではなく、中間のステップを踏んで、何が起こっているかを追跡するために途中でdiffを要求しましょう:

@example
$ git diff
--- a/file.txt
+++ b/file.txt
@@@@ -1 +1,2 @@@@
 hello world!
+hello world, again
$ git add file.txt
$ git diff
@end example


最後の差分は空ですが、新しいコミットは行われておらず、ヘッドにはまだ新しい行が含まれていないからです:

@example
$ git diff HEAD
diff --git a/file.txt b/file.txt
index a042389..513feba 100644
--- a/file.txt
+++ b/file.txt
@@@@ -1 +1,2 @@@@
 hello world!
+hello world, again
@end example


つまり、「git diff」はヘッド以外のものと比較しているのです。比較しているのは、実際にはインデックスファイルです。これはバイナリ形式で .git/index に保存されていますが、その内容はls-filesで調べることができます:

@example
$ git ls-files --stage
100644 513feba2e53ebbd2532419ded848ba19de88ba00 0       file.txt
$ git cat-file -t 513feba2
blob
$ git cat-file blob 513feba2
hello world!
hello world, again
@end example


したがって、「git add」が行ったことは、新しいブロブを格納し、それへの参照をインデックスファイルに配置することでした。ファイルを再度変更すると、新しい変更が「git diff」出力に反映されていることがわかります:

@example
$ echo 'again?' >>file.txt
$ git diff
index 513feba..ba3da7b 100644
--- a/file.txt
+++ b/file.txt
@@@@ -1,2 +1,3 @@@@
 hello world!
 hello world, again
+again?
@end example


正しい引数を使用すると、 @emph{git diff} は、作業ディレクトリと最後のコミットの違い、またはインデックスと最後のコミットの違いを示すこともできます:

@example
$ git diff HEAD
diff --git a/file.txt b/file.txt
index a042389..ba3da7b 100644
--- a/file.txt
+++ b/file.txt
@@@@ -1 +1,3 @@@@
 hello world!
+hello world, again
+again?
$ git diff --cached
diff --git a/file.txt b/file.txt
index a042389..513feba 100644
--- a/file.txt
+++ b/file.txt
@@@@ -1 +1,2 @@@@
 hello world!
+hello world, again
@end example


何度でも私達は「git commit」( @samp{-a} オプションなし）を使用して新しいコミットを作成することができ、コミットされた状態にはインデックスファイルに保存されている変更のみが含まれ、作業ツリーにのみ残っている追加の変更が含まれていないことを確認できます:

@example
$ git commit -m "repeat"
$ git diff HEAD
diff --git a/file.txt b/file.txt
index 513feba..ba3da7b 100644
--- a/file.txt
+++ b/file.txt
@@@@ -1,2 +1,3 @@@@
 hello world!
 hello world, again
+again?
@end example


つまり、デフォルトでは、「git commit」は、作業ツリーではなく、インデックスを使用してコミットを作成します。 コミットでの @samp{-a} オプションの指定は、最初に作業ツリーのすべての変更をインデックスに反映するように指示します。

最後に、インデックスファイルに対する「git add」の効果を確認しておきましょう:

@example
$ echo "goodbye, world" >closing.txt
$ git add closing.txt
@end example


@emph{git add} の効果は、インデックスファイルに1つのエントリを追加することでした:

@example
$ git ls-files --stage
100644 8b9743b20d4b15be3955fc8d5cd2b09cd2336138 0       closing.txt
100644 513feba2e53ebbd2532419ded848ba19de88ba00 0       file.txt
@end example


そして、 cat-file でわかるように、この新しいエントリはファイルの現在の内容を参照しています:

@example
$ git cat-file blob 8b9743b2
goodbye, world
@end example


「status」コマンドは、状況の概要をすばやく取得するための便利な方法です:

@example
$ git status
ブランチ master
コミット予定の変更点:
  (use "git restore --staged <file>..." to unstage)

        new file:   closing.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)

        modified:   file.txt
@end example


closeing.txtの現在の状態はインデックスファイルにキャッシュされているため、「コミット予定の変更点」(Changes to be committed)としてリストされます。 file.txtには、インデックスに反映されていない作業ディレクトリの変更があるため、「Changes not staged for commit」とマークされています。 この時点で、「git commit」を実行すると、（新しいコンテンツを含む)closeing.txtが追加されたコミットが作成されますが、file.txtは変更されませんでした。

また、裸の @samp{git diff} はfile.txtへの変更を示しますが、closeing.txtの追加は示しません。これは、インデックスファイルのcloseing.txtのバージョンが作業ディレクトリのバージョンと同じであるためです。

インデックスファイルは、新しいコミットのステージング領域であることに加えて、ブランチをチェックアウトするときにオブジェクトデータベースからも入力され、マージ操作に関係するツリーを保持するためにも使用されます。詳細については、 gitcore-tutorial(7) および関連するマニュアルページを参照してください。

@noindent

@chapheading What next?

この期に及んでは、あなたはgitコマンドのマニュアルページを読むために必要なすべてを知っている必要があります。それを始めるのに適した場所の1つは、 giteveryday(7) に記載されているコマンドを使用することです。また、あなたは gitglossary(7) で不明な専門用語を調べる事もできます。

@uref{user-manual.html,Git User’s Manual} は、Gitのより包括的な紹介を提供します。

gitcvs-migration(7) は、CVSリポジトリをGitにインポートする方法を説明し、CVSのような方法でGitを使用する方法を示しています。

Gitの使用に関する興味深い例については、 @uref{howto-index.html,howtos} を参照してください。

Git開発者向けに、 gitcore-tutorial(7) で、新しいコミットの作成などに関連する低レベルのGitメカニズムについて詳しく説明しています。

@noindent

@chapheading SEE ALSO

gittutorial(7), gitcvs-migration(7), gitcore-tutorial(7), gitglossary(7), git-help(1), giteveryday(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gittutorial,,,Top
@chapheading Name

gittutorial — Git入門

@noindent

@chapheading Synopsis

@display
git *
@end display


@noindent

@chapheading DESCRIPTION

このチュートリアルでは、新しいプロジェクトをGitにインポートし、変更を加え、他の開発者と変更を共有する方法について説明します。

Gitを使用してプロジェクトをフェッチする方に主な関心がある場合、たとえば、最新バージョンをテストする場合は、 @uref{user-manual.html,The Git User’s Manual} の最初の2つの章から始めることをお勧めします。

注意: まず最初に、 あなたは @samp{git log --graph} などのコマンドの文書を以下のようにして入手する事ができます:

@example
$ man git-log
@end example


または:

@example
$ git help log
@end example


後者では。あなたが選択したマニュアルビューアを使用できます。詳細については git-help(1) を参照してください。

操作を行う前に、名前と公開メールアドレスを使用してあなた自身をGitに紹介する(introduce yourself)ことをお勧めします。これを行う最も簡単な方法は以下のとおりです:

@example
$ git config --global user.name "Your Name Comes Here"
$ git config --global user.email you@@yourdomain.example.com
@end example


@noindent

@chapheading Importing a new project

Assume you have a tarball @samp{project.tar.gz} with your initial work. You can place it under Git revision control as follows.

@example
$ tar xzf project.tar.gz
$ cd project
$ git init
@end example


Gitは以下のメッセージを返すでしょう

@example
Initialized empty Git repository in .git/
@end example


You’ve now initialized the working directory—you may notice a new directory created, named @samp{.git}.

Next, tell Git to take a snapshot of the contents of all files under the current directory (note the @samp{.}), with @samp{git add}:

@example
$ git add .
@end example


This snapshot is now stored in a temporary staging area which Git calls the "index". You can permanently store the contents of the index in the repository with @samp{git commit}:

@example
$ git commit
@end example


これにより、コミットメッセージの入力を求められます。 これで、プロジェクトの最初のバージョンがGitに保存されました。

@noindent

@chapheading Making changes

いくつかのファイルを変更してから、更新された内容をインデックスに追加します:

@example
$ git add file1 file2 file3
@end example


You are now ready to commit. You can see what is about to be committed using @samp{git diff} with the @samp{--cached} option:

@example
$ git diff --cached
@end example


(Without @samp{--cached}, @samp{git diff} will show you any changes that you’ve made but not yet added to the index.) You can also get a brief summary of the situation with @samp{git status}:

@example
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

        modified:   file1
        modified:   file2
        modified:   file3
@end example


さらに調整が必要な場合は、ここで調整してから、新しく変更したコンテンツをインデックスに追加します。 最後に、以下のコマンドであなたの変更をコミットします。

@example
$ git commit
@end example


これにより、変更を説明するメッセージの入力を再度求められ、プロジェクトの新しいバージョンが記録されます。

Alternatively, instead of running @samp{git add} beforehand, you can use

@example
$ git commit -a
@end example


これにより、変更された(ただし新規ではない)ファイルが自動的に認識され、それらがインデックスに追加され、コミットされます。それらがすべて1つのステップで実行されます。

コミットメッセージに関する注意: 必須ではありませんが、コミットメッセージは、変更を要約した1行の短い(50文字未満)行で始まり、空行が1行あり、その後にさらに詳細な説明が続くようにすることをお勧めします。コミットメッセージの最初の空白行までのテキストはコミットタイトルとして扱われ、そのタイトルはGit全体で使用されます。たとえば、 git-format-patch(1) はコミットを電子メールに変換し、件名としてコミットタイトル、本文として残りのコミットメッセージを使用します。

@noindent

@chapheading Git tracks content not files

Many revision control systems provide an @samp{add} command that tells the system to start tracking changes to a new file. Git’s @samp{add} command does something simpler and more powerful: @samp{git add} is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.

@noindent

@chapheading Viewing project history

あなたはいつでも、以下を使用して変更の履歴を表示できます

@example
$ git log
@end example


あなたが各ステップで完全な差分も表示したい場合は、以下を使用してください

@example
$ git log -p
@end example


多くの場合、以下のような変更の概要は、各ステップの感触をつかむのに役立ちます

@example
$ git log --stat --summary
@end example


@noindent

@chapheading Managing branches

A single Git repository can maintain multiple branches of development. To create a new branch named @samp{experimental}, use

@example
$ git branch experimental
@end example


そして、以下のようにすることができます

@example
$ git branch
@end example


そうすると、既存のすべてのブランチのリストが表示されます。

@example
  experimental
* master
@end example


The @samp{experimental} branch is the one you just created, and the @samp{master} branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type

@example
$ git switch experimental
@end example


to switch to the @samp{experimental} branch. Now edit a file, commit the change, and switch back to the @samp{master} branch:

@example
(edit file)
$ git commit -a
$ git switch master
@end example


Check that the change you made is no longer visible, since it was made on the @samp{experimental} branch and you’re back on the @samp{master} branch.

You can make a different change on the @samp{master} branch:

@example
(edit file)
$ git commit -a
@end example


at this point the two branches have diverged, with different changes made in each. To merge the changes made in @samp{experimental} into @samp{master}, run

@example
$ git merge experimental
@end example


変更が競合しない場合は、これで完了です。 競合がある場合、競合を示すマーカーが問題のあるファイルに残されます。

@example
$ git diff
@end example


とすると、これを表示します。あなたが競合を解決するためにファイルを編集したら

@example
$ git commit -a
@end example


とすると、マージの結果をコミットします。そして最後に、

@example
$ gitk
@end example


とすると、結果の履歴の優れたグラフィック表現が表示されます。

At this point you could delete the @samp{experimental} branch with

@example
$ git branch -d experimental
@end example


This command ensures that the changes in the @samp{experimental} branch are already in the current branch.

If you develop on a branch @samp{crazy-idea}, then regret it, you can always delete the branch with

@example
$ git branch -D crazy-idea
@end example


ブランチのコストは安くて、かつ操作は簡単なので、これは何かを一時的に試す良い方法です。

@noindent

@chapheading Using Git for collaboration

Suppose that Alice has started a new project with a Git repository in @samp{/home/alice/project}, and that Bob, who has a home directory on the same machine, wants to contribute.

ボブは以下のように始めます:

@example
bob$ git clone /home/alice/project myrepo
@end example


This creates a new directory @samp{myrepo} containing a clone of Alice’s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project’s history.

次に、ボブはいくつかの変更を加えてコミットします:

@example
(edit files)
bob$ git commit -a
(repeat as necessary)
@end example


When he’s ready, he tells Alice to pull changes from the repository at @samp{/home/bob/myrepo}. She does this with:

@example
alice$ cd /home/alice/project
alice$ git pull /home/bob/myrepo master
@end example


This merges the changes from Bob’s @samp{master} branch into Alice’s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.

The @samp{pull} command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.

Note that in general, Alice would want her local changes committed before initiating this @samp{pull}. If Bob’s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge — Alice will have to get rid of her local changes in some way and pull again when this happens).

Alice can peek at what Bob did without merging first, using the @samp{fetch} command; this allows Alice to inspect what Bob did, using a special symbol @samp{FETCH_HEAD}, in order to determine if he has anything worth pulling, like this:

@example
alice$ git fetch /home/bob/myrepo master
alice$ git log -p HEAD..FETCH_HEAD
@end example


This operation is safe even if Alice has uncommitted local changes. The range notation @samp{HEAD..FETCH_HEAD} means "show everything that is reachable from the @samp{FETCH_HEAD} but exclude anything that is reachable from @samp{HEAD}". Alice already knows everything that leads to her current state (@samp{HEAD}), and reviews what Bob has in his state (@samp{FETCH_HEAD}) that she has not seen with this command.

アリスが、ボブとの履歴が分岐してから何をしたかを視覚化したい場合は、以下のコマンドを実行できます:

@example
$ gitk HEAD..FETCH_HEAD
@end example


This uses the same two-dot range notation we saw earlier with @samp{git log}.

アリスは、フォークして以来、アリスとボブの両方が何をしたかを見たいと思うかもしれません。その場合、アリスはは2ドット形式の代わりに3ドット形式を使用できます:

@example
$ gitk HEAD...FETCH_HEAD
@end example


これは、「どちらか一方から到達可能なものはすべて表示し、両方から到達可能なものはすべて除外する」ことを意味します。

Please note that these range notation can be used with both @samp{gitk} and @samp{git log}.

After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob’s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a @samp{pull}, and then finally unstash her work-in-progress on top of the resulting history.

小さな緊密なグループで作業している場合、同じリポジトリを何度も操作することは珍しくありません。リモートリポジトリの省略形を定義すると、作業は以下のように簡単になります:

@example
alice$ git remote add bob /home/bob/myrepo
@end example


With this, Alice can perform the first part of the @samp{pull} operation alone using the @samp{git fetch} command without merging them with her own branch, using:

@example
alice$ git fetch bob
@end example


Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with @samp{git remote}, what was fetched is stored in a remote-tracking branch, in this case @samp{bob/master}. So after this:

@example
alice$ git log -p master..bob/master
@end example


shows a list of all the changes that Bob made since he branched from Alice’s @samp{master} branch.

After examining those changes, Alice could merge the changes into her @samp{master} branch:

@example
alice$ git merge bob/master
@end example


この「マージ」は、以下のように「アリス自身のリモート追跡ブランチからプルする」ことによっても実行できます:

@example
alice$ git pull . remotes/bob/master
@end example


注意: コマンドラインで他に何が指定されているかに関係なく、 @samp{git pull} は常に現在のブランチにマージされることに注意してください。

その後、ボブは以下を使用してアリスの最新の変更でボブのリポジトリを更新できます

@example
bob$ git pull
@end example


注意: ボブはアリスのリポジトリへのパスを指定する必要がないことに注意してください。ボブがアリスのリポジトリのクローンを作成したとき、Gitはアリスのリポジトリの場所をリポジトリ構成に保存し、その場所がプルに使用されます。

@example
bob$ git config --get remote.origin.url
/home/alice/project
@end example


(The complete configuration created by @samp{git clone} is visible using @samp{git config -l}, and the git-config(1) man page explains the meaning of each option.)

Git also keeps a pristine copy of Alice’s @samp{master} branch under the name @samp{origin/master}:

@example
bob$ git branch -r
  origin/master
@end example


ボブが後で別のホストから作業することを決定した場合でも、sshプロトコルを使用してクローンとプルを実行できます:

@example
bob$ git clone alice.org:/home/alice/project myrepo
@end example


代わりに、Gitのネイティブプロトコルや、httpを使用できます。詳細については、 git-pull(1) を参照してください。

Gitは、さまざまなユーザーが変更をプッシュする中央リポジトリを使用して、CVSのようなモードで使用することもできます。 git-push(1) と gitcvs-migration(7) を参照してください。

@noindent

@chapheading Exploring history

Git history is represented as a series of interrelated commits. We have already seen that the @samp{git log} command can list those commits. Note that first line of each @samp{git log} entry also gives a name for the commit:

@example
$ git log
commit c82a22c39cbc32576f64f5c6b3f24b99ea8149c7
Author: Junio C Hamano <junkio@@cox.net>
Date:   Tue May 16 17:18:22 2006 -0700

    merge-base: Clarify the comments on post processing.
@end example


We can give this name to @samp{git show} to see the details about this commit.

@example
$ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7
@end example


ただし、コミットを参照する方法は他にもあります。あなたはコミットを一意に識別するのに十分な長さであれば名前の最初の部分だけを指定できます:

@example
$ git show c82a22c39c   # the first few characters of the name are
                        # usually enough
$ git show HEAD         # the tip of the current branch
$ git show experimental # the tip of the "experimental" branch
@end example


通常、あらゆるコミットには、プロジェクトの以前の状態を指す1つの「親」コミットがあります:

@example
$ git show HEAD^  # to see the parent of HEAD
$ git show HEAD^^ # to see the grandparent of HEAD
$ git show HEAD~4 # to see the great-great grandparent of HEAD
@end example


注意: マージコミットには複数の親が含まれる場合があることに注意してください:

@example
$ git show HEAD^1 # show the first parent of HEAD (same as HEAD^)
$ git show HEAD^2 # show the second parent of HEAD
@end example


コミットに独自の名前を付けることもできます。

@example
$ git tag v2.5 1b2e1d63ff
@end example


you can refer to @samp{1b2e1d63ff} by the name @samp{v2.5}. If you intend to share this name with other people (for example, to identify a release version), you should create a "tag" object, and perhaps sign it; see git-tag(1) for details.

コミットを知る必要のあるGitコマンドは、これらの名前のいずれかを指定することができます。 例えば:

@example
$ git diff v2.5 HEAD     # compare the current HEAD to v2.5
$ git branch stable v2.5 # start a new branch named "stable" based
                         # at v2.5
$ git reset --hard HEAD^ # reset your current branch and working
                         # directory to its state at HEAD^
@end example


Be careful with that last command: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don’t use @samp{git reset} on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use @samp{git revert} instead.

The @samp{git grep} command can search for strings in any version of your project, so

@example
$ git grep "hello" v2.5
@end example


searches for all occurrences of "hello" in @samp{v2.5}.

If you leave out the commit name, @samp{git grep} will search any of the files it manages in your current directory. So

@example
$ git grep "hello"
@end example


これは、Gitによって追跡されているファイルだけですばやく検索する方法です。

Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with @samp{git log}:

@example
$ git log v2.5..v2.6            # commits between v2.5 and v2.6
$ git log v2.5..                # commits since v2.5
$ git log --since="2 weeks ago" # commits from the last 2 weeks
$ git log v2.5.. Makefile       # commits since v2.5 which modify
                                # Makefile
@end example


You can also give @samp{git log} a "range" of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches @samp{stable} and @samp{master} diverged from a common commit some time ago, then

@example
$ git log stable..master
@end example


will list commits made in the @samp{master} branch but not in the stable branch, while

@example
$ git log master..stable
@end example


will show the list of commits made on the stable branch but not the @samp{master} branch.

The @samp{git log} command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which @samp{git log} presents those commits is meaningless.

Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and @samp{gitk} does a better job of visualizing their history. For example,

@example
$ gitk --since="2 weeks ago" drivers/
@end example


allows you to browse any commits from the last 2 weeks of commits that modified files under the @samp{drivers} directory. (Note: you can adjust gitk’s fonts by holding down the control key while pressing "-" or "+".)

最後に、ファイル名を取得するほとんどのコマンドでは、オプションで、ファイルの特定のバージョンを指定するために、任意のファイル名の前にコミットを付けることができます:

@example
$ git diff v2.5:Makefile HEAD:Makefile.in
@end example


You can also use @samp{git show} to see any such file:

@example
$ git show v2.5:Makefile
@end example


@noindent

@chapheading Next Steps

このチュートリアルは、プロジェクトの基本的な分散リビジョン管理を実行するのに十分なはずです。ただし、Gitの奥深さとパワーを完全に理解するには、Gitの基礎となる2つの簡単なアイデアを理解する必要があります:

@itemize 

@item
オブジェクトデータベースは、あなたのプロジェクトの履歴（ファイル、ディレクトリ、コミット）を格納するために使用されるかなり洗練されたシステムです。

@item
インデックスファイルは、ディレクトリツリーの状態のキャッシュであり、コミットの作成、作業ディレクトリのチェックアウト、およびマージに関係するさまざまなツリーの保持に使用されます。
@end itemize

このチュートリアルのパート2では、オブジェクトデータベース、インデックスファイル、およびGitを最大限に活用するために必要なその他のいくつかのガラクタについて説明します。 linkgit: gittutorial-2[7] をご覧下さい。

すぐにそれを続けたくない場合は、この時点で興味深いかもしれない他のいくつかのより道は以下のとおりです:

@itemize 

@item
git-format-patch(1) 、git-am(1): これらは一連のgitコミットを電子メールで送信されたパッチに変換します。その逆も同様です。電子メールで送信されたパッチに大きく依存するLinuxカーネルなどのプロジェクトで役立ちます。

@item
git-bisect(1): When there is a regression in your project, one way to track down the bug is by searching through the history to find the exact commit that’s to blame. @samp{git bisect} can help you perform a binary search for that commit. It is smart enough to perform a close-to-optimal search even in the case of complex non-linear history with lots of merged branches.

@item
gitworkflows(7): 推奨される作業の流れの概要を示します。

@item
giteveryday(7): 20コマンド程度で綴る日々のGit。

@item
gitcvs-migration(7): CVSユーザー向けのGit。
@end itemize

@noindent

@chapheading SEE ALSO

gittutorial-2(7), gitcvs-migration(7), gitcore-tutorial(7), gitglossary(7), git-help(1), gitworkflows(7), giteveryday(7), @uref{user-manual.html,The Git User’s Manual}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitweb.conf,,,Top
@chapheading Name

gitweb.conf — Gitweb(Git Webインターフェイス)構成ファイル

@noindent

@chapheading Synopsis

/etc/gitweb.conf, /etc/gitweb-common.conf, $GITWEBDIR/gitweb_config.perl

@noindent

@chapheading DESCRIPTION

Web上でGitリポジトリを表示するためのgitweb CGIスクリプトは、設定ファイルとしてperlスクリプト断片を使用します。 @samp{our $variable = value} を使用して変数を設定できます。 @samp{#} 文字から行末までのテキストは無視されます。 詳細については、「perlsyn(1)」を参照してください。

とある例:

@example
# gitweb configuration file for http://git.example.org
#
our $projectroot = "/srv/git"; # FHS recommendation
our $site_name = 'Example.org >> Repos';
@end example


構成ファイルは、 @samp{gitweb.cgi} スクリプトが生成されたときにgitwebに組み込み済みのデフォルト設定を上書きするために使用されます。

gitweb CGI自体の構成設定を変更することもできますが、それらの変更はアップグレード時に失われます。構成設定は、デフォルト名が @samp{gitweb_config.perl} のCGIスクリプトと同じディレクトリ内のファイルに配置される場合もあります。これにより、シンボリックリンクを使用して、構成が異なる複数のgitwebインスタンスを作成できます。

注意: 一部の構成は、gitweb全体ではなく、リポジトリごとに制御できることに注意してください。 gitweb(1)の manpage の「Per-repository gitweb configuration」サブセクションを参照してください。

@noindent

@chapheading DISCUSSION

gitwebは、以下のソースから以下の順序で構成データを読み取ります:

@itemize 

@item
組み込み値(ビルド段階で設定されるものもあります)

@item
共通のシステム全体の構成ファイル(デフォルトは @samp{/etc/gitweb-common.conf})

@item
インスタンスごとの構成ファイル(デフォルトでは、インストールされたgitwebと同じディレクトリにある @samp{gitweb_config.perl} になります)。または、存在しない場合は、システム全体の構成ファイル(デフォルトは @samp{/etc/gitweb.conf})にフォールバックします。
@end itemize

後から構成ファイルで得られた値は、上記の順序で先に得られた値を上書きします。

共通のシステム全体の構成ファイルや、フォールバックシステム全体の構成ファイルや、インスタンスごとの構成ファイルの場所は、ビルド時のMakefile構成変数、それぞれ @samp{GITWEB_CONFIG_COMMON} と @samp{GITWEB_CONFIG_SYSTEM} と @samp{GITWEB_CONFIG} を使用して定義されます。

あなたは環境変数 @samp{GITWEB_CONFIG_COMMON} と @samp{GITWEB_CONFIG_SYSTEM} と @samp{GITWEB_CONFIG} を空でない値に設定することにより、実行時にgitweb構成ファイルの場所をオーバーライドすることもできます。

構成ファイルの構文はPerlの構文です。これらのファイルは、Perlコード(gitweb自体が記述されている言語)の断片としてそれらをsourceすることによって処理されるためです。 変数は通常、 (@samp{our $variable = <value>;} のように) @samp{our} 修飾子を使用して設定され、新しいバージョンのgitwebがとある変数を使用しなくなったために、とある変数の宣言で停止(stop)する構文エラーを回避します。

あなたは read_config_file() サブルーチンを使用して、他の構成ファイルを含めることができます。たとえば、(Gitリポジトリ管理ツールの1つである)Gitoliteを介してリポジトリを表示するための、アクセス制御に関連するgitweb構成を別のファイルに入れたい場合があります。例えばそれが @samp{/etc/gitweb-gitolite.conf} にあるとすると、それを含めるには以下のようにします。

@example
read_config_file("/etc/gitweb-gitolite.conf");
@end example


これを、使用されているgitweb構成ファイルのどこか、例えばインストールごとのgitweb構成ファイルに置きます。 注意: read_config_file()は、読み取ったファイルが存在することを自分自身でチェックし、見つからない場合は何もしないことに注意してください。 また、インクルードファイルのエラーも処理します。

一部のインストールでは、構成ファイルがまったくないデフォルトの構成が完全に機能する場合があります。それでも、構成ファイルはgitwebの動作をさまざまな方法でカスタマイズまたは微調整するのに役立ち、構成可能な @samp{%features} 変数を使用して明示的に有効にしない限り、一部のオプション機能は有効になりません(以下の「Configuring gitweb features」セクションも参照)。

@noindent

@chapheading CONFIGURATION VARIABLES

設定変数の中には、gitwebのビルド時にデフォルト値が設定されるものがあります(CGIスクリプトに埋め込まれています) — その場合は、その事実を記述しています。 gitwebのビルドとインストールについては、gitwebの INSTALL ファイルを参照してください。

@noindent

@heading Location of repositories

以下で説明する構成変数は、gitwebがGitリポジトリを見つける方法、およびリポジトリが表示およびアクセスされる方法を制御します。

gitweb(1)の manpage の「Repositories」以降のサブセクションも参照してください。

@table @asis

@item  $projectroot 
プロジェクトパスの前に付加されるファイルシステム絶対パス。リポジトリへのパスは @samp{$projectroot/$project} です。 インストール時に @samp{$GITWEB_PROJECTROOT} に設定します。gitwebがリポジトリを見つけるには、この変数を正しく設定する必要があります。

たとえば、 @samp{$projectroot} が @samp{/srv/git} に設定されている場合、gitweb構成ファイルに以下のように入力します:

@example
our $projectroot = "/srv/git";
@end example


これは以下のようになります

@example
http://git.example.com/gitweb.cgi?p=foo/bar.git
@end example


そして以下はpath_infoベースの同等のものです

@example
http://git.example.com/gitweb.cgi/foo/bar.git
@end example


これはファイルシステムのパス @samp{/srv/git/foo/bar.git} にマップされます。

@item  $projects_list 
プロジェクトを一覧表示するプレーンテキストファイルの名前、またはプロジェクトをスキャンするディレクトリの名前。

プロジェクトリストファイルには、1行に1つのプロジェクトがリストされ、各行の形式は以下のとおりです

@example
<URI-encoded filesystem path to repository> SP <URI-encoded repository owner>
@end example


この変数のデフォルト値は、インストール時に @samp{GITWEB_LIST} makefile変数によって決定されます。この変数が空の場合、gitwebはフォールバックして @samp{$projectroot} ディレクトリのリポジトリをスキャンします。

@item  $project_maxdepth 
@samp{$projects_list} 変数が設定されていない場合、gitwebはファイルシステムを再帰的にスキャンしてGitリポジトリを探します。 @samp{$project_maxdepth} は、 @samp{$projectroot} (開始点)を基準にしてトラバーサル深度を制限するために使用されます。 これは、@samp{$project_maxdepth} よりも @samp{$projectroot} から離れているディレクトリがスキップされることを意味します。

これは純粋にパフォーマンスの最適化であり、元々は再帰的なディレクトリトラバーサルが遅い MacOS X を対象としています。Gitwebはシンボリックリンクをたどりますが、重複するファイルやディレクトリを無視して循環を検出します。

この変数のデフォルト値は、ビルド時の構成変数 @samp{GITWEB_PROJECT_MAXDEPTH} によって決定されます。デフォルトは2007です。

@item  $export_ok 
この(変数の値のファイル名の)ファイルが(リポジトリに)存在する場合にのみリポジトリを表示します。この変数がtrueと評価された場合にのみ有効です。 @samp{GITWEB_EXPORT_OK} を設定することにより、gitwebを構築するときに設定できます。 このパスは @samp{GIT_DIR} からの相対パスです。 git-daemon[1] は、 @samp{--export-all} で開始されていない限り、 @samp{git-daemon-export-ok} を使用します。デフォルトでは、この変数は設定されていません。つまり、この機能はオフになっています。

@item  $export_auth_hook 
表示するリポジトリを決定するために使用される関数。このサブルーチンは、プロジェクトへのフルパスという1つのパラメーターを受け取る必要があり、trueを返した場合、そのプロジェクトはプロジェクトリストに含まれ、 @samp{$export_ok} と $@samp{projects_list} と @samp{$projects_maxdepth} とで説明されている他の要件を満たしている限り、gitwebからアクセスできます。例:

@example
our $export_auth_hook = sub @{ return -e "$_[0]/git-daemon-export-ok"; @};
@end example


上記は代わりに、以下のように @samp{$export_ok} を使用して行うことができますが

@example
our $export_ok = "git-daemon-export-ok";
@end example


設定されていない場合(デフォルト)は、この機能はが無効になっています。

より複雑な例として、 gitweb(1) manpage の「Controlling access to Git repositories」サブセクションも参照してください。

@item  $strict_export 
概要ページにも表示されているリポジトリの表示のみを許可します。これにより、たとえば、 @samp{$ export_ok} ファイルは、リポジトリが表示されているかどうかだけでなく、リポジトリが使用可能かどうかを判断します。 @samp{$projects_list} がプロジェクトのリストを含むファイルを指している場合、リストされているリポジトリのみがgitwebで使用できます。 @samp{GITWEB_STRICT_EXPORT} を介してgitwebの構築中に設定できます。デフォルトでは、この変数は設定されていません。つまり、プロジェクトリストページから非表示になっている(たとえば、 `$projects_listファイルにリストされいない)リポジトリに直接のアクセスができます。
@end table

@noindent

@heading Finding files

以下の構成変数は、ファイルの場所をgitwebに指示します。これらの変数の値は、ファイルシステム上のパスです。

@table @asis

@item  $GIT 
使用するコアgit実行可能ファイル。デフォルトでは @samp{$GIT_BINDIR/git} に設定されており、これはデフォルトで @samp{$(bindir)/git} に設定されています。バイナリパッケージからインストールされたGitを使用する場合は、通常、これを @samp{/usr/bin/git} に設定する必要があります。Webサーバーに適切なPATHが通っている場合、これは単に @samp{git} になる可能性があります。 セキュリティの観点から、gitバイナリへの絶対パスを使用することをお勧めします。複数のGitバージョンがインストールされている場合は、gitバイナリへの絶対パスを使用して、使用するバージョンを選択できます。gitwebが機能するには、(正しく)設定する必要があります。

@item  $mimetypes_file 
@samp{/etc/mime.types} を試す前に、(ファイル名拡張子に基づいて)MIMEタイプを推測するために使用するファイル。 @strong{NOTE} このパスは、相対的である場合、CGIスクリプトではなく、現在のGitリポジトリに相対的であると見なされます。 設定されていない場合、 @samp{/etc/mime.types} のみが使用されます(@samp{/etc/mime.types} がファイルシステムに存在する場合)。 mimetypesファイルが見つからない場合、ファイルの拡張子に基づくmimetypeの推測は無効になります。デフォルトでは設定されていません。

@item  $highlight_bin 
使用するhighlight実行可能ファイルのパス(パラメーターと出力に関して仮定してあるため、 @uref{http://www.andre-simon.de,http://www.andre-simon.de} からのものである必要があります)。デフォルトでは @samp{highlight} に設定されています。WebサーバーのPATHが通ったところにインストールされていない場合は、highlight実行可能ファイルへのフルパスを設定します。gitwebが実際に構文の強調表示(syntax highlighting)を使用するには、 @samp{highlight} 機能を設定する必要があることに注意してください。

@strong{注意} : ファイルを強調表示するには、その構文タイプを検出し、
その構文を @samp{highlight} でサポートする必要があります。
デフォルトの構文検出は最小限であり、
デフォルトで検出されない多くのサポートされている構文タイプがあります。
構文検出を追加するには、3つのオプションがあります。
1番目と2番目の優先順位は @samp{%highlight_basename} と @samp{%highlight_ext} で、
これらはベース名(完全なファイル名、たとえば @samp{Makefile})と拡張子(たとえば @samp{sh})に基づいて検出します。
これらのハッシュのキーはそれぞれベース名と拡張子であり、
指定されたキーの値は、@samp{--syntax<syntax>} を介して @samp{highlight} に渡される構文の名前です。
最後の優先順位は、
ファイルの最初の行に基づいて言語を検出するための @samp{Shebang} 正規表現の @samp{highlight} 構成です
(たとえば、行 @samp{#!/bin/bash} とマッチします)。
highlightのドキュメントとデフォルトの設定を参照してください。
詳細については、 @samp{/etc/highlight/filetypes.conf} を参照してください。

たとえば、ホストしているリポジトリがPHPファイルに @samp{phtml} 拡張子を使用していて、それらのファイルに正しい構文を強調表示したい場合は、gitweb構成に以下を追加できます:

@example
our %highlight_ext;
$highlight_ext@{'phtml'@} = 'php';
@end example

@end table

@noindent

@heading Links and their targets

以下で説明する構成変数は、いくつかのgitwebリンクを構成します。ターゲットと外観(テキストまたは画像)、およびページの前提条件(スタイルシート、favicon、画像、スクリプト)の場所です。 通常、 @samp{@@stylesheets} 変数を除いて、デフォルト値のままになります。

@table @asis

@item  @samp{@@stylesheets} 
スタイルシートのURIのリスト(ページのベースURIからの相対パス)。複数のスタイルシートを指定する場合があります。たとえば、 @samp{gitweb.css} をベースとして使用し、サイト固有の変更を別のスタイルシートに追加して、gitwebのアップグレードを容易にします。 たとえば、あなたが @samp{site} スタイルシートを追加するには以下のようにします

@example
push @@stylesheets, "gitweb-site.css";
@end example


これをgitweb構成ファイルに追加します。相対パスであるこれらの値は、gitwebのベースURIを基準にしています。

このリストには、gitwebの標準スタイルシートのURIが含まれている必要があります。gitwebスタイルシートのデフォルトURIは、ビルド時に @samp{GITWEB_CSS} makefile変数を使用して設定できます。デフォルト値は @samp{static/gitweb.css} (または、 @samp{CSSMIN} 変数が定義されている場合、つまり、ビルド中にCSS minifierが使用されている場合は @samp{static/gitweb.min.css} ) です。

@strong{注意}: 古いgitwebで使用されていた従来の @samp{$stylesheet} 構成変数もあります。
`$stylesheet`変数が定義されている場合、
この変数によって指定されたCSSスタイルシートのみがgitwebによって使用されます。

@item  $logo 
Webサーバー上で @samp{git-logo.png} を配置する場所を指定します。または、72x27サイズの汎用ロゴのURIを指します。この画像は、各gitwebページの右上隅に表示され、Atomフィードのロゴとして使用されます。 gitwebのベースURIからの相対パスです。 @samp{GITWEB_LOGO} 変数を使用してgitwebを構築するときに調整できます。デフォルトでは @samp{static/git-logo.png} に設定されています。

@item  $favicon 
Webサーバー上で @samp{git-favicon.png} を配置する場所を指します。または、 @samp{image/png} タイプとして提供されるfaviconの汎用URIを指します。favicon(Webサイトアイコン)をサポートするWebブラウザーは、favicon(Webサイトアイコン)をブラウザーのURLバーに表示し、ブックマークのサイト名の横に表示する場合があります。gitwebのベースURIからの相対パスです。 @samp{GITWEB_FAVICON} 変数を使用してビルド時に調整できます。 デフォルトでは @samp{static/git-favicon.png} に設定されています。

@item  $javascript 
Webサーバー上で @samp{gitweb.js} を配置する場所を指します。より一般的には、gitwebで使用されるJavaScriptコードのURIを指します。 gitwebのベースURIを基準にしています。 @samp{GITWEB_JS} ビルド時構成変数を使用してビルド時に設定できます。

デフォルト値は、 @samp{static/gitweb.js} または @samp{JSMIN} ビルド変数が定義されている場合、つまりビルド時にJavaScript minifierが使用されている場合は @samp{static/gitweb.min.js} です。 @strong{注意} この単一のファイルは、複数の個別のJavaScriptモジュール達から生成されます。

@item  $home_link 
すべてのページの上部にあるホームリンク(home link)のターゲット(パンくずリスト(breadcrumbs)ビューの最初の部分)。 デフォルトでは、現在のページの絶対URIに設定されます(@samp{$my_uri} 変数の値、または @samp{$my_uri} が未定義または空の文字列の場合は @samp{/} に設定されます)。

@item  $home_link_str 
すべてのページの上部にある「home link」のラベルで、@samp{$home_link} に誘導します(通常、プロジェクトリストを含むメインのgitwebページです)。 @samp{<home link> / <project> / <action>} は、gitwebの「パンくずリスト」の最初のコンポーネントとして使用されます。 @samp{GITWEB_HOME_LINK_STR} 変数を使用してビルド時に設定できます。このリンクからプロジェクトのリストが表示されるため、デフォルトではラベルは "projects" に設定されています。もう1つの一般的な選択肢は、サイトの名前に設定することです。生のHTMLとして扱われるため、信頼できないソースからは設定しないでください。

@item  @samp{@@extra_breadcrumbs} 
ホームリンクの前のパンくずリスト(breadcrumb trail)の先頭に、gitwebサーバーをホストする組織や部門など、gitwebプロジェクトリストの論理的に「上位」にあたるページに追加される追加のリンク。リストの各要素は配列への参照であり、要素0はリンクテキスト(@samp{$home_link_str} 相当)で、要素1はターゲットURL(@samp{$home_link} 相当)です。

たとえば、以下の設定では、 @samp{home/dev/projects/ ...} のようなパンくずリストが生成されます。ここで、 @samp{projects} はホームリンクです。

@example
    our @@extra_breadcrumbs = (
      [ 'home' => 'https://www.example.org/' ],
      [ 'dev'  => 'https://dev.example.org/' ],
    );
@end example


@item  $logo_url 
@itemx  $logo_label 
Gitロゴリンク(または、別のロゴ画像を使用することを選択した場合はサイトのロゴ)の、URIとラベル(タイトル)。デフォルトでは、これらは両方ともGitホームページ @uref{https://git-scm.com,https://git-scm.com} を参照します。 過去には、 @uref{https://www.kernel.org,https://www.kernel.org} のGitのドキュメントを参照していました。
@end table

@noindent

@heading Changing gitweb’s look

あなたは、以下で説明する変数を使用して、gitwebによって生成されたページの外観を調整できます。サイト名を変更したり、すべてのページに共通のヘッダーとフッターを追加したり、メインページ(プロジェクトリストページ)に、このgitwebインストールの説明を追加したりできます。

@table @asis

@item  $site_name 
ページタイトルに表示される、サイト名または組織名です。 ブックマークなどを分かりやすくするために、何か説明的なものに設定してください。 この変数が設定されていない場合、あるいは設定されていても、gitweb は @samp{SERVER_NAME} CGI環境変数の値を使用して、サイト名を "$SERVER_NAME Git" に設定し、この環境変数が設定されていない場合(例: gitweb がスタンドアローンのスクリプトとして起動している場合など)は "Untitled Git" に設定します。

ビルド時に @samp{GITWEB_SITENAME} を使用して設定できます。 デフォルトでは設定されていません。

@item  $site_html_head_string 
各ページの<head>セクションに含まれるHTMLスニペット。ビルド時に @samp{GITWEB_SITE_HTML_HEAD_STRING} を使用して設定できます。 デフォルト値はありません。

@item  $site_header 
各ページの先頭にインクルードされるHTMLを記述したファイル名。 @samp{gitweb.cgi} スクリプトを含むディレクトリからの相対パスです。 ビルド時に @samp{GITWEB_SITE_HEADER} を使用して設定することができる。デフォルト値はありません。

@item  $site_footer 
各ページの下部にインクルードされるHTMLを含むファイルの名前。 @samp{gitweb.cgi} スクリプトを含むディレクトリに相対的です。ビルド時に @samp{GITWEB_SITE_FOOTER} を使用して設定できます。 デフォルト値はありません。

@item  $home_text 
存在すればgitwebプロジェクトの概要ページ(@samp{projects_list} ビュー)にインクルードされるHTMLファイルの名前。 @samp{gitweb.cgi} スクリプトを含むディレクトリに相対的です。デフォルト値は、 @samp{GITWEB_HOMETEXT} 変数を使用してビルド時に調整できます。デフォルトでは @samp{indextext.html} に設定されています。

@item  $projects_list_description_width 
プロジェクトリストの「説明」列の幅(文字数)。長い説明は切り捨てられます(単語の境界で切り取ろうと試みます)。完全な説明は、(通常はマウスオーバーで表示される)title属性にあります。デフォルトは25ですが、長いプロジェクトの説明を使用する場合は小さすぎる可能性があります。

@item  $default_projects_order 
プロジェクトリストページでのプロジェクトの順序のデフォルト値。これは、プロジェクトリストを明示的に並べ替えない場合に使用される順序を意味します(URLに @samp{o} CGIクエリパラメータがない場合)。 有効な値は、「none」(並べ替えなし)、「project」(プロジェクトはプロジェクト名、つまり「$ projectroot」からのリポジトリへのパス)、「descr」(プロジェクトの説明)、「owner」、「age」(最新のコミットの日付) です。

デフォルト値は @samp{project} です。不明な値は、ソートされていないことを意味します。
@end table

@noindent

@heading Changing gitweb’s behavior

これらの構成変数は、gitwebの「内部」動作を制御します。

@table @asis

@item  $default_blob_plain_mimetype 
mimetypeチェックで他のタイプが生成されない場合の、blob_plain (raw)ビューのデフォルトのmimetype。デフォルトでは "text/plain" です。 Gitwebは、 @samp{$mimetypes_file} (設定されていてfileが存在する場合)と @samp{/etc/mime.types} ファイルを使用して、ファイル名の拡張子に基づいて表示するファイルのmimetypeを推測します。( mime.types(5) manpage を参照してください。gitwebではファイル名拡張子ルールのみがサポートされています。)

@item  $default_text_plain_charset 
テキストファイルのデフォルトの文字セット。これが設定されていない場合は、Webサーバー構成が使用されます。デフォルトでは設定されていません(unset)。

@item  $fallback_encoding 
行にUTF-8以外の文字が含まれている場合、Gitwebはこの文字セットを想定します。フォールバックデコードはエラーチェックなしで使用されるため、「utf-8」にすることもできます。値は有効なエンコーディングである必要があります。 リストについては、 Encoding::Supported (3pm) の manpage を参照してください。デフォルトは「latin1」、別名「iso-8859-1」です。

@item  @samp{@@diff_opts} 
git-diffおよびgit-diff-treeの検出オプションの名前を変更します。デフォルトは ('-M') です。コピーも検出するには ('-C') または ('-C', '-C'）に設定するか、名前変更を検出したくない場合は () 、つまり空のリストに設定します。

@strong{注意} 名前変更(rename)、特にコピーの検出は、CPUにかなりの負荷がかかる可能性があります。
また、Git以外のツールでは、
上記のオプションで生成されたパッチで問題が発生する可能性があることにも注意してください。
特に、ファイルのコピー ('-C') または交差名前変更(criss-cross renames) ('-B') が含まれる場合はそうです。
@end table

@noindent

@heading Some optional features and policies

ほとんどの機能は @samp{%feature} ハッシュを介して構成されます。ただし、追加のgitweb機能の一部は、以下で説明する変数を使用してオンにして構成できます。gitwebの外観を制御する構成変数の傍にあるこのリストには、gitwebの管理側を構成する変数が含まれています。(例: クロスサイトスクリプティングの防止。ご存知のとおり、これは副作用として「要約」ページの外観や負荷制限に影響します)

@table @asis

@item  @samp{@@git_base_url_list} 
GitベースURLのリスト。これらのURL群は、プロジェクトの概要ページに表示される、プロジェクトを取得する場所を説明するURLを生成するために使用されます。このリストの各要素の完全なフェッチURLは @samp{$git_base_url/$project} です。 複数のベースURLを設定できます(たとえば、1つは @samp{git://} プロトコル用、もう1つは @samp{http://} プロトコル用)。

注意: リポジトリごとの構成は、 @samp{$GIT_DIR/cloneurl} ファイルで設定することも、プロジェクト構成の、複数値の @samp{gitweb.url} 構成変数の値として設定することもできます。リポジトリごとの構成は、 @samp{@@git_base_url_list} 要素とプロジェクト名で構成される値よりも優先されます。

あなたは @samp{GITWEB_BASE_URL} ビルド時構成変数を設定することにより、ビルド時に単一の値(1つの entry/item だけを持つリスト)を設定できます。デフォルトでは、 () 、つまり空のリストに設定されています。これは、gitwebがプロジェクト名から(フェッチのための)プロジェクトURLを作成しようとしないことを意味します。

@item  $projects_list_group_categories 
プロジェクトリストページでカテゴリ別にプロジェクトをグループ化できるようにするかどうか。プロジェクトのカテゴリは、各リポジトリの構成の @samp{$GIT_DIR/category} ファイル、または @samp{gitweb.category} 変数によって決定されます。デフォルトでは無効になっています(0に設定)。

@item  $project_list_default_category 
何も指定されていないプロジェクトのデフォルトカテゴリ。 これが空の文字列に設定されている場合、そのようなプロジェクトは未分類のままで、分類されたプロジェクトの上に表示されます。 プロジェクトカテゴリが有効になっている場合、つまり @samp{$projects_list_group_categories} がtrueの場合にのみ使用されます。デフォルトでは "" (空文字列)に設定されています。

@item  $prevent_xss 
trueの場合、リポジトリ内のコンテンツがクロスサイトスクリプティング(XSS)攻撃を開始するのを防ぐために、一部のgitweb機能が無効になっています。リポジトリのコンテンツを信頼できない場合は、これをtrueに設定します。デフォルトではFalse(0に設定)。

@item  $maxload 
gitwebクエリに応答する最大負荷を設定するために使用されます。サーバーの負荷がこの値を超えると、gitwebは「503 Service Unavailable」エラーを返します。 gitwebがその値を判別できない場合、サーバーの負荷は0と見なされます。 現在、Linuxでのみ動作し、 @samp{/proc/loadavg} を使用します。 負荷は、システム上でアクティブなタスクの数 — 実際に実行されているプロセス — が最後の1分間に平均化されたものです。

この機能をオフにするには、 @samp{$maxload} を未定義の値(undef)に設定します。デフォルト値は300です。

@item  $omit_age_column 
trueの場合、プロジェクトリストページの最新のコミットの日付の列を省略します。リポジトリごとに少しのI/Oとフォークを節約できます。

@item  $omit_owner 
trueの場合、リポジトリ所有者に関する情報を表示できなくなります。

@item  $per_request_config 
これがコードへの参照に設定されている場合、リクエストごとに1回実行されます。この方法で、セッションごとに構成の一部を変更設定できます。たとえば、gitweb構成ファイルで以下のコードを使用する場合があります

@example
our $per_request_config = sub @{
        $ENV@{GL_USER@} = $cgi->remote_user || "gitweb";
@};
@end example


@samp{$per_request_config} がコードへの参照でない場合、ブール値として解釈されます。trueの場合、gitwebはリクエストごとに1回設定ファイルを処理し、falseの場合、gitwebは実行されるたびに1回だけ設定ファイルを処理します。デフォルトではtrueです(1に設定)。

@strong{注意}:  @samp{$my_url} と @samp{$my_uri} と  @samp{$base_url} は、すべてのリクエストの発生前にデフォルト値で上書きされるため、
変更する場合は、必ずこの変数をtrueに設定するか、
必要な変更を行うコードへの参照を設定してください。

この変数は、mod_perl、FastCGI、Plackupなどの単一のgitwebインスタンスを使用して複数のリクエストを処理する永続的なWeb環境を使用する場合にのみ重要です。
@end table

@noindent

@heading Other variables

通常、あなたは以下で説明する構成変数を変更(調整)する必要はありません。 それらは正しい値にするために、gitwebが自動で設定する必要があります。

@table @asis

@item  $version 
Gitwebバージョン。gitweb.perlからgitweb.cgiを作成するときに自動的に設定されます。たとえば、あなたが変更したgitwebを実行している場合は、変更することをお勧めします。

@example
our $version .= " with caching";
@end example


あなたがキャッシュのサポートがある、変更バージョンのgitwebを実行する場合。この変数は純粋に情報提供用であり、たとえばHTMLヘッダーの「generator」メタヘッダー内で使われます。

@item  $my_url 
@itemx  $my_uri 
gitwebスクリプトの完全なURLと絶対URL。以前のバージョンのgitwebでは、これらの変数を設定する必要があるかもしれませんが、今では設定する必要はありません。 まだ設定する必要がある場合は、 @samp{$per_request_config} を参照してください。

@item  $base_url 
gitwebによって生成されたページ内の相対URLのベースURL(例えば、相対URLの場合は @emph{$logo} 、 @emph{$favicon} 、 @emph{@@stylesheets})が必要で、空でないPATH_INFOを持つURLに対してのみ @emph{<base href="$base_url">} が必要でした。通常、gitwebはその値を正しく設定し、この変数に $my_uri や "/" などを設定する必要はありません。あなたがとにかくそれをオーバーライドする必要がある場合は、 @emph{$per_request_config} を参照してください。
@end table

@noindent

@chapheading CONFIGURING GITWEB FEATURES

多くのgitweb機能は、 @samp{%feature} ハッシュ(連想配列)を使用して有効化(または無効化)および構成できます。gitweb機能の名前は、このハッシュのキーです。

各 @samp{％feature} ハッシュ(連想配列)要素はハッシュへの参照であり、以下の構造を持っています:

@example
"<feature_name>" => @{
        "sub" => <feature-sub (subroutine)>,
        "override" => <allow-override (boolean)>,
        "default" => [ <options>... ]
@},
@end example


一部の機能は、プロジェクトごとにオーバーライドできません。 これらの機能の場合、適切な @samp{%feature} ハッシュ要素の構造はより単純な形式になります:

@example
"<feature_name>" => @{
        "override" => 0,
        "default" => [ <options>... ]
@},
@end example


上記にはご覧のとおり、'sub' 要素がありません。

機能構成の各部分の意味を以下に説明します:

@table @asis

@item  default 
機能パラメータ(存在する場合)のリスト(配列への参照)。特定の機能を切り替える(有効または無効にする)ためにも使用されます。

注意: 機能が構成パラメーターを受け入れない場合でも、現在は常に配列への参照であり、'default' はオンまたはオフにするためにのみ使用されることに注意してください。 このような場合は、この要素を @samp{[1]} に設定して機能をオンにし、 @samp{[0]} に設定して機能を解除します。「Examples例」セクションの「blame」機能に関する一節も参照してください。

パラメータを受け入れる(設定可能な)機能を無効にするには、この要素を空のリスト、つまり @samp{[]} に設定する必要があります。

@item  override 
このフィールドにtrue値がある場合、指定の機能はオーバーライド可能です。つまり、リポジトリごとに構成(または 有効/無効 化)できます。

通常、指定の「<feature>」は、リポジトリごとのGit構成ファイルの @samp{gitweb.<feature>} 構成変数を介して構成できます。

@strong{注意} デフォルトではオーバーライド可能な機能はありません。

@item  sub 
実装の内部詳細。重要なのは、このフィールドが存在しない場合、特定の機能のリポジトリごとのオーバーライドはサポートされないということです。

あなたはgitweb構成ファイルでこれを変更する必要はありません。
@end table

@noindent

@heading Features in %feature

@samp{%feature} ハッシュを介して構成可能なgitweb機能を以下に示します。これは完全なリストであるべきですが、最終的に信頼できる完全なリストはgitweb.cgiソースコードにあり、機能はそのコメントで説明されています。

@table @asis

@item  blame 
「blame」および「blame_incremental」ブロブビューを有効にし、各行にそれを変更した最後のコミットを表示します。 git-blame(1) を参照してください。 これはCPUに非常に負荷がかかる可能性があるため、デフォルトでは無効になっています。

この機能は、リポジトリの @samp{gitweb.blame} 構成変数(ブール値)を介してリポジトリごとに構成できます。

@item  snapshot 
「snapshot」アクションを有効にして構成します。これにより、ユーザーは、 git-archive(1) によって生成され、そして、場合によってはさらに圧縮された、任意のツリーまたはコミットの圧縮アーカイブをダウンロードできます。大規模なプロジェクトがある場合、これにより大量のトラフィックが発生する可能性があります。

'default' の値は、提供するスナップショット形式の名前のリストであり、 @samp{%known_snapshot_formats} ハッシュで定義されています。サポートされている形式には、"tgz"、"tbz2"、"txz" (gzip/bzip2/xz で圧縮されたtarアーカイブ)、および "zip" が含まれます。完全なリストについては、gitwebのソースを参照してください。 デフォルトでは、"tgz"のみが提供されます。

この機能は、リポジトリの @samp{gitweb.snapshot} 構成変数を介してリポジトリごとに構成できます。この変数には、書式のコンマ区切りリストが含まれるか、スナップショットを無効にする場合は @samp{none} が含まれます。不明な値は無視されます。

@item  grep 
grep検索を有効にします。これにより、現在選択されているツリー(ディレクトリ)内で指定の文字列を含むファイルが一覧表示されます。 git-grep(1) を参照してください。 もちろん、これは潜在的にCPUを集中的に使用する可能性があります。 デフォルトで有効になっています。

この機能は、リポジトリの @samp{gitweb.grep} 構成変数(ブール値)を介してリポジトリごとに構成できます。

@item  pickaxe 
いわゆるpickaxe検索を有効にします。これにより、ファイル内の特定の文字列を導入または削除したコミットが一覧表示されます。 これは実用的で、「blame」アクションの非常に高速な代替手段ですが、それでもCPUに負荷がかかる可能性があります。 デフォルトで有効になっています。

pickaxe検索については、 git-log(1) で説明されています(詳細については gitdiffcore(7) のpickaxeエントリの @samp{-S<string>} オプションを参照してください)。

この機能は、リポジトリの @samp{gitweb.pickaxe} 構成変数(ブール値)を設定することにより、リポジトリごとに構成できます。

@item  show-sizes 
@samp{ls -l} と同様に、別の列の「ツリー」ビューにブロブ(通常のファイル)のサイズを表示できるようにします。 git-ls-tree(1) のmanpageにある @samp{-l} オプションの説明を参照してください。これにはちょびっとI/Oコストがかかります。デフォルトで有効になっています。

この機能は、リポジトリの @samp{gitweb.showSizes} 構成変数(ブール値)を介してリポジトリごとに構成できます。

@item  patches 
コミットのリストを電子メール(プレーンテキスト)出力形式で表示する「パッチ」ビューを有効にして構成します。 git-format-patch(1) も参照してください。 この値は、「パッチ」ビューで生成されたパッチセット内のパッチの最大数です。 @emph{default} フィールドを、パッチビューを無効にするための単一の項目を含むリストまたは空のリストに設定するか、制限を削除するために単一の負の数を含むリストに設定します。デフォルト値は16です。

この機能は、リポジトリの @samp{gitweb.patches} 構成変数(整数)を介してリポジトリごとに構成できます。

@item  avatar 
アバター(avatar)のサポート。この機能を有効にすると、「shortlog」や「commit」などのビューに、各コミッターと作成者の電子メールに関連付けられたアバターが表示されます。

現在利用可能なプロバイダーは、 gravatar と picon です。 一度に選択できるプロバイダーは1つだけです(「default」は要素1つだけのリストです)。不明なプロバイダーが指定されている場合、この機能は無効になります。 @strong{注意} 一部のプロバイダーでは、追加のPerlパッケージをインストールする必要がある場合があります。 詳細については、 @samp{gitweb/INSTALL} を参照してください。

この機能は、リポジトリの @samp{gitweb.avatar} 構成変数を介してリポジトリごとに構成できます。

アイコンとアバターのピクセルサイズを含む @samp{%avatar_size} も参照してください( "default" は "log" や "shortlog" などの1行モノに使用され、 "double" は "commit"、"commitdiff"、"tag" などの2行モノに使用されます)。デフォルトのフォントサイズまたは行の高さが変更された場合は、これらの値を変更すること(たとえば、 @samp{@@stylesheets} にCSSスタイルシートを追加するなど)が適切な場合があります。

@item  email-privacy 
生成されたHTMLなどのコンテンツの電子メールアドレスを改訂します。これにより、Gitログの作者/コミッターおよびコメントセクションから取得された電子メールアドレスを不明瞭にします。 これは、アドレスを収集して悪用するWebクローラーを妨害することを目的としています。このようなクローラーはrobots.txtを尊重しない場合があります。 注意: ユーザーとユーザーツールもアドレスが編集されたものとして表示されることに注意してください。Gitwebがワークフローの最後のステップではない場合、後続のステップは、受け取った情報が編集されているために誤動作する可能性があります。デフォルトでは無効になっています。

@item  highlight 
「ブロブ」ビューでサーバー側構文ハイライトサポートします。@samp{$height_bin} プログラムが使用可能である必要があるため(上記の「構成変数」セクションの、この変数の説明を参照)、デフォルトで無効になっています。

この機能は、リポジトリの @samp{gitweb.highlight} 構成変数(ブール値)を介してリポジトリごとに構成できます。

@item  remote_heads 
「ヘッド」リストにリモートヘッド(リモート追跡ブランチ)を表示できるようにします。ほとんどの場合、リモート追跡ブランチのリストは不要な内部プライベート詳細であるため、この機能はデフォルトで無効になっています。 git-instaweb(1) は、通常、ローカルリポジトリを参照するために使用され、この機能を有効にして使用します。

この機能は、リポジトリの @samp{gitweb.remote_heads} 構成変数(ブール値)を介してリポジトリごとに構成できます。
@end table

以下の、残りの機能は、プロジェクトごとにオーバーライドすることはできません。

@table @asis

@item  search 
テキスト検索を有効にします。これにより、作者(author)または、コミッターまたは、コミットテキストが特定の文字列に一致するコミットが一覧表示されます。 git-log(1) のmanpage にある @samp{--author} と @samp{--committer} と @samp{--grep} オプションの説明を参照してください。デフォルトで有効になっています。

プロジェクト固有のオーバーライドはサポートされていません。

@item  forks 
この機能が有効になっている場合、gitwebは、プロジェクトルート(ベース名)のサブディレクトリ内のプロジェクトを既存のプロジェクトのフォークと見なします。 @samp{$projname.git} プロジェクトごとに、 @samp{$projname/} ディレクトリ内のプロジェクトとそのサブディレクトリはメインプロジェクトリストに表示されません。代わりに、 @samp{$projname} の横に @samp{+} マークが表示されます。これは、すべてのフォーク(@samp{$projname/} サブディレクトリ内のすべてのプロジェクト)を一覧表示する "forks" ビューにリンクしています。さらに、プロジェクトの「fork」ビューは、プロジェクトの概要ページからリンクされています。

プロジェクトリストがファイルから取得された場合( @samp{$projects_list} はファイルを指している)、フォーク(fork)は、そのファイルのメインプロジェクトの後にリストされている場合にのみ認識されます。

プロジェクト固有のオーバーライドはサポートされていません。

@item  actions 
すべてのプロジェクトページのアクションバーへのカスタムリンクを挿入します。これにより、あなたはgitwebに統合されているサードパーティのスクリプトにリンクできます。

「default」値は、 @samp{("<label>", "<link>", "<position>")} という3要素組形式の、リストで構成されます。ここで、 "position" は、リンクを挿入するラベルです。 "link" はフォーマット文字列で、 @samp{%n} はプロジェクト名に展開され、 @samp{%f} はファイルシステム内のプロジェクトパス(つまり "$projectroot/$project")に展開され、 @samp{%h} は現在のハッシュ(@samp{h} gitwebパラメーター)、 @samp{%b} は現在のハッシュベース(@samp{hb} 'gitwebパラメーター) です。@samp{%%} は @samp{%} に展開されます。

たとえば、このページが作成された時点で、 @uref{http://repo.or.cz,http://repo.or.cz} Gitホスティングサイトは、グラフィカルログを有効にするために次のように設定しました(サードパーティツール git-browser を使用):

@example
$feature@{'actions'@}@{'default'@} =
        [ ('graphiclog', '/git-browser/by-commit.html?r=%n', 'summary')];
@end example


これにより、「summary」リンクの後に「graphiclog」というタイトルのリンクが追加され、クエリパラメータとして @samp{r=<project>} を渡して、 @samp{git-browser} スクリプトへ誘導します。

プロジェクト固有のオーバーライドはサポートされていません。

@item  timed 
ページフッター(ページの下部)に各ページを生成して表示するのにかかった時間とGitコマンドの数を表示できるようにします。たとえば、フッターには次のように含まれます。「This page took 6.53325 seconds and 13 Git commands to generate.」(このページの生成には6.53325秒と13のGitコマンドが必要でした。)。デフォルトでは無効になっています。

プロジェクト固有のオーバーライドはサポートされていません。

@item  javascript-timezone 
JavaScriptを介してgitweb出力の日付の共通タイムゾーンを変更する機能を有効にして構成します。 gitweb出力の日付には、「commit」ビューと「commitdiff」ビューと「log」ビューでのauthordateとcommitterdate、および「tag」ビューでのtaggerdateが含まれます。デフォルトで有効になっています。

値は、3つの値のリストです。デフォルトのタイムゾーン(default time zone)(クライアントが他のタイムゾーンを選択してCookieに保存していない場合)と、選択したタイムゾーンを保存するCookieの名前と、操作の日付をマークアップするために使用されるCSSクラスです。この機能をオフにする場合は、「default」を空のリストに設定します。つまり @samp{[]} 。

通常のgitweb構成ファイルでは、最初の、(default)タイムゾーンのみを変更し、他の要素はデフォルト値のままにします:

@example
$feature@{'javascript-timezone'@}@{'default'@}[0] = "utc";
@end example


ここに示されている構成例は、下位互換性と上位互換性が保証されています。

タイムゾーンの値は、 "local"(ブラウザが使用するローカルタイムゾーンの場合)、"utc"(JavaScriptまたは、この機能が無効になっている場合にgitwebが使用するもの)、または "@samp{0200" のような "}/-HHMM" 形式の数値のタイムゾーンにすることができます。

プロジェクト固有のオーバーライドはサポートされていません。

@item  extra-branch-refs 
"refs" の下にある、ブランチのrefとして使用される追加ディレクトリのリスト。たとえば、gerrit のセットアップで、refs/heads/ 以下のすべてのブランチが公式のもので、push-after-review のもの、そして refs/sandbox/, refs/wip, refs/other 以下のブランチはより広いパーミッションを持つユーザーのものである場合、あなたはこの変数を以下のように設定したいと思うことでしょう。

@example
$feature@{'extra-branch-refs'@}@{'default'@} =
        ['sandbox', 'wip', 'other'];
@end example


この機能は、 $feature@{@emph{extra-branch-refs}@}@{@emph{override}@} をtrueに設定した後、リポジトリの @samp{gitweb.extraBranchRefs} 構成変数を介して、リポジトリごとに構成できます。これには、スペースで区切られたrefのリストが含まれます。 例:

@example
[gitweb]
        extraBranchRefs = sandbox wip other
@end example


gitweb.extraBranchRefsは実際には複数値の構成変数であるため、以下の例も正しくて、結果は上記のスニペットと同じです:

@example
[gitweb]
        extraBranchRefs = sandbox
        extraBranchRefs = wip other
@end example


「gitcheck-ref-format」の精査に合格しないrefを指定するとエラーになります。 重複した値はフィルタリングされます。
@end table

@noindent

@chapheading EXAMPLES

blameと、pickaxe検索と、スナップショットのサポート("tar.gz" と "zip" のスナップショットを許可)を有効にし、個々のプロジェクトでそれらをオフにできるようにするには、GITWEB_CONFIGファイルに以下のように入力します:

@example
$feature@{'blame'@}@{'default'@} = [1];
$feature@{'blame'@}@{'override'@} = 1;

$feature@{'pickaxe'@}@{'default'@} = [1];
$feature@{'pickaxe'@}@{'override'@} = 1;

$feature@{'snapshot'@}@{'default'@} = ['zip', 'tgz'];
$feature@{'snapshot'@}@{'override'@} = 1;
@end example


スナップショット機能のオーバーライドを許可する場合は、グローバルに無効にするスナップショット形式を指定できます。必要なコマンドラインオプション(圧縮レベルの設定など)を追加することもできます。 たとえば、gitweb構成ファイルに以下の行を追加することで、Zip圧縮スナップショットを無効にし、 gzip(1)をレベル6で実行するように設定できます:

@example
$known_snapshot_formats@{'zip'@}@{'disabled'@} = 1;
$known_snapshot_formats@{'tgz'@}@{'compressor'@} = ['gzip','-6'];
@end example

@noindent

@chapheading BUGS

フォールバック構成ファイル(@samp{/etc/gitweb.conf})とその場所をオーバーライドする環境変数(@emph{GITWEB_CONFIG_SYSTEM})に、「fallback」の役割を反映した名前が付いていると、デバッグが容易になります。 現在の名前は、作業セットアップを壊さないように保持されます。

@noindent

@chapheading ENVIRONMENT

インスタンスごとおよびシステム全体の構成ファイルの場所は、以下の環境変数を使用してオーバーライドできます:

@table @asis

@item  GITWEB_CONFIG 
インスタンスごとの構成ファイルの場所を設定します。

@item  GITWEB_CONFIG_SYSTEM 
フォールバックするシステム全体の構成ファイルの場所を設定します。 このファイルは、インスタンスごとのファイルが存在しない場合にのみ読み取られます。

@item  GITWEB_CONFIG_COMMON 
共通のシステム全体の構成ファイルの場所を設定します。
@end table

@noindent

@chapheading FILES

@table @asis

@item  @samp{gitweb_config.perl} 
これは、インスタンスごとの構成ファイルのデフォルト名です。このファイルの形式は前述のとおりです。

@item  @samp{/etc/gitweb.conf} 
これは、フォールバックするシステム全体の構成ファイルのデフォルト名です。このファイルは、インスタンスごとの構成変数が見つからない場合にのみ使用されます。

@item  @samp{/etc/gitweb-common.conf} 
これは、共通システム全体の構成ファイルのデフォルト名です。
@end table

@noindent

@chapheading SEE ALSO

gitweb(1), git-instaweb(1)

@emph{gitweb/README}, @emph{gitweb/INSTALL}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitweb,,,Top
@chapheading Name

gitweb — Git Webインターフェイス(GitリポジトリのためのWebフロントエンド)

@noindent

@chapheading Synopsis

gitwebの使用を開始するには、Gitリポジトリから git-instaweb(1) を実行します。これにより、Webサーバーが構成および起動され、gitwebを指すWebブラウザーが実行されます。

@noindent

@chapheading DESCRIPTION

Gitwebは、GitリポジトリへのWebインターフェイスを提供します。その機能は以下のとおりです:

@itemize 

@item
共通のルートを持つ複数のGitリポジトリを表示します。

@item
リポジトリのすべてのリビジョンをブラウズします。

@item
リポジトリ内の任意のリビジョンのファイルの内容を表示します。

@item
ブランチのリビジョンログ、ファイルとディレクトリの履歴を表示して、何がいつ、誰によって変更されたかを表示します。

@item
(有効になっている場合)ファイルの blame/annotation の詳細を表示します。

@item
任意のブランチに対して、コミットのRSSおよびAtomフィードを生成します。フィードは、最新のWebブラウザーで自動検出可能です。

@item
リビジョンで変更されたすべてのものを表示し、一度に1つずつリビジョンをステップ表示して、リポジトリの履歴を表示します。

@item
指定した検索語にマッチするコミットメッセージのコミットを検索します。
@end itemize

gitweb自体を使用してブラウズできるgitwebソースコードについては、 @uref{http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/,http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/} を参照してください。

@noindent

@chapheading CONFIGURATION

gitwebの動作のさまざまな側面は、構成ファイル @samp{gitweb_config.perl} または @samp{/etc/gitweb.conf} を介して制御できます。詳細については gitweb.conf(5) を参照してください。

@noindent

@heading Repositories

Gitwebは、1つ以上のGitリポジトリからの情報を表示できます。 これらのリポジトリはすべてローカルファイルシステム上にあり、共通のリポジトリルートを共有する必要があります。つまり、すべてが単一の親リポジトリの下にある必要があります(ただし、「Advanced web server setup」セクションの「Webserver configuration with multiple projects' root」(複数のプロジェクトのルートを使用したWebサーバーの構成)サブセクションも参照してください)。

@example
our $projectroot = '/path/to/parent/directory';
@end example


@samp{$projectroot} のデフォルト値は @samp{/pub/git} です。 gitwebのビルド中に、@samp{GITWEB_PROJECTROOT} ビルド構成変数を介して変更できます。

デフォルトでは、 @samp{$projectroot} の下にあるすべてのGitリポジトリが表示され、gitwebで利用できます。 プロジェクトのリストは、デフォルトで @samp{$projectroot} ディレクトリをスキャンしてGitリポジトリを探します(オブジェクトデータベースをより正確に言うと、gitwebは作業領域に関心がなく、「裸の」(bare)リポジトリを表示するのに最適です)。

gitwebのリポジトリの名前は、@samp{$projectroot} を基準にした @samp{$GIT_DIR} (そのオブジェクトデータベース)へのパスです。 したがって、リポジトリ $repoは @samp{$projectroot/$repo} にあります。

@noindent

@heading Projects list file format

$projectroot から始まるファイルシステムをスキャンしてgitwebにリポジトリを検索させる代わりに、(いくつかの追加情報を含む)プロジェクトのリストを含むプレーンテキストファイルを指すように @samp{$projects_list} を設定することにより、事前生成された表示可能なプロジェクトのリストを提供できます。

このファイルは以下の形式を使用します:

@itemize 

@item
1行に1つのレコード(プロジェクト/リポジトリ用)。行の継続(改行のエスケープ)はサポートされていません。

@item
先頭と末尾の空白(whitespace)は無視されます。

@item
空白(whitespace)で区切られたフィールド。 空白(whitespace)はすべてフィールド区切り文字として使用できます(Perlの "@samp{split(" ", $line)}" ルール)。

@item
フィールドは、RFC 3986のセクション2.1(Percent-Encoding)で定義されているmodified URI encoding、または「Query string encoding」(@uref{https://en.wikipedia.org/wiki/Query_string#URL_encoding,https://en.wikipedia.org/wiki/Query_string#URL_encoding} 参照)を使用します。違いは次のとおりです。 そのSP（` @samp{）は `@{plus@}} としてエンコードできます(したがって、 @samp{@{plus@}} もパーセントエンコードする必要があります)。

予約文字は次のとおりです: @samp{%} (エンコードに使用)と、 @samp{@{plus@}} (スペースのエンコードに使用可能)と SP・TAB・LFを含むPerlで定義されているすべての空白文字(レコード内のフィールドの区切りに使用)。

@item
現在認識されているフィールドは以下のとおりです:

@table @asis

@item  <repository path> 
@samp{$projectroot} に相対的なリポジトリ GIT_DIR へのパス

@item  <repository owner> 
リポジトリの所有者、できればフルネームまたは電子メール、またはその両方として表示されます
@end table
@end itemize

あなたはgitwebから直接project_indexアクション(プロジェクトリストページの TXT リンク)を使用して、プロジェクトリストインデックスファイルを生成できます。 以下の「Generating projects list using gitweb」(gitwebを使用したプロジェクトリストの生成)セクションも参照してください。

内容例:

@example
foo.git       Joe+R+Hacker+<joe@@example.com>
foo/bar.git   O+W+Ner+<owner@@example.org>
@end example


デフォルトでは、このファイルはプロジェクトリストページに「表示」されるプロジェクトのみを制御します(注意:正しく認識されたGitリポジトリを指していないエントリはgitwebによって表示されないことに注意してください)。あなたはプロジェクトがプロジェクトリストページに表示されていない場合でも、gitwebURLを手動で作成することでプロジェクトを表示できます。 @samp{$strict_export} 構成変数(gitweb.conf(5) 参照)をtrueに設定すると、概要ページにも表示されるリポジトリのみを表示許可します(つまり、プロジェクトリストファイルに明示的にリストされているプロジェクトのみのアクセス)。

@noindent

@heading Generating projects list using gitweb

私達はGITWEB_CONFIGにはデフォルトのMakefile値、つまり「gitweb_config.perl」があると想定しています。 @samp{gitweb_make_index.perl} ファイルに以下を入れてください:

@example
read_config_file("gitweb_config.perl");
$projects_list = $projectroot;
@end example


次に、以下のスクリプトを作成して、GITWEB_LISTビルド構成変数(またはgitweb構成の @samp{$projects_list} 変数)に適した形式でプロジェクトのリストを取得します。

@example
#!/bin/sh

export GITWEB_CONFIG="gitweb_make_index.perl"
export GATEWAY_INTERFACE="CGI/1.1"
export HTTP_ACCEPT="*/*"
export REQUEST_METHOD="GET"
export QUERY_STRING="a=project_index"

perl -- /var/www/cgi-bin/gitweb.cgi
@end example


このスクリプトを実行し、その出力をファイルに保存します。このファイルは、プロジェクトリストファイルとして使用できます。つまり @samp{$projects_list} にそのファイル名を設定できます。

@noindent

@heading Controlling access to Git repositories

デフォルトでは、 @samp{$projectroot} の下にあるすべてのGitリポジトリが表示され、gitwebで利用できます。 ただし、あなたはgitwebがリポジトリへのアクセスを制御する方法を構成できます。

@itemize 

@item
「Projects list file format」のセクションで説明したように、プロジェクトリストファイルにリポジトリを選択的に含め、それを指すように @samp{$ projects_list} gitweb構成変数を設定することにより、どのプロジェクトを「表示」するかを制御できます。 @samp{$strict_export} を設定すると、プロジェクトリストファイルを使用して、「利用可能な」リポジトリを制御することもできます。

@item
あなたはgitweb構成ファイルの @samp{$export_ok} 変数を使用して、明示的にエクスポートされたリポジトリのみを一覧表示して表示できるようにgitwebを構成できます。 gitweb.conf(5) のmanpageを参照してください。 trueと評価された場合、gitwebは、 @samp{$export_ok} を評価したファイル名のファイルがオブジェクトデータベースに存在する場合にのみリポジトリを表示します(つまりディレクトリに @samp{$export_ok} を評価した値のファイル名のマジックファイルがある場合)。

たとえば、 git-daemon(1)は、デフォルトで(@samp{--export-all} オプションが使用されていない限り)、 @samp{git-daemon-export-ok} ファイルを持つリポジトリに対してのみプルを許可します。以下のように追加します

@example
our $export_ok = "git-daemon-export-ok";
@end example


こうすると、gitwebを表示し、 @samp{git://} プロトコルを介してフェッチできるリポジトリへのアクセスのみを許可します。

@item
最後に、リポジトリごとに呼び出される任意のperlサブルーチンを指定して、リポジトリをエクスポートできるかどうかを判断することができます。サブルーチンは、プロジェクト(リポジトリ)への絶対パスを唯一のパラメータ(つまり、 @samp{$projectroot/$ project} )として受け取ります。

たとえば、mod_perlを使用してスクリプトを実行し、リポジトリにバカHTTPプロトコル認証(dumb HTTP protocol authentication)を構成している場合、以下のフックを使用して、ユーザーがファイルの読み取りを許可されている場合にのみアクセスを許可できます。

@example
$export_auth_hook = sub @{
        use Apache2::SubRequest ();
        use Apache2::Const -compile => qw(HTTP_OK);
        my $path = "$_[0]/HEAD";
        my $r    = Apache2::RequestUtil->request;
        my $sub  = $r->lookup_file($path);
        return $sub->filename eq $path
            && $sub->status == Apache2::Const::HTTP_OK;
@};
@end example

@end itemize

@noindent

@heading Per-repository gitweb configuration

gitwebに表示される個々のリポジトリを構成するには、Gitリポジトリの @samp{GIT_DIR} にファイルを作成するか、リポジトリ構成変数を設定します( @samp{GIT_DIR/config} で。 git-config(1) 参照)。

あなたはリポジトリ内で以下のファイルを使用できます:

@table @asis

@item  README.html 
gitwebプロジェクトの「summary」ページの @samp{<div>} ブロック要素内にインクルードされるhtmlファイル(HTMLブロック)。プロジェクトのより長い説明、リンクの提供(たとえば、プロジェクトのホームページへ)などに使用できます。これは、XSS防止がオフの場合にのみ認識されます(@samp{$prevent_xss} はfalseです。 gitweb.conf(5) 参照)。XSS防止がオンになっているときにREADMEを安全に含める方法は、将来的には解決される可能性があります。

@item  description (または @samp{gitweb.description}) 
短いプロジェクトの(リポジトリの)1行説明(プロジェクトリストページでは @samp{$ projects_list_description_width} に長さをつめます。デフォルトでは25文字です。 gitweb.conf(5) 参照)。プレーンテキストファイルです。 HTMLはエスケープされます。デフォルトで以下のように設定されています

@example
Unnamed repository; edit this file to name it for gitweb.
@end example


リポジトリ作成中にテンプレートから引用されます。テンプレートは通常は @samp{/usr/share/git-core/templates/} にインストールされます。 @samp{gitweb.description} リポジトリ構成変数を使用できますが、ファイルが優先されます。

@item  category (または @samp{gitweb.category}) 
プロジェクトの単一行カテゴリ。 @samp{$projects_list_group_categories} が有効になっている場合にプロジェクトをグループ化するために使用されます。(ファイルと構成変数が設定されていない)デフォルトでは、分類されていないプロジェクトは @samp{$project_list_default_category} カテゴリに入れられます。 @samp{gitweb.category} リポジトリ構成変数を使用できますが、ファイルが優先されます。

構成変数`$projects_list_group_categories` と @samp{$project_list_default_category} は gitweb.conf(5) で説明されています。

@item  cloneurl (または 複数値変数の @samp{gitweb.url}) 
1行に1つずつ、リポジトリURL(クローンとフェッチに使用)を含むファイル。プロジェクトの概要ページに表示されます。そのために複数値の @samp{gitweb.url} リポジトリ設定変数を使用できますが、ファイルが優先されます。

これは、グローバルプレフィックスベースの @samp{@@git_base_url_list} gitweb 設定変数をリポジトリ毎用に拡張/改造したものです(gitweb.conf(5) 参照)。

@item  gitweb.owner 
@samp{gitweb.owner} リポジトリ設定変数を使用して、リポジトリの所有者を設定できます。 プロジェクトリストと概要ページに表示されます。

これが設定されていない場合、 @samp{$projects_list} が設定されていなければ(unset)、(gitweb は @samp{$projectroot} をスキャンしてリポジトリを探し、)ファイルシステムディレクトリの所有者(GECOSフィールド、つまり「getpwuid(3)」の実名フィールド経由)が使用されます。 @samp{$projects_list} がリポジトリのリストを含むファイルを指している場合、プロジェクト所有者はデフォルトで、指定されたリポジトリのこのファイルの値になります。

@item  various @samp{gitweb.*} config variables (in config) 
詳細なリストと説明については、 @samp{%feature} ハッシュ(連想配列)の説明をお読みください。 gitweb.conf(5) の「Configuring gitweb features」(gitweb機能の構成)セクションも参照してください。
@end table

@noindent

@chapheading ACTIONS, AND URLS

gitwebは、path_info (コンポーネント)ベースのURLを使用することも、クエリパラメーターを介して必要なすべての情報を渡すこともできます。一般的なgitweb URLは、次の以下の5つのコンポーネントに分類されます:

@example
.../gitweb.cgi/<repo>/<action>/<revision>:/<path>?<arguments>
@end example


@table @asis

@item  repo 
アクションが実行されるリポジトリ。

利用可能なすべてのプロジェクトをリストするアクションを除く、すべてのアクションには、どのような形式でも、このパラメーターが必要です。

@item  action 
実行されるアクション。 デフォルトは、リポジトリが設定されていない場合は @samp{projects_list} 、それ以外の場合は @samp{summary} です。

@item  revision 
表示されるリビジョン。デフォルトはHEADです。

@item  path 
それを必要とするアクション用の、アクションが実行される <repository> 内のパス。

@item  arguments 
アクションの振る舞いを制御する任意の引数。
@end table

一部のアクションでは、2つのリビジョン、場合によっては2つのパス名を指定する必要があります。最も一般的な形式では、このようなpath_info(コンポーネント)ベースの gitweb URL では以下のようになります:

@example
.../gitweb.cgi/<repo>/<action>/<revision_from>:/<path_from>..<revision_to>:/<path_to>?<arguments>
@end example


各アクションはサブルーチンとして実装され、%actions ハッシュ(連想配列)に存在する必要があります。一部のアクションはデフォルトで無効になっており、機能メカニズムを介してオンにする必要があります。たとえば、 @samp{blame} ビューを有効にするには、gitweb構成ファイルに以下を追加します:

@example
$feature@{'blame'@}@{'default'@} = [1];
@end example


@noindent

@heading Actions:

標準のアクションは以下のとおりです:

@table @asis

@item  project_list 
利用可能なGitリポジトリを一覧表示します。 URLにリポジトリが指定されていない場合、これがデフォルトのコマンドです。

@item  summary 
指定されたリポジトリに関する要約を表示します。 これは、URLにアクションが指定されておらず、リポジトリのみが指定されている場合のデフォルトのコマンドです。

@item  heads 
@itemx  remotes 
特定のリポジトリ内の、すべてのローカル、またはすべてのリモート追跡ブランチを一覧表示します。

後者は、構成されていない限り、デフォルトでは使用できません。

@item  tags 
指定のリポジトリ内のすべてのタグ(軽量および注釈付き)を一覧表示します。

@item  blob 
@itemx  tree 
指定のリポジトリパス内のファイルとディレクトリの指定のリビジョンを表示します。これは、URLにアクションが指定されておらず、パスが指定されている場合のデフォルトのコマンドです。

@item  blob_plain 
指定されたリポジトリ内の指定されたパスとリビジョンのファイルの生データを返します。このアクションへのリンクは @samp{raw} とマークされています。

@item  blobdiff 
同一ファイルの2つのリビジョンの間の違いを示します。

@item  blame 
@itemx  blame_incremental 
ファイルのblame(注釈とも呼ばれる)情報を表示します。行ごとに、その行が最後に変更されたリビジョンと、変更をコミットしたユーザーが表示されます。(設定されている場合は、JavaScriptが有効なときに自動的に使用される、)インクリメンタルバージョンは、Ajaxを使用して、指定されたファイルのコンテンツにblame情報をインクリメンタルに追加します。

このアクションは、パフォーマンス上の理由からデフォルトでは無効になっています。

@item  commit 
@itemx  commitdiff 
リポジトリ内の特定のコミットに関する情報を表示します。 @samp{commit} ビューにはコミットに関する情報がより詳細に表示され、 @samp{commitdiff} アクションには特定のコミットの変更セットが表示されます。

@item  patch 
git-am(1) で適用するのに適した、プレーンテキストのメール形式でコミットを返します。

@item  tag 
特定の注釈付きタグ(タグオブジェクト)を表示します。

@item  log 
@itemx  shortlog 
(特定のリビジョンから開始の)特定のブランチのログ情報(コミットメッセージまたはコミット件名)を表示します。

shortlogビューはよりコンパクトです。1行に1つのコミットが表示されます。

@item  history 
指定されたリビジョンから開始して、指定されたリポジトリパス内のファイルまたはディレクトリの履歴を表示します(デフォルトはHEAD、つまりデフォルトのブランチ)。

このビューは「shortlog」ビューに似ています。

@item  rss 
@itemx  atom 
リポジトリへの変更のRSS(またはAtom)フィードを生成します。
@end table

@noindent

@chapheading WEBSERVER CONFIGURATION

このセクションでは、gitwebを実行するようにいくつかの一般的なWebサーバーを構成する方法について説明します。いずれの場合も、例の @samp{/path/to/gitweb} は、インストールしたgitwebを実行したディレクトリであり、 @samp{gitweb_config.perl} を含んでいます。

あなたが、以下にリストされていない Web サーバーを gitweb 用に構成した場合は、将来のリリースに含めることができるように、ぜひ手順を送ってください。

@noindent

@heading Apache as CGI

Apacheは、gitwebがインストールされているディレクトリでCGIスクリプトをサポートするように設定する必要があります。 それが @samp{/var/www/cgi-bin} ディレクトリであると仮定しましょう。

@example
ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"

<Directory "/var/www/cgi-bin">
    Options Indexes FollowSymlinks ExecCGI
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>
@end example


この構成では、リポジトリをブラウズするためのフルパスは以下のようになります:

@example
http://server/cgi-bin/gitweb.cgi
@end example

@noindent

@heading Apache with mod_perl, via ModPerl::Registry

あなたはgitwebでmod_perlを使用できます。このサポートを有効にするには、mod_perl 1.xの場合は Apache::Registry をインストールする必要があり、また、 mod_perl 2.x の場合は ModPerl::Registry をインストールする必要があります。

gitwebが @samp{/var/www/perl} にインストールされていると仮定すると、以下のApache構成(mod_perl 2.xの場合)が適切です。

@example
Alias /perl "/var/www/perl"

<Directory "/var/www/perl">
    SetHandler perl-script
    PerlResponseHandler ModPerl::Registry
    PerlOptions +ParseHeaders
    Options Indexes FollowSymlinks +ExecCGI
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>
@end example


この構成では、リポジトリをブラウズするためのフルパスは以下のようになります:

@example
http://server/perl/gitweb.cgi
@end example

@noindent

@heading Apache with FastCGI

GitwebはApache＋FastCGIで動作します。 まず、 gitweb.cgiの名前を変更するか、コピーするか、シンボリックリンクして gitweb.fcgi にする必要があります。gitwebが @samp{/usr/share/gitweb} ディレクトリにインストールされていると仮定しましょう。以下のApache構成が適しています(スマン。これれはテストされていません！)

@example
FastCgiServer /usr/share/gitweb/gitweb.cgi
ScriptAlias /gitweb /usr/share/gitweb/gitweb.cgi

Alias /gitweb/static /usr/share/gitweb/static
<Directory /usr/share/gitweb/static>
    SetHandler default-handler
</Directory>
@end example


この構成では、リポジトリをブラウズするためのフルパスは以下のようになります:

@example
http://server/gitweb
@end example

@noindent

@chapheading ADVANCED WEB SERVER SETUP

これらの例はすべてリクエストの書き換えを使用しており、 @samp{mod_rewrite} (または同等のもの。以下の例はApache用に記述されています)が必要です。

@noindent

@heading Single URL for gitweb and for fetching

gitwebと あなたの @samp{http://} リポジトリの両方に1つのURLが必要な場合は、以下のようにApacheを構成できます:

@example
<VirtualHost *:80>
    ServerName    git.example.org
    DocumentRoot  /pub/git
    SetEnv        GITWEB_CONFIG   /etc/gitweb.conf

    # turning on mod rewrite
    RewriteEngine on

    # make the front page an internal rewrite to the gitweb script
    RewriteRule ^/$  /cgi-bin/gitweb.cgi

    # make access for "dumb clients" work
    RewriteRule ^/(.*\.git/(?!/?(HEAD|info|objects|refs)).*)?$ \
                /cgi-bin/gitweb.cgi%@{REQUEST_URI@}  [L,PT]
</VirtualHost>
@end example


The above configuration expects your public repositories to live under @samp{/pub/git} and will serve them as @samp{http://git.domain.org/dir-under-pub-git}, both as clonable Git URL and as browsable gitweb interface. If you then start your git-daemon(1) with @samp{--base-path=/pub/git --export-all} then you can even use the @samp{git://} URL with exactly the same path.

環境変数 @samp{GITWEB_CONFIG} を設定すると、名前付きファイル(つまり、この例では @samp{/etc/gitweb.conf})をgitwebの構成として使用するようにgitwebに指示します。 上記の例では、実際には必要ありません。構成ファイルが組み込み(gitwebのコンパイル中) や @samp{gitweb_config.perl} や @samp{/etc/gitweb.conf} とは異なる場所にある場合にのみ必要です。 詳細、特に優先順位ルールに関する情報については、 gitweb.conf(5) を参照してください。

あなたが例の書き換えルールを使用する場合は、gitweb構成ファイル(以下の例の @samp{/etc/gitweb.conf})に以下のようなものも必要になる場合があります:

@example
@@stylesheets = ("/some/absolute/path/gitweb.css");
$my_uri    = "/";
$home_link = "/";
$per_request_config = 1;
@end example


今どきでは、gitwebは必要に応じて、(相対リンクのベースURIを設定するために、)HTMLベースタグを作成する必要があるため、自動的に機能するはずです。

@noindent

@heading Webserver configuration with multiple projects' root

あなたが複数のプロジェクトルートでgitwebを使用する場合は、以下の方法でApache仮想ホストとgitweb構成ファイルを編集できます。

(Apache構成ファイル内の)仮想ホスト構成は以下のようになります:

@example
<VirtualHost *:80>
    ServerName    git.example.org
    DocumentRoot  /pub/git
    SetEnv        GITWEB_CONFIG  /etc/gitweb.conf

    # turning on mod rewrite
    RewriteEngine on

    # make the front page an internal rewrite to the gitweb script
    RewriteRule ^/$  /cgi-bin/gitweb.cgi  [QSA,L,PT]

    # look for a public_git directory in unix users' home
    # http://git.example.org/~<user>/
    RewriteRule ^/\~([^\/]+)(/|/gitweb.cgi)?$   /cgi-bin/gitweb.cgi \
                [QSA,E=GITWEB_PROJECTROOT:/home/$1/public_git/,L,PT]

    # http://git.example.org/+<user>/
    #RewriteRule ^/\+([^\/]+)(/|/gitweb.cgi)?$  /cgi-bin/gitweb.cgi \
                 [QSA,E=GITWEB_PROJECTROOT:/home/$1/public_git/,L,PT]

    # http://git.example.org/user/<user>/
    #RewriteRule ^/user/([^\/]+)/(gitweb.cgi)?$ /cgi-bin/gitweb.cgi \
                 [QSA,E=GITWEB_PROJECTROOT:/home/$1/public_git/,L,PT]

    # defined list of project roots
    RewriteRule ^/scm(/|/gitweb.cgi)?$ /cgi-bin/gitweb.cgi \
                [QSA,E=GITWEB_PROJECTROOT:/pub/scm/,L,PT]
    RewriteRule ^/var(/|/gitweb.cgi)?$ /cgi-bin/gitweb.cgi \
                [QSA,E=GITWEB_PROJECTROOT:/var/git/,L,PT]

    # make access for "dumb clients" work
    RewriteRule ^/(.*\.git/(?!/?(HEAD|info|objects|refs)).*)?$ \
                /cgi-bin/gitweb.cgi%@{REQUEST_URI@}  [L,PT]
</VirtualHost>
@end example


ここで、実際のプロジェクトルートはWebサーバーから @samp{GITWEB_PROJECT_ROOT} 環境変数を介してgitwebに渡されるため、gitweb構成ファイル(上記の例では @samp{/etc/gitweb.conf})に以下の行を入れる必要があります:

@example
$projectroot = $ENV@{'GITWEB_PROJECTROOT'@} || "/pub/git";
@end example


@strong{Note} これはリクエストごとに設定する必要があるため、
@samp{$ per_request_config} はfalseであるか、
上記を @samp{$per_request_config} によって参照されるコードに含める必要があります。

これらの構成により、2つのことが可能になります。 まず、サーバーの各UNIXユーザー(@samp{<user>})は、 @samp{~/public_git/} にある gitweb Gitリポジトリを以下のURLで参照できます:

@example
http://git.example.org/~<user>/
@end example

あなたがサーバーでこの機能を使用したくない場合は、2番目の書き換えルールを削除してください。

仮想ホストですでに @samp{mod_userdir} を使用している場合、または最初の文字として `~` を使用したくない場合は、2番目の書き換えルールをコメント化または削除し、必要に応じてそれ以降のいずれかをコメント化解除します。

次に、 @samp{/pub/scm/} と @samp{/var/git/} にあるリポジトリには、 @samp{http://git.example.org/scm/} と @samp{http://git.example.org/var/} からアクセスできます。3番目や4番目のような書き換えルールを追加することで、必要な数のプロジェクトルートを追加できます。

@noindent

@heading PATH_INFO usage

あなたがgitwebでPATH_INFOの使用を有効にするには以下のようにします

@example
$feature@{'pathinfo'@}@{'default'@} = [1];
@end example


あなたのgitweb構成ファイルで、あなたのサーバーが以下の形式のURLを消費および生成するようにサーバーを設定することができます

@example
http://git.example.com/project.git/shortlog/sometag
@end example

つまり、以下のような構成を使用して、 @samp{gitweb.cgi} 部分を使用しません。この構成では、 @samp{/var/www/gitweb} がWebサーバーのDocumentRootであり、gitweb.cgiスクリプトと補完的な静的ファイル(スタイルシート、favicon、JavaScript)が含まれていることを前提としています:

@example
<VirtualHost *:80>
        ServerAlias git.example.com

        DocumentRoot /var/www/gitweb

        <Directory /var/www/gitweb>
                Options ExecCGI
                AddHandler cgi-script cgi

                DirectoryIndex gitweb.cgi

                RewriteEngine On
                RewriteCond %@{REQUEST_FILENAME@} !-f
                RewriteCond %@{REQUEST_FILENAME@} !-d
                RewriteRule ^.* /gitweb.cgi/$0 [L,PT]
        </Directory>
</VirtualHost>
@end example


書き換えルールは、既存の静的ファイルが適切に提供されることを保証しますが、他のURLはPATH_INFOパラメーターとしてgitwebに渡されます。

@strong{注意} この場合、 @samp{@@stylesheets} と @samp{$my_uri} と @samp{$home_link} の特別な設定は必要ありません。
ただし、あなたのプロジェクトの .git ディレクトリへの「ダムクライアント」(dumb client)アクセスは失われます
(「Single URL for gitweb and for fetching」セクションで説明されています)。
後者の可能な回避策は次のとおりです。
つまり、あなたのプロジェクトのルートディレクトリ(例: @samp{/pub/git})に、
.git拡張子なしで名前を付けたプロジェクト(例: @samp{/pub/git/project.git} の代わりに @samp{/pub/git/project})を作成し、Apacheを以下のように構成します:

@example
<VirtualHost *:80>
        ServerAlias git.example.com

        DocumentRoot /var/www/gitweb

        AliasMatch ^(/.*?)(\.git)(/.*)?$ /pub/git$1$3
        <Directory /var/www/gitweb>
                Options ExecCGI
                AddHandler cgi-script cgi

                DirectoryIndex gitweb.cgi

                RewriteEngine On
                RewriteCond %@{REQUEST_FILENAME@} !-f
                RewriteCond %@{REQUEST_FILENAME@} !-d
                RewriteRule ^.* /gitweb.cgi/$0 [L,PT]
        </Directory>
</VirtualHost>
@end example


追加のAliasMatchにより、

@example
http://git.example.com/project.git
@end example

これはプロジェクトのGitディレクトリへの生のアクセスを提供します(プロジェクトのクローンを作成できるようにします)。

@example
http://git.example.com/project
@end example

これは人間に優しいgitwebアクセスを提供します。

この解決策100%安全ではありません。つまり、プロジェクトに @samp{git/} で始まる名前付きref(ブランチ、タグ)がある場合、以下のようなパスがあります

@example
http://git.example.com/project/command/abranch..git/abranch
@end example

これは404エラーで失敗します。

@noindent

@chapheading BUGS

お手数ですが、メールの件名に「gitweb」を入れて、@uref{mailto:バグや機能のリクエストをgit@@vger.kernel.orgに報告してください,バグや機能のリクエストをgit@@vger.kernel.orgに報告してください}。

@noindent

@chapheading SEE ALSO

gitweb.conf(5), git-instaweb(1)

@samp{gitweb/README}, @samp{gitweb/INSTALL}

@noindent

@chapheading GIT

Part of the git(1) suite

@node gitworkflows,,,Top
@chapheading Name

gitworkflows — Gitで推奨の作業手順の概要

@noindent

@chapheading Synopsis

@display
git *
@end display


@noindent

@chapheading DESCRIPTION

この文書は、 @samp{git.git} 自体に使用されるワークフロー要素のいくつかを書き留めて動機付けしようとしています。一般に多くのアイデアが当てはまりますが、関係者が少ない小規模なプロジェクトではこのような完全なワークフローが必要になることはめったにありません。

私たちが、すぐに参照できるように一連の「ルール」を作ったのは、本当にみんなのモチベーションを高めるためです。ですから常に文字通りに解釈する必要はありません。このような文章よりも、自分の行動に対する正当な理由を大切にしてください。

@noindent

@chapheading SEPARATE CHANGES

原則として、変更を小さな論理ステップに分割し、それぞれでコミットするようにしてください。それらは一貫性があり、その後のコミットとは独立して機能し、テストスイートに合格する必要があります。これにより、レビュープロセスがはるかに簡単になり、その履歴は、たとえば git-blame(1) や git-bisect(1)を使用して後で検査や分析する時にはるかに役立ちます。

これを実現するには、最初から作業を小さなステップに分割してみてください。1つの大きなコミットを複数に分割するよりも、いくつかのコミットをまとめる方が常に簡単です。途中で小さすぎる、または不完全なステップを作成することを恐れないでください。いつでも後で戻って、公開する前に @samp{git rebase --interactive} を使用してコミットを編集できます。 @samp{git stash push --keep-index} を使用して、他のコミットされていない変更とは無関係にテストスイートを実行できます。 git-stash(1) の「EXAMPLES」セクションを参照してください。

@noindent

@chapheading MANAGING BRANCHES

あるブランチから別のブランチへの変更を含めるために使用できる2つの主要なツールがあります。 git-merge(1) と git-cherry-pick(1) です。

マージには多くの利点があるため、マージだけで可能な限り多くの問題を解決しようとしています。 cherry-pickingまだ時々役に立ちます。例については、以下の「Merging upwards」を参照してください。

最も重要なことは、マージはブランチレベルで機能し、チェリーピッキングはコミットレベルで機能することです。これは、マージが1、10、または1000のコミットからの変更を同じように簡単に引き継ぐことができることを意味します。つまり、ワークフローは多数の貢献者(および貢献)に対してはるかに適切にスケーリングされます。マージコミットは、すべての親からのすべての変更が含まれた「約束」(promise)であるため、マージも理解しやすくなります。

もちろん、トレードオフがあります。マージには、より慎重なブランチ管理が必要です。以下のサブセクションでは、重要なポイントについて説明します。

@noindent

@heading Graduation

特定の機能が実験的なもの(experimental)から安定したもの(stable)に変わると、ソフトウェアの対応するブランチ間でも「段階的に」(graduates)移行します。 @samp{git.git} は以下の「統合ブランチ」(integration branches)を使用します:

@itemize 

@item
@samp{maint} は、次の「メンテナンスリリース」(maintenance release)、つまり最後にリリースされた安定バージョンの更新に入るコミットを追跡します

@item
@samp{master} は、次のリリースに入る予定のコミットを追跡します。

@item
@samp{next} は、masterの安定性をテストするトピックのテストブランチとして意図されています。
@end itemize

少し異なる方法で使用される4番目の公式ブランチがあります:

@itemize 

@item
@samp{seen} (メンテナによって表示されるパッチ)は、まだ含める準備が整っていないモノの統合ブランチです(以下の「Integration Branches」を参照)。
@end itemize

4つのブランチのそれぞれは、通常、その上のブランチの直接の子孫です。

概念的には、機能(feature)は不安定なブランチ(通常は「next」または「seen」)に入り、十分に安定している(stable)と見なされると、次のリリースのために「master」に「卒業」(graduates)します。

@noindent

@heading Merging upwards

上記の「downwards graduation」(下向きの卒業)は、実際に下向きにマージすることによって実行することはできません。なぜなら、不安定なブランチの「すべての」変更が安定したブランチにマージされるためです。 したがって、以下のようになります:

@strong{Merge upwards}

修正を必要とするサポートされている最も古いブランチに常に修正をコミットします。 次に、 (定期的に)統合ブランチを互いに上向きにマージします。

これにより、修正のフローが非常によく制御されます。たとえば、修正を適用したことに気付いた場合。 @samp{maint} でも必要な @samp{master} は、(git-cherry-pick(1) を使用して)下向きにチェリーピックする必要があります。これは数回発生しますが、頻繁に実行しない限り心配する必要はありません。

@noindent

@heading Topic branches

重要な機能を実装するにはいくつかのパッチが必要であり、その存続期間中に追加のバグ修正または改善が行われる可能性があります。

統合ブランチですべてを直接コミットすると、多くの問題が発生します。不正なコミットは元に戻せないため、1つずつ元に戻す必要があります。これにより、変更のグループの一部を元に戻すのを忘れると、混乱した履歴とエラーが発生する可能性があります。並行して作業すると、変更がごちゃまぜになり、さらに混乱が生じます。

「topic branches」(トピックブランチ)を使用すると、これらの問題が解決されます。名前はかなり自明ですが、上記の「merge upwards」(上向きにマージ)ルールに由来する警告があります:

@strong{Topic branches}

すべてのトピック(機能、バグ修正など)のサイドブランチを作成します。最終的にマージする最も古い統合ブランチでフォークします。

そうすれば、以下のように多くのことが非常に自然に実行できます:

@itemize 

@item
機能/バグ修正を統合ブランチに取り込むには、それをマージするだけです。その間にトピックがさらに進化した場合は、再度マージしてください。 (必ずしも最初に最も古い統合ブランチにマージする必要はないことに注意してください。たとえば、最初にバグ修正を next にマージし、テスト時間を与え、安定していることがわかったら maint にマージできます。)

@item
トピックの作業を続行するためにブランチ other の新機能が必要な場合は、 other を topic にマージします。 (ただし、これを「習慣的に」行わないでください。以下を参照してください。)

@item
分岐したブランチが間違っていることに気づき、それを「過去にさかのぼって」移動したい場合は、 git-rebase(1) を使用してください。
@end itemize

注意: 最後の項目が他の2つと衝突することに注意してください。他の場所でマージされたトピックは、リベースしないでください。 git-rebase(1) の「RECOVERING FROM UPSTREAM REBASE」に関するセクションを参照してください。

(通常は理由もなく)「習慣的に」統合ブランチをあなたのトピックにマージすること(つまり、トピックを拡張し、定期的に上流からマージし続けること)は眉をひそめられる行為であることを指摘しておく必要があります。

@strong{明確に定義されたポイントでのみ下流にマージします}

正当な理由がある場合を除いて、ダウンストリームにマージしないでください。正当な理由とは、例えば、アップストリームAPIの変更がブランチに影響する、ブランチがアップストリームにきれいにマージされなくなりました、等です。

正当な理由以外の場合、マージされたトピックには、(激しくバラバラの)突然の複数の変更が含まれます。結果として生じる多くの小さなマージは、履歴を大幅に混乱させます。後でファイルの履歴を調査する人は、そのマージが開発中のトピックに影響を与えたかどうかを確認する必要があります。アップストリームは、誤って「より安定した」ブランチにマージされることさえあるかも等々。

@noindent

@heading 使い捨て統合

先程の話題についていうと、多くの小さなトピックブランチがあり、あなたはそれらがどのように相互作用するのかワケワカメに思うことがあるでしょう。それらをマージしたらちゃんと機能しないかも？ そして、このようなマージは簡単に元に戻せないため、我々はこれらに対して「安定した」場所でのマージは避けたいと考えています。

もちろん、解決策は、元に戻すことができるマージを作成することです。つまり、使い捨てブランチ(throw-away branch)にマージします。

@strong{Throw-away integration branches}

いくつかのトピックの相互作用をテストするには、それらを使い捨てのブランチにマージします。あなたは決してそのようなブランチに基づいて作業を行ってはいけません！

テストの直後にこのブランチが削除されることを(非常に)明確にすると、このブランチを公開して、たとえば、テスターがこのブランチを操作できるようにしたり、他の開発者が進行中の作業に互換性があるかどうかを確認したりすることもできます。 @samp{git.git} には、「seen」と呼ばれるそのような公式の使い捨て統合ブランチがあります。

@noindent

@heading Branch management for a release

上記のマージアプローチを使用していると仮定すると、プロジェクトをリリースするときに、追加のブランチ管理作業を行う必要があります。

「master」は次の機能(feature)リリースに入るコミットを追跡するため、機能(feature)リリースは「master」ブランチから作成されます。

master ブランチは、 maint のスーパーセットであると想定されています。この条件が満たされない場合、 maint には master に含まれていないコミットが含まれています。したがって、 maint のコミットによって表される修正は、機能(feature)リリースには含まれません。

master が実際に maint のスーパーセットであることを確認するには、 @samp{git log} を使用します:

@strong{master が maint のスーパーセットであることを確認(verify)します:}

@samp{git log master..maint}

このコマンドは、コミットを一切リストしないはずです。そうでない場合は、「master」をチェックアウトし、「maint」をマージします。

これで、あなたは機能(feature)リリースの作成に進むことができます。リリースバージョンを示すタグを「master」の先端に適用します:

@strong{Release tagging}

@samp{git tag -s -m "Git X.Y.Z" vX.Y.Z master}

あなたは新しいタグをパブリックGitサーバーにプッシュする必要があります(以下の「DISTRIBUTED WORKFLOWS」参照)。これにより、プロジェクトを追跡している他のユーザーがタグを利用できるようになります。プッシュでは、更新後のフックをトリガーして、リリースtarballの作成や事前にフォーマットされたドキュメントページなどのリリース関連の項目を実行することもできます。

同様に、メンテナンスリリースの場合、「maint」はリリースされるコミットを追跡します。ゆえに、タグのリリース手順では、「master」ではなく「maint」にタグを付けてプッシュするだけです。

@noindent

@heading 機能リリース後のメンテナンスブランチ管理

機能(feature)リリース後、あなたはメンテナンスブランチを管理する必要があります。

まず、直近のリリースより前に行われた機能リリースのメンテナンス修正を引き続きリリースする場合は、その前のリリースのコミットを追跡するために別のブランチを作成する必要があります。

これを行うために、現在のメンテナンスブランチは、以前のリリースバージョン番号で名前が付けられた別のブランチにコピーされます(例: maint-X.Y.(Z-1) ここでX.Y.Zは現在のリリースとする)。

@strong{Copy maint}

@samp{git branch maint-X.Y.(Z-1) maint}

maint ブランチは、新しくリリースされたコードに早送り(fast-forwarded)され、現在のリリースのメンテナンス修正を追跡できるようになります:

@strong{Update maint to new release}

@itemize 

@item
@samp{git checkout maint}

@item
@samp{git merge --ff-only master}
@end itemize

早送り(fast-forwarded)ではないためにマージが失敗した場合は、機能リリースで「maint」のいくつかの修正が欠落している可能性があります。前のセクションで説明したようにブランチのコンテンツを検証(verify)した場合、これは発生しません。

@noindent

@heading 機能リリース後の「next」と「seen」のブランチ管理

機能のリリース後、統合ブランチ next は、オプションで、 next の残りのトピックを使用して、 master の先端から巻き戻されて再構築される場合があります:

@strong{Rewind and rebuild next}

@itemize 

@item
@samp{git switch -C next master}

@item
@samp{git merge ai/topic_in_next1}

@item
@samp{git merge ai/topic_in_next2}

@item
…
@end itemize

これを行うことの利点は、「next」の履歴がクリーンになることです。 たとえば、「next」にマージされた一部のトピックは、最初は有望に見えたかもしれませんが、後で望ましくないか時期尚早であることがわかりました。このような場合、トピックは「next」から元に戻され(revert)ますが、一度マージされて元に戻されたという事実は履歴に残ります。「next」を再作成することで、そのようなトピックの別の化身に再試行するためのきれいな状態を与えることができます。機能のリリースは、これを行うための履歴上の良い地点です。

これを行う場合は、「next」が巻き戻されて再構築されたことを示す公開アナウンスを行う必要があります。

「seen」についても、同じの巻き戻しと再構築のプロセスを行います。なお、上記のとおり「seen」は使い捨てのブランチであるため、公の発表は必要ありません。

@noindent

@chapheading DISTRIBUTED WORKFLOWS

前セクションを読んだ今となっては、あなたはトピックを管理する方法を知っておくべきです。 一般的に、プロジェクトに取り組んでいるのはあなただけではないので、あなたの仕事は共有しなければなりません。

大まかに言えば、マージとパッチという2つの重要な作業フローがあります。重要な違いは、マージ作業フローはマージを含む完全な履歴を伝播できますが、パッチは伝播できないことです。両方の作業フローを並行して使用できます。@samp{git.git} では、サブシステムメンテナのみがマージ作業フローを使用し、他のすべての作業フローはパッチを送信します。

注意: メンテナは、インクルードするために提出されたすべてのコミット/パッチが遵守しなければならない「Signed-off-by」要件などの制限を課すことができることに注意してください。より詳細な情報については、プロジェクトのドキュメントを参照してください。

@noindent

@heading Merge workflow

マージ作業フローは、上流(upstream)と下流(downstream)の間でブランチをコピーすることによって機能します。上流では、貢献の結果を公式の履歴に統合することができます。下流では、公式の履歴に基づいて作業します。

これに使用できる主なツールは3つあります:

@itemize 

@item
git-push(1) は、ブランチをリモートリポジトリにコピーします。通常は、関係者全員が読み取れるリポジトリにコピーします。

@item
git-fetch(1) は、リモートブランチをあなたのリポジトリにコピーします。

@item
git-pull(1) は、フェッチしてマージするのを一度に行います。
@end itemize

注意: 最後の点に注意してください。 実際にリモートブランチをマージする場合を除いて @samp{git pull} を使用しないでください。

変更を取得するのは簡単です:

@strong{push/pull: branches/topics の公開}

@samp{git push <remote> <branch>} を実行、そして、どこからフェッチできるかをみんなに伝えます。

あなたは今の所メールなどの他の手段で人々に伝えなければなりません。 (Gitは git-request-pull(1) を提供して、このタスクを簡素化するために、事前にフォーマットされたプルリクエストをアップストリームのメンテナーに送信します。 )

統合ブランチの最新のコピーを取得したいだけの場合は、最新の状態に保つのも簡単です:

@strong{push/pull: 最新の状態に保つ}

最新の状態に保つには @samp{git fetch <remote>} または @samp{git remote update} を使います。

次に、以前に説明したように、安定したリモートからトピックブランチをフォークするだけです。

あなたがメンテナであり、他の人のトピックブランチを統合ブランチにマージしたい場合、他の人々は通常、メールでそうするようにリクエストを送信してきます。そのようなリクエストは以下のようになります

@example
Please pull from
    <URL> <branch>
@end example


その場合、 @samp{git pull} は、以下のように、フェッチとマージを一度に実行できます。

@strong{Push/pull: Merging remote topics}

@samp{git pull <URL> <branch>}

場合によっては、メンテナが下流(downstream)から変更をプルしようとすると、マージの競合が発生することがあります。 この場合、下流にマージを実行して競合を彼ら自身で解決するように依頼できます(おそらく、彼らは競合を解決する方法をよりよく知っているでしょう)。これは、下流が上流(upsteram)からマージする必要があるまれなケースの1つです。

@noindent

@heading Patch workflow

あなたが変更を電子メールの形式でアップストリームに送信する貢献者の場合は、通常どおりトピックブランチを使用する必要があります(上記参照)。 次に、 git-format-patch(1) を使用して、対応する電子メールを生成します(メンテナの作業が楽になるため、手動でフォーマットするよりもこれを使うのを強く推奨します)。

@strong{format-patch/am: Publishing branches/topics}

@itemize 

@item
@samp{git format-patch -M upstream..topic} を使用して、事前に形式が決まっているパッチファイルに変換します

@item
@samp{git send-email --to=<recipient> <patches>}
@end itemize

使用上の注意については、 git-format-patch(1) と git-send-email(1) のmanpageを参照してください。

あなたのパッチがもはや現在の上流(upstream)に適用されなくなったとメンテナが告げた場合は、トピックをリベースする必要があります(format-patch マージができないため、マージを使用できません):

@strong{format-patch/am: Keeping topics up to date}

@samp{git pull --rebase <URL> <branch>}

あなたはその後、リベース中に競合を修正できます。おそらくあなたはメール以外であなたのトピックを公開していないので、それをリベースすることは問題ではありません。

あなたがこのようなパッチシリーズを受け取った場合(メンテナとして、または送信先のメーリングリストの読者として)、メールをファイルに保存し、新しいトピックブランチを作成し、 @samp{git am} を使用してコミットをインポートします:

@strong{format-patch/am: Importing patches}

@samp{git am < patch}

指摘する価値のある機能の1つは、競合が発生した場合に役立つ3方向マージです。 @samp{git am -3} は、パッチに含まれるインデックス情報を使用して、マージベースを把握します。他のオプションについては git-am(1) を参照してください。

@noindent

@chapheading SEE ALSO

gittutorial(7), git-push(1), git-pull(1), git-merge(1), git-rebase(1), git-format-patch(1), git-send-email(1), git-am(1)

@noindent

@chapheading GIT

Part of the git(1) suite

@node scalar,,,Top
@chapheading Name

scalar — 大規模 Git リポジトリ管理ツール

@noindent

@chapheading Synopsis

@display
scalar clone [--single-branch] [--branch <main-branch>] [--full-clone] <url> [<enlistment>]
scalar list
scalar register [<enlistment>]
scalar unregister [<enlistment>]
scalar run ( all | config | commit-graph | fetch | loose-objects | pack-files ) [<enlistment>]
scalar reconfigure [ --all | <enlistment> ]
scalar diagnose [<enlistment>]
scalar delete <enlistment>
@end display


@noindent

@chapheading DESCRIPTION

Scalar は、 大規模なリポジトリで使用するために Git を最適化するリポジトリ管理ツールです。 Scalar は、 高度な Git 設定を構成し、 バックグラウンドでリポジトリを保守し、 ネットワーク経由で送信されるデータを削減することで、 パフォーマンスを向上させます。

Scalar の重要な発想が enlistment です。 enlistment はプロジェクトの最上位ディレクトリで、 通常、 Gitワークツリーであるサブディレクトリ @samp{src/} を含んでいます。 これにより、 追跡対象のファイル (@samp{src/} 内) と、 ビルド生成物 (@samp{src/} の外部) などの追跡対象外のファイルとの分離が促進されます。 名前が @samp{src} ではない既存の Git ワークツリーを Scalar に登録(register)すると、 enlistment はワークツリーと同等になります。

@samp{scalar} コマンドは、さまざまなサブコマンドと、 サブコマンドに応じたさまざまなオプションを実装します。 @samp{clone} と @samp{list} と @samp{reconfigure --all} を除いて、 すべてのサブコマンドは enlistment の下で実行されることを想定しています。

以下のオプションはサブコマンドの「前で」指定可能です:

@table @asis

@item  @samp{-C <directory>} 
サブコマンドを実行する前に、 作業ディレクトリ(working directory)を変更してください。 このオプションは、 git(1) の同じオプションを模倣します。

@item  @samp{-c <key>=<value>} 
指定したサブコマンドを実行している間、 この設定を構成(configure)します。 このオプションは、 git(1) の同じオプションを模倣します。
@end table

@noindent

@chapheading COMMANDS

@noindent

@heading Clone

@table @asis

@item  @samp{clone [<options>] <url> [<enlistment>]} 
git-clone(1) と同様に、 指定のリポジトリのクローンを作成します。 デフォルトでは、 コミットおよびツリー・オブジェクトのみがクローンされます。 完了すると、 ワークツリーは @samp{<enlistment>/src} に配置されます。

(@samp{--full-clone} で実行した場合を除き、)スパース・チェックアウト機能が有効になり、存在するファイルは最上位ディレクトリにあるファイルのみです。 @samp{git sparse-checkout set} を使用してあなたが表示したいディレクトリのセットを展開するか、 または @samp{git sparse-checkout disable} を使用してすべてのファイルを展開します(詳細については、 git-sparse-checkout(1) を参照してください)。 @samp{git ls-tree HEAD[:<directory>]} を使用して、 あなたのスパースチェックアウトの外側のサブディレクトリを調べることができます。

@item  @samp{-b <name>} 
@itemx  @samp{--branch <name>} 
クローンされたリポジトリの HEAD が指すブランチをチェックアウトする代わりに、 @samp{<name>} ブランチをチェックアウトします。

@item  @samp{--[no-]single-branch} 
@samp{--branch} オプションで指定されるか、 プライマリ・ブランチ・リモートの @samp{HEAD} が指す、 単一のブランチの先端につながる履歴のみをクローンします。

結果のリポジトリへの更なるフェッチは、 最初のクローン作成時に、このオプションが使われたブランチのリモート追跡ブランチのみが更新されます。 @samp{--single-branch} クローンが作成されたときに、 リモートの HEAD がどのブランチも指していなかった場合、 リモート追跡ブランチは作成されません。

@item  @samp{--[no-]full-clone} 
デフォルトでスパース・チェックアウトは初期化(initialized)されます。 この動作は、 @samp{--full-clone} でオフにすることができます。
@end table

@noindent

@heading List

@table @asis

@item  list 
Scalar によって現在登録(register)されている enlistment を一覧表示します。 このサブコマンドは、 enlistment 内で実行する必要はありません。
@end table

@noindent

@heading Register

@table @asis

@item  @samp{register [<enlistment>]} 
enlistment のリポジトリを登録済みリポジトリ(registered repositories)のリストに追加し、 バックグラウンド・メンテナンスを開始します。 @samp{<enlistment>} が指定されていない場合、 現在の作業ディレクトリに関連付けられた enlistment が登録(registere)されます。

注意: このサブコマンドが @samp{src/} と呼ばれるワークツリーで呼び出されると、 その親ディレクトリは Scalar enlistment と見なされます。 ワークツリーが @samp{src/} と呼ばれ「無い」場合、それ自体が Scalar enlistment であると見なされます。
@end table

@noindent

@heading Unregister

@table @asis

@item  @samp{unregister [<enlistment>]} 
Scalar に登録(register)されているリポジトリのリストから指定されたリポジトリを削除し、 スケジュールされたバックグラウンド・メンテナンスを停止します。
@end table

@noindent

@heading Run

@table @asis

@item  @samp{scalar run ( all | config | commit-graph | fetch | loose-objects | pack-files ) [<enlistment>]} 
指定されたメンテナンス・タスク (@samp{all} が指定されている場合はすべてのタスク) を実行します。 このサブコマンドは @samp{all} と @samp{config} を除いて、 単純に git-maintenance(1) に渡します (@samp{fetch} を @samp{prefetch} に、 @samp{pack-files} を @samp{incremental-repack} にマッピングします)。

これらのタスクは、リポジトリが Scalar に登録されるとすぐに、スケジュールされたメンテナンスの一部として自動的に実行されます。 したがって、このサブコマンドを手動で実行する必要はありません。

@samp{config} タスクは Scalar 固有であり、 Git が大規模なリポジトリでより効率的に動作するように、 独自のデフォルト設定のすべてを構成します。 このタスクは @samp{scalar clone} の一部として自動的に実行されるため、 このタスクを明示的に呼び出す必要はほとんどありません。
@end table

@noindent

@heading Reconfigure

Scalar のアップグレード後、または Scalar enlistment の構成が何らかの形で破損または誤って変更された場合、 このサブコマンドを使用して enlistment を再構成できます。

@samp{--all} オプションを使用すると、 現在 Scalar に登録されているすべての enlistment が再構成されます。 Scalar アップグレード後毎にこのオプションを使用します。

@noindent

@heading Diagnose

@table @asis

@item  @samp{diagnose [<enlistment>]} 
Scalar に関する問題を報告する場合、 現在の enlistment のデータ形状を説明するログや特定の統計など、 このコマンドによって収集された情報を提供すると役立つことがよくあります。

このコマンドの出力は、 @samp{src} ディレクトリのワークツリーに隣接するディレクトリに書き込まれる @samp{.zip} ファイルです。
@end table

@noindent

@heading Delete

@table @asis

@item  @samp{delete <enlistment>} 
このサブコマンドを使用すると、 ローカル・ファイル・システムから既存の Scalar enlistment を削除して、 リポジトリを登録解除(unregister)できます。
@end table

@noindent

@chapheading SEE ALSO

git-clone(1), git-maintenance(1).

@noindent

@chapheading GIT

Part of the git(1) suite

@bye
