<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>gitformat-pack(5)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
gitformat-pack(5) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>gitformat-pack -
   Gitパック形式
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content">$GIT_DIR/objects/pack/pack-<strong>.{pack,idx}
$GIT_DIR/objects/pack/pack-</strong>.rev
$GIT_DIR/objects/pack/pack-*.mtimes
$GIT_DIR/objects/pack/multi-pack-index</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>Git パック形式は現在、Git のプライマリ・リポジトリ・データのほとんどを格納しています。 リポジトリの存続期間中、(もしあれば)緩いオブジェクトと小さなパックは、より大きなパック達に統合されていきます。 <a href="git-gc.html">git-gc(1)</a> と <a href="git-pack-objects.html">git-pack-objects(1)</a> を参照してください。</p></div>
<div class="paragraph"><p>パック形式は通信(over-the-wire)でも使用されます。 たとえば <a href="gitprotocol-v2.html">gitprotocol-v2(5)</a> を参照して下さい。 そして、 <a href="gitformat-bundle.html">gitformat-bundle(5)</a> では他のコンテナ形式の一部です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_checksums_and_object_ids">Checksums and object IDs</h2>
<div class="sectionbody">
<div class="paragraph"><p>従来のSHA-1を使用するリポジトリでは、以下で説明するパックチェックサム、インデックスチェックサム、およびオブジェクトID(オブジェクト名)はすべてSHA-1を使用して計算されます。 同様に、SHA-256リポジトリでは、これらの値はSHA-256を使用して計算されます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pack_pack_files_have_the_following_format">pack-*.pack files have the following format:</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
ヘッダーは最初にあらわれ、以下のもので構成されます
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
4-byte シグネチャ
</dt>
<dd>
<p>
  The signature is: {<code>P</code>, <code>A</code>, <code>C</code>, <code>K</code>}
</p>
</dd>
<dt class="hdlist1">
4-byte version number (network byte order)
</dt>
<dd>
<p>
  Gitは現在バージョン番号2または3を受け入れますが、バージョン2のみを生成します。
</p>
</dd>
<dt class="hdlist1">
4-byte パックに含まれるオブジェクトの数(network byte order)
</dt>
<dd>
<p>
  所見: このバージョンでは、パック内のオブジェクトは4Gを超えることはできず、パックも4Gを超えることはできません。
</p>
</dd>
</dl></div>
</li>
<li>
<p>
ヘッダーの後には、オブジェクトエントリの数が続き、各エントリは以下のようになります
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
(非デルタ化表現)
</dt>
<dd>
<p>
  n-byte type and length (type:3ビット幅、length: (n-1)*7+4 ビット幅)
</p>
<div class="paragraph"><p>圧縮データ</p></div>
</dd>
<dt class="hdlist1">
(デルタ化表現)
</dt>
<dd>
<p>
  n-byte type and length (type:3ビット幅、length: (n-1)*7+4 ビット幅)
</p>
<div class="paragraph"><p>OBJ_REF_DELTAの場合はベースオブジェクト名、OBJ_OFS_DELTAオブジェクトの場合はパック内のデルタオブジェクトの位置からの負の相対オフセット</p></div>
<div class="paragraph"><p>圧縮デルタデータ</p></div>
</dd>
</dl></div>
</li>
<li>
<p>
所見: 各オブジェクトの長さは可変長形式でエンコードされ、32ビットなどに制限されません。
</p>
</li>
<li>
<p>
トレーラー(trailer)は、上記のすべてのパックチェックサムを記録します。
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="_object_types">Object types</h3>
<div class="paragraph"><p>有効なオブジェクトタイプは以下のとおりです:</p></div>
<div class="ulist"><ul>
<li>
<p>
OBJ_COMMIT (1)
</p>
</li>
<li>
<p>
OBJ_TREE (2)
</p>
</li>
<li>
<p>
OBJ_BLOB (3)
</p>
</li>
<li>
<p>
OBJ_TAG (4)
</p>
</li>
<li>
<p>
OBJ_OFS_DELTA (6)
</p>
</li>
<li>
<p>
OBJ_REF_DELTA (7)
</p>
</li>
</ul></div>
<div class="paragraph"><p>タイプ5は、将来の拡張用に予約されています。 タイプ0は無効です。</p></div>
</div>
<div class="sect2">
<h3 id="_size_encoding">Size encoding</h3>
<div class="paragraph"><p>このドキュメントでは、負でない整数で、「サイズエンコーディング」(size encoding)を使用します。つまりそれは、 各バイトから、下位7ビットを使用して結果の整数を形成します。 最上位ビットが1である限り、この処理は続行されます。 MSB 0 のバイトは、最後の7ビットを提供します。これら7ビットのチャンクは連結されます。 後の値の方が上位です。</p></div>
<div class="paragraph"><p>このサイズエンコーディング(size encoding)を、このドキュメントでも使用されている「オフセットエンコーディング」(offset encoding)と混同しないでください。</p></div>
</div>
<div class="sect2">
<h3 id="_deltified_representation_デルタ化表現">Deltified representation(デルタ化表現)</h3>
<div class="paragraph"><p>概念的には、commit、tree、tag、blobの4つのオブジェクトタイプしかありません。 ただし、スペースを節約するために、オブジェクトを別の「ベース」(base)オブジェクトの「デルタ」(delta)として格納できます。 これらの表現には、パックファイルでのみ有効な新しいタイプの ref-delta および ofs-delta が割り当てられます。</p></div>
<div class="paragraph"><p>ofs-deltaとref-deltaはどちらも、オブジェクトを再構築するために別のオブジェクト(「ベースオブジェクト」と呼ばれる)に適用される「デルタ」を格納します。 それらの違いは、ref-deltaがベースオブジェクト名を直接エンコードすることです。 ベースオブジェクトが同じパックにある場合、ofs-deltaは代わりにパック内のベースオブジェクトのオフセットをエンコードします。</p></div>
<div class="paragraph"><p>同一パックに含まれている場合は、ベースオブジェクトを削除することもできます。 ref-deltaは、パック外のオブジェクト(つまり、いわゆる「薄いパック」(thin pack)）を参照することもできます。 ただし、ディスクに保存する場合は、循環依存を回避するためにパックを自己完結型にする必要があります。</p></div>
<div class="paragraph"><p>デルタデータは、ベースオブジェクトのサイズと再構築されるオブジェクトのサイズから始まります。 これらのサイズは、上記サイズエンコーディングを使用してエンコードされます。 デルタデータの残りの部分は、ベースオブジェクトからオブジェクトを再構築するための一連の命令です。 ベースオブジェクトが削除されている場合は、最初に標準形に変換する必要があります。 各命令は、完了するまでターゲットオブジェクトにどんどんデータを追加します。現時点でサポートされている命令は2つあります。1つはソースオブジェクトからバイト範囲をコピーするためのもので、もう1つは命令自体に埋め込まれた新しいデータを挿入するためのものです。</p></div>
<div class="paragraph"><p>各命令の長さは可変です。 命令タイプは、最初のオクテット(訳注:1バイト(8ビット))のビット7(訳注:つまりこのバイトの最上位ビット)によって決定されます。 以下の図は、RFC 1951（Deflate compressed data format;圧縮データ形式の解凍）の規則に従います。</p></div>
<div class="sect3">
<h4 id="_ベースオブジェクトからのコピー命令">ベースオブジェクトからのコピー命令</h4>
<div class="literalblock">
<div class="content">
<pre><code>+----------+---------+---------+---------+---------+-------+-------+-------+
| 1xxxxxxx | offset1 | offset2 | offset3 | offset4 | size1 | size2 | size3 |
+----------+---------+---------+---------+---------+-------+-------+-------+</code></pre>
</div></div>
<div class="paragraph"><p>これは、ソースオブジェクトからバイト範囲をコピーするための命令です。 コピー元のオフセットとコピーするバイト数をエンコードします。 オフセットとサイズはリトルエンディアンです。</p></div>
<div class="paragraph"><p>すべてのオフセットバイトとサイズバイトはオプションです。 これは、小さなオフセットまたはサイズをエンコードするときに命令サイズを減らすためです。 最初のオクテットの最初の7つのビット(訳注:bit6〜0)は、次の7つのオクテットのどれが存在するかを決定します。 ビットゼロが設定されている場合、offset1が存在します。 ビット1が設定されている場合、offset2が存在します。</p></div>
<div class="paragraph"><p>注意: よりコンパクトな形式は、オフセットとサイズのエンコーディングを変更しないことに注意してください。 たとえば、以下のようにoffset2のみが省略されている場合でも、offset3にはビット16〜23が含まれています。 それはoffset1の隣に続くからoffset2という訳ではなくて、(offset3の)ビット8〜15が含まれています。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>+----------+---------+---------+
| 10000101 | offset1 | offset3 |
+----------+---------+---------+</code></pre>
</div></div>
<div class="paragraph"><p>最もコンパクトな形式では、この命令はオフセットとサイズの両方が省略された1バイト(0x80)のみを使用し、デフォルト値はゼロになります。 もうひとつ例外があります。サイズゼロは自動的に 0x10000 に変換されます。</p></div>
</div>
<div class="sect3">
<h4 id="_新データ追加命令">新データ追加命令</h4>
<div class="literalblock">
<div class="content">
<pre><code>+----------+============+
| 0xxxxxxx |    data    |
+----------+============+</code></pre>
</div></div>
<div class="paragraph"><p>これは、ベースオブジェクトなしでターゲットオブジェクトを構築するための命令です。続くデータがターゲットオブジェクトに追加されます。最初のオクテットの最初の7つのビット(訳注:bit6〜0)は、データのサイズをバイト単位で決定します。サイズはゼロ以外でなければなりません。</p></div>
</div>
<div class="sect3">
<h4 id="_reserved_instruction">Reserved instruction</h4>
<div class="literalblock">
<div class="content">
<pre><code>+----------+============
| 00000000 |
+----------+============</code></pre>
</div></div>
<div class="paragraph"><p>これは、将来の拡張のために予約されている命令です。</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_original_version_1_pack_idx_files_have_the_following_format">Original (version 1) pack-*.idx files have the following format:</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
ヘッダーは、256個の4バイトのネットワークバイトオーダー整数で構成されます。このテーブルのN番目のエントリは、対応するパック内のオブジェクトの数を記録します。オブジェクト名の最初のバイトはN以下です。これは、「first-level fan-out」テーブルと呼ばれます。
</p>
</li>
<li>
<p>
ヘッダーの後には、ソートされた24バイトのエントリが続きます(パック内のオブジェクトごとに1つのエントリ)。 各エントリは以下のとおりです:
</p>
<div class="ulist"><ul>
<li>
<p>
4-byte ネットワークバイトオーダー整数で、オブジェクトが格納されている場所をパックファイル先頭からのオフセットとして記録します。
</p>
</li>
<li>
<p>
適切なサイズの1つのオブジェクト名。
</p>
</li>
</ul></div>
</li>
<li>
<p>
ファイルはトレーラーで締めくくられています:
</p>
<div class="paragraph"><p>対応するパックファイルの最後にあるパックチェックサムのコピー。</p></div>
</li>
<li>
<p>
上記すべてのインデックスチェックサム。
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="_パックidxファイル">パックIdxファイル:</h3>
<div class="listingblock">
<div class="content">
<pre><code>        --  +--------------------------------+
fanout      | fanout[0] = 2 (for example)    |-.
table       +--------------------------------+ |
            | fanout[1]                      | |
            +--------------------------------+ |
            | fanout[2]                      | |
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
            | fanout[255] = total objects    |---.
        --  +--------------------------------+ | |
main        | offset                         | | |
index       | object name 00XXXXXXXXXXXXXXXX | | |
table       +--------------------------------+ | |
            | offset                         | | |
            | object name 00XXXXXXXXXXXXXXXX | | |
            +--------------------------------+&lt;+ |
          .-| offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | +--------------------------------+   |
          | | offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   |
          | | offset                         |   |
          | | object name FFXXXXXXXXXXXXXXXX |   |
        --| +--------------------------------+&lt;--+
trailer   | | packfile checksum              |
          | +--------------------------------+
          | | idxfile checksum               |
          | +--------------------------------+
          .-------.
                  |
Pack file entry: &lt;+</code></pre>
</div></div>
<div class="paragraph"><p>パックされたオブジェクトのヘッダー:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
byte size extension bit (MSB)
</dt>
<dd>
<div class="ulist"><ul>
<li>
<p>
type (next 3 bit)
</p>
</li>
<li>
<p>
size0 (lower 4-bit)
</p>
</li>
<li>
<p>
n-byte sizeN (MSBがセットされている限り。各7ビット) size0..sizeN form 4+7+7+..+7 ビット整数で、size0 は最も下位で、 sizeN が最も上位です。
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
パックされたオブジェクトのデータ
</dt>
<dd>
<div class="ulist"><ul>
<li>
<p>
DELTAでない場合は、解凍されたバイト(上記のサイズは圧縮前のサイズです)。
</p>
</li>
<li>
<p>
REF_DELTAの場合、ベースオブジェクト名(上記サイズは後続のデルタデータのサイズです)。
</p>
</li>
<li>
<p>
圧縮されたデルタデータ。
</p>
</li>
<li>
<p>
OFS_DELTAの場合、nバイトオフセット(以下参照)は、ofs-deltaエントリのヘッダーのタイプバイトからの負のオフセットとして解釈されます(上記サイズは、後続のデルタデータのサイズです)。
</p>
</li>
<li>
<p>
圧縮されたデルタデータ。
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
offset encoding
</dt>
<dd>
<p>
    最後の1つを除くすべてにMSBが設定されたnバイト。 オフセットは、各バイトの下位7ビットを連結して作成された数値であり、n &gt;= 2 の場合、結果に <code>2^7 + 2^14 + ... + 2^(7*(n-1))</code> を加算します。
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_バージョン2_pack_idx_ファイルは4gibより大きいパックをサポートし_他のいくつかの再編成があります_それらの形式は以下のとおりです">バージョン2 pack-*.idx ファイルは4GiBより大きいパックをサポートし、他のいくつかの再編成があります。それらの形式は以下のとおりです:</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
4-byte マジックナンバー <code>\377tOc</code> は、 unreasonable fanout[0] 値です。
</p>
</li>
<li>
<p>
4-byte バージョン番号 (= 2)
</p>
</li>
<li>
<p>
v1と同様の256エントリのファンアウトテーブル。
</p>
</li>
<li>
<p>
ソートされたオブジェクト名のテーブル。 これらはオフセット値なしで一緒にパックされ、特定のオブジェクト名のバイナリ検索のキャッシュフットプリント(cache footprint)を削減します。
</p>
</li>
<li>
<p>
パックされたオブジェクトデータの4バイトCRC32値のテーブル。 これはv2の新機能で、再パック中に、未検出データ破損無しで圧縮データをパックからパックに直接コピーできます。
</p>
</li>
<li>
<p>
4バイトのオフセット値のテーブル(ネットワークバイトオーダー)。 これらは通常31ビットパックファイルオフセットですが、ラージオフセットは、msbitが設定された次のテーブルへのインデックスとしてエンコードされます。
</p>
</li>
<li>
<p>
8バイトのオフセットエントリのテーブル(2 GiB未満のパックファイルの場合は空)。 パックファイルは、頻繁に使用されるオブジェクトを手前に配置するように編成されているため、ほとんどのオブジェクト参照はこのテーブルを参照する必要はありません。
</p>
</li>
<li>
<p>
v1パックファイルと同一のトレーラー:
</p>
<div class="paragraph"><p>対応するパックファイルの最後にあるパックチェックサムのコピー。</p></div>
</li>
<li>
<p>
上記すべてのインデックスチェックサム。
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_pack_rev_ファイルは以下の形式です">pack-*.rev ファイルは以下の形式です:</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
4-byte マジックナンバー <code>0x52494458</code> (<code>RIDX</code>).
</p>
</li>
<li>
<p>
4-byte バージョンID(= 1)。
</p>
</li>
<li>
<p>
4-byte ハッシュ機能ID(= 1:SHA-1, 2:SHA-256)。
</p>
</li>
<li>
<p>
インデックス位置のテーブル(パックされたオブジェクトごとに1つ、合計 num_objects、それぞれネットワークオーダーで4バイトの符号なし整数)。パックファイル内の対応するオフセットでソートされます。
</p>
</li>
<li>
<p>
トレーラーは、対応するパックファイルのチェックサムと、上記のすべてのチェックサムを含みます。
</p>
</li>
</ul></div>
<div class="paragraph"><p>全ての 4-byte 数値はネットワークオーダーです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pack_mtimes_files_have_the_format">pack-*.mtimes files have the format:</h2>
<div class="sectionbody">
<div class="paragraph"><p>全ての 4バイト数はネットワーク・バイト・オーダーです。</p></div>
<div class="ulist"><ul>
<li>
<p>
4バイト。マジック・ナンバー <code>0x4d544d45</code> (<code>MTME</code>)
</p>
</li>
<li>
<p>
4-byte バージョンID(= 1)。
</p>
</li>
<li>
<p>
4-byte ハッシュ機能ID(= 1:SHA-1, 2:SHA-256)。
</p>
</li>
<li>
<p>
4バイトの符号なし整数の表。 i 番目の値は、 対応するパック内の i 番目のオブジェクトの変更時間(mtime)であり、 辞書順(インデックス順)です。 mtimes は、 標準エポック秒をカウントします。
</p>
</li>
<li>
<p>
対応するパックファイルのチェックサムと上記すべてのチェックサムを含むトレーラー (それぞれ指定されたハッシュ関数に応じた長さ)。
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_pack_index_midx_ファイルの形式は以下の通り">multi-pack-index (MIDX) ファイルの形式は以下の通り:</h2>
<div class="sectionbody">
<div class="paragraph"><p>multi-pack-indexファイルは、複数のパックファイル(pack-files)と緩いオブジェクト(loose objects)を参照します。</p></div>
<div class="paragraph"><p>MIDXにデータを追加する拡張機能を使用できるようにするために、ボディを「チャンク」に編成し、ボディの先頭にルックアップテーブルを提供します。 ヘッダーには、パックの数、ベースMIDXファイルの数、ハッシュの長さ、タイプなど、特定の長さ値達が含まれます。</p></div>
<div class="paragraph"><p>全ての 4-byte 数値はネットワークオーダーです。</p></div>
<div class="sect2">
<h3 id="_header">HEADER:</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
4-byte シグネチャ
</dt>
<dd>
<p>
    The signature is: {<code>M</code>, <code>I</code>, <code>D</code>, <code>X</code>}
</p>
</dd>
<dt class="hdlist1">
1-byte バージョン番号
</dt>
<dd>
<p>
    Gitはバージョン 1 のみを書き込みまたは認識します。
</p>
</dd>
<dt class="hdlist1">
1-byte オブジェクトIDバージョン(= 1: SHA-1, 2: SHA-256)
</dt>
<dd>
<p>
    この値からオブジェクトID(OID)の長さを推測します。 ハッシュタイプがリポジトリのハッシュアルゴリズムと一致しない場合は、multi-pack-indexファイルを無視して、ユーザーに警告を表示する必要があります。
</p>
</dd>
<dt class="hdlist1">
1-byte チャンクの数
</dt>
<dd>
<p>
    チャンクの数
</p>
</dd>
<dt class="hdlist1">
1-byte 「ベース multi-pack-index ファイル」の数
</dt>
<dd>
<p>
    この値は現在のところ常にゼロです。
</p>
</dd>
<dt class="hdlist1">
4-byte パックファアイルの数
</dt>
<dd>
<p>
    パックファアイルの数
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_chunk_lookup">CHUNK LOOKUP:</h3>
<div class="ulist"><ul>
<li>
<p>
(C + 1) * 12 bytes はチャンクオフセットを提供します
</p>
<div class="paragraph"><p>最初の4バイトはチャンクIDです。値 0 はラベル終端です。</p></div>
<div class="paragraph"><p>他の8バイトは、現在のファイルでチャンクを開始するためのオフセットを提供します。(チャンクはファイル順に提供されるため、必要に応じて次のチャンク位置を使用して長さを推測できます。)</p></div>
</li>
<li>
<p>
CHUNK LOOKUP は、チャンク・ベースのファイル形式の目次と一致します。 <a href="gitformat-chunk.html">gitformat-chunk(5)</a> を参照してください。
</p>
</li>
<li>
<p>
ボディの残りのデータは一度に1つのチャンクで記述され、これらのチャンクは任意の順序で指定できます。 特に指定がない限り、チャンクは必要です。
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_chunk_data">CHUNK DATA:</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Packfile Names (ID: {<code>P</code>, <code>N</code>, <code>A</code>, <code>M</code>})
</dt>
<dd>
<p>
    パックファイル名達を連結されたnullで終了する文字列として格納します。名前による高速ルックアップを行うには、パックファイルを辞書式順序でリストする必要があります。 これは、長さが4バイトの倍数であることが保証されていない唯一のチャンクであるため、アライメント上の理由から最後のチャンクにする必要があります。
</p>
</dd>
<dt class="hdlist1">
OID Fanout (ID: {<code>O</code>, <code>I</code>, <code>D</code>, <code>F</code>})
</dt>
<dd>
<p>
    i番目のエントリF[i]は、最初のバイトが最大iのOIDの数を格納します。 したがって、F[255]はオブジェクトの総数を格納します。
</p>
</dd>
<dt class="hdlist1">
OID Lookup (ID: {<code>O</code>, <code>I</code>, <code>D</code>, <code>L</code>})
</dt>
<dd>
<p>
    MIDX内のすべてのオブジェクトのOIDは、このチャンクに辞書式順序(lexicographic order)で格納されます。
</p>
</dd>
<dt class="hdlist1">
Object Offsets (ID: {<code>O</code>, <code>O</code>, <code>F</code>, <code>F</code>})
</dt>
<dd>
<p>
    オブジェクトごとに2つの4バイト値を格納します。
</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
このオブジェクトを格納するパックの pack-int-id。
</p>
</li>
<li>
<p>
パック内オフセット。 すべてのオフセットが <code>2^32</code> 未満(less than)の場合、 巨大オフセット・チャック(large offset chunk)は存在せず、 IDX v1 としてオフセットが格納されます。 <code>2^32-1</code> を超える(larger than)オフセット値が少なくとも 1 つある場合、 巨大オフセット・チャック(large offset chunk)が存在する必要があり、 <code>2^31-1</code> を超えるオフセットはそこに格納されなければなりません。 巨大オフセット・チャック(large offset chunk)が存在し、 31 番目のビットがオンの場合、 そのビットを削除すると、 このオブジェクトの 8バイト・オフセットを含む、巨大オフセット(large offsets)の行位置が判ります。
</p>
</li>
</ol></div>
</dd>
<dt class="hdlist1">
[オプション] Object Large Offsets (ID: {<code>L</code>, <code>O</code>, <code>F</code>, <code>F</code>})
</dt>
<dd>
<p>
    8-byte 大きなパックファイル(large packfiles)へのオフセット。
</p>
</dd>
<dt class="hdlist1">
[Optional] Bitmap pack order (ID: {<code>R</code>, <code>I</code>, <code>D</code>, <code>X</code>})
</dt>
<dd>
<p>
    MIDX 位置のリスト(MIDX 内のオブジェクトごとに 1 つ、 合計で num_objects 個、 それぞれがネットワーク・バイト順で 4 バイトの符号なし整数)で、相対的な ビットマップ/疑似パック 位置に従って並べ替えられます。
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_trailer">TRAILER:</h3>
<div class="ulist"><ul>
<li>
<p>
上記の内容のインデックスチェックサム。
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_pack_index_reverse_indexes">multi-pack-index reverse indexes</h2>
<div class="sectionbody">
<div class="paragraph"><p>パックベースのリバースインデックスと同様に、マルチパックインデックスを使用してリバースインデックスを生成することもできます。</p></div>
<div class="paragraph"><p>この逆インデックスは、offset、pack-、index の位置の間でマッピングする代わりに、MIDX内のオブジェクトの位置と、MIDXが記述する疑似パック内のそのオブジェクトの位置の間でマッピングします(つまり、マルチパック逆インデックスのi番目のエントリは、i番目のオブジェクトのMIDX位置を疑似パック順に保持します)。</p></div>
<div class="paragraph"><p>これらの順序の違いを明確にするために、マルチパック到達可能性ビットマップ(まだ存在していませんが、現在これを目指して開発中です)を検討してください。 各ビットはMIDX内のオブジェクトに対応する必要があるため、ビット位置からMIDX位置への効率的なマッピングが必要です。</p></div>
<div class="paragraph"><p>解決策の一つは、ビットがMIDXによって格納された、oidソートされたインデックスの同じ位置を占めるようにすることです。 ただし、oidは事実上ランダムであるため、結果として得られる到達可能性ビットマップには局所性がなく、圧縮が不十分になります。 (これが、シングルパックビットマップが同じ目的で、 .idx順序ではなく、パック順序を使用する理由です。)</p></div>
<div class="paragraph"><p>そのため、パックの順序に基づいてMIDX全体の順序を定義します。これにより、局所性が大幅に向上します（したがって、より効率的に圧縮されます）。 MIDX内のすべてのパックを連結して作成された疑似パックを考えることができます。 たとえば、3つのパック（a、b、c）、それぞれ10、15、および20個のオブジェクトを含むMIDXがある場合、以下のようなオブジェクトの順序を想像できます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>|a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|</code></pre>
</div></div>
<div class="paragraph"><p>ここで、パックの順序はMIDXのパックリストによって定義され、各パック内のオブジェクトの順序は実際のパックファイルでの順序と同じです。</p></div>
<div class="paragraph"><p>パックのリストとオブジェクトの数を考えると、その疑似パックの順序を簡単に再構築できます(たとえば、パック「a」と「b」がスロットの25を消費したため、位置27のオブジェクトは（c、1）でなければなりません)。 しかし、落とし穴があります。 オブジェクトはパック間で複製される可能性があるのです。その場合、MIDXはオブジェクトへのポインターを1つだけ格納します(したがって、ビットマップに1つのスロットのみが必要です)。</p></div>
<div class="paragraph"><p>呼び出し元は、ビット位置の順にオブジェクトを読み取ることで重複を処理できますが、オブジェクトの数は直線的であり、通常のビットマップルックアップにはコストがかかりすぎます。 逆インデックスを作成すると、これが解決されます。これは、インデックスの論理的な逆であり、そのインデックスはすでに重複を削除しているためです。 ただし、その場で逆インデックスを作成すると、コストがかかる可能性があります。 パックベースの逆インデックス用のオンディスク形式がすでにあるので、MIDXの疑似パックにも再利用する事しましょう。</p></div>
<div class="paragraph"><p>MIDXのオブジェクトは、疑似パックをつなぎ合わせるために次のように順序付けられます。 <code>pack(o)</code> がMIDXによって <code>o</code> が選択されたパックを返し、（MIDXによって保存された)数値IDに基づいてパックの順序を定義します。 <code>offset(o)</code> が <code>pack(o)</code> 内の <code>o</code> のオブジェクトオフセットを返すようにします。 次に、<code>o1</code> と` o2`を以下のように比較します:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>pack(o1)</code> と <code>pack(o2)</code> の一方が優先され、もう一方が優先されない場合、優先される方が最初にソートされます。
</p>
<div class="paragraph"><p>(詳細に言うと、これは、MIDXビットマップがビット位置0にあるオブジェクトを含むパックをMIDXに求めることができるので、パック再利用メカニズムによって使用されるべきパックを決定することを可能にします)。</p></div>
</li>
<li>
<p>
<code>pack(o1) ≠ pack(o2)</code> の場合、パックIDに基づいて2つのオブジェクトを降順で並べ替えます。
</p>
</li>
<li>
<p>
それ以外の場合、 <code>pack(o1) = pack(o2)</code> であり、オブジェクトはパック順に並べ替えられます(つまり、 <code>offset(o1) &lt; offset(o2)</code> の場合、<code>o1</code> は <code>o2</code> よりも先に並べ替えられます)。
</p>
</li>
</ul></div>
<div class="paragraph"><p>要するに、MIDXの擬似パックは、MIDXによって保存されたパック内のオブジェクトをパック順に並べ、パックをMIDX順(優先パックが先に来る)に並べたものを重複排除して連結したものです。</p></div>
<div class="paragraph"><p>MIDX の逆インデックスは、 MIDX 自体内の、オプションの <code>RIDX</code> チャンクに格納されます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_cruft_packs">cruft packs</h2>
<div class="sectionbody">
<div class="paragraph"><p>残り物パック(cruft pack)機能は、 到達不能オブジェクトを削除するという Git の従来のメカニズムに代わる手段を提供します。 このドキュメントでは、 Git の刈り込み(pruning)メカニズムの概要と、 代わりに残り物パックを使用して同一のことを実現する方法について説明します。</p></div>
<div class="sect2">
<h3 id="_background">Background</h3>
<div class="paragraph"><p>到達不能なオブジェクトをリポジトリから削除するために、 Git は <code>git repack -Ad</code> を提供しています(<a href="git-repack.html">git-repack(1)</a> を参照)。 以下、ドキュメントから引用します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>[...] 以前のパックの到達不能オブジェクトは、 古いパックに残されるのではなく、
パック解凍された緩いブジェクトになります。 [...] 到達不能なオブジェクトは、
次の `git gc` 呼び出しで通常の有効期限ルールに従って削除されます。</code></pre>
</div></div>
<div class="paragraph"><p>到達不能なオブジェクトはすぐには削除されません。 すぐに削除してしまうと、 削除しようとしているオブジェクトを参照する可能性のある後続のプッシュと競合する可能性があるためです。 代わりに、 これらの到達不能オブジェクトは緩いオブジェクトとして保存され、 期限切れウィンドウ(expiration window)より古くなるまでそのままの状態で保管されます。 期限切れになった時点で <a href="git-prune.html">git-prune(1)</a> で削除されます。</p></div>
<div class="paragraph"><p>Git は、オブジェクトごとの mtime を追跡するために、 これらの到達不能オブジェクトを緩い(loose)オブジェクトに保存する必要があります。 これらの到達不能オブジェクトが 1 つの大きなパックに書き込まれた場合、 そのパックを(その中に含まれるオブジェクトが書き直されたため)リフレッシュするするか、 または到達不能オブジェクトの新しいパックを作成すると、 パックの mtime が更新され、 その中のオブジェクトが有効期限ウィンドウから離脱することは決してありません。 代わりに、 個々のオブジェクトの mtimes を追跡し、 すべての残り物(cruft)オブジェクトが一度に更新される状況を回避するために、 オブジェクトは緩いオブジェクトとして格納されます。</p></div>
<div class="paragraph"><p>これにより、猶予期間を過ぎていない到達不能オブジェクトがリポジトリに多数含まれている場合に、望ましくない状況が発生する可能性があります。 <code>.git/objects</code> の一部(shard)に大きなディレクトリがあると、 リポジトリのパフォーマンスが低下する可能性があります。 また、 到達不能なオブジェクトがとても沢山ある場合、 i ノードの枯渇につながり、 システム全体のパフォーマンスを低下させる可能性があります。 これらのオブジェクトをパックすることはできないため、 これらのリポジトリは多くの場合、 大量のディスク領域を占有します。 それらは zlib 圧縮することしかできず、デルタ・チェーンに格納することはできないためです。</p></div>
</div>
<div class="sect2">
<h3 id="_cruft_packs_2">Cruft packs</h3>
<div class="paragraph"><p>残り物パック(cruft pack)は、 すべての緩い(loose)オブジェクトを含む単一のパックと一緒に、 オブジェクトごとの mtimes を別のファイルに含めることで、 到達不能なオブジェクトを緩いオブジェクト状態で保存する必要をなくします。</p></div>
<div class="paragraph"><p>残り物パックは、 新しいパックを生成するときに <code>git repack --cruft</code> によって書き込まれます。 注意: <code>git repack --cruft</code> は古典的なオールインワンの再パックであることに注意してください。 つまり、結果のパック内のすべてが到達可能であり、 他のすべては到達不能です。 <code>--cruft</code> オプションを記述すると、<code>git repack</code> に対して、前のステップでパックされなかったオブジェクトのみを含む別のパックを生成するように指示されます (これは、すべての到達不能オブジェクトを一緒にパックすることと同じです)。 これは以下のとおりに進行します:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
すべてのオブジェクトを列挙し、 (a)「keep-pack に含まれていないオブジェクト」および、 (b)「mtime がトラバーサル・ヒントとしての猶予期間内にあるオブジェクト」をマークします。
</p>
</li>
<li>
<p>
前のステップで収集したヒントに基づいて到達可能性のトラバーサルを実行し、 その途中ですべてのオブジェクトをパックに追加します。
</p>
</li>
<li>
<p>
オブジェクトごとのタイムスタンプを記録する <code>.mtimes</code> ファイルとともに、 パックを書き出します。
</p>
</li>
</ol></div>
<div class="paragraph"><p>このモードは、 残り物パック(cruft pack)を作成するように指示されたときに、 <a href="git-repack.html">git-repack(1)</a> によって内部的に呼び出されます。 重要なことは、コア内に保持されたパックのセットは、 再パックによって削除されないパックのセットであることで、 つまり、リポジトリの到達可能なすべてのオブジェクトが含まれています。</p></div>
<div class="paragraph"><p>リポジトリに既に残り物パック(cruft pack)がある場合、 <code>git repack --cruft</code> は通常、 それにオブジェクトを追加するだけです。 これに対する例外は、 <code>git repack</code> に <code>--cruft-expiration</code> オプションが与えられた場合です。 これにより生成された残り物パックは、 後で <a href="git-gc.html">git-gc(1)</a> がそれらのオブジェクトを期限切れにするのを待つ代わりに、 期限切れのオブジェクトを省略できます。</p></div>
<div class="paragraph"><p>通常、 期限切れの到達不能オブジェクトの削除を担当するのは <a href="git-gc.html">git-gc(1)</a> です。</p></div>
</div>
<div class="sect2">
<h3 id="_caution_for_mixed_version_environments">Caution for mixed-version environments</h3>
<div class="paragraph"><p>残り物パック(cruft pack)を含むリポジトリは、 古いバージョンの Git で引き続き動作します。 ただし、 <code>.mtimes</code> ファイルを認識しない以前のバージョンの Git は、残り物パックの mtime をその中のすべてのオブジェクトの mtime として使用することに注意してください。 つまり、 Git の古い (残り物パック以前の) バージョンが <code>.mtimes</code> ファイルの内容を解釈したり、読み取ったりすることを期待しないでください。</p></div>
<div class="paragraph"><p>注意 Git GC実行結果のバージョンが混在していると、 到達不能なオブジェクトが完全に刈り込みされない可能性があることに注意してください。 これは以下の状況で発生する可能性があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
古いバージョンの Git の GC 実行は、 残り物パックの mtime を使用して、 既存の残り物パックのコンテンツを緩いオブジェクトにします。
</p>
</li>
<li>
<p>
新しいバージョンのGit の GC 実行は、 これらの緩いオブジェクトを残り物パックに収集します。 <code>.mtime</code> ファイルは緩いオブジェクトの実際の mtime を反映しますが、残り物パックの mtime の値は「現在」になります。
</p>
</li>
</ul></div>
<div class="paragraph"><p>このプロセスを繰り返すと、 オブジェクトの mtime を現在の時刻に繰り返しリセットした結果、 到達不能オブジェクトが刈り込みされなくなります。</p></div>
<div class="paragraph"><p>If you are GC-ing repositories in a mixed version environment, consider omitting the <code>--cruft</code> option when using <a href="git-repack.html">git-repack(1)</a> and <a href="git-gc.html">git-gc(1)</a>, and setting the <code>gc.cruftPacks</code> configuration to "false" until all writers understand cruft packs.</p></div>
</div>
<div class="sect2">
<h3 id="_alternatives">Alternatives</h3>
<div class="paragraph"><p>この設計の注目すべき代替案は以下のとおりです:</p></div>
<div class="ulist"><ul>
<li>
<p>
オブジェクトごとの mtime データの配置と、
</p>
</li>
<li>
<p>
到達不能なオブジェクトの複数の残り物パックへの格納。
</p>
</li>
</ul></div>
<div class="paragraph"><p>mtime データの配置においては、 <code>.idx</code> 形式の複雑化を避けるために、 パックに関連付けられた新しい補助ファイルが選択されました。 <code>.idx</code> 形式がオプションのデータ・チャンクのサポートを獲得したならば、 <code>.mtimes</code> 形式を <code>.idx</code> 自体に統合することは理にかなっているかもしれません。</p></div>
<div class="paragraph"><p>複数の残り物パック(cruft pack)間(たとえば、 各再パック操作中に、 以前の残り物パックにまだ格納されていない到達不能オブジェクトのみを含む新しい残り物パックを作成)で到達不能オブジェクトを格納することは、 構築するのが非常に複雑であるため、 ここでは追求しません。 現在の実装の明らかな欠点は、 残り物パック全体を最初から書き直さなければならないことです。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-07-18 11:05:52 JST
</div>
</div>
</body>
</html>
