'\" t
.\"     Title: git-bisect
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-BISECT" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-bisect \- 二分木検索を使用して、バグを引き起こしたコミットを見つけます
.SH "SYNOPSIS"
.sp
.nf
\fIgit bisect\fR <subcommand> <options>
.fi
.sp
.SH "DESCRIPTION"
.sp
このコマンドは、さまざまなサブコマンドと、サブコマンドに応じて異なるオプションを取ります:
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect start [\-\-term\-{new,bad}=<term> \-\-term\-{old,good}=<term>]
                 [\-\-no\-checkout] [\-\-first\-parent] [<bad> [<good>\&.\&.\&.]] [\-\-] [<paths>\&.\&.\&.]
git bisect (bad|new|<term\-new>) [<rev>]
git bisect (good|old|<term\-old>) [<rev>\&.\&.\&.]
git bisect terms [\-\-term\-good | \-\-term\-bad]
git bisect skip [(<rev>|<range>)\&.\&.\&.]
git bisect reset [<commit>]
git bisect (visualize|view)
git bisect replay <logfile>
git bisect log
git bisect run <cmd>\&.\&.\&.
git bisect help
.fi
.if n \{\
.RE
.\}
.sp
このコマンドは、二分木検索アルゴリズムを使用して、プロジェクトの履歴のどのコミットでバグが発生したかを検出します。 最初に、バグが含まれていることがわかっている「bad」コミットと、バグが発生する前にあることがわかっている「good」コミットを伝えることで使用します。 次に、 \fBgit bisect\fR は、これら2つのエンドポイントの中間のコミットを選択し、選択したコミットが「good」か「bad」かを尋ねます。 変更を導入した正確なコミットが見つかるまで、範囲を絞り込み続けます。
.sp
実際、 \fBgit bisect\fR を使用して、プロジェクトの \fB任意の\fR プロパティを変更したコミットを見つけることができます。 例：バグを修正したコミット、またはベンチマークのパフォーマンスを向上させたコミット。 このより一般的な使用法をサポートするために、「good」と「bad」の代わりに「old」と「new」という用語(terms)を使用することも、独自の用語(terms)を選択することもできます。 詳細については、以下の「Alternate terms」(代替用語)のセクションを参照してください。
.SS "Basic bisect commands: start, bad, good"
.sp
例として、プロジェクトのバージョン \fBv2\&.6\&.13\-rc2\fR では動作することがわかっている機能を壊したコミットを見つけようとしているとします。以下のようにbisectセッションを開始します:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start
$ git bisect bad                 # Current version is bad
$ git bisect good v2\&.6\&.13\-rc2    # v2\&.6\&.13\-rc2 is known to be good
.fi
.if n \{\
.RE
.\}
.sp
.sp
少なくとも1つのbadコミットと1つのgoodコミットを指定すると、 \fBgit bisect\fR はその範囲の履歴の真ん中でコミットを選択し、それをチェックアウトして、以下のようなものを出力します(訳注:テスト対象残り675リビジョン(ざっくり10ステップ)):
.sp
.if n \{\
.RS 4
.\}
.nf
Bisecting: 675 revisions left to test after this (roughly 10 steps)
.fi
.if n \{\
.RE
.\}
.sp
.sp
あなたはチェックアウトしたバージョンをコンパイルしてテストする必要があります。 もし、そのバージョンが正しく機能する場合は、次のように入力します
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect good
.fi
.if n \{\
.RE
.\}
.sp
.sp
もし、そのバージョンが壊れている場合は、以下のように入力します
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect bad
.fi
.if n \{\
.RE
.\}
.sp
.sp
そうすると、 \fBgit bisect\fR は以下のように応答します
.sp
.if n \{\
.RS 4
.\}
.nf
Bisecting: 337 revisions left to test after this (roughly 9 steps)
.fi
.if n \{\
.RE
.\}
.sp
.sp
このプロセスを繰り返します: ツリーをコンパイルしてテストし、それがgoodかbadかに応じて、 \fBgit bisect good\fR または \fBgit bisect bad\fR を実行して、テストが必要な次のコミットを要求します。
.sp
最終的には、検査するリビジョンがなくなり、コマンドは最初の不正なコミットの説明を出力します。 参照 \fBrefs/bisect/bad\fR は、そのコミットを指したままになります。
.SS "Bisect reset"
.sp
bisectセッションの後、bisect状態をクリーンアップして元のHEADに戻すには、以下のコマンドを発行します:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect reset
.fi
.if n \{\
.RE
.\}
.sp
.sp
デフォルトでは、これにより、あなたのツリーは \fBgit bisect start\fR の前にチェックアウトされたコミットに戻ります。 (新しく行う \fBgit bisect start\fR も、古いbisect状態をクリーンアップするため、これを実行します。)
.sp
オプションの引数を使用すると、代わりに異なるコミットに戻ることができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect reset <commit>
.fi
.if n \{\
.RE
.\}
.sp
.sp
たとえば、 \fBgit bisect reset bisect/bad\fR は最初のbadリビジョンをチェックアウトしますが、 \fBgit bisect reset HEAD\fR は現在のbisectコミットのままにし、コミットの切り替えを完全に回避します。
.SS "Alternate terms(代替用語)"
.sp
破損を引き起こしたコミットではなく、他の「old」状態と「new」状態の間で変化を引き起こしたコミットを探している場合があります。 たとえば、特定の修正を導入したコミットを探している場合があります。 または、ソースコードのファイル名がすべて最終的に会社の命名基準に変換された最初のコミットを探しているかもしれません。その他何でもありです。
.sp
このような場合、「変更前の状態」と「変更後の状態」を指すのに「good」と「bad」という用語(terms)を使用することは非常に混乱する可能性があります。 したがって、「good」と「bad」の代わりに、それぞれ「old」と「new」という用語を使用できます。 (ただし、単一のセッション内で「good」と「bad」を「old」と「new」と混在させることはできないことに注意してください。)
.sp
このより一般的な使用法では、 \fBgit bisect\fR に、いくつかのプロパティを持つ「new」コミットと、そのプロパティを持たない「old」コミットを提供します。 \fBgit bisect\fR がコミットをチェックアウトするたびに、そのコミットにそのプロパティがあるかどうかをテストします。 含まれている場合は、コミットを「new」としてマークします。 それ以外の場合は、「old」とマークします。 bisectが行われると、 \fBgit bisect\fR はどのコミットがそのプロパティを導入したかを報告します。
.sp
「good」と「bad」の代わりに「old」と「new」を使用するには、引数としてcommitを指定せずに \fBgit bisect start\fR を実行してから、以下のコマンドを実行してコミットを追加する必要があります:
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect old [<rev>]
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、コミットが求められた変更の前であったことを知らせるためで、あるいは、
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect new [<rev>\&.\&.\&.]
.fi
.if n \{\
.RE
.\}
.sp
.sp
これはコミットが求められた変更より新しい事を知らせます。
.sp
現在使用している用語(terms)を思い出したいときは、以下を入力します。
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect terms
.fi
.if n \{\
.RE
.\}
.sp
.sp
old(または new)の用語(term)は、 \fBgit bisect terms \-\-term\-old\fR または \fBgit bisect terms \-\-term\-good\fR で取得できます。
.sp
bad/good または new/old の代わりに独自の用語(terms)を使用する場合は、以下を使用してbisectを開始することにより、(\fBreset\fR 、\fBstart\fR などの既存のbisectサブコマンドを除く)任意の名前を選択できます
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect start \-\-term\-old <term\-old> \-\-term\-new <term\-new>
.fi
.if n \{\
.RE
.\}
.sp
.sp
たとえば、あなたがパフォーマンスの低下をもたらすコミットを探している場合は、以下のように使用できます
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect start \-\-term\-old fast \-\-term\-new slow
.fi
.if n \{\
.RE
.\}
.sp
.sp
または、あなたがバグを修正したコミットを探している場合は、以下のようにします
.sp
.if n \{\
.RS 4
.\}
.nf
git bisect start \-\-term\-new fixed \-\-term\-old broken
.fi
.if n \{\
.RE
.\}
.sp
.sp
次に、コミットをマークするために、 \fBgit bisect good\fR や \fBgit bisect bad\fR の代わりに、 \fBgit bisect <term\-old>\fR や \fBgit bisect <term\-new>\fR を使用します。
.SS "Bisect visualize/view"
.sp
\fBgitk\fR に現在残っている容疑者(suspects)を確認するには、bisectプロセス中に以下のコマンドを発行します(サブコマンド \fBview\fR は \fBvisualize\fR の代わりに使用できます):
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect visualize
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fBDISPLAY\fR 環境変数が設定されていない場合、代わりに \fBgit log\fR が使用されます。 \fB\-p\fR や \fB\-\-stat\fR などのコマンドラインオプションを指定することもできます。
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect visualize \-\-stat
.fi
.if n \{\
.RE
.\}
.sp
.SS "Bisect log and bisect replay"
.sp
リビジョンをgoodまたはbadとマークした後、以下のコマンドを発行して、これまでに行われたことを表示します:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect log
.fi
.if n \{\
.RE
.\}
.sp
.sp
リビジョンのステータスの指定を間違えたのを見つけた場合は、このコマンドの出力をファイルに保存し、それを編集して誤ったエントリを削除してから、以下のコマンドを発行して修正された状態に戻すことができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect reset
$ git bisect replay that\-file
.fi
.if n \{\
.RE
.\}
.sp
.SS "Avoiding testing a commit"
.sp
bisectセッションの途中で、提案されたリビジョンがテストに適していないことがわかっている場合(たとえば、ビルドに失敗し、その失敗が追跡しているバグとは何の関係もないことがわかっている場合)、その近くのコミットを手動で選択し、代わりにそれをテストできます。
.sp
例えば:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect good/bad                   # previous round was good or bad\&.
Bisecting: 337 revisions left to test after this (roughly 9 steps)
$ git bisect visualize                  # oops, that is uninteresting\&.
$ git reset \-\-hard HEAD~3               # try 3 revisions before what
                                        # was suggested
.fi
.if n \{\
.RE
.\}
.sp
.sp
次に、選択したリビジョンをコンパイルしてテストし、その後、通常の方法でリビジョンにgoodまたはbadのマークを付けます。
.SS "Bisect skip"
.sp
自分で近くのコミットを選択する代わりに、コマンドを発行してGitにそれを実行するように依頼できます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect skip                 # Current version cannot be tested
.fi
.if n \{\
.RE
.\}
.sp
.sp
しかしながら、探しているコミットに隣接するコミットをスキップすると、Gitはそれらのコミットのどれが最初のbadコミットであったかを正確に知ることができなくなります。
.sp
範囲表記を使用して、1つのコミットだけでなく、範囲のコミットをスキップすることもできます。 例えば以下のようにします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect skip v2\&.5\&.\&.v2\&.6
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、\fBv2\&.5\fR 以降の \fBv2\&.6\fR までのコミットをテストしてはならないことをbisectプロセスに伝えます。
.sp
注意: 範囲の最初のコミットもスキップする場合は、以下のコマンドを発行することに注意してください:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect skip v2\&.5 v2\&.5\&.\&.v2\&.6
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、\fBv2\&.5\fR と \fBv2\&.6\fR (の両端を含む) の間のコミットをスキップする必要があることをbisectプロセスに通知します。
.SS "bisect startでより多くのパラメータを与えて探索量削減"
.sp
あなたが追跡している問題にツリーのどの部分が関係しているかがわかっている場合は、 \fBbisect start\fR コマンドを発行するときにパスパラメータを指定することで、試行回数をさらに減らすことができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start \-\- arch/i386 include/asm\-i386
.fi
.if n \{\
.RE
.\}
.sp
.sp
複数の適切なコミットが事前にわかっている場合は、 \fBbisect start\fR コマンドを発行するときに、badコミットの直後にすべてのgoodコミットを指定することで、bisect量を絞り込むことができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start v2\&.6\&.20\-rc6 v2\&.6\&.20\-rc4 v2\&.6\&.20\-rc1 \-\-
                   # v2\&.6\&.20\-rc6 is bad
                   # v2\&.6\&.20\-rc4 and v2\&.6\&.20\-rc1 are good
.fi
.if n \{\
.RE
.\}
.sp
.SS "Bisect run"
.sp
現在のソースコードがgoodかbadかを判断できるスクリプトがある場合は、以下のコマンドを発行してbisectすることができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect run my_script arguments
.fi
.if n \{\
.RE
.\}
.sp
.sp
注意: スクリプト(上記例では \fBmy_script\fR)は、現在のソースコードが good/old ならばコード0で終了し、現在のソースコードが bad/new の場合はコードは125を除く1〜127で終了します。
.sp
その他の終了コードは、bisectプロセスを中止します。 \fBexit(\-1)\fR を介して終了するプログラムは $?= 255 を残すことに注意してください。 (exit(3)のマニュアルページ参照)。 値は \fB& 0377\fR でマスクされます。
.sp
現在のソースコードをテストできない場合は、特別な終了コード125を使用する必要があります。 スクリプトがこのコードで終了する場合、現在のリビジョンはスキップされます(上記「git bisect skip」参照)。 126と127はPOSIXシェルによって特定のエラーステータスを通知するために使用されるため、125がこの目的で使用する最も適切な値として選択されました(127は、コマンドが見つかりません で、 126は コマンドが見つかりましたが実行可能ではありません です。 \(em これらの詳細は、 \fBbisect run\fR に関する限り、スクリプトの通常のエラーであるため、重要ではありません)。
.sp
bisectセッション中に、テスト対象のリビジョンに一時的な変更を加えたい場合がよくあります(例: ヘッダーファイルで \fBs/#define DEBUG 0/#define DEBUG 1/\fR 、または「このコミットがないリビジョンでは、このbisectが関心を持たない別の問題を解決するために、このパッチを適用する必要があります」)。
.sp
このような状況に対処するために、「git bisect」内部でテストする次のリビジョンを見つけた後、スクリプトはコンパイル前にパッチを適用し、実際のテストを実行し、その後、リビジョン(おそらく必要なパッチを含む)が合格したかどうかを判断できます。 テストしてから、ツリーを元の状態に巻き戻します。 最後に、スクリプトは実際のテストのステータスで終了し、 \fBgit bisect run\fR コマンドループがbisectセッションの最終的な結果を決定できるようにする必要があります。
.SH "OPTIONS"
.PP
\fB\-\-no\-checkout\fR
.RS 4
bisectプロセスの各反復で新しい作業ツリーをチェックアウトしないでください。 代わりに、
\fBBISECT_HEAD\fR
という名前の特別な参照を更新して、テストする必要のあるコミットを指すようにします。
.sp
このオプションは、各ステップで実行するテストで、チェックアウトされたツリーが必要ない場合に役立つことがあります。
.sp
ベアリポジトリの場合、
\fB\-\-no\-checkout\fR
が想定されます。
.RE
.PP
\fB\-\-first\-parent\fR
.RS 4
マージコミットを確認したら、最初の親コミットのみを実行します。
.sp
ブランチのマージによって導入されたデグレを検出する際に、マージコミットはバグの導入として識別され、その祖先は無視されます。
.sp
このオプションは、マージされたブランチに壊れたコミットまたはビルドできないコミットが含まれているが、マージ自体はOKな場合に誤検知を回避するのに特に役立ちます。
.RE
.SH "EXAMPLES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
v1\&.2とHEADの間で壊れたビルドを自動的にbisectします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start HEAD v1\&.2 \-\-      # HEAD is bad, v1\&.2 is good
$ git bisect run make                # "make" builds the app
$ git bisect reset                   # quit the bisect session
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
originとHEADの間のテスト失敗を自動的にbisectします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start HEAD origin \-\-    # HEAD is bad, origin is good
$ git bisect run make test           # "make test" builds and tests
$ git bisect reset                   # quit the bisect session
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
壊れたテストケースを自動的にbisectします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cat ~/test\&.sh
#!/bin/sh
make || exit 125                     # this skips broken builds
~/check_test_case\&.sh                 # does the test case pass?
$ git bisect start HEAD HEAD~10 \-\-   # culprit is among the last 10
$ git bisect run ~/test\&.sh
$ git bisect reset                   # quit the bisect session
.fi
.if n \{\
.RE
.\}
.sp
ここでは、
\fBtest\&.sh\fR
カスタムスクリプトを使用します。 このスクリプトでは、
\fBmake\fR
が失敗した場合、現在のコミットをスキップします。
\fBcheck_test_case\&.sh\fR
は、テストケースが合格した場合は
\fBexit 0\fR
であり、そうでない場合は
\fBexit 1\fR
である必要があります。
.sp
\fBtest\&.sh\fR
と
\fBcheck_test_case\&.sh\fR
の両方がリポジトリの外にある場合は、bisectプロセスとmakeプロセスとtestプロセスとスクリプトの間の相互作用を防ぐ方が安全です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
一時的な変更(ホットフィックス)で自動的にbisectします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cat ~/test\&.sh
#!/bin/sh

# tweak the working tree by merging the hot\-fix branch
# and then attempt a build
if      git merge \-\-no\-commit \-\-no\-ff hot\-fix &&
        make
then
        # run project specific test and report its status
        ~/check_test_case\&.sh
        status=$?
else
        # tell the caller this is untestable
        status=125
fi

# undo the tweak to allow clean flipping to the next commit
git reset \-\-hard

# return control
exit $status
.fi
.if n \{\
.RE
.\}
.sp
これにより、各テスト実行の前にホットフィックスブランチからの変更が適用されます。 例えば、ビルドやテスト環境が変わり、古いリビジョンではすでに修正されているものが、新しいリビジョンでは修正が必要になる可能性があるからです。（ホットフィックスブランチが、bisectしているすべてのリビジョンに含まれているコミットに基づいていることを確認して、マージがあまり引き込まれないようにするか、
\fBgit merge\fR
の代わりに
\fBgit cherry\-pick\fR
を使用します。)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
壊れたテストケースを自動的にbisectします:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start HEAD HEAD~10 \-\-   # culprit is among the last 10
$ git bisect run sh \-c "make || exit 125; ~/check_test_case\&.sh"
$ git bisect reset                   # quit the bisect session
.fi
.if n \{\
.RE
.\}
.sp
これは、テストを1行で記述した場合、実行スクリプトなしで実行できることを示しています。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
破損したリポジトリでオブジェクトグラフの適切な領域を見つけます
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start HEAD <known\-good\-commit> [ <boundary\-commit> \&.\&.\&. ] \-\-no\-checkout
$ git bisect run sh \-c \*(Aq
        GOOD=$(git for\-each\-ref "\-\-format=%(objectname)" refs/bisect/good\-*) &&
        git rev\-list \-\-objects BISECT_HEAD \-\-not $GOOD >tmp\&.$$ &&
        git pack\-objects \-\-stdout >/dev/null <tmp\&.$$
        rc=$?
        rm \-f tmp\&.$$
        test $rc = 0\*(Aq

$ git bisect reset                   # quit the bisect session
.fi
.if n \{\
.RE
.\}
.sp
この場合、「git bisect run」が終了すると、 bisect/bad は、到達可能なグラフが「git pack objects」で必要な意味で完全にトラバース可能な親が少なくとも1つあるコミットを参照します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
コードでデグレの代わりに修正を探します
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start
$ git bisect new HEAD    # current commit is marked as new
$ git bisect old HEAD~10 # the tenth commit from now is marked as old
.fi
.if n \{\
.RE
.\}
.sp
または:
.RE
.sp
.if n \{\
.RS 4
.\}
.nf
$ git bisect start \-\-term\-old broken \-\-term\-new fixed
$ git bisect fixed
$ git bisect broken HEAD~10
.fi
.if n \{\
.RE
.\}
.sp
.SS "Getting help"
.sp
\fBgit bisect\fR を使用して短い使用法の説明を取得し、 \fBgitbisect help\fR または \fBgit bisect \-h\fR を使用して長い使用法の説明を取得します。
.SH "SEE ALSO"
.sp
\m[blue]\fBFighting regressions with git bisect\fR\m[]\&\s-2\u[1]\d\s+2, \fBgit-blame\fR(1)\&.
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
Fighting regressions with git bisect
.RS 4
\%file:///home/hideo/share/doc/git-doc/git-bisect-lk2009.html
.RE
