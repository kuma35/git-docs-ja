'\" t
.\"     Title: git-sparse-checkout
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-SPARSE\-CHECKOU" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-sparse-checkout \- あなたの作業ツリーを追跡ファイルのサブセットのために縮小します
.SH "SYNOPSIS"
.sp
.nf
\fIgit sparse\-checkout <subcommand> [<options>]\fR
.fi
.sp
.SH "DESCRIPTION"
.sp
このコマンドは、すべての追跡ファイルが存在する状態から、それらのファイルのサブセットのみが存在する状態に作業ツリーを変更するスパース・チェックアウトを作成するために使用されます。 また、存在するファイルのサブセットを切り替えるか、または、元に戻してすべての追跡ファイルが作業コピーに存在するように戻すこともできます。
.sp
ファイルのサブセットは、コーン・モード(デフォルト)でディレクトリのリストを提供するか、非コーン・モードでパターンのリストを提供することによって選択されます。
.sp
スパース・チェックアウト中は、他の Git コマンドの動作が少し異なります。 たとえば、ブランチを切り替えても、スパース・チェックアウト・ディレクトリ外やスパース・チェックアウト・ディレクトリ外のパスは更新されず、 \fBgit commit \-a\fR はスパース・チェックアウト・ディレクトリ外や/スパース・チェックアウト・パターン外のパスを削除済みとして記録しません。
.sp
警告: このコマンドは実験的なものです。 その動作、およびスパースチェックアウトの存在下での他のコマンドの動作は、将来変更される可能性があります。
.SH "COMMANDS"
.PP
list
.RS 4
スパース・チェックアウト・ファイルにディレクトリ達またはパターン達を記述します。
.RE
.PP
set
.RS 4
必要なスパース・チェックアウト構成設定(\fBcore\&.sparseCheckout\fR
と
\fBcore\&.sparseCheckoutCone\fR
と`index\&.sparse`)がまだ目的の値に設定されていない場合は有効にし、
\fBset\fR
サブコマンドに続く引数のリストからスパース・チェックアウト・ファイルに入力し、それにマッチするよう作業ディレクトリを更新します。
.sp
ワークツリー内のスパース・チェックアウト設定を調整しても、他のワークツリーのスパース・チェックアウト設定が変更されないようにするために、
\fBset\fR
サブコマンドは、ワークツリー固有の設定がまだ存在しない場合は、それを使用するようにあなたのリポジトリ設定をアップグレードします。
\fBset\fR
サブコマンドへの引数によって定義されたスパース性は、ワークツリー固有のスパース・チェックアウト・ファイル(worktree\-specific sparse\-checkout file)に格納されます。 詳細については、\fBgit-worktree\fR(1)
および
\fBgit-config\fR(1)
の
\fBextensions\&.worktreeConfig\fR
のドキュメントを参照してください。
.sp
\fB\-\-stdin\fR
オプションを指定すると、ディレクトリ達またはパターン達は引数からではなく、改行で区切られたリストとして標準入力から読み込まれます。
.sp
デフォルトでは、入力リストはディレクトリのリストと見なされ、
\fBgit ls\-tree \-d \-\-name\-only\fR
の出力と一致します。 これには、二重引用符(\fB"\fR)で始まるパス名を C スタイルのクォートされた文字列として解釈することが含まれます。 注意: 指定されたディレクトリの(任意の深さの)下にあるすべてのファイル、および指定されたディレクトリまたはその祖先のいずれかの兄弟であるファイルがスパース・チェックアウトに含まれることに注意してください(詳細については、下記「CONE PATTERN SET」を参照してください)。 以前はこれがデフォルトではなく、
\fB\-\-cone\fR
を指定するか、\fBcore\&.sparseCheckoutCone\fR
を有効にする必要がありました。
.sp
\fB\-\-no\-cone\fR
が渡されると、入力リストはパターンのリストと見なされます。 このモードでは、\fB\-\-sparse\-index\fR
などの一部のオプションが機能し無い等、多くの欠点があります。 下記「Non\-cone Problems」セクションで説明されているように、使用はお勧めしません。
.sp
\fB\-\-[no\-]sparse\-index\fR
オプションを使用して、 スパース・インデックスを使用します(デフォルトでは使用しません)。 スパース・インデックスは、 インデックスのサイズを縮小して、スパース・チェックアウトの定義により近づけます。 これにより、
\fBgit status\fR
や
\fBgit add\fR
などのコマンドのパフォーマンスが大幅に向上します。 この機能はまだ実験段階です。 一部のコマンドは、機能に適切に統合されるまで、 スパース・インデックスを使用すると遅くなる可能性があります。
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
スパースインデックスを使用するには、外部ツールでは完全には理解できない方法でインデックスを変更する必要があります。 この互換性に問題がある場合は、
\fBgit sparse\-checkout init \-\-no\-sparse\-index\fR
を実行して、インデックスがまばらにならないように書き換えます。 古いバージョンのGitは、スパースディレクトリエントリのインデックス拡張機能を理解せず、それが無効になるまでリポジトリとのやり取りに失敗する可能性があります。
.sp .5v
.RE
.RE
.PP
add
.RS 4
スパース・チェックアウト・ファイルを更新して、 追加のディレクトリ(コーン・モードの場合)またはパターン(非コーン・モードの場合)を含めます。 デフォルトでは、これらのディレクトリまたはパターンはコマンドライン引数から読み取られますが、
\fB\-\-stdin\fR
オプションを使用して stdin から読み取ることができます。
.RE
.PP
reapply
.RS 4
作業ツリーのパスにスパースパターンルールを再適用します。 マージやリベースなどのコマンドは、作業を行うためのパスを具体化でき(たとえば、競合を表示するため)ますが、他のスパースチェックアウトコマンドは、個々のファイルをスパース化できない場合があります(たとえば、ステージングされていない変更や競合があるため)。 このような場合、影響を受けるパスをクリーンアップした後、(たとえば、競合の解決、変更の取り消しまたはコミットなどの)後で
\fBgit sparse\-checkout reapply\fR
を実行するのが理にかなっています。
.sp
\fBreapply\fR
コマンドは
\fB\-\-[no\-]cone\fR
や
\fB\-\-[no\-]sparse\-index\fR
フラグも使用できます。これは、
\fBset\fR
コマンドのフラグと同一の意味で、 これにより、あなたは全てのスパース・パス(sparsity paths)を再指定すること無く、スパース・モードを変更できます。
.RE
.PP
disable
.RS 4
\fBcore\&.sparseCheckout\fR
構成設定を無効にし、すべてのファイルを含めるように作業ディレクトリを復元(restore)します。
.RE
.PP
init
.RS 4
パスが指定されていない「set」のように動作する非推奨のコマンド。 将来削除される可能性があります。
.sp
かつて
\fBset\fR
は必要なすべての構成設定を処理していませんでした。 つまり、
\fBinit\fR
と
\fBset\fR
の両方を呼び出す必要がありました。 両方を呼び出すと、最初に
\fBinit\fR
ステップでほぼすべての追跡ファイルが削除され(コーン・モードでは無視されたファイル(ignored files)も含めて)、 次に
\fBset\fR
ステップで追跡ファイルの多くが追加されます(ただし、無視されたファイル(ignored files)は含まれません)。 ファイルが失われるだけでなく、この組み合わせのパフォーマンスと UI も貧弱でした。
.sp
また、かつては、 スパース・チェックアウト・ファイルが既に存在する場合、
\fBinit\fR
は実際にはそれを初期化しませんでした。 これは、後続の
\fBset\fR
または
\fBadd\fR
コマンドに渡すパスを覚えていなくても、 スパース・チェックアウトに戻ることができることを意味していました。 ただし、
\fB\-\-cone\fR
オプションと
\fB\-\-sparse\-index\fR
オプションは、
\fBdisable\fR
コマンドまでまたがって記憶される訳では無いため、 単純な
\fBinit\fR
を呼び出す簡単な復元の有用性が低下しました。
.RE
.SH "EXAMPLES"
.PP
\fBgit sparse\-checkout set MY/DIR1 SUB/DIR2\fR
.RS 4
作業コピーに存在する MY/DIR1/ および SUB/DIR2/ の下のすべてのファイル(任意の深さ)(加えて
\fBMY/\fR
や
\fBSUB/\fR
直下と、トップレベル・ディレクトリのすべてのファイル)を使用して、スパース チェックアウトに変更します。 すでにスパース・チェックアウトである場合は、作業コピーに存在するファイルをこの新しい選択に変更します。 注意: このコマンドは、追跡中のファイルまたは、無視されていない追跡されていない(non\-ignored\-untracked)ファイルが存在しなくなったディレクトリ内のすべての無視されたファイル(ignored files)も削除することに注意してください。
.RE
.PP
\fBgit sparse\-checkout disable\fR
.RS 4
スパース・チェックアウトを無効にして、 作業ディレクトリにすべてのファイルを再入力します。
.RE
.PP
\fBgit sparse\-checkout add SOME/DIR/ECTORY\fR
.RS 4
\fBSOME/DIR/ECTORY/\fR
の下(任意の深さ)にあるすべてのファイルをスパース・チェックアウトに追加し、
\fBSOME/DIR/\fR
の直下と
\fBSOME/\fR
の直下にあるすべてのファイルも追加します。 このコマンドを使用する前に、スパース・チェックアウトにしておく必要があります。
.RE
.PP
\fBgit sparse\-checkout reapply\fR
.RS 4
コマンドが、 選択されたスパース・ディレクトリを尊重しない方法で作業ツリーを更新する可能性があります。 これは、Git の外部のツールがファイルを書き込むことで発生したり、 また、(マージ/リベース時に競合が発生するなどの)特殊なケースや一部のコマンドがスパース・チェックアウトを完全にサポートしていないために Git コマンドに影響を与えるたりする可能性があります(たとえば、古い「recursive」(再帰的)マージ・バックエンドのサポートは限定的でした)。 このコマンドは、既存のスパース・ディレクトリの指定を再適用して、作業ディレクトリを一致させます。
.RE
.SH "INTERNALS \(em SPARSE CHECKOUT"
.sp
「スパース・チェックアウト」(sparse checkout;疎らなチェックアウト)を使用すると、 作業ディレクトリを疎らに設定できます。 これは、skip\-worktree ビット (\fBgit-update-index\fR(1) を参照) を使用して、作業ディレクトリ内のファイルを調べる価値があるかどうかを Git に伝えます。 skip\-worktree ビットが設定されていて、 ファイルが作業ツリーに存在しない場合、その不在は無視されます。 Git はこれらのファイルの内容を作業ディレクトリに入力することを回避します。これにより、多くのファイルを含むリポジトリで作業する場合にはスパース・チェックアウトが役に立ちますが、現在のユーザーにとってほとんど重要では無いものです。
.sp
\fB$GIT_DIR/info/sparse\-checkout\fR ファイルは、スキップワークツリー参照ビットマップを定義するために使用されます。 Gitが作業ディレクトリを更新すると、このファイルに基づいてインデックスのスキップワークツリービットが更新されます。 ファイル内のパターンに一致するファイルは作業ディレクトリに表示され、残りは表示されません。
.SH "INTERNALS \(em NON\-CONE PROBLEMS"
.sp
\fBset\fR や \fBadd\fR サブコマンドによって入力される \fB$GIT_DIR/info/sparse\-checkout\fR ファイルは、 \fB\&.gitignore\fR ファイルと同じ構文を使用して(1行に1つの)一連のパターンとして定義されます。 コーン・モードでは、 これらのパターンは一致するディレクトリに制限されます(ユーザーはディレクトリ名を指定または表示するだけで済みます)。一方、非コーン・モードでは、任意の gitignore スタイルのパターンが許可されます。 非コーン・モードで完全な gitignore スタイルのパターンを使用すると、 以下のようないくつかの欠点があります:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
基本的に、さまざまなワークツリー更新プロセス(pull, merge, rebase, switch, reset, checkout, 等)で O(N*M) 回のパターン・マッチングが必要になります。ここで、N はパターンの数、M はインデックス内のパスの数です。これはスケーリングが不十分です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
スケーリングの問題を回避するには、先頭のディレクトリ名またはグロブを指定してパターンの数を制限する必要があります。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
コマンドラインでグロブを渡すとエラーが発生しやすくなります。ユーザーがグロブをクォートするのを忘れる可能性があるため、シェルがそれをすべての一致するファイルに展開し、それらすべてを個別にスパース・チェックアウト set/add に渡す原因となります。 これは、例えば
\fBgit grep \-\- *\&.c\fR
でも問題になる可能性がありますが、 grep/log/status での間違いは即座に出力が得られます。 スパース・チェックアウトでは、間違いはスパース・チェックアウト・コマンドの実行時に記録され、後でユーザーがブランチ切り替えまたはリベースまたはマージを行うまで問題にならない可能性があるため、ユーザーのエラーと、ユーザーがそれをキャッチする機会、またはユーザにそれを通知する機会、までに遅延が生じます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
先の項目に関連して、スパース・チェックアウトには
\fBadd\fR
サブコマンドがありますが、
\fBremove\fR
サブコマンドはありません。
\fBremove\fR
サブコマンドが追加された場合、クォートされていない偶発的なグロブを元に戻すと、偶発的な追加の前に含まれていたエントリが削除される可能性があるため、「削除しすぎ」のリスクがあります。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
非コーン・モード(non\-cone mode)では gitignore スタイルのパターンを使用して「含める」(否定パターンを除く)ものを選択しますが、
\fB\&.gitignore\fR
ファイルは gitignore スタイルのパターンを使用して「除外するもの」(否定パターンを除く)を選択します。 gitignore スタイルのパターンに関するドキュメントは通常、 一致または不一致の観点からではなく、 ユーザーが何を「除外」したいかについて述べています。 これは、 スパース・チェックアウト・パターンを指定して目的の動作を取得する方法を学習しようとしているユーザーにとっては混乱を招く可能性があります。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ある種の「特別なパス・パターン・マッチング」を提供したい他のすべての git サブコマンドは pathspecs を使用しますが、 スパース・チェックアウトの非コーン・モードは gitignore パターンを使用するため、一貫性がありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
「正しい」動作が不明確な境界ギリギリのケース(edge cases)があります。 以下に例を2つ挙げます:
.sp
1つ目は、 2人のユーザーがサブディレクトリにいて、最初のユーザーが
\fBgit sparse\-checkout set \*(Aq/toplevel\-dir/*\&.c\*(Aq\fR
を実行し、 2番目のユーザーが
\fBgit sparse\-checkout set relative\-dir\fR
を実行します。 スパース・チェックアウト・ファイルに挿入する前に、これらの引数を
\fBcurrent/subdirectory/toplevel\-dir/*\&.c\fR
と
\fBcurrent/subdirectory/relative\-dir\fR
に変換する必要がありますか？ 最初のコマンドを入力したユーザーは、 set/add の引数が非円錐(non\-cone)モードのパターンであることを認識しており、おそらくこのような変換には満足しないでしょう。 けれども、多くの gitignore スタイルのパターンは単なるパスであり、2 番目のコマンドを入力したユーザーが考えていたものである可能性があり、引数が変換されていないと動揺することでしょう。
.sp
次に、非コーンのユーザーの set/add コマンドの bash補完は何を完了させる必要がありますか？ パスが提案されている場合、上記の問題を悪化させていませんか？ また、パスが提案されている場合、ユーザーのファイルやディレクトリが
\fB!\fR
や
\fB#\*(Aq`で始まっていたり、その名前に `*\fR
や
\fB\e\fR
や
\fB?\fR
や
\fB[\fR
や
\fB]\fR
が含まれていたらどうなるでしょう？ そしてまた、パスを提案する場合、現在のディレクトリの
\fB/progress\&.txt\fR
ではなく、
\fB/pro\fR
を (ルート・ファイルシステムの)
\fB/proc\fR
に補完しますか？ (\fB\&.gitignore\fR
ファイルにあることが多いのと同じ理由で、ユーザーは非コーン・モードで先頭の
\fB/\fR
でパスを開始する可能性が高いことに注意してください。) これらすべてのケースで、ファイルまたはディレクトリを補完すると、厄介なサプライズが生じる可能性があります。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
過度の柔軟性により、他の拡張機能は本質的に実用的ではなくなりました。
\fB\-\-sparse\-index\fR
機能は非コーン・モードではおそらく不可能です。 たとえそれが何らかの形で実行可能であったとしても、 実装するにははるかに多くの作業が必要であり、かつ、実際に動かすと遅すぎる可能性があります。 部分(partial)クローンとスパース・チェックアウトの間の結合を追加するためのいくつかのアイデアは、パスのセットがより制限されている場合にのみ実用的です。
.RE
.sp
これらすべての理由から、 非コーン・モードは推奨されません。 コーン・モードを使用するように切り替えてください。
.SH "INTERNALS \(em CONE MODE HANDLING"
.sp
デフォルトの「コーン・モード」では、含めるディレクトリのみを指定できます。 指定されたディレクトリについては、そのディレクトリの下のすべてのパスが含まれ、先頭のディレクトリ (最上位ディレクトリを含む) のすぐ下のパスも含まれます。 したがって、ディレクトリ \fBDocumentation/technical/\fR を指定した場合、スパース・チェックアウトには以下が含まれます:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
最上位ディレクトリ内のすべてのファイル
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBDocumentation/\fR
直下のすべてのファイル
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBDocumentation/technical/\fR
の下の任意の深さのすべてのファイル
.RE
.sp
また、コーン・モードでは、ディレクトリが指定されていない場合でも、最上位ディレクトリ内のファイルが含まれます。
.sp
円錐(cone)モードでスパースチェックアウトパターンを変更すると、Gitはスパースチェックアウト円錐(cone)内にない追跡中の各ディレクトリを検査して、追跡されていないファイルが含まれているかどうかを確認します。 \fB\&.gitignore\fR パターンが原因でこれらのファイルがすべて無視された場合、ディレクトリは削除されます。 そのディレクトリ内の追跡されていないファイルのいずれかが無視されない場合、そのディレクトリ内で削除は発生せず、警告メッセージが表示されます。 これらのファイルが重要な場合は、スパースチェックアウト定義をリセットして含まれるようにし、 \fBgit add\fR と \fBgit commit\fR を使用してファイルを保存し、残りのファイルを手動で削除して、Gitが最適に動作できるようにします。
.sp
ディレクトリがフード(hood)の下でスパース・チェックアウトのフル・パターン・セットのサブセットに変換される方法については、「Internals \(em Cone Pattern Set」セクションも参照してください。
.SH "INTERNALS \(em FULL PATTERN SET"
.sp
フルパターンセットにより、任意のパターンの一致と複雑な包含/除外ルールが可能になります。 これらにより、インデックスを更新するときに O(オー;N*M)パターンが一致する可能性があります。ここで、Nはパターンの数、Mはインデックス内のパスの数です。 このパフォーマンスの問題に対処するために、 \fBcore\&.sparseCheckoutCone\fR が有効になっている場合は、より制限されたパターンセットが許可されます。
.sp
スパース・チェックアウト・ファイルは \fB\&.gitignore\fR ファイルと同じ構文を使用します。 その詳細については、\fBgitignore\fR(5) を参照してください。 ただし、ここでは通常、どのファイルを除外するかではなく、どのファイルを含めるかを選択するためにパターンが使用されています。 (ただし、gitignore スタイルのパターンでは \fB!\fR で始まるパターンによって否定が定義されているため、「含めない」ファイルを選択することもでき、少々混乱することがあります。 )
.sp
たとえば、(\fBunwanted\fR という名前のファイルを除くすべてのファイルが作業ツリーに表示されるように)、すべてを選択してからファイル \fBunwanted\fR を削除するには以下のようにします:
.sp
.if n \{\
.RS 4
.\}
.nf
git sparse\-checkout set \-\-no\-cone \*(Aq/*\*(Aq \*(Aq!unwanted\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
これらのパターンはそのまま \fB$GIT_DIR/info/sparse\-checkout\fR というファイルに配置されるため、この時点での、このファイルの内容は以下のようになります
.sp
.if n \{\
.RS 4
.\}
.nf
/*
!unwanted
.fi
.if n \{\
.RE
.\}
.sp
.sp
スパース・チェックアウトで使用される gitignore スタイルのパターンの詳細については、 \fBgit-read-tree\fR(1) の「Sparse Checkout」セクションも参照してください。
.SH "INTERNALS \(em CONE PATTERN SET"
.sp
コーン・モードでは、ディレクトリのみが受け入れられますが、完全なパターン・セットで使用されるのと同じ gitignore スタイルのパターンに変換されます。 私達はその際に使用される特殊なパターンを2つのタイプに分類しています:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
\fB再帰\fR: (recursive)ディレクトリ内のすべてのパスが含まれます
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
\fB親\fR: (parent)ディレクトリ直下のすべてのファイルが含まれます。
.RE
.sp
コーン・モードでは常にトップレベルにファイルが含まれるため、 ディレクトリを指定せずに \fBgit sparse\-checkout set\fR を実行すると、 トップレベル・ディレクトリが親パターンとして追加されます。 この時点で、スパース・チェック・ファイルには以下のパターンが含まれています:
.sp
.if n \{\
.RS 4
.\}
.nf
/*
!/*/
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、「最上位ディレクトリの直下のすべてを含めますが、それより下のレベルのは何も含めない」という意味です。
.sp
コーン・モードの場合、 \fBgit sparse\-checkout set\fR サブコマンドはディレクトリのリストを受け取ります。 コマンド \fBgit sparse\-checkout set A/B/C\fR はディレクトリ \fBA/B/C\fR を再帰パターンとして設定し、 ディレクトリ \fBA\fR と \fBA/B\fR が親パターンとして追加されます。 結果として得られるスパース・チェックアウト・ファイルは以下のようになります
.sp
.if n \{\
.RS 4
.\}
.nf
/*
!/*/
/A/
!/A/*/
/A/B/
!/A/B/*/
/A/B/C/
.fi
.if n \{\
.RE
.\}
.sp
.sp
ここでは順番が重要なので、ネガティブなパターンはファイルの下位に表示されるポジティブなパターンに上書きされます。
.sp
\fBcore\&.sparseCheckoutCone\fR が明示的に \fBfalse\fR に設定されていない限り、Git はこれらのタイプのパターンを想定してスパース・チェックアウト・ファイルをパースします。 パターンが一致しない場合、Git は警告します。 パターンが予想される形式と一致する場合、Git はより高速なハッシュベースのアルゴリズムを使用して、スパース・チェックアウトへの包含を計算します。 一致しない場合、設定に関係なく、 git は \fBcore\&.sparseCheckoutCone\fR が \fBfalse\fR であるかのように動作します。
.sp
コーン・モードの場合、 完全なパターンが \fB$GIT_DIR/info/sparse\-checkout\fR ファイルに書き込まれるという事実にもかかわらず、 \fBgit sparse\-checkout list\fR サブコマンドは、再帰パターンを定義するディレクトリを一覧表示します。 上記のスパース・チェックアウト・ファイルの例では、出力は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git sparse\-checkout list
A/B/C
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fBcore\&.ignoreCase=true\fR の場合、パターンマッチングアルゴリズムは大文字と小文字を区別しないチェックを使用します。 これにより、 \fBgit sparse\-checkout set\fR コマンドのファイル名が一致しない状況が修正され、作業ディレクトリに期待される円錐(cone)が反映されます。
.SH "INTERNALS \(em SUBMODULES"
.sp
あなたのリポジトリに1つ以上のサブモジュールが含まれている場合、サブモジュールは \fBgit submodule\fR コマンドとの相互作用に基づいて入力されます。 具体的には、 \fBgit submodule init \-\- <path>\fR は \fB<path>\fR のサブモジュールが存在することを確認し、 \fBgit submodule deinit [\-f] \-\- <path>\fR は \fB<path>\fR のサブモジュールのファイルを削除します(追跡されていないファイル、コミットされていない変更、プッシュされていない履歴を含む)。sparse\-checkoutが作業ツリーからファイルを削除するが、インデックスにエントリを残す方法と同様に、初期化されていないサブモジュールは作業ディレクトリから削除されますが、インデックスにはエントリがあります。
.sp
サブモジュールにはプッシュされていない変更または追跡されていないファイルがある可能性があるため、それらを削除するとデータが失われる可能性があります。 したがって、スパース 包含/除外 ルールを変更しても、すでにチェックアウトされているサブモジュールが作業コピーから削除されることはありません。 別の言い方をすれば、サブモジュールを削除または追加するブランチを切り替えても、 \fBcheckout\fR によってサブモジュールが自動的に削除または初期化されないのと同様に、 \fBsparse\-checkout\fR を使用して「興味深い」ファイルの範囲を縮小または拡大してもサブモジュールの自動的な非初期化または初期化は発生しません。
.sp
さらに、上記の事実は、「追跡された」ファイルが作業コピーに存在しない可能性に複数の理由があることを意味します。スパースチェックアウトからのスパースパターンアプリケーション、およびサブモジュールの初期化状態です。 したがって、作業コピー内の追跡されたファイルで機能する \fBgit grep\fR のようなコマンドは、これらの制限のいずれかまたは両方によって制限される結果を返す可能性があります。
.SH "SEE ALSO"
.sp
\fBgit-read-tree\fR(1) \fBgitignore\fR(5)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
