'\" t
.\"     Title: git-update-ref
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-UPDATE\-REF" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-update-ref \- refに保存されているオブジェクト名を安全に更新します
.SH "SYNOPSIS"
.sp
.nf
\fIgit update\-ref\fR [\-m <reason>] [\-\-no\-deref] (\-d <ref> [<oldvalue>] | [\-\-create\-reflog] <ref> <newvalue> [<oldvalue>] | \-\-stdin [\-z])
.fi
.sp
.SH "DESCRIPTION"
.sp
2つの引数が与えられた場合、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。例えば、 \fBgit update\-ref HEAD <newvalue>\fR は、現在のブランチヘッドを新しいオブジェクトに更新します。
.sp
3つの引数が与えられた場合、<ref>の現在の値が<oldvalue>と一致することを確認した後、<newvalue>を<ref>に格納し、シンボリックrefを逆参照する可能性があります。 例えば、 \fBgit update\-ref refs/heads/master <newvalue> <oldvalue>\fR は、現在の値が<oldvalue>の場合にのみ、masterブランチヘッドを<newvalue>に更新します。 あなたは、作成する参照がまだ存在しないこと示すために、40個の"0" または 空の文字列を <oldvalue> として指定する事ができます。
.sp
また、 "ref:" という4バイトのヘッダーシーケンスで開始することにより、「ref」ファイルを別のrefファイルへのシンボリックポインタにすることもできます。
.sp
さらに重要なことは、refファイルの更新は、シンボリックリンクであろうと、これらの「通常のファイルのシンボリック参照」であろうと、これらのシンボリックポインタに従います。 \fBrefs/\fR で始まる場合にのみ「実際」のシンボリックリンクをたどります。それ以外の場合は、それらを読み取って通常のファイルとして更新しようとします(つまり、ファイルシステムはそれらを追跡できますが、他の場所へのそのようなシンボリックリンクは通常のファイル名で上書きされます)。
.sp
\fB\-\-no\-deref\fR を指定すると、シンボリックポインターをたどった結果ではなく、<ref>自体が上書きされます。
.sp
一般的には以下ように使います
.sp
.if n \{\
.RS 4
.\}
.nf
git update\-ref HEAD "$head"
.fi
.if n \{\
.RE
.\}
.sp
これは、以下のようにするよりもはるかに安全なはずです
.sp
.if n \{\
.RS 4
.\}
.nf
echo "$head" > "$GIT_DIR/HEAD"
.fi
.if n \{\
.RE
.\}
.sp
シンボリックリンク追跡とエラーチェックの両方の観点から、シンボリックリンクの "refs/" ルールは、ツリーの「外側」を指すシンボリックリンクが安全であることを意味します。つまり、読み取りでは追跡されますが、書き込みでは追跡されません(したがって、シンボリックリンクツリーを作成してアーカイブ全体をコピーした場合は、refシンボリックリンクを介して他のツリーに書き込むことはありません)。
.sp
\fB\-d\fR フラグを使用すると、<ref>がまだ<oldvalue>を含んでいることを確認(verify)した後、名前付きの<ref>を削除します。
.sp
\fB\-\-stdin\fR を使用すると、update\-refは標準入力から命令を読み取り、すべての変更を一緒に実行します。 以下の形式のコマンドを指定します:
.sp
.if n \{\
.RS 4
.\}
.nf
update SP <ref> SP <newvalue> [SP <oldvalue>] LF
create SP <ref> SP <newvalue> LF
delete SP <ref> [SP <oldvalue>] LF
verify SP <ref> [SP <oldvalue>] LF
option SP <opt> LF
start LF
prepare LF
commit LF
abort LF
.fi
.if n \{\
.RE
.\}
.sp
\fB\-\-create\-reflog\fR を使用すると、update\-refは、通常は作成されない場合でも、各refのreflogを作成します。
.sp
Cソースコードの文字列であるかのように空白を含むフィールドをクォートします。 つまり、二重引用符で囲まれ、バックスラッシュ(\fB\e\fR)でエスケープされます。 ゼロ値(zero value)を指定するには、40個の "0" 文字または空の文字列を使用します。 欠落している値(missing value)を指定するには、値とその前のSPを完全に省略します。
.sp
あるいは、 \fB\-z\fR を使用して、クォートせずにNUL終了形式で指定します:
.sp
.if n \{\
.RS 4
.\}
.nf
update SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL
create SP <ref> NUL <newvalue> NUL
delete SP <ref> NUL [<oldvalue>] NUL
verify SP <ref> NUL [<oldvalue>] NUL
option SP <opt> NUL
start NUL
prepare NUL
commit NUL
abort NUL
.fi
.if n \{\
.RE
.\}
.sp
この形式では、40個の "0" を使用してゼロ値(zero value)を指定し、空の文字列を使用して欠落している値(missing value)を指定します。
.sp
どちらの形式でも、Gitがオブジェクト名として認識する任意の形式で値を指定できます。他の形式のコマンドまたは繰り返される<ref>は、エラーを生成します。 コマンドの意味は以下のとおりです:
.PP
update
.RS 4
指定されている場合は、<oldvalue>を確認した後、<ref>を<newvalue>に設定します。 ゼロ<newvalue>を指定して、更新後にrefが存在しないことを確認(verify)するか、ゼロ<oldvalue>を指定して、更新前にrefが存在しないことを確認(verify)します。
.RE
.PP
create
.RS 4
存在しないことを確認した後、<newvalue>を使用して<ref>を作成します。 指定された<newvalue>はゼロではない可能性があります。
.RE
.PP
delete
.RS 4
<oldvalue>が指定されている場合は、それが存在することを確認した後、<ref>を削除します。 指定した場合、<oldvalue>はゼロではない可能性があります。
.RE
.PP
verify
.RS 4
<ref>を<oldvalue>に対して確認(verify)しますが、変更しないでください。 <oldvalue>がゼロ(zero)または欠落(missing)している場合、refは存在してはなりません。
.RE
.PP
option
.RS 4
<ref>に名前を付ける次のコマンドの振る舞いを変更します。 唯一の有効なオプションは
\fBno\-deref\fR
で、シンボリックrefの逆参照を回避します。
.RE
.PP
start
.RS 4
トランザクションを開始します。 非トランザクションセッションとは対照的に、セッションが明示的なコミットなしで終了すると、トランザクションは自動的に中止(abort)されます。 このコマンドは、現在のトランザクションがすでにコミットまたは中止(abort)されている場合に、新しい空のトランザクションを作成する場合があります。
.RE
.PP
prepare
.RS 4
トランザクションをコミットする準備をします。 これにより、キューに入れられたすべての参照更新のロックファイルが作成されます。 ロックできない参照がある場合、トランザクションは中止(abort)されます。
.RE
.PP
commit
.RS 4
トランザクションのためにキューに入れられたすべての参照更新をコミットし、トランザクションを終了(ending)します。
.RE
.PP
abort
.RS 4
トランザクションを中止(abort)し、トランザクションが準備済み状態(prepared state)の場合はすべてのロックを解除します。
.RE
.sp
すべての<ref>を一致する<oldvalue>で同時にロックできる場合、すべての変更が実行されます。 それ以外の場合、変更は実行されません。 注意: 個々の<ref>はアトミックに更新または削除されますが、並行読み取り(concurrent reader)では変更のサブセットが表示される場合があることに注意してください。
.SH "LOGGING UPDATES"
.sp
構成パラメーター \fBcore\&.logAllRefUpdates `がtrueで、参照が `refs/heads/\fR の下にある場合、 \fBrefs/remotes/\fR または \fBrefs/notes/\fR または HEADやORIG_HEADのような疑似参照 または ファイル \fB$GIT_DIR/logs/<ref>\fR が存在する場合に、 \fBgit update\-ref\fR はログファイル \fB$GIT_DIR/logs/<ref>\fR にref値の変更を説明する行を追加します(ログ名を作成する前に、すべてのシンボリックrefを間接参照します)。 ログ行は以下のようにフォーマットされます:
.sp
.if n \{\
.RS 4
.\}
.nf
oldsha1 SP newsha1 SP committer LF
.fi
.if n \{\
.RE
.\}
.sp
「oldsha1」は以前に<ref>に保存された40文字の16進値であり、「newsha1」は<newvalue>の40文字の16進値であり、「committer」は標準のGitコミッターID形式のコミッターの名前、メールアドレス、日付です。
.sp
オプションで \fB\-m\fR と一緒に使用すると:
.sp
.if n \{\
.RS 4
.\}
.nf
oldsha1 SP newsha1 SP committer TAB message LF
.fi
.if n \{\
.RE
.\}
.sp
これは、すべてのフィールドが上記のとおりであり、「message」が \fB\-m\fR オプションに指定された値です。
.sp
現在のユーザーが新しいログファイルを作成できない場合、既存のログファイルに追加できない場合、またはコミッター情報が利用できない場合、更新は（<ref>を変更せずに）失敗します。
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
