'\" t
.\"     Title: gitworkflows
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GITWORKFLOWS" "7" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
gitworkflows \- Gitで推奨の作業手順の概要
.SH "SYNOPSIS"
.sp
.nf
git *
.fi
.sp
.SH "DESCRIPTION"
.sp
この文書は、 \fBgit\&.git\fR 自体に使用されるワークフロー要素のいくつかを書き留めて動機付けしようとしています。一般に多くのアイデアが当てはまりますが、関係者が少ない小規模なプロジェクトではこのような完全なワークフローが必要になることはめったにありません。
.sp
私たちが、すぐに参照できるように一連の「ルール」を作ったのは、本当にみんなのモチベーションを高めるためです。ですから常に文字通りに解釈する必要はありません。このような文章よりも、自分の行動に対する正当な理由を大切にしてください。
.SH "SEPARATE CHANGES"
.sp
原則として、変更を小さな論理ステップに分割し、それぞれでコミットするようにしてください。それらは一貫性があり、その後のコミットとは独立して機能し、テストスイートに合格する必要があります。これにより、レビュープロセスがはるかに簡単になり、その履歴は、たとえば \fBgit-blame\fR(1) や \fBgit-bisect\fR(1)を使用して後で検査や分析する時にはるかに役立ちます。
.sp
これを実現するには、最初から作業を小さなステップに分割してみてください。1つの大きなコミットを複数に分割するよりも、いくつかのコミットをまとめる方が常に簡単です。途中で小さすぎる、または不完全なステップを作成することを恐れないでください。いつでも後で戻って、公開する前に \fBgit rebase \-\-interactive\fR を使用してコミットを編集できます。 \fBgit stash push \-\-keep\-index\fR を使用して、他のコミットされていない変更とは無関係にテストスイートを実行できます。 \fBgit-stash\fR(1) の「EXAMPLES」セクションを参照してください。
.SH "MANAGING BRANCHES"
.sp
あるブランチから別のブランチへの変更を含めるために使用できる2つの主要なツールがあります。 \fBgit-merge\fR(1) と \fBgit-cherry-pick\fR(1) です。
.sp
マージには多くの利点があるため、マージだけで可能な限り多くの問題を解決しようとしています。 cherry\-pickingまだ時々役に立ちます。例については、以下の「Merging upwards」を参照してください。
.sp
最も重要なことは、マージはブランチレベルで機能し、チェリーピッキングはコミットレベルで機能することです。これは、マージが1、10、または1000のコミットからの変更を同じように簡単に引き継ぐことができることを意味します。つまり、ワークフローは多数の貢献者(および貢献)に対してはるかに適切にスケーリングされます。マージコミットは、すべての親からのすべての変更が含まれた「約束」(promise)であるため、マージも理解しやすくなります。
.sp
もちろん、トレードオフがあります。マージには、より慎重なブランチ管理が必要です。以下のサブセクションでは、重要なポイントについて説明します。
.SS "Graduation"
.sp
特定の機能が実験的なもの(experimental)から安定したもの(stable)に変わると、ソフトウェアの対応するブランチ間でも「段階的に」(graduates)移行します。 \fBgit\&.git\fR は以下の「統合ブランチ」(integration branches)を使用します:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBmaint\fR
は、次の「メンテナンスリリース」(maintenance release)、つまり最後にリリースされた安定バージョンの更新に入るコミットを追跡します
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBmaster\fR
は、次のリリースに入る予定のコミットを追跡します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBnext\fR
は、masterの安定性をテストするトピックのテストブランチとして意図されています。
.RE
.sp
少し異なる方法で使用される4番目の公式ブランチがあります:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBseen\fR
(メンテナによって表示されるパッチ)は、まだ含める準備が整っていないモノの統合ブランチです(以下の「Integration Branches」を参照)。
.RE
.sp
4つのブランチのそれぞれは、通常、その上のブランチの直接の子孫です。
.sp
概念的には、機能(feature)は不安定なブランチ(通常は「next」または「seen」)に入り、十分に安定している(stable)と見なされると、次のリリースのために「master」に「卒業」(graduates)します。
.SS "Merging upwards"
.sp
上記の「downwards graduation」(下向きの卒業)は、実際に下向きにマージすることによって実行することはできません。なぜなら、不安定なブランチの「すべての」変更が安定したブランチにマージされるためです。 したがって、以下のようになります:
.PP
\fBExample\ \&1.\ \&Merge upwards\fR
.sp
修正を必要とするサポートされている最も古いブランチに常に修正をコミットします。 次に、 (定期的に)統合ブランチを互いに上向きにマージします。
.sp
これにより、修正のフローが非常によく制御されます。たとえば、修正を適用したことに気付いた場合。 \fBmaint\fR でも必要な \fBmaster\fR は、(\fBgit-cherry-pick\fR(1) を使用して)下向きにチェリーピックする必要があります。これは数回発生しますが、頻繁に実行しない限り心配する必要はありません。
.SS "Topic branches"
.sp
重要な機能を実装するにはいくつかのパッチが必要であり、その存続期間中に追加のバグ修正または改善が行われる可能性があります。
.sp
統合ブランチですべてを直接コミットすると、多くの問題が発生します。不正なコミットは元に戻せないため、1つずつ元に戻す必要があります。これにより、変更のグループの一部を元に戻すのを忘れると、混乱した履歴とエラーが発生する可能性があります。並行して作業すると、変更がごちゃまぜになり、さらに混乱が生じます。
.sp
「topic branches」(トピックブランチ)を使用すると、これらの問題が解決されます。名前はかなり自明ですが、上記の「merge upwards」(上向きにマージ)ルールに由来する警告があります:
.PP
\fBExample\ \&2.\ \&Topic branches\fR
.sp
すべてのトピック(機能、バグ修正など)のサイドブランチを作成します。最終的にマージする最も古い統合ブランチでフォークします。
.sp
そうすれば、以下のように多くのことが非常に自然に実行できます:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
機能/バグ修正を統合ブランチに取り込むには、それをマージするだけです。その間にトピックがさらに進化した場合は、再度マージしてください。 (必ずしも最初に最も古い統合ブランチにマージする必要はないことに注意してください。たとえば、最初にバグ修正を next にマージし、テスト時間を与え、安定していることがわかったら maint にマージできます。)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
トピックの作業を続行するためにブランチ other の新機能が必要な場合は、 other を topic にマージします。 (ただし、これを「習慣的に」行わないでください。以下を参照してください。)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
分岐したブランチが間違っていることに気づき、それを「過去にさかのぼって」移動したい場合は、
\fBgit-rebase\fR(1)
を使用してください。
.RE
.sp
注意: 最後の項目が他の2つと衝突することに注意してください。他の場所でマージされたトピックは、リベースしないでください。 \fBgit-rebase\fR(1) の「RECOVERING FROM UPSTREAM REBASE」に関するセクションを参照してください。
.sp
(通常は理由もなく)「習慣的に」統合ブランチをあなたのトピックにマージすること(つまり、トピックを拡張し、定期的に上流からマージし続けること)は眉をひそめられる行為であることを指摘しておく必要があります。
.PP
\fBExample\ \&3.\ \&明確に定義されたポイントでのみ下流にマージします\fR
.sp
正当な理由がある場合を除いて、ダウンストリームにマージしないでください。正当な理由とは、例えば、アップストリームAPIの変更がブランチに影響する、ブランチがアップストリームにきれいにマージされなくなりました、等です。
.sp
正当な理由以外の場合、マージされたトピックには、(激しくバラバラの)突然の複数の変更が含まれます。結果として生じる多くの小さなマージは、履歴を大幅に混乱させます。後でファイルの履歴を調査する人は、そのマージが開発中のトピックに影響を与えたかどうかを確認する必要があります。アップストリームは、誤って「より安定した」ブランチにマージされることさえあるかも等々。
.SS "使い捨て統合"
.sp
先程の話題についていうと、多くの小さなトピックブランチがあり、あなたはそれらがどのように相互作用するのかワケワカメに思うことがあるでしょう。それらをマージしたらちゃんと機能しないかも？ そして、このようなマージは簡単に元に戻せないため、我々はこれらに対して「安定した」場所でのマージは避けたいと考えています。
.sp
もちろん、解決策は、元に戻すことができるマージを作成することです。つまり、使い捨てブランチ(throw\-away branch)にマージします。
.PP
\fBExample\ \&4.\ \&Throw\-away integration branches\fR
.sp
いくつかのトピックの相互作用をテストするには、それらを使い捨てのブランチにマージします。あなたは決してそのようなブランチに基づいて作業を行ってはいけません！
.sp
テストの直後にこのブランチが削除されることを(非常に)明確にすると、このブランチを公開して、たとえば、テスターがこのブランチを操作できるようにしたり、他の開発者が進行中の作業に互換性があるかどうかを確認したりすることもできます。 \fBgit\&.git\fR には、「seen」と呼ばれるそのような公式の使い捨て統合ブランチがあります。
.SS "Branch management for a release"
.sp
上記のマージアプローチを使用していると仮定すると、プロジェクトをリリースするときに、追加のブランチ管理作業を行う必要があります。
.sp
「master」は次の機能(feature)リリースに入るコミットを追跡するため、機能(feature)リリースは「master」ブランチから作成されます。
.sp
master ブランチは、 maint のスーパーセットであると想定されています。この条件が満たされない場合、 maint には master に含まれていないコミットが含まれています。したがって、 maint のコミットによって表される修正は、機能(feature)リリースには含まれません。
.sp
master が実際に maint のスーパーセットであることを確認するには、 \fBgit log\fR を使用します:
.PP
\fBExample\ \&5.\ \&master が maint のスーパーセットであることを確認(verify)します:\fR
.sp
\fBgit log master\&.\&.maint\fR
.sp
このコマンドは、コミットを一切リストしないはずです。そうでない場合は、「master」をチェックアウトし、「maint」をマージします。
.sp
これで、あなたは機能(feature)リリースの作成に進むことができます。リリースバージョンを示すタグを「master」の先端に適用します:
.PP
\fBExample\ \&6.\ \&Release tagging\fR
.sp
\fBgit tag \-s \-m "Git X\&.Y\&.Z" vX\&.Y\&.Z master\fR
.sp
あなたは新しいタグをパブリックGitサーバーにプッシュする必要があります(以下の「DISTRIBUTED WORKFLOWS」参照)。これにより、プロジェクトを追跡している他のユーザーがタグを利用できるようになります。プッシュでは、更新後のフックをトリガーして、リリースtarballの作成や事前にフォーマットされたドキュメントページなどのリリース関連の項目を実行することもできます。
.sp
同様に、メンテナンスリリースの場合、「maint」はリリースされるコミットを追跡します。ゆえに、タグのリリース手順では、「master」ではなく「maint」にタグを付けてプッシュするだけです。
.SS "機能リリース後のメンテナンスブランチ管理"
.sp
機能(feature)リリース後、あなたはメンテナンスブランチを管理する必要があります。
.sp
まず、直近のリリースより前に行われた機能リリースのメンテナンス修正を引き続きリリースする場合は、その前のリリースのコミットを追跡するために別のブランチを作成する必要があります。
.sp
これを行うために、現在のメンテナンスブランチは、以前のリリースバージョン番号で名前が付けられた別のブランチにコピーされます(例: maint\-X\&.Y\&.(Z\-1) ここでX\&.Y\&.Zは現在のリリースとする)。
.PP
\fBExample\ \&7.\ \&Copy maint\fR
.sp
\fBgit branch maint\-X\&.Y\&.(Z\-1) maint\fR
.sp
maint ブランチは、新しくリリースされたコードに早送り(fast\-forwarded)され、現在のリリースのメンテナンス修正を追跡できるようになります:
.PP
\fBExample\ \&8.\ \&Update maint to new release\fR
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit checkout maint\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit merge \-\-ff\-only master\fR
.RE
.sp
早送り(fast\-forwarded)ではないためにマージが失敗した場合は、機能リリースで「maint」のいくつかの修正が欠落している可能性があります。前のセクションで説明したようにブランチのコンテンツを検証(verify)した場合、これは発生しません。
.SS "機能リリース後の「next」と「seen」のブランチ管理"
.sp
機能のリリース後、統合ブランチ next は、オプションで、 next の残りのトピックを使用して、 master の先端から巻き戻されて再構築される場合があります:
.PP
\fBExample\ \&9.\ \&Rewind and rebuild \fBnext\fR\fR
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit switch \-C next master\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit merge ai/topic_in_next1\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit merge ai/topic_in_next2\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\&...
.RE
.sp
これを行うことの利点は、「next」の履歴がクリーンになることです。 たとえば、「next」にマージされた一部のトピックは、最初は有望に見えたかもしれませんが、後で望ましくないか時期尚早であることがわかりました。このような場合、トピックは「next」から元に戻され(revert)ますが、一度マージされて元に戻されたという事実は履歴に残ります。「next」を再作成することで、そのようなトピックの別の化身に再試行するためのきれいな状態を与えることができます。機能のリリースは、これを行うための履歴上の良い地点です。
.sp
これを行う場合は、「next」が巻き戻されて再構築されたことを示す公開アナウンスを行う必要があります。
.sp
「seen」についても、同じの巻き戻しと再構築のプロセスを行います。なお、上記のとおり「seen」は使い捨てのブランチであるため、公の発表は必要ありません。
.SH "DISTRIBUTED WORKFLOWS"
.sp
前セクションを読んだ今となっては、あなたはトピックを管理する方法を知っておくべきです。 一般的に、プロジェクトに取り組んでいるのはあなただけではないので、あなたの仕事は共有しなければなりません。
.sp
大まかに言えば、マージとパッチという2つの重要な作業フローがあります。重要な違いは、マージ作業フローはマージを含む完全な履歴を伝播できますが、パッチは伝播できないことです。両方の作業フローを並行して使用できます。\fBgit\&.git\fR では、サブシステムメンテナのみがマージ作業フローを使用し、他のすべての作業フローはパッチを送信します。
.sp
注意: メンテナは、インクルードするために提出されたすべてのコミット/パッチが遵守しなければならない「Signed\-off\-by」要件などの制限を課すことができることに注意してください。より詳細な情報については、プロジェクトのドキュメントを参照してください。
.SS "Merge workflow"
.sp
マージ作業フローは、上流(upstream)と下流(downstream)の間でブランチをコピーすることによって機能します。上流では、貢献の結果を公式の履歴に統合することができます。下流では、公式の履歴に基づいて作業します。
.sp
これに使用できる主なツールは3つあります:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit-push\fR(1)
は、ブランチをリモートリポジトリにコピーします。通常は、関係者全員が読み取れるリポジトリにコピーします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit-fetch\fR(1)
は、リモートブランチをあなたのリポジトリにコピーします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit-pull\fR(1)
は、フェッチしてマージするのを一度に行います。
.RE
.sp
注意: 最後の点に注意してください。 実際にリモートブランチをマージする場合を除いて \fBgit pull\fR を使用しないでください。
.sp
変更を取得するのは簡単です:
.PP
\fBExample\ \&10.\ \&push/pull: branches/topics の公開\fR
.sp
\fBgit push <remote> <branch>\fR を実行、そして、どこからフェッチできるかをみんなに伝えます。
.sp
あなたは今の所メールなどの他の手段で人々に伝えなければなりません。 (Gitは \fBgit-request-pull\fR(1) を提供して、このタスクを簡素化するために、事前にフォーマットされたプルリクエストをアップストリームのメンテナーに送信します。 )
.sp
統合ブランチの最新のコピーを取得したいだけの場合は、最新の状態に保つのも簡単です:
.PP
\fBExample\ \&11.\ \&push/pull: 最新の状態に保つ\fR
.sp
最新の状態に保つには \fBgit fetch <remote>\fR または \fBgit remote update\fR を使います。
.sp
次に、以前に説明したように、安定したリモートからトピックブランチをフォークするだけです。
.sp
あなたがメンテナであり、他の人のトピックブランチを統合ブランチにマージしたい場合、他の人々は通常、メールでそうするようにリクエストを送信してきます。そのようなリクエストは以下のようになります
.sp
.if n \{\
.RS 4
.\}
.nf
Please pull from
    <URL> <branch>
.fi
.if n \{\
.RE
.\}
.sp
.sp
その場合、 \fBgit pull\fR は、以下のように、フェッチとマージを一度に実行できます。
.PP
\fBExample\ \&12.\ \&Push/pull: Merging remote topics\fR
.sp
\fBgit pull <URL> <branch>\fR
.sp
場合によっては、メンテナが下流(downstream)から変更をプルしようとすると、マージの競合が発生することがあります。 この場合、下流にマージを実行して競合を彼ら自身で解決するように依頼できます(おそらく、彼らは競合を解決する方法をよりよく知っているでしょう)。これは、下流が上流(upsteram)からマージする必要があるまれなケースの1つです。
.SS "Patch workflow"
.sp
あなたが変更を電子メールの形式でアップストリームに送信する貢献者の場合は、通常どおりトピックブランチを使用する必要があります(上記参照)。 次に、 \fBgit-format-patch\fR(1) を使用して、対応する電子メールを生成します(メンテナの作業が楽になるため、手動でフォーマットするよりもこれを使うのを強く推奨します)。
.PP
\fBExample\ \&13.\ \&format\-patch/am: Publishing branches/topics\fR
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit format\-patch \-M upstream\&.\&.topic\fR
を使用して、事前に形式が決まっているパッチファイルに変換します
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit send\-email \-\-to=<recipient> <patches>\fR
.RE
.sp
使用上の注意については、 \fBgit-format-patch\fR(1) と \fBgit-send-email\fR(1) のmanpageを参照してください。
.sp
あなたのパッチがもはや現在の上流(upstream)に適用されなくなったとメンテナが告げた場合は、トピックをリベースする必要があります(format\-patch マージができないため、マージを使用できません):
.PP
\fBExample\ \&14.\ \&format\-patch/am: Keeping topics up to date\fR
.sp
\fBgit pull \-\-rebase <URL> <branch>\fR
.sp
あなたはその後、リベース中に競合を修正できます。おそらくあなたはメール以外であなたのトピックを公開していないので、それをリベースすることは問題ではありません。
.sp
あなたがこのようなパッチシリーズを受け取った場合(メンテナとして、または送信先のメーリングリストの読者として)、メールをファイルに保存し、新しいトピックブランチを作成し、 \fBgit am\fR を使用してコミットをインポートします:
.PP
\fBExample\ \&15.\ \&format\-patch/am: Importing patches\fR
.sp
\fBgit am < patch\fR
.sp
指摘する価値のある機能の1つは、競合が発生した場合に役立つ3方向マージです。 \fBgit am \-3\fR は、パッチに含まれるインデックス情報を使用して、マージベースを把握します。他のオプションについては \fBgit-am\fR(1) を参照してください。
.SH "SEE ALSO"
.sp
\fBgittutorial\fR(7), \fBgit-push\fR(1), \fBgit-pull\fR(1), \fBgit-merge\fR(1), \fBgit-rebase\fR(1), \fBgit-format-patch\fR(1), \fBgit-send-email\fR(1), \fBgit-am\fR(1)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
