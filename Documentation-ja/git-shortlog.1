'\" t
.\"     Title: git-shortlog
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-SHORTLOG" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-shortlog \- 「git log」の出力を要約します。
.SH "SYNOPSIS"
.sp
.nf
\fIgit shortlog\fR [<options>] [<revision\-range>] [[\-\-] <path>\&...]
git log \-\-pretty=short | \fIgit shortlog\fR [<options>]
.fi
.sp
.SH "DESCRIPTION"
.sp
「git log」の出力を、リリースアナウンスに含めるのに適した形式で要約します。各コミットは、作者とタイトルごとにグループ化されます。
.sp
加えて、「[PATCH]」はコミットの説明から削除されます。
.sp
コマンドラインでリビジョンが渡されず、かつ、標準入力が端末ではないかまたは現在のブランチがない場合、「git shortlog」は、現在のリポジトリを参照せずに、標準入力から読み取られたログの概要を出力します。
.SH "OPTIONS"
.PP
\fB\-n\fR, \fB\-\-numbered\fR
.RS 4
作者のアルファベット順ではなく、作者のコミット数に従って出力を並べ替えます。
.RE
.PP
\fB\-s\fR, \fB\-\-summary\fR
.RS 4
コミットの説明を抑制し、コミット数の要約のみを提供します。
.RE
.PP
\fB\-e\fR, \fB\-\-email\fR
.RS 4
各作者のメールアドレスを表示します。
.RE
.PP
\fB\-\-format[=<format>]\fR
.RS 4
コミットの件名の代わりに、他の情報を使用して各コミットを説明します。
\fB<format>\fR
は、
\fB* [%h] %s\fR
など 、
\fBgit log\fR
の
\fB\-\-format\fR
オプションで受け入れられる任意の文字列にすることができます。 (\fBgit-log\fR(1)
の「PRETTY FORMATS」セクションを参照してください。)
.sp
.if n \{\
.RS 4
.\}
.nf
pretty\-printされた各コミットは、表示される前に再ラップ(rewrapp)されます。
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fB\-\-group=<type>\fR
.RS 4
グループは
\fB<type>\fR
に基づいてコミットします。
\fB\-\-group\fR
オプションが指定されていない場合、デフォルトは
\fBauthor\fR
です。
\fB<type>\fR
は以下のいずれかです:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBauthor\fR
: コミットは作成者ごとにグループ化されます
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBcommitter\fR
: コミットはコミッターによってグループ化されます(
\fB\-c\fR
と同じ)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBtrailer:<field>\fR
:
\fB<field>\fR
は大文字と小文字を区別しないコミットメッセージトレーラーとして解釈されます(\fBgit-interpret-trailers\fR(1)
参照)。たとえば、プロジェクトで
\fBReviewed\-by\fR
のトレーラーを使用している場合、
\fBgit shortlog \-ns \-\-group=trailer:reviewed\-by\fR
を使用して誰がレビューしているかを確認できます。
.sp
注意: トレーラーを含まないコミットはカウントされないことに注意してください。同様に、複数のトレーラーを使用したコミット(複数のサインオフなど)は、複数回カウントされる場合があります(ただし、そのコミットの一意のトレーラー値ごとに1回のみです)。
.sp
shortlog は、各トレーラー値を
\fBname <email>\fR
ID としてパースしようとします。成功すると、mailmapが適用され、
\fB\-\-email\fR
オプションが指定されていない限りemailは省略されます。値をIDとして解析できない場合は、その文言通りに取得されます。
.RE
.sp
\fB\-\-group\fR
が複数回指定されている場合、コミットは各値でカウントされます(ただし、そのコミットの一意の値ごとに1回だけカウントされます)。 たとえば、
\fBgit shortlog \-\-group=author \-\-group=trailer:co\-authored\-by\fR
は、authorとco\-authorの両方をカウントします。
.RE
.PP
\fB\-c\fR, \fB\-\-committer\fR
.RS 4
\fB\-\-group=committer\fR
のエイリアスです。
.RE
.PP
\fB\-w[<width>[,<indent1>[,<indent2>]]]\fR
.RS 4
各行を
\fBwidth\fR
で折り返すことにより、出力を行折り返します。各エントリの最初の行は
\fBindent1\fR
スペースでインデントされ、2行目以降は
\fBindent2\fR
スペースでインデントされます。
\fBwidth\fR
と
\fBindent1\fR
と
\fBindent2\fR
のデフォルトは、それぞれ76と6と9です。
.sp
widthが
\fB0\fR
(ゼロ)の場合、出力の行を折り返すことなくインデントします。
.RE
.PP
<revision\-range>
.RS 4
指定のリビジョン範囲のコミットのみを表示します。 <revision\-range> が指定されていない場合、デフォルトで
\fBHEAD\fR
(つまり、現在のコミットにつながる履歴全体)になります。
\fBorigin\&.\&.HEAD\fR
は、現在のコミット(つまり、
\fBHEAD\fR
)から到達可能なすべてのコミットを指定しますが、
\fBorigin\fR
からは指定しません。 <revision\-range> のスペルの完全なリストについては、
\fBgitrevisions\fR(7)
の「Specifying Ranges」セクションを参照してください。
.RE
.PP
[\-\-] <path>\&...
.RS 4
指定されたパスに一致するファイルがどのように作成されたかを説明するのに十分なコミットのみを検討してください。
.sp
混乱が生じた場合、パスをオプションまたはリビジョン範囲から分離するために、パスの前に
\fB\-\-\fR
を付ける必要がある場合があります。
.RE
.SS "Commit Limiting"
.sp
ここで説明されている特別な表記法を使用してリストする必要があるコミットの範囲を指定することに加えて、追加のコミット制限が適用される場合があります。
.sp
より多くのオプションを使用すると、通常、出力がさらに制限されます(たとえば、\fB\-\-since=<date1>`は\fR<date1>\fBより新しいコミットに制限され、\fR\-\-grep=<pattern>\fBと一緒に使用すると、ログメッセージに\fR<pattern>`と一致する行があるコミットにさらに制限されます)。
.sp
注意: これらは、`\-\-reverse`などのコミット順序およびフォーマットオプションの前に適用されることに注意してください。
.PP
\fB\-<number>\fR, \fB\-n <number>\fR, \fB\-\-max\-count=<number>\fR
.RS 4
出力するコミットの数を制限します。
.RE
.PP
\fB\-\-skip=<number>\fR
.RS 4
コミット出力の表示を開始する前に、number 個のコミットをスキップします。
.RE
.PP
\-\-since=<date>, \fB\-\-after=<date>\fR
.RS 4
指定の日付よりも新しいコミットを表示します。
.RE
.PP
\fB\-\-since\-as\-filter=<date>\fR
.RS 4
特定の日付より新しいすべてのコミットを表示します。 これは、特定の日付より古い最初のコミットで停止するのではなく、範囲内のすべてのコミットを訪問します。
.RE
.PP
\fB\-\-until=<date>\fR, \fB\-\-before=<date>\fR
.RS 4
指定の日付より古いコミットを表示します。
.RE
.PP
\fB\-\-author=<pattern>\fR, \fB\-\-committer=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致する作者(author)/コミッター(committer)ヘッダー行を持つものに制限します。複数の
\fB\-\-author=<pattern>\fR
がある場合、作者が指定されたパターンのいずれかに一致するコミットが選択されます(複数の
\fB\-\-committer=<pattern>\fR
の場合も同様)。
.RE
.PP
\fB\-\-grep\-reflog=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致するreflogエントリを持つものに制限します。複数の`\-\-grep\-reflog`を使用すると、指定されたパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。`\-\-walk\-reflogs`が使用されていない限り、このオプションを使用するとエラーになります。
.RE
.PP
\fB\-\-grep=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致するログメッセージを持つものに制限します。複数の`\-\-grep=<pattern>\fBを使用すると、指定されたパターンのいずれかにメッセージが一致するコミットが選択されます(全てに一致するコミットだけを選択したい場合、\fR\-\-all\-match`を参照してください)。
.sp
`\-\-notes`が有効な場合、ノートからのメッセージは、ログメッセージの一部であるかのようにマッチングされます。
.RE
.PP
\fB\-\-all\-match\fR
.RS 4
コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての`\-\-grep`に一致するものに制限します。
.RE
.PP
\fB\-\-invert\-grep\fR
.RS 4
コミット出力を、`\-\-grep=<pattern>`で指定されたパターンと一致しないログメッセージを持つものに制限します。
.RE
.PP
\fB\-i\fR, \fB\-\-regexp\-ignore\-case\fR
.RS 4
大文字小文字に関係なく、正規表現の制限パターンに一致します。
.RE
.PP
\fB\-\-basic\-regexp\fR
.RS 4
制限パターンを基本正規表現として扱います。これがデフォルトです。
.RE
.PP
\fB\-E\fR, \fB\-\-extended\-regexp\fR
.RS 4
制限パターンを、デフォルトの基本正規表現の代わりに拡張正規表現として扱います。
.RE
.PP
\fB\-F\fR, \fB\-\-fixed\-strings\fR
.RS 4
制限パターンを固定文字列として扱います(パターンを正規表現として解釈しないでください)。
.RE
.PP
\fB\-P\fR, \fB\-\-perl\-regexp\fR
.RS 4
制限パターンをPerl互換の正規表現として扱います。
.sp
これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。Gitが当該のサポート付きでコンパイルされていない場合、このオプションを提供すると、Gitが死にます(die)。
.RE
.PP
\fB\-\-remove\-empty\fR
.RS 4
指定されたパスがツリーから見えなくなったら停止(stop)します。
.RE
.PP
\fB\-\-merges\fR
.RS 4
マージコミットのみを印刷します。これは`\-\-min\-parents=2`とまったく同じです。
.RE
.PP
\fB\-\-no\-merges\fR
.RS 4
複数の親を持つコミットを出力しない。これは`\-\-max\-parents=1`とまったく同じです。
.RE
.PP
\fB\-\-min\-parents=<number>\fR, \fB\-\-max\-parents=<number>\fR, \fB\-\-no\-min\-parents\fR, \fB\-\-no\-max\-parents\fR
.RS 4
量の多少に関わらず、とにかく複数の親コミットがあるコミットのみを表示します。特に、\fB\-\-max\-parents=1`は\fR\-\-no\-merges`と同じであり、\fB\-\-min\-parents=2`は\fR\-\-merges`と同じです。\fB\-\-max\-parents=0`はすべてのルートコミットを提供し、\fR\-\-min\-parents=3`はすべてのタコ足マージ(octopus merges)を示します。
.sp
\fB\-\-no\-min\-parents`と\fR\-\-no\-max\-parents`は、これらの制限を(制限なしに)再度リセットします。同等の形式は、\fB\-\-min\-parents=0\fR(すべてのコミットに0個以上の親があります)および`\-\-max\-parents=\-1`(マイナスの数は上限がないことを示します)です。
.RE
.PP
\fB\-\-first\-parent\fR
.RS 4
インクルードするコミットを探すとき、マージ・コミットの最初の親コミットのみをたどります。 このオプションは、特定のトピックブランチの進化を表示するときに、より良い概要を提供できます。トピックブランチへのマージは、時々更新されるアップストリームに調整することだけである傾向があり、このオプションを使用すると、そのようなマージによって履歴に取り込まれた個々のコミットを無視できます。
.RE
.PP
\fB\-\-exclude\-first\-parent\-only\fR
.RS 4
(\fB^\fR
を使用して)除外するコミットを見つけるときは、判明したマージ・コミットの最初の親コミットのみに従います。 任意のマージが有効なトピック・ブランチの変更になる可能性がある場合、これを使用して、リモート・ブランチから分岐したポイントからトピック・ブランチ内の一連の変更を見つけることができます。
.RE
.PP
\fB\-\-not\fR
.RS 4
次に現れる
\fB\-\-not\fR
までの間、後続のすべてのリビジョン指定子の
\fB^\fR(カレット)接頭辞(またはその欠如)の意味を逆にします。
.RE
.PP
\fB\-\-all\fR
.RS 4
\fBrefs/\fR
内のすべてのrefが HEAD とともに、コマンドラインに <commit> としてリストされているかのように見せかけます。
.RE
.PP
\fB\-\-branches[=<pattern>]\fR
.RS 4
\fBrefs/heads\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-tags[=<pattern>]\fR
.RS 4
\fBrefs/tags\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合は、指定されたシェルグロブ(shell glob)に一致するタグにタグを制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-remotes[=<pattern>]\fR
.RS 4
\fBrefs/remotes\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、リモート追跡ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-glob=<glob\-pattern>\fR
.RS 4
シェルグロブ <glob\-pattern> に一致するすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。先頭の
\fBrefs/\fR
は、欠落している場合は自動的に先頭に追加されます。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-exclude=<glob\-pattern>\fR
.RS 4
次の
\fB\-\-all\fR
または
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
または
\fB\-\-glob\fR
が別の方法で考慮する <glob\-pattern> に一致するrefを含めないでください。このオプションを繰り返すと、次の
\fB\-\-all\fR
または
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
または
\fB\-\-glob\fR
オプションまで除外パターンが蓄積されます(他のオプションまたは引数は、蓄積されたパターンをクリアしません)。
.sp
与えられたパターンは、それぞれ
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
に適用される場合、
\fBrefs/heads\fR
または
\fBrefs/tags\fR
または
\fBrefs/remotes\fR
で始まるべきではありません。
\fB\-\-glob\fR
または
\fB\-\-all\fR
に適用する場合は、
\fBrefs/\fR
で始める必要があります。末尾の "/*" を意図している場合は、明示的に指定する必要があります。
.RE
.PP
\fB\-\-reflog\fR
.RS 4
reflogsで言及されているすべてのオブジェクトがコマンドラインに <commit> としてリストされているかのように見せかけます。
.RE
.PP
\fB\-\-alternate\-refs\fR
.RS 4
代替リポジトリのref先端として言及されているすべてのオブジェクトがコマンドラインにリストされているかのように見せかけます。代替リポジトリは、オブジェクトディレクトリが`objects/info/alternates`で指定されているリポジトリです。インクルードされたオブジェクトのセットは、`core\&.alternateRefsCommand`などによって変更できます。\fBgit-config\fR(1)を参照してください。
.RE
.PP
\fB\-\-single\-worktree\fR
.RS 4
デフォルトでは、作業ツリーが複数ある場合、\fB\-\-all`と\fR\-reflog`と`\-\-indexed\-objects`では、すべての作業ツリーが検査されます(\fBgit-worktree\fR(1)を参照)。このオプションは、現在の作業ツリーのみを調べるように強制します。
.RE
.PP
\fB\-\-ignore\-missing\fR
.RS 4
入力に無効なオブジェクト名が含まれている場合、そもそもその不正な入力が行われていないかのように見せかけます。
.RE
.PP
\fB\-\-bisect\fR
.RS 4
コマンドラインで、bad bisection ref
\fBrefs/bisect/bad\fR
がリストされ、その後に
\fB\-\-not\fR
と good bisection ref
\fBrefs/bisect/good\-*\fR
が続くかのように見せかけます。
.RE
.PP
\fB\-\-stdin\fR
.RS 4
コマンドラインにリストされている <commit> に加えて、標準入力からそれらを読み取ります。
\fB\-\-\fR
区切り文字が表示された場合は、コミットの読み取りを停止し、パスの読み取りを開始して結果を制限します。
.RE
.PP
\fB\-\-cherry\-mark\fR
.RS 4
\fB\-\-cherry\-pick\fR（以下を参照）と同様ですが、同等のコミットを省略せずに
\fB=\fR
と印し、同等でないコミットを
\fB+\fR
と印します。
.RE
.PP
\fB\-\-cherry\-pick\fR
.RS 4
コミットの組を対称差(symmetric difference)に制限する場合、「反対側」の別のコミットと同じ変更を導入するコミットを省略します。
.sp
たとえば、\fBA\fR
と
\fBB\fR
の2つのブランチがある場合、それらの片側だけですべてのコミットを一覧表示する通常の方法は、
\fB\-\-left\-right\fR
を使用することです(\fB\-\-left\-right\fR
オプションの説明の以下の例を参照してください)。ただし、他のブランチからは(ブランチAと重複しない)厳選されたコミットが表示されます(たとえば、「3rd onb」はブランチAからチェリーピックされる可能性があります)。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。
.RE
.PP
\fB\-\-left\-only\fR, \fB\-\-right\-only\fR
.RS 4
リストは、対称差のそれぞれの側でのみコミットします。つまり、\fB\-\-left\-right`で `<\fR
と印されるのだけか、あるいは`\-\-left\-right`で`>`と印されるものだけです。
.sp
たとえば、\fB\-\-cherry\-pick \-\-right\-only A\&.\&.\&.B`は、`A`にある、または`A`のコミットとパッチと同等のコミットを`B`から省略します。つまり、これは`git cherry A B`からの\fR+\fBコミットをリストします。より正確に書くと、\fR\-\-cherry\-pick \-\-right\-only \-\-no\-merges`により正確なリストを提供します。
.RE
.PP
\fB\-\-cherry\fR
.RS 4
`\-\-right\-only \-\-cherry\-mark \-\-no\-merges`の同義語です。出力を私たちの側のコミットに制限し、フォークされた履歴の反対の側に適用されたものを、`git cherry upstream mybranch`と同様に`git log \-\-cherry upstream\&...mybranch`で印するのに役立ちます。
.RE
.PP
\fB\-g\fR, \fB\-\-walk\-reflogs\fR
.RS 4
コミットの祖先チェーンをたどる代わりに、reflogエントリを最新のものから古いものに移動します。このオプションを使用する場合、除外するコミットを指定することはできません(つまり、 "^commit" や
\fBcommit1\&.\&.commit2\fR
や
\fBcommit1\&.\&.\&.commit2\fR
表記は使用できません)。
.sp
(明らかな理由で、)\fBoneline`と`reference`以外の\fR\-\-pretty`形式では、これにより、出力にreflogから取得された2行の追加情報が含まれます。出力のreflog指定子は、\fBref@{Nth}\fR
(\fBNth\fR
はreflogの逆時系列インデックス(reverse\-chronological index))または
\fBref@{timestamp}\fR
(そのエントリのタイムスタンプ付き)として表示されます。表示は下記のいくつかのルールに依存します:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
開始点が
\fBref@{Nth}\fR
として指定されている場合は、インデックス形式を表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
開始点が
\fBref@{now}\fR
として指定されている場合は、タイムスタンプ形式を表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
上記のどちらも使用されていないが、コマンドラインで`\-\-date`が指定されている場合は、`\-\-date`で要求された形式でタイムスタンプを表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
それ以外の場合は、インデックス形式を表示します。
.RE
.sp
\fB\-\-pretty = oneline`では、コミットメッセージの前にこの情報が同じ行に付けられます。このオプションを\fR\-\-reverse`と組み合わせることはできません。\fBgit-reflog\fR(1)も参照してください。
.sp
`\-\-pretty=reference`では、この情報はまったく表示されません。
.RE
.PP
\fB\-\-merge\fR
.RS 4
マージが失敗した後、競合があり、マージするすべてのheadに存在しないファイルに関連(touch)するrefを表示します。
.RE
.PP
\fB\-\-boundary\fR
.RS 4
除外された境界コミットを出力します。 境界コミットの前には `\-`が付いています。
.RE
.SS "History Simplification"
.sp
特定の<path>を変更するコミットなど、履歴の一部のみに関心がある場合があります。ただし、「履歴の簡略化」(History Simplification)は2つの部分から成ります。履歴を簡略化するためにはさまざまな戦略があるためです。その1つはコミットの選択であり、もう1つはそれを行う方法です。
.sp
以下のオプションは、表示するコミットを選択します:
.PP
<paths>
.RS 4
指定された<パス>を変更するコミットが選択されます。
.RE
.PP
\fB\-\-simplify\-by\-decoration\fR
.RS 4
いくつかのブランチまたはタグによって参照されるコミットが選択されます。
.RE
.sp
注意: 意味のある重要な履歴のために、追加のコミットを表示できることに注意してください。
.sp
以下のオプションは、簡略化の実行方法に影響します。
.PP
Default mode
.RS 4
履歴を、ツリーの最終状態を説明する最も単純な履歴に単純化します。最終結果が同じである場合(つまり、同じコンテンツのブランチをマージする場合)、いくつかの傍流ブランチ(side branches)を削除するため、最も単純です。
.RE
.PP
\fB\-\-show\-pulls\fR
.RS 4
デフォルトモードからのすべてのコミットを含めますが、最初の親へのTREESAMEではなく、後の親へのTREESAMEであるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに役立ちます。(訳注:TREESAME=pathspecが全く同一であるツリー)
.RE
.PP
\fB\-\-full\-history\fR
.RS 4
デフォルトモードと同じですが、一部の履歴を削除しません。
.RE
.PP
\fB\-\-dense\fR
.RS 4
選択したコミットのみが表示され、重大で意味のある履歴を持つコミットもいくつか表示されます。
.RE
.PP
\fB\-\-sparse\fR
.RS 4
簡略化された履歴内のすべてのコミットが表示されます。
.RE
.PP
\fB\-\-simplify\-merges\fR
.RS 4
このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除するための`\-\-full\-history`への追加オプション。
.RE
.PP
\fB\-\-ancestry\-path[=<commit>]\fR
.RS 4
表示するコミットの範囲を指定すると(例:
\fBcommit1\&.\&.commit2\fR
または
\fBcommit2 ^commit1\fR)、その範囲内で <commit> の祖先、<commit> の子孫、または <commit> 自身であるコミットのみを表示します。 コミットが指定されていない場合は、\fBcommit1\fR
(範囲の除外部分) を <commit> として使用します。 複数回渡すことができます。 その場合、あるコミットが指定されたコミットのいずれかであるか、それらのいずれかの祖先または子孫である場合、そのコミットは含まれます。
.RE
.sp
より詳細な説明は以下のとおりです。
.sp
<paths> として \fBfoo\fR を指定したとします。 \fBfoo\fR !TREESAME を変更するコミットを呼び出し、残りをTREESAMEと呼びます。( \fBfoo\fR のためにフィルタリングされた差分では、それぞれ異なって見えたりたり等しく見えたりします。）
.sp
以下、簡略化設定の違いを説明するために、同じ履歴例を使います。このコミットグラフでは、ファイル \fBfoo\fR をフィルタリングしていると想定しています:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \e   /   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq   X
.fi
.if n \{\
.RE
.\}
.sp
.sp
履歴 A\-\-\-Q の水平線は、各マージの最初の親と見なされます。その各コミットは以下のとおりです:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBI\fR
は最初のコミットであり、ファイル foo が内容 \(lqasdf\(rq で存在し、ファイル quux は内容 \(lqquux\(rq で存在します。最初のコミットは空のツリーと比較されるため、\fBI\fR
は !TREESAME です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBA\fR
では、 foo には \(lqfoo\(rq だけが含まれています。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBB\fR
には
\fBA\fR
と同じ変更が含まれています。そのマージ
\fBM\fR
は些細なことであり、したがってすべての親にとって TREESAME です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\fR
は
\fBfoo\fR
を変更しませんが、そのマージ
\fBN\fR
はそれを \(lqfoobar\(rq に変更するので、どの親にとっても TREESAME ではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBD\fR
は
\fBfoo\fR
を \(lqbaz\(rq に設定します。そのマージ
\fBO\fR
は、
\fBN\fR
と
\fBD\fR
から \(lqfoobarbaz\(rq への文字列を結合します。つまり、どの親にとっても TREESAME ではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBE\fR
は
\fBquux\fR
を \(lqxyzzy\(rq に変更し、そのマージ
\fBP\fR
は文字列を \(lqquuxxyzzy\(rq に結合します。
\fBP\fR
は
\fBO\fR
に対して TREESAME ですが、
\fBE\fR
に対してはそうではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBX\fR
は、新ファイル
\fBside\fR
を追加し、
\fBY\fR
がそれを変更した独立したルートコミットです。
\fBY\fR
は
\fBX\fR
へのTREESAMEです。そのマージ
\fBQ\fR
は
\fBP\fR
に
\fBside\fR
を追加し、
\fBQ\fR
は
\fBP\fR
にはTREESAMEですが、\fBY\fR
に対してはそうではありません。
.RE
.sp
\fBrev\-list\fR は、 \fB\-\-full\-history\fR および/または、( \fB\-\-parents\fR または \fB\-\-children\fR を介して)親の書き換えが使用されているかどうかに基づいて、コミットを含めたり除外したりして、履歴を逆方向にウォークスルーします。以下の設定が可能です。
.PP
Default mode
.RS 4
コミットは、どの親に対してもTREESAMEでない場合に含まれます(これは変更できますが、以下の
\fB\-\-sparse\fR
を参照してください)。コミットがマージであり、一方の親に対するTREESAMEであった場合は、その親のみをフォローします。(TREESAMEの親が複数ある場合でも、そのうちの1つだけをフォローします)。それ以外の場合は、すべての親をフォローします。
.sp
これにより、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-N\-\-\-O
         /     /   /
        I\-\-\-\-\-\-\-\-\-D
.fi
.if n \{\
.RE
.\}
.sp
TREESAMEの親のみに従うルールが利用可能な場合は、
\fBB\fR
を検討対象から完全に削除したことに注意してください。
\fBC\fR
は
\fBN\fR
を介して考慮されましたが、しかしそれはTREESAMEです。ルートコミットは空のツリーと比較されるため、
\fBI\fR
は !TREESAME です。
.sp
親子関係は
\fB\-\-parents\fR
でのみ表示されますが、デフォルトモードで選択されたコミットには影響しないため、親の行を示しました。
.RE
.PP
\fB\-\-full\-history without parent rewriting\fR
.RS 4
このモードは、デフォルトとはある一点で異なります。つまり、いずれかの親に対してTREESAMEであっても、常にマージのすべての親に従います。マージの複数の側にコミットが含まれている場合でも、これはマージ自体が含まれていることを意味するものではありません！ 例では以下のようになります。
.sp
.if n \{\
.RS 4
.\}
.nf
        I  A  B  N  D  O  P  Q
.fi
.if n \{\
.RE
.\}
.sp
\fBM\fR
は、両方の親にとってTREESAMEであるため、除外されました。
\fBE\fR
と
\fBC\fR
と
\fBB\fR
をすべて巡りましたが、
\fBB\fR
だけが !TREESAME だったので、他は表示されません。
.sp
注意: 親の書き換え(rewrite)がないと、コミット間の親子関係について話す(talk)ことは実際には不可能であるため、それらが切断されている(disconnected)ことを示していることに注意してください。
.RE
.PP
\fB\-\-full\-history with parent rewriting\fR
.RS 4
通常のコミットは !TREESAME の場合にのみ含まれます(これは変更できますが、以下の
\fB\-\-sparse\fR
を参照してください)。
.sp
マージは常に含まれます。ただし、親リストは書き直されます。各親に沿って、自分自身に含まれていないコミットを削除します。 これにより以下のようになります。
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /
        I     B   /   D   /
         \e   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
上記を書き直さずに
\fB\-\-full\-history\fR
と比較してください。
\fBE\fR
はTREESAMEであるため削除されましたが、Pの親リストは
\fBE\fR
の親
\fBI\fR
を含むように書き直されていることに注意してください。
\fBC\fR
と
\fBN\fR
および
\fBX\fR
と
\fBY\fR
と
\fBQ\fR
についても同じことが起こりました。
.RE
.sp
上記の設定に加えて、あなたはTREESAMEが包含に影響を与えるかどうかを変更できます:
.PP
\fB\-\-dense\fR
.RS 4
巡ったコミットは、親にとってTREESAMEでない場合に含まれます。
.RE
.PP
\fB\-\-sparse\fR
.RS 4
巡ったすべてのコミットが含まれます。
.sp
\fB\-\-full\-history\fR
がなくても、これによりマージが単純化されることに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側を巡ることはありません。
.RE
.PP
\fB\-\-simplify\-merges\fR
.RS 4
最初に、親を書き換えた
\fB\-\-full\-history\fR
と同じ方法で履歴グラフを作成します(上記を参照)。
.sp
それから、以下のルールに従って、各コミット
\fBC\fR
を最終履歴内の置換
\fBC\*(Aq\fR
に単純化します:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\*(Aq\fR
を
\fBC\fR
にセットします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\*(Aq\fR
の各親
\fBP\fR
をその簡略化された
\fBP\*(Aq\fR
に置き換えます。その過程で、他の親の祖先であるか、ルートである親を削除すると、TREESAMEが空のツリーにコミットされ、重複が削除されますが、TREESAMEであるすべての親を削除しないように注意してください。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
この親の書き換え後、
\fBC\*(Aq\fR
がルートまたはマージコミット(0または >1 の親を持つ)、境界コミット、または !TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。
.RE
.sp
この効果は、親の書き換えを使用した
\fB\-\-full\-history\fR
と比較することで最もよく示されます。例は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O
         /     /       /
        I     B       D
         \e   /       /
          `\-\-\-\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
注意:
\fB\-\-full\-history\fR
に対する
\fBN\fR
と
\fBP\fR
と
\fBQ\fR
の主な違いに注意してください:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBN\fR
の親リストは、他の親
\fBM\fR
の祖先であるため、
\fBI\fR
が削除されました。それでも、 !TREESAME なので
\fBN\fR
が残りました。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBP\fR
の親リストも同様に
\fBI\fR
が削除されました。
\fBP\fR
は、親が1つで TREESAMEであるため、完全に削除されました。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBQ\fR
の親リストでは、
\fBY\fR
が
\fBX\fR
に簡略化されていました。その後、
\fBX\fR
はTREESAMEルートであったため、削除されました。
\fBQ\fR
は、親が1つで TREESAMEであるため、完全に削除されました。
.RE
.RE
.sp
利用可能な別の簡略化モードがあります:
.PP
\fB\-\-ancestry\-path[=<commit>]\fR
.RS 4
表示されるコミットを <commit> の祖先、または <commit> の子孫、または <commit> 自身に制限します。
.sp
ユースケースの例として、以下のコミット履歴について考えます:
.sp
.if n \{\
.RS 4
.\}
.nf
            D\-\-\-E\-\-\-\-\-\-\-F
           /     \e       \e
          B\-\-\-C\-\-\-G\-\-\-H\-\-\-I\-\-\-J
         /                     \e
        A\-\-\-\-\-\-\-K\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
通常の
\fBD\&.\&.M\fR
は、
\fBM\fR
の祖先であるコミットのセットを計算しますが、
\fBD\fR
の祖先であるコミットは除外します。 これは、「
\fBM\fR
には
\fBD\fR
には存在しなかったものがある」という意味で、
\fBD\fR
以降の
\fBM`に至るまでの歴史に何が起こったのかを知るのに役立ちます。この例の結果は、 `A\fR
と
\fBB\fR
(そしてもちろん
\fBD\fR
自体)を除くすべてのコミットになります。
.sp
ただし、
\fBM\fR
のコミットが
\fBD\fR
で入ったバグで汚染されており、修正が必要な場合は、実際には
\fBD\fR
の子孫である
\fBD\&.\&.M\fR
のサブセットのみを表示する必要があります。つまり、
\fBC\fR
と
\fBK\fR
を除外します。これはまさに
\fB\-\-ancestry\-path\fR
オプションが行うことです。これを
\fBD\&.\&.M\fR
範囲に適用すると、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                E\-\-\-\-\-\-\-F
                 \e       \e
                  G\-\-\-H\-\-\-I\-\-\-J
                               \e
                                L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
\fB\-\-ancestry\-path\fR
の代わりに
\fB\-\-ancestry\-path=D\fR
を使用することもできます。これは、\fBD\&.\&.M\fR
範囲に適用された場合と同じことを意味しますが、より明示的です。
.sp
代わりに、この範囲内の特定のトピックに関心があり、そのトピックによって影響を受けるすべてのコミットに関心がある場合、祖先パスにそのトピックを含む
\fBD\&.\&.M\fR
のサブセットのみを表示したい場合があります。 たとえば、\fB\-\-ancestry\-path=H D\&.\&.M\fR
を使用すると、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                E
                 \e
                  G\-\-\-H\-\-\-I\-\-\-J
                               \e
                                L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
一方、\fB\-\-ancestry\-path=K D\&.\&.M\fR
は以下のようになります
.sp
.if n \{\
.RS 4
.\}
.nf
                K\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
別のオプション \fB\-\-show\-pulls\fR について説明する前に、新しいサンプル履歴を作成する必要があります。
.sp
簡略化された履歴を見るときにユーザーが直面する一般的な問題は、ファイルを変更したことがわかっているコミットが、ファイルの簡略化された履歴に表示されないことです。そこで、新しい例を示し、その場合に \fB\-\-full\-history\fR や \fB\-\-simplify\-merges\fR などのオプションがどのように機能するかを示しましょう。
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-\-\-C\-\-N\-\-\-O\-\-\-P
         /     / \e  \e  \e/   /   /
        I     B   \e  R\-\*(Aq`\-Z\*(Aq   /
         \e   /     \e/         /
          \e /      /\e        /
           `\-\-\-X\-\-\*(Aq  `\-\-\-Y\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
この例では、 \fBI\fR が \fBfile\&.txt\fR を作成し、それが \fBA\fR と`B` と \fBX\fR にてさまざまな方法で変更されたとします。ひとり親のコミット \fBC\fR と \fBZ\fR と \fBY\fR は \fBfile\&.txt\fR を変更していません。マージコミット \fBM\fR は、マージの競合を解決して、 \fBA\fR と \fBB\fR の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。ただし、マージコミット \fBR\fR は、 \fBM\fR の \fBfile\&.txt`の内容を無視し、 `X\fR の \fBfile\&.txt\fR の内容のみを取得することによって作成されました。 したがって、 \fBR\fR は \fBX\fR へのTREESAMEですが、 \fBM\fR はそうではありません。最後に、 \fBN\fR を作成するための自然なマージ解決は、 \fBR\fR で \fBfile\&.txt\fR の内容を取得することです。したがって、 \fBN\fR は \fBC\fR ではなく \fBR\fR へのTREESAMEです。マージコミット \fBO\fR と \fBP\fR は、最初の親にはTREESAMEですが、2番目の親である \fBZ\fR と \fBY\fR にはついてはそうではありません。
.sp
デフォルトモードを使用する場合、 \fBN\fR と \fBR\fR は両方ともTREESAMEの親を持っているため、これらのエッジはウォークされ、他のエッジは無視されます。結果の履歴グラフは以下のとおりです:
.sp
.if n \{\
.RS 4
.\}
.nf
        I\-\-\-X
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fB\-\-full\-history\fR を使用する場合、Gitはすべてのエッジを巡ります。これにより、コミット \fBA\fR と \fBB\fR と マージ \fBM\fR が検出されますが、マージコミット \fBO\fR と \fBP\fR も明らかになります。 親を書き換えると、結果のグラフは以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-\-\-\-\-\-N\-\-\-O\-\-\-P
         /     / \e  \e  \e/   /   /
        I     B   \e  R\-\*(Aq`\-\-\*(Aq   /
         \e   /     \e/         /
          \e /      /\e        /
           `\-\-\-X\-\-\*(Aq  `\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
ここで、マージコミット \fBO\fR と \fBP\fR は、実際には \fBfile\&.txt\fR への変更を提供しなかったため、余分なノイズを提供します。古いバージョンの \fBfile\&.txt\fR に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です。 \fB\-\-full\-history\fR の結果には、関連のない多くのマージが表示されます。
.sp
\fB\-\-simplify\-merges\fR オプションを使用すると、コミット \fBO\fR と \fBP\fR が結果から消えます。 これは、 \fBO\fR と \fBP\fR の書き直された2番目の親が、最初の親から到達可能であるためです。これらのエッジが削除されると、コミットは、親にとってTREESAMEである単一の親のコミットのように見えます。これはコミット \fBN\fR にも発生し、以下のような履歴ビューが表示されます:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\&.
         /     /    \e
        I     B      R
         \e   /      /
          \e /      /
           `\-\-\-X\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
このビューでは、 \fBA\fR と \fBB\fR と \fBX\fR からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ \fBM\fR とそれほど慎重に解決されていないマージ \fBR\fR も表示されます。これは通常、コミット \fBA\fR と \fBB\fR がデフォルトのビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。
.sp
最初の問題はパフォーマンスです。以前のオプションとは異なり、 \fB\-\-simplify\-merges\fR オプションでは、単一の結果を返す前にコミット履歴全体をウォークする必要があります。これにより、非常に大規模なリポジトリでこのオプションを使用するのが難しくなる可能性があります。
.sp
2番目の問題は監査の1つです。多くの寄稿者が同じリポジトリで作業している場合、どのマージコミットが重要なブランチに変更を導入したかが重要です。上記の問題のあるマージ \fBR\fR は、重要なブランチにマージするために使用されたマージコミットではない可能性があります。 代わりに、マージ \fBN\fR を使用して \fBR\fR と \fBX\fR を重要なブランチにマージしました。このコミットには、変更 \fBX\fR がコミットメッセージの \fBA\fR と \fBB\fR からの変更を上書きするようになった理由に関する情報が含まれている可能性があります。
.PP
\fB\-\-show\-pulls\fR
.RS 4
デフォルトの履歴に表示されるコミットに加えて、最初の親にはTREESAMEではなく、後の親にはTREESAMEである各マージコミットを表示します。
.sp
マージコミットが
\fB\-\-show\-pulls\fR
に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で
\fB\-\-show\-pulls\fR
を使用すると(他のオプションは使用しない場合、)結果のグラフは行かのようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
        I\-\-\-X\-\-\-R\-\-\-N
.fi
.if n \{\
.RE
.\}
.sp
ここで、コミット
\fBX\fR
と
\fBR\fR
をそれぞれベースブランチにプルしたため、マージコミット
\fBR\fR
と
\fBN\fR
が含まれています。これらのマージは、コミット
\fBA\fR
と
\fBB\fR
がデフォルトの履歴に表示されない理由です。
.sp
\fB\-\-show\-pulls\fR
が
\fB\-\-simplify\-merges\fR
とペアになっている場合、グラフには必要なすべての情報が含まれます:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\&.   N
         /     /    \e /
        I     B      R
         \e   /      /
          \e /      /
           `\-\-\-X\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
\fBM\fR
は
\fBR\fR
から到達可能であるため、
\fBN\fR
から
\fBM\fR
へのエッジが単純化されていることに注意してください。ただし、
\fBN\fR
は、変更
\fBR\fR
をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。
.RE
.sp
\fB\-\-simplify\-by\-decoration\fR オプションを使用すると、タグで参照されていないコミットを省略して、履歴のトポロジの全体像のみを表示できます。コミットは、(1)タグによって参照されている場合、または (2)コマンドラインで指定されたパスの内容を変更した場合に、!TREESAMEとしてマークされます(つまり、上記の履歴簡略化ルールの後に保持されます)。他のすべてのコミットはTREESAMEとしてマークされます(簡略化される可能性があります)。
.SH "MAPPING AUTHORS"
.sp
See \fBgitmailmap\fR(5)\&.
.sp
注意: (標準入力でログの内容を処理するため) \fBgit shortlog\fR がリポジトリの外部で実行される場合、現在のディレクトリで \fB\&.mailmap\fR ファイルが検索されることに注意してください。
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
