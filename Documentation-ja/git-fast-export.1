'\" t
.\"     Title: git-fast-export
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-FAST\-EXPORT" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-fast-export \- Gitデータエクスポーター
.SH "SYNOPSIS"
.sp
.nf
\fIgit fast\-export [<options>]\fR | \fIgit fast\-import\fR
.fi
.sp
.SH "DESCRIPTION"
.sp
このプログラムは、指定されたリビジョンを \fBgit fast\-import\fR にパイプするのに適した形式でダンプします。
.sp
人間が読める形式のバンドル置換として(linkgit：git\-bundle[1] 参照)、または履歴の書き換えを行うために \fBgit fast\-import\fR にフィードする前に編集できる形式として使用できます(\fBgit filter\-repo\fR などのツールの能力に依存します)。
.SH "OPTIONS"
.PP
\fB\-\-progress=<n>\fR
.RS 4
インポート中に
\fBgit fast\-import\fR
で表示されるように、<n>オブジェクトごとに
\fBprogress\fR
ステートメントを挿入します。
.RE
.PP
\fB\-\-signed\-tags=(verbatim|warn|warn\-strip|strip|abort)\fR
.RS 4
署名付きタグの処理方法を指定します。 エクスポート後の変換によってタグ名が変更される可能性があるため(リビジョンを除外する場合にも発生する可能性があります)、署名は一致しません。
.sp
\fBabort\fR
(デフォルト)を要求すると、このプログラムは署名されたタグに遭遇すると停止します。
\fBstrip\fR
を使用すると、タグは黙って署名なしになり、
\fBwarn\-strip\fR
を使用すると、タグは署名なしになりますが、警告が表示されます。
\fBverbatim\fR
を使用すると、タグは黙ってにエクスポートされ、
\fBwarn\fR
を使用すると、 エクスポートされますが、警告が表示されます。
.RE
.PP
\fB\-\-tag\-of\-filtered\-object=(abort|drop|rewrite)\fR
.RS 4
タグ付けされたオブジェクトが除外される、タグの処理方法を指定します。 エクスポートするリビジョンとファイルはパスによって制限される可能性があるため、タグ付けされたオブジェクトは完全にフィルタリングされる可能性があります。
.sp
\fBabort\fR
(デフォルト)を要求すると、このプログラムはそのようなタグに遭遇すると停止します。
\fBdrop\fR
を使用すると、そのようなタグが出力から省略されます。
\fBrewrite\fR
を使用すると、タグ付けされたオブジェクトがコミットの場合、タグを書き換えて祖先のコミットにタグを付けます(親の書き換えを介して、
\fBgit-rev-list\fR(1)
参照)
.RE
.PP
\fB\-M\fR, \fB\-C\fR
.RS 4
\fBgit-diff\fR(1)
のマニュアルページで説明されているように、移動 および/または コピーの検出を実行し、それを使用して、出力ダンプに rename および copy コマンドを生成します。
.sp
注意: これらのオプションを指定した場合、このコマンドの以前のバージョンは警告を出さずに誤った結果を生成することに注意してください。
.RE
.PP
\fB\-\-export\-marks=<file>\fR
.RS 4
完了すると、内部マークテーブルを<file>にダンプします。 マークは1行に1つずつ
\fB:markid SHA\-1\fR
として書き込まれます。 リビジョンのマークのみがダンプされます。 ブロブのマークは無視されます。 バックエンドはこのファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行(incremental runs)全体でマークテーブルを保存したりできます。 <file>は完了時にのみ開かれ、切り捨てられるため、同じパスを
\fB\-\-import\-marks\fR
に安全に指定することもできます。 新しいオブジェクトが マーク/エクスポート されていない場合、ファイルは書き込まれません。
.RE
.PP
\fB\-\-import\-marks=<file>\fR
.RS 4
入力を処理する前に、<file>で指定されたマークをロードします。 入力ファイルは存在し、読み取り可能であり、
\fB\-\-export\-marks\fR
によって生成されたものと同じ形式を使用する必要があります。
.RE
.PP
\fB\-\-mark\-tags\fR
.RS 4
マークIDでブロブとコミットにラベルを付けることに加えて、タグにもラベルを付けます。 これは、
\fB\-\-export\-marks\fR
および
\fB\-\-import\-marks\fR
と組み合わせて使用すると便利です。また、ネストされたタグのエクスポートにも役立ちます(そして必要です)。 それは他のケースを損なうことはなく、デフォルトになりえますが、多くのfast\-importフロントエンドは、マーク識別子を持つタグを受け入れる準備ができていません。
.sp
すでにマークされているコミット(またはタグ)は、再度エクスポートされません。 バックエンドが同様の
\fB\-\-import\-marks\fR
ファイルを使用する場合、これにより、複数実行に渡ってマークを同一に保つことにより、リポジトリの増分双方向エクスポートが可能になります。
.RE
.PP
\fB\-\-fake\-missing\-tagger\fR
.RS 4
一部の古いリポジトリには、taggerのないタグがあります。 fast\-importプロトコルはそれについてかなり厳格であり、それを許可しません。 したがって、出力を高速にインポートできるように、taggerを偽造します。
.RE
.PP
\fB\-\-use\-done\-feature\fR
.RS 4
\fBfeature done\fR
句(stanza)でストリームを開始し、
\fBdone\fR
コマンドで終了します。
.RE
.PP
\fB\-\-no\-data\fR
.RS 4
ブロブオブジェクトの出力をスキップし、代わりに元のSHA\-1ハッシュを介してブロブを参照します。 これは、個々のファイルの内容に触れることなく、リポジトリのディレクトリ構造または履歴を書き換える場合に役立ちます。 結果のストリームは、必要なオブジェクトがすでに含まれているリポジトリでのみ使用できることに注意してください。
.RE
.PP
\fB\-\-full\-tree\fR
.RS 4
このオプションにより、fast\-exportは、コミットごとに
\fBdeleteall\fR
ディレクティブを発行し、その後にコミット内のすべてのファイルの完全なリストを発行します(コミットの最初の親とは異なるファイルをリストするだけではありません)。
.RE
.PP
\fB\-\-anonymize\fR
.RS 4
履歴と保存されたツリーの形を維持しながら、リポジトリのコンテンツを匿名化(anonymize)します。 以下の「ANONYMIZING」のセクションを参照してください。
.RE
.PP
\fB\-\-anonymize\-map=<from>[:<to>]\fR
.RS 4
匿名化(anonymized)された出力でトークン
\fB<from>\fR
を
\fB<to>\fR
に変換します。
\fB<to>`を省略した場合は、 `<from>\fR
をそれ自体にマップします(つまり、匿名化しません)。 以下の「ANONYMIZING」セクションを参照してください。
.RE
.PP
\fB\-\-reference\-excluded\-parents\fR
.RS 4
デフォルトでは、
\fBgit fast\-export master~5\&.\&.master\fR
などのコマンドを実行すると、コミット master~5 が含まれなくなり、master~4 の親として master~5 がなくなります( ただし、古い master~4 と 新しい master~4 の両方に同じファイルがあります)。
\fB\-\-reference\-excluded\-parents\fR
を使用して、代わりに、sha1sum によって除外された履歴範囲内のコミットをストリームに参照させます。 結果のストリームは、必要な親コミットがすでに含まれているリポジトリでのみ使用できることに注意してください。
.RE
.PP
\fB\-\-show\-original\-ids\fR
.RS 4
コミットとブロブの出力に追加のディレクティブ
\fBoriginal\-oid <SHA1SUM>\fR
を追加します。 このようなディレクティブは git\-fast\-import などのインポーターによって無視される可能性がありますが、中間フィルター(たとえば、古いコミットを参照するコミットメッセージの書き換え、またはIDによるブロブの削除)に役立つ場合があります。
.RE
.PP
\fB\-\-reencode=(yes|no|abort)\fR
.RS 4
コミットオブジェクトで
\fBencoding\fR
ヘッダーを処理する方法を指定します。
\fBabort\fR
(デフォルト)を要求すると、このプログラムはそのようなコミットオブジェクトに遭遇すると停止します。
\fByes\fR
を使用すると、コミットメッセージがUTF\-8に再エンコードされます。
\fBno\fR
を使用すると、元のエンコーディングが保持されます。
.RE
.PP
\fB\-\-refspec\fR
.RS 4
指定されたrefspecをエクスポートされた各refに適用します。複数指定することができます。
.RE
.PP
[<git\-rev\-list\-args>\&...]
.RS 4
エクスポートする特定のオブジェクトと参照を指定する、
\fBgit rev\-parse\fR
および
\fBgit rev\-list\fR
に受け入れられる引数のリスト。 たとえば、
\fBmaster~10\&.\&.master\fR
を使用すると、現在のmaster参照が、10番目の祖先のコミット以降に追加されたすべてのオブジェクト、および (\-\-reference\-excluded\-parentsオプションが指定されていない場合、) master~9 と master~10 に共通のすべてのファイルとともにエクスポートされます。
.RE
.SH "EXAMPLES"
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fast\-export \-\-all | (cd /empty/repository && git fast\-import)
.fi
.if n \{\
.RE
.\}
.sp
.sp
これにより、リポジトリ全体がエクスポートされ、既存の空のリポジトリにインポートされます。 UTF\-8でないコミットの再エンコードを除いて、1対1のミラーになります。
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fast\-export master~5\&.\&.master |
        sed "s|refs/heads/master|refs/heads/other|" |
        git fast\-import
.fi
.if n \{\
.RE
.\}
.sp
.sp
これにより、 \fBmaster~5\&.\&.master\fR から \fBother\fR という新しいブランチが作成されます(つまり、 \fBmaster\fR に線形履歴がある場合は、最後の5回のコミットが必要になります)。
.sp
注意: これは、そのリビジョン範囲によって参照されるブロブとコミットメッセージのいずれにも文字列 \fBrefs/heads/master\fR が含まれていないことを前提としていることに注意してください。
.SH "ANONYMIZING(匿名化)"
.sp
\fB\-\-anonymize\fR オプションが指定されている場合、gitは、いくつかのバグを再現するのに十分な元のツリーと履歴パターンを保持しながら、リポジトリからすべての識別情報(identifying information)を削除しようとします。 その目標は、プライベートリポジトリで見つかったgitバグが匿名化されたリポジトリに残り、匿名化されたリポジトリをgit開発者と共有してバグの解決に役立てることです。
.sp
このオプションを使用すると、gitは、出力内のすべての refname、パス、ブロブコンテンツ、コミットメッセージ、タグメッセージ、名前、電子メールアドレス を匿名化されたデータに置き換えます。 同じ文字列の2つのインスタンスは同等に置き換えられます(たとえば、同じ作者による2つのコミットは、出力に同じ匿名の作者が含まれますが、元の作者文字列とは類似していません)。 コミット、ブランチ、タグの関係、コミット のタイムスタンプは保持されます(ただし、コミットメッセージとrefnameは元のメッセージとは似ていません)。 ツリーの相対的な構成は保持されますが(たとえば、10個のファイルと3個のツリーを持つルートツリーがある場合、出力も保持されます)、それらの名前とファイルの内容は置き換えられます。
.sp
あなたがgitのバグを見つけたと思う場合は、リポジトリ全体の匿名化されたストリームをエクスポートすることから始めることができます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fast\-export \-\-anonymize \-\-all >anon\-stream
.fi
.if n \{\
.RE
.\}
.sp
.sp
次に、そのストリームから作成されたリポジトリでバグが持続することを確認します(多くのバグは、リポジトリの正確な内容に依存しているため、持続しません):
.sp
.if n \{\
.RS 4
.\}
.nf
$ git init anon\-repo
$ cd anon\-repo
$ git fast\-import <\&.\&./anon\-stream
$ \&.\&.\&. test your bug \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
匿名化されたリポジトリにバグが表示されている場合は、通常のバグレポートと一緒に \fBanon\-stream\fR を共有する価値があるかもしれません。 匿名化されたストリームは非常によく圧縮されるため、gzipすることをお勧めします。ストリームを調べてプライベートデータが含まれていないことを確認する場合は、送信する前にストリームを直接確認できます。 また、試してみることもできます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ perl \-pe \*(Aqs/\ed+/X/g\*(Aq <anon\-stream | sort \-u | less
.fi
.if n \{\
.RE
.\}
.sp
.sp
これは、すべての一意の行を表示します("User 0"、 "User 1" などを "User X" に折りたたむために、数字を "X" に変換します)。 これにより、出力がはるかに小さくなり、通常、ストリームにプライベートデータがないことをすばやく確認するのは簡単です。
.sp
一部のバグを再現するには、特定のコミットまたはパスを参照する必要がある場合があります。これは、refnameおよびパスが匿名化された後に困難になります。 特定のトークンをそのままにするか、新しい値にマップするように要求できます。 たとえば、 \fBgit rev\-list sensitive \-\- secret\&.c\fR で再現されるバグがある場合は、以下のコマンドを実行できます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fast\-export \-\-anonymize \-\-all \e
      \-\-anonymize\-map=sensitive:foo \e
      \-\-anonymize\-map=secret\&.c:bar\&.c \e
      >stream
.fi
.if n \{\
.RE
.\}
.sp
.sp
ストリームをインポートした後、匿名化されたリポジトリで \fBgit rev\-list foo \-\- bar\&.c\fR を実行できます。
.sp
注意: パスとrefnameは、スラッシュ(\fB/\fR)境界でトークンに分割されることに注意してください。 上記のコマンドは、 \fBsubdir/secret\&.c\fR を \fBpath123/bar\&.c\fR のようなものとして匿名化します。 次に、あなたは匿名化されたリポジトリで \fBbar\&.c\fR を検索して、最終的なパス名を決定できます。
.sp
最終パス名の参照を簡単にするために、各パスコンポーネントをマップできます。 したがって、\fBsubdir\fR も \fBpublicdir\fR に匿名化すると、最終的なパス名は \fBpublicdir/bar\&.c\fR になります。
.SH "LIMITATIONS"
.sp
\fBgit fast\-import\fR はツリーにタグを付けることができないため、コミットではなくツリーを参照するタグが含まれている linux\&.git リポジトリを完全にエクスポートすることはできません。
.SH "SEE ALSO"
.sp
\fBgit-fast-import\fR(1)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
