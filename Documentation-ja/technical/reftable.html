<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_reftable">reftable</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview">Overview</h3>
<div class="sect3">
<h4 id="_problem_statement">Problem statement</h4>
<div class="paragraph"><p>一部のリポジトリにはたくさんの参照が含まれています(例: android の 866k、rails の 31k)。 既存の pack-refs 形式は多くのスペース(たとえば 62M とか)を占有し、追加の参照では拡張できません。 単一の参照を検索するには、ファイルを線形にスキャンする必要があります。</p></div>
<div class="paragraph"><p>複数の参照を変更するアトミック・プッシュでは、パックされた参照ファイル全体をコピーする必要があります。これは、(2つの参照が変更されただけの、)小さな取引 (transactions)でも、かなりの量のデータが移動される可能性があります(たとえば、62M の入出力)。</p></div>
<div class="paragraph"><p>各参照は 41 バイトを格納する独自のファイル (および対応する reflog 用の別のファイル) であるため、多くの緩い(loose)参照を含むリポジトリは、ローカル・ファイルシステム上で多数のディスク・ブロックを占有します。 これは、多数のリポジトリが同じファイルシステムに保存されている場合に、利用可能な inode の数に悪影響を及ぼします。 <code>$GIT_DIR/refs</code> ディレクトリをトラバースして読み取るために必要なシステムコールの数がすごくたくさんになるため、読み取り側は不利(penalize)になる可能性があります。</p></div>
</div>
<div class="sect3">
<h4 id="_objectives">Objectives</h4>
<div class="ulist"><ul>
<li>
<p>
リポジトリがコールドでプロセスやカーネルキャッシュにない場合でも、単一の参照に対してほぼ一定時間の検索(lookup)を可能にする。
</p>
</li>
<li>
<p>
オブジェクト名が少なくとも1つの参照によって参照される場合、ほぼ一定時間で検証(verification)を行う(allow-tip-sha1-in-want 用)。
</p>
</li>
<li>
<p>
<code>refs/tags/</code> のような名前空間全体の効率的な列挙。
</p>
</li>
<li>
<p>
<code>O(size_of_update)</code> 操作量によるアトミック(atomic)プッシュをサポートします。
</p>
</li>
<li>
<p>
小さな取引(transactions)用に reflog ストレージと ref ストレージを組み合わせます。
</p>
</li>
<li>
<p>
ベース ref と履歴ログ用の、個別の reflog ストレージ。
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_description">Description</h4>
<div class="paragraph"><p>reftable ファイルは、参照ストレージ用にカスタマイズされた可搬性(portable)のあるバイナリ・ファイル形式です。 参照は並べ替えられ、線形スキャン、二分木検索検索(binary search lookup)、範囲スキャンが可能になります。</p></div>
<div class="paragraph"><p>ファイル内のストレージは、可変サイズのブロックに編成されます。 ディスク領域を削減するために、1 つのブロック内でプレフィックス圧縮が使用されます。 ブロックサイズと揃え幅(alignment)は、ライターによって調整可能です。</p></div>
</div>
<div class="sect3">
<h4 id="_performance">Performance</h4>
<div class="paragraph"><p>使用スペース packed-refs V.S. reftable:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<thead>
<tr>
<th align="left" valign="top">repository </th>
<th align="right" valign="top">packed-refs </th>
<th align="right" valign="top">reftable </th>
<th align="right" valign="top">% original </th>
<th align="right" valign="top">avg ref </th>
<th align="right" valign="top">avg obj</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">android</p></td>
<td align="right" valign="top"><p class="table">62.2 M</p></td>
<td align="right" valign="top"><p class="table">36.1 M</p></td>
<td align="right" valign="top"><p class="table">58.0%</p></td>
<td align="right" valign="top"><p class="table">33 bytes</p></td>
<td align="right" valign="top"><p class="table">5 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">rails</p></td>
<td align="right" valign="top"><p class="table">1.8 M</p></td>
<td align="right" valign="top"><p class="table">1.1 M</p></td>
<td align="right" valign="top"><p class="table">57.7%</p></td>
<td align="right" valign="top"><p class="table">29 bytes</p></td>
<td align="right" valign="top"><p class="table">4 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">git</p></td>
<td align="right" valign="top"><p class="table">78.7 K</p></td>
<td align="right" valign="top"><p class="table">48.1 K</p></td>
<td align="right" valign="top"><p class="table">61.0%</p></td>
<td align="right" valign="top"><p class="table">50 bytes</p></td>
<td align="right" valign="top"><p class="table">4 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">git (heads)</p></td>
<td align="right" valign="top"><p class="table">332 b</p></td>
<td align="right" valign="top"><p class="table">269 b</p></td>
<td align="right" valign="top"><p class="table">81.0%</p></td>
<td align="right" valign="top"><p class="table">33 bytes</p></td>
<td align="right" valign="top"><p class="table">0 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>スキャン (866k ref の読み取り)と、参照名検索(lookup) (866k refs から 単一 ref を)と、SHA-1 検索(lookup) (866k refs からのその SHA-1 を含む refs):</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<thead>
<tr>
<th align="left" valign="top">format </th>
<th align="right" valign="top">cache </th>
<th align="right" valign="top">scan </th>
<th align="right" valign="top">by name </th>
<th align="right" valign="top">by SHA-1</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">packed-refs</p></td>
<td align="right" valign="top"><p class="table">cold</p></td>
<td align="right" valign="top"><p class="table">402 ms</p></td>
<td align="right" valign="top"><p class="table">409,660.1 usec</p></td>
<td align="right" valign="top"><p class="table">412,535.8 usec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">packed-refs</p></td>
<td align="right" valign="top"><p class="table">hot</p></td>
<td align="right" valign="top"><p class="table"></p></td>
<td align="right" valign="top"><p class="table">6,844.6 usec</p></td>
<td align="right" valign="top"><p class="table">20,110.1 usec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reftable</p></td>
<td align="right" valign="top"><p class="table">cold</p></td>
<td align="right" valign="top"><p class="table">112 ms</p></td>
<td align="right" valign="top"><p class="table">33.9 usec</p></td>
<td align="right" valign="top"><p class="table">323.2 usec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reftable</p></td>
<td align="right" valign="top"><p class="table">hot</p></td>
<td align="right" valign="top"><p class="table"></p></td>
<td align="right" valign="top"><p class="table">20.2 usec</p></td>
<td align="right" valign="top"><p class="table">320.8 usec</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>43,061 refs の 149,932 ログ エントリに使用されるスペース reflog V.S. reftable:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">format </th>
<th align="right" valign="top">size </th>
<th align="right" valign="top">avg entry</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">$GIT_DIR/logs</p></td>
<td align="right" valign="top"><p class="table">173 M</p></td>
<td align="right" valign="top"><p class="table">1209 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reftable</p></td>
<td align="right" valign="top"><p class="table">5 M</p></td>
<td align="right" valign="top"><p class="table">37 bytes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_details">Details</h3>
<div class="sect3">
<h4 id="_peeling">Peeling</h4>
<div class="paragraph"><p>reftable に格納された参照は皮むき(peel)され、注釈付き (または署名付き) タグのレコードは、タグ オブジェクトとそれが参照するオブジェクトの両方を記録します。 これは、packed-refs 形式のストレージに似ています。</p></div>
</div>
<div class="sect3">
<h4 id="_reference_name_encoding">Reference name encoding</h4>
<div class="paragraph"><p>参照名は解釈されないバイト列で、有効な参照名としては <a href="../git-check-ref-format.html">git-check-ref-format(1)</a> をパス(pass)しなければなりません。</p></div>
</div>
<div class="sect3">
<h4 id="_key_unicity">Key unicity</h4>
<div class="paragraph"><p>各エントリには一意のキーが必要です。 キーの繰り返しは許可されません。</p></div>
</div>
<div class="sect3">
<h4 id="_network_byte_order">Network byte order</h4>
<div class="paragraph"><p>複数バイトの固定幅フィールドは、全てネットワークバイトオーダーです。</p></div>
</div>
<div class="sect3">
<h4 id="_varint_encoding">Varint encoding</h4>
<div class="paragraph"><p>派生(varint)エンコーディングは、パックファイル内で使用される ofs-delta エンコーディング方法と同じです。</p></div>
<div class="paragraph"><p>デコーダーは以下のとおり機能します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>val = buf[ptr] &amp; 0x7f
while (buf[ptr] &amp; 0x80) {
  ptr++
  val = ((val + 1) &lt;&lt; 7) | (buf[ptr] &amp; 0x7f)
}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_ordering">Ordering</h4>
<div class="paragraph"><p>ブロックは、最初の参照によって辞書順(lexicographically ordered)に並べられます。</p></div>
</div>
<div class="sect3">
<h4 id="_directory_file_conflicts">Directory/file conflicts</h4>
<div class="paragraph"><p>reftable 形式は、<code>refs/heads/foo</code> と <code>refs/heads/foo/bar</code> の両方を別個の参照として受け入れます。</p></div>
<div class="paragraph"><p>この特性は、reftable にログ レコードを保持するのに役立ちますが、<code>$GIT_DIR/refs</code> ディレクトリ ツリーを使用して参照を維持する Git のバージョンを混乱させる可能性があります。 reftable のユーザーは、ピアの問題を防ぐために、<code>foo</code> および <code>foo/bar</code> タイプの競合を引き続き拒否することを選択できます。</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_file_format">File format</h3>
<div class="sect3">
<h4 id="_structure">Structure</h4>
<div class="paragraph"><p>reftable ファイルには、以下の高レベル構造があります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>first_block {
  header
  first_ref_block
}
ref_block*
ref_index*
obj_block*
obj_index*
log_block*
log_index*
footer</code></pre>
</div></div>
<div class="paragraph"><p>ログのみのファイルでは、<code>ref_block</code> と <code>ref_index</code> と`obj_block` と`obj_index` セクションが省略され、ファイルヘッダーとログブロックのみが含まれます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>first_block {
  header
}
log_block*
log_index*
footer</code></pre>
</div></div>
<div class="paragraph"><p>ログのみのファイルでは、最初のログ ブロックはファイル ヘッダーの直後に続き、ブロック揃え幅へのパディングは行われません。</p></div>
</div>
<div class="sect3">
<h4 id="_block_size">Block size</h4>
<div class="paragraph"><p>ファイルのブロック・サイズはライター(writer)によって任意に決定され、2 のべき乗である必要はありません。参照は複数のブロックにまたがることができないため、ブロック サイズは、リポジトリで使用される最長の参照名またはログ・エントリよりも大きくする必要があります。</p></div>
<div class="paragraph"><p>仮想メモリ・システムまたはファイル・システム (4k や 8k など) に適した 2 の累乗が推奨されます。 サイズが大きい (64k) ほど圧縮率が高くなりますが、アクセス中にリーダー(readers)が負担するコストが増加する可能性があります。</p></div>
<div class="paragraph"><p>最大ブロック サイズは「16777215」バイト (15.99 MiB) です。</p></div>
</div>
<div class="sect3">
<h4 id="_block_alignment">Block alignment</h4>
<div class="paragraph"><p>ライター(writers)は、ブロックの末尾に NUL バイトで満たされた「詰物」(padding)を含めることにより、ブロック・サイズの倍数でブロックを揃えて、選択した揃え幅(alignment)に丸めることができます。 揃えを使用する場合、ライターはファイル・ヘッダーの「block_size」フィールドで揃え幅(alignment)を指定する必要があります。</p></div>
<div class="paragraph"><p>このファイル形式では、ブロック揃え幅(alignment)は必須ではありません。 揃えない(unaligned)ファイルは、ファイル・ヘッダーで <code>block_size = 0</code> を設定し、「詰物」(padding)を省略しなければなりません。 複数の ref ブロックを含む揃えないファイルには、 <a href="#Ref-index">ref index</a> を含めて高速検索をサポートする必要があります。 リーダー(readers)は、揃えるファイルと揃えないファイルの両方を読み取ることができなければなりません。</p></div>
<div class="paragraph"><p>非常に小さなファイル (単一の ref ブロックなど) では、合計ファイル サイズを減らすために「詰物」(padding)とrefインデックスを省略できます。</p></div>
</div>
<div class="sect3">
<h4 id="_header_version_1">Header (version 1)</h4>
<div class="paragraph"><p>24バイト。ファイルの先頭に 24 バイトのヘッダーが表れます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'REFT'
uint8( version_number = 1 )
uint24( block_size )
uint64( min_update_index )
uint64( max_update_index )</code></pre>
</div></div>
<div class="paragraph"><p>揃えるファイルは、予想されるブロック揃え幅(alignment)でリーダーを構成するために、 <code>block_size</code> を指定する必要があります。 揃えないファイルは、<code>block_size = 0</code> を設定する必要があります。</p></div>
<div class="paragraph"><p><code>min_update_index</code> と <code>max_update_index</code> は、このファイル内のすべてのログ・レコードの <code>update_index</code> フィールドの境界を記述します。 <a href="#Update-transactions">transactions</a> のスタックで reftable が使用される場合、これらのフィールドは、前のファイルの <code>max_update_index + 1</code> が次のファイルの <code>min_update_index</code> になるようにファイルを並べ替えることができます。</p></div>
</div>
<div class="sect3">
<h4 id="_header_version_2">Header (version 2)</h4>
<div class="paragraph"><p>28バイト。ファイルの先頭には28バイトのヘッダーが表れます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'REFT'
uint8( version_number = 2 )
uint24( block_size )
uint64( min_update_index )
uint64( max_update_index )
uint32( hash_id )</code></pre>
</div></div>
<div class="paragraph"><p>ヘッダーは「version_number=1」と全く同じで、 4バイトのハッシュID (SHA1 の場合は「sha1」、SHA-256 の場合は「s256」) がヘッダーに追加されます。</p></div>
<div class="paragraph"><p>下位互換性を最大限に保つために、SHA1 reftable を作成する場合はバージョン 1 を使用することをお勧めします。</p></div>
</div>
<div class="sect3">
<h4 id="_first_ref_block">First ref block</h4>
<div class="paragraph"><p>最初の ref ブロックは、ファイルヘッダーと同一のブロックを共有し、ファイル内の他のすべてのブロックよりも 24 バイト小さくなります。 最初のブロックは、ファイルヘッダーの直後の 24 番目の位置から始まります。</p></div>
<div class="paragraph"><p>最初のブロックがログ・ブロック (ログのみのファイル) の場合、そのブロック・ヘッダーは位置 24 から直ちに始まります。</p></div>
</div>
<div class="sect3">
<h4 id="_ref_block_format">Ref block format</h4>
<div class="paragraph"><p>ref ブロックは以下のとおり記述されます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'r'
uint24( block_len )
ref_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</code></pre>
</div></div>
<div class="paragraph"><p>ブロックは <code>block_type = 'r'</code> で始まり、そして 3 バイトの <code>block_len</code> はブロック内のバイト数をエンコードしますが、オプションの「詰物」は含みません。 これは、常にファイルのブロック・イズ以下です。 最初の ref ブロックでは、 <code>block_len</code> にファイル・ヘッダー用の 24 バイトが含まれます。</p></div>
<div class="paragraph"><p>2 バイトの「restart_count」には、「restart_offset」リストのエントリ数が格納されます。このリストは空であってはなりません。 リーダーは、線形スキャンを開始する前に、「restart_count」を使用して再開区間(between restarts)で二分木検索を行うことができます。</p></div>
<div class="paragraph"><p>正確に <code>restart_count</code> の 3 バイトの <code>restart_offset</code> 値が <code>restart_count</code> に先行します。 オフセットはブロックの開始からの相対であり、名前がプレフィックス圧縮されていない「ref_record」の最初のバイトを参照します。 <code>restart_offset</code> リストのエントリは、昇順で並べ替える必要があります。 リーダーは、これらのレコードのいずれかから線形スキャンを開始できます。</p></div>
<div class="paragraph"><p>可変数の「ref_record」がブロックの中央部を埋め、参照名と値を記述します。 形式は下記のとおりです。</p></div>
<div class="paragraph"><p>最初の ref ブロックは最初のファイル・ブロックをファイル・ヘッダーと共有するため、最初のブロックのすべての <code>restart_offset</code> はファイルの先頭 (位置 0) からの相対であり、ファイル・ヘッダーを含みます。 これにより、最初の「restart_offset」は強制的に「28」になります。</p></div>
<div class="sect4">
<h5 id="_ref_record">ref record</h5>
<div class="paragraph"><p><code>ref_record</code> は、名前とその値の両方を格納する単一の参照を記述します。各レコードは以下の形式です:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | value_type )
suffix
varint( update_index_delta )
value?</code></pre>
</div></div>
<div class="paragraph"><p>「prefix_length」フィールドは、この参照の名前を取得するために、前の参照レコードの名前の先頭の何バイトをコピーする必要があるかを指定します。 これは、任意のブロックの最初の参照では 0 でなければならず、ブロックの最後の <code>restart_offset</code> テーブルにオフセットがリストされているすべての <code>ref_record</code> についても 0 でなければなりません。</p></div>
<div class="paragraph"><p>任意の <code>ref_record</code> から参照名を復元するのは単純な連結です:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>this_name = prior_name[0..prefix_length] + suffix</code></pre>
</div></div>
<div class="paragraph"><p><code>suffix_length</code> 値は、参照名を完成させるために <code>suffix</code> からコピーするために <code>suffix</code> で利用可能なバイト数を提供します。</p></div>
<div class="paragraph"><p>参照を最後に変更した <code>update_index</code> は、ファイル・ヘッダーの <code>min_update_index</code> に <code>update_index_delta</code> を追加することで取得できます: <code>min_update_index + update_index_delta</code></p></div>
<div class="paragraph"><p>「値」が続きます。 その形式は、以下のいずれかの「value_type」によって決まります:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>0x0</code>: 削除。値データ無し(下記 transactions 参照)
</p>
</li>
<li>
<p>
<code>0x1</code>: 1つのオブジェクト名。refの値
</p>
</li>
<li>
<p>
<code>0x2</code>: 2つのオブジェクト名。refの値と皮むきされた(peeled)ターゲット
</p>
</li>
<li>
<p>
<code>0x3</code>: シンボリック参照。 <code>varint( target_len ) target</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>シンボリック参照は <code>0x3</code> を使用し、その後に参照ターゲットの完全な名前が続きます。 ターゲット名に圧縮は適用されません。</p></div>
<div class="paragraph"><p><code>0x4</code>〜<code>0x7</code> 将来の為に予約。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_ref_index">Ref index</h4>
<div class="paragraph"><p>ref インデックスは、ファイル内のすべての ref ブロックからの最後の参照の名前を格納し、検索(lookup)のためのディスク・シークを削減します。 インデックスを検索(search)し、それを含むブロックを特定し、そのブロック内を検索(search)することで、すべての参照を見つける(find)ことができます。</p></div>
<div class="paragraph"><p>インデックスは、マルチレベル・インデックスに編成することができます。この場合、第 1 レベルのインデックス・ブロックが追加の参照インデックス・ブロック(第2レベル)を指し、さらに追加のインデックス・ブロック (たとえば 第 3 レベル) または参照ブロック (リーフ レベル) を指す場合があります。 ref にアクセスするために必要なディスク読み取りの必要性は、インデックス・レベルが高いほど高くなります。 単一のインデックス・ブロックがファイル形式の最大ブロック サイズ「16777215」バイト (15.99 MiB) を超えないようにするために、複数レベルのインデックスが必要になる場合があります。 検索(lookup)のために一定の O(1) ディスク・シークを実現するには、インデックスは単一レベルである必要があります。これは、ファイルの構成されたブロック・サイズを超えることは許可されていますが、フォーマットの最大ブロック・サイズである 15.99 MiB を超えることは許可されていません。</p></div>
<div class="paragraph"><p>もしあれば、refインデックス・ブロック(達)は最後のrefブロックの後に表れます。</p></div>
<div class="paragraph"><p>少なくとも 4 つの ref ブロックがある場合は、検索(lookup)時間を改善するために ref インデックス・ブロックを書き込む必要があります。 インデックスを使用したコールド読み取りには 2 つのディスク読み取り (インデックス読み取りとブロック読み取り) が必要であり、また、4ブロック未満のバイナリ検索でもディスク読み取りが2回以下必要です。 小さいファイルからインデックス・ブロックを省略すると、スペースが節約されます。</p></div>
<div class="paragraph"><p>ファイルが揃えられておらず、複数の ref ブロックが含まれている場合は、ref インデックスを書き込む必要があります。</p></div>
<div class="paragraph"><p>インデックス・ブロック形式:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'i'
uint24( block_len )
index_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</code></pre>
</div></div>
<div class="paragraph"><p>インデックス・ブロックは、<code>block_type = 'i'</code> で始まり、そして、ブロック内のバイト数をエンコードする 3 バイトの <code>block_len</code> は、オプションの「詰物」を含みません。</p></div>
<div class="paragraph"><p><code>restart_offset</code> および <code>restart_count</code> フィールドの形式と意味と使用法は、 ref ブロックの場合と全く同じです。</p></div>
<div class="paragraph"><p>非常に大きなファイルのランダム・アクセスに必要な読み取り回数を減らすために、インデックス・ブロックは他のブロックよりも大きくなる場合があります。 ただし、これを利用するには、リーダーはインデックス全体をメモリに保持する必要があるため、ファイル・サイズとリーダー・メモリの両方で時間と空間のトレードオフになります。</p></div>
<div class="paragraph"><p>ファイルのブロック・サイズを大きくすると、インデックス・サイズが小さくなります。 別の方法として、複数レベルのインデックスを使用して、インデックス・ブロックをファイルのブロック・サイズ内に保ちながら、アクセスする必要があるブロックの数を増やすこともできます。</p></div>
<div class="sect4">
<h5 id="_index_record">index record</h5>
<div class="paragraph"><p>インデックス・レコードは、別のブロックの最後のエントリを記述します。 インデックス・レコードは以下のとおり記述されます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | 0 )
suffix
varint( block_position )</code></pre>
</div></div>
<div class="paragraph"><p>インデックス・レコードは、<code>ref_record</code> と正確に同様にプレフィックス圧縮を使用します。</p></div>
<div class="paragraph"><p>インデックス・レコードは、サフィックスの後に「block_position」を格納し、この参照で終了するブロックの (ファイルの先頭からの) 絶対位置をバイト単位で指定します。 リーダーは「block_position」へシークして、ブロック・ヘッダーの読み取りを開始できます。</p></div>
<div class="paragraph"><p>リーダーは、<code>block_position</code> のブロック・ヘッダーを調べて、次のブロックが別のレベルのインデックス・ブロックであるか、枝葉レベル(leaf-level)の ref ブロックであるかを判断する必要があります。</p></div>
</div>
<div class="sect4">
<h5 id="_reading_the_index">Reading the index</h5>
<div class="paragraph"><p>ref インデックスをロードするリーダーは、最初にフッター (下記) を読んで <code>ref_index_position</code> を取得する必要があります。 存在しない場合、位置は 0 になります。 <code>ref_index_position</code> は、ref インデックスの第 1 レベルのルート(root)用です。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_obj_block_format">Obj block format</h4>
<div class="paragraph"><p>オブジェクト・ブロックはオプションです。 ライターは、特にリーダーがrefマッピングにオブジェクト名を使用しない場合は、オブジェクト・ブロックを省略することを選択できます。</p></div>
<div class="paragraph"><p>オブジェクト・ブロックは、 2 ～ 31 個の一意の短縮オブジェクト名キーを使用し、そのオブジェクトを直接指す参照を含む ref ブロックにマッピングするか、注釈付きタグの皮むきされた値(peeled value)としてマッピングします。 ref ブロックと同様に、オブジェクト・ブロックはファイルの標準ブロック・サイズを使用します。 省略形の長さは、フッターで <code>obj_id_len</code> として利用できます。</p></div>
<div class="paragraph"><p>小さなファイルのスペースを節約するために、ref インデックスが存在しない場合はオブジェクト・ブロックを省略できます。力づくで検索(brute force search)を行う場合はいくつかの ref ブロックを読み取るだけでよいためです。 欠落がある場合、リーダーは、オブジェクト名で検索(lookup)するすべての参照の線形検索を力ずくで実行する必要があります。</p></div>
<div class="paragraph"><p>オブジェクト・ブロックは以下のとおり記述されます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'o'
uint24( block_len )
obj_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</code></pre>
</div></div>
<div class="paragraph"><p>フィールドは ref ブロックの場合と全く同じです。 再開表(restart table)を使用した二分木探索は、参照ブロックの場合と全く同一に機能します。</p></div>
<div class="paragraph"><p>オブジェクト名はライターによって reftable 内の最も短い一意の略語に省略されるため、オブジェクト・キーの長さは可変長になります。 それらの長さは少なくとも 2 バイトでなければなりません。 リーダーは、オブジェクト・ブロックまたはオブジェクト・インデックス内の一般的なプレフィックスの一致についてのみ比較する必要があります。</p></div>
<div class="sect4">
<h5 id="_obj_record">obj record</h5>
<div class="paragraph"><p><code>obj_record</code> は、単一のオブジェクトの略語と、その一意の略語を使用する参照を含むブロックを記述します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | cnt_3 )
suffix
varint( cnt_large )?
varint( position_delta )*</code></pre>
</div></div>
<div class="paragraph"><p>参照ブロックと同様に、省略形はオブジェクト・ブロック内でプレフィックス圧縮されます。 多くの一意のオブジェクトや、より大きなブロック・サイズ (64k)や、より長い再開間隔 (128) を持つ大きな reftable では、オブジェクト・レコード内では <code>prefix_length</code> の値は2または3で <code>suffix_length</code> の値は3が一般的です(5～6バイトである10～12桁の16進数の一意の省略形)。</p></div>
<div class="paragraph"><p>各レコードには、一致する参照ブロックの位置の「position_count」数が含まれます。 1 ～ 7 の位置の場合、カウントは「cnt_3」に格納されます。 <code>cnt_3 = 0</code> の場合、実際のカウントは派生(varint) の <code>cnt_large</code> に続きます。</p></div>
<div class="paragraph"><p><code>cnt_3</code> の使用は、ほとんどのオブジェクトが 1 つの参照のみによって指されていること、いくつかのオブジェクトは 2 つの参照によって指されていること、および 7 つ以上の参照によって指されているオブジェクトは (存在するとしても) 非常に少ないことに賭けます。</p></div>
<div class="paragraph"><p><code>cnt_3 = 0</code> かつ <code>cnt_large = 0</code> である特殊なケースがあります: 「position_delta」はありませんが、少なくとも 1 つの参照がこの省略形で始まります。 正確な参照名が必要なリーダーは、すべての参照をスキャンして、目的のオブジェクトを持つ特定の参照を見つける必要があります。 ライターは、同じオブジェクトを指している多数の参照が原因で「position_delta」リストがファイルのブロック・サイズをオーバーフローした場合に、この形式を使用する必要があります。</p></div>
<div class="paragraph"><p>最初の <code>position_delta</code> は、ファイルの先頭からの位置です。 追加の「position_delta」エントリは昇順で、前のエントリに対して相対的にソートされます。 リーダーは以下のことを実行します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>pos = position_delta[0]
prior = pos
for (j = 1; j &lt; position_count; j++) {
  pos = prior + position_delta[j]
  prior = pos
}</code></pre>
</div></div>
<div class="paragraph"><p>位置を取得したら、リーダーは最初の ref_record から開始して ref ブロックを直線的にスキャンし、各参照のオブジェクト名 ( <code>value_type</code> = <code>0x1</code> または <code>0x2</code> ) が完全に等しいかどうかをテストする必要があります。 単一の ref ブロック内のオブジェクト名による高速検索(searching)は、reftable 形式ではサポートされていません。 ブロック・サイズが小さいほど、このステップで考慮する必要がある候補の数が減ります。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_obj_index">Obj index</h4>
<div class="paragraph"><p>オブジェクト・インデックスには、ファイル内のすべてのオブジェクト・ブロックの最後のエントリの省略形が格納され、すべての検索(lookup)でのディスク・シークが削減されます。それは ref インデックスと正確に同じフォーマットがなされますが、オブジェクト・ブロックを参照します。</p></div>
<div class="paragraph"><p>オブジェクト・ブロックはより大きなファイルにのみ書き込む必要があるため、オブジェクト・ブロックが存在する場合は、オブジェクト・インデックスが存在する必要があります。</p></div>
<div class="paragraph"><p>オブジェクト・インデックスをロードするリーダーは、最初にフッター (下記) を読んで <code>obj_index_position</code> を取得する必要があります。 存在しない場合、位置は 0 になります。</p></div>
</div>
<div class="sect3">
<h4 id="_log_block_format">Log block format</h4>
<div class="paragraph"><p>ref ブロックや obj ブロックとは異なり、ログ ブロックは常に揃えられていません。</p></div>
<div class="paragraph"><p>ログ・ブロックのサイズは可変であり、ファイル・ヘッダーまたはフッターで指定された「block_size」と一致しません。 ライターは、「2 * block_size」などの適切なバッファ・サイズを選択して、圧縮用のログ・ブロックを準備する必要があります。</p></div>
<div class="paragraph"><p>ログ・ブロックは以下のとおり記述されます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>'g'
uint24( block_len )
zlib_deflate {
  log_record+
  uint24( restart_offset )+
  uint16( restart_count )
}</code></pre>
</div></div>
<div class="paragraph"><p>ログ・ブロックは、<code>block_type = 'g'</code> を除いて、refブロックと似ています。</p></div>
<div class="paragraph"><p>4バイトのブロック・ヘッダーの後に、zlib圧縮を使用して圧縮されたブロックの内容が続きます。 ヘッダーの「block_len」は膨張したサイズ (4 バイトのブロック・ヘッダーを含む) であり、解凍出力バッファーを事前に割り当てるためにリーダーで使用する必要があります。 ログ・ブロックの「block_len」がファイルのブロック・サイズを超える場合があります。</p></div>
<div class="paragraph"><p>ログ・ブロック内のオフセット (「restart_offset」など) には、4 バイトのヘッダーがまだ含まれています。 リーダーは、解凍出力バッファーの前に 4 バイトのヘッダーをプレフィックスすることを好むかもしれません。</p></div>
<div class="paragraph"><p>圧縮コンテナー内では、可変数の「log_record」が参照の変更を記述します。 ログの記録形式は以下のとおりです。 <code>restart_offset</code> と <code>restart_count</code> の説明については、「ref block format」(ref ブロック形式)(上述) を参照してください。</p></div>
<div class="paragraph"><p>ログ・ブロックにはブロック間の揃え幅(alignment)や詰物(padding)がないため、リーダーは次のログ・ブロックの開始位置を知るために、インフレータによって消費されるバイトを追跡する必要があります。</p></div>
<div class="sect4">
<h5 id="_log_record">log record</h5>
<div class="paragraph"><p>ログ・レコード・キーは以下のように構成(structure)されます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ref_name '\0' reverse_int64( update_index )</code></pre>
</div></div>
<div class="paragraph"><p>ここで、「update_index」は一意の取引(transaction)IDです。 <code>update_index</code> フィールドは、 <code>ref_name</code> のスコープ内で一意である必要があります。 詳細については、下記「update transactions」(取引更新)セクションを参照してください。</p></div>
<div class="paragraph"><p><code>reverse_int64</code> 関数は値を反転するので、ネットワーク・バイト・オーダー・エンコーディングの辞書式順序付けは、より高い <code>update_index</code> 値を持つ新しいレコードが最初になるように並べ替えます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>reverse_int64(int64 t) {
  return 0xffffffffffffffff - t;
}</code></pre>
</div></div>
<div class="paragraph"><p>ログ・レコードは、上記のログ・レコード・キーに適用されるのと同じプレフィックス圧縮方式を利用して、ref および index レコードと同様の開始構造(starting structure)を持っています。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    varint( prefix_length )
    varint( (suffix_length &lt;&lt; 3) | log_type )
    suffix
    log_data {
      old_id
      new_id
      varint( name_length    )  name
      varint( email_length   )  email
      varint( time_seconds )
      sint16( tz_offset )
      varint( message_length )  message
    }?</code></pre>
</div></div>
<div class="paragraph"><p>ログ・レコード・エントリでは、 <code>log_type</code> を使用して、以下のことを示します:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>0x0</code>: 削除。ログデータ無し。
</p>
</li>
<li>
<p>
<code>0x1</code>: 上記 <code>log_data</code> を使用した標準の git reflog データ。
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>log_type = 0x0</code> は、より大きなファイルを書き換える必要なく、取引ファイル(transaction file)(下記) の <code>refs/stash</code> の reflog からエントリを削除して、 <code>git stash drop</code> に最も役立ちます。 reflog のスタックを読み取るリーダーは、これを削除として扱う必要があります。</p></div>
<div class="paragraph"><p>「log_type = 0x1」の場合、「log_data」セクションは <a href="../git-update-ref.html">git-update-ref(1)</a> ロギングに従い、以下が含まれます:</p></div>
<div class="ulist"><ul>
<li>
<p>
2つのオブジェクト名(old id, new id)
</p>
</li>
<li>
<p>
コミッター名の派生文字列(varint string)
</p>
</li>
<li>
<p>
コミッターメールアドレスの派生文字列(varint string)
</p>
</li>
<li>
<p>
エポック(Jan 1, 1970)からの経過秒数による派生時間(varint time)
</p>
</li>
<li>
<p>
2バイト。分単位のタイムゾーン・オフセット(signed)
</p>
</li>
<li>
<p>
メッセージの派生文字列(varint string)
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>tz_offset</code> は、更新時にコミッターがいたタイムゾーンです(GMT からのオフセットで表される)。 たとえば、<code>GMT-0800</code> は reftable で <code>sint16(-480)</code> としてエンコードされ、<code>GMT+0230</code> は <code>sint16(150)</code> としてエンコードされます。</p></div>
<div class="paragraph"><p>コミッターの電子メールアドレスには <code>&lt;</code> または <code>&gt;</code> は含まれません。これは通常、git commit オブジェクト ヘッダーの <code>&lt;&gt;</code> の間にある値です。</p></div>
<div class="paragraph"><p><code>message_length</code> は 0 の場合があります。この場合、更新用のメッセージは提供されていません。</p></div>
<div class="paragraph"><p>従来の reflog (ファイル) とは対照的に、名前の変更は ref 削除と ref 作成の組み合わせとしてエンコードされます。 削除は new_id がゼロのログ・レコードであり、作成は old_id がゼロのログ・レコードです。</p></div>
</div>
<div class="sect4">
<h5 id="_reading_the_log">Reading the log</h5>
<div class="paragraph"><p>ログにアクセスするリーダーは、最初にフッター (下記) を読んで <code>log_position</code> を判断する必要があります。 ログの最初のブロックは、ファイルの先頭から <code>log_position</code> バイトで始まります。 <code>log_position</code> はブロック揃えになっていません。</p></div>
</div>
<div class="sect4">
<h5 id="_importing_logs">Importing logs</h5>
<div class="paragraph"><p><code>$GIT_DIR/logs</code> からインポートする場合、ライターは、ファイルの順序を維持しながら、すべてのログ・レコードを大まかにタイムスタンプで並べ替え、ログ行ごとに一意の、増加する <code>update_index</code> 値を割り当てる必要があります。 新しいログ・レコードほど、「update_index」の値が大きくなります。</p></div>
<div class="paragraph"><p>インポートは 1 つの reftable ファイルのみを書き込むことができますが、セマンティクスを維持するために各ログ行には独自の <code>update_index</code> が必要であるため、 reftable ファイルは多くの一意の <code>update_index</code> にまたがる必要があります。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_log_index">Log index</h4>
<div class="paragraph"><p>ログ・インデックスは、ファイル内のすべてのログ・ブロックの最後のログ・レコードのログ・キー (<code>refname \0 reverse_int64(update_index)</code>) を格納し、制限時間検索(bounded-time lookup)をサポートします。</p></div>
<div class="paragraph"><p>2 つ以上のログ・ブロックがファイルに書き込まれる場合は、ログ・インデックス・ブロックを書き込む必要があります。 存在する場合、ログ・インデックスは最後のログ・ブロックの後に表れます。 ログ・インデックスをブロック揃え幅(alignment)に揃える(align)ために使用される詰物(padding)はありません。</p></div>
<div class="paragraph"><p>ログ・インデックスの形式は ref インデックスと同じですが、<code>'\0'</code> と 8 バイトの <code>reverse_int64(update_index)</code> を含めるためにキーが 9 バイト長くなります。 レコードは「block_position」を使用してログ・ブロック開始を参照します。</p></div>
<div class="sect4">
<h5 id="_reading_the_index_2">Reading the index</h5>
<div class="paragraph"><p>ログ・インデックスをロードするリーダーは、最初にフッター (下記) を読んで <code>log_index_position</code> を取得する必要があります。 存在しない場合、位置は 0 になります。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_footer">Footer</h4>
<div class="paragraph"><p>ファイルの最後のブロックの後ろに、ファイル・フッターが書き込まれます。 ファイル・ヘッダーのように始まりますが、追加のデータで拡張されています。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    HEADER

    uint64( ref_index_position )
    uint64( (obj_position &lt;&lt; 5) | obj_id_len )
    uint64( obj_index_position )

    uint64( log_position )
    uint64( log_index_position )

    uint32( CRC-32 of above )</code></pre>
</div></div>
<div class="paragraph"><p>セクションが欠落している場合 (たとえば ref インデックス)、対応する位置フィールド (たとえば <code>ref_index_position</code>) は 0 になります。</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>obj_position</code>: 最初のオブジェクト・ブロックのバイト位置。
</p>
</li>
<li>
<p>
<code>obj_id_len</code>: オブジェクト・ブロック内の短縮オブジェクト名のために使用されるバイト数。
</p>
</li>
<li>
<p>
<code>log_position</code>: 最初のログ・ブロックのバイト位置。
</p>
</li>
<li>
<p>
<code>ref_index_position</code>: refインデクス開始のバイト位置。
</p>
</li>
<li>
<p>
<code>obj_index_position</code>: オブジェクト・インデックス開始のバイト位置。
</p>
</li>
<li>
<p>
<code>log_index_position</code>: ログ・インデックス開始のバイト位置。
</p>
</li>
</ul></div>
<div class="paragraph"><p>フッターのサイズは、バージョン 1 で 68 バイト、バージョン 2 で 72 バイトです。</p></div>
<div class="sect4">
<h5 id="_reading_the_footer">Reading the footer</h5>
<div class="paragraph"><p>リーダーは、最初にファイルの先頭を読んでバージョン番号を確認する必要があります。 次に、フッターにアクセスするために「file_length - FOOTER_LENGTH」を探します。 「file_length」を取得するには、信頼できる外部ソース (「stat(2)」など) が必要です。 フッターを読むとき、リーダー以下のことを確認する必要があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
4バイトのマジックが正しい
</p>
</li>
<li>
<p>
1バイトのバージョン番号を認識
</p>
</li>
<li>
<p>
4バイトのCRC-32 は他の 64 バイトと一致します(マジックとバージョンを含む)
</p>
</li>
</ul></div>
<div class="paragraph"><p>検証が完了すると、フッターの他のフィールドにアクセスできるようになります。</p></div>
</div>
<div class="sect4">
<h5 id="_empty_tables">Empty tables</h5>
<div class="paragraph"><p>reftable は空である可能性があります。 この場合、ファイルはヘッダーで始まり、すぐにフッターが続きます。</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_binary_search">Binary search</h4>
<div class="paragraph"><p>ブロック内の二分木検索は、ブロックの末尾にある「restart_offset」フィールドによってサポートされています。 リーダーは、再開表(restart table)を二分木検索して、探している参照またはキーがどの 2 つの再開点(restart points)の間に現れるかどうかを特定できます。</p></div>
<div class="paragraph"><p><code>restart_offset</code> によって識別される各レコードは、レコードの <code>suffix</code> フィールドに完全なキーを格納し、バイナリ検索中の比較操作を簡単にします。</p></div>
<div class="paragraph"><p>求められる参照より辞書的に前の再開点(restart point)が特定されると、リーダーは求められるレコードを見つけるために次のレコードエントリを線形にスキャンすることができ、現在のレコードがソート後であれば（したがって、求められるキーが存在しなければ）終了する。</p></div>
<div class="sect4">
<h5 id="_restart_point_selection">Restart point selection</h5>
<div class="paragraph"><p>ライターは、ファイルの作成時に再開ポイントを決定します。 処理方法は任意ですが、16 または 64 レコードごとをお勧めします。 小さいブロック・サイズ (4k または 8k) には 16 ごと、大きいブロック・サイズ (64k) には 64 ごとが適している場合があります。</p></div>
<div class="paragraph"><p>再開点(restart points)の頻度が高くなると、プレフィックス圧縮が減少し、再開表(restart table)によって消費される領域が増加します。どちらもファイル・サイズが増加します。</p></div>
<div class="paragraph"><p>再スタート・ポイントの頻度が低いと、プレフィックスの圧縮がより効果的になり、全体的なファイル・サイズが小さくなり、二分探索ステップの後でより多くのレコードを参照するリーダーのペナルティが増加します。</p></div>
<div class="paragraph"><p>ブロックごとに最大「65535」の再スタート点がサポートされています。</p></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_considerations">Considerations</h3>
<div class="sect3">
<h4 id="_lightweight_refs_dominate">Lightweight refs dominate</h4>
<div class="paragraph"><p>reftable 形式は、参照の大部分が、 Gerrit Code Review の <code>refs/changes/</code> 名前空間、または GitHub の <code>refs/pulls/</code> 名前空間、または <code>refs/tags/</code> 名前空間です。</p></div>
<div class="paragraph"><p>皮剥きされた(peeled)オブジェクトを格納する注釈付きタグには、参照ごとに追加のオブジェクト名が必要です。</p></div>
</div>
<div class="sect3">
<h4 id="_low_overhead">Low overhead</h4>
<div class="paragraph"><p>参照がほとんどない reftable (例: 5 つのヘッドを持つ git.git) は、reftable で 269 バイト、packed-ref で 332 バイトです。 これにより、取引ログの参照可能なスケール・ダウンがサポートされます(下記参照)。</p></div>
</div>
<div class="sect3">
<h4 id="_block_size_2">Block size</h4>
<div class="paragraph"><p>多くの変更refがある Gerrit Code Review タイプのリポジトリの場合、ブロック・サイズが大きく (64 KiB)、再開点(restart points)再起動ポイントの頻度が低い (64 KiB ごと) ほどで、ブロック内の参照が前の参照に対して圧縮されるため、圧縮率が向上します。</p></div>
<div class="paragraph"><p>reftable が同じ数の参照を格納するために必要なブロックが少なくなるため、ブロック・サイズが大きくなるとインデックス・サイズが小さくなります。</p></div>
</div>
<div class="sect3">
<h4 id="_minimal_disk_seeks">Minimal disk seeks</h4>
<div class="paragraph"><p>インデックス・ブロックがメモリに読み込まれていると仮定すると、任意の単一参照のバイナリ検索では、包含ブロックを読み込むためにちょうど 1 回のディスク・シークが必要です。</p></div>
</div>
<div class="sect3">
<h4 id="_scans_and_lookups_dominate">Scans and lookups dominate</h4>
<div class="paragraph"><p>すべての参照を走査(scan)し、名前 (または「refs/heads/」などの名前空間) で検索(lookup)することは、リポジトリで実行される最も一般的なアクティビティです。 このユースケースを最適化するために、オブジェクト名は参照とともに直接保存されます。</p></div>
</div>
<div class="sect3">
<h4 id="_logs_are_infrequently_read">Logs are infrequently read</h4>
<div class="paragraph"><p>ログはめったにアクセスされませんが、サイズが大きくなる可能性があります。 ログ・ブロックを圧縮すると、ディスク・スペースが節約されますが、読み取り時のペナルティがいくらか増加します。</p></div>
<div class="paragraph"><p>ログは ref から分離されたセクションに保存されるため、ログを無視したい参照リーダーの負担が軽減されます。 さらに、履歴ログをログのみのファイルに分離できます。</p></div>
</div>
<div class="sect3">
<h4 id="_logs_are_read_backwards">Logs are read backwards</h4>
<div class="paragraph"><p>ログは頻繁に逆方向にアクセスされるため (master が <code>master@{4}</code> に応答する最新の N レコード)、ログ・レコードは参照によってグループ化され、更新インデックスによって降順に並べ替えられます。</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_repository_format">Repository format</h3>
<div class="sect3">
<h4 id="_version_1">Version 1</h4>
<div class="paragraph"><p>reftable を設定するには、リポジトリで <code>$GIT_DIR/config</code> を設定する必要があります:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[core]
    repositoryformatversion = 1
[extensions]
    refStorage = reftable</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_layout">Layout</h4>
<div class="paragraph"><p>reftable ファイルのコレクションは <code>$GIT_DIR/reftable/</code> ディレクトリに保存されます。 それらの名前には、各ファイル名がグローバルに一意になるように、ランダムな要素を含める必要があります。 これにより、開いているファイルを削除または上書きできない Windows での誤ったエラーを回避できます。 その命名規則として <code>${min_update_index}-${max_update_index}-${random}.ref</code> を使用することが提案されました。</p></div>
<div class="paragraph"><p>ログのみのファイルは <code>.log</code> 拡張子を使用しますが、 ref のみのファイルや ref とログの混合ファイルは <code>.ref</code> 拡張子を使用します。</p></div>
<div class="paragraph"><p>スタック順序付けファイルは <code>$GIT_DIR/reftable/tables.list</code> で、現在のファイルを 1 行に 1 つずつ、もっとも古いの (ベース) から最新 (最新) の順にリストします。</p></div>
<div class="literalblock">
<div class="content">
<pre><code>$ cat .git/reftable/tables.list
00000001-00000001-RANDOM1.log
00000002-00000002-RANDOM2.ref
00000003-00000003-RANDOM3.ref</code></pre>
</div></div>
<div class="paragraph"><p>リーダーは <code>$GIT_DIR/reftable/tables.list</code> を読んで現在どのファイルが関連しているかを判断し、逆の順序でスタックを検索(search)する必要があります (最後の reftable が最初に調べられます)。</p></div>
<div class="paragraph"><p><code>tables.list</code> にリストされていない reftable ファイルは、新しい (そして、アクティブなライターによってスタックに追加されようとしている) か、古くて刈り込みされる準備ができている可能性があります。</p></div>
</div>
<div class="sect3">
<h4 id="_backward_compatibility">Backward compatibility</h4>
<div class="paragraph"><p>古いクライアントは、ディレクトリを git リポジトリとして認識し続ける必要があるため、親ディレクトリ内のエンクロージング・リポジトリを検索しません。 このため、reftable 対応のリポジトリには以下のダミー・ファイルが含まれている必要があります。</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>.git/HEAD</code> は、 <code>ref: refs/heads/.invalid</code> を含む通常のファイルです。
</p>
</li>
<li>
<p>
<code>.git/refs/</code> はディレクトリです
</p>
</li>
<li>
<p>
<code>.git/refs/heads</code> は通常ファイルです
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_readers">Readers</h4>
<div class="paragraph"><p>リーダー(readers)は、以下の方法で参照空間(the reference space)の一貫したスナップショットを取得できます:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>tables.list</code> ファイルをオープンして読みとります。
</p>
</li>
<li>
<p>
言及されている各reftableファイルをオープンします。
</p>
</li>
<li>
<p>
いずれかのファイルが欠落している場合は、 goto 1
</p>
</li>
<li>
<p>
現在開いているファイル群から必要なだけ読み取ります。
</p>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_update_transactions">Update transactions</h4>
<div class="paragraph"><p>reftable は不変ですが、新しい reftable を作成し、アトミックにスタックに追加することで変更(mutation)がサポートされます:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>tables.list.lock</code> を取得します。
</p>
</li>
<li>
<p>
現在の reftable を確認するには、 <code>tables.list</code> を読み取ります。
</p>
</li>
<li>
<p>
最新のファイルの「max_update_index + 1」になるように「update_index」を選択します。
</p>
</li>
<li>
<p>
ログ・エントリを含む一時 reftable <code>tmp_XXXXXX</code> を準備します。
</p>
</li>
<li>
<p>
<code>tmp_XXXXXX</code> を <code>${update_index}-${update_index}-${random}.ref</code> に名前変更します。
</p>
</li>
<li>
<p>
<code>tables.list</code> を <code>tables.list.lock</code> にコピーし、(5) のファイルを追加します。
</p>
</li>
<li>
<p>
<code>tables.list.lock</code> を <code>tables.list</code> に名前変更します。
</p>
</li>
</ol></div>
<div class="paragraph"><p>ステップ 4 では、新しいファイルの <code>min_update_index</code> と <code>max_update_index</code> は両方とも、ステップ 3 で選択された <code>update_index</code> に設定されます。取引のすべてのログ・レコードは、それらのキーで同一の <code>update_index</code> を使用します。 これにより、同じ取引によってどの参照が更新されたかを後で関連付けることができます。</p></div>
<div class="paragraph"><p>単一の <code>tables.list.lock</code> ファイルがロックの管理に使用されるため、リポジトリはライター用のシングルスレッドです。 ライターは、許容可能な待機期間まで、 <code>tables.list.lock</code> の作成中に (バックオフを伴って) ビジースピンする必要がある場合があり、リポジトリが忙しすぎて変更できない場合は中止します。 リポジトリにラップされたアプリケーション・サーバー (Gerrit Code Review など) は、独自の ロック/待機 キューをレイヤー化して、ライターへの公平性を向上させることができます。</p></div>
</div>
<div class="sect3">
<h4 id="_reference_deletions">Reference deletions</h4>
<div class="paragraph"><p><code>type</code> を <code>0x0</code> に設定し、 <code>ref_record</code> の <code>value</code> フィールドを省略することにより、任意の参照の削除を明示的に保存できます。 これは、スタック内の以前のファイルからの参照の存在に関するアサーションをオーバーライドして、墓標(tombstone)として機能します。</p></div>
</div>
<div class="sect3">
<h4 id="_compaction">Compaction</h4>
<div class="paragraph"><p>reftable の部分的なスタックは、reftable 間で単純なマージ結合を使用して参照をマージし、出力用に最新の値を選択し、残りの下位の reftable に表示されない削除された参照を省略することで圧縮できます。</p></div>
<div class="paragraph"><p>圧縮された reftable は、その <code>min_update_index</code> を入力ファイル達の最小の <code>min_update_index</code> に設定し、同様にその <code>max_update_index</code> を入力ファイル達の最大の <code>max_update_index</code> に設定する必要があります。</p></div>
<div class="paragraph"><p>説明のために、スタックが現在 reftable ファイル達 (古いものから新しいものへ) で構成されていると仮定します: A、B、C、および D です。圧縮器(compactor)は B と C を圧縮し、A と D だけを残します。</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
ロック <code>tables.list.lock</code> を取得し、そして、 <code>tables.list</code> ファイルを読み取ります。
</p>
</li>
<li>
<p>
ロック「B.lock」と「C.lock」を取得します。 これらのロックの所有権により、他のプロセスがこれらのファイルを圧縮しようとするのを防ぎます。
</p>
</li>
<li>
<p>
<code>tables.list.lock</code> を開放(release)します。
</p>
</li>
<li>
<p>
<code>B</code> と <code>C</code> を一時ファイル <code>${min_update_index}-${max_update_index}_XXXXXX</code> に圧縮します。
</p>
</li>
<li>
<p>
<code>tables.list.lock</code> のロックを取得します。
</p>
</li>
<li>
<p>
<code>B</code> と <code>C</code> がこの順序でまだスタックにあることを確認(verify)します。 他のプロセスがロック・プロトコルに従っていると仮定すると、これは常に当てはまるはずです。
</p>
</li>
<li>
<p>
<code>${min_update_index}-${max_update_index}_XXXXXX</code> を <code>${min_update_index}-${max_update_index}-${random}.ref</code> に名前変更します。
</p>
</li>
<li>
<p>
新しいスタックを「tables.list.lock」に書き込み、「B」と「C」を (4) のファイルに置き換えます。
</p>
</li>
<li>
<p>
<code>tables.list.lock</code> を <code>tables.list</code> に名前変更します。
</p>
</li>
<li>
<p>
リーダーがバックトラック(backtrack)を強いられるのを避けるために、おそらく短いsleepの後、 <code>B</code> と <code>C</code> を削除します。
</p>
</li>
</ol></div>
<div class="paragraph"><p>この戦略により、更新とは無関係に圧縮を進めることができます。</p></div>
<div class="paragraph"><p>各 reftable (圧縮されているかどうかに関係なく) はその名前で一意に識別されるため、開いている reftable はその名前でキャッシュできます。</p></div>
</div>
<div class="sect3">
<h4 id="_windows">Windows</h4>
<div class="paragraph"><p>Windows や、ファイルを開くための削除や名前変更を許可しないその他のシステムでは、圧縮は成功する可能性がありますが、他のリーダーでは古いテーブルの削除が妨げられる場合があります。</p></div>
<div class="paragraph"><p>これらのプラットフォームでは、次の戦略に従うことができます: reftable スタックを閉じて、 <code>tables.list</code> をリロードし、 <code>tables.list</code> で言及されなくなったテーブルを削除します。</p></div>
<div class="paragraph"><p>イレギュラーなプログラムの終了により、未使用のファイルが残る場合があります。 この場合、クリーンアップ操作は以下のように進める必要があります:</p></div>
<div class="ulist"><ul>
<li>
<p>
並列変更を防ぐためにロック <code>tables.list.lock</code> を取得します
</p>
</li>
<li>
<p>
<code>tables.list</code> を読み取って、reftable スタックを更新(refresh)します
</p>
</li>
<li>
<p>
各 <code>*.ref</code> ファイルごとに、以下の場合は削除します
</p>
<div class="ulist"><ul>
<li>
<p>
それは <code>tables.list</code> に記載されておらず、
</p>
</li>
<li>
<p>
かつ、その最大 update_index は、スタックの最大 update_index を超えていません
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives_considered">Alternatives considered</h3>
<div class="sect3">
<h4 id="_bzip_packed_refs">bzip packed-refs</h4>
<div class="paragraph"><p><code>bzip2</code> は、大きなパックされた参照ファイルを大幅に圧縮できます (たとえば、62 MiB は 23 MiB と、37% に圧縮されます)。 ただし、bzip 形式は、単一の参照へのランダム・アクセスをサポートしていません。 リーダーは、リニア・スキャン実行中、解凍と破棄を行う必要があります。</p></div>
<div class="paragraph"><p>パックされた参照をチャンクに分割する (各チャンクを個別に圧縮する) と、リーダーが解凍しなければならないデータの量が減りますが、正しいチャンクを効率的に見つけるリーダーをサポートするために、チャンクにインデックスを付けるという問題が残ります。</p></div>
<div class="paragraph"><p>reftable のエンコーディングによって達成される圧縮を考えると、 bzip/gzip/zlib の複雑さを追加する必要はないようです。</p></div>
</div>
<div class="sect3">
<h4 id="_michael_haggerty_8217_s_alternate_format">Michael Haggerty&#8217;s alternate format</h4>
<div class="paragraph"><p>Michael Haggerty は、Git メーリング リストで <a href="https://lore.kernel.org/git/CAMy9T_HCnyc1g8XWOOWhe7nN0aEFyyBskV2aOMb_fe%2BwGvEJ7A%40mail.gmail.com/">an alternate</a> 形式を reftable に提案しました。 この形式は、再開表(restart table)なしでより小さいチャンクを使用し、詰物によるブロック揃えを回避します。 reflog エントリは各 ref の直後に続くため、ref 間に差し挟まれます。</p></div>
<div class="paragraph"><p>性能テストでは、reftable の方が検索(lookup)より高速であることが示されています (51% 高速、11.2 usec 対 5.4 usec)。ただし、reftable はわずかに大きなファイルを生成します (+ ~3.2%、28.3M 対 29.2M):</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="right" valign="top">format </th>
<th align="right" valign="top">size </th>
<th align="right" valign="top">seek cold </th>
<th align="right" valign="top">seek hot</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table">mh-alt</p></td>
<td align="right" valign="top"><p class="table">28.3 M</p></td>
<td align="right" valign="top"><p class="table">23.4 usec</p></td>
<td align="right" valign="top"><p class="table">11.2 usec</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">reftable</p></td>
<td align="right" valign="top"><p class="table">29.2 M</p></td>
<td align="right" valign="top"><p class="table">19.9 usec</p></td>
<td align="right" valign="top"><p class="table">5.4 usec</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_jgit_ketch_reftree">JGit Ketch RefTree</h4>
<div class="paragraph"><p><a href="https://dev.eclipse.org/mhonarc/lists/jgit-dev/msg03073.html">JGit Ketch</a> は <a href="https://lore.kernel.org/git/CAJo%3DhJvnAPNAdDcAAwAvU9C4RVeQdoS3Ev9WTguHx4fD0V_nOg%40mail.gmail.com/">RefTree</a> を提案しました。 これは、リポジトリのオブジェクト・データベースの一部として格納された Git ツリー・オブジェクト内の参照のエンコーディングです。</p></div>
<div class="paragraph"><p>RefTree 形式は、オブジェクト・データベース・ストレージ層に追加の負荷を加え (より多くの緩いオブジェクト、より多くのパック内のオブジェクト)、スペースを節約するためにパッカーのデルタ圧縮に大きく依存しています。 フラットな名前空間 (例: refs/tags 内の数千のタグ) は、最初は非常に大きな緩いオブジェクトを作成するため、RefTree は多くの参照をコピーして一部を変更するという問題に対処しません。</p></div>
<div class="paragraph"><p>フラットな名前空間は、RefTree では効率的に検索できません。標準的な形式のツリー・オブジェクトは二分木検索できないためです。 これは、GitHubの <code>refs/pulls</code> のような単一の名前空間で多数の参照を処理する必要性や、多くのタグを持つプロジェクトで失敗します。</p></div>
</div>
<div class="sect3">
<h4 id="_lmdb">LMDB</h4>
<div class="paragraph"><p>David Turner は <a href="https://lore.kernel.org/git/1455772670-21142-26-git-send-email-dturner@twopensource.com/">using LMDB</a> を提案しました。これは、LMDB が軽量 (64k のランタイム コード) で、かつ、 GPL互換ライセンス であるためです。</p></div>
<div class="paragraph"><p>LMDB の欠点は、単一の C 実装に依存していることです。 これにより、JGit (Git の一般的な再実装) 内への組み込みが困難になり、仮想ストレージ (JGit DFS 用) へのホスティングが事実上不可能になります。</p></div>
<div class="paragraph"><p>すべての主要な Git 実装 (git-core、JGit、libgit2) でサポートできる共通の形式が強く推奨されます。</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-07-18 11:06:04 JST
</div>
</div>
</body>
</html>
