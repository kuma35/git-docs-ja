<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>Bundle URIs</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Bundle URIs</h1>
<span id="revdate">2023-07-22</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Git バンドルは、 パック・ファイルと追加のメタ・データを格納するファイルです。 これには、 一連の ref と (場合によっては空の) 必要なコミットのセットが含まれます。 詳細については、 <a href="../git-bundle.html">git-bundle(1)</a> および <a href="../gitformat-bundle.html">gitformat-bundle(5)</a> を参照してください。</p></div>
<div class="paragraph"><p>バンドル URI は、 remote からバンドル以外の残りのオブジェクトをフェッチするのに先立って、 オブジェクト・データベースをゼロから立ち上げる(bootstrap)ために、 Git が 1 つ以上のバンドルをダウンロードできる場所です。</p></div>
<div class="paragraph"><p>最大の目標(one goal)として、 orogin サーバーへのネットワーク接続が不十分なユーザーのクローンとフェッチを高速化することを目指しています。 別の利点としては、 CI ビルド・ファームなどのヘビー・ユーザーが Git データの大部分にローカル・リソースを使用できるようにすることで、 origin サーバーの負荷を軽減できることです。</p></div>
<div class="paragraph"><p>バンドル URI 機能を有効にするには、ユーザーがコマンドライン・オプションを使用してバンドル URI を指定するか、 origin サーバーがプロトコル v2 機能を介して 1 つ以上の URI を広告(advertise)します。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_design_goals">Design Goals</h2>
<div class="sectionbody">
<div class="paragraph"><p>バンドル URI 標準は、 複数の作業(workload)を満たすのに十分な柔軟性を目指しています。 バンドル提供側(bundle provider)と Git クライアントには、 バンドル URI を作成および使用する方法についていくつかの選択肢があります。</p></div>
<div class="ulist"><ul>
<li>
<p>
バンドルには、 サーバーが望む名前を付けることができます。 この名前によって、 バンドル・コンテンツのハッシュを使用して不変データを参照できます。 ただし、 これは、 コンテンツが更新されるたびに新しい URI が必要になることを意味します。 これは、 サーバーが URI を広告(advertise)している (そしてサーバーが新しいバンドルが生成されていることを認識している) 場合は許容できますが、 コマンド・ライン・オプションを使用するユーザーにとっては使いやすくありません(not ergonomic)。
</p>
</li>
<li>
<p>
バンドルは、 完全なクローンをゼロから作成(bootstrap)するために特別に編成できますが、 増分フェッチを始める(bootstrap)目的で編成することもできます。 バンドル提供側は、 増分フェッチ中のクライアントのダウンロードを最小限に抑えるために、 いくつかの構成スキーム(organization schemes)のいずれを使うかを決定する必要がありますが、 Git クライアントは、これらの操作のいずれかにバンドルを使用するかどうかを選択することもできます。
</p>
</li>
<li>
<p>
バンドル提供側は、 完全なクローン(full clones)や部分的なクローン(partial clones)またはその両方をサポートすることを選択できます。 クライアントは、 リポジトリの部分クローン・フィルタに適したバンドルがあれば、それを検出できます。
</p>
</li>
<li>
<p>
バンドル提供側は、 単一のバンドル(クローンのみ)またはバンドルのリストを使用できます。 バンドルのリストを使用する場合、 提供側は、 クライアントが完全なクローン(full clone)のためにバンドル URI の「全て(all)を必要とするか」、 あるいはバンドル URI の「いずれ(any)かで十分か」どうか、を指定できます。 これにより、 バンドル提供側は異なる地域に対して異なる URI を使用できます。
</p>
</li>
<li>
<p>
バンドル提供側は、 作成トークン(creation token)などのヒューリスティックを使用してバンドルを整理し、 クライアントが不要なバンドルをダウンロードしないようにすることができます。 バンドル提供側がこれらのヒューリスティックを提供しない場合は、 クライアントは最適化を使用して、 ダウンロードされるデータの量を最小限に抑えることができます。
</p>
</li>
<li>
<p>
バンドル提供側を Git サーバーに関連付ける必要はありません。 クライアントは、Git サーバーによって広告(advertise)れることなく、 バンドル提供側を使用することを選択できます。
</p>
</li>
<li>
<p>
クライアントは、 Git サーバーによって広告(advertise)されるバンドル提供側を検出することを選択できます。 これは、 <code>git clone</code> 中や <code>git fetch</code> 中またはその両方で発生する可能性があり、 どちらでも発生しない可能性があります。 ユーザーは、 自分に最適な組み合わせを選択できます。
</p>
</li>
<li>
<p>
クライアントは、 いつでもバンドル提供側を手動で構成することを選択できます。 クライアントは <code>git clone</code> のコマンドライン・オプションとして、バンドル提供側を手動で指定することもできます。
</p>
</li>
</ul></div>
<div class="paragraph"><p>各リポジトリは異なり、そして、各Git サーバーごとに異なるニーズがあります。 うまくいけば、 バンドル URI 機能は、 すべてのニーズを満たすのに十分柔軟です。 そうでない場合は、 バージョン管理メカニズムを通じて機能を拡張できる訳です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_server_requirements">Server requirements</h2>
<div class="sectionbody">
<div class="paragraph"><p>バンドル・サーバーのサーバー側実装を提供するために、 Git プロトコルの他の部分は必要ありません。 これにより、 サーバー管理者は CDN などの静的コンテンツ・ソリューションを使用してバンドル・ファイルを提供できます。</p></div>
<div class="paragraph"><p>バンドル URI 機能の現在のスコープでは、 すべての URI が HTTP(S) URL であると想定され、 その URL への GET リクエストを使用してコンテンツがローカル・ファイルにダウンロードされます。 サーバーは、 安全なアクセスのために構成された資格情報ヘルパー(configured credential helper)をトリガーする目的で、 これらのリクエストに認証要件(authentication requirement)を含めることができます。 (将来の拡張では、 <code>file://</code> URI または SSH URI を使用できるようになる予定です。)</p></div>
<div class="paragraph"><p>サーバーからの <code>200 OK</code> 応答が得られたとして、 URL の指すコンテンツを調べます。 最初に、 Git はファイルをバージョン 2 以降のバンドル・ファイルと見なしてパースしようとします。 ファイルがバンドルでない場合、 ファイルは Git の構成パーサー(config parser)を使用してプレーン・テキスト・ファイルと見なしてパースし、 その構成ファイルのキーと値のペアは、バンドル URI のリストを記述することが期待されます。 これらのパースの試みがいずれも成功しない場合、 Git は、 バンドル URI が誤ったデータを提供したというエラーをユーザーに報告します。</p></div>
<div class="paragraph"><p>サーバーによって提供されるその他のデータは、エラーと見なされます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_bundle_lists">Bundle Lists</h2>
<div class="sectionbody">
<div class="paragraph"><p>Git サーバーは、一連の <code>key=value</code> ペアを使用してバンドル URI を広告(advertise)できます。 バンドル URI は、 これらの同一の <code>key=value</code> ペアを含む Git 構成形式のプレーン・テキスト・ファイルを提供することもできます。 どちらの場合も、 これを バンドル・リスト(bundle list) と見なします。 <code>key=value</code> ペアは、 クライアントがダウンロードするバンドルと無視するバンドルを決定するために使用できる、 バンドルに関する情報を指定します。</p></div>
<div class="paragraph"><p>いくつかのキーは、 リスト自体の属性(property)に焦点を当てています。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
bundle.version
</dt>
<dd>
<p>
        (必須)この値は、 バンドル・リストのバージョン番号を提供します。 将来の Git の変更により、 Git クライアントがバンドル・リスト・ファイル内の新しいキーに対応する必要がある機能が有効になる場合、 このバージョン番号はインクリメントされます。 現在のバージョン番号は 1 だけです。 それ以外の値が指定されている場合、 Git はこのファイルを使用できません。
</p>
</dd>
<dt class="hdlist1">
bundle.mode
</dt>
<dd>
<p>
        (必須) この値は、 <code>all</code> と <code>any</code> のどちらかです。 <code>all</code> が指定されている場合、 クライアントは、 リポジトリの要件に一致する、 リストされているすべてのバンドル URI が必要であると想定する必要があります。 <code>any</code> が指定されている場合、 クライアントは、 リポジトリの要件に一致するバンドル URI のいずれかで十分であると想定する必要があります。 通常、 <code>any</code> オプションは、異なる地域にある多数の異なるバンドル・サーバーを一覧表示するために使用されます。
</p>
</dd>
<dt class="hdlist1">
bundle.heuristic
</dt>
<dd>
<p>
        この文字列値のキーが存在する場合、 バンドル・リストは増分 <code>git fetch</code> コマンドで適切に機能するように設計されています。 heuristic は、 クライアントがダウンロードする必要があるバンドルのサブセットを決定するのに役立つ、 バンドルごとに使用可能な追加のキーがあることを示します。 現在策定されている唯一の heuristic は <code>creationToken</code> です。
</p>
</dd>
</dl></div>
<div class="paragraph"><p>以下のキー達には、 利用可能な各バンドルのサーバー指定名である <code>&lt;id&gt;</code> セグメントが含まれます。 <code>&lt;id&gt;</code> には、英数字(alphanumeric)と <code>-</code> 文字のみを含める必要があります。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
bundle.&lt;id&gt;.uri
</dt>
<dd>
<p>
        (必須)この文字列値は、 バンドル <code>&lt;id&gt;</code> をダウンロードするための URI です。 URI がプロトコル(<code>http://</code> または <code>https://</code>)で始まる場合、絶対(absolute)URI です。 それ以外の場合、 URI は、 バンドル・リストに使用される URI への相対(relative)として解釈されます。 URI が <code>/</code> で始まる場合、その相対パスは、 バンドル・リストに使用されるドメイン名からの相対パスです。 (この相対パスの使用は、異なるドメイン名を持つ多数のサーバーまたは CDN にバンドルの組を簡単に配布できるようにすることを目的としています。)
</p>
</dd>
<dt class="hdlist1">
bundle.&lt;id&gt;.filter
</dt>
<dd>
<p>
        この文字列値は、 このバンドルのヘッダーにも表示されるオブジェクト・フィルターを表します。 サーバーはこの値を使用して、 異なる種類のバンドルを区別し、 そこからクライアントが自分のオブジェクト・フィルタに一致するものを選択できるようにします。
</p>
</dd>
<dt class="hdlist1">
bundle.&lt;id&gt;.creationToken
</dt>
<dd>
<p>
        This value is a nonnegative 64-bit integer used for sorting the bundles list. This is used to download a subset of bundles during a fetch when <code>bundle.heuristic=creationToken</code>.
</p>
</dd>
<dt class="hdlist1">
bundle.&lt;id&gt;.location
</dt>
<dd>
<p>
        この文字列値は、 バンドル URI が提供される実際の場所(real-world location)を広告(advertise)します。 これは、 どのバンドルURIを使うかというオプションをユーザーに提示するため、 あるいは、単にGitによってどのバンドルURIが選択されたかという情報インジケーターとして使用することができます。 これは、 bundle.mode の値が <code>any</code> の場合にのみ有効です。
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Git 構成形式(Git config format)を使用したバンドル・リストの例を以下に示します:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle]
        version = 1
        mode = all
        heuristic = creationToken</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-09-1644442601-daily"]
        uri = https://bundles.example.com/git/git/2022-02-09-1644442601-daily.bundle
        creationToken = 1644442601</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-02-1643842562"]
        uri = https://bundles.example.com/git/git/2022-02-02-1643842562.bundle
        creationToken = 1643842562</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-09-1644442631-daily-blobless"]
        uri = 2022-02-09-1644442631-daily-blobless.bundle
        creationToken = 1644442631
        filter = blob:none</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-02-1643842568-blobless"]
        uri = /git/git/2022-02-02-1643842568-blobless.bundle
        creationToken = 1643842568
        filter = blob:none</code></pre>
</div></div>
<div class="paragraph"><p>この例では、 <code>bundle.mode=all</code> はもちろん、 <code>bundle.&lt;id&gt;.creationToken</code> ヒューリスティックも使用しています。 また、 <code>bundle.&lt;id&gt;.filter</code> オプションを使用して、 バンドルの 2 つの並列セットを提示します。 1 つは完全なクローン用(full clone)で、 もう 1 つはブロブn無し部分クローン用(blobless partial clones)です。</p></div>
<div class="paragraph"><p>このバンドル・リストは URI <code>https://bundles.example.com/git/git/</code> で見つかったので、2 つのブロブ無しバンドル(blobless bundles)には以下の完全に展開された URI があると見なします。</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>https://bundles.example.com/git/git/2022-02-09-1644442631-daily-blobless.bundle</code>
</p>
</li>
<li>
<p>
<code>https://bundles.example.com/git/git/2022-02-02-1643842568-blobless.bundle</code>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_advertising_bundle_uris">Advertising Bundle URIs</h2>
<div class="sectionbody">
<div class="paragraph"><p>ユーザーがクローンしているリポジトリのバンドル URI を知っている場合、 コマンドライン・オプションを使用してその URI を手動で指定できます。 けれども、 Gitホストとしては、 クローン操作中にバンドル URI を広告(advertise)して、 この機能を知らないユーザーを支援したいと思うかもしれません。</p></div>
<div class="paragraph"><p>この機能に必要なのは、 サーバーが 1 つ以上のバンドル URI を広告(advertise)可能であることだけです。 この広告(advertisement)は、 バンドル URI を検出するために、特別に、新しいプロトコル v2 機能の形式を取ります。</p></div>
<div class="paragraph"><p>クライアントはオプションとして任意(arbitrary)のバンドル URI を選択するか、または、いくつかの探索的チェック(exploratory checks)によって最高のパフォーマンスを持つ URI を選択できます。 複数の URI を持つことが、 サーバー側のインフラストラクチャを通じて地理的に分散された単一の URI よりも望ましいかどうかを判断するのは、バンドル提供側次第です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_cloning_with_bundle_uris">Cloning with Bundle URIs</h2>
<div class="sectionbody">
<div class="paragraph"><p>バンドル URI の主な需要はクローンを高速化することです。 Git クライアントは、 以下の流れに従ってバンドル URI と対話します:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
ユーザーが <code>--bundle-uri</code> コマンドライン・オプションを使用してバンドル URI を指定するか、 クライアントが Git サーバーによって広告(advertise)されたバンドル・リストを検出します。
</p>
</li>
<li>
<p>
If the downloaded data from a bundle URI is a bundle, then the client inspects the bundle headers to check that the prerequisite commit OIDs are present in the client repository. If some are missing, then the client delays unbundling until other bundles have been unbundled, making those OIDs present. When all required OIDs are present, the client unbundles that data using a refspec. The default refspec is <code>+refs/heads/*:refs/bundles/*</code>, but this can be configured. These refs are stored so that later <code>git fetch</code> negotiations can communicate each bundled ref as a <code>have</code>, reducing the size of the fetch over the Git protocol. To allow pruning refs from this ref namespace, Git may introduce a numbered namespace (such as <code>refs/bundles/&lt;i&gt;/*</code>) such that stale bundle refs can be deleted.
</p>
</li>
<li>
<p>
ファイルが代わりにバンドル・リストである場合、 クライアントは <code>bundle.mode</code> を調べて、リストが <code>all</code> と <code>any</code> のどちらの形式であるかを確認します。
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
<code>bundle.mode=all</code> の場合、 クライアントは全バンドル URI を考慮します。 クライアント・リポジトリの部分(partial)クローン・フィルターに一致する <code>bundle.&lt;id&gt;.filter</code> オプションに基づいてリストが削られます。 それから、 全バンドル URI を要求します。 <code>bundle.&lt;id&gt;.creationToken</code> ヒューリスティックが提供されている場合、 バンドルは作成トークン(creationToken)の降順でダウンロードされ、 バンドルに必要な OID がすべて揃った時点で停止(stop)します。 その後、 作成トークンの昇順でバンドルをバンドル解除(unbundle)できます。 クライアントは、 バンドル・リストがより大きな作成トークンを含むバンドルを広告(advertise)しない場合、 将来のダウンロードを回避するためのヒューリスティックとして最新の作成トークンを保存します。
</p>
</li>
<li>
<p>
<code>bundle.mode=any</code> の場合、 クライアントは調べたバンドル URI のいずれかを選択できます。 クライアントは、 さまざまな方法でこれらの URI を選択できます。 最初の選択で結果が返されなかった場合、 クライアントは別の URI にフォールバックすることもできます。
</p>
</li>
</ol></div>
</li>
</ol></div>
<div class="paragraph"><p>注意: クローン中はすべてのバンドルが必要になることが予想されます。 また、 <code>bundle.&lt;uri&gt;.creationToken</code> などのヒューリスティックを使用して、 バンドルを時系列または並列でダウンロードできます。</p></div>
<div class="paragraph"><p>特定のバンドル URI が <code>bundle.heuristic</code> 値を持つバンドル・リストである場合、 クライアントはその URI を選択したバンドル URI として保存することを選択できます。 その後、クライアントは、 後の <code>git fetch</code> 呼び出し中にその URI に直接移動できます。</p></div>
<div class="paragraph"><p>クライアントは、 バンドル URI をダウンロードするとき、 コンテンツ全体のダウンロードをお願いする前に、 最初のコンテンツを調査することを選択できます。 これにより、 URI がバンドル・リストかバンドルかを判断するのに十分な情報が得られる場合があります。 バンドルの場合、 クライアントはバンドル・ヘッダーを調べて、 広告(advertise)されたすべての先端(tips)がクライアント・リポジトリに既にあることを確認し、 残りのダウンロードをキャンセルすることができます。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_fetching_with_bundle_uris">Fetching with Bundle URIs</h2>
<div class="sectionbody">
<div class="paragraph"><p>クライアントが新しいデータをフェッチするとき、 origin のリモートから取得する前に、バンドル・サーバーから取得するよう決めておく事ができます。 これはコマンド・ライン・オプションを介して行うこともできますが、 クローン中に指定したような構成値を使用する方が便利な場合があります。</p></div>
<div class="paragraph"><p>フェッチ操作は、 バンドル・リストからバンドルをダウンロードするのと同じ手順に従います(ただし、 私達は、ここでは並列ダウンロードを使用することを「望んでいません」)。 薄いバンドル(thin bundle)内のすべての前提条件のコミット OID がオブジェクト・データベースに既にある場合、 私達は処理の終了(end)を期待します。</p></div>
<div class="paragraph"><p><code>creationToken</code> ヒューリスティックを使用する場合、 それらの作成トークン(creation tokens)が格納されている作成トークン(creation tokens)以下の数値の場合、 クライアントはバンドルのダウンロードを回避できます。 新しいバンドルをフェッチした後、 Git はこのローカル作成トークン(creation token)を更新します。</p></div>
<div class="paragraph"><p>バンドル提供側(bundle provider)がヒューリスティックを提供しない場合、 クライアント・リポジトリにバンドル先端(bundle tips)が既に存在する場合に、 クライアントは全バンドル・データをダウンロードする前にバンドル・ヘッダーの調査を試みるべきです。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_error_conditions">Error Conditions</h2>
<div class="sectionbody">
<div class="paragraph"><p>バンドル URI またはその場所で見つかったバンドル・リストに従って情報をダウンロードしているときに、 Git クライアントが予期しないものを発見した場合、 Git はそのデータを無視して、 バンドル URI が指定されていないかのように処理を続行できます。 バンドル URI ではなく、リモート Git サーバーは、最終的に信頼できる情報源です。</p></div>
<div class="paragraph"><p>以下にエラー状態の例をいくつか示します:</p></div>
<div class="ulist"><ul>
<li>
<p>
クライアントが指定された URI でサーバーとの接続に失敗するか、または、接続が失われて回復する機会がありません。
</p>
</li>
<li>
<p>
クライアントは 400番台のレスポンス (<code>404 Not Found</code> や <code>401 Not Authorized</code> など) を受け取りました。 クライアントは、 資格情報ヘルパー(credential helper)を使用して URI の資格情報(credential)を見つけて提供する必要がありますが、 特定の 400番台のエラーの処理に関しては、 Git の他の HTTP プロトコルのセマンティクスと一致させる必要があります。
</p>
</li>
<li>
<p>
サーバがその他の「失敗」応答(failure response)を返しました。
</p>
</li>
<li>
<p>
クライアントが受け取ったデータがバンドルまたはバンドル・リストとしてパースできませんでした。
</p>
</li>
<li>
<p>
バンドルに期待したものでないフィルターが含まれています。
</p>
</li>
<li>
<p>
前提条件のコミット OID がオブジェクト・データベースになく、 ダウンロードするバンドルがこれ以上ないため、 クライアントはそのバンドルをバンドル解除(unbundle)できません。
</p>
</li>
</ul></div>
<div class="paragraph"><p>また、以下は無駄だと見なされる状況な事もありますが、エラー状態ではありません:</p></div>
<div class="ulist"><ul>
<li>
<p>
ダウンロードされたバンドルには、 クローンまたはフェッチ要求によって要求されたよりも多くの情報が含まれています。 あるあるな例として、 ユーザーが <code>--single-branch</code> を使用してクローンを要求するが、 すべての <code>refs/heads/*</code> 参照から到達可能なすべてのコミットを格納するバンドルをダウンロードする場合です。 これは最初は無駄かもしれませんが、おそらくこれらのオブジェクトは、 クライアントが気にする後々 ref 更新によって到達可能オブジェクトに成る事でしょう。
</p>
</li>
<li>
<p>
<code>git fetch</code> 中のバンドルのダウンロードには、 オブジェクト・データベースに既にあるオブジェクトが含まれています。 リモート・サーバーへの「追随」(catch-up)フェッチを実行した時は、 ほとんどの場合、 クライアントはバンドル・サーバーよりもわずかに先行するため、 フェッチにバンドルを使用している場合、 これはおそらく避けられません。 この余分な作業は、 サーバーがバンドルを計算するよりも、クライアントがはるかに頻繁にフェッチしている場合に最も無駄になります。 たとえば、 サーバーは週イチでバンドルを計算のに、 クライアントがバックグラウンド・メンテナンスで 1 時間ごとのプリフェッチを行っている場合です。 このため、サーバーが <code>bundle.heuristic</code> 値を通じて明示的に推奨しない限り、 クライアントは fetch にバンドル URI を使用しないでください。
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_example_bundle_provider_organization">Example Bundle Provider organization</h2>
<div class="sectionbody">
<div class="paragraph"><p>バンドル URI 機能は、バンドル提供側(bundle provider)がオブジェクト・データを編成するさまざまな方法に柔軟に対応できるように意図的に設計されています。 ただし、 以下で説明する完全な編成モデルを用意しておけば、 提供側(provider)がそのベースから始める事ができるので、役に立つことがあります。</p></div>
<div class="paragraph"><p>この編成例は、 GVFS キャッシュ・サーバー (このドキュメントの最後のセクションを参照) で使用されるものの単純化されたモデルであり 、Git 以外の追加のソフトウェアを使用していますが、 非常に大きなリポジトリ(very large repositories)のクローンとフェッチを高速化するのに役立ちました。</p></div>
<div class="paragraph"><p>バンドル提供側(bundle provider)は、 サーバーを複数の地域に展開します。 各サーバーは独自のバンドル・セットを管理します。 サーバーは多数の Git リポジトリを追跡できますが、 バンドル・リストの提供は各々のパターンに基づいています。 たとえば、 <code>https://&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;</code> でリポジトリをミラーリングする場合、 バンドル・サーバーはそのバンドル・リストを <code>https://&lt;server-url&gt;/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;</code> で使用できるようにすることができます。 origin の Git サーバーは、 これらすべてのサーバーを <code>any</code> モードでリストできます:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle]
        version = 1
        mode = any</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "eastus"]
        uri = https://eastus.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "europe"]
        uri = https://europe.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "apac"]
        uri = https://apac.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;</code></pre>
</div></div>
<div class="paragraph"><p>この「リストのリスト」は静的であり、 バンドル・サーバーが追加または削除された場合にのみ変更されます。</p></div>
<div class="paragraph"><p>各バンドル・サーバーは、 独自のバンドルの組を管理します。 最初のバンドル・リストには、 単一のバンドルのみが含まれており、 origin サーバーからリポジトリをクローンして受け取ったすべてのオブジェクトが含まれています。 リストは <code>creationToken</code> ヒューリスティックを使用し、 <code>creationToken</code> はサーバーのタイムスタンプに基づいてバンドル用に作成されます。</p></div>
<div class="paragraph"><p>バンドル・サーバーは、 1 日 1 回など、 定期的にスケジュールされたバンドル・リストの更新を実行します。 このタスクの処理中、 サーバーは origin サーバーから最新のコンテンツをフェッチし、 最新の origin ref から到達可能であるが、 以前に計算されたバンドルには含まれていないオブジェクトを含むバンドルを生成します。 このバンドルは、 <code>creationToken</code> 値が以前の最大 <code>creationToken</code> 値より必ず大きくなるように注意してリストに追加されます。</p></div>
<div class="paragraph"><p>バンドルリストが大きくなりすぎたとき、 つまり、 バンドルの数が30を超えると、 「N - 30」(N minus 30)より古いバンドル達を1つのバンドルにまとめます。 このバンドルの <code>creationToken</code> は、 まとめられたバンドルの中の最大の <code>creationToken</code> と等しくなります。</p></div>
<div class="paragraph"><p>以下にバンドル・リストの例を示しますが、日毎のバンドルは2つしかなく、リストは30個にはとうてい足りていません:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle]
        version = 1
        mode = all
        heuristic = creationToken</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-13-1644770820-daily"]
        uri = https://eastus.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;/2022-02-09-1644770820-daily.bundle
        creationToken = 1644770820</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-09-1644442601-daily"]
        uri = https://eastus.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;/2022-02-09-1644442601-daily.bundle
        creationToken = 1644442601</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>[bundle "2022-02-02-1643842562"]
        uri = https://eastus.example.com/&lt;domain&gt;/&lt;org&gt;/&lt;repo&gt;/2022-02-02-1643842562.bundle
        creationToken = 1643842562</code></pre>
</div></div>
<div class="paragraph"><p>origin サーバーで到達不能になったにもかかわらず、 永続的にオブジェクト・データを保存および提供することを避けるために、 このバンドルのマージをより慎重に行うことができます。 古いバンドル達の絶対結合(absolute union)を得る代わりに、 より新しいバンドル達を調べて、 このマージされたバンドルで必要なコミットが全て利用可能であることを確認することでバンドルを作成できます。 これにより、 この期間内に新しいコミット達で使用されていないオブジェクト・データを「期限切れにする」ことができます。 そのデータは、その後のプッシュによって再導入される可能性があります。</p></div>
<div class="paragraph"><p>このデータ編成は主に2つの事を意図しています。 ひとつ目は、 リポジトリの最初のクローンは、 より近いソースから事前計算(precompute)されたオブジェクト・データをダウンロードすることで高速に行われます。 ふたつ目は、 特に、 クライアントが数日間フェッチしていない場合は、 <code>git fetch</code> コマンドの方が高速ですが、 クライアントが 30 日間フェッチしないと、 バンドル・リストの編成により、 大量のオブジェクト・データが再ダウンロードされます。</p></div>
<div class="paragraph"><p>頻繁にフェッチするユーザーにとってこの編成をより便利にする方法のひとつは、 より頻繁にバンドルを作成することです。 たとえば、 バンドルを 1 時間ごと(every hour)に作成し、 1 日に 1 回これらの「毎時」(hourly)バンドルを、「日次」(daily)バンドルにマージすることができます。 日次(daily)バンドルは、 30 日後に「最古のバンドル」(the oldest bundle)にマージされます。</p></div>
<div class="paragraph"><p>このリポジトリのクライアントがブロブ無し部分クローン(blobless partial clones)を使用することを期待している場合は、 このバンドル戦略を <code>blob:none</code> フィルターで繰り返すことをお勧めします。 この ブロブ無しバンドル(blobless bundle)のリストは、 完全なバンドル(full bundle)と同一のリストに入りますが、 <code>bundle.&lt;id&gt;.filter</code> キーを使用することで 2 つのグループに分離します。 非常に大きなリポジトリの場合、 バンドル提供側(bundle provider)はブロブ無しバンドル(blobless bundle)のみを提供したい場合があります。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_plan">Implementation Plan</h2>
<div class="sectionbody">
<div class="paragraph"><p>この設計ドキュメントは、 いくつかのパッチ・シリーズの過程で言及されたすべてのクライアント機能を実装することを目標として、 野心的なドキュメントとして単独で提案されています。 提案に値する見込みのある機能(概要)は以下のとおり:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>--bundle-uri</code> オプションを使用して、バンドル URI を <code>git clone</code> に統合します。 これには、 <code>git clone</code> の下位実装として使用するための新しい <code>git fetch --bundle-uri</code> モードが含まれます。 この初期バージョンは、 与えられた URI で単一のバンドルが指定されること期待しています。
</p>
</li>
<li>
<p>
バンドル URI からバンドル・リストをパースする機能を実装し、 <code>bundle.mode</code> オプションを適切に区別するために <code>git fetch --bundle-uri</code> ロジックを更新します。 設定形式(config format)のパースでキーと値のペアのリストがバンドル・リスト・ロジックに送られるように、 機能を具体的に設計します。
</p>
</li>
<li>
<p>
<code>bundle-uri</code> プロトコル v2 コマンドを作成して、 Git サーバーがキーと値のペアを使用してバンドル URI を広告(advertise)できるようにします。 バンドル・リスト・ロジックへの既存のキー値入力に組み込みます。 <code>git clone</code> がこれらのバンドル URI を検出し、 バンドル・データからクライアント・リポジトリをゼロから作成(bootstrap)できるようにします。 (この選択は、 構成オプションとコマンドライン・オプションにより、 ユーザーに許可を求める方式(opt-in) です。)
</p>
</li>
<li>
<p>
Allow the client to understand the <code>bundle.heuristic</code> configuration key and the <code>bundle.&lt;id&gt;.creationToken</code> heuristic. When <code>git clone</code> discovers a bundle URI with <code>bundle.heuristic</code>, it configures the client repository to check that bundle URI during later <code>git fetch &lt;remote&gt;</code> commands.
</p>
</li>
<li>
<p>
Allow clients to discover bundle URIs during <code>git fetch</code> and configure a bundle URI for later fetches if <code>bundle.heuristic</code> is set.
</p>
</li>
<li>
<p>
<code>bundle.&lt;id&gt;.creationToken</code> ヒューリスティックが利用できない場合にデータのダウンロードを減らすために、「ヘッダー調査」(inspect headers)ヒューリスティックを実装します。
</p>
</li>
</ol></div>
<div class="paragraph"><p>これらの機能が見直されるにつれて、 この計画は更新される可能性があります。 また、 この機能が成熟し、 実際のシナリオで使用されるようになるにつれて、 新しい設計が発見され、 実装されることも期待しています。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_related_work_packfile_uris">Related Work: Packfile URIs</h2>
<div class="sectionbody">
<div class="paragraph"><p>Git プロトコルには、 Git サーバーがクライアントのリクエストを処理するときに、 パックファイル応答(response)と共に URL の組をリストできる機能が既に備わっています。 クライアントは、 レスポンスを受け取った後、 レスポンスを完全に理解するために、 それらの URL の場所にあるパックファイルをダウンロードする必要があります。</p></div>
<div class="paragraph"><p>このメカニズムは(JGit で実装された) Gerrit サーバーによって使用され、 クローン時の、 CPU 負荷の削減とユーザー・パフォーマンスの向上に効果的です。</p></div>
<div class="paragraph"><p>このメカニズムの主な欠点は、 origin サーバーがこれらのパックファイルの内容を「正確に」知る必要があり、 サーバーが応答した後しばらくの間、 ユーザーがパックファイルを利用できる必要があることです。 この、 origin と パックファイル・データの間の結合の管理は困難です。</p></div>
<div class="paragraph"><p>さらに、 この実装はフェッチで機能させるのが非常に困難です。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_related_work_gvfs_cache_servers">Related Work: GVFS Cache Servers</h2>
<div class="sectionbody">
<div class="paragraph"><p>GVFS プロトコル [2] は、Git の部分(partial)クローンが作成される以前に、 Git プロジェクトとは別に設計された一連の HTTP 通信端点(endponts)です。 このプロトコルの特徴の 1 つは、 中央サーバーに過負荷をかけずに Git データを転送するために、 ビルド・マシンまたは開発者オフィスと同じ場所に配置できる「キャッシュ・サーバー」のアイデアです。</p></div>
<div class="paragraph"><p>VFS for Git で有名な通信端点(endpoint)は、 オンデマンドでオブジェクトをダウンロードできる <code>GET /gvfs/objects/{oid}</code> 通信端点(endpoint)です。 これは、 当該製品のファイル・システム仮想化の重要な部分です。</p></div>
<div class="paragraph"><p>けれども、 <code>GET /gvfs/prefetch?lastPackTimestamp=&lt;t&gt;</code> 通信端点(endpoint)は必要性が薄いです。 オプションのタイムスタンプを指定すると、 キャッシュ・サーバーは、 それらの時間間隔で導入されたコミットとツリーを含む、事前計算されたパックファイルのリストで応答します。</p></div>
<div class="paragraph"><p>キャッシュ・サーバーは、 以下の戦略を使用してこれらの「プリフェッチ」パックファイルを計算します: The cache server computes these "prefetch" packfiles using the following strategy:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
1 時間ごとに指定のタイムスタンプで「毎時」(hourly)パックが生成されます。
</p>
</li>
<li>
<p>
毎晩、それ以前の 24 時間分の毎時パックが「日次」(daily)パックにまとめられます。
</p>
</li>
<li>
<p>
毎晩、 30 日以上経過したすべてのプリフェッチ・パックが 1 つのパックにまとめられます。
</p>
</li>
</ol></div>
<div class="paragraph"><p>ユーザーがキャッシュ・サーバーを使用して、リポジトリ対して <code>gvfs clone</code> または <code>scalar clone</code> を実行すると、 クライアントはすべてのプリフェッチ・パック・ファイルを要求します。これは、コミットとツリーのみをダウンロードする、最大で「24 + 30 + 1」の数のパックファイルです。 次に、 クライアントは origin サーバーに参照を要求し、その先端参照(tip reference)のチェックアウトを試みます。 (コミットがまだプリフェッチ・パック・ファイルに含まれていない場合に備えて、 特定のコミットから到達可能なすべてのツリーを取得するのに役立つ追加の通信端点(endpoint)があります。)</p></div>
<div class="paragraph"><p><code>git fetch</code> 中、 フックは、 以前にダウンロードされたプリフェッチ・パック・ファイルからの最新のタイムスタンプを使用して、 プリフェッチ通信端点(endnpoint)を要求します。 タイムスタンプが新しいパック・ファイルのリストのみがダウンロードされます。 ほとんどのユーザーは 1 時間ごとにフェッチするため、 1 時間ごとに最大 1 つのプリフェッチ・パックを取得します。 マシンの電源がオフになっているか、 30 日以上フェッチされていないユーザーは、 すべてのプリフェッチ・パック・ファイルを再ダウンロードする可能性がありますが、これはまれな事です。</p></div>
<div class="paragraph"><p>クライアントは常に refs 広告(advertisement)のために origin サーバーに接続するため、 refs はプリフェッチされたパック・データよりも「先に」なることが多いことに注意することが重要です。 不足しているオブジェクトは、 <code>git checkout</code> や <code>git log</code> などのコマンドで必要になったときに、 <code>GET gvfs/objects/{oid}</code> リクエストを使用してオンデマンドでダウンロードされます。 一部の Git 最適化は、これらのオンデマンド・ダウンロードに積極的になりすぎる原因となるチェックを無効にします。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">See Also</h2>
<div class="sectionbody">
<div class="paragraph"><p>[1] <a href="https://lore.kernel.org/git/RFC-cover-00.13-0000000000-20210805T150534Z-avarab@gmail.com/">https://lore.kernel.org/git/RFC-cover-00.13-0000000000-20210805T150534Z-avarab@gmail.com/</a>
    An earlier RFC for a bundle URI feature.</p></div>
<div class="paragraph"><p>[2] <a href="https://github.com/microsoft/VFSForGit/blob/master/Protocol.md">https://github.com/microsoft/VFSForGit/blob/master/Protocol.md</a>
    The GVFS Protocol</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-07-18 11:06:02 JST
</div>
</div>
</body>
</html>
