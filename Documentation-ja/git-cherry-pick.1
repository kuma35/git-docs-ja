'\" t
.\"     Title: git-cherry-pick
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-CHERRY\-PICK" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-cherry-pick \- いくつかの既存のコミットによって導入された変更を適用します
.SH "SYNOPSIS"
.sp
.nf
\fIgit cherry\-pick\fR [\-\-edit] [\-n] [\-m <parent\-number>] [\-s] [\-x] [\-\-ff]
                  [\-S[<keyid>]] <commit>\&...
\fIgit cherry\-pick\fR (\-\-continue | \-\-skip | \-\-abort | \-\-quit)
.fi
.sp
.SH "DESCRIPTION"
.sp
1つ以上の既存のコミットが与えられた場合、それぞれが導入する変更を適用し、それぞれに新しいコミットを記録します。 これには、作業ツリーがクリーン(HEADコミットが編集中でない)である必要があります。
.sp
変更を適用する方法が明確でない場合、以下のようになります:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
現在のブランチと
\fBHEAD\fR
ポインタは、正常に行われた最後のコミットに留まります。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
\fBCHERRY_PICK_HEAD\fR
refは、適用が難しい変更を導入したコミットを指すように設定されています。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
変更がクリーンに適用されたパスは、インデックスファイルとあなたの作業ツリーの両方で更新されます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
競合するパスの場合、\fBgit-merge\fR(1)
の「TRUE MERGE」セクションで説明されているように、インデックスファイルには最大3つのバージョンが記録されます。 作業ツリーファイルには、通常の競合マーカー
\fB<<<<<<<\fR
および
\fB>>>>>>>\fR
で囲まれた競合の説明が含まれます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
その他の変更は行われません。
.RE
.sp
このような競合を解決するための幾つかのヒントについては、 \fBgit-merge\fR(1) を参照してください。
.SH "OPTIONS"
.PP
<commit>\&...
.RS 4
チェリーピックにコミットします。 コミットを綴る方法のより完全なリストについては、
\fBgitrevisions\fR(7)
を参照してください。 コミットのセットを渡すことはできますが、デフォルトでは、
\fB\-\-no\-walk\fR
オプションが指定されているかのように振る舞い、トラバーサルは実行されません。
\fBgit-rev-list\fR(1)
を参照してください。 範囲を指定すると、すべての
\fB<commit>\&.\&.\&.\fR
引数が単一のリビジョンウォークに送られることに注意してください(\fBmaint master\&.\&.next\fR
を使用するk後述する例を参照してください)。
.RE
.PP
\fB\-e\fR, \fB\-\-edit\fR
.RS 4
このオプションを使用すると、
\fBgit cherry\-pick\fR
を使用してコミットする前にコミットメッセージを編集できます。
.RE
.PP
\fB\-\-cleanup=<mode>\fR
.RS 4
このオプションは、コミットメッセージがコミット機構に渡される前にどのようにクリーンアップされるかを決定します。 詳細については、
\fBgit-commit\fR(1)
を参照してください。 特に、
\fB<mode>\fR
に
\fBscissors\fR
の値が指定されている場合、競合が発生した場合に渡される前に、切り取り線 が
\fBMERGE_MSG\fR
に追加されます。
.RE
.PP
\fB\-x\fR
.RS 4
コミットを記録するときは、"(cherry picked from commit \&...)" という行を元のコミットメッセージに追加して、この変更がどのコミットからチェリーピックされたかを示します。 これは、競合のないチェリーピックに対してのみ行われます。 情報が受信者にとって役に立たないため、プライベートブランチからチェリーピッキングをしている場合は、このオプションを使用しないでください。 一方、公開されている2つのブランチ間を選択している場合(たとえば、開発ブランチからの古いリリースのメンテナンスブランチへの修正をバックポートする場合)、この情報を追加すると便利です。
.RE
.PP
\fB\-r\fR
.RS 4
以前は、コマンドはデフォルトで上記の
\fB\-x\fR
を実行し、
\fB\-r\fR
はそれを無効にすることでした。 現在、デフォルトでは
\fB\-x\fR
を実行しないため、このオプションは何もしません。
.RE
.PP
\fB\-m <parent\-number>\fR, \fB\-\-mainline <parent\-number>\fR
.RS 4
マージのどちら側をメインラインと見なすべきかわからないため、通常、マージを選択することはできません。 このオプションは、メインラインの親番号(1から始まる)を指定し、cherry\-pickが指定された親に関連する変更を再実行(replay)できるようにします。
.RE
.PP
\fB\-n\fR, \fB\-\-no\-commit\fR
.RS 4
通常、コマンドはコミットのシーケンスを自動的に作成します。 このフラグは、コミットを行わずに、名前付きの各コミットを作業ツリーとインデックスにチェリーピックするために必要な変更を適用します。 さらに、このオプションを使用する場合、インデックスはHEADコミットと一致する必要はありません。 チェリーピックは、インデックスの開始状態に対して行われます。
.sp
これは、インデックスへの複数のコミットの効果を連続して選択する場合に便利です。
.RE
.PP
\fB\-s\fR, \fB\-\-signoff\fR
.RS 4
コミットメッセージの最後に
\fBSigned\-off\-by\fR
トレーラーを追加します。 詳細については、\fBgit-commit\fR(1)
のsignoffオプションを参照してください。
.RE
.PP
\fB\-S[<keyid>]\fR, \fB\-\-gpg\-sign[=<keyid>]\fR, \fB\-\-no\-gpg\-sign\fR
.RS 4
GPG署名コミット。
\fBkeyid\fR
引数はオプションであり、デフォルトでコミッターIDになります。 指定する場合は、スペースなしでオプションに固定する必要があります。
\fB\-\-no\-gpg\-sign\fR
は、
\fBcommit\&.gpgSign\fR
構成変数と以前の
\fB\-\-gpg\-sign\fR
の両方を打ち消すのに役立ちます。
.RE
.PP
\fB\-\-ff\fR
.RS 4
現在のHEADが、チェリーピックされたコミットの親と同じである場合、このコミットへの早送り(fast forward)が実行されます。
.RE
.PP
\fB\-\-allow\-empty\fR
.RS 4
デフォルトでは、空のコミットのチェリーピックは失敗し、
\fBgit commit \-\-allow\-empty\fR
の明示的な呼び出しが必要であることを示します。 このオプションはその動作をオーバーライドし、空のコミットをチェリーピックに自動的に保存できるようにします。
\fB\-\-ff\fR
が有効な場合、「早送り」要件を満たす空のコミットは、このオプションがなくても保持されることに注意してください。 注意: また、このオプションを使用すると、最初は空だったコミット(つまり、親と同じツリーを記録していたコミット)だけが保持されることに注意してください。以前のコミットのために空にされたコミットはドロップされます。 これらのコミットを強制的に含めるには、
\fB\-\-keep\-redundant\-commits\fR
を使用します。
.RE
.PP
\fB\-\-allow\-empty\-message\fR
.RS 4
デフォルトでは、空のメッセージでコミットをチェリーピックすると失敗します。 このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをチェリーピックできるようにします。
.RE
.PP
\fB\-\-keep\-redundant\-commits\fR
.RS 4
チェリーピックされているコミットが現在の履歴にすでにあるコミットと重複している場合、そのコミットは空になります。 デフォルトでは、これらの冗長なコミットにより
\fBcherry\-pick\fR
が停止するため、ユーザーはコミットを調べることができます。 このオプションはその動作をオーバーライドし、空のコミットオブジェクトを作成します。
\fB\-\-allow\-empty\fR
の指定含んでいます。
.RE
.PP
\fB\-\-strategy=<strategy>\fR
.RS 4
指定のマージ戦略を使用します。複数回指定できません。 詳細については、
\fBgit-merge\fR(1)
の「MERGE STRATEGIES」セクションを参照してください。
.RE
.PP
\fB\-X<option>\fR, \fB\-\-strategy\-option=<option>\fR
.RS 4
マージ戦略固有のオプションをマージ戦略に渡します。 詳細については、
\fBgit-merge\fR(1)
を参照してください。
.RE
.PP
\fB\-\-rerere\-autoupdate\fR, \fB\-\-no\-rerere\-autoupdate\fR
.RS 4
rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。
\fB\-\-no\-rerere\-autoupdate\fR
は、別の
\fBgit add\fR
で結果をインデックスにコミットする前に、「rerere」が行ったことを再確認し、潜在的な間違いマージ(mismerges)を捉える良い方法です。
.RE
.SH "SEQUENCER SUBCOMMANDS"
.PP
\fB\-\-continue\fR
.RS 4
\fB\&.git/sequencer\fR
の情報を使用して、進行中の操作の続行を行います。失敗したcherry\-pickまたはrevertの競合を解決した後、続行するために使用できます。
.RE
.PP
\fB\-\-skip\fR
.RS 4
現在のコミットをスキップして、残りのシーケンスを続行します。
.RE
.PP
\fB\-\-quit\fR
.RS 4
進行中の今回の操作を忘れてください。チェリーピックまたはrevertに失敗した後、シーケンサーの状態をクリアするために使用できます。
.RE
.PP
\fB\-\-abort\fR
.RS 4
操作をキャンセルして、シーケンス操作前の状態に戻ります。
.RE
.SH "EXAMPLES"
.PP
\fBgit cherry\-pick master\fR
.RS 4
masterブランチの先端でコミットによって導入された変更を適用し、その変更で新しいコミットを作成します。
.RE
.PP
\fBgit cherry\-pick \&.\&.master\fR, \fBgit cherry\-pick ^HEAD master\fR
.RS 4
masterの祖先であるがHEADの祖先ではないすべてのコミットによって導入された変更を適用して、新しいコミットを生成します。
.RE
.PP
\fBgit cherry\-pick maint next ^master\fR, \fBgit cherry\-pick maint master\&.\&.next\fR
.RS 4
maintまたはnextの祖先であるが、masterまたはその祖先のいずれでもないすべてのコミットによって導入された変更を適用します。 後者は
\fBmaint\fR
と
\fBmaster\fR
と
\fBnext\fR
の間のすべてを意味するものではないことに注意してください。 具体的には、
\fBmaster\fR
に含まれている場合は
\fBmaint\fR
は使用されません。
.RE
.PP
\fBgit cherry\-pick master~4 master~2\fR
.RS 4
masterが指す最後から5番目と3番目のコミットによって導入された変更を適用し、これらの変更を使用して2つの新しいコミットを作成します。
.RE
.PP
\fBgit cherry\-pick \-n master~1 next\fR
.RS 4
作業ツリーとインデックスに、masterが指す最後から2番目のコミットとnextが指す最後のコミットによって導入された変更を適用しますが、これらの変更でコミットを作成しないでください。
.RE
.PP
\fBgit cherry\-pick \-\-ff \&.\&.next\fR
.RS 4
履歴が線形で、HEADがnextの祖先である場合は、作業ツリーを更新し、HEADポインターをnextに一致するように進めます。 それ以外の場合は、次のコミットで導入された変更を現在のブランチに適用し、新しい変更ごとに新しいコミットを作成します。
.RE
.PP
\fBgit rev\-list \-\-reverse master \-\- README | git cherry\-pick \-n \-\-stdin\fR
.RS 4
READMEにアクセスしたmasterブランチのすべてのコミットによって導入された変更を作業ツリーとインデックスに適用します。これにより、結果を検査して、必要に応じて1つの新しいコミットにすることができます。
.RE
.sp
以下のシーケンスは、パッチのバックポートを試み、パッチが適用されるコードが大幅に変更されたためにベイルアウト(脱出; git reste)してから、再試行します。今度は、コンテキスト行の一致にさらに注意を払います。
.sp
.if n \{\
.RS 4
.\}
.nf
$ git cherry\-pick topic^             \fB(1)\fR
$ git diff                           \fB(2)\fR
$ git reset \-\-merge ORIG_HEAD        \fB(3)\fR
$ git cherry\-pick \-Xpatience topic^  \fB(4)\fR
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fB1. \fR\fBgit show topic^\fR
で表示される変更を適用します。 この例では、パッチが適切に適用されないため、競合に関する情報がインデックスと作業ツリーに書き込まれ、新しいコミット結果はありません。
.br
\fB2. \fR調停する変更を要約します
.br
\fB3. \fRチェリーピックをキャンセルします。 つまり、作業ツリーで行ったローカルの変更を保持したまま、チェリーピック前の状態に戻ります。
.br
\fB4. \fRより多くの時間のを費やして、
\fBtopic^\fR
によって導入された変更を再度適用し、コンテキスト行の誤った一致に基づく間違いを避けようと試みます。
.br
.SH "SEE ALSO"
.sp
\fBgit-revert\fR(1)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
