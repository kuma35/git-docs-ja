'\" t
.\"     Title: git-rev-list
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-REV\-LIST" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-rev-list \- コミットオブジェクトを新しい順に一覧表示します
.SH "SYNOPSIS"
.sp
.nf
\fIgit rev\-list\fR [<options>] <commit>\&... [[\-\-] <path>\&...]
.fi
.sp
.SH "DESCRIPTION"
.sp
指定されたコミットから「親」リンクをたどることによって到達可能なコミットをリストしますが、その前に ^ が付いているコミットから到達可能なコミットは除外します。デフォルトでは、出力は時系列の逆順で表示されます。
.sp
これは集合演算と考えることができます。 コマンドラインで指定されたコミットのいずれかから到達可能なコミットのセットを形成し、 ^ が前に付いたコミットのいずれかから到達可能なコミットがそのセットから差し引かれます。差し引かれた残りのコミットは、コマンドの出力に出力されるものです。他のさまざまなオプションとパスパラメータ(pats parameters)を使用して、結果をさらに制限できます。
.sp
したがって、以下のコマンド:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rev\-list foo bar ^baz
.fi
.if n \{\
.RE
.\}
.sp
.sp
は、「foo または bar から到達可能であるが、 baz からは到達できないすべてのコミットをリストする」を意味します。
.sp
特別な表記 \fB<commit1>\&.\&.<commit2>\fR は、 \fB^<commit1> <commit2>\fR の省略形として使用できます。たとえば、以下のどちらかを同じ意味で使用できます:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rev\-list origin\&.\&.HEAD
$ git rev\-list HEAD ^origin
.fi
.if n \{\
.RE
.\}
.sp
.sp
もう1つの特別な表記法は、マージに役立つ \fB<commit1>\&.\&.\&.<commit2>\fR です。結果として得られるコミットのセットは、2つのオペランド間の対称差(symmetric difference)です。以下の2つのコマンドは同等です:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git rev\-list A B \-\-not $(git merge\-base \-\-all A B)
$ git rev\-list A\&.\&.\&.B
.fi
.if n \{\
.RE
.\}
.sp
.sp
\*(Aqrev\-list\(cqは、コミットの祖先グラフ作成およびトラバースする機能を提供するため、非常に重要なGitコマンドです。 このため、\*(Aqgit bisect\(cqや\*(Aqgit repack\(cqなどのさまざまなコマンドで使用できるようにするさまざまなオプションがあります。
.SH "OPTIONS"
.SS "Commit Limiting"
.sp
ここで説明されている特別な表記法を使用してリストする必要があるコミットの範囲を指定することに加えて、追加のコミット制限が適用される場合があります。
.sp
より多くのオプションを使用すると、通常、出力がさらに制限されます(たとえば、\fB\-\-since=<date1>`は\fR<date1>\fBより新しいコミットに制限され、\fR\-\-grep=<pattern>\fBと一緒に使用すると、ログメッセージに\fR<pattern>`と一致する行があるコミットにさらに制限されます)。
.sp
注意: これらは、`\-\-reverse`などのコミット順序およびフォーマットオプションの前に適用されることに注意してください。
.PP
\fB\-<number>\fR, \fB\-n <number>\fR, \fB\-\-max\-count=<number>\fR
.RS 4
出力するコミットの数を制限します。
.RE
.PP
\fB\-\-skip=<number>\fR
.RS 4
コミット出力の表示を開始する前に、number 個のコミットをスキップします。
.RE
.PP
\-\-since=<date>, \fB\-\-after=<date>\fR
.RS 4
指定の日付よりも新しいコミットを表示します。
.RE
.PP
\fB\-\-since\-as\-filter=<date>\fR
.RS 4
特定の日付より新しいすべてのコミットを表示します。 これは、特定の日付より古い最初のコミットで停止するのではなく、範囲内のすべてのコミットを訪問します。
.RE
.PP
\fB\-\-until=<date>\fR, \fB\-\-before=<date>\fR
.RS 4
指定の日付より古いコミットを表示します。
.RE
.PP
\fB\-\-max\-age=<timestamp>\fR, \fB\-\-min\-age=<timestamp>\fR
.RS 4
コミット出力を指定された時間範囲に制限します。
.RE
.PP
\fB\-\-author=<pattern>\fR, \fB\-\-committer=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致する作者(author)/コミッター(committer)ヘッダー行を持つものに制限します。複数の
\fB\-\-author=<pattern>\fR
がある場合、作者が指定されたパターンのいずれかに一致するコミットが選択されます(複数の
\fB\-\-committer=<pattern>\fR
の場合も同様)。
.RE
.PP
\fB\-\-grep\-reflog=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致するreflogエントリを持つものに制限します。複数の`\-\-grep\-reflog`を使用すると、指定されたパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。`\-\-walk\-reflogs`が使用されていない限り、このオプションを使用するとエラーになります。
.RE
.PP
\fB\-\-grep=<pattern>\fR
.RS 4
コミット出力を、指定されたパターン(正規表現)に一致するログメッセージを持つものに制限します。複数の`\-\-grep=<pattern>\fBを使用すると、指定されたパターンのいずれかにメッセージが一致するコミットが選択されます(全てに一致するコミットだけを選択したい場合、\fR\-\-all\-match`を参照してください)。
.RE
.PP
\fB\-\-all\-match\fR
.RS 4
コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての`\-\-grep`に一致するものに制限します。
.RE
.PP
\fB\-\-invert\-grep\fR
.RS 4
コミット出力を、`\-\-grep=<pattern>`で指定されたパターンと一致しないログメッセージを持つものに制限します。
.RE
.PP
\fB\-i\fR, \fB\-\-regexp\-ignore\-case\fR
.RS 4
大文字小文字に関係なく、正規表現の制限パターンに一致します。
.RE
.PP
\fB\-\-basic\-regexp\fR
.RS 4
制限パターンを基本正規表現として扱います。これがデフォルトです。
.RE
.PP
\fB\-E\fR, \fB\-\-extended\-regexp\fR
.RS 4
制限パターンを、デフォルトの基本正規表現の代わりに拡張正規表現として扱います。
.RE
.PP
\fB\-F\fR, \fB\-\-fixed\-strings\fR
.RS 4
制限パターンを固定文字列として扱います(パターンを正規表現として解釈しないでください)。
.RE
.PP
\fB\-P\fR, \fB\-\-perl\-regexp\fR
.RS 4
制限パターンをPerl互換の正規表現として扱います。
.sp
これらのタイプの正規表現のサポートは、コンパイル時オプションに依存します。Gitが当該のサポート付きでコンパイルされていない場合、このオプションを提供すると、Gitが死にます(die)。
.RE
.PP
\fB\-\-remove\-empty\fR
.RS 4
指定されたパスがツリーから見えなくなったら停止(stop)します。
.RE
.PP
\fB\-\-merges\fR
.RS 4
マージコミットのみを印刷します。これは`\-\-min\-parents=2`とまったく同じです。
.RE
.PP
\fB\-\-no\-merges\fR
.RS 4
複数の親を持つコミットを出力しない。これは`\-\-max\-parents=1`とまったく同じです。
.RE
.PP
\fB\-\-min\-parents=<number>\fR, \fB\-\-max\-parents=<number>\fR, \fB\-\-no\-min\-parents\fR, \fB\-\-no\-max\-parents\fR
.RS 4
量の多少に関わらず、とにかく複数の親コミットがあるコミットのみを表示します。特に、\fB\-\-max\-parents=1`は\fR\-\-no\-merges`と同じであり、\fB\-\-min\-parents=2`は\fR\-\-merges`と同じです。\fB\-\-max\-parents=0`はすべてのルートコミットを提供し、\fR\-\-min\-parents=3`はすべてのタコ足マージ(octopus merges)を示します。
.sp
\fB\-\-no\-min\-parents`と\fR\-\-no\-max\-parents`は、これらの制限を(制限なしに)再度リセットします。同等の形式は、\fB\-\-min\-parents=0\fR(すべてのコミットに0個以上の親があります)および`\-\-max\-parents=\-1`(マイナスの数は上限がないことを示します)です。
.RE
.PP
\fB\-\-first\-parent\fR
.RS 4
インクルードするコミットを探すとき、マージ・コミットの最初の親コミットのみをたどります。 このオプションは、特定のトピックブランチの進化を表示するときに、より良い概要を提供できます。トピックブランチへのマージは、時々更新されるアップストリームに調整することだけである傾向があり、このオプションを使用すると、そのようなマージによって履歴に取り込まれた個々のコミットを無視できます。
.RE
.PP
\fB\-\-exclude\-first\-parent\-only\fR
.RS 4
(\fB^\fR
を使用して)除外するコミットを見つけるときは、判明したマージ・コミットの最初の親コミットのみに従います。 任意のマージが有効なトピック・ブランチの変更になる可能性がある場合、これを使用して、リモート・ブランチから分岐したポイントからトピック・ブランチ内の一連の変更を見つけることができます。
.RE
.PP
\fB\-\-not\fR
.RS 4
次に現れる
\fB\-\-not\fR
までの間、後続のすべてのリビジョン指定子の
\fB^\fR(カレット)接頭辞(またはその欠如)の意味を逆にします。
.RE
.PP
\fB\-\-all\fR
.RS 4
\fBrefs/\fR
内のすべてのrefが HEAD とともに、コマンドラインに <commit> としてリストされているかのように見せかけます。
.RE
.PP
\fB\-\-branches[=<pattern>]\fR
.RS 4
\fBrefs/heads\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-tags[=<pattern>]\fR
.RS 4
\fBrefs/tags\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合は、指定されたシェルグロブ(shell glob)に一致するタグにタグを制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-remotes[=<pattern>]\fR
.RS 4
\fBrefs/remotes\fR
内のすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。 <pattern> が指定されている場合、リモート追跡ブランチを指定されたシェルグロブ(shell glob)に一致するものに制限します。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-glob=<glob\-pattern>\fR
.RS 4
シェルグロブ <glob\-pattern> に一致するすべてのrefがコマンドラインに <commit> としてリストされているかのように見せかけます。先頭の
\fBrefs/\fR
は、欠落している場合は自動的に先頭に追加されます。パターンに "?" または "*" または "[" がない場合、最後に "/*" が含まれます。
.RE
.PP
\fB\-\-exclude=<glob\-pattern>\fR
.RS 4
次の
\fB\-\-all\fR
または
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
または
\fB\-\-glob\fR
が別の方法で考慮する <glob\-pattern> に一致するrefを含めないでください。このオプションを繰り返すと、次の
\fB\-\-all\fR
または
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
または
\fB\-\-glob\fR
オプションまで除外パターンが蓄積されます(他のオプションまたは引数は、蓄積されたパターンをクリアしません)。
.sp
与えられたパターンは、それぞれ
\fB\-\-branches\fR
または
\fB\-\-tags\fR
または
\fB\-\-remotes\fR
に適用される場合、
\fBrefs/heads\fR
または
\fBrefs/tags\fR
または
\fBrefs/remotes\fR
で始まるべきではありません。
\fB\-\-glob\fR
または
\fB\-\-all\fR
に適用する場合は、
\fBrefs/\fR
で始める必要があります。末尾の "/*" を意図している場合は、明示的に指定する必要があります。
.RE
.PP
\fB\-\-reflog\fR
.RS 4
reflogsで言及されているすべてのオブジェクトがコマンドラインに <commit> としてリストされているかのように見せかけます。
.RE
.PP
\fB\-\-alternate\-refs\fR
.RS 4
代替リポジトリのref先端として言及されているすべてのオブジェクトがコマンドラインにリストされているかのように見せかけます。代替リポジトリは、オブジェクトディレクトリが`objects/info/alternates`で指定されているリポジトリです。インクルードされたオブジェクトのセットは、`core\&.alternateRefsCommand`などによって変更できます。\fBgit-config\fR(1)を参照してください。
.RE
.PP
\fB\-\-single\-worktree\fR
.RS 4
デフォルトでは、作業ツリーが複数ある場合、\fB\-\-all`と\fR\-reflog`と`\-\-indexed\-objects`では、すべての作業ツリーが検査されます(\fBgit-worktree\fR(1)を参照)。このオプションは、現在の作業ツリーのみを調べるように強制します。
.RE
.PP
\fB\-\-ignore\-missing\fR
.RS 4
入力に無効なオブジェクト名が含まれている場合、そもそもその不正な入力が行われていないかのように見せかけます。
.RE
.PP
\fB\-\-stdin\fR
.RS 4
コマンドラインにリストされている <commit> に加えて、標準入力からそれらを読み取ります。
\fB\-\-\fR
区切り文字が表示された場合は、コミットの読み取りを停止し、パスの読み取りを開始して結果を制限します。
.RE
.PP
\fB\-\-quiet\fR
.RS 4
標準出力には何も出力しないでください。この形式は主に、呼び出し元が終了ステータスをテストして、オブジェクトの範囲が完全に接続されているかどうかを確認できるようにすることを目的としています。出力をフォーマットする必要がないため、stdoutを`/dev/null`にリダイレクトするよりも高速です。
.RE
.PP
\fB\-\-disk\-usage\fR, \fB\-\-disk\-usage=human\fR
.RS 4
通常の出力を抑制します。代わりに、選択したコミットまたはオブジェクトによってディスク上のストレージに使用されたバイトの合計を出力します。これは、出力が(特に
\fB\-\-use\-bitmap\-index\fR
を伴った場合)はるかに高速に実行されることを除いて、出力を
\fBgit cat\-file \-\-batch\-check=\*(Aq%(objectsize:disk)\*(Aq\fR
にパイプすることと同じです。 "on\-disk storage" の意味する制限については、
\fBgit-cat-file\fR(1)
の「CAVEATS」を参照してください。 オプションの値
\fBhuman\fR
を使用すると、ディスク上のストレージ・サイズが人間が読み取れる文字列で表示されます(例: 12\&.24 Kib、3\&.50 Mib など)。
.RE
.PP
\fB\-\-cherry\-mark\fR
.RS 4
\fB\-\-cherry\-pick\fR（以下を参照）と同様ですが、同等のコミットを省略せずに
\fB=\fR
と印し、同等でないコミットを
\fB+\fR
と印します。
.RE
.PP
\fB\-\-cherry\-pick\fR
.RS 4
コミットの組を対称差(symmetric difference)に制限する場合、「反対側」の別のコミットと同じ変更を導入するコミットを省略します。
.sp
たとえば、\fBA\fR
と
\fBB\fR
の2つのブランチがある場合、それらの片側だけですべてのコミットを一覧表示する通常の方法は、
\fB\-\-left\-right\fR
を使用することです(\fB\-\-left\-right\fR
オプションの説明の以下の例を参照してください)。ただし、他のブランチからは(ブランチAと重複しない)厳選されたコミットが表示されます(たとえば、「3rd onb」はブランチAからチェリーピックされる可能性があります)。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。
.RE
.PP
\fB\-\-left\-only\fR, \fB\-\-right\-only\fR
.RS 4
リストは、対称差のそれぞれの側でのみコミットします。つまり、\fB\-\-left\-right`で `<\fR
と印されるのだけか、あるいは`\-\-left\-right`で`>`と印されるものだけです。
.sp
たとえば、\fB\-\-cherry\-pick \-\-right\-only A\&.\&.\&.B`は、`A`にある、または`A`のコミットとパッチと同等のコミットを`B`から省略します。つまり、これは`git cherry A B`からの\fR+\fBコミットをリストします。より正確に書くと、\fR\-\-cherry\-pick \-\-right\-only \-\-no\-merges`により正確なリストを提供します。
.RE
.PP
\fB\-\-cherry\fR
.RS 4
`\-\-right\-only \-\-cherry\-mark \-\-no\-merges`の同義語です。出力を私たちの側のコミットに制限し、フォークされた履歴の反対の側に適用されたものを、`git cherry upstream mybranch`と同様に`git log \-\-cherry upstream\&...mybranch`で印するのに役立ちます。
.RE
.PP
\fB\-g\fR, \fB\-\-walk\-reflogs\fR
.RS 4
コミットの祖先チェーンをたどる代わりに、reflogエントリを最新のものから古いものに移動します。このオプションを使用する場合、除外するコミットを指定することはできません(つまり、 "^commit" や
\fBcommit1\&.\&.commit2\fR
や
\fBcommit1\&.\&.\&.commit2\fR
表記は使用できません)。
.sp
(明らかな理由で、)\fBoneline`と`reference`以外の\fR\-\-pretty`形式では、これにより、出力にreflogから取得された2行の追加情報が含まれます。出力のreflog指定子は、\fBref@{Nth}\fR
(\fBNth\fR
はreflogの逆時系列インデックス(reverse\-chronological index))または
\fBref@{timestamp}\fR
(そのエントリのタイムスタンプ付き)として表示されます。表示は下記のいくつかのルールに依存します:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
開始点が
\fBref@{Nth}\fR
として指定されている場合は、インデックス形式を表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
開始点が
\fBref@{now}\fR
として指定されている場合は、タイムスタンプ形式を表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
上記のどちらも使用されていないが、コマンドラインで`\-\-date`が指定されている場合は、`\-\-date`で要求された形式でタイムスタンプを表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
それ以外の場合は、インデックス形式を表示します。
.RE
.sp
\fB\-\-pretty = oneline`では、コミットメッセージの前にこの情報が同じ行に付けられます。このオプションを\fR\-\-reverse`と組み合わせることはできません。\fBgit-reflog\fR(1)も参照してください。
.sp
`\-\-pretty=reference`では、この情報はまったく表示されません。
.RE
.PP
\fB\-\-merge\fR
.RS 4
マージが失敗した後、競合があり、マージするすべてのheadに存在しないファイルに関連(touch)するrefを表示します。
.RE
.PP
\fB\-\-boundary\fR
.RS 4
除外された境界コミットを出力します。 境界コミットの前には `\-`が付いています。
.RE
.PP
\fB\-\-use\-bitmap\-index\fR
.RS 4
(使用可能な場合は、)パックビットマップインデックスを使用して、トラバーサルを高速化しようと試みます。`\-\-objects`でトラバースする場合、ツリーとブロブには関連するパスが出力されないことに注意してください。
.RE
.PP
\fB\-\-progress=<header>\fR
.RS 4
オブジェクトが対称になるときに、stderrに進捗レポートを表示します。`<header>`テキストは、進行状況が更新されるたびに印刷されます。
.RE
.SS "History Simplification"
.sp
特定の<path>を変更するコミットなど、履歴の一部のみに関心がある場合があります。ただし、「履歴の簡略化」(History Simplification)は2つの部分から成ります。履歴を簡略化するためにはさまざまな戦略があるためです。その1つはコミットの選択であり、もう1つはそれを行う方法です。
.sp
以下のオプションは、表示するコミットを選択します:
.PP
<paths>
.RS 4
指定された<パス>を変更するコミットが選択されます。
.RE
.PP
\fB\-\-simplify\-by\-decoration\fR
.RS 4
いくつかのブランチまたはタグによって参照されるコミットが選択されます。
.RE
.sp
注意: 意味のある重要な履歴のために、追加のコミットを表示できることに注意してください。
.sp
以下のオプションは、簡略化の実行方法に影響します。
.PP
Default mode
.RS 4
履歴を、ツリーの最終状態を説明する最も単純な履歴に単純化します。最終結果が同じである場合(つまり、同じコンテンツのブランチをマージする場合)、いくつかの傍流ブランチ(side branches)を削除するため、最も単純です。
.RE
.PP
\fB\-\-show\-pulls\fR
.RS 4
デフォルトモードからのすべてのコミットを含めますが、最初の親へのTREESAMEではなく、後の親へのTREESAMEであるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに役立ちます。(訳注:TREESAME=pathspecが全く同一であるツリー)
.RE
.PP
\fB\-\-full\-history\fR
.RS 4
デフォルトモードと同じですが、一部の履歴を削除しません。
.RE
.PP
\fB\-\-dense\fR
.RS 4
選択したコミットのみが表示され、重大で意味のある履歴を持つコミットもいくつか表示されます。
.RE
.PP
\fB\-\-sparse\fR
.RS 4
簡略化された履歴内のすべてのコミットが表示されます。
.RE
.PP
\fB\-\-simplify\-merges\fR
.RS 4
このマージに寄与する選択されたコミットがないため、結果の履歴からいくつかの不要なマージを削除するための`\-\-full\-history`への追加オプション。
.RE
.PP
\fB\-\-ancestry\-path[=<commit>]\fR
.RS 4
表示するコミットの範囲を指定すると(例:
\fBcommit1\&.\&.commit2\fR
または
\fBcommit2 ^commit1\fR)、その範囲内で <commit> の祖先、<commit> の子孫、または <commit> 自身であるコミットのみを表示します。 コミットが指定されていない場合は、\fBcommit1\fR
(範囲の除外部分) を <commit> として使用します。 複数回渡すことができます。 その場合、あるコミットが指定されたコミットのいずれかであるか、それらのいずれかの祖先または子孫である場合、そのコミットは含まれます。
.RE
.sp
より詳細な説明は以下のとおりです。
.sp
<paths> として \fBfoo\fR を指定したとします。 \fBfoo\fR !TREESAME を変更するコミットを呼び出し、残りをTREESAMEと呼びます。( \fBfoo\fR のためにフィルタリングされた差分では、それぞれ異なって見えたりたり等しく見えたりします。）
.sp
以下、簡略化設定の違いを説明するために、同じ履歴例を使います。このコミットグラフでは、ファイル \fBfoo\fR をフィルタリングしていると想定しています:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \e   /   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq   X
.fi
.if n \{\
.RE
.\}
.sp
.sp
履歴 A\-\-\-Q の水平線は、各マージの最初の親と見なされます。その各コミットは以下のとおりです:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBI\fR
は最初のコミットであり、ファイル foo が内容 \(lqasdf\(rq で存在し、ファイル quux は内容 \(lqquux\(rq で存在します。最初のコミットは空のツリーと比較されるため、\fBI\fR
は !TREESAME です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBA\fR
では、 foo には \(lqfoo\(rq だけが含まれています。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBB\fR
には
\fBA\fR
と同じ変更が含まれています。そのマージ
\fBM\fR
は些細なことであり、したがってすべての親にとって TREESAME です。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\fR
は
\fBfoo\fR
を変更しませんが、そのマージ
\fBN\fR
はそれを \(lqfoobar\(rq に変更するので、どの親にとっても TREESAME ではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBD\fR
は
\fBfoo\fR
を \(lqbaz\(rq に設定します。そのマージ
\fBO\fR
は、
\fBN\fR
と
\fBD\fR
から \(lqfoobarbaz\(rq への文字列を結合します。つまり、どの親にとっても TREESAME ではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBE\fR
は
\fBquux\fR
を \(lqxyzzy\(rq に変更し、そのマージ
\fBP\fR
は文字列を \(lqquuxxyzzy\(rq に結合します。
\fBP\fR
は
\fBO\fR
に対して TREESAME ですが、
\fBE\fR
に対してはそうではありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBX\fR
は、新ファイル
\fBside\fR
を追加し、
\fBY\fR
がそれを変更した独立したルートコミットです。
\fBY\fR
は
\fBX\fR
へのTREESAMEです。そのマージ
\fBQ\fR
は
\fBP\fR
に
\fBside\fR
を追加し、
\fBQ\fR
は
\fBP\fR
にはTREESAMEですが、\fBY\fR
に対してはそうではありません。
.RE
.sp
\fBrev\-list\fR は、 \fB\-\-full\-history\fR および/または、( \fB\-\-parents\fR または \fB\-\-children\fR を介して)親の書き換えが使用されているかどうかに基づいて、コミットを含めたり除外したりして、履歴を逆方向にウォークスルーします。以下の設定が可能です。
.PP
Default mode
.RS 4
コミットは、どの親に対してもTREESAMEでない場合に含まれます(これは変更できますが、以下の
\fB\-\-sparse\fR
を参照してください)。コミットがマージであり、一方の親に対するTREESAMEであった場合は、その親のみをフォローします。(TREESAMEの親が複数ある場合でも、そのうちの1つだけをフォローします)。それ以外の場合は、すべての親をフォローします。
.sp
これにより、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-N\-\-\-O
         /     /   /
        I\-\-\-\-\-\-\-\-\-D
.fi
.if n \{\
.RE
.\}
.sp
TREESAMEの親のみに従うルールが利用可能な場合は、
\fBB\fR
を検討対象から完全に削除したことに注意してください。
\fBC\fR
は
\fBN\fR
を介して考慮されましたが、しかしそれはTREESAMEです。ルートコミットは空のツリーと比較されるため、
\fBI\fR
は !TREESAME です。
.sp
親子関係は
\fB\-\-parents\fR
でのみ表示されますが、デフォルトモードで選択されたコミットには影響しないため、親の行を示しました。
.RE
.PP
\fB\-\-full\-history without parent rewriting\fR
.RS 4
このモードは、デフォルトとはある一点で異なります。つまり、いずれかの親に対してTREESAMEであっても、常にマージのすべての親に従います。マージの複数の側にコミットが含まれている場合でも、これはマージ自体が含まれていることを意味するものではありません！ 例では以下のようになります。
.sp
.if n \{\
.RS 4
.\}
.nf
        I  A  B  N  D  O  P  Q
.fi
.if n \{\
.RE
.\}
.sp
\fBM\fR
は、両方の親にとってTREESAMEであるため、除外されました。
\fBE\fR
と
\fBC\fR
と
\fBB\fR
をすべて巡りましたが、
\fBB\fR
だけが !TREESAME だったので、他は表示されません。
.sp
注意: 親の書き換え(rewrite)がないと、コミット間の親子関係について話す(talk)ことは実際には不可能であるため、それらが切断されている(disconnected)ことを示していることに注意してください。
.RE
.PP
\fB\-\-full\-history with parent rewriting\fR
.RS 4
通常のコミットは !TREESAME の場合にのみ含まれます(これは変更できますが、以下の
\fB\-\-sparse\fR
を参照してください)。
.sp
マージは常に含まれます。ただし、親リストは書き直されます。各親に沿って、自分自身に含まれていないコミットを削除します。 これにより以下のようになります。
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /
        I     B   /   D   /
         \e   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
上記を書き直さずに
\fB\-\-full\-history\fR
と比較してください。
\fBE\fR
はTREESAMEであるため削除されましたが、Pの親リストは
\fBE\fR
の親
\fBI\fR
を含むように書き直されていることに注意してください。
\fBC\fR
と
\fBN\fR
および
\fBX\fR
と
\fBY\fR
と
\fBQ\fR
についても同じことが起こりました。
.RE
.sp
上記の設定に加えて、あなたはTREESAMEが包含に影響を与えるかどうかを変更できます:
.PP
\fB\-\-dense\fR
.RS 4
巡ったコミットは、親にとってTREESAMEでない場合に含まれます。
.RE
.PP
\fB\-\-sparse\fR
.RS 4
巡ったすべてのコミットが含まれます。
.sp
\fB\-\-full\-history\fR
がなくても、これによりマージが単純化されることに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側を巡ることはありません。
.RE
.PP
\fB\-\-simplify\-merges\fR
.RS 4
最初に、親を書き換えた
\fB\-\-full\-history\fR
と同じ方法で履歴グラフを作成します(上記を参照)。
.sp
それから、以下のルールに従って、各コミット
\fBC\fR
を最終履歴内の置換
\fBC\*(Aq\fR
に単純化します:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\*(Aq\fR
を
\fBC\fR
にセットします。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBC\*(Aq\fR
の各親
\fBP\fR
をその簡略化された
\fBP\*(Aq\fR
に置き換えます。その過程で、他の親の祖先であるか、ルートである親を削除すると、TREESAMEが空のツリーにコミットされ、重複が削除されますが、TREESAMEであるすべての親を削除しないように注意してください。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
この親の書き換え後、
\fBC\*(Aq\fR
がルートまたはマージコミット(0または >1 の親を持つ)、境界コミット、または !TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。
.RE
.sp
この効果は、親の書き換えを使用した
\fB\-\-full\-history\fR
と比較することで最もよく示されます。例は以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O
         /     /       /
        I     B       D
         \e   /       /
          `\-\-\-\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
注意:
\fB\-\-full\-history\fR
に対する
\fBN\fR
と
\fBP\fR
と
\fBQ\fR
の主な違いに注意してください:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBN\fR
の親リストは、他の親
\fBM\fR
の祖先であるため、
\fBI\fR
が削除されました。それでも、 !TREESAME なので
\fBN\fR
が残りました。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBP\fR
の親リストも同様に
\fBI\fR
が削除されました。
\fBP\fR
は、親が1つで TREESAMEであるため、完全に削除されました。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBQ\fR
の親リストでは、
\fBY\fR
が
\fBX\fR
に簡略化されていました。その後、
\fBX\fR
はTREESAMEルートであったため、削除されました。
\fBQ\fR
は、親が1つで TREESAMEであるため、完全に削除されました。
.RE
.RE
.sp
利用可能な別の簡略化モードがあります:
.PP
\fB\-\-ancestry\-path[=<commit>]\fR
.RS 4
表示されるコミットを <commit> の祖先、または <commit> の子孫、または <commit> 自身に制限します。
.sp
ユースケースの例として、以下のコミット履歴について考えます:
.sp
.if n \{\
.RS 4
.\}
.nf
            D\-\-\-E\-\-\-\-\-\-\-F
           /     \e       \e
          B\-\-\-C\-\-\-G\-\-\-H\-\-\-I\-\-\-J
         /                     \e
        A\-\-\-\-\-\-\-K\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
通常の
\fBD\&.\&.M\fR
は、
\fBM\fR
の祖先であるコミットのセットを計算しますが、
\fBD\fR
の祖先であるコミットは除外します。 これは、「
\fBM\fR
には
\fBD\fR
には存在しなかったものがある」という意味で、
\fBD\fR
以降の
\fBM`に至るまでの歴史に何が起こったのかを知るのに役立ちます。この例の結果は、 `A\fR
と
\fBB\fR
(そしてもちろん
\fBD\fR
自体)を除くすべてのコミットになります。
.sp
ただし、
\fBM\fR
のコミットが
\fBD\fR
で入ったバグで汚染されており、修正が必要な場合は、実際には
\fBD\fR
の子孫である
\fBD\&.\&.M\fR
のサブセットのみを表示する必要があります。つまり、
\fBC\fR
と
\fBK\fR
を除外します。これはまさに
\fB\-\-ancestry\-path\fR
オプションが行うことです。これを
\fBD\&.\&.M\fR
範囲に適用すると、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                E\-\-\-\-\-\-\-F
                 \e       \e
                  G\-\-\-H\-\-\-I\-\-\-J
                               \e
                                L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
\fB\-\-ancestry\-path\fR
の代わりに
\fB\-\-ancestry\-path=D\fR
を使用することもできます。これは、\fBD\&.\&.M\fR
範囲に適用された場合と同じことを意味しますが、より明示的です。
.sp
代わりに、この範囲内の特定のトピックに関心があり、そのトピックによって影響を受けるすべてのコミットに関心がある場合、祖先パスにそのトピックを含む
\fBD\&.\&.M\fR
のサブセットのみを表示したい場合があります。 たとえば、\fB\-\-ancestry\-path=H D\&.\&.M\fR
を使用すると、以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
                E
                 \e
                  G\-\-\-H\-\-\-I\-\-\-J
                               \e
                                L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
一方、\fB\-\-ancestry\-path=K D\&.\&.M\fR
は以下のようになります
.sp
.if n \{\
.RS 4
.\}
.nf
                K\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
別のオプション \fB\-\-show\-pulls\fR について説明する前に、新しいサンプル履歴を作成する必要があります。
.sp
簡略化された履歴を見るときにユーザーが直面する一般的な問題は、ファイルを変更したことがわかっているコミットが、ファイルの簡略化された履歴に表示されないことです。そこで、新しい例を示し、その場合に \fB\-\-full\-history\fR や \fB\-\-simplify\-merges\fR などのオプションがどのように機能するかを示しましょう。
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-\-\-C\-\-N\-\-\-O\-\-\-P
         /     / \e  \e  \e/   /   /
        I     B   \e  R\-\*(Aq`\-Z\*(Aq   /
         \e   /     \e/         /
          \e /      /\e        /
           `\-\-\-X\-\-\*(Aq  `\-\-\-Y\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
この例では、 \fBI\fR が \fBfile\&.txt\fR を作成し、それが \fBA\fR と`B` と \fBX\fR にてさまざまな方法で変更されたとします。ひとり親のコミット \fBC\fR と \fBZ\fR と \fBY\fR は \fBfile\&.txt\fR を変更していません。マージコミット \fBM\fR は、マージの競合を解決して、 \fBA\fR と \fBB\fR の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。ただし、マージコミット \fBR\fR は、 \fBM\fR の \fBfile\&.txt`の内容を無視し、 `X\fR の \fBfile\&.txt\fR の内容のみを取得することによって作成されました。 したがって、 \fBR\fR は \fBX\fR へのTREESAMEですが、 \fBM\fR はそうではありません。最後に、 \fBN\fR を作成するための自然なマージ解決は、 \fBR\fR で \fBfile\&.txt\fR の内容を取得することです。したがって、 \fBN\fR は \fBC\fR ではなく \fBR\fR へのTREESAMEです。マージコミット \fBO\fR と \fBP\fR は、最初の親にはTREESAMEですが、2番目の親である \fBZ\fR と \fBY\fR にはついてはそうではありません。
.sp
デフォルトモードを使用する場合、 \fBN\fR と \fBR\fR は両方ともTREESAMEの親を持っているため、これらのエッジはウォークされ、他のエッジは無視されます。結果の履歴グラフは以下のとおりです:
.sp
.if n \{\
.RS 4
.\}
.nf
        I\-\-\-X
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fB\-\-full\-history\fR を使用する場合、Gitはすべてのエッジを巡ります。これにより、コミット \fBA\fR と \fBB\fR と マージ \fBM\fR が検出されますが、マージコミット \fBO\fR と \fBP\fR も明らかになります。 親を書き換えると、結果のグラフは以下のようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-\-\-\-\-\-N\-\-\-O\-\-\-P
         /     / \e  \e  \e/   /   /
        I     B   \e  R\-\*(Aq`\-\-\*(Aq   /
         \e   /     \e/         /
          \e /      /\e        /
           `\-\-\-X\-\-\*(Aq  `\-\-\-\-\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
ここで、マージコミット \fBO\fR と \fBP\fR は、実際には \fBfile\&.txt\fR への変更を提供しなかったため、余分なノイズを提供します。古いバージョンの \fBfile\&.txt\fR に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です。 \fB\-\-full\-history\fR の結果には、関連のない多くのマージが表示されます。
.sp
\fB\-\-simplify\-merges\fR オプションを使用すると、コミット \fBO\fR と \fBP\fR が結果から消えます。 これは、 \fBO\fR と \fBP\fR の書き直された2番目の親が、最初の親から到達可能であるためです。これらのエッジが削除されると、コミットは、親にとってTREESAMEである単一の親のコミットのように見えます。これはコミット \fBN\fR にも発生し、以下のような履歴ビューが表示されます:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\&.
         /     /    \e
        I     B      R
         \e   /      /
          \e /      /
           `\-\-\-X\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
このビューでは、 \fBA\fR と \fBB\fR と \fBX\fR からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ \fBM\fR とそれほど慎重に解決されていないマージ \fBR\fR も表示されます。これは通常、コミット \fBA\fR と \fBB\fR がデフォルトのビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。
.sp
最初の問題はパフォーマンスです。以前のオプションとは異なり、 \fB\-\-simplify\-merges\fR オプションでは、単一の結果を返す前にコミット履歴全体をウォークする必要があります。これにより、非常に大規模なリポジトリでこのオプションを使用するのが難しくなる可能性があります。
.sp
2番目の問題は監査の1つです。多くの寄稿者が同じリポジトリで作業している場合、どのマージコミットが重要なブランチに変更を導入したかが重要です。上記の問題のあるマージ \fBR\fR は、重要なブランチにマージするために使用されたマージコミットではない可能性があります。 代わりに、マージ \fBN\fR を使用して \fBR\fR と \fBX\fR を重要なブランチにマージしました。このコミットには、変更 \fBX\fR がコミットメッセージの \fBA\fR と \fBB\fR からの変更を上書きするようになった理由に関する情報が含まれている可能性があります。
.PP
\fB\-\-show\-pulls\fR
.RS 4
デフォルトの履歴に表示されるコミットに加えて、最初の親にはTREESAMEではなく、後の親にはTREESAMEである各マージコミットを表示します。
.sp
マージコミットが
\fB\-\-show\-pulls\fR
に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で
\fB\-\-show\-pulls\fR
を使用すると(他のオプションは使用しない場合、)結果のグラフは行かのようになります:
.sp
.if n \{\
.RS 4
.\}
.nf
        I\-\-\-X\-\-\-R\-\-\-N
.fi
.if n \{\
.RE
.\}
.sp
ここで、コミット
\fBX\fR
と
\fBR\fR
をそれぞれベースブランチにプルしたため、マージコミット
\fBR\fR
と
\fBN\fR
が含まれています。これらのマージは、コミット
\fBA\fR
と
\fBB\fR
がデフォルトの履歴に表示されない理由です。
.sp
\fB\-\-show\-pulls\fR
が
\fB\-\-simplify\-merges\fR
とペアになっている場合、グラフには必要なすべての情報が含まれます:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\&.   N
         /     /    \e /
        I     B      R
         \e   /      /
          \e /      /
           `\-\-\-X\-\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
\fBM\fR
は
\fBR\fR
から到達可能であるため、
\fBN\fR
から
\fBM\fR
へのエッジが単純化されていることに注意してください。ただし、
\fBN\fR
は、変更
\fBR\fR
をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。
.RE
.sp
\fB\-\-simplify\-by\-decoration\fR オプションを使用すると、タグで参照されていないコミットを省略して、履歴のトポロジの全体像のみを表示できます。コミットは、(1)タグによって参照されている場合、または (2)コマンドラインで指定されたパスの内容を変更した場合に、!TREESAMEとしてマークされます(つまり、上記の履歴簡略化ルールの後に保持されます)。他のすべてのコミットはTREESAMEとしてマークされます(簡略化される可能性があります)。
.SS "Bisection Helpers"
.PP
\fB\-\-bisect\fR
.RS 4
含まれるコミットと除外されるコミットのほぼ中間にある1つのコミットオブジェクトに出力を制限します。(存在する場合)bad bisection ref
\fBrefs/bisect/bad\fR
が含まれるコミットに追加され、（存在する場合)good bisection ref
\fBrefs/bisect/good\-*\fR
が除外されるコミットに追加されることに注意してください。したがって、
\fBrefs/bisect/\fR
にrefsがないと仮定すると、
.sp
.if n \{\
.RS 4
.\}
.nf
        $ git rev\-list \-\-bisect foo ^bar ^baz
.fi
.if n \{\
.RE
.\}
.sp
は、2つのコマンドの出力である中間点(midpoint)を出力します
.sp
.if n \{\
.RS 4
.\}
.nf
        $ git rev\-list foo ^midpoint
        $ git rev\-list midpoint ^bar ^baz
.fi
.if n \{\
.RE
.\}
.sp
上記は、ほぼ同じ長さになります。 したがって、回帰を導入する変更を見つけることは、バイナリ検索(binary search)に還元されます。コミットチェーンの長さが1になるまで、新しい中間点(midpoint)を繰り返し生成してテストします。
.RE
.PP
\fB\-\-bisect\-vars\fR
.RS 4
これは、
\fBrefs/bisect/\fR
内のrefが使用されないこと、およびシェルによって評価される準備ができているテキストを出力することを除いて、
\fB\-\-bisect\fR
と同じように計算されます。これらの行は、中間点リビジョンの名前を変数
\fBbisect_rev\fR
に割り当て、
\fBbisect_rev\fR
が
\fBbisect_nr\fR
にテストされた後にテストされるコミットの予想数、
\fBbisect_rev\fR
が
\fBbisect_good`に適していることが判明した場合にテストされるコミットの予想数、 `bisect_rev\fR
が
\fBbisect_bad\fR
に不適切であることが判明した場合にテストされるコミットの予想数、および現在
\fBbisect_all\fR
に二等分しているコミットの数です。
.RE
.PP
\fB\-\-bisect\-all\fR
.RS 4
これにより、含まれるコミットと除外されるコミットの間のすべてのコミットオブジェクトが、含まれるコミットと除外されるコミットまでの距離順に出力されます。
\fBrefs/bisect/\fR
のrefは使用されません。それらから最も遠いものが最初に表示されます。(これは
\fB\-\-bisect\fR
によって表示される唯一のものです。)
.sp
これは、何らかの理由(たとえば、コンパイルできない場合など)でそれらの一部をテストすることを避けたい場合に、テストするための適切なコミットを簡単に選択できるため便利です。
.sp
このオプションは
\fB\-\-bisect\-vars\fR
と一緒に使用できます。この場合、ソートされたすべてのコミットオブジェクトの後に、
\fB\-\-bisect\-vars\fR
が単独で使用された場合と同じテキストが表示されます。
.RE
.SS "Commit Ordering"
.sp
デフォルトでは、コミットは新しい順に表示されます。
.PP
\fB\-\-date\-order\fR
.RS 4
すべての子が表示されるまで親を表示しませんが、それ以外の場合はコミットタイムスタンプの順序でコミットを表示します。
.RE
.PP
\fB\-\-author\-date\-order\fR
.RS 4
すべての子が表示されるまで親を表示しませんが、それ以外の場合は、作者(author)のタイムスタンプ順にコミットを表示します。
.RE
.PP
\fB\-\-topo\-order\fR
.RS 4
すべての子が表示されるまで親を表示せず、複数の履歴行が混在するコミットを表示しないようにします。
.sp
たとえば、以下のようなコミット履歴があります:
.sp
.if n \{\
.RS 4
.\}
.nf
    \-\-\-1\-\-\-\-2\-\-\-\-4\-\-\-\-7
        \e              \e
         3\-\-\-\-5\-\-\-\-6\-\-\-\-8\-\-\-
.fi
.if n \{\
.RE
.\}
.sp
ここで、数字はコミットタイムスタンプの順序を示し、
\fBgitrev\-list\fR
と
\fB\-\-date\-order\fR
のある友達は、タイムスタンプの順序でコミットを示します。つまり、8 7 6 5 4 3 2 1
.sp
\fB\-\-topo\-order\fR
を使用すると、8 6 5 3 7 4 2 1（または8 7 4 2 6 5 3 1）が表示されます。2つの並列開発トラックからのコミットが混在して表示されないようにするために、いくつかの古いコミットが新しいコミットの前に表示されます。
.RE
.PP
\fB\-\-reverse\fR
.RS 4
表示するように選択したコミットを逆の順序で出力します(上記の Commit Limiting 節を参照)。
\fB\-\-walk\-reflogs\fR
と組み合わせることはできません。
.RE
.SS "Object Traversal"
.sp
これらのオプションは、主にGitリポジトリのパッキングを対象としています。
.PP
\fB\-\-objects\fR
.RS 4
リストされたコミットによって参照されるオブジェクトのオブジェクトIDを出力します。 したがって、
\fB\-\-objects foo ^bar\fR
「コミットオブジェクトが bar であるが foo でない場合にダウンロードする必要があるすべてのオブジェクトIDを送ってください」という意味です。
.RE
.PP
\fB\-\-in\-commit\-order\fR
.RS 4
ツリーIDとブロブのIDをコミット順に出力します。 ツリーIDとブロブのIDは、コミットによって最初に参照された後に出力されます。
.RE
.PP
\fB\-\-objects\-edge\fR
.RS 4
\fB\-\-objects\fR
に似ていますが、接頭辞 \(lq\-\(rq 文字が付いた除外されたコミットのIDも出力します。これは
\fBgit-pack-objects\fR(1)
によって使用され、ネットワークトラフィックを削減するために、これらの除外されたコミットに含まれるオブジェクトに基づいてオブジェクトを削除された形式で記録する「薄い」パック(thin pack)を構築します。
.RE
.PP
\fB\-\-objects\-edge\-aggressive\fR
.RS 4
\fB\-\-objects\-edge\fR
に似ていますが、時間がかかるという犠牲を払って、除外されたコミットを見つけためにもっともっと頑張ります。これは、\fB\-\-objects\-edge\fR
の代わりに使用されて浅いリポジトリ(shallow repositories)用の「薄い」パック(thin pack)を構築します。
.RE
.PP
\fB\-\-indexed\-objects\fR
.RS 4
インデックスで使用されるすべてのツリーとブロブがコマンドラインにリストされているかのように見せかけます。 注意: たぶんあなたは一緒に
\fB\-\-objects\fR
も使用したいと思うでしょう。
.RE
.PP
\fB\-\-unpacked\fR
.RS 4
\fB\-\-objects\fR
と一緒の時のみ役立ちます。パックに含まれていないオブジェクトIDを出力します。
.RE
.PP
\fB\-\-object\-names\fR
.RS 4
\fB\-\-objects\fR
と一緒の時のみ役立ちます。見つかったオブジェクトIDの名前を出力します。これがデフォルトの動作です。
.RE
.PP
\fB\-\-no\-object\-names\fR
.RS 4
\fB\-\-objects\fR
と一緒の時のみ役立ちます。見つかったオブジェクトIDの名前は出力されません。これにより、
\fB\-\-object\-names\fR
が反転します。 このフラグを使用すると、
\fBgit-cat-file\fR(1)
などのコマンドで出力をより簡単に解析できます。
.RE
.PP
\fB\-\-filter=<filter\-spec>\fR
.RS 4
\fB\-\-objectsほげほげ\fR
のどれかと一緒の時のみ役立ちます。印刷されたオブジェクトのリストからオブジェクト(通常はブロブ)を省略します。 <filter\-spec> は、以下のいずれかになります:
.sp
\fB\-\-filter=blob:none\fR
の形式では、すべてのブロブが省略されます。
.sp
\fB\-\-filter=blob:limit=<n>[kmg]\fR
の形式では、nバイトまたは指定の単位より大きいブロブが省略されます。nはゼロの場合があります。 接尾辞kとmとgを使用して、KiBまたはMiBまたはGiBの単位にすることができます。 たとえば、
\fBblob:limit=1k\fR
は
\fBblob:limit=1024\fR
と同じです。
.sp
\fB\-\-filter=object:type=(tag|commit|tree|blob)\fR
の形式では、要求されたタイプではないすべてのオブジェクトが省略されます。
.sp
\fB\-\-filter=sparse:oid=<blob\-ish>\fR
の形式は、ブロブ(またはブロブ式) <blob\-ish> に含まれるsparse\-checkout仕様を使用して、 要求されたrefsでsparse checkoutに必要のないブロブを省略します。
.sp
\fB\-\-filter=tree:<depth>\fR
の形式は、ルートツリーからの深さが
\fB>= <depth>\fR
(オブジェクトがトラバースされたコミットの複数の深さにある場合の最小深さ)であるすべてのブロブとツリーを省略します。 <depth>=0 は、コマンドライン(または \-\-stdin が使用されている場合は標準入力)に明示的に含まれていない限り、ツリーやブロブを含みません。 <depth>=1 は、 <commit> から到達可能なコミットまたは明示的に指定されたオブジェクトによって直接参照されるツリーとブロブのみが含まれます。 <depth>=2 は <depth>=1 に似ていますが、明示的に指定されたコミットまたはツリーから削除されたもう1つのレベルのツリーとブロブも含まれます。
.sp
注意: ファイルシステム上の任意のパスから読み取れる形式である
\fB\-\-filter=sparse:path=<path>\fR
は、セキュリティ上の理由から削除されたことに注意してください。
.sp
複数の
\fB\-\-filter=\fR
フラグを指定して、フィルターを組み合わせることができます。指定の全てのフィルターで受け入れられるオブジェクトのみが含まれます。
.sp
\fB\-\-filter=combine:<filter1>+<filter2>+\&.\&.\&.<filterN>\fR
の形式を使用して、複数のフィルターを組み合わせることができますが、これは
\fB\-\-filter\fR
フラグを繰り返すよりもずっとずっと難しく、通常は必要はありません。フィルタは
\fB+\fR
で結合され、個々のフィルタは
\fB%\fR
エンコードされます(つまり、URLエンコードされます)。
\fB+\fR
と
\fB%\fR
文字に加えて、次の文字は予約されており、エンコードする必要があります:
\fB~!@#$^&*()[]{}\e;",<>?\fR\fB\*(Aq`\fR
およびASCIコード
\fB0x20\fR
以下の全ての文字(空白(space)と改行(newline)を含む)。
.sp
他の任意の文字もエンコードできます。 たとえば、
\fBcombine:tree:3+blob:none\fR
と
\fBcombine:tree%3A3+blob%3Anone\fR
は同等です。
.RE
.PP
\fB\-\-no\-filter\fR
.RS 4
以前の
\fB\-\-filter=\fR
引数をすべてオフにします。
.RE
.PP
\fB\-\-filter\-provided\-objects\fR
.RS 4
明示的に提供されたオブジェクトのリストをフィルタリングします。そうしないと、どのフィルターとも一致しなくても常に出力されます。
\fB\-\-filter=\fR
と一緒に使った時のみ役に立ちます。
.RE
.PP
\fB\-\-filter\-print\-omitted\fR
.RS 4
\fB\-\-filter=\fR
と一緒の時のみ役立ちます。フィルタによって省略されたオブジェクトのリストを出力します。オブジェクトIDの前には \(lq~\(rq 文字が付いています。
.RE
.PP
\fB\-\-missing=<missing\-action>\fR
.RS 4
将来の「部分クローン」(partial clone)開発に役立つデバッグオプション。このオプションは、欠落しているオブジェクトの処理方法を指定します。
.sp
\fB\-\-missing=error\fR
の形式は、欠落しているオブジェクトが検出された場合に、rev\-list がエラーで停止することを要求します。これがデフォルトのアクションです。
.sp
\fB\-\-missing=allow\-any\fR
の形式を使用すると、欠落しているオブジェクトが検出された場合でも、オブジェクトの走査を続行できます。欠落しているオブジェクトは、結果から黙って省略されます。
.sp
\fB\-\-missing=allow\-promisor\fR
の形式は allow\-any に似ていますが、オブジェクトのトラバーサルは、 EXPECTED promisor が欠落しているオブジェクトに対してのみ続行できます。予期しない欠落したオブジェクトはエラーを発生させます。
.sp
\fB\-\-missing=print\fR
の形式は allow\-any に似ていますが、欠落しているオブジェクトのリストも出力します。オブジェクトIDの前には \(lq?\(rq 文字が付いています。
.RE
.PP
\fB\-\-exclude\-promisor\-objects\fR
.RS 4
(内部使用のみ。) promisor境界でのオブジェクトトラバーサルをプレフィルターします。これは部分クローン(partial clone)で使用されます。これは、欠落しているオブジェクトに関するエラーを単に黙らせるのではなく、トラバーサルを制限するため、
\fB\-\-missing=allow\-promisor\fR
よりも強力です。
.RE
.PP
\fB\-\-no\-walk[=(sorted|unsorted)]\fR
.RS 4
指定されたコミットのみを表示し、祖先をトラバースしない。範囲が指定されている場合、これは効果がありません。引数
\fBunsorted\fR
が指定されている場合、コミットはコマンドラインで指定された順序で表示されます。それ以外の場合(
\fBsorted\fR
または引数が指定されていない場合)、コミットはコミット時間の逆順に表示されます。
\fB\-\-graph\fR
と組み合わせることはできません。
.RE
.PP
\fB\-\-do\-walk\fR
.RS 4
以前の
\fB\-\-no\-walk\fR
を上書きします。
.RE
.SS "Commit Formatting"
.sp
これらのオプションを使用すると、 \fBgit-rev-list\fR(1) より専門的なコミットログツールのファミリーである \fBgit-log\fR(1) や \fBgit-show\fR(1) や \fBgit-whatchanged\fR(1) と同様に機能します。
.PP
\fB\-\-pretty[=<format>]\fR, \fB\-\-format=<format>\fR
.RS 4
コミットログの内容を指定された形式できれいに印刷(pretty\-print)します。 <format> は oneline、short、medium、full、fuller、reference、email、raw、format:<string>、tformat:<string> のいずれかになります。 <format> が上記のいずれでもなく、「%プレースホルダー」が含まれている場合、
\fB\-\-pretty=tformat:<format>\fR
が指定されたかのように動作します。
.sp
各フォーマットの詳細については、「PRETTY FORMATS」セクションを参照してください。
\fB=<format>\fR
の部分を省略すると、デフォルトで medium になります。
.sp
注意: リポジトリー構成でデフォルトのpretty formatを指定できます(\fBgit-config\fR(1)
参照)。
.RE
.PP
\fB\-\-abbrev\-commit\fR
.RS 4
40バイトの16進コミットオブジェクト名全体を表示する代わりに、オブジェクトに一意の名前を付けるプレフィックスを表示します。 "\-\-abbrev=<n>" (表示されている場合はdiff出力も変更します)オプションを使用して、プレフィックスの最小長を指定できます。
.sp
これにより、80桁幅の端末を使用している人にとって "\-\-pretty=oneline" がずっと読みやすくなるはずです。
.RE
.PP
\fB\-\-no\-abbrev\-commit\fR
.RS 4
完全な40バイトの16進コミットオブジェクト名を表示します。 これにより、明示的または "\-\-oneline" などの他のオプションによって暗黙的に示される
\fB\-\-abbrev\-commit\fR
が無効になります。また、
\fBlog\&.abbrevCommit\fR
変数をオーバーライドします。
.RE
.PP
\fB\-\-oneline\fR
.RS 4
これは、 "\-\-pretty=oneline \-\-abbrev\-commit" を一緒に使用するための省略形です。
.RE
.PP
\fB\-\-encoding=<encoding>\fR
.RS 4
コミットオブジェクトは、ログメッセージに使用される文字エンコードをエンコードヘッダーに記録します。このオプションを使用して、ユーザーが好むエンコーディングでコミットログメッセージを再コーディングするようにコマンドに指示できます。配管以外のコマンドの場合、これはデフォルトでUTF\-8になります。オブジェクトが
\fBX\fR
でエンコードされていると主張し、
\fBX\fR
で出力している場合、オブジェクトをそのまま出力することに注意してください。これは、元のコミットの無効なシーケンスが出力にコピーされる可能性があることを意味します。 同様に、 iconv(3) がコミットの変換に失敗した場合、 元のオブジェクトをそのまま黙って出力します。
.RE
.PP
\fB\-\-expand\-tabs=<n>\fR, \fB\-\-expand\-tabs\fR, \fB\-\-no\-expand\-tabs\fR
.RS 4
出力に表示する前に、ログメッセージでタブ展開を実行します(タブ幅を <n> とみなして <n> 境界に揃うように空白で調整する)。
\fB\-\-expand\-tabs\fR
は
\fB\-\-expand\-tabs=8\fR
の省略形であり、
\fB\-\-no\-expand\-tabs\fR
は
\fB\-\-expand\-tabs=0\fR
の省略形です。タブの展開を無効にします。
.sp
デフォルトでは、タブはログメッセージを4つのスペースでインデントするきれいな形式(pretty formats)で展開されます(つまり、medium (これがデフォルト) と full と fuller)。
.RE
.PP
\fB\-\-show\-signature\fR
.RS 4
署名を
\fBgpg \-\-verify\fR
に渡して、署名されたコミットオブジェクトの有効性を確認し、出力を表示します。
.RE
.PP
\fB\-\-relative\-date\fR
.RS 4
\fB\-\-date=relative\fR
と同じ。
.RE
.PP
\fB\-\-date=<format>\fR
.RS 4
\fB\-\-pretty\fR
を使用する場合など、人間が読める形式で表示される日付に対してのみ有効になります。
\fBlog\&.date\fR
構成変数(config variable)は、logコマンドの
\fB\-\-date\fR
オプションのデフォルト値を設定します。デフォルトでは、日付は元のタイムゾーン(コミッターの、または作者のいずれか)で表示されます。フォーマットに
\fB\-local\fR
が追加されている場合(例:
\fBiso\-local\fR
)、代わりにユーザーのローカルタイムゾーンが使用されます。
.sp
\fB\-\-date=relative\fR
は、現在の時刻を基準にした日付を示します。例: \(lq2 hours ago\(rq 。
\fB\-local\fR
オプションは
\fB\-\-date = relative\fR
には効果がありません。
.sp
\fB\-\-date=local\fR
は
\fB\-\-date=default\-local\fR
のエイリアスです。
.sp
\fB\-\-date=iso\fR
(または
\fB\-\-date=iso8601\fR
)は、タイムスタンプをISO 8601のような形式で表示します。厳密なISO 8601形式との違いは以下のとおりです:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBT\fR
日付/時刻区切り文字の代わりにスペース
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
時間とタイムゾーンの間のスペース
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
タイムゾーンの時間と分の間にコロンがありません
.RE
.sp
\fB\-\-date=iso\-strict\fR
(または
\fB\-\-date=iso8601\-strict\fR
)は、タイムスタンプを厳密なISO 8601形式で表示します。
.sp
\fB\-\-date=rfc\fR
(または
\fB\-\-date=rfc2822\fR
)は、RFC 2822形式のタイムスタンプを示します。これは、電子メールメッセージでよく見られます。
.sp
\fB\-\-date=short\fR
は、日付のみを表示し、時刻は表示せず、
\fBYYYY\-MM\-DD\fR
形式で表示します。
.sp
\fB\-\-date=raw\fR
は、エポック(1970\-01\-01 00:00:00 UTC)からの秒数、スペース、UTCからのオフセット(\fB+\fR
または
\fB\-\fR
の付いた4桁数字で、最初の2つは時間、次の2つは分です)。つまり、タイムスタンプが
\fBstrftime("%s %z")\fR
でフォーマットされているかのようになります。
\fB\-local\fR
オプションは、seconds\-since\-epoch値(常にUTCで測定されます)には影響しませんが、付随するタイムゾーン値を切り替えることに注意してください。
.sp
\fB\-\-date=human\fR
は、タイムゾーンが現在のタイムゾーンと一致しない場合はタイムゾーンを表示し、一致する場合は日付全体を印刷しません(つまり、「今年」の日付の場合は年の印刷をスキップしますが、何があったか覚えてるような過去数日については日付自体もスキップします)。 古い日付の場合、時と分も省略されます。
.sp
\fB\-\-date=unix\fR
は、日付をUnixエポックタイムスタンプ(1970年からの秒数)として表示します。
\fB\-\-raw\fR
と同様に、これは常にUTCであるため、 ` \-local` は効果がありません。
.sp
\fB\-\-date=format:\&.\&.\&.\fR
は、内部で処理される%sと%zと%Zを除いて、フォーマット
\fB\&.\&.\&.\fR
をあなたのシステムの
\fBstrftime\fR
に送ります。
\fB\-\-date=format:%c\fR
を使用して、システムロケールの推奨形式で日付を表示します。フォーマットプレースホルダーの完全なリストについては、
\fBstrftime\fR
マニュアルを参照してください。
\fB\-local\fR
を使用する場合、正しい構文は
\fB\-\-date=format\-local:\&.\&.\&.\fR
です。
.sp
\fB\-\-date=default\fR
はデフォルトの形式であり、いくつかの例外を除いて
\fB\-\-date=rfc2822\fR
に似ています:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
曜日の後にコンマはありません
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ローカルタイムゾーンを使用する場合、タイムゾーンは省略されます
.RE
.RE
.PP
\fB\-\-header\fR
.RS 4
コミットの内容をraw形式で出力します。各レコードはNUL文字で区切られます。
.RE
.PP
\fB\-\-no\-commit\-header\fR
.RS 4
"commit" を含むヘッダー行と、指定された形式の前に出力されたオブジェクトIDを抑制します。これは組み込みフォーマットには影響しません。 カスタムフォーマットのみが影響を受けます。
.RE
.PP
\fB\-\-commit\-header\fR
.RS 4
以前の
\fB\-\-no\-commit\-header\fR
を上書きします。
.RE
.PP
\fB\-\-parents\fR
.RS 4
コミットの親も出力します( "commit parent\&..." の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。
.RE
.PP
\fB\-\-children\fR
.RS 4
コミットの子も出力します( "commit child\&..." の形式で)。親の書き換えも可能にします。上記「History Simplification」を参照してください。
.RE
.PP
\fB\-\-timestamp\fR
.RS 4
生のコミットタイムスタンプを出力します。
.RE
.PP
\fB\-\-left\-right\fR
.RS 4
対称差のどちら側からコミットに到達できるかをマークします。左側からのコミットには
\fB<\fR
が付けられ、右側からのコミットには
\fB>\fR
が付けられます。
\fB\-\-boundary\fR
と組み合わせると、それらのコミットの前に
\fB\-\fR
が付きます。
.sp
たとえば、以下のトポロジーの場合:
.sp
.if n \{\
.RS 4
.\}
.nf
             y\-\-\-b\-\-\-b  branch B
            / \e /
           /   \&.
          /   / \e
         o\-\-\-x\-\-\-a\-\-\-a  branch A
.fi
.if n \{\
.RE
.\}
.sp
以下のような出力が得られます:
.sp
.if n \{\
.RS 4
.\}
.nf
        $ git rev\-list \-\-left\-right \-\-boundary \-\-pretty=oneline A\&.\&.\&.B

        >bbbbbbb\&.\&.\&. 3rd on b
        >bbbbbbb\&.\&.\&. 2nd on b
        <aaaaaaa\&.\&.\&. 3rd on a
        <aaaaaaa\&.\&.\&. 2nd on a
        \-yyyyyyy\&.\&.\&. 1st on b
        \-xxxxxxx\&.\&.\&. 1st on a
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-\-graph\fR
.RS 4
出力の左側に、コミット履歴のテキストベースのグラフィック表現を描画します。グラフ履歴を適切に描画するために、コミットの間に余分な行が出力される可能性があります。
\fB\-\-no\-walk\fR
と組み合わせることはできません。
.sp
これにより、親の書き換えが可能になります。上記「History Simplification」を参照してください。
.sp
これは、デフォルトで
\fB\-\-topo\-order\fR
オプションを意味しますが、
\fB\-\-date\-order\fR
オプションも指定できます。
.RE
.PP
\fB\-\-show\-linear\-break[=<barrier>]\fR
.RS 4
\-\-graph を使用しない場合、すべての履歴ブランチがフラット化されるため、2つの連続するコミットが線形ブランチに属していないことがわかりにくくなる可能性があります。このオプションは、その場合、それらの間に障壁を置きます。
\fB<barrier>\fR
が指定されている場合、デフォルトの障壁文字列の代わりに
\fB<barrier>\fR
が表示されます。
.RE
.PP
\fB\-\-count\fR
.RS 4
リストされたコミットの数を示す数値を出力し、他のすべての出力を抑制します。
\fB\-\-left\-right\fR
と一緒に使用する場合は、代わりに、タブで区切って、左右のコミットのカウントを出力します。
\fB\-\-cherry\-mark\fR
と一緒に使用する場合は、これらのカウントからパッチの同等のコミットを省略し、タブで区切られた同等のコミットのカウントを出力します。
.RE
.SH "PRETTY FORMATS"
.sp
コミットがマージであり、 pretty\-format が \fBoneline\fR または \fBemail\fR または \fBraw\fR で無い場合、 \fBAuthor:\fR 行の前に追加の行が挿入されます。この行は "Merge: " で始まり、先祖のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合、リストされたコミットは必ずしも \fB直接\fR の親コミットのリストではない可能性があることに注意してください。
.sp
いくつかの組み込みフォーマットがあります。そして以下で説明するように、 pretty\&.<name> 構成オプション(config option)を別のフォーマット名または \fBformat:\fR 文字列に設定することで、追加のフォーマットを定義できます(\fBgit-config\fR(1) 参照)。組み込みフォーマットの詳細は以下のとおりです:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBoneline\fR
.sp
.if n \{\
.RS 4
.\}
.nf
<hash> <title\-line>
.fi
.if n \{\
.RE
.\}
.sp
これは、可能な限りコンパクトになるように設計されています。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBshort\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <hash>
Author: <author>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title\-line>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBmedium\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <hash>
Author: <author>
Date:   <author\-date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title\-line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full\-commit\-message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBfull\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <hash>
Author: <author>
Commit: <committer>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title\-line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full\-commit\-message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBfuller\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <hash>
Author:     <author>
AuthorDate: <author\-date>
Commit:     <committer>
CommitDate: <committer\-date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title\-line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full\-commit\-message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBreference\fR
.sp
.if n \{\
.RS 4
.\}
.nf
<abbrev\-hash> (<title\-line>, <short\-author\-date>)
.fi
.if n \{\
.RE
.\}
.sp
この形式は、コミットメッセージ内の別のコミットを参照するために使用され、
\fB\-\-pretty=\*(Aqformat:%C(auto)%h (%s, %ad)\*(Aq\fR
と同じです。 デフォルトでは、別の
\fB\-\-date\fR
オプションが明示的に指定されていない限り、日付は
\fB\-\-date=short\fR
でフォーマットされます。formatプレースホルダーを使用する他の
\fBformat:\fR
と同様に、その出力は、
\fB\-\-decorate\fR
や
\fB\-\-walk\-reflogs\fR
などの他のオプションの影響を受けません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBemail\fR
.sp
.if n \{\
.RS 4
.\}
.nf
From <hash> <date>
From: <author>
Date: <author\-date>
Subject: [PATCH] <title\-line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full\-commit\-message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBmboxrd\fR
.sp
\fBemail\fR
と同様ですが、コミットメッセージの "From " で始まる行(前に0個以上の
\fB>\fR
が付いている)は
\fB>\fR
でクォートされているため、新しいコミットの開始と混同されることはありません。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBraw\fR
.sp
\fBraw\fR
形式は、コミットオブジェクトに格納されているとおりにコミット全体を正確に表示します。とりわけ
\fB\-\-abbrev\fR
または
\fB\-\-no\-abbrev\fR
のどちらが使用されているかに関係なく、ハッシュは完全に表示され、「親」(parents)情報は、移植や履歴の単純化を考慮せずに、真の親のコミットを示します。この形式は、コミットの表示方法に影響しますが、いわゆる
\fBgit log \-\-raw\fR
の差分の表示方法ではありません。生のdiff形式で完全なオブジェクト名を取得するには、
\fB\-\-no\-abbrev\fR
を使用します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIformat:<format\-string>\fR
.sp
\fBformat:<format\-string>\fR
形式を使用すると、表示する情報を指定できます。注意: これはprintf書式に少し似ていますが、
\fB\en\fR
の代わりに
\fB%n\fR
を使用して改行を取得するという例外に注意してください。
.sp
例:
\fBformat:"The author of %h was %an, %ar%nThe title was >>%s<<%n"\fR
は以下のように表示されます:
.sp
.if n \{\
.RS 4
.\}
.nf
The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was >>t4119: test autocomputing \-p<n> for traditional diff input\&.<<
.fi
.if n \{\
.RE
.\}
.sp
さて、以下がプレースホルダー達です:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
単一のリテラル文字に展開されるプレースホルダー:
.PP
\fB%n\fR
.RS 4
改行(newline)
.RE
.PP
\fB%%\fR
.RS 4
`%`そのもの
.RE
.PP
\fB%x00\fR
.RS 4
16進数のバイト値を出力
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
うしろのプレースホルダーのフォーマッティングに影響するプレースホルダー:
.PP
\fB%Cred\fR
.RS 4
赤色に切り替える
.RE
.PP
\fB%Cgreen\fR
.RS 4
緑色に切り替える
.RE
.PP
\fB%Cblue\fR
.RS 4
青色に切り替える。
.RE
.PP
\fB%Creset\fR
.RS 4
色をリセットする
.RE
.PP
\fB%C(\&.\&.\&.)\fR
.RS 4
\fBgit-config\fR(1)
の「CONFIGURATION FILE」の Values で説明されている色の指定。 デフォルトでは、色はログ出力が有効になっている場合にのみ表示されます\*(Aq(\fBcolor\&.diff\fR
または
\fBcolor\&.ui\fR
または
\fB\-\-color\fR
によって、ターミナルに出す場合は前者の
\fBauto\fR
設定を尊重します)。
\fB%C(auto,\&.\&.\&.)\fR
は、 default の歴史的同義語として受け入れられます(例:
\fB%C(auto,red)\fR)。
\fB%C(always,\&.\&.\&.)\fR
を指定すると、色が有効になっていない場合でも色が表示されます(この形式やgitが色付けする可能性のある他のすべてのものを含め、出力全体の色を有効にするために
\fB\-\-color=always\fR
の使用を検討してください)。
\fBauto\fR
のみ(つまり、
\fB%C(auto)\fR)は、色が再び切り替わるまで、これに続くプレースホルダーで自動色付けをオンにします。
.RE
.PP
\fB%m\fR
.RS 4
左(\fB<\fR) または 右(\fB>\fR) または 境界 (\fB\-\fR) の印
.RE
.PP
\fB%w([<w>[,<i1>[,<i2>]]])\fR
.RS 4
\fBgit-shortlog\fR(1)
の \-w オプションのように、 行の折り返しを切り替えます。
.RE
.PP
\fB%<(<N>[,trunc|ltrunc|mtrunc])\fR
.RS 4
次のプレースホルダーに少なくともN列を使用させ、 必要に応じて右側にスペースを埋め込みます。オプションで、出力がN列より長い場合は、先頭(ltrunc)または中間(mtrunc)または末尾(trunc)で切り捨てます。注意: 切り捨ては、 N >= 2 でのみ正しく機能することに注意してください。
.RE
.PP
\fB%<|(<N>)\fR
.RS 4
次のプレースホルダーを少なくともN番目の列まで取得し、 必要に応じて右側にスペースを埋め込みます
.RE
.PP
\fB%>(<N>)\fR, \fB%>|(<N>)\fR
.RS 4
それぞれ
\fB%<(<N>)\fR
、
\fB%<|(<N>)\fR
に似ていますが、 左側にスペースが埋め込まれています
.RE
.PP
\fB%>>(<N>)\fR, \fB%>>|(<N>)\fR
.RS 4
\fB%>(<N>)\fR
、
\fB%>|(<N>)\fR
とそれぞれ似ていますが、 次のプレースホルダーが指定されたよりも多くのスペースを取り、その左側にスペースがある場合は、それらのスペースを使用します。
.RE
.PP
\fB%><(<N>)\fR, \fB%><|(<N>)\fR
.RS 4
それぞれ
\fB%<(<N>)\fR
、
\fB%<|(<N>)\fR
に似ていますが、 両側にパディングがあります(つまり、テキストが中央に配置されます)
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
コミットから抽出された情報に展開するプレースホルダー:
.PP
\fB%H\fR
.RS 4
コミットハッシュ
.RE
.PP
\fB%h\fR
.RS 4
省略されたコミットハッシュ
.RE
.PP
\fB%T\fR
.RS 4
ツリーハッシュ
.RE
.PP
\fB%t\fR
.RS 4
省略されたツリーハッシュ
.RE
.PP
\fB%P\fR
.RS 4
親のハッシュ達
.RE
.PP
\fB%p\fR
.RS 4
省略された親のハッシュ達
.RE
.PP
\fB%an\fR
.RS 4
作者名
.RE
.PP
\fB%aN\fR
.RS 4
作者名( \&.mailmap に関しては、\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
を参照)
.RE
.PP
\fB%ae\fR
.RS 4
作者電子メールアドレス
.RE
.PP
\fB%aE\fR
.RS 4
作者電子メールアドレス(\&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
を参照)
.RE
.PP
\fB%al\fR
.RS 4
作者電子メールアドレスアカウント名(local\-part)(\fB@\fR
の前の部分)
.RE
.PP
\fB%aL\fR
.RS 4
作者電子メールアドレスアカウント名(local\-part)(\fB%al\fR
参照) \&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%ad\fR
.RS 4
作成日(フォーマットに関しては \-\-date= オプション参照)
.RE
.PP
\fB%aD\fR
.RS 4
作成日 RFC2822形式
.RE
.PP
\fB%ar\fR
.RS 4
作成日 相対(relative)形式
.RE
.PP
\fB%at\fR
.RS 4
作成日 UNIXタイムスタンプ形式
.RE
.PP
\fB%ai\fR
.RS 4
作成日 ISO 8601風形式
.RE
.PP
\fB%aI\fR
.RS 4
作成日 厳密なISO 8601形式
.RE
.PP
\fB%as\fR
.RS 4
作成日 短い形式(\fBYYYY\-MM\-DD\fR)
.RE
.PP
\fB%ah\fR
.RS 4
作成日 human形式(
\fBgit-rev-list\fR(1)
の
\fB\-\-date=human\fR
オプションのようなかんじ)
.RE
.PP
\fB%cn\fR
.RS 4
コミッター名
.RE
.PP
\fB%cN\fR
.RS 4
作者名( \&.mailmap に関しては、\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%ce\fR
.RS 4
コミッター電子メールアドレス
.RE
.PP
\fB%cE\fR
.RS 4
コミッター電子メールアドレス(\&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%cl\fR
.RS 4
コミッター電子メールアドレスアカウント名(local\-part)(
\fB@\fR
の前の部分)
.RE
.PP
\fB%cL\fR
.RS 4
コミッター電子メールアドレスアカウント名(local\-part)(
\fB%cl\fR
参照) \&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%cd\fR
.RS 4
コミッター日付(フォーマットに関しては
\fB\-\-date=\fR
オプション参照)
.RE
.PP
\fB%cD\fR
.RS 4
コミッター日付 RFC2822形式
.RE
.PP
\fB%cr\fR
.RS 4
コミッター日付 相対(relative)形式
.RE
.PP
\fB%ct\fR
.RS 4
コミッター日付 UNIXタイムスタンプ形式
.RE
.PP
\fB%ci\fR
.RS 4
コミッター日付 ISO 8601風形式
.RE
.PP
\fB%cI\fR
.RS 4
コミッター日付 厳密なISO 8601形式
.RE
.PP
\fB%cs\fR
.RS 4
コミッター日付 短い形式(\fBYYYY\-MM\-DD\fR)
.RE
.PP
\fB%ch\fR
.RS 4
コミッター日付 human形式(\fBgit-rev-list\fR(1)
の
\fB\-\-date=human\fR
オプションのようなかんじ)
.RE
.PP
\fB%d\fR
.RS 4
ref名
\fBgit-log\fR(1)
の \-\-decorate オプションみたいなの
.RE
.PP
\fB%D\fR
.RS 4
" (", ")" で囲ってないref名
.RE
.PP
\fB%(describe[:options])\fR
.RS 4
\fBgit-describe\fR(1)
のような人間が読める名前。 説明できないコミットの場合は空の文字列。
\fBdescribe\fR
文字列の後には、コロンと0個以上のカンマ区切りオプションを続けることができます。タグが同時に追加または削除されると、説明に一貫性がなくなる可能性があります。
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBtags[=<bool\-value>]\fR: 注釈付きタグ(annotated tags)だけを考慮するのではなく、軽量タグ(lightweight tags)も考慮してください。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBabbrev=<number>\fR: 短縮ブジェクト名のデフォルトの 16 進数の桁数 (デフォルトは 7 で、リポジトリ内のオブジェクトの数によって異なります) を使用する代わりに、 <number> 桁を使用するか、または 一意のオブジェクト名を形成するために必要な桁数。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBmatch=<pattern>\fR:
\fBrefs/tags/\fR
プレフィックスを除いて、指定された
\fBglob(7)\fR
パターンに一致するタグのみを考慮します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBexclude=<pattern>\fR:
\fBrefs/tags/\fR
プレフィックスを除いて、指定された
\fBglob(7)\fR
パターンに一致するタグを対象にしません。
.RE
.RE
.PP
\fB%S\fR
.RS 4
コミットに到達したコマンドラインで指定されたref名 (
\fBgit log \-\-source\fR
など)は、
\fBgit log\fR
でのみ機能します
.RE
.PP
\fB%e\fR
.RS 4
エンコーディング
.RE
.PP
\fB%s\fR
.RS 4
件名(subject)
.RE
.PP
\fB%f\fR
.RS 4
ファイル名に適した、サニタイズされた件名
.RE
.PP
\fB%b\fR
.RS 4
本文(body)
.RE
.PP
\fB%B\fR
.RS 4
生本文(raw body)(ラップされてない件名と本文)
.RE
.PP
\fB%GG\fR
.RS 4
署名されたコミットの為のGPSからの生の検証メッセージ
.RE
.PP
\fB%G?\fR
.RS 4
.PP
G
.RS 4
良い(good)な(有効な)署名の場合はこの文字に置換されます。
.RE
.PP
B
.RS 4
悪い署名(bad signature)の場合はこの文字に置換されます。
.RE
.PP
U
.RS 4
有効性が不明(unknown validity)な良い署名の場合はこの文字に置換されます。
.RE
.PP
X
.RS 4
期限切れ(eXpired)の良い署名の場合はこの文字に置換されます。
.RE
.PP
Y
.RS 4
期限切れのキーで作成された良い署名の場合はこの文字に置換されます。
.RE
.PP
R
.RS 4
取り消されたキーによって作成された良い署名の場合はこの文字に置換されます。
.RE
.PP
E
.RS 4
署名を確認できない場合(キーの欠落など)の場合はこの文字に置換されます。
.RE
.PP
N
.RS 4
署名がない場合の場合はこの文字に置換されます。
.RE
.RE
.PP
\fB%GS\fR
.RS 4
署名されたコミットの署名者の名前を表示する
.RE
.PP
\fB%GK\fR
.RS 4
署名されたコミットに署名するために使用されるキーを表示する
.RE
.PP
\fB%GF\fR
.RS 4
署名されたコミットに署名するために使用されるキーのフィンガープリントを表示する
.RE
.PP
\fB%GP\fR
.RS 4
署名されたコミットに署名するためにサブキーが使用された 主キーのフィンガープリントを表示します
.RE
.PP
\fB%GT\fR
.RS 4
署名されたコミットに署名するために使用されるキーの信頼レベル(trust level)を表示します
.RE
.PP
\fB%gD\fR
.RS 4
reflogセレクター(例:\fBrefs/stash@{1}\fR
or
\fBrefs/stash@{2 minutes ago}\fR) この形式は、
\fB\-g\fR
オプションで説明されている規則に従います。
\fB@\fR
の前の部分は、コマンドラインで指定されたrefnameです(したがって、
\fBgit log \-g refs/heads/master\fR
は
\fBrefs/heads/master@{0}\fR
を生成します)。
.RE
.PP
\fB%gd\fR
.RS 4
短縮されたreflogセレクター。
\fB%gD\fR
と同じですが、 人間が読みやすいようにrefname部分が短縮されています(したがって、
\fBrefs/heads/master\fR
は単に
\fBmaster\fR
になります)。
.RE
.PP
\fB%gn\fR
.RS 4
reflog ID名
.RE
.PP
\fB%gN\fR
.RS 4
reflog ID名( \&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%ge\fR
.RS 4
reflog ID 電子メールアドレス
.RE
.PP
\fB%gE\fR
.RS 4
reflog ID 電子メールアドレス( \&.mailmap に関しては
\fBgit-shortlog\fR(1)
または
\fBgit-blame\fR(1)
参照)
.RE
.PP
\fB%gs\fR
.RS 4
reflog 件名
.RE
.PP
\fB%(trailers[:options])\fR
.RS 4
\fBgit-interpret-trailers\fR(1)
によって解釈されるようにボディのトレーラーを表示します。
\fBtrailers\fR
文字列の後には、コロンと0個以上のカンマ区切りオプションを続けることができます。いずれかのオプションが複数回提供された場合、それぞれ最後のものが優先されます。
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBkey=<key>\fR: 指定された <key> を持つトレーラーのみを表示します。マッチングは大文字と小文字を区別せずに行われ、末尾のコロンはオプションです。オプションが複数回指定されている場合、いずれかのキーに一致するトレーラー行が表示されます。このオプションは自動的に
\fBonly\fR
オプションを有効にして、トレーラーブロック内の非トレーラー行が非表示になるようにします。それが望ましくない場合は、
\fBonly=false\fR
で無効にすることができます。 たとえば、
\fB%(trailers:key=Reviewed\-by)\fR
は、キーが `Reviewed\-by`のトレーラー行を表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBonly[=<bool>]\fR: トレーラーブロックに非トレーラー行を含めるかどうかを選択します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBseparator=<sep>\fR: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラー行は改行文字で終了します。文字列 <sep> には、上記のリテラルフォーマットコードが含まれる場合があります。区切り文字としてコンマを使用するには、次のオプションとして解析されないよう
\fB%x2C\fR
を使用する必要があります。 たとえば、
\fB%(trailers:key=Ticket,separator=%x2C )\fR
は、キーが
\fBTicket\fR
であるすべてのトレーラー行をカンマとスペースで区切って表示します。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBunfold[=<bool>]\fR: interpret\-trailer の
\fB\-\-unfold\fR
オプションが指定されたかのように動作させます。たとえば、
\fB%(trailers:only,unfold=true)\fR
が展開され、すべてのトレーラー行が表示されます。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBkeyonly[=<bool>]\fR: トレーラーのキー部分のみを表示。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBvalueonly[=<bool>]\fR: トレーラーの値部分のみ表示。
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBkey_value_separator=<sep>\fR: トレーラー行の間に挿入される区切り文字を指定します。このオプションが指定されていない場合、各トレーラーのキーと値のペアは ": " で区切られます。 それ以外の場合は、上記の
\fBseparator=<sep>\fR
と同じセマンティクスを共有します。
.RE
.RE
.RE
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
一部のプレースホルダーは、リビジョントラバーサルエンジンに指定された他のオプションに依存する場合があります。 たとえば、 \fB%g*\fR reflogオプションは、reflogエントリをトラバースしない限り(たとえば、 \fBgit log \-g\fR によって)空の文字列を挿入します。コマンドラインで \fB\-\-decorate\fR がまだ指定されていない場合、 \fB%d\fR と \fB%D\fR プレースホルダーは「短い」(short)装飾形式を使用します。
.sp .5v
.RE
.sp
ブール値オプションは、オプションの値 \fB[=<bool\-value>]\fR を受け入れます。 値 \fBtrue\fR 、\fBfalse\fR 、 \fBon\fR 、\fBoff\fR などはすべて受け入れられます。 \fBgit-config\fR(1) の "EXAMPLES" の "boolean" サブセクションを参照してください。ブール値オプションが値なしで指定された場合、それは有効を指定した事になります。
.sp
プレースホルダーの \fB%\fR の後に \fB+\fR (プラス記号)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。
.sp
プレースホルダーの \fB%\fR の後に \fB\-\fR (マイナス記号)を追加すると、プレースホルダーが空の文字列に展開された場合にのみ、展開の直前の連続するすべての改行が削除されます。
.sp
プレースホルダーの \fB%\fR の後に " " (スペース)を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前にスペースが挿入されます。
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBtformat:\fR
.sp
\fBtformat:\fR
形式は、 "separator" セマンティクスの代わりに "terminator" セマンティクスを提供することを除いて、
\fBformat:\fR
とまったく同じように機能します。 つまり、各コミットには、エントリ間に区切り文字を配置するのではなく、メッセージターミネータ文字(通常は改行)が追加されます。 これは、「1行」形式と同様に、1行形式の最終エントリが新しい行で適切に終了することを意味します。 例えば:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=format:%h 4da45bef \e
  | perl \-pe \*(Aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\*(Aq
4da45be
7134973 \-\- NO NEWLINE

$ git log \-2 \-\-pretty=tformat:%h 4da45bef \e
  | perl \-pe \*(Aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\*(Aq
4da45be
7134973
.fi
.if n \{\
.RE
.\}
.sp
加えて、
\fB%\fR
が含まれている認識されない文字列は、その前に
\fBtformat:\fR
があるかのように解釈(interpret)されます。 たとえば、以下の2つは同等です:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=tformat:%h 4da45bef
$ git log \-2 \-\-pretty=%h 4da45bef
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "EXAMPLES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
現在のブランチから到達可能なコミットのリストを出力します。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list HEAD
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
このブランチのコミットのリストを出力しますが、アップストリームブランチのは表示しません。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list @{upstream}\&.\&.HEAD
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
作者(author)とコミットメッセージを使用してコミットをフォーマットします(磁器コマンドの\fBgit-log\fR(1)も参照)。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list \-\-format=medium HEAD
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
コミットとその差分をフォーマットします(これを単一のプロセスで実行できる磁器コマンドの\fBgit-log\fR(1)も参照してください)。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list HEAD |
git diff\-tree \-\-stdin \-\-format=medium \-p
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
現在のブランチで、`Documentation`ディレクトリ内のファイルに関連(touch)したコミットのリストを出力します。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list HEAD \-\- Documentation/
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
任意のブランチ・タグ・\m[blue]\fB他のrefから過去1年間に作者you@example\&.comが作成したコミットのリストを出力します\fR\m[]\&\s-2\u[1]\d\s+2。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list \-\-author=you@example\&.com \-\-since=1\&.year\&.ago \-\-all
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
現在のブランチから到達可能なオブジェクトのリストを出力します(つまり、すべてのコミットと、それらに含まれるブロブとツリー)。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list \-\-objects HEAD
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
到達可能なすべてのオブジェクトのディスクサイズ、reflogから到達可能なオブジェクト、およびパックされた合計サイズを比較します。これにより、`git repack \-ad`を実行すると(到達不能なオブジェクトを削除することで)リポジトリのサイズが減少するかどうか、およびreflogの有効期限が切れる(expire)ことによってリポジトリのサイズ減少に役立つかどうかがわかります。
.sp
.if n \{\
.RS 4
.\}
.nf
# reachable objects
git rev\-list \-\-disk\-usage \-\-objects \-\-all
# plus reflogs
git rev\-list \-\-disk\-usage \-\-objects \-\-all \-\-reflog
# total disk size used
du \-c \&.git/objects/pack/*\&.pack \&.git/objects/??/*
# alternative to du: add up "size" and "size\-pack" fields
git count\-objects \-v
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
現在のブランチで使用されているオブジェクトを除いて、各ブランチのディスクサイズを報告します。 これにより、リポジトリサイズの肥大化の原因となっているイレギュラー値を見つけることができます(たとえば、誰かが誤って大きなビルドアーティファクトをコミットしたためとか)。
.sp
.if n \{\
.RS 4
.\}
.nf
git for\-each\-ref \-\-format=\*(Aq%(refname)\*(Aq |
while read branch
do
        size=$(git rev\-list \-\-disk\-usage \-\-objects HEAD\&.\&.$branch)
        echo "$size $branch"
done |
sort \-n
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
(別のグループを除いた)refsの単一のグループのブランチのディスク上のサイズを比較します。1つのリポジトリに複数のリモートからのオブジェクトを混在させる場合、これにより、リポジトリ内で、どのリモートがどれだけ占めているかを示すことができます(`origin`のサイズを基準値として使用)。
.sp
.if n \{\
.RS 4
.\}
.nf
git rev\-list \-\-disk\-usage \-\-objects \-\-remotes=$suspect \-\-not \-\-remotes=origin
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
他のrefから過去1年間に作者you@example.comが作成したコミットのリストを出力します
.RS 4
\%mailto:他のrefから過去1年間に作者you@example.comが作成したコミットのリストを出力します
.RE
