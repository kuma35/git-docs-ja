<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.1.1" />
<title>Fighting regressions with git bisect</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Fighting regressions with git bisect</h1>
<span id="author">Christian Couder &lt;chriscool@tuxfamily.org&gt; 2009/11/08</span><br />
<span id="revdate">2023-10-17</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph"><p>「git bisect」を使用すると、ソフトウェアユーザーと開発者はデグレ(regression)を引き起こしたコミットを簡単に見つけることができます。 デグレと戦うための優れたツールが重要である理由を示します。 「git bisect」がどのように機能するか、および内部で使用するアルゴリズムについて説明します。 それから、「git bisect」を利用して現在の慣行を改善する方法を説明します。 また、「git bisect」が将来どのように改善されるかについて議論します。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction_to_git_bisect">Introduction to "git bisect"</h2>
<div class="sectionbody">
<div class="paragraph"><p>Gitは、Linus Torvaldsによって作成され、濱野 純(Junio Hamano)によって維持されている分散バージョン管理システム(DVCS;Distributed Version Control system)です。</p></div>
<div class="paragraph"><p>Gitでは、他の多くのバージョン管理システム(VCS)と同様に、システムによって管理されるデータのさまざまな状態をコミットと呼びます。 また、VCSは主にソフトウェアのソースコードを管理するために使用されるため、一部のコミットには、ソフトウェアの振る舞いに関して「興味ある」変更が導入されることがあります。</p></div>
<div class="paragraph"><p>実際には、人々はバグやデグレ(regression)と呼ばれる「悪い」(bad)振る舞いをもたらすコミットに特に興味を持っています。 コミットには(うまくすれば)ソースコードの変更の非常に小さな組が含まれているため、彼らはこれらコミットに興味を持っています。そして、そもそもどこを見ているのかわからないときより、非常に小さな変更セットをチェックするだけでよいならば、問題を理解して適切に修正する方がはるかに簡単です。</p></div>
<div class="paragraph"><p>そこで、人々が「悪い」(bad)振る舞いをもたらすコミットを見つけるのを助けるために、「git bisect」コマンドセットが発明されました。 そしてもちろん、「git bisect」の用語では、「興味深い動作」が存在するコミットは「bad」コミットと呼ばれ、他のコミットは「good」コミットと呼ばれます。 そして、私たちが興味を持っている振る舞いを紹介するコミットは「最初のbadコミット」と呼ばれます。 注意: 私達が探索しているコミット空間に複数の「最初のbadコミット」が存在する可能性があることに注意してください。</p></div>
<div class="paragraph"><p>したがって、「gitbisect」は「最初のbadコミット」を見つけるのに役立つように設計されています。 そして、可能な限り効率的にするために、それは二分木探索(binary search)を実行しようとします。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_fighting_regressions_overview">Fighting regressions overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_regressions_a_big_problem">Regressions: a big problem</h3>
<div class="paragraph"><p>デグレ(regressions)は、ソフトウェア業界では大きな問題です。 しかし、その実態を知るのは困難です。</p></div>
<div class="paragraph"><p>2002年のNIST(訳注:アメリカ連邦標準・技術局)の調査 <a href="#1">[1]</a> のように、一般的なバグについてはいくつかの数字があります:</p></div>
<div class="quoteblock">
<div class="content">新たに発表された商務省国立標準技術研究所(NIST)委託の調査によると、ソフトウェアのバグまたはエラーは非常に蔓延しており、非常に有害であるため、米国経済に年間推定595億ドル、つまり国内総生産の約0.6%のコストがかかっています。 米国全土レベルでは、コストの半分以上はソフトウェアユーザーが負担し、残りはソフトウェア 開発者/ベンダー が負担します。この調査では、すべてのエラーを削除することはできませんが、ソフトウェアの欠陥をより早く、より効果的に特定して削除できるようにするテストインフラストラクチャを改善することで、これらのコストの3分の1以上、つまり推定222億ドルを削減できることもわかりました。これらは、エラーが発生する開発段階に近いエラーの割合の増加(しかし、100%ではない)を見つけることに関連する節約です。現在、すべてのエラーの半分以上は、開発プロセスの「ダウンストリーム」または販売後のソフトウェアの使用中まで見つかりません。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>そして</p></div>
<div class="quoteblock">
<div class="content">ソフトウェア開発者はすでに開発コストの約80%を欠陥の特定と修正に費やしているものの、ソフトウェア以外のタイプの製品には、このような高レベルのエラーが含まれているものはほとんどありません。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>つまり結論としては:</p></div>
<div class="quoteblock">
<div class="content">より高いソフトウェア品質への道筋は、大幅に改善されたソフトウェアテストです。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>ソフトウェアに関連するコストの80%はメンテナンスに関するものであるという見積もりもあります(<a href="#2">[2]</a>)。</p></div>
<div class="paragraph"><p>しかしながら、ウィキペディア(<a href="#3">[3]</a>)によると:</p></div>
<div class="quoteblock">
<div class="content">メンテナンスに対する一般的な認識は、単にバグを修正しているだけ、というものです。しかし、長年にわたる調査と調査によると、保守作業の80%以上は、非修正アクションに使用されています(Pigosky1997)。 このような認識は、実際にはシステムの機能拡張である問題レポートをユーザーが提出することによって広まっています。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>しかし、デグレに注意する必要があるため、既存のソフトウェアの改善には非常にコストがかかると推測できます。 少なくとも、これは上記の研究結果と整合しています。</p></div>
<div class="paragraph"><p>もちろん、ある種のソフトウェアが開発され、それからしばらくの間、あまり改善されることなく使用され、そして最終的に捨てられます。 もちろん、この場合、デグレは大きな問題ではないかもしれません。 しかしその一方で、多くの人々によって何年も、あるいは何十年もの間継続的に開発され維持されている大きなソフトウェアがたくさんあります。 そして、そのようなソフトウェアに(時には深刻に)依存する人がしばしばいるので、デグレは本当に大きな問題です。</p></div>
<div class="paragraph"><p>そのようなソフトウェアの1つがLinuxカーネルです。 Linuxカーネルを見ると、デグレと戦うために多くの時間と労力が費やされていることがわかります。 リリースサイクルは、2週間のマージウィンドウから始まります。 次に、最初のリリース候補(rc)バージョンにタグが付けられます。 その後、最終リリースの前に、さらに約7または8個のrcバージョンが表示され、それぞれの間に約1週間かかります。</p></div>
<div class="paragraph"><p>最初のrcリリースから最終リリースまでの時間は、rcバージョンをテストし、バグ、特にデグレと戦うために使用されることになっています。 そして、この時間はリリースサイクル時間の80%以上です。 しかし、これはまだ戦いの終わりではなく、もちろん、リリース後も続くのです。</p></div>
<div class="paragraph"><p>そして、Ingo Molnar(有名なLinuxカーネル開発者)は git bisect の使用についてこう言っています:</p></div>
<div class="quoteblock">
<div class="content">私はマージウィンドウで最も積極的に使用します(多くのツリーが上流でマージされ、バグの流入が最も多い場合)。ええ、1日に複数回使用する場合があります。 私の平均はおおよそ1日1回です。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>つまり、開発者は常にデグレと戦っています。実際、バグが見つかったらすぐに修正する必要があることはよく知られています。 そのため、この目的のための優れたツールがあるのは興味深いことです。</p></div>
</div>
<div class="sect2">
<h3 id="_other_tools_to_fight_regressions">Other tools to fight regressions</h3>
<div class="paragraph"><p>では、デグレと戦うために使用されるツールは何ですか？ それらは、通常のバグと戦うために使用されるものとほぼ同じです。 唯一の特定のツールは、テストスイートと「git bisect」に似たツールです。</p></div>
<div class="paragraph"><p>テストスイートはとても素晴らしいものです。しかし、テストスイートを単独で使用する場合、コミットごとにすべてのテストをチェックするように使用することが前提となっています。つまり、テストスイートはあまり効率的ではないということです。なぜなら、多くのテストが何の面白みもない結果を得るために実行され、組み合わせの爆発に悩まされるからです。</p></div>
<div class="paragraph"><p>実際問題として、大きなソフトウェアには多くの異なる構成オプションがあり、各コミット後に各テストケースが各構成に合格する必要があることです。 したがって、リリースごとに N個の構成、M個のコミット、T個のテストケース がある場合は、あなたは以下のように行うべきです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>N * M * T tests</code></pre>
</div></div>
<div class="paragraph"><p>ここで、NとMとTはすべて、あなたのソフトウェアのサイズとともに成長します。</p></div>
<div class="paragraph"><p>そのため、すぐに全てを完全にテストすることはできなくなります。</p></div>
<div class="paragraph"><p>また、いくつかのバグがあなたのテストスイートをすり抜けた場合は、テストスイートにテストを追加できます。 しかし、新しく改善されたテストスイートを使用してバグが発生した場所を見つけたい場合は、bisectプロセスをエミュレートするか、「bad」コミットから始めて、各コミットを逆方向に愚直ににテストする必要があります。すげー無駄です。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_bisect_overview">"git bisect" overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_starting_a_bisection">Starting a bisection</h3>
<div class="paragraph"><p>使用する最初の「git bisect」サブコマンドは、探索を開始するための「git bisect start」です。 次に、コミット空間を制限するために境界を設定する必要があります。 これは通常、1つの「bad」コミットと、少なくとも1つの「good」コミットを与えることによって行われます。 これらは、以下のように「git bisect start」への最初の呼び出しで渡すことができます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start [BAD [GOOD...]]</code></pre>
</div></div>
<div class="paragraph"><p>または、以下を使用して設定できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect bad [COMMIT]</code></pre>
</div></div>
<div class="paragraph"><p>かつ</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect good [COMMIT...]</code></pre>
</div></div>
<div class="paragraph"><p>ここで、BAD と GOOD と COMMIT はすべて、コミットに解決できる名前です。</p></div>
<div class="paragraph"><p>次に、「git bisect」は選択したコミットをチェックアウトし、以下のようにユーザーにテストを依頼します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start v2.6.27 v2.6.25
Bisecting: 10928 revisions left to test after this (roughly 14 steps)
[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit</code></pre>
</div></div>
<div class="paragraph"><p>注意: 使用する例は実際には単純化モデル(toy example)であることに注意してください。「2.6.26-something」のようなバージョンを持つ最初のコミット、つまりトップレベルのMakefileに「SUBLEVEL = 26」行が含まれるコミットを探します。 「git bisect」を使用するよりも、Gitでこのコミットを見つけるためのより良い方法(たとえば、 <code>git blame</code> や <code>git log -S&lt;string&gt;</code> )があるため、これは単純化モデル(toy example)です。</p></div>
</div>
<div class="sect2">
<h3 id="_driving_a_bisection_manually">Driving a bisection manually</h3>
<div class="paragraph"><p>この時点では、探索を実行する方法は基本的には2つです。 ユーザーが手動で駆動するか、あるいは、スクリプトまたはコマンドで自動的に駆動することができます。</p></div>
<div class="paragraph"><p>ユーザーが駆動している場合、探索の各ステップで、ユーザーは現在のコミットをテストし、 <code>git bisect good</code> または <code>git bisect bad</code> コマンドを使用して「good」か「bad」かを言う必要があります。それぞれ上記で説明されています。 例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect bad
Bisecting: 5480 revisions left to test after this (roughly 13 steps)
[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file-&gt;f_count abuse in kvm</code></pre>
</div></div>
<div class="paragraph"><p>そして、このようないくつかのステップの後、 <code>git bisect</code> は最終的に最初のbadコミットを見つけます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect bad
2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Author: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Date:   Sat May 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

:100644 100644 5cf82581... 4492984e... M      Makefile</code></pre>
</div></div>
<div class="paragraph"><p>この時点で、コミットが何をするかを確認したり、チェックアウトしたり(まだチェックアウトされていない場合)、それをいじくり回したりできます。例えば以下のように:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git show HEAD
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Author: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Date:   Sat May 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

diff --git a/Makefile b/Makefile
index 5cf8258..4492984 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
-SUBLEVEL = 25
-EXTRAVERSION =
+SUBLEVEL = 26
+EXTRAVERSION = -rc1
 NAME = Funky Weasel is Jiggy wit it

 # *DOCUMENTATION*</code></pre>
</div></div>
<div class="paragraph"><p>終了したら、「git bisect reset」を使用して、bisectを開始する前のブランチに戻ることができます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect reset
Checking out files: 100% (21549/21549), done.
Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1
Switched to branch 'master'</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_driving_a_bisection_automatically">Driving a bisection automatically</h3>
<div class="paragraph"><p>bisectプロセスを駆動するもう1つの方法は、「git bisect」に、各bisectステップにてスクリプトまたはコマンドを起動して、現在のコミットが「good」か「bad」かを知るように指示することです。 これを行うには、「git bisect run」コマンドを使用します。 例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start v2.6.27 v2.6.25
Bisecting: 10928 revisions left to test after this (roughly 14 steps)
[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit
$
$ git bisect run grep '^SUBLEVEL = 25' Makefile
running grep ^SUBLEVEL = 25 Makefile
Bisecting: 5480 revisions left to test after this (roughly 13 steps)
[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file-&gt;f_count abuse in kvm
running grep ^SUBLEVEL = 25 Makefile
SUBLEVEL = 25
Bisecting: 2740 revisions left to test after this (roughly 12 steps)
[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s
...
...
running grep ^SUBLEVEL = 25 Makefile
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1
running grep ^SUBLEVEL = 25 Makefile
2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Author: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Date:   Sat May 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

:100644 100644 5cf82581... 4492984e... M      Makefile
bisect run success</code></pre>
</div></div>
<div class="paragraph"><p>この例では、「git bisect run」のパラメーターとして `grep <em>^SUBLEVEL = 25</em> Makefile`を渡しました。 これは、各ステップで、渡したgrepコマンドが起動されることを意味します。 そして、それがコード0で終了する場合(つまり成功を意味します)、 git bisectは現在の状態を「good」としてマークします。 コード1(または特別なコード125を除く1から127までのコードが含まれている)で終了した場合、現在の状態は「bad」としてマークされます。</p></div>
<div class="paragraph"><p>128〜255の終了コードは、「git bisect run」に固有のものです。 これらはbisectプロセスを即座に停止(stop)させます。 これは、渡されたコマンドが完了するまでに時間がかかりすぎる場合などに有効で、シグナルでkillすればbisectプロセスを停止させることができるからです。</p></div>
<div class="paragraph"><p>また、非常に異常な状況が検出された場合に、「git bisect run」から「exit 255」に渡されるスクリプトでも役立ちます。</p></div>
</div>
<div class="sect2">
<h3 id="_テスト不可能なコミットの回避">テスト不可能なコミットの回避</h3>
<div class="paragraph"><p>時々、現在の状態をテストできないことがあります。たとえば、その時点でコンパイルを妨げるバグがあったためにコンパイルされない場合です。 これが、特別な終了コード125の目的です。 「git bisect run」に、現在のコミットをテスト不可としてマークし、別のコミットを選択してチェックアウトする必要があることを通知します。</p></div>
<div class="paragraph"><p>bisectプロセスを手動で実行する場合は、「git bisect skip」を使用して同じことを行うことができます。 (実際、特別な終了コード125により、「git bisect run」はバックグラウンドで「git bisect skip」を使用します。)</p></div>
<div class="paragraph"><p>または、より詳細な制御が必要な場合は、たとえば「git bisect visualize」を使用して現在の状態を調べることができます。 より適切な二等分点を見つけるのに役立つgitk(または <code>DISPLAY</code> 環境変数が設定されていない場合は「git log」)を起動します。</p></div>
<div class="paragraph"><p>いずれにせよ、一連のテスト不可能なコミットがある場合、探しているデグレが、これらのテスト不可能なコミットの1つによって導入された可能性があります。 この場合、どのコミットがデグレを導入したかを確実に知ることはできません。</p></div>
<div class="paragraph"><p>したがって、「git bisect skip」(または実行スクリプトが特別なコード125で終了)を使用した場合、以下のような結果が得られる可能性があります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>There are only 'skip'ped commits left to test.
The first bad commit could be any of:
15722f2fa328eaba97022898a305ffc8172db6b1
78e86cf3e850bd755bb71831f42e200626fbd1e0
e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace
070eab2303024706f2924822bfec8b9847e4ac1b
We cannot bisect more!</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_saving_a_log_and_replaying_it">Saving a log and replaying it</h3>
<div class="paragraph"><p>他の人にあなたのbisectプロセスを見せたい場合は、例えば以下を使用してログを取得できます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect log &gt; bisect_log.txt</code></pre>
</div></div>
<div class="paragraph"><p>そして、これを使用して以下のようにリプレイすることが可能です:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect replay bisect_log.txt</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_bisect_details">"git bisect" details</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bisection_algorithm">Bisection algorithm</h3>
<div class="paragraph"><p>Gitコミットは有向非巡回グラフ(DAG)を形成するため、各ステップでテストするのに最適な二等分コミットを見つけることはそれほど簡単ではありません。 とにかく、Linusは、後に濱野 純(Junio Hamano)によって改良された「本当にばかげた」(truly stupid)アルゴリズムを見つけて実装しました。これは非常にうまく機能します。</p></div>
<div class="paragraph"><p>スキップされたコミットがない場合に最適な二等分コミットを見つけるために「git bisect」によって使用されるアルゴリズムは以下のとおり:</p></div>
<div class="paragraph"><p>1) 以下のコミットのみを保持します:</p></div>
<div class="paragraph"><p>a) 「bad」コミットの祖先(「bad」コミット自体を含む)
b) 「good」コミットの祖先では無い(「good」コミット自体を除く)</p></div>
<div class="paragraph"><p>これは、DAGで興味のないコミット(uninteresting commits)を取り除くことを意味します。</p></div>
<div class="paragraph"><p>たとえば、以下のようなグラフから始める場合:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>G-Y-G-W-W-W-X-X-X-X
           \ /
            W-W-B
           /
Y---G-W---W
 \ /   \
Y-Y     X-X-X-X

-&gt; time goes this way -&gt;</code></pre>
</div></div>
<div class="paragraph"><p>ここで、Bは「bad」コミットで、「G」は「good」コミットで、WとXとYはその他のコミットです。この最初のステップ後、私達は以下のグラフを得ます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>W-W-W
     \
      W-W-B
     /
W---W</code></pre>
</div></div>
<div class="paragraph"><p>WコミットとBコミットのみが保持されます。 コミットXとYはそれぞれ ルール a）と ルール b）によって削除され、コミットGも ルール b）によって削除されるためです。</p></div>
<div class="paragraph"><p>注意: Gitユーザーの場合、以下のコマンドによって与えられたコミットのみを保持することと同等であることに注意してください:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>git rev-list BAD --not GOOD1 GOOD2...</code></pre>
</div></div>
<div class="paragraph"><p>また、保持するコミットは「good」コミットの子孫である必要はないことに注意しましょう。つまり、以下の例では、コミット W と Z が保持されます。</p></div>
<div class="listingblock">
<div class="content">
<pre><code>G-W-W-W-B
   /
Z-Z</code></pre>
</div></div>
<div class="paragraph"><p>2) グラフの「good」端から始めて、各コミットに、それが持っている祖先の数に1を加えた数を関連付けます</p></div>
<div class="paragraph"><p>たとえば、以下のグラフでは、Hは「bad」コミットであり、AとDはいくつかの「good」コミットの親です:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>A-B-C
     \
      F-G-H
     /
D---E</code></pre>
</div></div>
<div class="paragraph"><p>これには以下のように数が与えられます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>1 2 3
A-B-C
     \6 7 8
      F-G-H
1   2/
D---E</code></pre>
</div></div>
<div class="paragraph"><p>3) 各コミットの相関: min(X, N - X)</p></div>
<div class="paragraph"><p>ここで、X はステップ 2）のコミットに関連付けられた値であり、N はグラフ内のコミットの総数です。</p></div>
<div class="paragraph"><p>上記の例では、<code>N = 8</code> であるため、以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>1 2 3
A-B-C
     \2 1 0
      F-G-H
1   2/
D---E</code></pre>
</div></div>
<div class="paragraph"><p>4) 最適な二等分点は、相関値が最も大きいコミットです</p></div>
<div class="paragraph"><p>したがって、上記の例では、最良の二等分点はコミットCです。</p></div>
<div class="paragraph"><p>5) 注意: アルゴリズムを高速化するためにいくつかのショートカットが実装されていることに注意してください</p></div>
<div class="paragraph"><p>最初からNを知っているので、 <code>min(X, N - X)</code> は <code>N/2</code> より大きくなることはできないことがわかります。 したがって、ステップ 2）と ステップ 3）で、 <code>N/2</code> をコミットに関連付ける場合、これが最良の二等分点であることがわかります。 したがって、この場合、他のコミットの処理を停止して、現在のコミットを返すことができます。</p></div>
</div>
<div class="sect2">
<h3 id="_bisection_algorithm_debugging">Bisection algorithm debugging</h3>
<div class="paragraph"><p>どのコミットグラフでも、 <code>git rev-list --bisect-all</code> を使用して、各コミットの相関値を確認できます。</p></div>
<div class="paragraph"><p>たとえば、上のグラフの場合、以下のようなコマンド:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rev-list --bisect-all BAD --not GOOD1 GOOD2</code></pre>
</div></div>
<div class="paragraph"><p>は、以下のような出力になります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)
15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)
78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)
a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)
070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)
a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)
a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)
9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_bisection_algorithm_discussed">Bisection algorithm discussed</h3>
<div class="paragraph"><p>まず、「最良二等分点」を定義しましょう。あるコミットXの状態(「good」または「bad」)を与えることで、コミットの状態が「good」か「bad」かの情報が可能な限り多く得られる場合、私達はコミットXを最良二等分点または最良二等分コミットと呼ぶことにします。</p></div>
<div class="paragraph"><p>これは、最良の二等分コミットは、以下の関数の値が最大になるコミットであることを意味します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`f(X) = min(information_if_good(X), information_if_bad(X))`</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 <code>information_if_good(X)</code> は、Xがgoodな場合に取得する情報であり、 <code>information_if_bad(X)</code> は、Xがbadの場合に取得する情報です。</p></div>
<div class="paragraph"><p>ここで、私達は「最初のbadコミット」は1つだけであると想定します。 これは、そのすべての子孫が「bad」なとを意味し、他のすべてのコミットは「good」なことを意味します。 そして、すべてのコミットがgoodかbadか、または最初のbadコミットである確率が等しいと仮定します。 したがって、cコミットの状態を知ることで、これらのcコミットがグラフ上にある場合、およびcが何であれ、常に同じ量の情報が得られます。 (したがって、これらのコミットが、たとえばブランチ上にあるか、goodコミットまたはbadコミットの近くにあると、多かれ少なかれ情報が得られないと想定します)。</p></div>
<div class="paragraph"><p>また、上記のbisectアルゴリズムの ステップ 1）の後のようなクリーンアップされたグラフがあると仮定しましょう。 これは、グラフから削除できるコミット数の観点から取得した情報を測定できることを意味します。</p></div>
<div class="paragraph"><p>では、グラフでコミットXを見てみましょう。</p></div>
<div class="paragraph"><p>Xが「good」であることが判明した場合、その祖先はすべて「good」であることがわかっているので、あなたは以下のように言いたいと思います:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`information_if_good(X) = number_of_ancestors(X)`  (TRUE)</code></pre>
</div></div>
<div class="paragraph"><p>そして、これは真実です。なぜなら、ステップ1）の b）で、「good」コミットの祖先を削除するからです。</p></div>
<div class="paragraph"><p>Xが「bad」であることが判明した場合、その子孫はすべて「bad」であることがわかっているので、あなたは以下のように言いたいでしょう:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`information_if_bad(X) = number_of_descendants(X)`  (WRONG)</code></pre>
</div></div>
<div class="paragraph"><p>しかし、これは間違っています。なぜなら、ステップ 1）の a）では、badコミットの祖先だけを保持しているからです。 したがって、コミットが「bad」としてマークされると、より多くの情報が得られます。これは、新しい「bad」コミットの祖先ではない以前の「bad」コミットの祖先が最初のbadコミットではないこともわかっているためです。 それらがgoodかbadかはわかりませんが、新しい「bad」コミットの祖先ではないため、最初のbadコミットではないことはわかっています。</p></div>
<div class="paragraph"><p>したがって、コミットが「bad」としてマークされている場合、新しい「bad」コミットの祖先であるコミットを除いて、グラフ内のすべてのコミットを削除できることがわかります。 以下を意味します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`information_if_bad(X) = N - number_of_ancestors(X)`  (TRUE)</code></pre>
</div></div>
<div class="paragraph"><p>ここで、Nは (クリーンアップされた)グラフのコミット数です。</p></div>
<div class="paragraph"><p>つまり、これは最終的に、最適な二等分コミットを見つけるために、関数の値をを最大化する必要があることを意味します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))`</code></pre>
</div></div>
<div class="paragraph"><p>そして、これは素晴らしいことです。なぜなら、ステップ 2）で <code>number_of_ancestors(X)</code> を計算し、ステップ 3）で f(X) を計算するからです。</p></div>
<div class="paragraph"><p>例として以下のグラフを見てみましょう:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>            G-H-I-J
           /       \
A-B-C-D-E-F         O
           \       /
            K-L-M-N</code></pre>
</div></div>
<div class="paragraph"><p>その上で以下の非最適化関数を計算します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>g(X) = min(number_of_ancestors(X), number_of_descendants(X))</code></pre>
</div></div>
<div class="paragraph"><p>そうすると私達は以下の結果を得ます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>            4 3 2 1
            G-H-I-J
1 2 3 4 5 6/       \0
A-B-C-D-E-F         O
           \       /
            K-L-M-N
            4 3 2 1</code></pre>
</div></div>
<div class="paragraph"><p>しかし、git bisectで使用されるアルゴリズムを使用すると、以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>            7 7 6 5
            G-H-I-J
1 2 3 4 5 6/       \0
A-B-C-D-E-F         O
           \       /
            K-L-M-N
            7 7 6 5</code></pre>
</div></div>
<div class="paragraph"><p>私達は、GまたはHまたはKまたはLを最良の二等分点として選択しました。これは、Fよりも優れています。たとえばLがbadの場合、LとMとNがbadなだけでなく、GとHとIとJは最初のbadコミットでは無いと分かるためです。(最初のbadコミットは1つだけであり、Lの祖先である必要があるため)。</p></div>
<div class="paragraph"><p>つまり、現在のアルゴリズムは、私達が最初に想定した限りにおいて最良のように見えます。</p></div>
</div>
<div class="sect2">
<h3 id="_skip_algorithm">Skip algorithm</h3>
<div class="paragraph"><p>(「git bisect skip」を使用して)一部のコミットがスキップされた場合、bisectアルゴリズムは ステップ 1）から ステップ 3）までは同じです。 ただし、それ以降は大まかに以下の手順を使用します:</p></div>
<div class="paragraph"><p>6) 関連値の降順でコミットを並べ替えます</p></div>
<div class="paragraph"><p>7) 最初のコミットがスキップされていない場合は、それを返してここで停止(stop)できます</p></div>
<div class="paragraph"><p>8) それ以外の場合は、ソートされたリストでスキップされたすべてのコミットを除外します</p></div>
<div class="paragraph"><p>9) 疑似乱数ジェネレーター(PRNG)を使用して、0〜1の乱数を生成します</p></div>
<div class="paragraph"><p>10) この乱数に平方根を乗じて0に偏らせます</p></div>
<div class="paragraph"><p>11) 結果に、フィルターされたリスト内のコミット数を乗じて、このリストへのインデックスを取得します</p></div>
<div class="paragraph"><p>12) 計算されたインデックスでコミットを返します</p></div>
</div>
<div class="sect2">
<h3 id="_skip_algorithm_discussed">Skip algorithm discussed</h3>
<div class="paragraph"><p>(skip algorithmの）ステップ 7）の後、2番目のコミットがスキップされたかどうかを確認し、スキップされていない場合はそれを返すことができます。 実際、これは、「git bisect skip」がGitバージョン1.5.4(2008年2月1日リリース)で開発されてからGitバージョン1.6.4(2009年7月29日リリース)まで使用したアルゴリズムでした。</p></div>
<div class="paragraph"><p>しかし、Ingo MolnarとH.Peter Anvin(別の有名なLinuxカーネル開発者)は両方とも、全コミットがテスト不能な領域内にすべての最良の二等分点がたまたまあると不満を漏らしました。 そしてこの場合、ユーザーは多くのテスト不能なコミットをテストするように求めらますが、これは非常に非効率的である可能性があります。</p></div>
<div class="paragraph"><p>実際、一度破損が発生した後、他の多くのコミットが導入された後にのみ破損が修正されたため、テスト不能なコミットはテストできないことがよくあります。</p></div>
<div class="paragraph"><p>もちろん、こういう破損は、ほとんどの場合、私達がコミットグラフで見つけようとしている破損とは無関係です。 しかし、それは私たちが興味深い「bad振る舞い」が存在するかどうかを知ることを妨げます。</p></div>
<div class="paragraph"><p>したがって、テスト不能なコミットの近くのコミットは、それ自体がテスト不能である可能性が高いのは事実です。 そして、最良の二等分コミットも一緒に見つかることがよくあります(二分アルゴリズムのため)。</p></div>
<div class="paragraph"><p>これが、最初のコミットがスキップされたときに、次に最適なスキップされていない二等分コミットを選択するのは悪い考えである理由です。</p></div>
<div class="paragraph"><p>グラフ上のほとんどのコミットは、テスト時にかなり多くの情報を提供する可能性があることがわかりました。 そして、平均して、多くの情報を提供しないコミットは、goodコミットとbadコミットに近いものです。</p></div>
<div class="paragraph"><p>したがって、goodコミットとbadコミットから離れてコミットを優先するバイアスのあるPRNGを使用することは、良い選択のように見えました。</p></div>
<div class="paragraph"><p>このアルゴリズムの明らかな改善点の1つは、PRNGを使用する前に、最良の二等分コミットの1つに近い値が関連付けられ、別のブランチにあるコミットを探すことです。 そのようなコミットが存在する場合、それもテストできない可能性は非常に低いため、ほぼランダムに選択されたものよりも多くの情報が提供される可能性があります。</p></div>
</div>
<div class="sect2">
<h3 id="_checking_merge_bases">Checking merge bases</h3>
<div class="paragraph"><p>上記の「二分アルゴリズム」で説明されていない二分アルゴリズムの別の微調整があります。</p></div>
<div class="paragraph"><p>前の例では、「good」コミットは「bad」コミットの祖先であると想定していました。 しかし、これは「git bisect」の要件ではありません。</p></div>
<div class="paragraph"><p>もちろん、「bad」コミットは「good」コミットの祖先になることはできません。goodコミットの祖先は「good」と想定されているからです。 そして、すべての「good」コミットはbadコミットに関連している必要があります。 「bad」コミットのブランチとのリンクがないブランチに配置することはできません。 しかし、goodコミットがbadコミットに関連していても、その祖先でも子孫でもない可能性があります。</p></div>
<div class="paragraph"><p>たとえば、「main」ブランチと、以下のように「D」という名前のコミットでmainブランチから分岐した「dev」ブランチが存在する可能性があります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>A-B-C-D-E-F-G  &lt;--main
       \
        H-I-J  &lt;--dev</code></pre>
</div></div>
<div class="paragraph"><p>コミット「D」は、ブランチ「main」および「dev」の「マージベース」と呼ばれます。それは、これらのブランチがマージするための最も一般的な祖先であるためです。</p></div>
<div class="paragraph"><p>ここで、コミットJがbadで、コミットGがgoodであり、前述のように二分アルゴリズムを適用するとします。</p></div>
<div class="paragraph"><p>二分アルゴリズムの ステップ 1）の b）で説明したように、goodコミットのすべての祖先もgoodであると想定されているため、それらをすべて削除します。</p></div>
<div class="paragraph"><p>したがって、以下のものだけが残ります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>H-I-J</code></pre>
</div></div>
<div class="paragraph"><p>しかし、最初のbadコミットが「B」であり、コミット「F」によって「main」ブランチで修正された場合はどうなりますか？</p></div>
<div class="paragraph"><p>このようなbisectの結果は、Hが最初のbadコミットであると探索します。しかし実際にはBです。つまり、これは間違いです！</p></div>
<div class="paragraph"><p>そして、実際には、あるブランチで作業している人は、別のブランチで作業している人がバグを修正したことに気付いていないことがあります。 また、Fが複数のバグを修正した場合や、リリースに間に合わなかった大きな開発努力の戻し(revert)であることもあり得ます。</p></div>
<div class="paragraph"><p>実際、開発チームは開発ブランチとメンテナンスブランチの両方を維持することが多く、メンテナンスブランチにない開発ブランチでデグレをbisectしたいときに「git bisect」が機能すれば非常に簡単です。 彼らは以下を使用してbisectを開始できるはずです:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start dev main</code></pre>
</div></div>
<div class="paragraph"><p>この追加機能を有効にするために、bisectを開始したときに、いくつかのgoodコミットがbadコミットの祖先でない場合、まずbadコミットとgoodコミットの間のマージベースを計算し、これらのマージベースをチェックアウトしてテストする最初のコミットとして選択するようにしています。</p></div>
<div class="paragraph"><p>1つのマージベースがbadである場合、bisectプロセスは以下のようなメッセージで停止します(訳注:マージベースBBBBBBがbadです。これは、BBBBBBと[GGGGGG,&#8230;]の間でバグが修正されたことを意味します):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>The merge base BBBBBB is bad.
This means the bug has been fixed between BBBBBB and [GGGGGG,...].</code></pre>
</div></div>
<div class="paragraph"><p>ここで、BBBBBBはbadなマージベースのsha1ハッシュであり、 [GGGGGG,&#8230;] はgoodなコミットのsha1のコンマ区切りのリストです。</p></div>
<div class="paragraph"><p>一部のマージベースがスキップされた場合、bisectプロセスは続行されますが、スキップされたマージベースごとに以下のメッセージが出力されます(訳注:…最初のbadなコミットがMMMMMMとBBBBBBの間であるかどうかを確認することはできません。とにかく続けます…):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Warning: the merge base between BBBBBB and [GGGGGG,...] must be skipped.
So we cannot be sure the first bad commit is between MMMMMM and BBBBBB.
We continue anyway.</code></pre>
</div></div>
<div class="paragraph"><p>ここで、BBBBBBはbadなコミットのsha1ハッシュ、MMMMMMはスキップされるマージベースのsha1ハッシュ、 [GGGGGG,&#8230;] はgoodなコミットのsha1のコンマ区切りのリストです。</p></div>
<div class="paragraph"><p>badなマージベースがない場合、このステップの後、bisectプロセスは通常どおり続行されます。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_best_bisecting_practices">Best bisecting practices</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_using_test_suites_and_git_bisect_together">Using test suites and git bisect together</h3>
<div class="paragraph"><p>テストスイートとgit bisectの両方がある場合、各コミット後にすべてのテストに合格することを確認することはそれほど重要ではなくなります。 もちろん、他のバグをbisectするのがより難しくなる可能性があるので、あまりにも多くのものを壊さないようにいくつかのチェックを行うことはおそらく良い考えです。</p></div>
<div class="paragraph"><p>すべてのテストケース(T) がすべての構成(N)に合格することを、いくつかのポイント(たとえば、rcおよびベータリリース)で確認することに集中できます。 また、一部のテストに合格しなかった場合は、「git bisect」(またはより適切な「git bisect run」)を使用できます。 したがって、ざっくり以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>c * N * T + b * M * log2(M) tests</code></pre>
</div></div>
<div class="paragraph"><p>ここで、cはテストのラウンド数(つまり小さな定数)であり、bはコミットごとのバグの比率(できれば小さな定数であって欲しい)です。</p></div>
<div class="paragraph"><p>したがって、もちろん、各コミット後にすべてをテストする場合は、O(N * T * M) に対して O(N * T) の方がはるかに優れています。</p></div>
<div class="paragraph"><p>これは、テストスイートがいくつかのバグのコミットを防ぐのに適していることを意味します。また、いくつかのバグがあることを通知するのにも非常に適しています。 しかし、いくつかのバグがどこに導入されたかを伝えるのはあまり良くありません。 それを効率的に伝えるには、git bisectが必要です。</p></div>
<div class="paragraph"><p>テストスイートのもう1つの優れた点は、テストスイートを持っている場合、badい振る舞いをテストする方法をすでに知っていることです。 したがって、この知識を使用して、デグレがあると思われる場合に「git bisect」の新しいテストケースを作成できます。 したがって、バグをbisectして修正する方が簡単です。 そしてそれから、作成したばかりのテストケースをテストスイートに追加できます。</p></div>
<div class="paragraph"><p>したがって、テストケースの作成方法とbisectする方法を知っている場合は、好循環になります:</p></div>
<div class="paragraph"><p>よりテストされる &#8658; テストの作成がより簡単になる &#8658; bisectするのがより簡単なる &#8658; よりテストされる</p></div>
<div class="paragraph"><p>したがって、テストスイートと「git bisect」は、一緒に使用すると非常に強力で効率的な補完ツールです。</p></div>
</div>
<div class="sect2">
<h3 id="_bisecting_build_failures">Bisecting build failures</h3>
<div class="paragraph"><p>以下のようなものを使用して、壊れたビルドを非常に簡単に自動的にbisectすることができます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start BAD GOOD
$ git bisect run make</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_passing_sh_c_some_commands_to_git_bisect_run">Passing sh -c "some commands" to "git bisect run"</h3>
<div class="paragraph"><p>例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect run sh -c "make || exit 125; ./my_app | grep 'good output'"</code></pre>
</div></div>
<div class="paragraph"><p>一方、これを頻繁に行う場合は、タイピングしまくらなくていいようにスクリプトを作成する価値があります。</p></div>
</div>
<div class="sect2">
<h3 id="_finding_performance_regressions">Finding performance regressions</h3>
<div class="paragraph"><p>これは、濱野 純(Junio Hamano) が使用する実際のスクリプトから少し変更されたスクリプトの例です <a href="#4">[4]</a> 。</p></div>
<div class="paragraph"><p>このスクリプトを「git bisect run」に渡して、パフォーマンスの低下を引き起こしたコミットを見つけることができます:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#!/bin/sh

# Build errors are not what I am interested in.
make my_app || exit 255

# We are checking if it stops in a reasonable amount of time, so
# let it run in the background...

./my_app &gt;log 2&gt;&amp;1 &amp;

# ... and grab its process ID.
pid=$!

# ... and then wait for sufficiently long.
sleep $NORMAL_TIME

# ... and then see if the process is still there.
if kill -0 $pid
then
        # It is still running -- that is bad.
        kill $pid; sleep 1; kill $pid;
        exit 1
else
        # It has already finished (the $pid process was no more),
        # and we are happy.
        exit 0
fi</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_一般的なベストプラクティスに従う">一般的なベストプラクティスに従う</h3>
<div class="paragraph"><p>他のコミットで後で破損を修正するにしても、意図的に物事を破損するような変更を加えたコミットを行わないのが明らかに良い考えです。</p></div>
<div class="paragraph"><p>また、VCSを使用して、各コミットで論理的な変更を1つだけ行うこともお勧めします。</p></div>
<div class="paragraph"><p>あなたのコミットの変更が小さいほど、最も効果的な「git bisect」になります。 また、小さな変更はコミッターによってのみレビューされる場合でもレビューしやすいため、そもそも「git bisect」の必要性は少なくなります。</p></div>
<div class="paragraph"><p>もう1つの良いアイデアは、適切なコミットメッセージを用意することです。 いくつかの変更が行われた理由を理解するのに非常に役立ちます。</p></div>
<div class="paragraph"><p>これらの一般的なベストプラクティスは、あなたが頻繁にbisectする場合に非常に役立ちます。</p></div>
</div>
<div class="sect2">
<h3 id="_avoiding_bug_prone_merges">Avoiding bug prone merges</h3>
<div class="paragraph"><p>最初のマージ自体は、マージがソースコードの競合解決を必要としない場合でも、いくつかのデグレを引き起こす可能性があります。 これは、一方のブランチでセマンティックの変更が発生する可能性がある一方で、もう一方のブランチはそれを認識していないためです。</p></div>
<div class="paragraph"><p>たとえば、一方のブランチが関数のセマンティクスを変更し、もう一方のブランチが同じ関数への呼び出しを追加する場合があります。</p></div>
<div class="paragraph"><p>競合を解決するために多くのファイルを修正する必要がある場合、これはさらに悪化します。 そのため、このようなマージは「悪のマージ」(evil merges)と呼ばれます。 それらは、デグレを追跡することを非常に困難にする可能性があります。 最初のbadコミットがそのようなマージである場合、それを知ることは誤解を招く可能性さえあります。なぜなら、バグは1つのブランチのセマンティック変更に起因する場合、競合解決が悪いことに起因すると考える可能性があるからです。</p></div>
<div class="paragraph"><p>とにかく、「git rebase」を使用して履歴を線形化できます。 これは、そもそもマージを回避するために使用できます。 または、非線形履歴の代わりに線形履歴をbisectするために使用できます。これにより、1つのブランチで意味が変更された場合に、より多くの情報が得られるはずです。</p></div>
<div class="paragraph"><p>長いバージョンに関連するブランチだけでなく、小さなブランチを使用するか、多くのトピックブランチを使用することで、マージを簡単にすることもできます。</p></div>
<div class="paragraph"><p>また、Linuxカーネルのlinux-nextのような特別な統合ブランチでテストをより頻繁に行うことができます。</p></div>
</div>
<div class="sect2">
<h3 id="_adapting_your_work_flow">Adapting your work-flow</h3>
<div class="paragraph"><p>デグレを処理するための特別なワークフローは、素晴らしい結果をもたらす可能性があります。</p></div>
<div class="paragraph"><p>ここで、 Andreas Ericsson が使用するワークフローの例を以下に示します:</p></div>
<div class="ulist"><ul>
<li>
<p>
テストスイートでは、デグレを明らかにするテストスクリプトを書きます
</p>
</li>
<li>
<p>
「git bisect run」を使用して、それを導入したコミットを見つけます
</p>
</li>
<li>
<p>
前ステップで明らかになることが多いバグを修正します
</p>
</li>
<li>
<p>
修正とテストスクリプトの両方をコミットします(必要に応じてさらにテストを行います)
</p>
</li>
</ul></div>
<div class="paragraph"><p>そして、以下が Andreas このワークフローについて言ったことです <a href="#5">[5]</a>:</p></div>
<div class="quoteblock">
<div class="content">具体的な数字を挙げると、以前は報告から修正までの平均サイクルが 142.6 時間でした((壁掛け時計の時間だけを計測する、ちょっと変わったバグトラッカーによるものです)。Gitに移行してからは、16.2時間まで短縮されました。これは主に、バグフィックスを怠らないようになったことと、誰もがバグフィックスに参加するようになったからです(私たちは、バグを見つけるのをいかにGitに任せて怠慢しているかを誇りに思っています)。新しいリリースのたびに、バグの数は40%ほど減っています(ほぼ間違いなく、私たちがテストを書くことにどう感じているかによるものです)。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>明らかに、このワークフローは、テストスイートと「git bisect」の間の好循環を利用しています。 実際、それはデグレに対処するための標準的な手順になります。</p></div>
<div class="paragraph"><p>他のメッセージで Andreas は、上記の「ベストプラクティス」も使用していると述べています。小さな論理コミット、トピックブランチ、悪意のないマージ(no evil merge)などです。これらのプラクティスはすべて、bisectをより簡単でより便利にすることによって、コミットグラフの二分探索性を改善します。</p></div>
<div class="paragraph"><p>したがって、上記の点を念頭に適切なワークフローを設計する必要があります。 これにより、bisectがより簡単に、より便利に、標準的になります。</p></div>
</div>
<div class="sect2">
<h3 id="_品質担当者と_可能であればエンドユーザーを巻き込む">品質担当者と、可能であればエンドユーザーを巻き込む</h3>
<div class="paragraph"><p>「git bisect」の良いところの1つは、それが開発者用のツールだけではないということです。 品質担当者、さらにはエンドユーザー(ソースコードにアクセスできる場合、またはすべてのビルドにアクセスできる場合)が効果的に使用できます。</p></div>
<div class="paragraph"><p>一時期、linuxのカーネルメーリングリストで、エンドユーザーに常にbisectを要求して良いのかという議論があり、良いという意見を支持する非常に良い指摘がありました。</p></div>
<div class="paragraph"><p>たとえば、 David Miller は以下のように書いています <a href="#6">[6]</a> :</p></div>
<div class="quoteblock">
<div class="content">人々が理解していないのは、これが「エンド・ノードの原則」(end node principle)が適用される状況であるということです。リソース（ここでは開発者）が限られている場合、開発者に負担の大部分を押し付けないようにします。その代わりに、多くのリソースを持っているエンドノード（ここではユーザー）に物事を押し付け、状況の大きさが実態の大きさに沿うようにするのです。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>これは、品質担当者またはエンドユーザーがそれを実行できる場合、多くの場合「安価」であることを意味します。</p></div>
<div class="paragraph"><p>また、興味深いのは、バグを報告しているエンドユーザー(またはバグを再現した品質担当者)が、バグが発生する環境にアクセスできることです。 そのため、多くの場合、デグレをより簡単に再現できます。 そして、bisectすることができれば、バグが発生した環境からより多くの情報が抽出されます。つまり、バグを理解して修正するのが簡単になります。</p></div>
<div class="paragraph"><p>オープンソースプロジェクトでは、エンドユーザーからより有益な貢献を得るための良い方法となり、品質管理や開発活動に導入することができます。</p></div>
</div>
<div class="sect2">
<h3 id="_using_complex_scripts">Using complex scripts</h3>
<div class="paragraph"><p>カーネル開発の場合のように、bisectを完全に自動化できるように複雑なスクリプトを開発する価値がある場合があります。</p></div>
<div class="paragraph"><p>Ingo Molnar はこれについて以下のように言っています <a href="#7">[7]</a>:</p></div>
<div class="quoteblock">
<div class="content">私は完全に自動化された起動時ハングアップ対応bisectスクリプトを持っています。 これは「git-bisect run」に基づいています。 スクリプトを実行すると、カーネルが完全に自動的にビルドおよび起動され、起動が失敗すると(スクリプトは、継続的に監視するシリアルログを介して、またはタイムアウトを介して、システムが10分以内に起動しない場合は 「bad」カーネルとします)、スクリプトはビープ音を介して私の注意を喚起し、テストボックスの電源を入れ直します。 （ええもちろん、それを100%自動化するためには、制御された電源コンセントを利用する必要があります)</div>
<div class="attribution">
</div></div>
</div>
<div class="sect2">
<h3 id="_combining_test_suites_git_bisect_and_other_systems_together">Combining test suites, git bisect and other systems together</h3>
<div class="paragraph"><p>テストスイートとgit bisectを一緒に使用すると、非常に強力であることがわかりました。 それらを他のシステムと組み合わせることができれば、さらに強力になる可能性があります。</p></div>
<div class="paragraph"><p>たとえば、一部のテストスイートは、いくつかの異常な(またはランダムな)構成で夜間に自動的に実行される可能性があります。 また、テストスイートでデグレが見つかった場合は、「git bisect」を自動的に起動し、その結果を「git bisect」で最初に見つかったbadなコミットの作成者や他の人にメールで送信できます。 また、バグ追跡システムの新しいエントリも自動的に作成される可能性があります。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_future_of_bisecting">The future of bisecting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_git_replace">"git replace"</h3>
<div class="paragraph"><p>「git bisect skip」は、PRNGを使用して、コミットがテストできないコミットグラフの領域を回避しようとしていることを以前に見ました。 問題は、最初のbadコミットがテストできない領域にある場合があることです。</p></div>
<div class="paragraph"><p>議論を単純化するために、テスト不能な領域はコミットの単純な文字列であり、あるコミットによって導入された破損によって作成され(bisect breaking commitの場合はBBCと呼びます)、後で別のコミットによって修正された(bisect fixing commitの場合はBFCと呼びます)と仮定します。</p></div>
<div class="paragraph"><p>例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...</code></pre>
</div></div>
<div class="paragraph"><p>ここで、Yはgoodで、BFCはbadであり、BBCと、X1〜X6はテストできません。</p></div>
<div class="paragraph"><p>この場合、手動でbisectする場合は、BBCの直前から始まる特別なブランチを作成することができます。 このブランチの最初のコミットは、BFCをつぶしたBBCになるはずです(squash)。 そしてブランチの他のコミットは、BBC と BFC の間のコミットをブランチの最初のコミットでリベースし、BFC の後のコミットもリベースしたものでなければなりません。</p></div>
<div class="paragraph"><p>例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'
     /
...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...</code></pre>
</div></div>
<div class="paragraph"><p>ここで、 &#8216;'` 付きの(X1&#8217;,X2',X3',X4',X5',X6',Z')がリベースされたコミットです。</p></div>
<div class="paragraph"><p>対話的リベースを使用して、Gitでこのようなブランチを簡単に作成できます。</p></div>
<div class="paragraph"><p>例えば以下のように使用します:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git rebase -i Y Z</code></pre>
</div></div>
<div class="paragraph"><p>そしてBBCの後にBFCを動かしてつぶし(squash)ます。</p></div>
<div class="paragraph"><p>その後、あなたは新しいブランチで通常どおりbisectを開始でき、最終的に最初のbadコミットを見つけるでしょう。</p></div>
<div class="paragraph"><p>例えば:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git bisect start Z' Y</code></pre>
</div></div>
<div class="paragraph"><p>「git bisect run」を使用している場合は、上記と同じ手動修正を使用してから、特別なブランチで別の「git bisect run」を開始できます。 または、「git bisect」のマニュアルページに記載されているように、「git bisect run」に渡されたスクリプトは、ソフトウェアをコンパイルしてテストする前にパッチを適用できます <a href="#8">[8]</a> 。 パッチは、現在のテスト不能なコミットをテスト可能なコミットに変える必要があります。 したがって、テストの結果は「good」または「bad」になり、「git bisect」は最初のbadコミットを見つけることができます。 また、スクリプトを終了する前にテストが完了したら、スクリプトはパッチを削除することを忘れないでください。</p></div>
<div class="paragraph"><p>(注意: パッチの代わりに <code>git cherry-pick BFC</code> を使用して修正を適用できることに注意してください。この場合、 <code>git reset --hard HEAD^</code> を使用して、テスト後にスクリプトから戻る前にチェリーピックを元に戻す必要があります。)</p></div>
<div class="paragraph"><p>しかし、テスト不能な領域を回避する上記の方法は少々ぎこちないです。 特別なブランチを使用することは、これらのブランチを通常のブランチのように開発者が共有できるので便利ですが、リスクは人々がそのようなブランチをたくさん取得することです。 そして、それは通常の「git bisect」ワークフローを混乱させます。 したがって、「git bisect run」を完全に自動的に使用する場合は、スクリプトに特別なコードを追加して、特別なブランチでbisectを再開する必要があります。</p></div>
<div class="paragraph"><p>とにかく、上記の特別なブランチの例では、Z' と Z のコミットが同じソースコードの状態(git用語では同じ「ツリー」)を指している必要があることに気付くでしょう。 これは、Z' が Z と同じ変更をわずかに異なる順序で適用した結果であるためです。</p></div>
<div class="paragraph"><p>したがって、bisectするときに Z を Z' に「置き換える」ことができれば、スクリプトに何も追加する必要はありません。 それは、特別なブランチとその代替品を共有するプロジェクトの誰にとってもうまくいくでしょう。</p></div>
<div class="paragraph"><p>上記例では、以下のようになります:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...
     /
...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z</code></pre>
</div></div>
<div class="paragraph"><p>このために、「git replace」コマンドが作成されました。 技術的には、「置き換えるrefs」を <code>refs/replace/</code> 階層に格納します。 これらの「ref」は、ブランチ(<code>refs/heads/</code> に格納)またはタグ(<code>refs/tags</code> に格納)のようなものであり、開発者間でブランチまたはタグのように自動的に共有できることを意味します。</p></div>
<div class="paragraph"><p>「git replace」は非常に強力なメカニズムです。 これは、すでにリリースされた履歴のコミットを修正するために使用できます。たとえば、コミットメッセージや作成者を変更するために使用できます。 また、 git "grafts" の代わりに使用して、リポジトリを別の古いリポジトリにリンクすることもできます。</p></div>
<div class="paragraph"><p>実際には、Gitコミュニティに「お披露目」したのはこの最後の機能であるため、現在これはGitのGitリポジトリのmasterブランチにあり、2009年10月または11月にGit1.6.5でリリースされる予定です。</p></div>
<div class="paragraph"><p>「git replace」の問題の1つは、現在すべての置換refを <code>refs/replace/</code> に格納していることですが、bisectにのみ役立つ置換refが <code>refs/replace/bisect/ にあるとよいでしょう。 このように、置換参照は二等分にのみ使用できますが、「refs /replace/」に直接含まれる他の参照はほぼ常に使用されます。 git replace の問題点として、現在 `refs/replace/</code> に全ての置換用refを格納していますが、bisectするためだけに有用な置換用refを <code>refs/replace/bisect/</code> に格納した方が良いのではないかと思います。こうすることで、 <code>refs/replace/</code> に直接ある他のrefsがほぼ常に使用される一方で、置換refsはbisectするときだけ使用することができます。</p></div>
</div>
<div class="sect2">
<h3 id="_まばらなバグのbisect">まばらなバグのbisect</h3>
<div class="paragraph"><p>「git bisect」のもう1つの可能な改善点は、実行されるテストにオプションで冗長性を追加して、まばらなバグ(sporadic bugs)を追跡する際の信頼性を高めることです。</p></div>
<div class="paragraph"><p>散発的なバグ(sporadic bugs)と呼ばれるいくつかのバグは、コンパイラの出力に大きく依存していて、すべてのカーネルビルドでは現れないため、この改善は一部のカーネル開発者から要求されています。</p></div>
<div class="paragraph"><p>このアイデアは、たとえば「git bisect」を実行するたびに、(その子孫あるいは祖先がそれぞれ「good」または「bad」と判定されたために、)すでに「good」または「bad」と判定されたコミットをテストするようユーザーに求めることができます。もしあるコミットが以前に間違って分類されていた場合、できれば多くの間違いが起こる前に、bisectを早期に中止することができます。その場合、ユーザーは何が起こったのかを調べ、修正された bisect ログを使用して bisect を再開しなければなりません。</p></div>
<div class="paragraph"><p>ベイジアン検索理論(Bayesian Search Theory)を使用してそのようなことを行う、Github上に Ealdwulf Wuffinga によって作成された BBChop というプロジェクトがすでにあります <a href="#9">[9]</a> :</p></div>
<div class="quoteblock">
<div class="content">BBChopは「gitbisect」(または同等のもの)に似ていますが、バグが断続的に発生する場合に機能します。 つまり、検知漏れ(false negatives)(あるバージョンにバグが含まれていても、今回はそのバージョンが機能する場合)が存在する場合に機能します。 誤検知(false positives)がないことを前提としています(原則として、同一プローチで機能しますが、追加するのは簡単ではない場合があります)。</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>ただし、BBChopはVCSから独立しているため、GitユーザーとしてはGitに何かを統合する方が簡単です。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_結論">結論</h2>
<div class="sectionbody">
<div class="paragraph"><p>リグレッションは重要な問題であり、「git bisect」には、デグレと戦うために一般的に使用される非常に優れたプラクティスやその他のツール、特にテストスイートを補完する優れた機能があることがわかりました。 しかし、それを最大限に活用するには、いくつかのワークフローと(悪い)習慣を変更する必要があるかもしれません。</p></div>
<div class="paragraph"><p>「git bisect」内のアルゴリズムにいくつかの改善が可能であり、いくつかの新機能が役立つ場合もありますが、全体的な「git bisect」はすでに非常にうまく機能し、多く使用されており、すでに非常に便利です。 最後の主張を裏付けるために、Ingo Molnarが著者に「git bisect を使うとどのくらい時間が節約できると思いますか」と聞かれたときの答えを引用しましょう:</p></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>たくさん節約できたよ。</p></div>
<div class="paragraph"><p>約10年前、Linuxパッチキューの最初の「二等分」を実行しました。 それはGitの前(そしてBitKeeperよりも前)でした。 私は文字通り、パッチを整理し、本質的にそのバグに関連していると推測したスタンドアロンのコミットを作成するのに何日も費やしました。</p></div>
<div class="paragraph"><p>それはツールとして絶対的に最後の手段でした。 手動の「パッチ二等分」よりも、printkの出力を確認するのに何日も費やしたと思います。</p></div>
<div class="paragraph"><p>Git bisect を使用すると、これは簡単です。最良の場合、自動化された方法で、20〜30分で最大15ステップのカーネルbisectを実行できます。 手動のヘルプを使用したり、複数の重複するバグをbisectしたりしても、1時間以上かかることはめったにありません。</p></div>
<div class="paragraph"><p>実際、git bisectがなければ、「デバッグしようと試みさえしない」しないバグがあるので、非常に貴重です。 過去には、デバッグするのに直ぐに絶望的と分かるバグパターンがありました。それは、せいぜい クラッシュ/バグシグネチャ をlkmlに送信して、他の誰かが何かを考えてくれることを期待するのがせいぜいでした。</p></div>
<div class="paragraph"><p>そして今や、bisectが失敗したとしても、それはバグについて何か価値のあることを教えてくれます。それは非決定論的であり、タイミングやカーネルイメージのレイアウトに依存します。</p></div>
<div class="paragraph"><p>つまり、git bisect は無条件に良いものなのです&#8201;&#8212;&#8201;このフレーズは自由に引用していいです ;-)</p></div>
</div>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_謝辞">謝辞</h2>
<div class="sectionbody">
<div class="paragraph"><p>この論文のレビュー、Gitメーリングリストに送信したパッチのレビュー、いくつかのアイデアの議論と改善の支援、「git bisect」の大幅な改善、Gitの開発および維持における素晴らしい仕事に協力してくれた濱野 純(Junio Hamano)に感謝します。</p></div>
<div class="paragraph"><p>この論文に登場する非常に有用な情報を提供してくれた Ingo Molnar、この論文へのコメント、「git bisect」を改善するための提案、およびLinuxカーネルメーリングリストでの「git bisect」の伝道に感謝します。</p></div>
<div class="paragraph"><p>「gitbisect」、Git、Linuxを発明、開発、伝道してくれたLinus Torvaldsに感謝します。</p></div>
<div class="paragraph"><p>私がGitに取り組んだときに何らかの形で助けてくれた他の多くの素晴らしい人々、特に Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour に感謝します。</p></div>
<div class="paragraph"><p>講演を行う著者を選択し、この論文を発表してくれた Linux-Kongress プログラム委員会に感謝します。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<a id="1"></a>[1] <a href="https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm"><em>Software Errors Cost U.S. Economy $59.5 Billion Annually</em>. Nist News Release.</a> こちらもご覧下さい： <a href="https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf"><em>The Economic Impacts of Inadequate Infratructure for Software Testing</em>. Nist Planning Report 02-3</a>, Executive Summary and Chapter 8.
</p>
</li>
<li>
<p>
<a id="2"></a>[2] <a href="https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html"><em>Code Conventions for the Java Programming Language: 1. Introduction</em>. Sun Microsystems.</a>
</p>
</li>
<li>
<p>
<a id="3"></a>[3] <a href="https://en.wikipedia.org/wiki/Software_maintenance"><em>Software maintenance</em>. Wikipedia.</a>
</p>
</li>
<li>
<p>
<a id="4"></a>[4] <a href="https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/">Junio C Hamano. <em>Automated bisect success story</em>.</a>
</p>
</li>
<li>
<p>
<a id="5"></a>[5] <a href="https://lwn.net/Articles/317154/">Christian Couder. <em>Fully automated bisecting with "git bisect run"</em>. LWN.net.</a>
</p>
</li>
<li>
<p>
<a id="6"></a>[6] <a href="https://lwn.net/Articles/277872/">Jonathan Corbet. <em>Bisection divides users and developers</em>. LWN.net.</a>
</p>
</li>
<li>
<p>
<a id="7"></a>[7] <a href="https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/">Ingo Molnar. <em>Re: BUG 2.6.23-rc3 can&#8217;t see sd partitions on Alpha</em>. Linux-kernel mailing list.</a>
</p>
</li>
<li>
<p>
<a id="8"></a>[8] <a href="https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html">Junio C Hamano and the git-list. <em>git-bisect(1) Manual Page</em>. Linux Kernel Archives.</a>
</p>
</li>
<li>
<p>
<a id="9"></a>[9] <a href="https://github.com/Ealdwulf/bbchop">Ealdwulf. <em>bbchop</em>. GitHub.</a>
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-10-17 11:03:29 JST
</div>
</div>
</body>
</html>
