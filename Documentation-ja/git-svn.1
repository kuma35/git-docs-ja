'\" t
.\"     Title: git-svn
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 12/10/2022
.\"    Manual: Git Manual
.\"    Source: Git 2.38.0.rc1.238.g4f4d434dc6.dirty
.\"  Language: English
.\"
.TH "GIT\-SVN" "1" "12/10/2022" "Git 2\&.38\&.0\&.rc1\&.238\&.g" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-svn \- SubversionリポジトリとGit間の双方向操作
.SH "SYNOPSIS"
.sp
.nf
\fIgit svn\fR <command> [<options>] [<arguments>]
.fi
.sp
.SH "DESCRIPTION"
.sp
\fBgit svn\fR は、SubversionとGitの間のチェンジセットのための単純な水道管です。 SubversionとGitリポジトリ間の双方向の変更フローを提供します。
.sp
\fBgit svn\fR は、 \fB\-\-stdlayout\fR オプションを使用して、一般的な「trunk/branches/tags」レイアウトに従って、標準のSubversionリポジトリを追跡できます。 また、 \fB\-T\fR/\fB\-t\fR/\fB\-b\fR オプションを使用して、任意のレイアウトのブランチとタグを追跡することもできます(以下の「initコマンド」のオプションおよび「cloneコマンド」も参照してください)。
.sp
(上記の方法のいずれかを使用して)Subversionリポジトリを追跡すると、Gitリポジトリは「fetch」コマンドによってSubversionから更新され、Subversionは「dcommit」コマンドによってGitから更新されます。
.SH "COMMANDS"
.PP
\fBinit\fR
.RS 4
\fBgit svn\fR
の追加のメタデータディレクトリを使用して空のGitリポジトリを初期化します。 Subversion URLは、コマンドライン引数として、または
\fB\-T\fR/\fB\-t\fR/\fB\-b\fR
への完全なURL引数として指定できます。 オプションで、操作するターゲットディレクトリを2番目の引数として指定できます。 通常、このコマンドは現在のディレクトリを初期化します。
.PP
\fB\-T<trunk_subdir>\fR, \fB\-\-trunk=<trunk_subdir>\fR, \fB\-t<tags_subdir>\fR, \fB\-\-tags=<tags_subdir>\fR, \fB\-b<branches_subdir>\fR, \fB\-\-branches=<branches_subdir>\fR, \fB\-s\fR, \fB\-\-stdlayout\fR
.RS 4
これらは、initのコマンドラインオプションです。 これらの各フラグは、相対リポジトリパス(\fB\-tags=project/tags\fR)または完全なURL(\fB\-\-tags=https://foo\&.org/project/tags\fR)を指すことができます。 Subversionリポジトリがタグまたはブランチを複数のパスの下に配置する場合は、複数の
\fB\-\-tags\fR
および/または
\fB\-\-branches\fR
オプションを指定できます。 オプション
\fB\-\-stdlayout\fR
は、トランク、タグ、ブランチを相対パスとして設定する簡単な方法です。これは、Subversionのデフォルトです。 他のオプションのいずれかが同様に指定されている場合、それらが優先されます。
.RE
.PP
\fB\-\-no\-metadata\fR
.RS 4
[svn\-remote] 設定で
\fBnoMetadata\fR
オプションを設定します。 このオプションはお勧めしません。このオプションを使用する前に、このマンページの「svn\&.noMetadata」セクションをお読みください。
.RE
.PP
\fB\-\-use\-svm\-props\fR
.RS 4
[svn\-remote]設定で
\fBuseSvmProps\fR
オプションを設定します。
.RE
.PP
\fB\-\-use\-svnsync\-props\fR
.RS 4
[svn\-remote] 設定で
\fBuseSvnsyncProps\fR
オプションを設定します。
.RE
.PP
\fB\-\-rewrite\-root=<URL>\fR
.RS 4
[svn\-remote]設定で
\fBrewriteRoot\fR
オプションを設定します。
.RE
.PP
\fB\-\-rewrite\-uuid=<UUID>\fR
.RS 4
[svn\-remote]設定で
\fBrewriteUUID\fR
オプションを設定します。
.RE
.PP
\fB\-\-username=<user>\fR
.RS 4
SVNが認証を処理する転送(http や https やプレーンsvn)の場合に、ユーザー名を指定します。 他の転送(例:
\fBsvn+ssh://\fR)の場合、URLにユーザー名を含める必要があります。例：
\fBsvn+ssh://foo@svn\&.bar\&.com/project\fR
.RE
.PP
\fB\-\-prefix=<prefix>\fR
.RS 4
これにより、トランク/ブランチ/タグ が指定されている場合に、リモートの名前の前に付加される接頭辞を指定できます。 接頭辞(prefix)には自動的に末尾のスラッシュが含まれ無いため、必要に応じて引数に必ず末尾のスラッシュを含めてください。
\fB\-\-branches\fR/\fB\-b\fR
を指定する場合、接頭辞には末尾のスラッシュを含める必要があります。 SVN追跡refは
\fBrefs/remotes/$prefix/*\fR
に配置されるため、(末尾にスラッシュを付けた)接頭辞を設定することを強くお勧めします。これは、Git独自のリモート追跡refレイアウトと互換性があります(\fBrefs/remotes/$remote/*\fR)。 接頭辞の設定は、共通のリポジトリを共有する複数のプロジェクトを追跡する場合にも役立ちます。 デフォルトでは、接頭辞は
\fBorigin/\fR
に設定されています。
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Git v2\&.0 より前は、デフォルトの接頭辞は "" (接頭辞無し)でした。 これは、SVN追跡refが
\fBrefs/remotes/*\fR
に配置されたことを意味します。これは、Git自体のリモート追跡refの編成方法と互換性がありません。 それでも古いデフォルトが必要な場合は、コマンドラインで
\fB\-\-prefix ""\fR
を渡すことで取得できます(Perlの Getopt::Long is < v2\&.37 の場合、
\fB\-\-prefix=""\fR
は機能しない可能性があります)。
.sp .5v
.RE
.RE
.PP
\fB\-\-ignore\-refs=<regex>\fR
.RS 4
\fBinit\fR
または
\fBclone\fR
に渡されると、この正規表現は構成キー(config key)として保持されます。
\fB\-\-ignore\-refs\fR
の説明については、「fetch」コマンドを参照してください。
.RE
.PP
\fB\-\-ignore\-paths=<regex>\fR
.RS 4
\fBinit\fR
または` clone` に渡されると、この正規表現は構成キー(config key)として保持されます。
\fB\-\-ignore\-paths\fR
の説明については、「fetch」コマンドを参照してください。
.RE
.PP
\fB\-\-include\-paths=<regex>\fR
.RS 4
\fBinit\fR
または
\fBclone\fR
に渡されると、この正規表現は構成キー(config key)として保持されます。
\fB\-\-include\-paths\fR
の説明については、「fetch」コマンドを参照してください。
.RE
.PP
\fB\-\-no\-minimize\-url\fR
.RS 4
(\fB\-\-stdlayout\fR
または
\fB\-\-branches\fR
または
\fB\-\-tags\fR
オプションを使用して、)複数のディレクトリを追跡する場合、git svnはSubversionリポジトリのルート(または許可されている最高レベル)への接続を試みます。 このデフォルトでは、プロジェクト全体がリポジトリ内で移動された場合に履歴をより適切に追跡できますが、読み取りアクセス制限が設定されているリポジトリで問題が発生する可能性があります。
\fB\-\-no\-minimize\-url\fR
を渡すと、git svnは、上位レベルのディレクトリに接続しようとせずに、URLをそのまま受け入れることができます。 このオプションは、1つの URL/ブランチ のみが追跡される場合はデフォルトでオフになっています(ほとんど効果ありません)。
.RE
.RE
.PP
\fBfetch\fR
.RS 4
私達が追跡しているSubversionリモートからフェッチされていないリビジョンを取得します。 $GIT_DIR/config ファイルの [svn\-remote "\&..."] セクションの名前は、オプションのコマンドライン引数として指定できます。
.sp
これにより、必要に応じてrev_mapが自動的に更新されます(詳細については、以下の「FILES」セクションの
\fB$GIT_DIR/svn/\e**/\&.rev_map\&.*\fR
を参照してください)。
.PP
\fB\-\-localtime\fR
.RS 4
Gitのコミット時間をUTCではなくローカルタイムゾーンで保存します。 これにより、「git log」は(`\-\-date=local`がなくても)、「svn log」がローカルタイムゾーンで表示されるのと同じ時間を表示します。
.sp
これは、クローンを作成したSubversionリポジトリとの相互運用を妨げることはありませんが、ローカルGitリポジトリを他の誰かのローカルGitリポジトリと相互運用できるようにする場合は、このオプションを使用しないか、両方で同一のローカルタイムゾーンを使用する必要があります。
.RE
.PP
\fB\-\-parent\fR
.RS 4
現在のHEADのSVNの親からのみフェッチします。
.RE
.PP
\fB\-\-ignore\-refs=<regex>\fR
.RS 4
Perlの正規表現にマッチするブランチまたはタグのrefを無視します。
\fB^refs/remotes/origin/(?!tags/wanted\-tag|wanted\-branch)\&.*$\fR
のような「negative look\-ahead assertion」(負の先読みアサーション)は、特定のrefのみを許可するために使用できます。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\-remote\&.<name>\&.ignore\-refs
.fi
.if n \{\
.RE
.\}
.sp
ignore\-refs 構成キーが設定されていて、コマンドラインオプションも指定されている場合は、両方の正規表現が使用されます。
.RE
.PP
\fB\-\-ignore\-paths=<regex>\fR
.RS 4
これにより、SVNからのチェックアウトから一致するすべてのパスをスキップするPerl正規表現を指定できます。
\fB\-\-ignore\-paths\fR
オプションは、特定のリポジトリのすべての
\fBfetch\fR
(\fBclone\fR,
\fBdcommit\fR,
\fBrebase\fR
などによる自動フェッチを含む)にマッチする必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\-remote\&.<name>\&.ignore\-paths
.fi
.if n \{\
.RE
.\}
.sp
ignore\-paths 構成キーが設定されていて、コマンドラインオプションも指定されている場合は、両方の正規表現が使用されます。
.sp
例:
.PP
フェッチするたびに \fBdoc*\fR ディレクトリをスキップします
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-ignore\-paths="^doc"
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
第1レベルのディレクトリの「branches」と「tags」をスキップします
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-ignore\-paths="^[^/]+/(?:branches|tags)"
.fi
.if n \{\
.RE
.\}
.sp
.RE
.RE
.PP
\fB\-\-include\-paths=<regex>\fR
.RS 4
これにより、SVNのチェックアウトからのマッチするパスのみを含めるPerl正規表現を指定できます。
\fB\-\-include\-paths\fR
オプションは、特定のリポジトリのすべての
\fBfetch\fR(\fBclone\fR,
\fBdcommit\fR,
\fBrebase\fR
などによる自動フェッチを含む)に一致する必要があります。
\fB\-\-ignore\-paths\fR
は
\fB\-\-include\-paths\fR
よりも優先されます。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\-remote\&.<name>\&.include\-paths
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-\-log\-window\-size=<n>\fR
.RS 4
Subversionの履歴をスキャンするときに、リクエストごとに<n>個のログエントリを取得します。 デフォルトは100です。非常に大きなSubversionリポジトリの場合、「クローン」/「フェッチ」 が妥当な時間で完了するには、より大きな値が必要になる場合があります。 ただし、値が大きすぎると、メモリ使用量が増え、リクエストののタイムアウトが発生する可能性があります。
.RE
.RE
.PP
\fBclone\fR
.RS 4
\fBinit\fR
と
\fBfetch\fR
を実行します。 渡されたURLのベース名に基づいてディレクトリを自動的に作成します。 または2番目の引数が渡された場合はディレクトリを作成し、その中で動作します。
\fB\-\-fetch\-all\fR
と
\fB\-\-parent\fR
を除いて、
\fBinit\fR
と
\fBfetch\fR
コマンドが受け入れるすべての引数を受け入れます。 リポジトリのクローンが作成されると、「fetch」コマンドは作業ツリーに影響を与えることなくリビジョンを更新できるようになります。 「rebase」コマンドは、作業ツリーを最新の変更で更新できるようになります。
.PP
\fB\-\-preserve\-empty\-dirs\fR
.RS 4
Subversionからフェッチされた空のディレクトリごとに、ローカルGitリポジトリにプレースホルダーファイルを作成します。 これには、Subversionリポジトリ内のすべてのエントリを削除することによって空になるディレクトリが含まれます(ディレクトリ自体は削除されません)。 プレースホルダーファイルも追跡され、不要になったときに削除されます。
.RE
.PP
\fB\-\-placeholder\-filename=<filename>\fR
.RS 4
\fB\-\-preserve\-empty\-dirs\fR
によって作成されたプレースホルダーファイルの名前を設定します。 デフォルトは
\fB\&.gitignore\fR
です。
.RE
.RE
.PP
\fBrebase\fR
.RS 4
これにより、現在のHEADのSVN親からリビジョンがフェッチされ、現在の(SVNにコミットされていない)作業がリベースされます。
.sp
これは
\fBsvn update\fR
または
\fBgit pull\fR
と同様に機能しますが、
\fBgit svn\fR
でのコミットを容易にするために
\fBgit merge\fR
ではなく
\fBgit rebase\fR
で線形履歴を保持する点が異なります。
.sp
これは、
\fBgit svn fetch\fR
や
\fBgit rebase\fR
が受け入れるすべてのオプションを受け入れます。 ただし、
\fB\-\-fetch\-all\fR
は現在の[svn\-remote]からのみフェッチし、すべての[svn\-remote]定義からフェッチするわけではありません。
.sp
\fBgit rebase\fR
と同様です。これには、作業ツリーがクリーンであり、コミットされていない変更がないことが必要です。
.sp
これにより、必要に応じてrev_mapが自動的に更新されます(詳細については、以下の「FILES」セクションの
\fB$GIT_DIR/svn/\e**/\&.rev_map\&.*\fR
を参照してください)。
.PP
\fB\-l\fR, \fB\-\-local\fR
.RS 4
リモートでフェッチしないでください。 アップストリームSVNから最後にフェッチされたコミットに対してのみ
\fBgit rebase\fR
を実行します。
.RE
.RE
.PP
\fBdcommit\fR
.RS 4
現在のブランチからの各diffを直接SVNリポジトリにコミットしてから、リベースまたはリセットします(SVNとヘッドの間にdiffがあるかどうかによって異なります)。 これにより、GitのコミットごとにSVNにリビジョンが作成されます。
.sp
オプションのGitブランチ名(またはGitコミットオブジェクト名)が引数として指定されている場合、サブコマンドは現在のブランチではなく、指定されたブランチで機能します。
.sp
\fBset\-tree\fR
(下記)よりも
\fBdcommit\fR
の使用が推奨されます。
.PP
\fB\-\-no\-rebase\fR
.RS 4
コミット後にリベースまたはリセットしないでください。
.RE
.PP
\fB\-\-commit\-url <URL>\fR
.RS 4
このSVN URL(フルパス)にコミットします。 これは、ユーザーが後でコミット用の代替転送方法(例えば
\fBsvn+ssh://\fR
や
\fBhttps://\fR)へのアクセスを許可された場合に、ある転送方法(例えば、匿名読み取りの場合は
\fBsvn://\fR
または
\fBhttp://\fR)で作成された既存の
\fBgit svn\fR
リポジトリを再利用できるようにすることを目的としています。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\-remote\&.<name>\&.commiturl
config key: svn\&.commiturl (overwrites all svn\-remote\&.<name>\&.commiturl options)
.fi
.if n \{\
.RE
.\}
.sp
注意: commiturl構成キーのSVN URLにはSVNブランチが含まれていることに注意してください。 SVNリポジトリ全体のコミットURLを設定する場合は、代わりに
\fBsvn\-remote\&.<name>\&.pushurl\fR
を使用してください。
.sp
このオプションを他の目的(それがナニカは聞かないで下さい)で使用することは、全く全然欠片もお勧めできません。
.RE
.PP
\fB\-\-mergeinfo=<mergeinfo>\fR
.RS 4
dcommit中に指定されたマージ情報を追加します(たとえば
\fB\-\-mergeinfo="/branches/foo:1\-10"\fR)。 すべてのsvnサーバーバージョンはこの情報を(プロパティとして)保存でき、バージョン1\&.5以降のsvnクライアントはそれを利用できます。 複数のブランチからのマージ情報を指定するには、ブランチの間に単一の空白文字を使用します(\fB\-\-mergeinfo="/branches/foo:1\-10 /branches/bar:3,5\-6,8"\fR)
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.pushmergeinfo
.fi
.if n \{\
.RE
.\}
.sp
このオプションにより、git\-svnは、可能な場合、SVNリポジトリの svn:mergeinfo プロパティに自動的にデータを入力しようとします。 現在、これは、最初の親を除くすべての親がすでにSVNにプッシュされている非早送りマージをコミットする場合にのみ実行できます。
.RE
.PP
\fB\-\-interactive\fR
.RS 4
パッチセットが実際にSVNに送信される必要があることを確認するようにユーザーに問い合わせます。 パッチごとに、「yes」(このパッチを受け入れる)、または「no」(このパッチを破棄する)、または「all」(すべてのパッチを受け入れる)、または「quit」と答えることができます。
.sp
\fBgit svn dcommit\fR
は、回答が「no」または「quit」の場合、SVNに何もコミットせずに、すぐに終了します。
.RE
.RE
.PP
\fBbranch\fR
.RS 4
SVNリポジトリにブランチを作成します。
.PP
\fB\-m\fR, \fB\-\-message\fR
.RS 4
コミットメッセージを指定できます。
.RE
.PP
\fB\-t\fR, \fB\-\-tag\fR
.RS 4
\fBgit svn init\fR
で指定された branchs_subdir の代わりに、 tags_subdir を使用してタグを作成します。
.RE
.PP
\fB\-d<path>\fR, \fB\-\-destination=<path>\fR
.RS 4
\fBinit\fR
または
\fBclone\fR
コマンドに複数の
\fB\-\-branches\fR(または
\fB\-\-tags\fR)オプションが指定されている場合は、SVNリポジトリに作成するブランチ(またはタグ)の場所を指定する必要があります。 <path> はブランチやタグを作成するために使用するパスを指定し、設定されたブランチやタグのrefspecsのどれかの左側のパターンに一致する必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
git config \-\-get\-all svn\-remote\&.<name>\&.branches
git config \-\-get\-all svn\-remote\&.<name>\&.tags
.fi
.if n \{\
.RE
.\}
.sp
ここで、 <name> は、\fBinit\fR
の
\fB\-R\fR
オプションで指定されたSVNリポジトリーの名前です(またはデフォルトでは
\fBsvn\fR)。
.RE
.PP
\fB\-\-username\fR
.RS 4
コミットを実行するSVNユーザー名を指定します。 このオプションは、
\fBusername\fR
構成プロパティをオーバーライドします。
.RE
.PP
\fB\-\-commit\-url\fR
.RS 4
指定のURLを使用して、宛先のSubversionリポジトリに接続します。 これは、ソースSVNリポジトリが読み取り専用である場合に役立ちます。 このオプションは、構成プロパティ
\fIcommiturl\fR
をオーバーライドします。
.sp
.if n \{\
.RS 4
.\}
.nf
git config \-\-get\-all svn\-remote\&.<name>\&.commiturl
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fB\-\-parents\fR
.RS 4
親フォルダを作成します。 このパラメーターは、
\fBsvn cp\fR
コマンドの
\fB\-\-parents\fR
パラメーターと同等であり、非標準のリポジトリーレイアウトで役立ちます。
.RE
.RE
.PP
\fBtag\fR
.RS 4
SVNリポジトリにタグを作成します。 これは
\fBbranch \-t\fR
の省略形です。
.RE
.PP
\fBlog\fR
.RS 4
これにより、svnユーザーが
\fB\-r\fR/\fB\-revision\fR
番号を参照するときに、svnログメッセージを簡単に検索できるようになります。
.sp
\fBsvn log\fR
では以下の機能がサポートされています:
.PP
\fB\-r <n>[:<n>]\fR, \fB\-\-revision=<n>[:<n>]\fR
.RS 4
数値以外の、 HEAD, NEXT, BASE, PREV, 等 はサポートされていません。
.RE
.PP
\fB\-v\fR, \fB\-\-verbose\fR
.RS 4
\fBsvn log\fR
の
\fB\-\-verbose\fR
出力と完全互換性ではありませんが、かなり近いです。
.RE
.PP
\fB\-\-limit=<n>\fR
.RS 4
このオプションは
\fB\-\-max\-count\fR
と同一ではなく、 マージされた/除外された コミットをカウントしません
.RE
.PP
\fB\-\-incremental\fR
.RS 4
supported(訳注: 原文ママ)
.RE
.sp
新機能:
.PP
\fB\-\-show\-commit\fR
.RS 4
Gitコミットのsha1も表示します
.RE
.PP
\fB\-\-oneline\fR
.RS 4
私たちのバージョンの
\fB\-\-pretty=oneline\fR
.RE
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
SVN自体はUTCでのみ時間を保存し、他には何も保存しません。 通常のsvnクライアントは、UTC時刻を現地時間(local time)に(または TZ= 環境変数に基づいて)変換します。 このコマンドの振る舞いは同一です。
.sp .5v
.RE
その他の引数はすべて
\fBgit log\fR
に直接渡されます
.RE
.PP
\fBblame\fR
.RS 4
ファイルの各行を最後に変更したリビジョンと作成者を表示します。 このモードの出力は、デフォルトで
\fBsvn blame\fR
の出力と書式の互換があります。 SVN blameコマンドと同様に、作業ツリー内のローカルのコミットされていない変更は無視されます。 HEADリビジョンのファイルのバージョンに注釈を付けます。 不明な引数は「git blame」に直接渡されます。
.PP
\fB\-\-git\-format\fR
.RS 4
\fBgit blame\fR
と同じ形式で出力を生成しますが、Gitコミットハッシュの代わりにSVNリビジョン番号を使用します。 このモードでは、SVNにコミットされていない変更(ローカルの作業コピー編集を含む)は リビジョン0 として表示されます。
.RE
.RE
.PP
\fBfind\-rev\fR
.RS 4
\fBrN\fR
の形式のSVNリビジョン番号を指定すると、対応するGitコミットハッシュを返します(オプションで、検索するブランチを指定するためにツリーっぽい何かの後に続けることができます)。 ツリーっぽい何かの場合は、対応するSVNリビジョン番号を返します。
.PP
\fB\-B\fR, \fB\-\-before\fR
.RS 4
SVNリビジョンが与えられた場合、完全一致は要求しません。代わりに、指定されたリビジョンでの(現在のブランチ上の)SVNリポジトリの状態に対応するコミットを探します。
.RE
.PP
\fB\-A\fR, \fB\-\-after\fR
.RS 4
SVNリビジョンが与えられた場合、完全一致を要求しません。 完全一致がない場合は、履歴内で前方に検索する最も近い一致を返します。
.RE
.RE
.PP
\fBset\-tree\fR
.RS 4
あなたは、このコマンドの代わりに「dcommit」の使用を検討する必要があります。 これは指定の コミットまたはツリーオブジェクト をSVNにコミットします。 これは、インポートされたフェッチデータが最新であることに依存しています。 よって、SVNにコミットするときにパッチを適用する試みはまったく行われず、ツリーまたはコミットで指定されたファイルでファイルが上書きされるだけです。 すべてのマージは、「git svn」機能とは独立して行われたと見なされます。
.RE
.PP
\fBcreate\-ignore\fR
.RS 4
ディレクトリの svn:ignore プロパティを再帰的に検索し、一致する \&.gitignore ファイルを作成します。 結果のファイルはコミットされるよう、ステージングされますが、コミットは行われません。
\fB\-r\fR/\fB\-revision\fR
を使用して、特定のリビジョンを参照します。
.RE
.PP
\fBshow\-ignore\fR
.RS 4
ディレクトリの
\fBsvn:ignore\fR
プロパティを再帰的に検索して一覧表示します。 この出力は、
\fB$GIT_DIR/info/exclude\fR
ファイルに追加するのに適しています。
.RE
.PP
\fBmkdirs\fR
.RS 4
\fB$GIT_DIR/svn/<refname>/unhandled\&.log\fR
ファイルの情報に基づいてコアGitが追跡できない空のディレクトリを再作成しようとします。 「git svn clone」や「git svn rebase」を使用すると、空のディレクトリが自動的に再作成されるため、「mkdirs」は「git checkout」や「git reset」などのコマンドの後に使用することを目的としています。 (詳細については、
\fBsvn\-remote\&.<name>\&.automkdirs\fR
構成ファイルオプションを参照してください。)
.RE
.PP
\fBcommit\-diff\fR
.RS 4
コマンドラインで指定された2つのツリーっぽい引数のdiffをコミットします。 このコマンドは、
\fBgit svn init\fR
されたリポジトリ内にあることに依存していません。 このコマンドは、 (a)差分する元のツリー、(b)新しいツリーの結果、(c)ターゲットのSubversionリポジトリのURL、の3つの引数を取ります。
\fBgit svn\fR
対応リポジトリ(\fBgit svn\fR
で
\fBinit\fR
されているリポジトリ)から作業している場合は、最後の引数(URL)を省略できます。 これには、
\fB\-r<revision>\fR
オプションが必要です。
.sp
コミットメッセージは、
\fB\-m\fR
または
\fB\-F\fR
オプションを使用して直接提供されるか、2番目のツリーっぽい何かがそのようなオブジェクトを示す場合はタグまたはコミットから間接的に提供されるか、エディターを呼び出すことによって要求されます(下記
\fB\-\-edit\fR
オプション参照)。
.PP
\fB\-m <msg>\fR, \fB\-\-message=<msg>\fR
.RS 4
指定された
\fBmsg\fR
をコミットメッセージとして使用します。 このオプションは、\fB\-\-edit\fR
オプションを無効にします。
.RE
.PP
\fB\-F <filename>\fR, \fB\-\-file=<filename>\fR
.RS 4
指定されたファイルからコミットメッセージを取得します。 このオプションは
\fB\-\-edit\fR
オプションを無効にします。
.RE
.RE
.PP
\fBinfo\fR
.RS 4
\fBsvn info\fR
が提供するものと同様のファイルまたはディレクトリに関する情報を表示します。 現在のところ
\fB\-r\fR/\fB\-revision\fR
引数はサポートしていません。
\fB\-\-url\fR
オプションを使用すると、「URL:」フィールドの値のみを出力します。
.RE
.PP
\fBproplist\fR
.RS 4
特定のファイルまたはディレクトリについてSubversionリポジトリに保存されているプロパティを一覧表示します。
\fB\-r\fR/\fB\-revision\fR
を使用して、特定のSubversionリビジョンを参照します。
.RE
.PP
\fBpropget\fR
.RS 4
ファイルの最初の引数として指定されたSubversionプロパティを取得します。 特定のリビジョンは
\fB\-r\fR/\fB\-revision\fR
で指定できます。
.RE
.PP
\fBpropset\fR
.RS 4
最初の引数として与えられた Subversion のプロパティを、3番目の引数として与えられたファイルに対して2番目の引数として与えられた値に設定します。
.sp
例:
.sp
.if n \{\
.RS 4
.\}
.nf
git svn propset svn:keywords "FreeBSD=%H" devel/py\-tipper/Makefile
.fi
.if n \{\
.RE
.\}
.sp
これにより、ファイル
\fBdevel/py\-tipper/Makefile\fR
のプロパティ
\fBsvn:keywords\fR
が
\fBFreeBSD=%H\fR
に設定されます。
.RE
.PP
\fBshow\-externals\fR
.RS 4
Subversionのexternalsを表示します。
\fB\-r\fR/\fB\-revision\fR
を使用して、特定のリビジョンを指定します。
.RE
.PP
\fBgc\fR
.RS 4
\fB$GIT_DIR/svn/<refname>/unhandled\&.log\fR
ファイルを圧縮し、
\fB$GIT_DIR/svn/<refname>/index\fR
ファイル達を削除します。
.RE
.PP
\fBreset\fR
.RS 4
\fBfetch\fR
の効果を元に戻し、指定されたリビジョンに戻します。 これにより、SVNリビジョンを「再フェッチ」できます。 通常、SVNリビジョンの内容は決して変更されるべきではなく、「リセット」は必要ありません。 ただし、SVN権限が変更された場合、または
\fB\-\-ignore\-paths\fR
オプションを変更した場合、「フェッチ」が「not found in commit」(コミットで見つかりません)(ファイルが以前に表示されなかった)または「checksum mismatch」(チェックサムの不一致)(変更を見逃した)で失敗する場合があります。 問題のあるファイルを永久に無視できない場合(\fB\-\-ignore\-pathsを使用\fR）、リポジトリを修復する唯一の方法は「reset」を使用することです。
.sp
rev_map と
\fBrefs/remotes/git\-svn\fR
のみが変更されます(詳細については、下記「ファイル」セクションの「$GIT_DIR/svn/**/\&.rev_map\&.*」を参照してください)。
\fBreset\fR
の後に
\fBfetch\fR
を続け、次に
\fBgit reset\fR
または
\fBgit rebase\fR
を実行して、ローカルブランチを新しいツリーに移動します。
.PP
\fB\-r <n>\fR, \fB\-\-revision=<n>\fR
.RS 4
保持する最新のリビジョンを指定します。 それ以降のリビジョンはすべて破棄されます。
.RE
.PP
\fB\-p\fR, \fB\-\-parent\fR
.RS 4
指定のリビジョンも破棄し、代わりに最も近い親を保持します。
.RE
.PP
例:
.RS 4
「master」にローカルの変更があると仮定しますが、あなたは「r2」を再フェッチする必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
    r1\-\-\-r2\-\-\-r3 remotes/git\-svn
                \e
                 A\-\-\-B master
.fi
.if n \{\
.RE
.\}
.sp
そもそも「r2」が不完全になる原因となったignore\-pathsまたはSVNパーミッションの問題を修正します。 それから:
.sp
.if n \{\
.RS 4
.\}
.nf
git svn reset \-r2 \-p
git svn fetch
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
    r1\-\-\-r2\*(Aq\-\-r3\*(Aq remotes/git\-svn
      \e
       r2\-\-\-r3\-\-\-A\-\-\-B master
.fi
.if n \{\
.RE
.\}
.sp
次に、「master」を「git rebase」で修正します。 「git merge」を使用してはいけません。「git merge」を使用すると、履歴が将来の「dcommit」と互換性がなくなります。
.sp
.if n \{\
.RS 4
.\}
.nf
git rebase \-\-onto remotes/git\-svn A^ master
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
    r1\-\-\-r2\*(Aq\-\-r3\*(Aq remotes/git\-svn
                \e
                 A\*(Aq\-\-B\*(Aq master
.fi
.if n \{\
.RE
.\}
.sp
.RE
.RE
.SH "OPTIONS"
.PP
\fB\-\-shared[=(false|true|umask|group|all|world|everybody)]\fR, \fB\-\-template=<template\-directory>\fR
.RS 4
\fBinit\fR
コマンドでのみ使用されます。 これらは
\fBgit init\fR
に直接渡されます。
.RE
.PP
\fB\-r <arg>\fR, \fB\-\-revision <arg>\fR
.RS 4
\fBfetch\fR
コマンドで使用されます。
.sp
これにより、部分的な(partial)/一部が取り除かれた(cauterized) 履歴のリビジョン範囲をサポートできます。 $NUMBER, $NUMBER1:$NUMBER2 (数値範囲) と $NUMBER:HEAD と $NUMBER：HEAD と BASE:$NUMBER はすべてサポートされています。
.sp
これにより、フェッチの実行時に部分ミラーを作成できます。 ただし、履歴がスキップされて失われるため、通常はお勧めしません。
.RE
.PP
\fB\-\fR, \fB\-\-stdin\fR
.RS 4
\fBset\-tree\fR
コマンドでのみ使用されます。
.sp
stdinからコミットのリストを読み取り、逆の順序でコミットします。 各行からは先頭のsha1のみが読み取られるため、
\fBgit rev\-list \-\-pretty=oneline\fR
出力を使用できます。
.RE
.PP
\fB\-\-rmdir\fR
.RS 4
\fBdcommit\fR
と
\fBset\-tree\fR
と
\fBcommit\-diff\fR
コマンドでのみ使用されます。
.sp
ファイルが残っていない場合は、SVNツリーからディレクトリを削除します。 SVNは空のディレクトリをバージョン管理でき、ファイルが残っていない場合、デフォルトでは削除されません。 Gitは空のディレクトリをバージョン管理できません。 このフラグを有効にすると、SVNへのコミットがGitのように機能します。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.rmdir
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-e\fR, \fB\-\-edit\fR
.RS 4
\fBdcommit\fR
と
\fBset\-tree\fR
と
\fBcommit\-diff\fR
コマンドでのみ使用されます。
.sp
SVNにコミットする前に、コミットメッセージを編集します。 これは、コミットされているオブジェクトではデフォルトでオフになっており、ツリーオブジェクトをコミットするときには強制的にオンになります。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.edit
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-l<num>\fR, \fB\-\-find\-copies\-harder\fR
.RS 4
\fBdcommit\fR
と
\fBset\-tree\fR
と
\fBcommit\-diff\fR
コマンドでのみ使用されます。
.sp
これらは両方とも「git diff\-tree」に直接渡されます。 詳細については、
\fBgit-diff-tree\fR(1)
を参照してください。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.l
config key: svn\&.findcopiesharder
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-A<filename>\fR, \fB\-\-authors\-file=<filename>\fR
.RS 4
構文は「git cvs import」で使用されるファイルと互換性がありますが、空の電子メールアドレスを
\fB<>\fR
で指定できます:
.sp
.if n \{\
.RS 4
.\}
.nf
        loginname = Joe User <user@example\&.com>
.fi
.if n \{\
.RE
.\}
.sp
このオプションが指定されていて、「git svn」が authors\-file に存在しないSVNコミッター名を検出した場合、「git svn」は操作を中止(abort)します。 この後、ユーザーは適切なエントリを追加する必要があります。 authors\-file を変更後、 先程の「git svn」コマンドを再実行すると、操作が続行されます。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.authorsfile
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-\-authors\-prog=<filename>\fR
.RS 4
このオプションを指定すると、authorsファイルに存在しないSVNコミッター名ごとに、指定のファイルを最初の引数としてコミッター名を使用してプログラムを実行します。プログラムは、「Name<email>」または「Name<>」の形式の1行を返すことが期待されており、これは、authorsファイルに含まれているかのように扱われます。
.sp
歴史的な理由により、相対的な
\fBfilename\fR
は、最初に「init」および「clone」の現在のディレクトリに対して、そして、「fetch」の作業ツリーのルートに対して、相対的に検索されます。
\fBfilename\fR
が見つからない場合は、
\fB$PATH\fR
の他のコマンドと同様に検索されます。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.authorsProg
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-q\fR, \fB\-\-quiet\fR
.RS 4
\fBgit svn\fR
のおしゃべりを減らします。 もう一度指定すると、おしゃべりがさらに少なくなります。
.RE
.PP
\fB\-m\fR, \fB\-\-merge\fR, \fB\-s<strategy>\fR, \fB\-\-strategy=<strategy>\fR, \fB\-p\fR, \fB\-\-rebase\-merges\fR
.RS 4
これらは、
\fBdcommit\fR
と
\fBrebase\fR
コマンドでのみ使用されます。
.sp
「git reset」を使用できない場合、「dcommit」を使用するときに「git rebase」に直接渡されます(「dcommit」コマンド参照)。
.RE
.PP
\fB\-n\fR, \fB\-\-dry\-run\fR
.RS 4
これは、
\fBdcommit\fR
と
\fBrebase\fR
と
\fBbranch\fR
と
\fBtag\fR
コマンドで使用できます。
.sp
\fBdcommit\fR
の場合、どのdiffがSVNにコミットされるかを示す一連のGit引数を出力します。
.sp
\fBrebase\fR
の場合、現在のブランチに関連付けられているアップストリームsvnリポジトリに関連付けられているローカルブランチと、フェッチ元のsvnリポジトリのURLを表示します。
.sp
\fBbranch\fR
や
\fBtag\fR
の場合、ブランチまたはタグを作成するときにコピーに使用されるURLを表示します。
.RE
.PP
\fB\-\-use\-log\-author\fR
.RS 4
(「fetch」または「rebase」または「dcommit」操作の一部として、)svnのコミットをGitに取得する場合、ログメッセージで最初の
\fBFrom:\fR
行または
\fBSigned\-off\-by\fR
トレーラーを探し、それを著者文字列として使用します。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.useLogAuthor
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-\-add\-author\-from\fR
.RS 4
(「set\-tree」または「dcommit」操作の一部として)Gitからsvnにコミットするとき、既存のログメッセージに
\fBFrom:\fR
または
\fBSigned\-off\-by\fR
トレーラーがまだ存在しない場合は、Gitコミットの作者文字列に基づく
\fBFrom:\fR
行を追加します。 これを使用すると
\fB\-\-use\-log\-author\fR
はすべてのコミットに対して有効な作者文字列を取得します。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.addAuthorFrom
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "ADVANCED OPTIONS"
.PP
\fB\-i<GIT_SVN_ID>\fR, \fB\-\-id <GIT_SVN_ID>\fR
.RS 4
これにより、(環境変数を使用する代わりに) GIT_SVN_ID が設定されます。 これにより、ユーザーは単一のURLを追跡するときにフェッチするデフォルトのrefnameをオーバーライドできます。
\fBlog\fR
コマンドと
\fBdcommit\fR
コマンドは、もはや引数としてこのスイッチを必要としなくなりました。
.RE
.PP
\fB\-R<remote name>\fR, \fB\-\-svn\-remote <remote name>\fR
.RS 4
使用する [svn\-remote "<remote name>"] セクションを指定します。これにより、SVNの複数のリポジトリを追跡できます。 デフォルトは
\fBsvn\fR
です。
.RE
.PP
\fB\-\-follow\-parent\fR
.RS 4
このオプションは、ブランチを追跡している場合にのみ関連します(リポジトリレイアウトオプション
\fB\-\-trunk\fR,
\fB\-\-tags\fR,
\fB\-\-branches\fR,
\fB\-\-stdlayout\fR
のどれかを使用)。 追跡されたブランチごとに、そのリビジョンがどこからコピーされたかを調べ、ブランチの最初のGitコミットで適切な親を設定しようと試みます。 これは、リポジトリ内で移動されたディレクトリを追跡する場合に特に役立ちます。 この機能が無効になっている場合、「git svn」によって作成されたブランチはすべて線形であり、履歴を共有しません。つまり、ブランチが分岐またはマージされた場所に関する情報はありません。 ただし、長い/複雑 な履歴の追跡には長い時間がかかる可能性があるため、この機能を無効にすると、クローン作成プロセスが高速化される可能性があります。 この機能はデフォルトで有効になっています。無効にするには
\fB\-\-no\-follow\-parent\fR
を使用します。
.sp
.if n \{\
.RS 4
.\}
.nf
config key: svn\&.followparent
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "CONFIG FILE\-ONLY OPTIONS"
.PP
svn\&.noMetadata, svn\-remote\&.<name>\&.noMetadata
.RS 4
これにより、すべてのコミットの最後にある
\fBgit\-svn\-id:\fR
行が削除されます。
.sp
\fBgit svn\fR
はメタデータなしでは再度フェッチできないため、このオプションはワンショットインポートにのみ使用できます。 さらに、もし、あなたが
\fB$GIT_DIR/svn/\e**/\&.rev_map\&.*\fR
ファイル達を失ってしまっても、
\fBgit svn\fR
はそれらを再構築できません。
.sp
\fBgit svn log\fR
コマンドは、これを使用するリポジトリ上でも機能しません。 これを使用すると、 (うまくいけば)明らかな理由で
\fBuseSvmProps\fR
オプションと競合します。
.sp
このオプションは、既存のドキュメントやバグレポートやアーカイブでSVNリビジョン番号への古い参照を追跡するのが困難になるため「お勧めしません」。 最終的にSVNからGitに移行することを計画していて、SVN履歴を削除することに確信がある場合は、代わりに
\m[blue]\fBgit\-filter\-repo\fR\m[]\&\s-2\u[1]\d\s+2
を検討してください。 filter\-repoを使用すると、メタデータを再フォーマットして、「svn\&.authorsFile」以外のユーザーの作成者情報を読みやすく書き直しやすくすることもできます。
.RE
.PP
svn\&.useSvmProps, svn\-remote\&.<name>\&.useSvmProps
.RS 4
これにより、「git svn」は、メタデータ用に
\fBSVN::Mirror\fR
(またはsvk)を使用して作成されたミラーからリポジトリのURLとUUIDを再マップできます。
.sp
SVNリビジョンにプロパティ「svm:headrev」がある場合、リビジョンは (SVKでも使用される、) SVN::Mirror によって作成された可能性があります。 プロパティには、リポジトリUUIDとリビジョンが含まれています。 元のURLをミラーリングしているように見せるために、元のID URLとUUIDを返すヘルパー関数を導入し、コミットメッセージでメタデータを生成するときに使用します。
.RE
.PP
svn\&.useSvnsyncProps, svn\-remote\&.<name>\&.useSvnsyncprops
.RS 4
useSvmPropsオプションと同様です。 これは、SVN 1\&.4\&.x以降で配布されている svnsync(1) コマンドのユーザー向けです。
.RE
.PP
svn\-remote\&.<name>\&.rewriteRoot
.RS 4
これにより、ユーザーは代替URL(alternate URLs)からリポジトリを作成できます。 たとえば、管理者はサーバー上で
\fBgit svn\fR
をローカルで実行できますが(file:// 経由でアクセス)、メタデータに パブリック http:// または svn:// URL を含むリポジトリを配布して、ユーザーにパブリックURLが表示されるようにします。
.RE
.PP
svn\-remote\&.<name>\&.rewriteUUID
.RS 4
useSvmPropsオプションと同様です。 これは、UUIDを手動で再マップする必要があるユーザー向けです。 これは、 useSvmProps または useSvnsyncProps のいずれかを介して元のUUIDを使用できない状況で役立つ場合があります。
.RE
.PP
svn\-remote\&.<name>\&.pushurl
.RS 4
Gitの
\fBremote\&.<name>\&.pushurl\fR
と同様に、このキーは、
\fBurl\fR
が読み取り専用転送(transport)を介してSVNリポジトリを指している場合に使用され、代替の 読み取り/書き込み 転送を提供するように設計されています。 両方のキーが同じリポジトリを指していると想定されています。
\fBcommiturl\fR
とは異なり、
\fBpushurl\fR
はベースパスです。
\fBcommiturl\fR
または
\fBpushurl\fR
のいずれかを使用できる場合は、
\fBcommiturl\fR
が優先されます。
.RE
.PP
svn\&.brokenSymlinkWorkaround
.RS 4
これにより、壊れたクライアントによってSVNにチェックインされた壊れたシンボリックリンクを回避するための潜在的に高価なチェックが無効になります。 シンボリックリンクではない空のブロブが多数あるSVNリポジトリを追跡する場合は、このオプションを「false」に設定します。 このオプションは、「git svn」の実行中に変更され、フェッチされた次のリビジョンで有効になる場合があります。 設定されていない場合、「git svn」はこのオプションが「true」であると見なします。
.RE
.PP
svn\&.pathnameencoding
.RS 4
これは、パス名を特定のエンコーディングに再コード化するようにgit svnに指示します。 Windowsユーザーおよび 非utf\-8 のロケールで作業するユーザーが使用して、ASCII以外の文字でファイル名が破損しないようにすることができます。 有効なエンコーディングは、PerlのEncodeモジュールでサポートされているものです。
.RE
.PP
svn\-remote\&.<name>\&.automkdirs
.RS 4
通常、「git svn clone」および「git svn rebase」コマンドは、Subversionリポジトリにある空のディレクトリを再作成しようとします。 このオプションが「false」に設定されている場合、「git svn mkdirs」コマンドが明示的に実行された場合にのみ、空のディレクトリが作成されます。 設定されていない場合、「git svn」はこのオプションが「true」であると見なします。
.RE
.sp
noMetadata と rewriteRoot と rewriteUUID と useSvnsyncProps とuseSvmProps オプションはすべて、「git svn」によって生成および使用されるメタデータに影響を与えるためです。 これらは、履歴をインポートする前に構成ファイルで設定する必要があります。これらの設定は、一旦設定したら決して変更してはいけません。
.sp
さらに、これらのオプションは、一緒に使用できる rewriteRoot と rewriteUUID を除いて、 \fBgit\-svn\-id:\fR メタデータ行に影響を与えるため、svn\-remoteセクションごとに使用できるのは1つだけです。
.SH "BASIC EXAMPLES"
.sp
Subversion管理プロジェクトのtrunkの追跡と貢献(タグとブランチを無視):
.sp
.if n \{\
.RS 4
.\}
.nf
# リポジトリのクローン(`git clone` と同様):
        git svn clone http://svn\&.example\&.com/project/trunk
# 新しく複製されたディレクトリに入る:
        cd trunk
# あなたはmasterブランチにいる必要があります。 `git branch ` で再確認
        git branch
# いくつかの作業を行い、ローカルでGitにコミットします:
        git commit \&.\&.\&.
# 何かをSVNにコミットし、
# SVNの最新の変更に対してあなたのローカルの変更をリベースします:
        git svn rebase
# 次に、変更(先程はGitを使用してコミットしたもの)を
# SVNにコミットし、作業中のHEADを自動的に更新します:
        git svn dcommit
# svn:ignore 設定をデフォルトのGit除外ファイルに追加します:
        git svn show\-ignore >> \&.git/info/exclude
.fi
.if n \{\
.RE
.\}
.sp
.sp
Subversion管理プロジェクト全体の追跡と貢献(trunkとタグとブランチを完備):
.sp
.if n \{\
.RS 4
.\}
.nf
# 標準のSVNディレクトリレイアウトを使用してリポジトリのクローンを作成します(`git clone`と同様):
        git svn clone http://svn\&.example\&.com/project \-\-stdlayout \-\-prefix svn/
# または、標準でないディレクトリレイアウトを使うリポジトリの場合は:
        git svn clone http://svn\&.example\&.com/project \-T tr \-b branch \-t tag \-\-prefix svn/
# クローンしたすべてのブランチとタグを表示:
        git branch \-r
# SVNに新しいブランチを作成
        git svn branch waldo
# masterをtrunk(または他のブランチ。`trunk` は
# 適切な名前に置き換えて下さい)にリセットします:
        git reset \-\-hard svn/trunk
# 一度に1つの ブランチ/タグ/trunk にのみコミットできます。
# dcommit/rebase/show\-ignore の使用法は、上記と同じである必要があります。
.fi
.if n \{\
.RE
.\}
.sp
.sp
最初の「git svn clone」は非常に時間がかかる可能性があります(特に大規模なSubversionリポジトリの場合)。 複数の人(または複数のマシンを持つ1人)が同じSubversionリポジトリと対話するために「git svn」を使用したい場合は、あなたがサーバー上のリポジトリに対して最初の「git svn clone」を実行し、 \fBgit clone\fR で各人にそのリポジトリのクローンを作成させることができます:
.sp
.if n \{\
.RS 4
.\}
.nf
# サーバーで初期インポートを実行します
        ssh server "cd /pub && git svn clone http://svn\&.example\&.com/project [options\&.\&.\&.]"
# ローカルでクローンします \- refs/remotes/ 空間 がサーバーと一致することを確認してください
        mkdir project
        cd project
        git init
        git remote add origin server:/pub/project
        git config \-\-replace\-all remote\&.origin\&.fetch \*(Aq+refs/remotes/*:refs/remotes/*\*(Aq
        git fetch
# 今後、リモートGitサーバーからの フェッチ/プル を防止します
# 今後の更新には git svn のみを使用します
        git config \-\-remove\-section remote\&.origin
# フェッチしたブランチの1つからローカルブランチを作成します
        git checkout \-b master FETCH_HEAD
# `git svn` をローカルで初期化します(サーバーで使用されたものと同じURLと
# `\-\-stdlayout`/`\-T`/`\-b`/`\-t`/`\-prefix` オプションを使用してください)
        git svn init http://svn\&.example\&.com/project [options\&.\&.\&.]
# Subversionから最新の変更をプルする
        git svn rebase
.fi
.if n \{\
.RE
.\}
.sp
.SH "REBASE VS\&. PULL/MERGE"
.sp
統合されていないコミットを「git svn」ブランチと同期するには、「git pull」または「git merge」ではなく、「git svn rebase」または「git rebase」を使用することをお勧めします。 そうすることで、統合されていないコミットの履歴がアップストリームSVNリポジトリに対して線形に保たれ、優先される「git svn dcommit」サブコマンドを使用して統合されていないコミットをSVNにプッシュバックできるようになります。
.sp
当初、「git svn」は、開発者が「git svn」ブランチからプルまたはマージすることを推奨していました。 これは、作成者が複数のコミットをコミットするための \fBgit svn set\-tree A\&.\&.B\fR 表記ではなく、単一のヘッドをコミットするために \fBgit svn set\-tree B\fR を好んだためです。 「git pull」または「git merge」を、 \fBgit svn set\-tree A\&.\&.B\fR と一緒に使用すると、SVNにコミットするときに非線形履歴がフラット化され、これにより、マージコミットがSVNの以前のコミットを予期せず逆転させる可能性があります。
.SH "MERGE TRACKING"
.sp
\fBgit svn\fR は、標準レイアウト(standard layout)を採用しているリポジトリのコピー履歴(ブランチとタグを含む)を追跡できますが、git内でSVNユーザーに戻って発生したマージ履歴を表すことはできません。 したがって、SVNとの互換性を容易にするために、ユーザーはGit内で履歴を可能な限り線形に保つことをお勧めします(下記「CAVEATS」セクション参照)。
.SH "HANDLING OF SVN BRANCHES"
.sp
\fBgit svn\fR がブランチをフェッチするように構成されている場合(そして \fB\-\-follow\-branches\fR が有効な場合）、1つのSVNブランチに対して複数のGitブランチが作成されることがあり、追加のブランチの名前は \fBbranchname@nnn\fR(nnn はSVNリビジョン番号)形式になります。 これらの追加のブランチは、 \fBgit svn\fR がSVNブランチの最初のコミットの親コミットを見つけられない場合に作成され、ブランチを他のブランチの履歴に接続します。
.sp
通常、SVNブランチの最初のコミットはコピー操作で構成されます。 「git svn」はこのコミットを読み取り、ブランチが作成されたSVNリビジョンを取得します。次に、このSVNリビジョンに対応するGitコミットを見つけようとし、それをブランチの親として使用します。ただし、親として機能する適切なGitコミットがない可能性があります。 これは、他の理由の中でも特に、SVNブランチが「git svn」によってフェッチされなかったリビジョンのコピーである場合(たとえば、 `\-\-revision`でスキップされた古いリビジョンであるため)、またはSVNで「git svn」によって追跡されないディレクトリがコピーされた場合(まったく追跡されていないブランチ、または追跡されたブランチのサブディレクトリなど)に発生します。 このような場合、「git svn」は引き続きGitブランチを作成しますが、ブランチの親として既存のGitコミットを使用する代わりに、ブランチのコピー元のディレクトリのSVN履歴を読み取り、適切なGitコミットを作成します。これは、 "Initializing parent: <branchname>" というメッセージで示されます。
.sp
さらに、 \fB<branchname>@<SVN\-Revision>\fR という名前の特別なブランチを作成します。ここで、<SVN\-Revision> は、ブランチのコピー元のSVNリビジョン番号です。 このブランチは、ブランチの新しく作成された親コミットを指します。 SVNでブランチが削除され、後で別のバージョンから再作成された場合、 \fB@\fR が付いたこのようなブランチが複数存在します。
.sp
これは、単一のSVNリビジョンに対して複数のGitコミットが作成されることを意味する場合があることに注意してください。
.sp
例: 標準の トランク/タグ/ブランチ レイアウトのSVNリポジトリでは、ディレクトリ \fBtrunk/sub\fR が \fBr\&.100\fR に作成されます。 \fBr\&.200\fR では、 \fBtrunk/sub\fR は \fBbranchs/\fR にコピーすることで分岐します。 \fBgit svn clone \-s`は、ブランチ `sub\fR を作成します。 また、 \fBr\&.100\fR から \fBr\&.199\fR までの新しいGitコミットを作成し、これらをブランチ \fBsub\fR の履歴として使用します。 したがって、 \fBr\&.100\fR から \fBr\&.199\fR までのリビジョンごとに2つのGitコミットがあります(1つは \fBtrunk/\fR を含み、もう1つは \fBtrunk/sub/\fR を含みます)。 最後に、ブランチ \fBsub\fR の新しい親コミットを指すブランチ \fBsub@200\fR を作成します(つまり、 \fBr\&.200\fR および \fBtrunk/sub/\fR のコミット)。
.SH "CAVEATS"
.sp
単純化とSubversionとの相互運用のために、すべての「git svn」ユーザーがSVNサーバーから直接クローンを作成し、フェッチしてdcommitし、Gitリポジトリとブランチ間で、すべての 「git clone」/「pull」/「merge」/「push」 操作を回避することをお勧めします。Gitブランチとユーザーの間でコードを交換するための推奨される方法は、「git format\-patch」と「git am」、または単に「SVNリポジトリへのdcommit」です。
.sp
「dcommit」を計画しているブランチで「git merge」または「git pull」を実行することはお勧めしません。Subversionユーザーはあなたが行ったマージを見ることができないからです。 さらに、SVNブランチのミラーであるGitブランチからマージまたはプルすると、「dcommit」が間違ったブランチにコミットする可能性があります。
.sp
マージする場合は、以下のルールに注意してください: \fBgit svn dcommit\fR は、以下で指定されたSVNコミット上でコミットを試みます
.sp
.if n \{\
.RS 4
.\}
.nf
git log \-\-grep=^git\-svn\-id: \-\-first\-parent \-1
.fi
.if n \{\
.RE
.\}
.sp
.sp
したがって、dcommitするブランチの最新のコミットがマージの「最初の」親であることを確認する「必要」があります。 特に最初の親が同じSVNブランチの古いコミットである場合は、混沌(chaos)になります。
.sp
\fBgit clone\fR は \fBrefs/remotes/\fR 階層下のブランチや \fBgit svn\fR のメタデータや設定をクローンしません。 そのため、\fBgit svn\fR を使って作成・管理されたリポジトリのクローンを作成する場合は \fBrsync\fR を使用する必要があります。
.sp
\fBcommit\fR は内部でリベースを使用しているので、 \fBdcommit\fR の前に \fBgit push\fR した Git ブランチは、リモートリポジトリの既存の ref を強制的に上書きする必要があります。 詳細は \fBgit-push\fR(1) ドキュメントを参照ください。
.sp
すでにコミットした変更に、 \fBgit-commit\fR(1) の \fB\-\-amend\fR オプションを使用しないでください。 他のユーザーのためのリモートリポジトリにすでにプッシュしたコミットを修正することは悪い習慣と考えられており、SVNを使用したdcommitはそれに類似しています。
.sp
SVNリポジトリのクローンを作成するときに、リポジトリレイアウトを記述するためのオプション(\fB\-\-trunk\fR, \fB\-\-tags\fR, \fB\-\-branches\fR, \fB\-\-stdlayout\fR)が使用されてい無い場合、 \fBgit svn clone\fR は完全に線形の履歴を持つGitリポジトリを作成します 、ブランチとタグは作業コピーで別々のディレクトリとして表示されます。 これは完全なリポジトリのコピーを取得する最も簡単な方法ですが、多くのブランチを持つプロジェクトの場合、トランクだけの何倍ものサイズの作業コピーになります。 したがって、標準のディレクトリ構造(trunk/branchs/tags)を使用するプロジェクトの場合、オプション \fB\-\-stdlayout\fR を使用してクローンを作成することをお勧めします。 プロジェクトが非標準の構造を使用している場合、および/または ブランチとタグが不要な場合は、リポジトリのレイアウトオプションを指定せずに、1つのディレクトリ(通常はトランク)のみを複製するのが最も簡単です。 ブランチとタグを含む完全な履歴が必要な場合は、オプション \fB\-\-trunk\fR/\fB\-\-branches\fR/\fB\-\-tags\fR を使用する必要があります。
.sp
複数の \fB\-\-branches\fR または \fB\-\-tags\fR を使用する場合、「git svn」は名前の衝突を自動的に処理しません(たとえば、異なるパスからの2つのブランチが同じ名前である場合、またはブランチとタグが同じ名前である場合)。 このような場合は、「init」を使用してGitリポジトリを設定し、最初の「フェッチ」の前に、ブランチとタグが異なる名前空間に関連付けられるように $GIT_DIR/config ファイルを編集します。 例えば:
.sp
.if n \{\
.RS 4
.\}
.nf
branches = stable/*:refs/remotes/svn/stable/*
branches = debug/*:refs/remotes/svn/debug/*
.fi
.if n \{\
.RE
.\}
.SH "CONFIGURATION"
.sp
「git svn」は、 [svn\-remote] 構成情報をリポジトリ $GIT_DIR/config ファイルに保存します。 \fBfetch\fR キーがglob引数を受け入れないことを除いて、コアGitの [remote] セクションに似ています。 ただし、代わりに \fBbranches\fR キーと \fBtags\fR キーによって処理されます。 一部のSVNリポジトリは、複数のプロジェクトで奇妙に構成されているため、以下にリストされているようなグロブ拡張が許可されます:
.sp
.if n \{\
.RS 4
.\}
.nf
[svn\-remote "project\-a"]
        url = http://server\&.org/svn
        fetch = trunk/project\-a:refs/remotes/project\-a/trunk
        branches = branches/*/project\-a:refs/remotes/project\-a/branches/*
        branches = branches/release_*:refs/remotes/project\-a/branches/release_*
        branches = branches/re*se:refs/remotes/project\-a/branches/*
        tags = tags/*/project\-a:refs/remotes/project\-a/tags/*
.fi
.if n \{\
.RE
.\}
.sp
.sp
(\fB:\fR の右側の)ローカル参照の \fB*\fR(アスタリスク)ワイルドカードは、 最も右のパスコンポーネントである必要があることに注意してください。 ただし、リモートのワイルドカードは、独立したパスコンポーネント (\fB/\fR または EOLで囲まれている)である限り、どこにあってもかまいません。 このタイプの構成は、 \fBinit\fR によって自動的に作成されるわけではないため、 テキストエディターまたは \fBgit config\fR を使用して手動で入力する必要があります。
.sp
また、単語ごとに1つのアスタリスク(\fB*\fR)のみが許可されていることに注意してください。 例えば:
.sp
.if n \{\
.RS 4
.\}
.nf
branches = branches/re*se:refs/remotes/project\-a/branches/*
.fi
.if n \{\
.RE
.\}
.sp
ただし、これは、ブランチ \fBrelease\fR 、\fBrese\fR 、\fBre123se\fR とマッチします
.sp
.if n \{\
.RS 4
.\}
.nf
branches = branches/re*s*e:refs/remotes/project\-a/branches/*
.fi
.if n \{\
.RE
.\}
.sp
これはエラーを発生させます。
.sp
中括弧(\fB{\fR , \fB}\fR)内の名前のコンマ(\fB,\fR)区切りリストを使用して、ブランチまたはタグのサブセットをフェッチすることもできます。 例えば:
.sp
.if n \{\
.RS 4
.\}
.nf
[svn\-remote "huge\-project"]
        url = http://server\&.org/svn
        fetch = trunk/src:refs/remotes/trunk
        branches = branches/{red,green}/src:refs/remotes/project\-a/branches/*
        tags = tags/{1\&.0,2\&.0}/src:refs/remotes/project\-a/tags/*
.fi
.if n \{\
.RE
.\}
.sp
.sp
複数フェッチとブランチとタグキーがサポートされています:
.sp
.if n \{\
.RS 4
.\}
.nf
[svn\-remote "messy\-repo"]
        url = http://server\&.org/svn
        fetch = trunk/project\-a:refs/remotes/project\-a/trunk
        fetch = branches/demos/june\-project\-a\-demo:refs/remotes/project\-a/demos/june\-demo
        branches = branches/server/*:refs/remotes/project\-a/branches/*
        branches = branches/demos/2011/*:refs/remotes/project\-a/2011\-demos/*
        tags = tags/server/*:refs/remotes/project\-a/tags/*
.fi
.if n \{\
.RE
.\}
.sp
.sp
このような構成でブランチを作成するには、 \fB\-d\fR または \fB\-\-destination\fR フラグを使用して使用する場所を明確にする必要があります:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git svn branch \-d branches/server release\-2\-3\-0
.fi
.if n \{\
.RE
.\}
.sp
.sp
git\-svnは、ブランチまたはタグが出現した最高のリビジョン(highest revision)を追跡することに注意してください。 フェッチ後にブランチまたはタグのサブセットが変更された場合は、 \fB$GIT_DIR/svn/\&.metadata\fR を手動で編集して、必要に応じて branches\-maxRev および/または tags\-maxRev を削除(またはリセット)する必要があります。
.SH "FILES"
.PP
$GIT_DIR/svn/**/\&.rev_map\&.*
.RS 4
Subversionリビジョン番号とGitコミット名の間のマッピング。 noMetadataオプションが設定されていないリポジトリでは、これはすべてのコミットの最後にある
\fBgit\-svn\-id:\fR
行から再構築できます(詳細については、上記「svn\&.noMetadata」セクションを参照してください)。
.sp
\fBgit svn fetch\fR
および
\fBgit svn rebase\fR
は、rev_mapが欠落しているか最新でない場合、自動的に更新します。
\fBgit svn reset\fR
は自動的にそれを巻き戻します。
.RE
.SH "BUGS"
.sp
svn:executable を除くすべてのSVNプロパティを無視します。 未処理のプロパティはすべて \fB$GIT_DIR/svn/<refname>/unhandled\&.log\fR に記録されます
.sp
名前変更とコピーされたディレクトリはGitによって検出されないため、SVNにコミットするときに追跡されません。 考えられるすべてのレアケース(corner cases)に対応する作業を行うのは非常に困難で時間がかかるため、これに対するサポートを追加する予定はありません(Gitもサポートしていません)。 名前変更とコピーされたファイルのコミットは、Gitがそれらを検出するのに十分類似している場合、完全にサポートされます。
.sp
SVNでは、(推奨されていませんが)タグへの変更をコミットすることが可能です(タグは単なるディレクトリコピーであり、技術的にはブランチと同じであるため)。 SVNリポジトリのクローンを作成する場合、「git svn」は、タグへのそのようなコミットが将来発生するかどうかを知ることができません。 したがって、保守的な動作を行い、すべてのSVNタグをブランチとしてインポートし、タグ名の前に \fBtags/\fR 接頭辞を付けます。
.SH "SEE ALSO"
.sp
\fBgit-rebase\fR(1)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
git-filter-repo
.RS 4
\%https://github.com/newren/git-filter-repo
.RE
